// This file is auto-generated, don't edit it. Thanks.

#ifndef ALIBABACLOUD_CLOUDAPI20160714_H_
#define ALIBABACLOUD_CLOUDAPI20160714_H_

#include <alibabacloud/open_api.hpp>
#include <boost/any.hpp>
#include <boost/throw_exception.hpp>
#include <darabonba/core.hpp>
#include <darabonba/util.hpp>
#include <iostream>
#include <map>
#include <vector>

using namespace std;

namespace Alibabacloud_CloudAPI20160714 {
class AbolishApiRequest : public Darabonba::Model {
public:
  shared_ptr<string> apiId{};
  shared_ptr<string> groupId{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> stageName{};

  AbolishApiRequest() {}

  explicit AbolishApiRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiId) {
      res["ApiId"] = boost::any(*apiId);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (stageName) {
      res["StageName"] = boost::any(*stageName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiId") != m.end() && !m["ApiId"].empty()) {
      apiId = make_shared<string>(boost::any_cast<string>(m["ApiId"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("StageName") != m.end() && !m["StageName"].empty()) {
      stageName = make_shared<string>(boost::any_cast<string>(m["StageName"]));
    }
  }


  virtual ~AbolishApiRequest() = default;
};
class AbolishApiResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  AbolishApiResponseBody() {}

  explicit AbolishApiResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AbolishApiResponseBody() = default;
};
class AbolishApiResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<AbolishApiResponseBody> body{};

  AbolishApiResponse() {}

  explicit AbolishApiResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AbolishApiResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AbolishApiResponseBody>(model1);
      }
    }
  }


  virtual ~AbolishApiResponse() = default;
};
class AddIpControlPolicyItemRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> cidrIp{};
  shared_ptr<string> ipControlId{};
  shared_ptr<string> securityToken{};

  AddIpControlPolicyItemRequest() {}

  explicit AddIpControlPolicyItemRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (cidrIp) {
      res["CidrIp"] = boost::any(*cidrIp);
    }
    if (ipControlId) {
      res["IpControlId"] = boost::any(*ipControlId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("CidrIp") != m.end() && !m["CidrIp"].empty()) {
      cidrIp = make_shared<string>(boost::any_cast<string>(m["CidrIp"]));
    }
    if (m.find("IpControlId") != m.end() && !m["IpControlId"].empty()) {
      ipControlId = make_shared<string>(boost::any_cast<string>(m["IpControlId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~AddIpControlPolicyItemRequest() = default;
};
class AddIpControlPolicyItemResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> policyItemId{};
  shared_ptr<string> requestId{};

  AddIpControlPolicyItemResponseBody() {}

  explicit AddIpControlPolicyItemResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (policyItemId) {
      res["PolicyItemId"] = boost::any(*policyItemId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PolicyItemId") != m.end() && !m["PolicyItemId"].empty()) {
      policyItemId = make_shared<string>(boost::any_cast<string>(m["PolicyItemId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AddIpControlPolicyItemResponseBody() = default;
};
class AddIpControlPolicyItemResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<AddIpControlPolicyItemResponseBody> body{};

  AddIpControlPolicyItemResponse() {}

  explicit AddIpControlPolicyItemResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddIpControlPolicyItemResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddIpControlPolicyItemResponseBody>(model1);
      }
    }
  }


  virtual ~AddIpControlPolicyItemResponse() = default;
};
class AddTrafficSpecialControlRequest : public Darabonba::Model {
public:
  shared_ptr<string> securityToken{};
  shared_ptr<string> specialKey{};
  shared_ptr<string> specialType{};
  shared_ptr<string> trafficControlId{};
  shared_ptr<long> trafficValue{};

  AddTrafficSpecialControlRequest() {}

  explicit AddTrafficSpecialControlRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (specialKey) {
      res["SpecialKey"] = boost::any(*specialKey);
    }
    if (specialType) {
      res["SpecialType"] = boost::any(*specialType);
    }
    if (trafficControlId) {
      res["TrafficControlId"] = boost::any(*trafficControlId);
    }
    if (trafficValue) {
      res["TrafficValue"] = boost::any(*trafficValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("SpecialKey") != m.end() && !m["SpecialKey"].empty()) {
      specialKey = make_shared<string>(boost::any_cast<string>(m["SpecialKey"]));
    }
    if (m.find("SpecialType") != m.end() && !m["SpecialType"].empty()) {
      specialType = make_shared<string>(boost::any_cast<string>(m["SpecialType"]));
    }
    if (m.find("TrafficControlId") != m.end() && !m["TrafficControlId"].empty()) {
      trafficControlId = make_shared<string>(boost::any_cast<string>(m["TrafficControlId"]));
    }
    if (m.find("TrafficValue") != m.end() && !m["TrafficValue"].empty()) {
      trafficValue = make_shared<long>(boost::any_cast<long>(m["TrafficValue"]));
    }
  }


  virtual ~AddTrafficSpecialControlRequest() = default;
};
class AddTrafficSpecialControlResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  AddTrafficSpecialControlResponseBody() {}

  explicit AddTrafficSpecialControlResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AddTrafficSpecialControlResponseBody() = default;
};
class AddTrafficSpecialControlResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<AddTrafficSpecialControlResponseBody> body{};

  AddTrafficSpecialControlResponse() {}

  explicit AddTrafficSpecialControlResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddTrafficSpecialControlResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddTrafficSpecialControlResponseBody>(model1);
      }
    }
  }


  virtual ~AddTrafficSpecialControlResponse() = default;
};
class AttachPluginRequest : public Darabonba::Model {
public:
  shared_ptr<string> apiId{};
  shared_ptr<string> apiIds{};
  shared_ptr<string> groupId{};
  shared_ptr<string> pluginId{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> stageName{};

  AttachPluginRequest() {}

  explicit AttachPluginRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiId) {
      res["ApiId"] = boost::any(*apiId);
    }
    if (apiIds) {
      res["ApiIds"] = boost::any(*apiIds);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (pluginId) {
      res["PluginId"] = boost::any(*pluginId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (stageName) {
      res["StageName"] = boost::any(*stageName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiId") != m.end() && !m["ApiId"].empty()) {
      apiId = make_shared<string>(boost::any_cast<string>(m["ApiId"]));
    }
    if (m.find("ApiIds") != m.end() && !m["ApiIds"].empty()) {
      apiIds = make_shared<string>(boost::any_cast<string>(m["ApiIds"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("PluginId") != m.end() && !m["PluginId"].empty()) {
      pluginId = make_shared<string>(boost::any_cast<string>(m["PluginId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("StageName") != m.end() && !m["StageName"].empty()) {
      stageName = make_shared<string>(boost::any_cast<string>(m["StageName"]));
    }
  }


  virtual ~AttachPluginRequest() = default;
};
class AttachPluginResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  AttachPluginResponseBody() {}

  explicit AttachPluginResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AttachPluginResponseBody() = default;
};
class AttachPluginResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<AttachPluginResponseBody> body{};

  AttachPluginResponse() {}

  explicit AttachPluginResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AttachPluginResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AttachPluginResponseBody>(model1);
      }
    }
  }


  virtual ~AttachPluginResponse() = default;
};
class BatchAbolishApisRequestApi : public Darabonba::Model {
public:
  shared_ptr<string> apiUid{};
  shared_ptr<string> groupId{};
  shared_ptr<string> stageId{};

  BatchAbolishApisRequestApi() {}

  explicit BatchAbolishApisRequestApi(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiUid) {
      res["ApiUid"] = boost::any(*apiUid);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (stageId) {
      res["StageId"] = boost::any(*stageId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiUid") != m.end() && !m["ApiUid"].empty()) {
      apiUid = make_shared<string>(boost::any_cast<string>(m["ApiUid"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("StageId") != m.end() && !m["StageId"].empty()) {
      stageId = make_shared<string>(boost::any_cast<string>(m["StageId"]));
    }
  }


  virtual ~BatchAbolishApisRequestApi() = default;
};
class BatchAbolishApisRequest : public Darabonba::Model {
public:
  shared_ptr<vector<BatchAbolishApisRequestApi>> api{};
  shared_ptr<string> securityToken{};

  BatchAbolishApisRequest() {}

  explicit BatchAbolishApisRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (api) {
      vector<boost::any> temp1;
      for(auto item1:*api){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Api"] = boost::any(temp1);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Api") != m.end() && !m["Api"].empty()) {
      if (typeid(vector<boost::any>) == m["Api"].type()) {
        vector<BatchAbolishApisRequestApi> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Api"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            BatchAbolishApisRequestApi model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        api = make_shared<vector<BatchAbolishApisRequestApi>>(expect1);
      }
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~BatchAbolishApisRequest() = default;
};
class BatchAbolishApisResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> operationId{};
  shared_ptr<string> requestId{};

  BatchAbolishApisResponseBody() {}

  explicit BatchAbolishApisResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (operationId) {
      res["OperationId"] = boost::any(*operationId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OperationId") != m.end() && !m["OperationId"].empty()) {
      operationId = make_shared<string>(boost::any_cast<string>(m["OperationId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~BatchAbolishApisResponseBody() = default;
};
class BatchAbolishApisResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<BatchAbolishApisResponseBody> body{};

  BatchAbolishApisResponse() {}

  explicit BatchAbolishApisResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        BatchAbolishApisResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<BatchAbolishApisResponseBody>(model1);
      }
    }
  }


  virtual ~BatchAbolishApisResponse() = default;
};
class BatchDeployApisRequestApi : public Darabonba::Model {
public:
  shared_ptr<string> apiUid{};
  shared_ptr<string> groupId{};

  BatchDeployApisRequestApi() {}

  explicit BatchDeployApisRequestApi(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiUid) {
      res["ApiUid"] = boost::any(*apiUid);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiUid") != m.end() && !m["ApiUid"].empty()) {
      apiUid = make_shared<string>(boost::any_cast<string>(m["ApiUid"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
  }


  virtual ~BatchDeployApisRequestApi() = default;
};
class BatchDeployApisRequest : public Darabonba::Model {
public:
  shared_ptr<vector<BatchDeployApisRequestApi>> api{};
  shared_ptr<string> description{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> stageName{};

  BatchDeployApisRequest() {}

  explicit BatchDeployApisRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (api) {
      vector<boost::any> temp1;
      for(auto item1:*api){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Api"] = boost::any(temp1);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (stageName) {
      res["StageName"] = boost::any(*stageName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Api") != m.end() && !m["Api"].empty()) {
      if (typeid(vector<boost::any>) == m["Api"].type()) {
        vector<BatchDeployApisRequestApi> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Api"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            BatchDeployApisRequestApi model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        api = make_shared<vector<BatchDeployApisRequestApi>>(expect1);
      }
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("StageName") != m.end() && !m["StageName"].empty()) {
      stageName = make_shared<string>(boost::any_cast<string>(m["StageName"]));
    }
  }


  virtual ~BatchDeployApisRequest() = default;
};
class BatchDeployApisResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> operationId{};
  shared_ptr<string> requestId{};

  BatchDeployApisResponseBody() {}

  explicit BatchDeployApisResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (operationId) {
      res["OperationId"] = boost::any(*operationId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OperationId") != m.end() && !m["OperationId"].empty()) {
      operationId = make_shared<string>(boost::any_cast<string>(m["OperationId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~BatchDeployApisResponseBody() = default;
};
class BatchDeployApisResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<BatchDeployApisResponseBody> body{};

  BatchDeployApisResponse() {}

  explicit BatchDeployApisResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        BatchDeployApisResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<BatchDeployApisResponseBody>(model1);
      }
    }
  }


  virtual ~BatchDeployApisResponse() = default;
};
class CreateApiRequest : public Darabonba::Model {
public:
  shared_ptr<string> allowSignatureMethod{};
  shared_ptr<string> apiName{};
  shared_ptr<string> appCodeAuthType{};
  shared_ptr<string> authType{};
  shared_ptr<string> constantParameters{};
  shared_ptr<string> description{};
  shared_ptr<bool> disableInternet{};
  shared_ptr<string> errorCodeSamples{};
  shared_ptr<string> failResultSample{};
  shared_ptr<bool> forceNonceCheck{};
  shared_ptr<string> groupId{};
  shared_ptr<string> openIdConnectConfig{};
  shared_ptr<string> requestConfig{};
  shared_ptr<string> requestParameters{};
  shared_ptr<string> resultBodyModel{};
  shared_ptr<string> resultDescriptions{};
  shared_ptr<string> resultSample{};
  shared_ptr<string> resultType{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> serviceConfig{};
  shared_ptr<string> serviceParameters{};
  shared_ptr<string> serviceParametersMap{};
  shared_ptr<string> systemParameters{};
  shared_ptr<string> visibility{};
  shared_ptr<string> webSocketApiType{};

  CreateApiRequest() {}

  explicit CreateApiRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (allowSignatureMethod) {
      res["AllowSignatureMethod"] = boost::any(*allowSignatureMethod);
    }
    if (apiName) {
      res["ApiName"] = boost::any(*apiName);
    }
    if (appCodeAuthType) {
      res["AppCodeAuthType"] = boost::any(*appCodeAuthType);
    }
    if (authType) {
      res["AuthType"] = boost::any(*authType);
    }
    if (constantParameters) {
      res["ConstantParameters"] = boost::any(*constantParameters);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (disableInternet) {
      res["DisableInternet"] = boost::any(*disableInternet);
    }
    if (errorCodeSamples) {
      res["ErrorCodeSamples"] = boost::any(*errorCodeSamples);
    }
    if (failResultSample) {
      res["FailResultSample"] = boost::any(*failResultSample);
    }
    if (forceNonceCheck) {
      res["ForceNonceCheck"] = boost::any(*forceNonceCheck);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (openIdConnectConfig) {
      res["OpenIdConnectConfig"] = boost::any(*openIdConnectConfig);
    }
    if (requestConfig) {
      res["RequestConfig"] = boost::any(*requestConfig);
    }
    if (requestParameters) {
      res["RequestParameters"] = boost::any(*requestParameters);
    }
    if (resultBodyModel) {
      res["ResultBodyModel"] = boost::any(*resultBodyModel);
    }
    if (resultDescriptions) {
      res["ResultDescriptions"] = boost::any(*resultDescriptions);
    }
    if (resultSample) {
      res["ResultSample"] = boost::any(*resultSample);
    }
    if (resultType) {
      res["ResultType"] = boost::any(*resultType);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (serviceConfig) {
      res["ServiceConfig"] = boost::any(*serviceConfig);
    }
    if (serviceParameters) {
      res["ServiceParameters"] = boost::any(*serviceParameters);
    }
    if (serviceParametersMap) {
      res["ServiceParametersMap"] = boost::any(*serviceParametersMap);
    }
    if (systemParameters) {
      res["SystemParameters"] = boost::any(*systemParameters);
    }
    if (visibility) {
      res["Visibility"] = boost::any(*visibility);
    }
    if (webSocketApiType) {
      res["WebSocketApiType"] = boost::any(*webSocketApiType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AllowSignatureMethod") != m.end() && !m["AllowSignatureMethod"].empty()) {
      allowSignatureMethod = make_shared<string>(boost::any_cast<string>(m["AllowSignatureMethod"]));
    }
    if (m.find("ApiName") != m.end() && !m["ApiName"].empty()) {
      apiName = make_shared<string>(boost::any_cast<string>(m["ApiName"]));
    }
    if (m.find("AppCodeAuthType") != m.end() && !m["AppCodeAuthType"].empty()) {
      appCodeAuthType = make_shared<string>(boost::any_cast<string>(m["AppCodeAuthType"]));
    }
    if (m.find("AuthType") != m.end() && !m["AuthType"].empty()) {
      authType = make_shared<string>(boost::any_cast<string>(m["AuthType"]));
    }
    if (m.find("ConstantParameters") != m.end() && !m["ConstantParameters"].empty()) {
      constantParameters = make_shared<string>(boost::any_cast<string>(m["ConstantParameters"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DisableInternet") != m.end() && !m["DisableInternet"].empty()) {
      disableInternet = make_shared<bool>(boost::any_cast<bool>(m["DisableInternet"]));
    }
    if (m.find("ErrorCodeSamples") != m.end() && !m["ErrorCodeSamples"].empty()) {
      errorCodeSamples = make_shared<string>(boost::any_cast<string>(m["ErrorCodeSamples"]));
    }
    if (m.find("FailResultSample") != m.end() && !m["FailResultSample"].empty()) {
      failResultSample = make_shared<string>(boost::any_cast<string>(m["FailResultSample"]));
    }
    if (m.find("ForceNonceCheck") != m.end() && !m["ForceNonceCheck"].empty()) {
      forceNonceCheck = make_shared<bool>(boost::any_cast<bool>(m["ForceNonceCheck"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("OpenIdConnectConfig") != m.end() && !m["OpenIdConnectConfig"].empty()) {
      openIdConnectConfig = make_shared<string>(boost::any_cast<string>(m["OpenIdConnectConfig"]));
    }
    if (m.find("RequestConfig") != m.end() && !m["RequestConfig"].empty()) {
      requestConfig = make_shared<string>(boost::any_cast<string>(m["RequestConfig"]));
    }
    if (m.find("RequestParameters") != m.end() && !m["RequestParameters"].empty()) {
      requestParameters = make_shared<string>(boost::any_cast<string>(m["RequestParameters"]));
    }
    if (m.find("ResultBodyModel") != m.end() && !m["ResultBodyModel"].empty()) {
      resultBodyModel = make_shared<string>(boost::any_cast<string>(m["ResultBodyModel"]));
    }
    if (m.find("ResultDescriptions") != m.end() && !m["ResultDescriptions"].empty()) {
      resultDescriptions = make_shared<string>(boost::any_cast<string>(m["ResultDescriptions"]));
    }
    if (m.find("ResultSample") != m.end() && !m["ResultSample"].empty()) {
      resultSample = make_shared<string>(boost::any_cast<string>(m["ResultSample"]));
    }
    if (m.find("ResultType") != m.end() && !m["ResultType"].empty()) {
      resultType = make_shared<string>(boost::any_cast<string>(m["ResultType"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("ServiceConfig") != m.end() && !m["ServiceConfig"].empty()) {
      serviceConfig = make_shared<string>(boost::any_cast<string>(m["ServiceConfig"]));
    }
    if (m.find("ServiceParameters") != m.end() && !m["ServiceParameters"].empty()) {
      serviceParameters = make_shared<string>(boost::any_cast<string>(m["ServiceParameters"]));
    }
    if (m.find("ServiceParametersMap") != m.end() && !m["ServiceParametersMap"].empty()) {
      serviceParametersMap = make_shared<string>(boost::any_cast<string>(m["ServiceParametersMap"]));
    }
    if (m.find("SystemParameters") != m.end() && !m["SystemParameters"].empty()) {
      systemParameters = make_shared<string>(boost::any_cast<string>(m["SystemParameters"]));
    }
    if (m.find("Visibility") != m.end() && !m["Visibility"].empty()) {
      visibility = make_shared<string>(boost::any_cast<string>(m["Visibility"]));
    }
    if (m.find("WebSocketApiType") != m.end() && !m["WebSocketApiType"].empty()) {
      webSocketApiType = make_shared<string>(boost::any_cast<string>(m["WebSocketApiType"]));
    }
  }


  virtual ~CreateApiRequest() = default;
};
class CreateApiResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> apiId{};
  shared_ptr<string> requestId{};

  CreateApiResponseBody() {}

  explicit CreateApiResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiId) {
      res["ApiId"] = boost::any(*apiId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiId") != m.end() && !m["ApiId"].empty()) {
      apiId = make_shared<string>(boost::any_cast<string>(m["ApiId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateApiResponseBody() = default;
};
class CreateApiResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CreateApiResponseBody> body{};

  CreateApiResponse() {}

  explicit CreateApiResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateApiResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateApiResponseBody>(model1);
      }
    }
  }


  virtual ~CreateApiResponse() = default;
};
class CreateApiGroupRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  CreateApiGroupRequestTag() {}

  explicit CreateApiGroupRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~CreateApiGroupRequestTag() = default;
};
class CreateApiGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> basePath{};
  shared_ptr<string> description{};
  shared_ptr<string> groupName{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> securityToken{};
  shared_ptr<vector<CreateApiGroupRequestTag>> tag{};

  CreateApiGroupRequest() {}

  explicit CreateApiGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (basePath) {
      res["BasePath"] = boost::any(*basePath);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BasePath") != m.end() && !m["BasePath"].empty()) {
      basePath = make_shared<string>(boost::any_cast<string>(m["BasePath"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<CreateApiGroupRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateApiGroupRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<CreateApiGroupRequestTag>>(expect1);
      }
    }
  }


  virtual ~CreateApiGroupRequest() = default;
};
class CreateApiGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> basePath{};
  shared_ptr<string> description{};
  shared_ptr<string> groupId{};
  shared_ptr<string> groupName{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> instanceType{};
  shared_ptr<string> requestId{};
  shared_ptr<string> subDomain{};
  shared_ptr<bool> tagStatus{};

  CreateApiGroupResponseBody() {}

  explicit CreateApiGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (basePath) {
      res["BasePath"] = boost::any(*basePath);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (subDomain) {
      res["SubDomain"] = boost::any(*subDomain);
    }
    if (tagStatus) {
      res["TagStatus"] = boost::any(*tagStatus);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BasePath") != m.end() && !m["BasePath"].empty()) {
      basePath = make_shared<string>(boost::any_cast<string>(m["BasePath"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SubDomain") != m.end() && !m["SubDomain"].empty()) {
      subDomain = make_shared<string>(boost::any_cast<string>(m["SubDomain"]));
    }
    if (m.find("TagStatus") != m.end() && !m["TagStatus"].empty()) {
      tagStatus = make_shared<bool>(boost::any_cast<bool>(m["TagStatus"]));
    }
  }


  virtual ~CreateApiGroupResponseBody() = default;
};
class CreateApiGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CreateApiGroupResponseBody> body{};

  CreateApiGroupResponse() {}

  explicit CreateApiGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateApiGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateApiGroupResponseBody>(model1);
      }
    }
  }


  virtual ~CreateApiGroupResponse() = default;
};
class CreateApiStageVariableRequest : public Darabonba::Model {
public:
  shared_ptr<string> groupId{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> stageId{};
  shared_ptr<string> stageRouteModel{};
  shared_ptr<bool> supportRoute{};
  shared_ptr<string> variableName{};
  shared_ptr<string> variableValue{};

  CreateApiStageVariableRequest() {}

  explicit CreateApiStageVariableRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (stageId) {
      res["StageId"] = boost::any(*stageId);
    }
    if (stageRouteModel) {
      res["StageRouteModel"] = boost::any(*stageRouteModel);
    }
    if (supportRoute) {
      res["SupportRoute"] = boost::any(*supportRoute);
    }
    if (variableName) {
      res["VariableName"] = boost::any(*variableName);
    }
    if (variableValue) {
      res["VariableValue"] = boost::any(*variableValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("StageId") != m.end() && !m["StageId"].empty()) {
      stageId = make_shared<string>(boost::any_cast<string>(m["StageId"]));
    }
    if (m.find("StageRouteModel") != m.end() && !m["StageRouteModel"].empty()) {
      stageRouteModel = make_shared<string>(boost::any_cast<string>(m["StageRouteModel"]));
    }
    if (m.find("SupportRoute") != m.end() && !m["SupportRoute"].empty()) {
      supportRoute = make_shared<bool>(boost::any_cast<bool>(m["SupportRoute"]));
    }
    if (m.find("VariableName") != m.end() && !m["VariableName"].empty()) {
      variableName = make_shared<string>(boost::any_cast<string>(m["VariableName"]));
    }
    if (m.find("VariableValue") != m.end() && !m["VariableValue"].empty()) {
      variableValue = make_shared<string>(boost::any_cast<string>(m["VariableValue"]));
    }
  }


  virtual ~CreateApiStageVariableRequest() = default;
};
class CreateApiStageVariableResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  CreateApiStageVariableResponseBody() {}

  explicit CreateApiStageVariableResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateApiStageVariableResponseBody() = default;
};
class CreateApiStageVariableResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CreateApiStageVariableResponseBody> body{};

  CreateApiStageVariableResponse() {}

  explicit CreateApiStageVariableResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateApiStageVariableResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateApiStageVariableResponseBody>(model1);
      }
    }
  }


  virtual ~CreateApiStageVariableResponse() = default;
};
class CreateAppRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  CreateAppRequestTag() {}

  explicit CreateAppRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~CreateAppRequestTag() = default;
};
class CreateAppRequest : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<string> description{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> source{};
  shared_ptr<vector<CreateAppRequestTag>> tag{};

  CreateAppRequest() {}

  explicit CreateAppRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (source) {
      res["Source"] = boost::any(*source);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("Source") != m.end() && !m["Source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["Source"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<CreateAppRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateAppRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<CreateAppRequestTag>>(expect1);
      }
    }
  }


  virtual ~CreateAppRequest() = default;
};
class CreateAppResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> appId{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> tagStatus{};

  CreateAppResponseBody() {}

  explicit CreateAppResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (tagStatus) {
      res["TagStatus"] = boost::any(*tagStatus);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<long>(boost::any_cast<long>(m["AppId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TagStatus") != m.end() && !m["TagStatus"].empty()) {
      tagStatus = make_shared<bool>(boost::any_cast<bool>(m["TagStatus"]));
    }
  }


  virtual ~CreateAppResponseBody() = default;
};
class CreateAppResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CreateAppResponseBody> body{};

  CreateAppResponse() {}

  explicit CreateAppResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateAppResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateAppResponseBody>(model1);
      }
    }
  }


  virtual ~CreateAppResponse() = default;
};
class CreateInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<bool> autoPay{};
  shared_ptr<string> chargeType{};
  shared_ptr<long> duration{};
  shared_ptr<string> httpsPolicy{};
  shared_ptr<string> instanceName{};
  shared_ptr<string> instanceSpec{};
  shared_ptr<string> pricingCycle{};
  shared_ptr<string> token{};
  shared_ptr<string> zoneId{};

  CreateInstanceRequest() {}

  explicit CreateInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (autoPay) {
      res["AutoPay"] = boost::any(*autoPay);
    }
    if (chargeType) {
      res["ChargeType"] = boost::any(*chargeType);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (httpsPolicy) {
      res["HttpsPolicy"] = boost::any(*httpsPolicy);
    }
    if (instanceName) {
      res["InstanceName"] = boost::any(*instanceName);
    }
    if (instanceSpec) {
      res["InstanceSpec"] = boost::any(*instanceSpec);
    }
    if (pricingCycle) {
      res["PricingCycle"] = boost::any(*pricingCycle);
    }
    if (token) {
      res["Token"] = boost::any(*token);
    }
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AutoPay") != m.end() && !m["AutoPay"].empty()) {
      autoPay = make_shared<bool>(boost::any_cast<bool>(m["AutoPay"]));
    }
    if (m.find("ChargeType") != m.end() && !m["ChargeType"].empty()) {
      chargeType = make_shared<string>(boost::any_cast<string>(m["ChargeType"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<long>(boost::any_cast<long>(m["Duration"]));
    }
    if (m.find("HttpsPolicy") != m.end() && !m["HttpsPolicy"].empty()) {
      httpsPolicy = make_shared<string>(boost::any_cast<string>(m["HttpsPolicy"]));
    }
    if (m.find("InstanceName") != m.end() && !m["InstanceName"].empty()) {
      instanceName = make_shared<string>(boost::any_cast<string>(m["InstanceName"]));
    }
    if (m.find("InstanceSpec") != m.end() && !m["InstanceSpec"].empty()) {
      instanceSpec = make_shared<string>(boost::any_cast<string>(m["InstanceSpec"]));
    }
    if (m.find("PricingCycle") != m.end() && !m["PricingCycle"].empty()) {
      pricingCycle = make_shared<string>(boost::any_cast<string>(m["PricingCycle"]));
    }
    if (m.find("Token") != m.end() && !m["Token"].empty()) {
      token = make_shared<string>(boost::any_cast<string>(m["Token"]));
    }
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["ZoneId"]));
    }
  }


  virtual ~CreateInstanceRequest() = default;
};
class CreateInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> requestId{};

  CreateInstanceResponseBody() {}

  explicit CreateInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateInstanceResponseBody() = default;
};
class CreateInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CreateInstanceResponseBody> body{};

  CreateInstanceResponse() {}

  explicit CreateInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~CreateInstanceResponse() = default;
};
class CreateIntranetDomainRequest : public Darabonba::Model {
public:
  shared_ptr<string> groupId{};
  shared_ptr<string> securityToken{};

  CreateIntranetDomainRequest() {}

  explicit CreateIntranetDomainRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~CreateIntranetDomainRequest() = default;
};
class CreateIntranetDomainResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> requestId{};

  CreateIntranetDomainResponseBody() {}

  explicit CreateIntranetDomainResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateIntranetDomainResponseBody() = default;
};
class CreateIntranetDomainResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CreateIntranetDomainResponseBody> body{};

  CreateIntranetDomainResponse() {}

  explicit CreateIntranetDomainResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateIntranetDomainResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateIntranetDomainResponseBody>(model1);
      }
    }
  }


  virtual ~CreateIntranetDomainResponse() = default;
};
class CreateIpControlRequestIpControlPolicys : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> cidrIp{};

  CreateIpControlRequestIpControlPolicys() {}

  explicit CreateIpControlRequestIpControlPolicys(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (cidrIp) {
      res["CidrIp"] = boost::any(*cidrIp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("CidrIp") != m.end() && !m["CidrIp"].empty()) {
      cidrIp = make_shared<string>(boost::any_cast<string>(m["CidrIp"]));
    }
  }


  virtual ~CreateIpControlRequestIpControlPolicys() = default;
};
class CreateIpControlRequest : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> ipControlName{};
  shared_ptr<vector<CreateIpControlRequestIpControlPolicys>> ipControlPolicys{};
  shared_ptr<string> ipControlType{};
  shared_ptr<string> securityToken{};

  CreateIpControlRequest() {}

  explicit CreateIpControlRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (ipControlName) {
      res["IpControlName"] = boost::any(*ipControlName);
    }
    if (ipControlPolicys) {
      vector<boost::any> temp1;
      for(auto item1:*ipControlPolicys){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["IpControlPolicys"] = boost::any(temp1);
    }
    if (ipControlType) {
      res["IpControlType"] = boost::any(*ipControlType);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("IpControlName") != m.end() && !m["IpControlName"].empty()) {
      ipControlName = make_shared<string>(boost::any_cast<string>(m["IpControlName"]));
    }
    if (m.find("IpControlPolicys") != m.end() && !m["IpControlPolicys"].empty()) {
      if (typeid(vector<boost::any>) == m["IpControlPolicys"].type()) {
        vector<CreateIpControlRequestIpControlPolicys> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["IpControlPolicys"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateIpControlRequestIpControlPolicys model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ipControlPolicys = make_shared<vector<CreateIpControlRequestIpControlPolicys>>(expect1);
      }
    }
    if (m.find("IpControlType") != m.end() && !m["IpControlType"].empty()) {
      ipControlType = make_shared<string>(boost::any_cast<string>(m["IpControlType"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~CreateIpControlRequest() = default;
};
class CreateIpControlResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> ipControlId{};
  shared_ptr<string> requestId{};

  CreateIpControlResponseBody() {}

  explicit CreateIpControlResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ipControlId) {
      res["IpControlId"] = boost::any(*ipControlId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IpControlId") != m.end() && !m["IpControlId"].empty()) {
      ipControlId = make_shared<string>(boost::any_cast<string>(m["IpControlId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateIpControlResponseBody() = default;
};
class CreateIpControlResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CreateIpControlResponseBody> body{};

  CreateIpControlResponse() {}

  explicit CreateIpControlResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateIpControlResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateIpControlResponseBody>(model1);
      }
    }
  }


  virtual ~CreateIpControlResponse() = default;
};
class CreateLogConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> logType{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> slsLogStore{};
  shared_ptr<string> slsProject{};

  CreateLogConfigRequest() {}

  explicit CreateLogConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (logType) {
      res["LogType"] = boost::any(*logType);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (slsLogStore) {
      res["SlsLogStore"] = boost::any(*slsLogStore);
    }
    if (slsProject) {
      res["SlsProject"] = boost::any(*slsProject);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LogType") != m.end() && !m["LogType"].empty()) {
      logType = make_shared<string>(boost::any_cast<string>(m["LogType"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("SlsLogStore") != m.end() && !m["SlsLogStore"].empty()) {
      slsLogStore = make_shared<string>(boost::any_cast<string>(m["SlsLogStore"]));
    }
    if (m.find("SlsProject") != m.end() && !m["SlsProject"].empty()) {
      slsProject = make_shared<string>(boost::any_cast<string>(m["SlsProject"]));
    }
  }


  virtual ~CreateLogConfigRequest() = default;
};
class CreateLogConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  CreateLogConfigResponseBody() {}

  explicit CreateLogConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateLogConfigResponseBody() = default;
};
class CreateLogConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CreateLogConfigResponseBody> body{};

  CreateLogConfigResponse() {}

  explicit CreateLogConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateLogConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateLogConfigResponseBody>(model1);
      }
    }
  }


  virtual ~CreateLogConfigResponse() = default;
};
class CreateModelRequest : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> groupId{};
  shared_ptr<string> modelName{};
  shared_ptr<string> schema{};

  CreateModelRequest() {}

  explicit CreateModelRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (modelName) {
      res["ModelName"] = boost::any(*modelName);
    }
    if (schema) {
      res["Schema"] = boost::any(*schema);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("ModelName") != m.end() && !m["ModelName"].empty()) {
      modelName = make_shared<string>(boost::any_cast<string>(m["ModelName"]));
    }
    if (m.find("Schema") != m.end() && !m["Schema"].empty()) {
      schema = make_shared<string>(boost::any_cast<string>(m["Schema"]));
    }
  }


  virtual ~CreateModelRequest() = default;
};
class CreateModelResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> createdTime{};
  shared_ptr<string> description{};
  shared_ptr<string> groupId{};
  shared_ptr<string> modelId{};
  shared_ptr<string> modelName{};
  shared_ptr<string> modelRef{};
  shared_ptr<string> modifiedTime{};
  shared_ptr<string> regionId{};
  shared_ptr<string> requestId{};
  shared_ptr<string> schema{};

  CreateModelResponseBody() {}

  explicit CreateModelResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createdTime) {
      res["CreatedTime"] = boost::any(*createdTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (modelId) {
      res["ModelId"] = boost::any(*modelId);
    }
    if (modelName) {
      res["ModelName"] = boost::any(*modelName);
    }
    if (modelRef) {
      res["ModelRef"] = boost::any(*modelRef);
    }
    if (modifiedTime) {
      res["ModifiedTime"] = boost::any(*modifiedTime);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (schema) {
      res["Schema"] = boost::any(*schema);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreatedTime") != m.end() && !m["CreatedTime"].empty()) {
      createdTime = make_shared<string>(boost::any_cast<string>(m["CreatedTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("ModelId") != m.end() && !m["ModelId"].empty()) {
      modelId = make_shared<string>(boost::any_cast<string>(m["ModelId"]));
    }
    if (m.find("ModelName") != m.end() && !m["ModelName"].empty()) {
      modelName = make_shared<string>(boost::any_cast<string>(m["ModelName"]));
    }
    if (m.find("ModelRef") != m.end() && !m["ModelRef"].empty()) {
      modelRef = make_shared<string>(boost::any_cast<string>(m["ModelRef"]));
    }
    if (m.find("ModifiedTime") != m.end() && !m["ModifiedTime"].empty()) {
      modifiedTime = make_shared<string>(boost::any_cast<string>(m["ModifiedTime"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Schema") != m.end() && !m["Schema"].empty()) {
      schema = make_shared<string>(boost::any_cast<string>(m["Schema"]));
    }
  }


  virtual ~CreateModelResponseBody() = default;
};
class CreateModelResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CreateModelResponseBody> body{};

  CreateModelResponse() {}

  explicit CreateModelResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateModelResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateModelResponseBody>(model1);
      }
    }
  }


  virtual ~CreateModelResponse() = default;
};
class CreateMonitorGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> auth{};
  shared_ptr<string> groupId{};
  shared_ptr<long> rawMonitorGroupId{};
  shared_ptr<string> securityToken{};

  CreateMonitorGroupRequest() {}

  explicit CreateMonitorGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (auth) {
      res["Auth"] = boost::any(*auth);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (rawMonitorGroupId) {
      res["RawMonitorGroupId"] = boost::any(*rawMonitorGroupId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Auth") != m.end() && !m["Auth"].empty()) {
      auth = make_shared<string>(boost::any_cast<string>(m["Auth"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("RawMonitorGroupId") != m.end() && !m["RawMonitorGroupId"].empty()) {
      rawMonitorGroupId = make_shared<long>(boost::any_cast<long>(m["RawMonitorGroupId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~CreateMonitorGroupRequest() = default;
};
class CreateMonitorGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> monitorGroupId{};
  shared_ptr<string> requestId{};

  CreateMonitorGroupResponseBody() {}

  explicit CreateMonitorGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (monitorGroupId) {
      res["MonitorGroupId"] = boost::any(*monitorGroupId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MonitorGroupId") != m.end() && !m["MonitorGroupId"].empty()) {
      monitorGroupId = make_shared<long>(boost::any_cast<long>(m["MonitorGroupId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateMonitorGroupResponseBody() = default;
};
class CreateMonitorGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CreateMonitorGroupResponseBody> body{};

  CreateMonitorGroupResponse() {}

  explicit CreateMonitorGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateMonitorGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateMonitorGroupResponseBody>(model1);
      }
    }
  }


  virtual ~CreateMonitorGroupResponse() = default;
};
class CreatePluginRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  CreatePluginRequestTag() {}

  explicit CreatePluginRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~CreatePluginRequestTag() = default;
};
class CreatePluginRequest : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> pluginData{};
  shared_ptr<string> pluginName{};
  shared_ptr<string> pluginType{};
  shared_ptr<string> securityToken{};
  shared_ptr<vector<CreatePluginRequestTag>> tag{};

  CreatePluginRequest() {}

  explicit CreatePluginRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (pluginData) {
      res["PluginData"] = boost::any(*pluginData);
    }
    if (pluginName) {
      res["PluginName"] = boost::any(*pluginName);
    }
    if (pluginType) {
      res["PluginType"] = boost::any(*pluginType);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("PluginData") != m.end() && !m["PluginData"].empty()) {
      pluginData = make_shared<string>(boost::any_cast<string>(m["PluginData"]));
    }
    if (m.find("PluginName") != m.end() && !m["PluginName"].empty()) {
      pluginName = make_shared<string>(boost::any_cast<string>(m["PluginName"]));
    }
    if (m.find("PluginType") != m.end() && !m["PluginType"].empty()) {
      pluginType = make_shared<string>(boost::any_cast<string>(m["PluginType"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<CreatePluginRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreatePluginRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<CreatePluginRequestTag>>(expect1);
      }
    }
  }


  virtual ~CreatePluginRequest() = default;
};
class CreatePluginResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> pluginId{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> tagStatus{};

  CreatePluginResponseBody() {}

  explicit CreatePluginResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pluginId) {
      res["PluginId"] = boost::any(*pluginId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (tagStatus) {
      res["TagStatus"] = boost::any(*tagStatus);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PluginId") != m.end() && !m["PluginId"].empty()) {
      pluginId = make_shared<string>(boost::any_cast<string>(m["PluginId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TagStatus") != m.end() && !m["TagStatus"].empty()) {
      tagStatus = make_shared<bool>(boost::any_cast<bool>(m["TagStatus"]));
    }
  }


  virtual ~CreatePluginResponseBody() = default;
};
class CreatePluginResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CreatePluginResponseBody> body{};

  CreatePluginResponse() {}

  explicit CreatePluginResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreatePluginResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreatePluginResponseBody>(model1);
      }
    }
  }


  virtual ~CreatePluginResponse() = default;
};
class CreateSignatureRequest : public Darabonba::Model {
public:
  shared_ptr<string> securityToken{};
  shared_ptr<string> signatureKey{};
  shared_ptr<string> signatureName{};
  shared_ptr<string> signatureSecret{};

  CreateSignatureRequest() {}

  explicit CreateSignatureRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (signatureKey) {
      res["SignatureKey"] = boost::any(*signatureKey);
    }
    if (signatureName) {
      res["SignatureName"] = boost::any(*signatureName);
    }
    if (signatureSecret) {
      res["SignatureSecret"] = boost::any(*signatureSecret);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("SignatureKey") != m.end() && !m["SignatureKey"].empty()) {
      signatureKey = make_shared<string>(boost::any_cast<string>(m["SignatureKey"]));
    }
    if (m.find("SignatureName") != m.end() && !m["SignatureName"].empty()) {
      signatureName = make_shared<string>(boost::any_cast<string>(m["SignatureName"]));
    }
    if (m.find("SignatureSecret") != m.end() && !m["SignatureSecret"].empty()) {
      signatureSecret = make_shared<string>(boost::any_cast<string>(m["SignatureSecret"]));
    }
  }


  virtual ~CreateSignatureRequest() = default;
};
class CreateSignatureResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> signatureId{};
  shared_ptr<string> signatureName{};

  CreateSignatureResponseBody() {}

  explicit CreateSignatureResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (signatureId) {
      res["SignatureId"] = boost::any(*signatureId);
    }
    if (signatureName) {
      res["SignatureName"] = boost::any(*signatureName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SignatureId") != m.end() && !m["SignatureId"].empty()) {
      signatureId = make_shared<string>(boost::any_cast<string>(m["SignatureId"]));
    }
    if (m.find("SignatureName") != m.end() && !m["SignatureName"].empty()) {
      signatureName = make_shared<string>(boost::any_cast<string>(m["SignatureName"]));
    }
  }


  virtual ~CreateSignatureResponseBody() = default;
};
class CreateSignatureResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CreateSignatureResponseBody> body{};

  CreateSignatureResponse() {}

  explicit CreateSignatureResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateSignatureResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateSignatureResponseBody>(model1);
      }
    }
  }


  virtual ~CreateSignatureResponse() = default;
};
class CreateTrafficControlRequest : public Darabonba::Model {
public:
  shared_ptr<long> apiDefault{};
  shared_ptr<long> appDefault{};
  shared_ptr<string> description{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> trafficControlName{};
  shared_ptr<string> trafficControlUnit{};
  shared_ptr<long> userDefault{};

  CreateTrafficControlRequest() {}

  explicit CreateTrafficControlRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiDefault) {
      res["ApiDefault"] = boost::any(*apiDefault);
    }
    if (appDefault) {
      res["AppDefault"] = boost::any(*appDefault);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (trafficControlName) {
      res["TrafficControlName"] = boost::any(*trafficControlName);
    }
    if (trafficControlUnit) {
      res["TrafficControlUnit"] = boost::any(*trafficControlUnit);
    }
    if (userDefault) {
      res["UserDefault"] = boost::any(*userDefault);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiDefault") != m.end() && !m["ApiDefault"].empty()) {
      apiDefault = make_shared<long>(boost::any_cast<long>(m["ApiDefault"]));
    }
    if (m.find("AppDefault") != m.end() && !m["AppDefault"].empty()) {
      appDefault = make_shared<long>(boost::any_cast<long>(m["AppDefault"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("TrafficControlName") != m.end() && !m["TrafficControlName"].empty()) {
      trafficControlName = make_shared<string>(boost::any_cast<string>(m["TrafficControlName"]));
    }
    if (m.find("TrafficControlUnit") != m.end() && !m["TrafficControlUnit"].empty()) {
      trafficControlUnit = make_shared<string>(boost::any_cast<string>(m["TrafficControlUnit"]));
    }
    if (m.find("UserDefault") != m.end() && !m["UserDefault"].empty()) {
      userDefault = make_shared<long>(boost::any_cast<long>(m["UserDefault"]));
    }
  }


  virtual ~CreateTrafficControlRequest() = default;
};
class CreateTrafficControlResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> trafficControlId{};

  CreateTrafficControlResponseBody() {}

  explicit CreateTrafficControlResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (trafficControlId) {
      res["TrafficControlId"] = boost::any(*trafficControlId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TrafficControlId") != m.end() && !m["TrafficControlId"].empty()) {
      trafficControlId = make_shared<string>(boost::any_cast<string>(m["TrafficControlId"]));
    }
  }


  virtual ~CreateTrafficControlResponseBody() = default;
};
class CreateTrafficControlResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CreateTrafficControlResponseBody> body{};

  CreateTrafficControlResponse() {}

  explicit CreateTrafficControlResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateTrafficControlResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateTrafficControlResponseBody>(model1);
      }
    }
  }


  virtual ~CreateTrafficControlResponse() = default;
};
class DeleteAllTrafficSpecialControlRequest : public Darabonba::Model {
public:
  shared_ptr<string> securityToken{};
  shared_ptr<string> trafficControlId{};

  DeleteAllTrafficSpecialControlRequest() {}

  explicit DeleteAllTrafficSpecialControlRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (trafficControlId) {
      res["TrafficControlId"] = boost::any(*trafficControlId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("TrafficControlId") != m.end() && !m["TrafficControlId"].empty()) {
      trafficControlId = make_shared<string>(boost::any_cast<string>(m["TrafficControlId"]));
    }
  }


  virtual ~DeleteAllTrafficSpecialControlRequest() = default;
};
class DeleteAllTrafficSpecialControlResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteAllTrafficSpecialControlResponseBody() {}

  explicit DeleteAllTrafficSpecialControlResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteAllTrafficSpecialControlResponseBody() = default;
};
class DeleteAllTrafficSpecialControlResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DeleteAllTrafficSpecialControlResponseBody> body{};

  DeleteAllTrafficSpecialControlResponse() {}

  explicit DeleteAllTrafficSpecialControlResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteAllTrafficSpecialControlResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteAllTrafficSpecialControlResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteAllTrafficSpecialControlResponse() = default;
};
class DeleteApiRequest : public Darabonba::Model {
public:
  shared_ptr<string> apiId{};
  shared_ptr<string> groupId{};
  shared_ptr<string> securityToken{};

  DeleteApiRequest() {}

  explicit DeleteApiRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiId) {
      res["ApiId"] = boost::any(*apiId);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiId") != m.end() && !m["ApiId"].empty()) {
      apiId = make_shared<string>(boost::any_cast<string>(m["ApiId"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~DeleteApiRequest() = default;
};
class DeleteApiResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteApiResponseBody() {}

  explicit DeleteApiResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteApiResponseBody() = default;
};
class DeleteApiResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DeleteApiResponseBody> body{};

  DeleteApiResponse() {}

  explicit DeleteApiResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteApiResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteApiResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteApiResponse() = default;
};
class DeleteApiGroupRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  DeleteApiGroupRequestTag() {}

  explicit DeleteApiGroupRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DeleteApiGroupRequestTag() = default;
};
class DeleteApiGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> groupId{};
  shared_ptr<string> securityToken{};
  shared_ptr<vector<DeleteApiGroupRequestTag>> tag{};

  DeleteApiGroupRequest() {}

  explicit DeleteApiGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<DeleteApiGroupRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DeleteApiGroupRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<DeleteApiGroupRequestTag>>(expect1);
      }
    }
  }


  virtual ~DeleteApiGroupRequest() = default;
};
class DeleteApiGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteApiGroupResponseBody() {}

  explicit DeleteApiGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteApiGroupResponseBody() = default;
};
class DeleteApiGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DeleteApiGroupResponseBody> body{};

  DeleteApiGroupResponse() {}

  explicit DeleteApiGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteApiGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteApiGroupResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteApiGroupResponse() = default;
};
class DeleteApiStageVariableRequest : public Darabonba::Model {
public:
  shared_ptr<string> groupId{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> stageId{};
  shared_ptr<string> variableName{};

  DeleteApiStageVariableRequest() {}

  explicit DeleteApiStageVariableRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (stageId) {
      res["StageId"] = boost::any(*stageId);
    }
    if (variableName) {
      res["VariableName"] = boost::any(*variableName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("StageId") != m.end() && !m["StageId"].empty()) {
      stageId = make_shared<string>(boost::any_cast<string>(m["StageId"]));
    }
    if (m.find("VariableName") != m.end() && !m["VariableName"].empty()) {
      variableName = make_shared<string>(boost::any_cast<string>(m["VariableName"]));
    }
  }


  virtual ~DeleteApiStageVariableRequest() = default;
};
class DeleteApiStageVariableResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteApiStageVariableResponseBody() {}

  explicit DeleteApiStageVariableResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteApiStageVariableResponseBody() = default;
};
class DeleteApiStageVariableResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DeleteApiStageVariableResponseBody> body{};

  DeleteApiStageVariableResponse() {}

  explicit DeleteApiStageVariableResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteApiStageVariableResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteApiStageVariableResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteApiStageVariableResponse() = default;
};
class DeleteAppRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  DeleteAppRequestTag() {}

  explicit DeleteAppRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DeleteAppRequestTag() = default;
};
class DeleteAppRequest : public Darabonba::Model {
public:
  shared_ptr<long> appId{};
  shared_ptr<string> securityToken{};
  shared_ptr<vector<DeleteAppRequestTag>> tag{};

  DeleteAppRequest() {}

  explicit DeleteAppRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<long>(boost::any_cast<long>(m["AppId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<DeleteAppRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DeleteAppRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<DeleteAppRequestTag>>(expect1);
      }
    }
  }


  virtual ~DeleteAppRequest() = default;
};
class DeleteAppResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteAppResponseBody() {}

  explicit DeleteAppResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteAppResponseBody() = default;
};
class DeleteAppResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DeleteAppResponseBody> body{};

  DeleteAppResponse() {}

  explicit DeleteAppResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteAppResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteAppResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteAppResponse() = default;
};
class DeleteDomainRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> groupId{};
  shared_ptr<string> securityToken{};

  DeleteDomainRequest() {}

  explicit DeleteDomainRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~DeleteDomainRequest() = default;
};
class DeleteDomainResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteDomainResponseBody() {}

  explicit DeleteDomainResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteDomainResponseBody() = default;
};
class DeleteDomainResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DeleteDomainResponseBody> body{};

  DeleteDomainResponse() {}

  explicit DeleteDomainResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteDomainResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteDomainResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteDomainResponse() = default;
};
class DeleteDomainCertificateRequest : public Darabonba::Model {
public:
  shared_ptr<string> certificateId{};
  shared_ptr<string> domainName{};
  shared_ptr<string> groupId{};
  shared_ptr<string> securityToken{};

  DeleteDomainCertificateRequest() {}

  explicit DeleteDomainCertificateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (certificateId) {
      res["CertificateId"] = boost::any(*certificateId);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CertificateId") != m.end() && !m["CertificateId"].empty()) {
      certificateId = make_shared<string>(boost::any_cast<string>(m["CertificateId"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~DeleteDomainCertificateRequest() = default;
};
class DeleteDomainCertificateResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteDomainCertificateResponseBody() {}

  explicit DeleteDomainCertificateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteDomainCertificateResponseBody() = default;
};
class DeleteDomainCertificateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DeleteDomainCertificateResponseBody> body{};

  DeleteDomainCertificateResponse() {}

  explicit DeleteDomainCertificateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteDomainCertificateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteDomainCertificateResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteDomainCertificateResponse() = default;
};
class DeleteInstanceRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  DeleteInstanceRequestTag() {}

  explicit DeleteInstanceRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DeleteInstanceRequestTag() = default;
};
class DeleteInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<vector<DeleteInstanceRequestTag>> tag{};

  DeleteInstanceRequest() {}

  explicit DeleteInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<DeleteInstanceRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DeleteInstanceRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<DeleteInstanceRequestTag>>(expect1);
      }
    }
  }


  virtual ~DeleteInstanceRequest() = default;
};
class DeleteInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteInstanceResponseBody() {}

  explicit DeleteInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteInstanceResponseBody() = default;
};
class DeleteInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DeleteInstanceResponseBody> body{};

  DeleteInstanceResponse() {}

  explicit DeleteInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteInstanceResponse() = default;
};
class DeleteIpControlRequest : public Darabonba::Model {
public:
  shared_ptr<string> ipControlId{};
  shared_ptr<string> securityToken{};

  DeleteIpControlRequest() {}

  explicit DeleteIpControlRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ipControlId) {
      res["IpControlId"] = boost::any(*ipControlId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IpControlId") != m.end() && !m["IpControlId"].empty()) {
      ipControlId = make_shared<string>(boost::any_cast<string>(m["IpControlId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~DeleteIpControlRequest() = default;
};
class DeleteIpControlResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteIpControlResponseBody() {}

  explicit DeleteIpControlResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteIpControlResponseBody() = default;
};
class DeleteIpControlResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DeleteIpControlResponseBody> body{};

  DeleteIpControlResponse() {}

  explicit DeleteIpControlResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteIpControlResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteIpControlResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteIpControlResponse() = default;
};
class DeleteLogConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> logType{};
  shared_ptr<string> securityToken{};

  DeleteLogConfigRequest() {}

  explicit DeleteLogConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (logType) {
      res["LogType"] = boost::any(*logType);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LogType") != m.end() && !m["LogType"].empty()) {
      logType = make_shared<string>(boost::any_cast<string>(m["LogType"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~DeleteLogConfigRequest() = default;
};
class DeleteLogConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteLogConfigResponseBody() {}

  explicit DeleteLogConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteLogConfigResponseBody() = default;
};
class DeleteLogConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DeleteLogConfigResponseBody> body{};

  DeleteLogConfigResponse() {}

  explicit DeleteLogConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteLogConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteLogConfigResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteLogConfigResponse() = default;
};
class DeleteModelRequest : public Darabonba::Model {
public:
  shared_ptr<string> groupId{};
  shared_ptr<string> modelName{};

  DeleteModelRequest() {}

  explicit DeleteModelRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (modelName) {
      res["ModelName"] = boost::any(*modelName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("ModelName") != m.end() && !m["ModelName"].empty()) {
      modelName = make_shared<string>(boost::any_cast<string>(m["ModelName"]));
    }
  }


  virtual ~DeleteModelRequest() = default;
};
class DeleteModelResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteModelResponseBody() {}

  explicit DeleteModelResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteModelResponseBody() = default;
};
class DeleteModelResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DeleteModelResponseBody> body{};

  DeleteModelResponse() {}

  explicit DeleteModelResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteModelResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteModelResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteModelResponse() = default;
};
class DeletePluginRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  DeletePluginRequestTag() {}

  explicit DeletePluginRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DeletePluginRequestTag() = default;
};
class DeletePluginRequest : public Darabonba::Model {
public:
  shared_ptr<string> pluginId{};
  shared_ptr<string> securityToken{};
  shared_ptr<vector<DeletePluginRequestTag>> tag{};

  DeletePluginRequest() {}

  explicit DeletePluginRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pluginId) {
      res["PluginId"] = boost::any(*pluginId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PluginId") != m.end() && !m["PluginId"].empty()) {
      pluginId = make_shared<string>(boost::any_cast<string>(m["PluginId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<DeletePluginRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DeletePluginRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<DeletePluginRequestTag>>(expect1);
      }
    }
  }


  virtual ~DeletePluginRequest() = default;
};
class DeletePluginResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeletePluginResponseBody() {}

  explicit DeletePluginResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeletePluginResponseBody() = default;
};
class DeletePluginResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DeletePluginResponseBody> body{};

  DeletePluginResponse() {}

  explicit DeletePluginResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeletePluginResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeletePluginResponseBody>(model1);
      }
    }
  }


  virtual ~DeletePluginResponse() = default;
};
class DeleteSignatureRequest : public Darabonba::Model {
public:
  shared_ptr<string> securityToken{};
  shared_ptr<string> signatureId{};

  DeleteSignatureRequest() {}

  explicit DeleteSignatureRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (signatureId) {
      res["SignatureId"] = boost::any(*signatureId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("SignatureId") != m.end() && !m["SignatureId"].empty()) {
      signatureId = make_shared<string>(boost::any_cast<string>(m["SignatureId"]));
    }
  }


  virtual ~DeleteSignatureRequest() = default;
};
class DeleteSignatureResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteSignatureResponseBody() {}

  explicit DeleteSignatureResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteSignatureResponseBody() = default;
};
class DeleteSignatureResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DeleteSignatureResponseBody> body{};

  DeleteSignatureResponse() {}

  explicit DeleteSignatureResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteSignatureResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteSignatureResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteSignatureResponse() = default;
};
class DeleteTrafficControlRequest : public Darabonba::Model {
public:
  shared_ptr<string> securityToken{};
  shared_ptr<string> trafficControlId{};

  DeleteTrafficControlRequest() {}

  explicit DeleteTrafficControlRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (trafficControlId) {
      res["TrafficControlId"] = boost::any(*trafficControlId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("TrafficControlId") != m.end() && !m["TrafficControlId"].empty()) {
      trafficControlId = make_shared<string>(boost::any_cast<string>(m["TrafficControlId"]));
    }
  }


  virtual ~DeleteTrafficControlRequest() = default;
};
class DeleteTrafficControlResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteTrafficControlResponseBody() {}

  explicit DeleteTrafficControlResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteTrafficControlResponseBody() = default;
};
class DeleteTrafficControlResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DeleteTrafficControlResponseBody> body{};

  DeleteTrafficControlResponse() {}

  explicit DeleteTrafficControlResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteTrafficControlResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteTrafficControlResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteTrafficControlResponse() = default;
};
class DeleteTrafficSpecialControlRequest : public Darabonba::Model {
public:
  shared_ptr<string> securityToken{};
  shared_ptr<string> specialKey{};
  shared_ptr<string> specialType{};
  shared_ptr<string> trafficControlId{};

  DeleteTrafficSpecialControlRequest() {}

  explicit DeleteTrafficSpecialControlRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (specialKey) {
      res["SpecialKey"] = boost::any(*specialKey);
    }
    if (specialType) {
      res["SpecialType"] = boost::any(*specialType);
    }
    if (trafficControlId) {
      res["TrafficControlId"] = boost::any(*trafficControlId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("SpecialKey") != m.end() && !m["SpecialKey"].empty()) {
      specialKey = make_shared<string>(boost::any_cast<string>(m["SpecialKey"]));
    }
    if (m.find("SpecialType") != m.end() && !m["SpecialType"].empty()) {
      specialType = make_shared<string>(boost::any_cast<string>(m["SpecialType"]));
    }
    if (m.find("TrafficControlId") != m.end() && !m["TrafficControlId"].empty()) {
      trafficControlId = make_shared<string>(boost::any_cast<string>(m["TrafficControlId"]));
    }
  }


  virtual ~DeleteTrafficSpecialControlRequest() = default;
};
class DeleteTrafficSpecialControlResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteTrafficSpecialControlResponseBody() {}

  explicit DeleteTrafficSpecialControlResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteTrafficSpecialControlResponseBody() = default;
};
class DeleteTrafficSpecialControlResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DeleteTrafficSpecialControlResponseBody> body{};

  DeleteTrafficSpecialControlResponse() {}

  explicit DeleteTrafficSpecialControlResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteTrafficSpecialControlResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteTrafficSpecialControlResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteTrafficSpecialControlResponse() = default;
};
class DeployApiRequest : public Darabonba::Model {
public:
  shared_ptr<string> apiId{};
  shared_ptr<string> description{};
  shared_ptr<string> groupId{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> stageName{};

  DeployApiRequest() {}

  explicit DeployApiRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiId) {
      res["ApiId"] = boost::any(*apiId);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (stageName) {
      res["StageName"] = boost::any(*stageName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiId") != m.end() && !m["ApiId"].empty()) {
      apiId = make_shared<string>(boost::any_cast<string>(m["ApiId"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("StageName") != m.end() && !m["StageName"].empty()) {
      stageName = make_shared<string>(boost::any_cast<string>(m["StageName"]));
    }
  }


  virtual ~DeployApiRequest() = default;
};
class DeployApiResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeployApiResponseBody() {}

  explicit DeployApiResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeployApiResponseBody() = default;
};
class DeployApiResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DeployApiResponseBody> body{};

  DeployApiResponse() {}

  explicit DeployApiResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeployApiResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeployApiResponseBody>(model1);
      }
    }
  }


  virtual ~DeployApiResponse() = default;
};
class DescribeAbolishApiTaskRequest : public Darabonba::Model {
public:
  shared_ptr<string> operationUid{};
  shared_ptr<string> securityToken{};

  DescribeAbolishApiTaskRequest() {}

  explicit DescribeAbolishApiTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (operationUid) {
      res["OperationUid"] = boost::any(*operationUid);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OperationUid") != m.end() && !m["OperationUid"].empty()) {
      operationUid = make_shared<string>(boost::any_cast<string>(m["OperationUid"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~DescribeAbolishApiTaskRequest() = default;
};
class DescribeAbolishApiTaskResponseBodyApiAbolishResultsApiAbolishResult : public Darabonba::Model {
public:
  shared_ptr<string> abolishStatus{};
  shared_ptr<string> apiName{};
  shared_ptr<string> apiUid{};
  shared_ptr<string> errorMsg{};
  shared_ptr<string> groupId{};
  shared_ptr<string> groupName{};
  shared_ptr<string> stageId{};
  shared_ptr<string> stageName{};

  DescribeAbolishApiTaskResponseBodyApiAbolishResultsApiAbolishResult() {}

  explicit DescribeAbolishApiTaskResponseBodyApiAbolishResultsApiAbolishResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (abolishStatus) {
      res["AbolishStatus"] = boost::any(*abolishStatus);
    }
    if (apiName) {
      res["ApiName"] = boost::any(*apiName);
    }
    if (apiUid) {
      res["ApiUid"] = boost::any(*apiUid);
    }
    if (errorMsg) {
      res["ErrorMsg"] = boost::any(*errorMsg);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (stageId) {
      res["StageId"] = boost::any(*stageId);
    }
    if (stageName) {
      res["StageName"] = boost::any(*stageName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AbolishStatus") != m.end() && !m["AbolishStatus"].empty()) {
      abolishStatus = make_shared<string>(boost::any_cast<string>(m["AbolishStatus"]));
    }
    if (m.find("ApiName") != m.end() && !m["ApiName"].empty()) {
      apiName = make_shared<string>(boost::any_cast<string>(m["ApiName"]));
    }
    if (m.find("ApiUid") != m.end() && !m["ApiUid"].empty()) {
      apiUid = make_shared<string>(boost::any_cast<string>(m["ApiUid"]));
    }
    if (m.find("ErrorMsg") != m.end() && !m["ErrorMsg"].empty()) {
      errorMsg = make_shared<string>(boost::any_cast<string>(m["ErrorMsg"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("StageId") != m.end() && !m["StageId"].empty()) {
      stageId = make_shared<string>(boost::any_cast<string>(m["StageId"]));
    }
    if (m.find("StageName") != m.end() && !m["StageName"].empty()) {
      stageName = make_shared<string>(boost::any_cast<string>(m["StageName"]));
    }
  }


  virtual ~DescribeAbolishApiTaskResponseBodyApiAbolishResultsApiAbolishResult() = default;
};
class DescribeAbolishApiTaskResponseBodyApiAbolishResults : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeAbolishApiTaskResponseBodyApiAbolishResultsApiAbolishResult>> apiAbolishResult{};

  DescribeAbolishApiTaskResponseBodyApiAbolishResults() {}

  explicit DescribeAbolishApiTaskResponseBodyApiAbolishResults(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiAbolishResult) {
      vector<boost::any> temp1;
      for(auto item1:*apiAbolishResult){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ApiAbolishResult"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiAbolishResult") != m.end() && !m["ApiAbolishResult"].empty()) {
      if (typeid(vector<boost::any>) == m["ApiAbolishResult"].type()) {
        vector<DescribeAbolishApiTaskResponseBodyApiAbolishResultsApiAbolishResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ApiAbolishResult"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeAbolishApiTaskResponseBodyApiAbolishResultsApiAbolishResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        apiAbolishResult = make_shared<vector<DescribeAbolishApiTaskResponseBodyApiAbolishResultsApiAbolishResult>>(expect1);
      }
    }
  }


  virtual ~DescribeAbolishApiTaskResponseBodyApiAbolishResults() = default;
};
class DescribeAbolishApiTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeAbolishApiTaskResponseBodyApiAbolishResults> apiAbolishResults{};
  shared_ptr<string> requestId{};

  DescribeAbolishApiTaskResponseBody() {}

  explicit DescribeAbolishApiTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiAbolishResults) {
      res["ApiAbolishResults"] = apiAbolishResults ? boost::any(apiAbolishResults->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiAbolishResults") != m.end() && !m["ApiAbolishResults"].empty()) {
      if (typeid(map<string, boost::any>) == m["ApiAbolishResults"].type()) {
        DescribeAbolishApiTaskResponseBodyApiAbolishResults model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ApiAbolishResults"]));
        apiAbolishResults = make_shared<DescribeAbolishApiTaskResponseBodyApiAbolishResults>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeAbolishApiTaskResponseBody() = default;
};
class DescribeAbolishApiTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeAbolishApiTaskResponseBody> body{};

  DescribeAbolishApiTaskResponse() {}

  explicit DescribeAbolishApiTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeAbolishApiTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeAbolishApiTaskResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeAbolishApiTaskResponse() = default;
};
class DescribeApiRequest : public Darabonba::Model {
public:
  shared_ptr<string> apiId{};
  shared_ptr<string> groupId{};
  shared_ptr<string> securityToken{};

  DescribeApiRequest() {}

  explicit DescribeApiRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiId) {
      res["ApiId"] = boost::any(*apiId);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiId") != m.end() && !m["ApiId"].empty()) {
      apiId = make_shared<string>(boost::any_cast<string>(m["ApiId"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~DescribeApiRequest() = default;
};
class DescribeApiResponseBodyConstantParametersConstantParameter : public Darabonba::Model {
public:
  shared_ptr<string> constantValue{};
  shared_ptr<string> description{};
  shared_ptr<string> location{};
  shared_ptr<string> serviceParameterName{};

  DescribeApiResponseBodyConstantParametersConstantParameter() {}

  explicit DescribeApiResponseBodyConstantParametersConstantParameter(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (constantValue) {
      res["ConstantValue"] = boost::any(*constantValue);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (serviceParameterName) {
      res["ServiceParameterName"] = boost::any(*serviceParameterName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConstantValue") != m.end() && !m["ConstantValue"].empty()) {
      constantValue = make_shared<string>(boost::any_cast<string>(m["ConstantValue"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("ServiceParameterName") != m.end() && !m["ServiceParameterName"].empty()) {
      serviceParameterName = make_shared<string>(boost::any_cast<string>(m["ServiceParameterName"]));
    }
  }


  virtual ~DescribeApiResponseBodyConstantParametersConstantParameter() = default;
};
class DescribeApiResponseBodyConstantParameters : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeApiResponseBodyConstantParametersConstantParameter>> constantParameter{};

  DescribeApiResponseBodyConstantParameters() {}

  explicit DescribeApiResponseBodyConstantParameters(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (constantParameter) {
      vector<boost::any> temp1;
      for(auto item1:*constantParameter){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ConstantParameter"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConstantParameter") != m.end() && !m["ConstantParameter"].empty()) {
      if (typeid(vector<boost::any>) == m["ConstantParameter"].type()) {
        vector<DescribeApiResponseBodyConstantParametersConstantParameter> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ConstantParameter"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeApiResponseBodyConstantParametersConstantParameter model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        constantParameter = make_shared<vector<DescribeApiResponseBodyConstantParametersConstantParameter>>(expect1);
      }
    }
  }


  virtual ~DescribeApiResponseBodyConstantParameters() = default;
};
class DescribeApiResponseBodyCustomSystemParametersCustomSystemParameter : public Darabonba::Model {
public:
  shared_ptr<string> demoValue{};
  shared_ptr<string> description{};
  shared_ptr<string> location{};
  shared_ptr<string> parameterName{};
  shared_ptr<string> serviceParameterName{};

  DescribeApiResponseBodyCustomSystemParametersCustomSystemParameter() {}

  explicit DescribeApiResponseBodyCustomSystemParametersCustomSystemParameter(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (demoValue) {
      res["DemoValue"] = boost::any(*demoValue);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (parameterName) {
      res["ParameterName"] = boost::any(*parameterName);
    }
    if (serviceParameterName) {
      res["ServiceParameterName"] = boost::any(*serviceParameterName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DemoValue") != m.end() && !m["DemoValue"].empty()) {
      demoValue = make_shared<string>(boost::any_cast<string>(m["DemoValue"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("ParameterName") != m.end() && !m["ParameterName"].empty()) {
      parameterName = make_shared<string>(boost::any_cast<string>(m["ParameterName"]));
    }
    if (m.find("ServiceParameterName") != m.end() && !m["ServiceParameterName"].empty()) {
      serviceParameterName = make_shared<string>(boost::any_cast<string>(m["ServiceParameterName"]));
    }
  }


  virtual ~DescribeApiResponseBodyCustomSystemParametersCustomSystemParameter() = default;
};
class DescribeApiResponseBodyCustomSystemParameters : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeApiResponseBodyCustomSystemParametersCustomSystemParameter>> customSystemParameter{};

  DescribeApiResponseBodyCustomSystemParameters() {}

  explicit DescribeApiResponseBodyCustomSystemParameters(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (customSystemParameter) {
      vector<boost::any> temp1;
      for(auto item1:*customSystemParameter){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CustomSystemParameter"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CustomSystemParameter") != m.end() && !m["CustomSystemParameter"].empty()) {
      if (typeid(vector<boost::any>) == m["CustomSystemParameter"].type()) {
        vector<DescribeApiResponseBodyCustomSystemParametersCustomSystemParameter> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CustomSystemParameter"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeApiResponseBodyCustomSystemParametersCustomSystemParameter model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        customSystemParameter = make_shared<vector<DescribeApiResponseBodyCustomSystemParametersCustomSystemParameter>>(expect1);
      }
    }
  }


  virtual ~DescribeApiResponseBodyCustomSystemParameters() = default;
};
class DescribeApiResponseBodyDeployedInfosDeployedInfo : public Darabonba::Model {
public:
  shared_ptr<string> deployedStatus{};
  shared_ptr<string> effectiveVersion{};
  shared_ptr<string> stageName{};

  DescribeApiResponseBodyDeployedInfosDeployedInfo() {}

  explicit DescribeApiResponseBodyDeployedInfosDeployedInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deployedStatus) {
      res["DeployedStatus"] = boost::any(*deployedStatus);
    }
    if (effectiveVersion) {
      res["EffectiveVersion"] = boost::any(*effectiveVersion);
    }
    if (stageName) {
      res["StageName"] = boost::any(*stageName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeployedStatus") != m.end() && !m["DeployedStatus"].empty()) {
      deployedStatus = make_shared<string>(boost::any_cast<string>(m["DeployedStatus"]));
    }
    if (m.find("EffectiveVersion") != m.end() && !m["EffectiveVersion"].empty()) {
      effectiveVersion = make_shared<string>(boost::any_cast<string>(m["EffectiveVersion"]));
    }
    if (m.find("StageName") != m.end() && !m["StageName"].empty()) {
      stageName = make_shared<string>(boost::any_cast<string>(m["StageName"]));
    }
  }


  virtual ~DescribeApiResponseBodyDeployedInfosDeployedInfo() = default;
};
class DescribeApiResponseBodyDeployedInfos : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeApiResponseBodyDeployedInfosDeployedInfo>> deployedInfo{};

  DescribeApiResponseBodyDeployedInfos() {}

  explicit DescribeApiResponseBodyDeployedInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deployedInfo) {
      vector<boost::any> temp1;
      for(auto item1:*deployedInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DeployedInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeployedInfo") != m.end() && !m["DeployedInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["DeployedInfo"].type()) {
        vector<DescribeApiResponseBodyDeployedInfosDeployedInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DeployedInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeApiResponseBodyDeployedInfosDeployedInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        deployedInfo = make_shared<vector<DescribeApiResponseBodyDeployedInfosDeployedInfo>>(expect1);
      }
    }
  }


  virtual ~DescribeApiResponseBodyDeployedInfos() = default;
};
class DescribeApiResponseBodyErrorCodeSamplesErrorCodeSample : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> description{};
  shared_ptr<string> message{};
  shared_ptr<string> model{};

  DescribeApiResponseBodyErrorCodeSamplesErrorCodeSample() {}

  explicit DescribeApiResponseBodyErrorCodeSamplesErrorCodeSample(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (model) {
      res["Model"] = boost::any(*model);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Model") != m.end() && !m["Model"].empty()) {
      model = make_shared<string>(boost::any_cast<string>(m["Model"]));
    }
  }


  virtual ~DescribeApiResponseBodyErrorCodeSamplesErrorCodeSample() = default;
};
class DescribeApiResponseBodyErrorCodeSamples : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeApiResponseBodyErrorCodeSamplesErrorCodeSample>> errorCodeSample{};

  DescribeApiResponseBodyErrorCodeSamples() {}

  explicit DescribeApiResponseBodyErrorCodeSamples(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCodeSample) {
      vector<boost::any> temp1;
      for(auto item1:*errorCodeSample){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ErrorCodeSample"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCodeSample") != m.end() && !m["ErrorCodeSample"].empty()) {
      if (typeid(vector<boost::any>) == m["ErrorCodeSample"].type()) {
        vector<DescribeApiResponseBodyErrorCodeSamplesErrorCodeSample> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ErrorCodeSample"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeApiResponseBodyErrorCodeSamplesErrorCodeSample model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        errorCodeSample = make_shared<vector<DescribeApiResponseBodyErrorCodeSamplesErrorCodeSample>>(expect1);
      }
    }
  }


  virtual ~DescribeApiResponseBodyErrorCodeSamples() = default;
};
class DescribeApiResponseBodyOpenIdConnectConfig : public Darabonba::Model {
public:
  shared_ptr<string> idTokenParamName{};
  shared_ptr<string> openIdApiType{};
  shared_ptr<string> publicKey{};
  shared_ptr<string> publicKeyId{};

  DescribeApiResponseBodyOpenIdConnectConfig() {}

  explicit DescribeApiResponseBodyOpenIdConnectConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (idTokenParamName) {
      res["IdTokenParamName"] = boost::any(*idTokenParamName);
    }
    if (openIdApiType) {
      res["OpenIdApiType"] = boost::any(*openIdApiType);
    }
    if (publicKey) {
      res["PublicKey"] = boost::any(*publicKey);
    }
    if (publicKeyId) {
      res["PublicKeyId"] = boost::any(*publicKeyId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IdTokenParamName") != m.end() && !m["IdTokenParamName"].empty()) {
      idTokenParamName = make_shared<string>(boost::any_cast<string>(m["IdTokenParamName"]));
    }
    if (m.find("OpenIdApiType") != m.end() && !m["OpenIdApiType"].empty()) {
      openIdApiType = make_shared<string>(boost::any_cast<string>(m["OpenIdApiType"]));
    }
    if (m.find("PublicKey") != m.end() && !m["PublicKey"].empty()) {
      publicKey = make_shared<string>(boost::any_cast<string>(m["PublicKey"]));
    }
    if (m.find("PublicKeyId") != m.end() && !m["PublicKeyId"].empty()) {
      publicKeyId = make_shared<string>(boost::any_cast<string>(m["PublicKeyId"]));
    }
  }


  virtual ~DescribeApiResponseBodyOpenIdConnectConfig() = default;
};
class DescribeApiResponseBodyRequestConfig : public Darabonba::Model {
public:
  shared_ptr<string> bodyFormat{};
  shared_ptr<string> bodyModel{};
  shared_ptr<string> postBodyDescription{};
  shared_ptr<string> requestHttpMethod{};
  shared_ptr<string> requestMode{};
  shared_ptr<string> requestPath{};
  shared_ptr<string> requestProtocol{};

  DescribeApiResponseBodyRequestConfig() {}

  explicit DescribeApiResponseBodyRequestConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bodyFormat) {
      res["BodyFormat"] = boost::any(*bodyFormat);
    }
    if (bodyModel) {
      res["BodyModel"] = boost::any(*bodyModel);
    }
    if (postBodyDescription) {
      res["PostBodyDescription"] = boost::any(*postBodyDescription);
    }
    if (requestHttpMethod) {
      res["RequestHttpMethod"] = boost::any(*requestHttpMethod);
    }
    if (requestMode) {
      res["RequestMode"] = boost::any(*requestMode);
    }
    if (requestPath) {
      res["RequestPath"] = boost::any(*requestPath);
    }
    if (requestProtocol) {
      res["RequestProtocol"] = boost::any(*requestProtocol);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BodyFormat") != m.end() && !m["BodyFormat"].empty()) {
      bodyFormat = make_shared<string>(boost::any_cast<string>(m["BodyFormat"]));
    }
    if (m.find("BodyModel") != m.end() && !m["BodyModel"].empty()) {
      bodyModel = make_shared<string>(boost::any_cast<string>(m["BodyModel"]));
    }
    if (m.find("PostBodyDescription") != m.end() && !m["PostBodyDescription"].empty()) {
      postBodyDescription = make_shared<string>(boost::any_cast<string>(m["PostBodyDescription"]));
    }
    if (m.find("RequestHttpMethod") != m.end() && !m["RequestHttpMethod"].empty()) {
      requestHttpMethod = make_shared<string>(boost::any_cast<string>(m["RequestHttpMethod"]));
    }
    if (m.find("RequestMode") != m.end() && !m["RequestMode"].empty()) {
      requestMode = make_shared<string>(boost::any_cast<string>(m["RequestMode"]));
    }
    if (m.find("RequestPath") != m.end() && !m["RequestPath"].empty()) {
      requestPath = make_shared<string>(boost::any_cast<string>(m["RequestPath"]));
    }
    if (m.find("RequestProtocol") != m.end() && !m["RequestProtocol"].empty()) {
      requestProtocol = make_shared<string>(boost::any_cast<string>(m["RequestProtocol"]));
    }
  }


  virtual ~DescribeApiResponseBodyRequestConfig() = default;
};
class DescribeApiResponseBodyRequestParametersRequestParameter : public Darabonba::Model {
public:
  shared_ptr<string> apiParameterName{};
  shared_ptr<string> arrayItemsType{};
  shared_ptr<string> defaultValue{};
  shared_ptr<string> demoValue{};
  shared_ptr<string> description{};
  shared_ptr<long> docOrder{};
  shared_ptr<string> docShow{};
  shared_ptr<string> enumValue{};
  shared_ptr<string> jsonScheme{};
  shared_ptr<string> location{};
  shared_ptr<long> maxLength{};
  shared_ptr<long> maxValue{};
  shared_ptr<long> minLength{};
  shared_ptr<long> minValue{};
  shared_ptr<string> parameterType{};
  shared_ptr<string> regularExpression{};
  shared_ptr<string> required{};

  DescribeApiResponseBodyRequestParametersRequestParameter() {}

  explicit DescribeApiResponseBodyRequestParametersRequestParameter(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiParameterName) {
      res["ApiParameterName"] = boost::any(*apiParameterName);
    }
    if (arrayItemsType) {
      res["ArrayItemsType"] = boost::any(*arrayItemsType);
    }
    if (defaultValue) {
      res["DefaultValue"] = boost::any(*defaultValue);
    }
    if (demoValue) {
      res["DemoValue"] = boost::any(*demoValue);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (docOrder) {
      res["DocOrder"] = boost::any(*docOrder);
    }
    if (docShow) {
      res["DocShow"] = boost::any(*docShow);
    }
    if (enumValue) {
      res["EnumValue"] = boost::any(*enumValue);
    }
    if (jsonScheme) {
      res["JsonScheme"] = boost::any(*jsonScheme);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (maxLength) {
      res["MaxLength"] = boost::any(*maxLength);
    }
    if (maxValue) {
      res["MaxValue"] = boost::any(*maxValue);
    }
    if (minLength) {
      res["MinLength"] = boost::any(*minLength);
    }
    if (minValue) {
      res["MinValue"] = boost::any(*minValue);
    }
    if (parameterType) {
      res["ParameterType"] = boost::any(*parameterType);
    }
    if (regularExpression) {
      res["RegularExpression"] = boost::any(*regularExpression);
    }
    if (required) {
      res["Required"] = boost::any(*required);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiParameterName") != m.end() && !m["ApiParameterName"].empty()) {
      apiParameterName = make_shared<string>(boost::any_cast<string>(m["ApiParameterName"]));
    }
    if (m.find("ArrayItemsType") != m.end() && !m["ArrayItemsType"].empty()) {
      arrayItemsType = make_shared<string>(boost::any_cast<string>(m["ArrayItemsType"]));
    }
    if (m.find("DefaultValue") != m.end() && !m["DefaultValue"].empty()) {
      defaultValue = make_shared<string>(boost::any_cast<string>(m["DefaultValue"]));
    }
    if (m.find("DemoValue") != m.end() && !m["DemoValue"].empty()) {
      demoValue = make_shared<string>(boost::any_cast<string>(m["DemoValue"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DocOrder") != m.end() && !m["DocOrder"].empty()) {
      docOrder = make_shared<long>(boost::any_cast<long>(m["DocOrder"]));
    }
    if (m.find("DocShow") != m.end() && !m["DocShow"].empty()) {
      docShow = make_shared<string>(boost::any_cast<string>(m["DocShow"]));
    }
    if (m.find("EnumValue") != m.end() && !m["EnumValue"].empty()) {
      enumValue = make_shared<string>(boost::any_cast<string>(m["EnumValue"]));
    }
    if (m.find("JsonScheme") != m.end() && !m["JsonScheme"].empty()) {
      jsonScheme = make_shared<string>(boost::any_cast<string>(m["JsonScheme"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("MaxLength") != m.end() && !m["MaxLength"].empty()) {
      maxLength = make_shared<long>(boost::any_cast<long>(m["MaxLength"]));
    }
    if (m.find("MaxValue") != m.end() && !m["MaxValue"].empty()) {
      maxValue = make_shared<long>(boost::any_cast<long>(m["MaxValue"]));
    }
    if (m.find("MinLength") != m.end() && !m["MinLength"].empty()) {
      minLength = make_shared<long>(boost::any_cast<long>(m["MinLength"]));
    }
    if (m.find("MinValue") != m.end() && !m["MinValue"].empty()) {
      minValue = make_shared<long>(boost::any_cast<long>(m["MinValue"]));
    }
    if (m.find("ParameterType") != m.end() && !m["ParameterType"].empty()) {
      parameterType = make_shared<string>(boost::any_cast<string>(m["ParameterType"]));
    }
    if (m.find("RegularExpression") != m.end() && !m["RegularExpression"].empty()) {
      regularExpression = make_shared<string>(boost::any_cast<string>(m["RegularExpression"]));
    }
    if (m.find("Required") != m.end() && !m["Required"].empty()) {
      required = make_shared<string>(boost::any_cast<string>(m["Required"]));
    }
  }


  virtual ~DescribeApiResponseBodyRequestParametersRequestParameter() = default;
};
class DescribeApiResponseBodyRequestParameters : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeApiResponseBodyRequestParametersRequestParameter>> requestParameter{};

  DescribeApiResponseBodyRequestParameters() {}

  explicit DescribeApiResponseBodyRequestParameters(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestParameter) {
      vector<boost::any> temp1;
      for(auto item1:*requestParameter){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RequestParameter"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestParameter") != m.end() && !m["RequestParameter"].empty()) {
      if (typeid(vector<boost::any>) == m["RequestParameter"].type()) {
        vector<DescribeApiResponseBodyRequestParametersRequestParameter> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RequestParameter"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeApiResponseBodyRequestParametersRequestParameter model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        requestParameter = make_shared<vector<DescribeApiResponseBodyRequestParametersRequestParameter>>(expect1);
      }
    }
  }


  virtual ~DescribeApiResponseBodyRequestParameters() = default;
};
class DescribeApiResponseBodyResultDescriptionsResultDescription : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<bool> hasChild{};
  shared_ptr<string> id{};
  shared_ptr<string> key{};
  shared_ptr<bool> mandatory{};
  shared_ptr<string> name{};
  shared_ptr<string> pid{};
  shared_ptr<string> type{};

  DescribeApiResponseBodyResultDescriptionsResultDescription() {}

  explicit DescribeApiResponseBodyResultDescriptionsResultDescription(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (hasChild) {
      res["HasChild"] = boost::any(*hasChild);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (mandatory) {
      res["Mandatory"] = boost::any(*mandatory);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (pid) {
      res["Pid"] = boost::any(*pid);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("HasChild") != m.end() && !m["HasChild"].empty()) {
      hasChild = make_shared<bool>(boost::any_cast<bool>(m["HasChild"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Mandatory") != m.end() && !m["Mandatory"].empty()) {
      mandatory = make_shared<bool>(boost::any_cast<bool>(m["Mandatory"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Pid") != m.end() && !m["Pid"].empty()) {
      pid = make_shared<string>(boost::any_cast<string>(m["Pid"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DescribeApiResponseBodyResultDescriptionsResultDescription() = default;
};
class DescribeApiResponseBodyResultDescriptions : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeApiResponseBodyResultDescriptionsResultDescription>> resultDescription{};

  DescribeApiResponseBodyResultDescriptions() {}

  explicit DescribeApiResponseBodyResultDescriptions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resultDescription) {
      vector<boost::any> temp1;
      for(auto item1:*resultDescription){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ResultDescription"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResultDescription") != m.end() && !m["ResultDescription"].empty()) {
      if (typeid(vector<boost::any>) == m["ResultDescription"].type()) {
        vector<DescribeApiResponseBodyResultDescriptionsResultDescription> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ResultDescription"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeApiResponseBodyResultDescriptionsResultDescription model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        resultDescription = make_shared<vector<DescribeApiResponseBodyResultDescriptionsResultDescription>>(expect1);
      }
    }
  }


  virtual ~DescribeApiResponseBodyResultDescriptions() = default;
};
class DescribeApiResponseBodyServiceConfigFunctionComputeConfig : public Darabonba::Model {
public:
  shared_ptr<string> contentTypeCatagory{};
  shared_ptr<string> contentTypeValue{};
  shared_ptr<string> fcBaseUrl{};
  shared_ptr<string> fcType{};
  shared_ptr<string> functionName{};
  shared_ptr<string> method{};
  shared_ptr<bool> onlyBusinessPath{};
  shared_ptr<string> path{};
  shared_ptr<string> qualifier{};
  shared_ptr<string> regionId{};
  shared_ptr<string> roleArn{};
  shared_ptr<string> serviceName{};

  DescribeApiResponseBodyServiceConfigFunctionComputeConfig() {}

  explicit DescribeApiResponseBodyServiceConfigFunctionComputeConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contentTypeCatagory) {
      res["ContentTypeCatagory"] = boost::any(*contentTypeCatagory);
    }
    if (contentTypeValue) {
      res["ContentTypeValue"] = boost::any(*contentTypeValue);
    }
    if (fcBaseUrl) {
      res["FcBaseUrl"] = boost::any(*fcBaseUrl);
    }
    if (fcType) {
      res["FcType"] = boost::any(*fcType);
    }
    if (functionName) {
      res["FunctionName"] = boost::any(*functionName);
    }
    if (method) {
      res["Method"] = boost::any(*method);
    }
    if (onlyBusinessPath) {
      res["OnlyBusinessPath"] = boost::any(*onlyBusinessPath);
    }
    if (path) {
      res["Path"] = boost::any(*path);
    }
    if (qualifier) {
      res["Qualifier"] = boost::any(*qualifier);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (roleArn) {
      res["RoleArn"] = boost::any(*roleArn);
    }
    if (serviceName) {
      res["ServiceName"] = boost::any(*serviceName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ContentTypeCatagory") != m.end() && !m["ContentTypeCatagory"].empty()) {
      contentTypeCatagory = make_shared<string>(boost::any_cast<string>(m["ContentTypeCatagory"]));
    }
    if (m.find("ContentTypeValue") != m.end() && !m["ContentTypeValue"].empty()) {
      contentTypeValue = make_shared<string>(boost::any_cast<string>(m["ContentTypeValue"]));
    }
    if (m.find("FcBaseUrl") != m.end() && !m["FcBaseUrl"].empty()) {
      fcBaseUrl = make_shared<string>(boost::any_cast<string>(m["FcBaseUrl"]));
    }
    if (m.find("FcType") != m.end() && !m["FcType"].empty()) {
      fcType = make_shared<string>(boost::any_cast<string>(m["FcType"]));
    }
    if (m.find("FunctionName") != m.end() && !m["FunctionName"].empty()) {
      functionName = make_shared<string>(boost::any_cast<string>(m["FunctionName"]));
    }
    if (m.find("Method") != m.end() && !m["Method"].empty()) {
      method = make_shared<string>(boost::any_cast<string>(m["Method"]));
    }
    if (m.find("OnlyBusinessPath") != m.end() && !m["OnlyBusinessPath"].empty()) {
      onlyBusinessPath = make_shared<bool>(boost::any_cast<bool>(m["OnlyBusinessPath"]));
    }
    if (m.find("Path") != m.end() && !m["Path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["Path"]));
    }
    if (m.find("Qualifier") != m.end() && !m["Qualifier"].empty()) {
      qualifier = make_shared<string>(boost::any_cast<string>(m["Qualifier"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("RoleArn") != m.end() && !m["RoleArn"].empty()) {
      roleArn = make_shared<string>(boost::any_cast<string>(m["RoleArn"]));
    }
    if (m.find("ServiceName") != m.end() && !m["ServiceName"].empty()) {
      serviceName = make_shared<string>(boost::any_cast<string>(m["ServiceName"]));
    }
  }


  virtual ~DescribeApiResponseBodyServiceConfigFunctionComputeConfig() = default;
};
class DescribeApiResponseBodyServiceConfigMockHeadersMockHeader : public Darabonba::Model {
public:
  shared_ptr<string> headerName{};
  shared_ptr<string> headerValue{};

  DescribeApiResponseBodyServiceConfigMockHeadersMockHeader() {}

  explicit DescribeApiResponseBodyServiceConfigMockHeadersMockHeader(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headerName) {
      res["HeaderName"] = boost::any(*headerName);
    }
    if (headerValue) {
      res["HeaderValue"] = boost::any(*headerValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HeaderName") != m.end() && !m["HeaderName"].empty()) {
      headerName = make_shared<string>(boost::any_cast<string>(m["HeaderName"]));
    }
    if (m.find("HeaderValue") != m.end() && !m["HeaderValue"].empty()) {
      headerValue = make_shared<string>(boost::any_cast<string>(m["HeaderValue"]));
    }
  }


  virtual ~DescribeApiResponseBodyServiceConfigMockHeadersMockHeader() = default;
};
class DescribeApiResponseBodyServiceConfigMockHeaders : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeApiResponseBodyServiceConfigMockHeadersMockHeader>> mockHeader{};

  DescribeApiResponseBodyServiceConfigMockHeaders() {}

  explicit DescribeApiResponseBodyServiceConfigMockHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mockHeader) {
      vector<boost::any> temp1;
      for(auto item1:*mockHeader){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["MockHeader"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MockHeader") != m.end() && !m["MockHeader"].empty()) {
      if (typeid(vector<boost::any>) == m["MockHeader"].type()) {
        vector<DescribeApiResponseBodyServiceConfigMockHeadersMockHeader> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["MockHeader"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeApiResponseBodyServiceConfigMockHeadersMockHeader model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        mockHeader = make_shared<vector<DescribeApiResponseBodyServiceConfigMockHeadersMockHeader>>(expect1);
      }
    }
  }


  virtual ~DescribeApiResponseBodyServiceConfigMockHeaders() = default;
};
class DescribeApiResponseBodyServiceConfigOssConfig : public Darabonba::Model {
public:
  shared_ptr<string> action{};
  shared_ptr<string> bucketName{};
  shared_ptr<string> key{};
  shared_ptr<string> ossRegionId{};

  DescribeApiResponseBodyServiceConfigOssConfig() {}

  explicit DescribeApiResponseBodyServiceConfigOssConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (action) {
      res["Action"] = boost::any(*action);
    }
    if (bucketName) {
      res["BucketName"] = boost::any(*bucketName);
    }
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (ossRegionId) {
      res["OssRegionId"] = boost::any(*ossRegionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Action") != m.end() && !m["Action"].empty()) {
      action = make_shared<string>(boost::any_cast<string>(m["Action"]));
    }
    if (m.find("BucketName") != m.end() && !m["BucketName"].empty()) {
      bucketName = make_shared<string>(boost::any_cast<string>(m["BucketName"]));
    }
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("OssRegionId") != m.end() && !m["OssRegionId"].empty()) {
      ossRegionId = make_shared<string>(boost::any_cast<string>(m["OssRegionId"]));
    }
  }


  virtual ~DescribeApiResponseBodyServiceConfigOssConfig() = default;
};
class DescribeApiResponseBodyServiceConfigVpcConfig : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> name{};
  shared_ptr<long> port{};
  shared_ptr<string> vpcId{};
  shared_ptr<string> vpcScheme{};

  DescribeApiResponseBodyServiceConfigVpcConfig() {}

  explicit DescribeApiResponseBodyServiceConfigVpcConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    if (vpcScheme) {
      res["VpcScheme"] = boost::any(*vpcScheme);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<long>(boost::any_cast<long>(m["Port"]));
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
    if (m.find("VpcScheme") != m.end() && !m["VpcScheme"].empty()) {
      vpcScheme = make_shared<string>(boost::any_cast<string>(m["VpcScheme"]));
    }
  }


  virtual ~DescribeApiResponseBodyServiceConfigVpcConfig() = default;
};
class DescribeApiResponseBodyServiceConfig : public Darabonba::Model {
public:
  shared_ptr<string> aoneAppName{};
  shared_ptr<string> contentTypeCatagory{};
  shared_ptr<string> contentTypeValue{};
  shared_ptr<DescribeApiResponseBodyServiceConfigFunctionComputeConfig> functionComputeConfig{};
  shared_ptr<string> mock{};
  shared_ptr<DescribeApiResponseBodyServiceConfigMockHeaders> mockHeaders{};
  shared_ptr<string> mockResult{};
  shared_ptr<long> mockStatusCode{};
  shared_ptr<DescribeApiResponseBodyServiceConfigOssConfig> ossConfig{};
  shared_ptr<string> serviceAddress{};
  shared_ptr<string> serviceHttpMethod{};
  shared_ptr<string> servicePath{};
  shared_ptr<string> serviceProtocol{};
  shared_ptr<long> serviceTimeout{};
  shared_ptr<string> serviceVpcEnable{};
  shared_ptr<DescribeApiResponseBodyServiceConfigVpcConfig> vpcConfig{};

  DescribeApiResponseBodyServiceConfig() {}

  explicit DescribeApiResponseBodyServiceConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aoneAppName) {
      res["AoneAppName"] = boost::any(*aoneAppName);
    }
    if (contentTypeCatagory) {
      res["ContentTypeCatagory"] = boost::any(*contentTypeCatagory);
    }
    if (contentTypeValue) {
      res["ContentTypeValue"] = boost::any(*contentTypeValue);
    }
    if (functionComputeConfig) {
      res["FunctionComputeConfig"] = functionComputeConfig ? boost::any(functionComputeConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (mock) {
      res["Mock"] = boost::any(*mock);
    }
    if (mockHeaders) {
      res["MockHeaders"] = mockHeaders ? boost::any(mockHeaders->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (mockResult) {
      res["MockResult"] = boost::any(*mockResult);
    }
    if (mockStatusCode) {
      res["MockStatusCode"] = boost::any(*mockStatusCode);
    }
    if (ossConfig) {
      res["OssConfig"] = ossConfig ? boost::any(ossConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (serviceAddress) {
      res["ServiceAddress"] = boost::any(*serviceAddress);
    }
    if (serviceHttpMethod) {
      res["ServiceHttpMethod"] = boost::any(*serviceHttpMethod);
    }
    if (servicePath) {
      res["ServicePath"] = boost::any(*servicePath);
    }
    if (serviceProtocol) {
      res["ServiceProtocol"] = boost::any(*serviceProtocol);
    }
    if (serviceTimeout) {
      res["ServiceTimeout"] = boost::any(*serviceTimeout);
    }
    if (serviceVpcEnable) {
      res["ServiceVpcEnable"] = boost::any(*serviceVpcEnable);
    }
    if (vpcConfig) {
      res["VpcConfig"] = vpcConfig ? boost::any(vpcConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AoneAppName") != m.end() && !m["AoneAppName"].empty()) {
      aoneAppName = make_shared<string>(boost::any_cast<string>(m["AoneAppName"]));
    }
    if (m.find("ContentTypeCatagory") != m.end() && !m["ContentTypeCatagory"].empty()) {
      contentTypeCatagory = make_shared<string>(boost::any_cast<string>(m["ContentTypeCatagory"]));
    }
    if (m.find("ContentTypeValue") != m.end() && !m["ContentTypeValue"].empty()) {
      contentTypeValue = make_shared<string>(boost::any_cast<string>(m["ContentTypeValue"]));
    }
    if (m.find("FunctionComputeConfig") != m.end() && !m["FunctionComputeConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["FunctionComputeConfig"].type()) {
        DescribeApiResponseBodyServiceConfigFunctionComputeConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FunctionComputeConfig"]));
        functionComputeConfig = make_shared<DescribeApiResponseBodyServiceConfigFunctionComputeConfig>(model1);
      }
    }
    if (m.find("Mock") != m.end() && !m["Mock"].empty()) {
      mock = make_shared<string>(boost::any_cast<string>(m["Mock"]));
    }
    if (m.find("MockHeaders") != m.end() && !m["MockHeaders"].empty()) {
      if (typeid(map<string, boost::any>) == m["MockHeaders"].type()) {
        DescribeApiResponseBodyServiceConfigMockHeaders model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MockHeaders"]));
        mockHeaders = make_shared<DescribeApiResponseBodyServiceConfigMockHeaders>(model1);
      }
    }
    if (m.find("MockResult") != m.end() && !m["MockResult"].empty()) {
      mockResult = make_shared<string>(boost::any_cast<string>(m["MockResult"]));
    }
    if (m.find("MockStatusCode") != m.end() && !m["MockStatusCode"].empty()) {
      mockStatusCode = make_shared<long>(boost::any_cast<long>(m["MockStatusCode"]));
    }
    if (m.find("OssConfig") != m.end() && !m["OssConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["OssConfig"].type()) {
        DescribeApiResponseBodyServiceConfigOssConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OssConfig"]));
        ossConfig = make_shared<DescribeApiResponseBodyServiceConfigOssConfig>(model1);
      }
    }
    if (m.find("ServiceAddress") != m.end() && !m["ServiceAddress"].empty()) {
      serviceAddress = make_shared<string>(boost::any_cast<string>(m["ServiceAddress"]));
    }
    if (m.find("ServiceHttpMethod") != m.end() && !m["ServiceHttpMethod"].empty()) {
      serviceHttpMethod = make_shared<string>(boost::any_cast<string>(m["ServiceHttpMethod"]));
    }
    if (m.find("ServicePath") != m.end() && !m["ServicePath"].empty()) {
      servicePath = make_shared<string>(boost::any_cast<string>(m["ServicePath"]));
    }
    if (m.find("ServiceProtocol") != m.end() && !m["ServiceProtocol"].empty()) {
      serviceProtocol = make_shared<string>(boost::any_cast<string>(m["ServiceProtocol"]));
    }
    if (m.find("ServiceTimeout") != m.end() && !m["ServiceTimeout"].empty()) {
      serviceTimeout = make_shared<long>(boost::any_cast<long>(m["ServiceTimeout"]));
    }
    if (m.find("ServiceVpcEnable") != m.end() && !m["ServiceVpcEnable"].empty()) {
      serviceVpcEnable = make_shared<string>(boost::any_cast<string>(m["ServiceVpcEnable"]));
    }
    if (m.find("VpcConfig") != m.end() && !m["VpcConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["VpcConfig"].type()) {
        DescribeApiResponseBodyServiceConfigVpcConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["VpcConfig"]));
        vpcConfig = make_shared<DescribeApiResponseBodyServiceConfigVpcConfig>(model1);
      }
    }
  }


  virtual ~DescribeApiResponseBodyServiceConfig() = default;
};
class DescribeApiResponseBodyServiceParametersServiceParameter : public Darabonba::Model {
public:
  shared_ptr<string> location{};
  shared_ptr<string> parameterType{};
  shared_ptr<string> serviceParameterName{};

  DescribeApiResponseBodyServiceParametersServiceParameter() {}

  explicit DescribeApiResponseBodyServiceParametersServiceParameter(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (parameterType) {
      res["ParameterType"] = boost::any(*parameterType);
    }
    if (serviceParameterName) {
      res["ServiceParameterName"] = boost::any(*serviceParameterName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("ParameterType") != m.end() && !m["ParameterType"].empty()) {
      parameterType = make_shared<string>(boost::any_cast<string>(m["ParameterType"]));
    }
    if (m.find("ServiceParameterName") != m.end() && !m["ServiceParameterName"].empty()) {
      serviceParameterName = make_shared<string>(boost::any_cast<string>(m["ServiceParameterName"]));
    }
  }


  virtual ~DescribeApiResponseBodyServiceParametersServiceParameter() = default;
};
class DescribeApiResponseBodyServiceParameters : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeApiResponseBodyServiceParametersServiceParameter>> serviceParameter{};

  DescribeApiResponseBodyServiceParameters() {}

  explicit DescribeApiResponseBodyServiceParameters(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (serviceParameter) {
      vector<boost::any> temp1;
      for(auto item1:*serviceParameter){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ServiceParameter"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ServiceParameter") != m.end() && !m["ServiceParameter"].empty()) {
      if (typeid(vector<boost::any>) == m["ServiceParameter"].type()) {
        vector<DescribeApiResponseBodyServiceParametersServiceParameter> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ServiceParameter"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeApiResponseBodyServiceParametersServiceParameter model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        serviceParameter = make_shared<vector<DescribeApiResponseBodyServiceParametersServiceParameter>>(expect1);
      }
    }
  }


  virtual ~DescribeApiResponseBodyServiceParameters() = default;
};
class DescribeApiResponseBodyServiceParametersMapServiceParameterMap : public Darabonba::Model {
public:
  shared_ptr<string> requestParameterName{};
  shared_ptr<string> serviceParameterName{};

  DescribeApiResponseBodyServiceParametersMapServiceParameterMap() {}

  explicit DescribeApiResponseBodyServiceParametersMapServiceParameterMap(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestParameterName) {
      res["RequestParameterName"] = boost::any(*requestParameterName);
    }
    if (serviceParameterName) {
      res["ServiceParameterName"] = boost::any(*serviceParameterName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestParameterName") != m.end() && !m["RequestParameterName"].empty()) {
      requestParameterName = make_shared<string>(boost::any_cast<string>(m["RequestParameterName"]));
    }
    if (m.find("ServiceParameterName") != m.end() && !m["ServiceParameterName"].empty()) {
      serviceParameterName = make_shared<string>(boost::any_cast<string>(m["ServiceParameterName"]));
    }
  }


  virtual ~DescribeApiResponseBodyServiceParametersMapServiceParameterMap() = default;
};
class DescribeApiResponseBodyServiceParametersMap : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeApiResponseBodyServiceParametersMapServiceParameterMap>> serviceParameterMap{};

  DescribeApiResponseBodyServiceParametersMap() {}

  explicit DescribeApiResponseBodyServiceParametersMap(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (serviceParameterMap) {
      vector<boost::any> temp1;
      for(auto item1:*serviceParameterMap){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ServiceParameterMap"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ServiceParameterMap") != m.end() && !m["ServiceParameterMap"].empty()) {
      if (typeid(vector<boost::any>) == m["ServiceParameterMap"].type()) {
        vector<DescribeApiResponseBodyServiceParametersMapServiceParameterMap> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ServiceParameterMap"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeApiResponseBodyServiceParametersMapServiceParameterMap model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        serviceParameterMap = make_shared<vector<DescribeApiResponseBodyServiceParametersMapServiceParameterMap>>(expect1);
      }
    }
  }


  virtual ~DescribeApiResponseBodyServiceParametersMap() = default;
};
class DescribeApiResponseBodySystemParametersSystemParameter : public Darabonba::Model {
public:
  shared_ptr<string> demoValue{};
  shared_ptr<string> description{};
  shared_ptr<string> location{};
  shared_ptr<string> parameterName{};
  shared_ptr<string> serviceParameterName{};

  DescribeApiResponseBodySystemParametersSystemParameter() {}

  explicit DescribeApiResponseBodySystemParametersSystemParameter(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (demoValue) {
      res["DemoValue"] = boost::any(*demoValue);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (parameterName) {
      res["ParameterName"] = boost::any(*parameterName);
    }
    if (serviceParameterName) {
      res["ServiceParameterName"] = boost::any(*serviceParameterName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DemoValue") != m.end() && !m["DemoValue"].empty()) {
      demoValue = make_shared<string>(boost::any_cast<string>(m["DemoValue"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("ParameterName") != m.end() && !m["ParameterName"].empty()) {
      parameterName = make_shared<string>(boost::any_cast<string>(m["ParameterName"]));
    }
    if (m.find("ServiceParameterName") != m.end() && !m["ServiceParameterName"].empty()) {
      serviceParameterName = make_shared<string>(boost::any_cast<string>(m["ServiceParameterName"]));
    }
  }


  virtual ~DescribeApiResponseBodySystemParametersSystemParameter() = default;
};
class DescribeApiResponseBodySystemParameters : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeApiResponseBodySystemParametersSystemParameter>> systemParameter{};

  DescribeApiResponseBodySystemParameters() {}

  explicit DescribeApiResponseBodySystemParameters(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (systemParameter) {
      vector<boost::any> temp1;
      for(auto item1:*systemParameter){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SystemParameter"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SystemParameter") != m.end() && !m["SystemParameter"].empty()) {
      if (typeid(vector<boost::any>) == m["SystemParameter"].type()) {
        vector<DescribeApiResponseBodySystemParametersSystemParameter> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SystemParameter"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeApiResponseBodySystemParametersSystemParameter model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        systemParameter = make_shared<vector<DescribeApiResponseBodySystemParametersSystemParameter>>(expect1);
      }
    }
  }


  virtual ~DescribeApiResponseBodySystemParameters() = default;
};
class DescribeApiResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> allowSignatureMethod{};
  shared_ptr<string> apiId{};
  shared_ptr<string> apiName{};
  shared_ptr<string> appCodeAuthType{};
  shared_ptr<string> authType{};
  shared_ptr<DescribeApiResponseBodyConstantParameters> constantParameters{};
  shared_ptr<string> createdTime{};
  shared_ptr<DescribeApiResponseBodyCustomSystemParameters> customSystemParameters{};
  shared_ptr<DescribeApiResponseBodyDeployedInfos> deployedInfos{};
  shared_ptr<string> description{};
  shared_ptr<bool> disableInternet{};
  shared_ptr<DescribeApiResponseBodyErrorCodeSamples> errorCodeSamples{};
  shared_ptr<string> failResultSample{};
  shared_ptr<bool> forceNonceCheck{};
  shared_ptr<string> groupId{};
  shared_ptr<string> groupName{};
  shared_ptr<string> mock{};
  shared_ptr<string> mockResult{};
  shared_ptr<string> modifiedTime{};
  shared_ptr<DescribeApiResponseBodyOpenIdConnectConfig> openIdConnectConfig{};
  shared_ptr<string> regionId{};
  shared_ptr<DescribeApiResponseBodyRequestConfig> requestConfig{};
  shared_ptr<string> requestId{};
  shared_ptr<DescribeApiResponseBodyRequestParameters> requestParameters{};
  shared_ptr<string> resultBodyModel{};
  shared_ptr<DescribeApiResponseBodyResultDescriptions> resultDescriptions{};
  shared_ptr<string> resultSample{};
  shared_ptr<string> resultType{};
  shared_ptr<DescribeApiResponseBodyServiceConfig> serviceConfig{};
  shared_ptr<DescribeApiResponseBodyServiceParameters> serviceParameters{};
  shared_ptr<DescribeApiResponseBodyServiceParametersMap> serviceParametersMap{};
  shared_ptr<DescribeApiResponseBodySystemParameters> systemParameters{};
  shared_ptr<string> visibility{};
  shared_ptr<string> webSocketApiType{};

  DescribeApiResponseBody() {}

  explicit DescribeApiResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (allowSignatureMethod) {
      res["AllowSignatureMethod"] = boost::any(*allowSignatureMethod);
    }
    if (apiId) {
      res["ApiId"] = boost::any(*apiId);
    }
    if (apiName) {
      res["ApiName"] = boost::any(*apiName);
    }
    if (appCodeAuthType) {
      res["AppCodeAuthType"] = boost::any(*appCodeAuthType);
    }
    if (authType) {
      res["AuthType"] = boost::any(*authType);
    }
    if (constantParameters) {
      res["ConstantParameters"] = constantParameters ? boost::any(constantParameters->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (createdTime) {
      res["CreatedTime"] = boost::any(*createdTime);
    }
    if (customSystemParameters) {
      res["CustomSystemParameters"] = customSystemParameters ? boost::any(customSystemParameters->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (deployedInfos) {
      res["DeployedInfos"] = deployedInfos ? boost::any(deployedInfos->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (disableInternet) {
      res["DisableInternet"] = boost::any(*disableInternet);
    }
    if (errorCodeSamples) {
      res["ErrorCodeSamples"] = errorCodeSamples ? boost::any(errorCodeSamples->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (failResultSample) {
      res["FailResultSample"] = boost::any(*failResultSample);
    }
    if (forceNonceCheck) {
      res["ForceNonceCheck"] = boost::any(*forceNonceCheck);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (mock) {
      res["Mock"] = boost::any(*mock);
    }
    if (mockResult) {
      res["MockResult"] = boost::any(*mockResult);
    }
    if (modifiedTime) {
      res["ModifiedTime"] = boost::any(*modifiedTime);
    }
    if (openIdConnectConfig) {
      res["OpenIdConnectConfig"] = openIdConnectConfig ? boost::any(openIdConnectConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (requestConfig) {
      res["RequestConfig"] = requestConfig ? boost::any(requestConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (requestParameters) {
      res["RequestParameters"] = requestParameters ? boost::any(requestParameters->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (resultBodyModel) {
      res["ResultBodyModel"] = boost::any(*resultBodyModel);
    }
    if (resultDescriptions) {
      res["ResultDescriptions"] = resultDescriptions ? boost::any(resultDescriptions->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (resultSample) {
      res["ResultSample"] = boost::any(*resultSample);
    }
    if (resultType) {
      res["ResultType"] = boost::any(*resultType);
    }
    if (serviceConfig) {
      res["ServiceConfig"] = serviceConfig ? boost::any(serviceConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (serviceParameters) {
      res["ServiceParameters"] = serviceParameters ? boost::any(serviceParameters->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (serviceParametersMap) {
      res["ServiceParametersMap"] = serviceParametersMap ? boost::any(serviceParametersMap->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (systemParameters) {
      res["SystemParameters"] = systemParameters ? boost::any(systemParameters->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (visibility) {
      res["Visibility"] = boost::any(*visibility);
    }
    if (webSocketApiType) {
      res["WebSocketApiType"] = boost::any(*webSocketApiType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AllowSignatureMethod") != m.end() && !m["AllowSignatureMethod"].empty()) {
      allowSignatureMethod = make_shared<string>(boost::any_cast<string>(m["AllowSignatureMethod"]));
    }
    if (m.find("ApiId") != m.end() && !m["ApiId"].empty()) {
      apiId = make_shared<string>(boost::any_cast<string>(m["ApiId"]));
    }
    if (m.find("ApiName") != m.end() && !m["ApiName"].empty()) {
      apiName = make_shared<string>(boost::any_cast<string>(m["ApiName"]));
    }
    if (m.find("AppCodeAuthType") != m.end() && !m["AppCodeAuthType"].empty()) {
      appCodeAuthType = make_shared<string>(boost::any_cast<string>(m["AppCodeAuthType"]));
    }
    if (m.find("AuthType") != m.end() && !m["AuthType"].empty()) {
      authType = make_shared<string>(boost::any_cast<string>(m["AuthType"]));
    }
    if (m.find("ConstantParameters") != m.end() && !m["ConstantParameters"].empty()) {
      if (typeid(map<string, boost::any>) == m["ConstantParameters"].type()) {
        DescribeApiResponseBodyConstantParameters model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ConstantParameters"]));
        constantParameters = make_shared<DescribeApiResponseBodyConstantParameters>(model1);
      }
    }
    if (m.find("CreatedTime") != m.end() && !m["CreatedTime"].empty()) {
      createdTime = make_shared<string>(boost::any_cast<string>(m["CreatedTime"]));
    }
    if (m.find("CustomSystemParameters") != m.end() && !m["CustomSystemParameters"].empty()) {
      if (typeid(map<string, boost::any>) == m["CustomSystemParameters"].type()) {
        DescribeApiResponseBodyCustomSystemParameters model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CustomSystemParameters"]));
        customSystemParameters = make_shared<DescribeApiResponseBodyCustomSystemParameters>(model1);
      }
    }
    if (m.find("DeployedInfos") != m.end() && !m["DeployedInfos"].empty()) {
      if (typeid(map<string, boost::any>) == m["DeployedInfos"].type()) {
        DescribeApiResponseBodyDeployedInfos model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DeployedInfos"]));
        deployedInfos = make_shared<DescribeApiResponseBodyDeployedInfos>(model1);
      }
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DisableInternet") != m.end() && !m["DisableInternet"].empty()) {
      disableInternet = make_shared<bool>(boost::any_cast<bool>(m["DisableInternet"]));
    }
    if (m.find("ErrorCodeSamples") != m.end() && !m["ErrorCodeSamples"].empty()) {
      if (typeid(map<string, boost::any>) == m["ErrorCodeSamples"].type()) {
        DescribeApiResponseBodyErrorCodeSamples model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ErrorCodeSamples"]));
        errorCodeSamples = make_shared<DescribeApiResponseBodyErrorCodeSamples>(model1);
      }
    }
    if (m.find("FailResultSample") != m.end() && !m["FailResultSample"].empty()) {
      failResultSample = make_shared<string>(boost::any_cast<string>(m["FailResultSample"]));
    }
    if (m.find("ForceNonceCheck") != m.end() && !m["ForceNonceCheck"].empty()) {
      forceNonceCheck = make_shared<bool>(boost::any_cast<bool>(m["ForceNonceCheck"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("Mock") != m.end() && !m["Mock"].empty()) {
      mock = make_shared<string>(boost::any_cast<string>(m["Mock"]));
    }
    if (m.find("MockResult") != m.end() && !m["MockResult"].empty()) {
      mockResult = make_shared<string>(boost::any_cast<string>(m["MockResult"]));
    }
    if (m.find("ModifiedTime") != m.end() && !m["ModifiedTime"].empty()) {
      modifiedTime = make_shared<string>(boost::any_cast<string>(m["ModifiedTime"]));
    }
    if (m.find("OpenIdConnectConfig") != m.end() && !m["OpenIdConnectConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["OpenIdConnectConfig"].type()) {
        DescribeApiResponseBodyOpenIdConnectConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OpenIdConnectConfig"]));
        openIdConnectConfig = make_shared<DescribeApiResponseBodyOpenIdConnectConfig>(model1);
      }
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("RequestConfig") != m.end() && !m["RequestConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["RequestConfig"].type()) {
        DescribeApiResponseBodyRequestConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RequestConfig"]));
        requestConfig = make_shared<DescribeApiResponseBodyRequestConfig>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("RequestParameters") != m.end() && !m["RequestParameters"].empty()) {
      if (typeid(map<string, boost::any>) == m["RequestParameters"].type()) {
        DescribeApiResponseBodyRequestParameters model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RequestParameters"]));
        requestParameters = make_shared<DescribeApiResponseBodyRequestParameters>(model1);
      }
    }
    if (m.find("ResultBodyModel") != m.end() && !m["ResultBodyModel"].empty()) {
      resultBodyModel = make_shared<string>(boost::any_cast<string>(m["ResultBodyModel"]));
    }
    if (m.find("ResultDescriptions") != m.end() && !m["ResultDescriptions"].empty()) {
      if (typeid(map<string, boost::any>) == m["ResultDescriptions"].type()) {
        DescribeApiResponseBodyResultDescriptions model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ResultDescriptions"]));
        resultDescriptions = make_shared<DescribeApiResponseBodyResultDescriptions>(model1);
      }
    }
    if (m.find("ResultSample") != m.end() && !m["ResultSample"].empty()) {
      resultSample = make_shared<string>(boost::any_cast<string>(m["ResultSample"]));
    }
    if (m.find("ResultType") != m.end() && !m["ResultType"].empty()) {
      resultType = make_shared<string>(boost::any_cast<string>(m["ResultType"]));
    }
    if (m.find("ServiceConfig") != m.end() && !m["ServiceConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["ServiceConfig"].type()) {
        DescribeApiResponseBodyServiceConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ServiceConfig"]));
        serviceConfig = make_shared<DescribeApiResponseBodyServiceConfig>(model1);
      }
    }
    if (m.find("ServiceParameters") != m.end() && !m["ServiceParameters"].empty()) {
      if (typeid(map<string, boost::any>) == m["ServiceParameters"].type()) {
        DescribeApiResponseBodyServiceParameters model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ServiceParameters"]));
        serviceParameters = make_shared<DescribeApiResponseBodyServiceParameters>(model1);
      }
    }
    if (m.find("ServiceParametersMap") != m.end() && !m["ServiceParametersMap"].empty()) {
      if (typeid(map<string, boost::any>) == m["ServiceParametersMap"].type()) {
        DescribeApiResponseBodyServiceParametersMap model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ServiceParametersMap"]));
        serviceParametersMap = make_shared<DescribeApiResponseBodyServiceParametersMap>(model1);
      }
    }
    if (m.find("SystemParameters") != m.end() && !m["SystemParameters"].empty()) {
      if (typeid(map<string, boost::any>) == m["SystemParameters"].type()) {
        DescribeApiResponseBodySystemParameters model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SystemParameters"]));
        systemParameters = make_shared<DescribeApiResponseBodySystemParameters>(model1);
      }
    }
    if (m.find("Visibility") != m.end() && !m["Visibility"].empty()) {
      visibility = make_shared<string>(boost::any_cast<string>(m["Visibility"]));
    }
    if (m.find("WebSocketApiType") != m.end() && !m["WebSocketApiType"].empty()) {
      webSocketApiType = make_shared<string>(boost::any_cast<string>(m["WebSocketApiType"]));
    }
  }


  virtual ~DescribeApiResponseBody() = default;
};
class DescribeApiResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeApiResponseBody> body{};

  DescribeApiResponse() {}

  explicit DescribeApiResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeApiResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeApiResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeApiResponse() = default;
};
class DescribeApiDocRequest : public Darabonba::Model {
public:
  shared_ptr<string> apiId{};
  shared_ptr<string> groupId{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> stageName{};

  DescribeApiDocRequest() {}

  explicit DescribeApiDocRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiId) {
      res["ApiId"] = boost::any(*apiId);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (stageName) {
      res["StageName"] = boost::any(*stageName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiId") != m.end() && !m["ApiId"].empty()) {
      apiId = make_shared<string>(boost::any_cast<string>(m["ApiId"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("StageName") != m.end() && !m["StageName"].empty()) {
      stageName = make_shared<string>(boost::any_cast<string>(m["StageName"]));
    }
  }


  virtual ~DescribeApiDocRequest() = default;
};
class DescribeApiDocResponseBodyErrorCodeSamplesErrorCodeSample : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> description{};
  shared_ptr<string> message{};

  DescribeApiDocResponseBodyErrorCodeSamplesErrorCodeSample() {}

  explicit DescribeApiDocResponseBodyErrorCodeSamplesErrorCodeSample(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
  }


  virtual ~DescribeApiDocResponseBodyErrorCodeSamplesErrorCodeSample() = default;
};
class DescribeApiDocResponseBodyErrorCodeSamples : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeApiDocResponseBodyErrorCodeSamplesErrorCodeSample>> errorCodeSample{};

  DescribeApiDocResponseBodyErrorCodeSamples() {}

  explicit DescribeApiDocResponseBodyErrorCodeSamples(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCodeSample) {
      vector<boost::any> temp1;
      for(auto item1:*errorCodeSample){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ErrorCodeSample"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCodeSample") != m.end() && !m["ErrorCodeSample"].empty()) {
      if (typeid(vector<boost::any>) == m["ErrorCodeSample"].type()) {
        vector<DescribeApiDocResponseBodyErrorCodeSamplesErrorCodeSample> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ErrorCodeSample"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeApiDocResponseBodyErrorCodeSamplesErrorCodeSample model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        errorCodeSample = make_shared<vector<DescribeApiDocResponseBodyErrorCodeSamplesErrorCodeSample>>(expect1);
      }
    }
  }


  virtual ~DescribeApiDocResponseBodyErrorCodeSamples() = default;
};
class DescribeApiDocResponseBodyRequestConfig : public Darabonba::Model {
public:
  shared_ptr<string> bodyFormat{};
  shared_ptr<string> postBodyDescription{};
  shared_ptr<string> requestHttpMethod{};
  shared_ptr<string> requestMode{};
  shared_ptr<string> requestPath{};
  shared_ptr<string> requestProtocol{};

  DescribeApiDocResponseBodyRequestConfig() {}

  explicit DescribeApiDocResponseBodyRequestConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bodyFormat) {
      res["BodyFormat"] = boost::any(*bodyFormat);
    }
    if (postBodyDescription) {
      res["PostBodyDescription"] = boost::any(*postBodyDescription);
    }
    if (requestHttpMethod) {
      res["RequestHttpMethod"] = boost::any(*requestHttpMethod);
    }
    if (requestMode) {
      res["RequestMode"] = boost::any(*requestMode);
    }
    if (requestPath) {
      res["RequestPath"] = boost::any(*requestPath);
    }
    if (requestProtocol) {
      res["RequestProtocol"] = boost::any(*requestProtocol);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BodyFormat") != m.end() && !m["BodyFormat"].empty()) {
      bodyFormat = make_shared<string>(boost::any_cast<string>(m["BodyFormat"]));
    }
    if (m.find("PostBodyDescription") != m.end() && !m["PostBodyDescription"].empty()) {
      postBodyDescription = make_shared<string>(boost::any_cast<string>(m["PostBodyDescription"]));
    }
    if (m.find("RequestHttpMethod") != m.end() && !m["RequestHttpMethod"].empty()) {
      requestHttpMethod = make_shared<string>(boost::any_cast<string>(m["RequestHttpMethod"]));
    }
    if (m.find("RequestMode") != m.end() && !m["RequestMode"].empty()) {
      requestMode = make_shared<string>(boost::any_cast<string>(m["RequestMode"]));
    }
    if (m.find("RequestPath") != m.end() && !m["RequestPath"].empty()) {
      requestPath = make_shared<string>(boost::any_cast<string>(m["RequestPath"]));
    }
    if (m.find("RequestProtocol") != m.end() && !m["RequestProtocol"].empty()) {
      requestProtocol = make_shared<string>(boost::any_cast<string>(m["RequestProtocol"]));
    }
  }


  virtual ~DescribeApiDocResponseBodyRequestConfig() = default;
};
class DescribeApiDocResponseBodyRequestParametersRequestParameter : public Darabonba::Model {
public:
  shared_ptr<string> apiParameterName{};
  shared_ptr<string> arrayItemsType{};
  shared_ptr<string> defaultValue{};
  shared_ptr<string> demoValue{};
  shared_ptr<string> description{};
  shared_ptr<long> docOrder{};
  shared_ptr<string> docShow{};
  shared_ptr<string> enumValue{};
  shared_ptr<string> jsonScheme{};
  shared_ptr<string> location{};
  shared_ptr<long> maxLength{};
  shared_ptr<long> maxValue{};
  shared_ptr<long> minLength{};
  shared_ptr<long> minValue{};
  shared_ptr<string> parameterType{};
  shared_ptr<string> regularExpression{};
  shared_ptr<string> required{};

  DescribeApiDocResponseBodyRequestParametersRequestParameter() {}

  explicit DescribeApiDocResponseBodyRequestParametersRequestParameter(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiParameterName) {
      res["ApiParameterName"] = boost::any(*apiParameterName);
    }
    if (arrayItemsType) {
      res["ArrayItemsType"] = boost::any(*arrayItemsType);
    }
    if (defaultValue) {
      res["DefaultValue"] = boost::any(*defaultValue);
    }
    if (demoValue) {
      res["DemoValue"] = boost::any(*demoValue);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (docOrder) {
      res["DocOrder"] = boost::any(*docOrder);
    }
    if (docShow) {
      res["DocShow"] = boost::any(*docShow);
    }
    if (enumValue) {
      res["EnumValue"] = boost::any(*enumValue);
    }
    if (jsonScheme) {
      res["JsonScheme"] = boost::any(*jsonScheme);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (maxLength) {
      res["MaxLength"] = boost::any(*maxLength);
    }
    if (maxValue) {
      res["MaxValue"] = boost::any(*maxValue);
    }
    if (minLength) {
      res["MinLength"] = boost::any(*minLength);
    }
    if (minValue) {
      res["MinValue"] = boost::any(*minValue);
    }
    if (parameterType) {
      res["ParameterType"] = boost::any(*parameterType);
    }
    if (regularExpression) {
      res["RegularExpression"] = boost::any(*regularExpression);
    }
    if (required) {
      res["Required"] = boost::any(*required);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiParameterName") != m.end() && !m["ApiParameterName"].empty()) {
      apiParameterName = make_shared<string>(boost::any_cast<string>(m["ApiParameterName"]));
    }
    if (m.find("ArrayItemsType") != m.end() && !m["ArrayItemsType"].empty()) {
      arrayItemsType = make_shared<string>(boost::any_cast<string>(m["ArrayItemsType"]));
    }
    if (m.find("DefaultValue") != m.end() && !m["DefaultValue"].empty()) {
      defaultValue = make_shared<string>(boost::any_cast<string>(m["DefaultValue"]));
    }
    if (m.find("DemoValue") != m.end() && !m["DemoValue"].empty()) {
      demoValue = make_shared<string>(boost::any_cast<string>(m["DemoValue"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DocOrder") != m.end() && !m["DocOrder"].empty()) {
      docOrder = make_shared<long>(boost::any_cast<long>(m["DocOrder"]));
    }
    if (m.find("DocShow") != m.end() && !m["DocShow"].empty()) {
      docShow = make_shared<string>(boost::any_cast<string>(m["DocShow"]));
    }
    if (m.find("EnumValue") != m.end() && !m["EnumValue"].empty()) {
      enumValue = make_shared<string>(boost::any_cast<string>(m["EnumValue"]));
    }
    if (m.find("JsonScheme") != m.end() && !m["JsonScheme"].empty()) {
      jsonScheme = make_shared<string>(boost::any_cast<string>(m["JsonScheme"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("MaxLength") != m.end() && !m["MaxLength"].empty()) {
      maxLength = make_shared<long>(boost::any_cast<long>(m["MaxLength"]));
    }
    if (m.find("MaxValue") != m.end() && !m["MaxValue"].empty()) {
      maxValue = make_shared<long>(boost::any_cast<long>(m["MaxValue"]));
    }
    if (m.find("MinLength") != m.end() && !m["MinLength"].empty()) {
      minLength = make_shared<long>(boost::any_cast<long>(m["MinLength"]));
    }
    if (m.find("MinValue") != m.end() && !m["MinValue"].empty()) {
      minValue = make_shared<long>(boost::any_cast<long>(m["MinValue"]));
    }
    if (m.find("ParameterType") != m.end() && !m["ParameterType"].empty()) {
      parameterType = make_shared<string>(boost::any_cast<string>(m["ParameterType"]));
    }
    if (m.find("RegularExpression") != m.end() && !m["RegularExpression"].empty()) {
      regularExpression = make_shared<string>(boost::any_cast<string>(m["RegularExpression"]));
    }
    if (m.find("Required") != m.end() && !m["Required"].empty()) {
      required = make_shared<string>(boost::any_cast<string>(m["Required"]));
    }
  }


  virtual ~DescribeApiDocResponseBodyRequestParametersRequestParameter() = default;
};
class DescribeApiDocResponseBodyRequestParameters : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeApiDocResponseBodyRequestParametersRequestParameter>> requestParameter{};

  DescribeApiDocResponseBodyRequestParameters() {}

  explicit DescribeApiDocResponseBodyRequestParameters(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestParameter) {
      vector<boost::any> temp1;
      for(auto item1:*requestParameter){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RequestParameter"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestParameter") != m.end() && !m["RequestParameter"].empty()) {
      if (typeid(vector<boost::any>) == m["RequestParameter"].type()) {
        vector<DescribeApiDocResponseBodyRequestParametersRequestParameter> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RequestParameter"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeApiDocResponseBodyRequestParametersRequestParameter model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        requestParameter = make_shared<vector<DescribeApiDocResponseBodyRequestParametersRequestParameter>>(expect1);
      }
    }
  }


  virtual ~DescribeApiDocResponseBodyRequestParameters() = default;
};
class DescribeApiDocResponseBodyResultDescriptionsResultDescription : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<bool> hasChild{};
  shared_ptr<string> id{};
  shared_ptr<string> key{};
  shared_ptr<bool> mandatory{};
  shared_ptr<string> name{};
  shared_ptr<string> pid{};
  shared_ptr<string> type{};

  DescribeApiDocResponseBodyResultDescriptionsResultDescription() {}

  explicit DescribeApiDocResponseBodyResultDescriptionsResultDescription(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (hasChild) {
      res["HasChild"] = boost::any(*hasChild);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (mandatory) {
      res["Mandatory"] = boost::any(*mandatory);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (pid) {
      res["Pid"] = boost::any(*pid);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("HasChild") != m.end() && !m["HasChild"].empty()) {
      hasChild = make_shared<bool>(boost::any_cast<bool>(m["HasChild"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Mandatory") != m.end() && !m["Mandatory"].empty()) {
      mandatory = make_shared<bool>(boost::any_cast<bool>(m["Mandatory"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Pid") != m.end() && !m["Pid"].empty()) {
      pid = make_shared<string>(boost::any_cast<string>(m["Pid"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DescribeApiDocResponseBodyResultDescriptionsResultDescription() = default;
};
class DescribeApiDocResponseBodyResultDescriptions : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeApiDocResponseBodyResultDescriptionsResultDescription>> resultDescription{};

  DescribeApiDocResponseBodyResultDescriptions() {}

  explicit DescribeApiDocResponseBodyResultDescriptions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resultDescription) {
      vector<boost::any> temp1;
      for(auto item1:*resultDescription){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ResultDescription"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResultDescription") != m.end() && !m["ResultDescription"].empty()) {
      if (typeid(vector<boost::any>) == m["ResultDescription"].type()) {
        vector<DescribeApiDocResponseBodyResultDescriptionsResultDescription> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ResultDescription"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeApiDocResponseBodyResultDescriptionsResultDescription model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        resultDescription = make_shared<vector<DescribeApiDocResponseBodyResultDescriptionsResultDescription>>(expect1);
      }
    }
  }


  virtual ~DescribeApiDocResponseBodyResultDescriptions() = default;
};
class DescribeApiDocResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> apiId{};
  shared_ptr<string> apiName{};
  shared_ptr<string> authType{};
  shared_ptr<string> deployedTime{};
  shared_ptr<string> description{};
  shared_ptr<bool> disableInternet{};
  shared_ptr<DescribeApiDocResponseBodyErrorCodeSamples> errorCodeSamples{};
  shared_ptr<string> failResultSample{};
  shared_ptr<bool> forceNonceCheck{};
  shared_ptr<string> groupId{};
  shared_ptr<string> groupName{};
  shared_ptr<string> regionId{};
  shared_ptr<DescribeApiDocResponseBodyRequestConfig> requestConfig{};
  shared_ptr<string> requestId{};
  shared_ptr<DescribeApiDocResponseBodyRequestParameters> requestParameters{};
  shared_ptr<DescribeApiDocResponseBodyResultDescriptions> resultDescriptions{};
  shared_ptr<string> resultSample{};
  shared_ptr<string> resultType{};
  shared_ptr<string> stageName{};
  shared_ptr<string> visibility{};

  DescribeApiDocResponseBody() {}

  explicit DescribeApiDocResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiId) {
      res["ApiId"] = boost::any(*apiId);
    }
    if (apiName) {
      res["ApiName"] = boost::any(*apiName);
    }
    if (authType) {
      res["AuthType"] = boost::any(*authType);
    }
    if (deployedTime) {
      res["DeployedTime"] = boost::any(*deployedTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (disableInternet) {
      res["DisableInternet"] = boost::any(*disableInternet);
    }
    if (errorCodeSamples) {
      res["ErrorCodeSamples"] = errorCodeSamples ? boost::any(errorCodeSamples->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (failResultSample) {
      res["FailResultSample"] = boost::any(*failResultSample);
    }
    if (forceNonceCheck) {
      res["ForceNonceCheck"] = boost::any(*forceNonceCheck);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (requestConfig) {
      res["RequestConfig"] = requestConfig ? boost::any(requestConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (requestParameters) {
      res["RequestParameters"] = requestParameters ? boost::any(requestParameters->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (resultDescriptions) {
      res["ResultDescriptions"] = resultDescriptions ? boost::any(resultDescriptions->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (resultSample) {
      res["ResultSample"] = boost::any(*resultSample);
    }
    if (resultType) {
      res["ResultType"] = boost::any(*resultType);
    }
    if (stageName) {
      res["StageName"] = boost::any(*stageName);
    }
    if (visibility) {
      res["Visibility"] = boost::any(*visibility);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiId") != m.end() && !m["ApiId"].empty()) {
      apiId = make_shared<string>(boost::any_cast<string>(m["ApiId"]));
    }
    if (m.find("ApiName") != m.end() && !m["ApiName"].empty()) {
      apiName = make_shared<string>(boost::any_cast<string>(m["ApiName"]));
    }
    if (m.find("AuthType") != m.end() && !m["AuthType"].empty()) {
      authType = make_shared<string>(boost::any_cast<string>(m["AuthType"]));
    }
    if (m.find("DeployedTime") != m.end() && !m["DeployedTime"].empty()) {
      deployedTime = make_shared<string>(boost::any_cast<string>(m["DeployedTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DisableInternet") != m.end() && !m["DisableInternet"].empty()) {
      disableInternet = make_shared<bool>(boost::any_cast<bool>(m["DisableInternet"]));
    }
    if (m.find("ErrorCodeSamples") != m.end() && !m["ErrorCodeSamples"].empty()) {
      if (typeid(map<string, boost::any>) == m["ErrorCodeSamples"].type()) {
        DescribeApiDocResponseBodyErrorCodeSamples model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ErrorCodeSamples"]));
        errorCodeSamples = make_shared<DescribeApiDocResponseBodyErrorCodeSamples>(model1);
      }
    }
    if (m.find("FailResultSample") != m.end() && !m["FailResultSample"].empty()) {
      failResultSample = make_shared<string>(boost::any_cast<string>(m["FailResultSample"]));
    }
    if (m.find("ForceNonceCheck") != m.end() && !m["ForceNonceCheck"].empty()) {
      forceNonceCheck = make_shared<bool>(boost::any_cast<bool>(m["ForceNonceCheck"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("RequestConfig") != m.end() && !m["RequestConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["RequestConfig"].type()) {
        DescribeApiDocResponseBodyRequestConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RequestConfig"]));
        requestConfig = make_shared<DescribeApiDocResponseBodyRequestConfig>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("RequestParameters") != m.end() && !m["RequestParameters"].empty()) {
      if (typeid(map<string, boost::any>) == m["RequestParameters"].type()) {
        DescribeApiDocResponseBodyRequestParameters model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RequestParameters"]));
        requestParameters = make_shared<DescribeApiDocResponseBodyRequestParameters>(model1);
      }
    }
    if (m.find("ResultDescriptions") != m.end() && !m["ResultDescriptions"].empty()) {
      if (typeid(map<string, boost::any>) == m["ResultDescriptions"].type()) {
        DescribeApiDocResponseBodyResultDescriptions model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ResultDescriptions"]));
        resultDescriptions = make_shared<DescribeApiDocResponseBodyResultDescriptions>(model1);
      }
    }
    if (m.find("ResultSample") != m.end() && !m["ResultSample"].empty()) {
      resultSample = make_shared<string>(boost::any_cast<string>(m["ResultSample"]));
    }
    if (m.find("ResultType") != m.end() && !m["ResultType"].empty()) {
      resultType = make_shared<string>(boost::any_cast<string>(m["ResultType"]));
    }
    if (m.find("StageName") != m.end() && !m["StageName"].empty()) {
      stageName = make_shared<string>(boost::any_cast<string>(m["StageName"]));
    }
    if (m.find("Visibility") != m.end() && !m["Visibility"].empty()) {
      visibility = make_shared<string>(boost::any_cast<string>(m["Visibility"]));
    }
  }


  virtual ~DescribeApiDocResponseBody() = default;
};
class DescribeApiDocResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeApiDocResponseBody> body{};

  DescribeApiDocResponse() {}

  explicit DescribeApiDocResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeApiDocResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeApiDocResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeApiDocResponse() = default;
};
class DescribeApiGroupRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  DescribeApiGroupRequestTag() {}

  explicit DescribeApiGroupRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeApiGroupRequestTag() = default;
};
class DescribeApiGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> groupId{};
  shared_ptr<string> securityToken{};
  shared_ptr<vector<DescribeApiGroupRequestTag>> tag{};

  DescribeApiGroupRequest() {}

  explicit DescribeApiGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<DescribeApiGroupRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeApiGroupRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<DescribeApiGroupRequestTag>>(expect1);
      }
    }
  }


  virtual ~DescribeApiGroupRequest() = default;
};
class DescribeApiGroupResponseBodyCustomDomainsDomainItem : public Darabonba::Model {
public:
  shared_ptr<string> bindStageName{};
  shared_ptr<string> certificateId{};
  shared_ptr<string> certificateName{};
  shared_ptr<string> customDomainType{};
  shared_ptr<string> domainBindingStatus{};
  shared_ptr<string> domainCNAMEStatus{};
  shared_ptr<string> domainLegalStatus{};
  shared_ptr<string> domainName{};
  shared_ptr<string> domainRemark{};
  shared_ptr<string> domainWebSocketStatus{};
  shared_ptr<string> wildcardDomainPatterns{};

  DescribeApiGroupResponseBodyCustomDomainsDomainItem() {}

  explicit DescribeApiGroupResponseBodyCustomDomainsDomainItem(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bindStageName) {
      res["BindStageName"] = boost::any(*bindStageName);
    }
    if (certificateId) {
      res["CertificateId"] = boost::any(*certificateId);
    }
    if (certificateName) {
      res["CertificateName"] = boost::any(*certificateName);
    }
    if (customDomainType) {
      res["CustomDomainType"] = boost::any(*customDomainType);
    }
    if (domainBindingStatus) {
      res["DomainBindingStatus"] = boost::any(*domainBindingStatus);
    }
    if (domainCNAMEStatus) {
      res["DomainCNAMEStatus"] = boost::any(*domainCNAMEStatus);
    }
    if (domainLegalStatus) {
      res["DomainLegalStatus"] = boost::any(*domainLegalStatus);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (domainRemark) {
      res["DomainRemark"] = boost::any(*domainRemark);
    }
    if (domainWebSocketStatus) {
      res["DomainWebSocketStatus"] = boost::any(*domainWebSocketStatus);
    }
    if (wildcardDomainPatterns) {
      res["WildcardDomainPatterns"] = boost::any(*wildcardDomainPatterns);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BindStageName") != m.end() && !m["BindStageName"].empty()) {
      bindStageName = make_shared<string>(boost::any_cast<string>(m["BindStageName"]));
    }
    if (m.find("CertificateId") != m.end() && !m["CertificateId"].empty()) {
      certificateId = make_shared<string>(boost::any_cast<string>(m["CertificateId"]));
    }
    if (m.find("CertificateName") != m.end() && !m["CertificateName"].empty()) {
      certificateName = make_shared<string>(boost::any_cast<string>(m["CertificateName"]));
    }
    if (m.find("CustomDomainType") != m.end() && !m["CustomDomainType"].empty()) {
      customDomainType = make_shared<string>(boost::any_cast<string>(m["CustomDomainType"]));
    }
    if (m.find("DomainBindingStatus") != m.end() && !m["DomainBindingStatus"].empty()) {
      domainBindingStatus = make_shared<string>(boost::any_cast<string>(m["DomainBindingStatus"]));
    }
    if (m.find("DomainCNAMEStatus") != m.end() && !m["DomainCNAMEStatus"].empty()) {
      domainCNAMEStatus = make_shared<string>(boost::any_cast<string>(m["DomainCNAMEStatus"]));
    }
    if (m.find("DomainLegalStatus") != m.end() && !m["DomainLegalStatus"].empty()) {
      domainLegalStatus = make_shared<string>(boost::any_cast<string>(m["DomainLegalStatus"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("DomainRemark") != m.end() && !m["DomainRemark"].empty()) {
      domainRemark = make_shared<string>(boost::any_cast<string>(m["DomainRemark"]));
    }
    if (m.find("DomainWebSocketStatus") != m.end() && !m["DomainWebSocketStatus"].empty()) {
      domainWebSocketStatus = make_shared<string>(boost::any_cast<string>(m["DomainWebSocketStatus"]));
    }
    if (m.find("WildcardDomainPatterns") != m.end() && !m["WildcardDomainPatterns"].empty()) {
      wildcardDomainPatterns = make_shared<string>(boost::any_cast<string>(m["WildcardDomainPatterns"]));
    }
  }


  virtual ~DescribeApiGroupResponseBodyCustomDomainsDomainItem() = default;
};
class DescribeApiGroupResponseBodyCustomDomains : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeApiGroupResponseBodyCustomDomainsDomainItem>> domainItem{};

  DescribeApiGroupResponseBodyCustomDomains() {}

  explicit DescribeApiGroupResponseBodyCustomDomains(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainItem) {
      vector<boost::any> temp1;
      for(auto item1:*domainItem){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DomainItem"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainItem") != m.end() && !m["DomainItem"].empty()) {
      if (typeid(vector<boost::any>) == m["DomainItem"].type()) {
        vector<DescribeApiGroupResponseBodyCustomDomainsDomainItem> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DomainItem"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeApiGroupResponseBodyCustomDomainsDomainItem model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        domainItem = make_shared<vector<DescribeApiGroupResponseBodyCustomDomainsDomainItem>>(expect1);
      }
    }
  }


  virtual ~DescribeApiGroupResponseBodyCustomDomains() = default;
};
class DescribeApiGroupResponseBodyStageItemsStageInfo : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> stageId{};
  shared_ptr<string> stageName{};

  DescribeApiGroupResponseBodyStageItemsStageInfo() {}

  explicit DescribeApiGroupResponseBodyStageItemsStageInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (stageId) {
      res["StageId"] = boost::any(*stageId);
    }
    if (stageName) {
      res["StageName"] = boost::any(*stageName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("StageId") != m.end() && !m["StageId"].empty()) {
      stageId = make_shared<string>(boost::any_cast<string>(m["StageId"]));
    }
    if (m.find("StageName") != m.end() && !m["StageName"].empty()) {
      stageName = make_shared<string>(boost::any_cast<string>(m["StageName"]));
    }
  }


  virtual ~DescribeApiGroupResponseBodyStageItemsStageInfo() = default;
};
class DescribeApiGroupResponseBodyStageItems : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeApiGroupResponseBodyStageItemsStageInfo>> stageInfo{};

  DescribeApiGroupResponseBodyStageItems() {}

  explicit DescribeApiGroupResponseBodyStageItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (stageInfo) {
      vector<boost::any> temp1;
      for(auto item1:*stageInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["StageInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("StageInfo") != m.end() && !m["StageInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["StageInfo"].type()) {
        vector<DescribeApiGroupResponseBodyStageItemsStageInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["StageInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeApiGroupResponseBodyStageItemsStageInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        stageInfo = make_shared<vector<DescribeApiGroupResponseBodyStageItemsStageInfo>>(expect1);
      }
    }
  }


  virtual ~DescribeApiGroupResponseBodyStageItems() = default;
};
class DescribeApiGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> basePath{};
  shared_ptr<string> billingStatus{};
  shared_ptr<string> classicVpcSubDomain{};
  shared_ptr<string> cmsMonitorGroup{};
  shared_ptr<string> compatibleFlags{};
  shared_ptr<string> createdTime{};
  shared_ptr<DescribeApiGroupResponseBodyCustomDomains> customDomains{};
  shared_ptr<string> customTraceConfig{};
  shared_ptr<string> customerConfigs{};
  shared_ptr<string> defaultDomain{};
  shared_ptr<string> description{};
  shared_ptr<string> groupId{};
  shared_ptr<string> groupName{};
  shared_ptr<string> httpsPolicy{};
  shared_ptr<string> illegalStatus{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> instanceType{};
  shared_ptr<string> instanceVipList{};
  shared_ptr<string> ipv6Status{};
  shared_ptr<string> modifiedTime{};
  shared_ptr<string> passthroughHeaders{};
  shared_ptr<string> regionId{};
  shared_ptr<string> requestId{};
  shared_ptr<string> rpcPattern{};
  shared_ptr<DescribeApiGroupResponseBodyStageItems> stageItems{};
  shared_ptr<string> status{};
  shared_ptr<string> subDomain{};
  shared_ptr<long> trafficLimit{};
  shared_ptr<string> userLogConfig{};
  shared_ptr<string> vpcDomain{};
  shared_ptr<string> vpcSlbIntranetDomain{};

  DescribeApiGroupResponseBody() {}

  explicit DescribeApiGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (basePath) {
      res["BasePath"] = boost::any(*basePath);
    }
    if (billingStatus) {
      res["BillingStatus"] = boost::any(*billingStatus);
    }
    if (classicVpcSubDomain) {
      res["ClassicVpcSubDomain"] = boost::any(*classicVpcSubDomain);
    }
    if (cmsMonitorGroup) {
      res["CmsMonitorGroup"] = boost::any(*cmsMonitorGroup);
    }
    if (compatibleFlags) {
      res["CompatibleFlags"] = boost::any(*compatibleFlags);
    }
    if (createdTime) {
      res["CreatedTime"] = boost::any(*createdTime);
    }
    if (customDomains) {
      res["CustomDomains"] = customDomains ? boost::any(customDomains->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (customTraceConfig) {
      res["CustomTraceConfig"] = boost::any(*customTraceConfig);
    }
    if (customerConfigs) {
      res["CustomerConfigs"] = boost::any(*customerConfigs);
    }
    if (defaultDomain) {
      res["DefaultDomain"] = boost::any(*defaultDomain);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (httpsPolicy) {
      res["HttpsPolicy"] = boost::any(*httpsPolicy);
    }
    if (illegalStatus) {
      res["IllegalStatus"] = boost::any(*illegalStatus);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (instanceVipList) {
      res["InstanceVipList"] = boost::any(*instanceVipList);
    }
    if (ipv6Status) {
      res["Ipv6Status"] = boost::any(*ipv6Status);
    }
    if (modifiedTime) {
      res["ModifiedTime"] = boost::any(*modifiedTime);
    }
    if (passthroughHeaders) {
      res["PassthroughHeaders"] = boost::any(*passthroughHeaders);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (rpcPattern) {
      res["RpcPattern"] = boost::any(*rpcPattern);
    }
    if (stageItems) {
      res["StageItems"] = stageItems ? boost::any(stageItems->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (subDomain) {
      res["SubDomain"] = boost::any(*subDomain);
    }
    if (trafficLimit) {
      res["TrafficLimit"] = boost::any(*trafficLimit);
    }
    if (userLogConfig) {
      res["UserLogConfig"] = boost::any(*userLogConfig);
    }
    if (vpcDomain) {
      res["VpcDomain"] = boost::any(*vpcDomain);
    }
    if (vpcSlbIntranetDomain) {
      res["VpcSlbIntranetDomain"] = boost::any(*vpcSlbIntranetDomain);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BasePath") != m.end() && !m["BasePath"].empty()) {
      basePath = make_shared<string>(boost::any_cast<string>(m["BasePath"]));
    }
    if (m.find("BillingStatus") != m.end() && !m["BillingStatus"].empty()) {
      billingStatus = make_shared<string>(boost::any_cast<string>(m["BillingStatus"]));
    }
    if (m.find("ClassicVpcSubDomain") != m.end() && !m["ClassicVpcSubDomain"].empty()) {
      classicVpcSubDomain = make_shared<string>(boost::any_cast<string>(m["ClassicVpcSubDomain"]));
    }
    if (m.find("CmsMonitorGroup") != m.end() && !m["CmsMonitorGroup"].empty()) {
      cmsMonitorGroup = make_shared<string>(boost::any_cast<string>(m["CmsMonitorGroup"]));
    }
    if (m.find("CompatibleFlags") != m.end() && !m["CompatibleFlags"].empty()) {
      compatibleFlags = make_shared<string>(boost::any_cast<string>(m["CompatibleFlags"]));
    }
    if (m.find("CreatedTime") != m.end() && !m["CreatedTime"].empty()) {
      createdTime = make_shared<string>(boost::any_cast<string>(m["CreatedTime"]));
    }
    if (m.find("CustomDomains") != m.end() && !m["CustomDomains"].empty()) {
      if (typeid(map<string, boost::any>) == m["CustomDomains"].type()) {
        DescribeApiGroupResponseBodyCustomDomains model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CustomDomains"]));
        customDomains = make_shared<DescribeApiGroupResponseBodyCustomDomains>(model1);
      }
    }
    if (m.find("CustomTraceConfig") != m.end() && !m["CustomTraceConfig"].empty()) {
      customTraceConfig = make_shared<string>(boost::any_cast<string>(m["CustomTraceConfig"]));
    }
    if (m.find("CustomerConfigs") != m.end() && !m["CustomerConfigs"].empty()) {
      customerConfigs = make_shared<string>(boost::any_cast<string>(m["CustomerConfigs"]));
    }
    if (m.find("DefaultDomain") != m.end() && !m["DefaultDomain"].empty()) {
      defaultDomain = make_shared<string>(boost::any_cast<string>(m["DefaultDomain"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("HttpsPolicy") != m.end() && !m["HttpsPolicy"].empty()) {
      httpsPolicy = make_shared<string>(boost::any_cast<string>(m["HttpsPolicy"]));
    }
    if (m.find("IllegalStatus") != m.end() && !m["IllegalStatus"].empty()) {
      illegalStatus = make_shared<string>(boost::any_cast<string>(m["IllegalStatus"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("InstanceVipList") != m.end() && !m["InstanceVipList"].empty()) {
      instanceVipList = make_shared<string>(boost::any_cast<string>(m["InstanceVipList"]));
    }
    if (m.find("Ipv6Status") != m.end() && !m["Ipv6Status"].empty()) {
      ipv6Status = make_shared<string>(boost::any_cast<string>(m["Ipv6Status"]));
    }
    if (m.find("ModifiedTime") != m.end() && !m["ModifiedTime"].empty()) {
      modifiedTime = make_shared<string>(boost::any_cast<string>(m["ModifiedTime"]));
    }
    if (m.find("PassthroughHeaders") != m.end() && !m["PassthroughHeaders"].empty()) {
      passthroughHeaders = make_shared<string>(boost::any_cast<string>(m["PassthroughHeaders"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("RpcPattern") != m.end() && !m["RpcPattern"].empty()) {
      rpcPattern = make_shared<string>(boost::any_cast<string>(m["RpcPattern"]));
    }
    if (m.find("StageItems") != m.end() && !m["StageItems"].empty()) {
      if (typeid(map<string, boost::any>) == m["StageItems"].type()) {
        DescribeApiGroupResponseBodyStageItems model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["StageItems"]));
        stageItems = make_shared<DescribeApiGroupResponseBodyStageItems>(model1);
      }
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("SubDomain") != m.end() && !m["SubDomain"].empty()) {
      subDomain = make_shared<string>(boost::any_cast<string>(m["SubDomain"]));
    }
    if (m.find("TrafficLimit") != m.end() && !m["TrafficLimit"].empty()) {
      trafficLimit = make_shared<long>(boost::any_cast<long>(m["TrafficLimit"]));
    }
    if (m.find("UserLogConfig") != m.end() && !m["UserLogConfig"].empty()) {
      userLogConfig = make_shared<string>(boost::any_cast<string>(m["UserLogConfig"]));
    }
    if (m.find("VpcDomain") != m.end() && !m["VpcDomain"].empty()) {
      vpcDomain = make_shared<string>(boost::any_cast<string>(m["VpcDomain"]));
    }
    if (m.find("VpcSlbIntranetDomain") != m.end() && !m["VpcSlbIntranetDomain"].empty()) {
      vpcSlbIntranetDomain = make_shared<string>(boost::any_cast<string>(m["VpcSlbIntranetDomain"]));
    }
  }


  virtual ~DescribeApiGroupResponseBody() = default;
};
class DescribeApiGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeApiGroupResponseBody> body{};

  DescribeApiGroupResponse() {}

  explicit DescribeApiGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeApiGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeApiGroupResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeApiGroupResponse() = default;
};
class DescribeApiGroupVpcWhitelistRequest : public Darabonba::Model {
public:
  shared_ptr<string> groupId{};
  shared_ptr<string> securityToken{};

  DescribeApiGroupVpcWhitelistRequest() {}

  explicit DescribeApiGroupVpcWhitelistRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~DescribeApiGroupVpcWhitelistRequest() = default;
};
class DescribeApiGroupVpcWhitelistResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> vpcIds{};

  DescribeApiGroupVpcWhitelistResponseBody() {}

  explicit DescribeApiGroupVpcWhitelistResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (vpcIds) {
      res["VpcIds"] = boost::any(*vpcIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("VpcIds") != m.end() && !m["VpcIds"].empty()) {
      vpcIds = make_shared<string>(boost::any_cast<string>(m["VpcIds"]));
    }
  }


  virtual ~DescribeApiGroupVpcWhitelistResponseBody() = default;
};
class DescribeApiGroupVpcWhitelistResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeApiGroupVpcWhitelistResponseBody> body{};

  DescribeApiGroupVpcWhitelistResponse() {}

  explicit DescribeApiGroupVpcWhitelistResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeApiGroupVpcWhitelistResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeApiGroupVpcWhitelistResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeApiGroupVpcWhitelistResponse() = default;
};
class DescribeApiGroupsRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  DescribeApiGroupsRequestTag() {}

  explicit DescribeApiGroupsRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeApiGroupsRequestTag() = default;
};
class DescribeApiGroupsRequest : public Darabonba::Model {
public:
  shared_ptr<bool> enableTagAuth{};
  shared_ptr<string> groupId{};
  shared_ptr<string> groupName{};
  shared_ptr<string> instanceId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> sort{};
  shared_ptr<vector<DescribeApiGroupsRequestTag>> tag{};

  DescribeApiGroupsRequest() {}

  explicit DescribeApiGroupsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (enableTagAuth) {
      res["EnableTagAuth"] = boost::any(*enableTagAuth);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (sort) {
      res["Sort"] = boost::any(*sort);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EnableTagAuth") != m.end() && !m["EnableTagAuth"].empty()) {
      enableTagAuth = make_shared<bool>(boost::any_cast<bool>(m["EnableTagAuth"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("Sort") != m.end() && !m["Sort"].empty()) {
      sort = make_shared<string>(boost::any_cast<string>(m["Sort"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<DescribeApiGroupsRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeApiGroupsRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<DescribeApiGroupsRequestTag>>(expect1);
      }
    }
  }


  virtual ~DescribeApiGroupsRequest() = default;
};
class DescribeApiGroupsResponseBodyApiGroupAttributesApiGroupAttributeTagsTagInfo : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  DescribeApiGroupsResponseBodyApiGroupAttributesApiGroupAttributeTagsTagInfo() {}

  explicit DescribeApiGroupsResponseBodyApiGroupAttributesApiGroupAttributeTagsTagInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeApiGroupsResponseBodyApiGroupAttributesApiGroupAttributeTagsTagInfo() = default;
};
class DescribeApiGroupsResponseBodyApiGroupAttributesApiGroupAttributeTags : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeApiGroupsResponseBodyApiGroupAttributesApiGroupAttributeTagsTagInfo>> tagInfo{};

  DescribeApiGroupsResponseBodyApiGroupAttributesApiGroupAttributeTags() {}

  explicit DescribeApiGroupsResponseBodyApiGroupAttributesApiGroupAttributeTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tagInfo) {
      vector<boost::any> temp1;
      for(auto item1:*tagInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TagInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TagInfo") != m.end() && !m["TagInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["TagInfo"].type()) {
        vector<DescribeApiGroupsResponseBodyApiGroupAttributesApiGroupAttributeTagsTagInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TagInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeApiGroupsResponseBodyApiGroupAttributesApiGroupAttributeTagsTagInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tagInfo = make_shared<vector<DescribeApiGroupsResponseBodyApiGroupAttributesApiGroupAttributeTagsTagInfo>>(expect1);
      }
    }
  }


  virtual ~DescribeApiGroupsResponseBodyApiGroupAttributesApiGroupAttributeTags() = default;
};
class DescribeApiGroupsResponseBodyApiGroupAttributesApiGroupAttribute : public Darabonba::Model {
public:
  shared_ptr<string> basePath{};
  shared_ptr<string> billingStatus{};
  shared_ptr<string> createdTime{};
  shared_ptr<string> description{};
  shared_ptr<string> groupId{};
  shared_ptr<string> groupName{};
  shared_ptr<string> httpsPolicy{};
  shared_ptr<string> illegalStatus{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> instanceType{};
  shared_ptr<string> modifiedTime{};
  shared_ptr<string> regionId{};
  shared_ptr<string> subDomain{};
  shared_ptr<DescribeApiGroupsResponseBodyApiGroupAttributesApiGroupAttributeTags> tags{};
  shared_ptr<long> trafficLimit{};

  DescribeApiGroupsResponseBodyApiGroupAttributesApiGroupAttribute() {}

  explicit DescribeApiGroupsResponseBodyApiGroupAttributesApiGroupAttribute(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (basePath) {
      res["BasePath"] = boost::any(*basePath);
    }
    if (billingStatus) {
      res["BillingStatus"] = boost::any(*billingStatus);
    }
    if (createdTime) {
      res["CreatedTime"] = boost::any(*createdTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (httpsPolicy) {
      res["HttpsPolicy"] = boost::any(*httpsPolicy);
    }
    if (illegalStatus) {
      res["IllegalStatus"] = boost::any(*illegalStatus);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (modifiedTime) {
      res["ModifiedTime"] = boost::any(*modifiedTime);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (subDomain) {
      res["SubDomain"] = boost::any(*subDomain);
    }
    if (tags) {
      res["Tags"] = tags ? boost::any(tags->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (trafficLimit) {
      res["TrafficLimit"] = boost::any(*trafficLimit);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BasePath") != m.end() && !m["BasePath"].empty()) {
      basePath = make_shared<string>(boost::any_cast<string>(m["BasePath"]));
    }
    if (m.find("BillingStatus") != m.end() && !m["BillingStatus"].empty()) {
      billingStatus = make_shared<string>(boost::any_cast<string>(m["BillingStatus"]));
    }
    if (m.find("CreatedTime") != m.end() && !m["CreatedTime"].empty()) {
      createdTime = make_shared<string>(boost::any_cast<string>(m["CreatedTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("HttpsPolicy") != m.end() && !m["HttpsPolicy"].empty()) {
      httpsPolicy = make_shared<string>(boost::any_cast<string>(m["HttpsPolicy"]));
    }
    if (m.find("IllegalStatus") != m.end() && !m["IllegalStatus"].empty()) {
      illegalStatus = make_shared<string>(boost::any_cast<string>(m["IllegalStatus"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("ModifiedTime") != m.end() && !m["ModifiedTime"].empty()) {
      modifiedTime = make_shared<string>(boost::any_cast<string>(m["ModifiedTime"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SubDomain") != m.end() && !m["SubDomain"].empty()) {
      subDomain = make_shared<string>(boost::any_cast<string>(m["SubDomain"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(map<string, boost::any>) == m["Tags"].type()) {
        DescribeApiGroupsResponseBodyApiGroupAttributesApiGroupAttributeTags model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Tags"]));
        tags = make_shared<DescribeApiGroupsResponseBodyApiGroupAttributesApiGroupAttributeTags>(model1);
      }
    }
    if (m.find("TrafficLimit") != m.end() && !m["TrafficLimit"].empty()) {
      trafficLimit = make_shared<long>(boost::any_cast<long>(m["TrafficLimit"]));
    }
  }


  virtual ~DescribeApiGroupsResponseBodyApiGroupAttributesApiGroupAttribute() = default;
};
class DescribeApiGroupsResponseBodyApiGroupAttributes : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeApiGroupsResponseBodyApiGroupAttributesApiGroupAttribute>> apiGroupAttribute{};

  DescribeApiGroupsResponseBodyApiGroupAttributes() {}

  explicit DescribeApiGroupsResponseBodyApiGroupAttributes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiGroupAttribute) {
      vector<boost::any> temp1;
      for(auto item1:*apiGroupAttribute){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ApiGroupAttribute"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiGroupAttribute") != m.end() && !m["ApiGroupAttribute"].empty()) {
      if (typeid(vector<boost::any>) == m["ApiGroupAttribute"].type()) {
        vector<DescribeApiGroupsResponseBodyApiGroupAttributesApiGroupAttribute> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ApiGroupAttribute"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeApiGroupsResponseBodyApiGroupAttributesApiGroupAttribute model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        apiGroupAttribute = make_shared<vector<DescribeApiGroupsResponseBodyApiGroupAttributesApiGroupAttribute>>(expect1);
      }
    }
  }


  virtual ~DescribeApiGroupsResponseBodyApiGroupAttributes() = default;
};
class DescribeApiGroupsResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeApiGroupsResponseBodyApiGroupAttributes> apiGroupAttributes{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeApiGroupsResponseBody() {}

  explicit DescribeApiGroupsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiGroupAttributes) {
      res["ApiGroupAttributes"] = apiGroupAttributes ? boost::any(apiGroupAttributes->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiGroupAttributes") != m.end() && !m["ApiGroupAttributes"].empty()) {
      if (typeid(map<string, boost::any>) == m["ApiGroupAttributes"].type()) {
        DescribeApiGroupsResponseBodyApiGroupAttributes model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ApiGroupAttributes"]));
        apiGroupAttributes = make_shared<DescribeApiGroupsResponseBodyApiGroupAttributes>(model1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeApiGroupsResponseBody() = default;
};
class DescribeApiGroupsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeApiGroupsResponseBody> body{};

  DescribeApiGroupsResponse() {}

  explicit DescribeApiGroupsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeApiGroupsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeApiGroupsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeApiGroupsResponse() = default;
};
class DescribeApiHistoriesRequest : public Darabonba::Model {
public:
  shared_ptr<string> apiId{};
  shared_ptr<string> apiName{};
  shared_ptr<string> groupId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> stageName{};

  DescribeApiHistoriesRequest() {}

  explicit DescribeApiHistoriesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiId) {
      res["ApiId"] = boost::any(*apiId);
    }
    if (apiName) {
      res["ApiName"] = boost::any(*apiName);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (stageName) {
      res["StageName"] = boost::any(*stageName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiId") != m.end() && !m["ApiId"].empty()) {
      apiId = make_shared<string>(boost::any_cast<string>(m["ApiId"]));
    }
    if (m.find("ApiName") != m.end() && !m["ApiName"].empty()) {
      apiName = make_shared<string>(boost::any_cast<string>(m["ApiName"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("StageName") != m.end() && !m["StageName"].empty()) {
      stageName = make_shared<string>(boost::any_cast<string>(m["StageName"]));
    }
  }


  virtual ~DescribeApiHistoriesRequest() = default;
};
class DescribeApiHistoriesResponseBodyApiHisItemsApiHisItem : public Darabonba::Model {
public:
  shared_ptr<string> apiId{};
  shared_ptr<string> apiName{};
  shared_ptr<string> deployedTime{};
  shared_ptr<string> description{};
  shared_ptr<string> groupId{};
  shared_ptr<string> groupName{};
  shared_ptr<string> historyVersion{};
  shared_ptr<string> regionId{};
  shared_ptr<string> stageName{};
  shared_ptr<string> status{};

  DescribeApiHistoriesResponseBodyApiHisItemsApiHisItem() {}

  explicit DescribeApiHistoriesResponseBodyApiHisItemsApiHisItem(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiId) {
      res["ApiId"] = boost::any(*apiId);
    }
    if (apiName) {
      res["ApiName"] = boost::any(*apiName);
    }
    if (deployedTime) {
      res["DeployedTime"] = boost::any(*deployedTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (historyVersion) {
      res["HistoryVersion"] = boost::any(*historyVersion);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (stageName) {
      res["StageName"] = boost::any(*stageName);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiId") != m.end() && !m["ApiId"].empty()) {
      apiId = make_shared<string>(boost::any_cast<string>(m["ApiId"]));
    }
    if (m.find("ApiName") != m.end() && !m["ApiName"].empty()) {
      apiName = make_shared<string>(boost::any_cast<string>(m["ApiName"]));
    }
    if (m.find("DeployedTime") != m.end() && !m["DeployedTime"].empty()) {
      deployedTime = make_shared<string>(boost::any_cast<string>(m["DeployedTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("HistoryVersion") != m.end() && !m["HistoryVersion"].empty()) {
      historyVersion = make_shared<string>(boost::any_cast<string>(m["HistoryVersion"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("StageName") != m.end() && !m["StageName"].empty()) {
      stageName = make_shared<string>(boost::any_cast<string>(m["StageName"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeApiHistoriesResponseBodyApiHisItemsApiHisItem() = default;
};
class DescribeApiHistoriesResponseBodyApiHisItems : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeApiHistoriesResponseBodyApiHisItemsApiHisItem>> apiHisItem{};

  DescribeApiHistoriesResponseBodyApiHisItems() {}

  explicit DescribeApiHistoriesResponseBodyApiHisItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiHisItem) {
      vector<boost::any> temp1;
      for(auto item1:*apiHisItem){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ApiHisItem"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiHisItem") != m.end() && !m["ApiHisItem"].empty()) {
      if (typeid(vector<boost::any>) == m["ApiHisItem"].type()) {
        vector<DescribeApiHistoriesResponseBodyApiHisItemsApiHisItem> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ApiHisItem"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeApiHistoriesResponseBodyApiHisItemsApiHisItem model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        apiHisItem = make_shared<vector<DescribeApiHistoriesResponseBodyApiHisItemsApiHisItem>>(expect1);
      }
    }
  }


  virtual ~DescribeApiHistoriesResponseBodyApiHisItems() = default;
};
class DescribeApiHistoriesResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeApiHistoriesResponseBodyApiHisItems> apiHisItems{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeApiHistoriesResponseBody() {}

  explicit DescribeApiHistoriesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiHisItems) {
      res["ApiHisItems"] = apiHisItems ? boost::any(apiHisItems->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiHisItems") != m.end() && !m["ApiHisItems"].empty()) {
      if (typeid(map<string, boost::any>) == m["ApiHisItems"].type()) {
        DescribeApiHistoriesResponseBodyApiHisItems model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ApiHisItems"]));
        apiHisItems = make_shared<DescribeApiHistoriesResponseBodyApiHisItems>(model1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeApiHistoriesResponseBody() = default;
};
class DescribeApiHistoriesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeApiHistoriesResponseBody> body{};

  DescribeApiHistoriesResponse() {}

  explicit DescribeApiHistoriesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeApiHistoriesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeApiHistoriesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeApiHistoriesResponse() = default;
};
class DescribeApiHistoryRequest : public Darabonba::Model {
public:
  shared_ptr<string> apiId{};
  shared_ptr<string> groupId{};
  shared_ptr<string> historyVersion{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> stageName{};

  DescribeApiHistoryRequest() {}

  explicit DescribeApiHistoryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiId) {
      res["ApiId"] = boost::any(*apiId);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (historyVersion) {
      res["HistoryVersion"] = boost::any(*historyVersion);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (stageName) {
      res["StageName"] = boost::any(*stageName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiId") != m.end() && !m["ApiId"].empty()) {
      apiId = make_shared<string>(boost::any_cast<string>(m["ApiId"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("HistoryVersion") != m.end() && !m["HistoryVersion"].empty()) {
      historyVersion = make_shared<string>(boost::any_cast<string>(m["HistoryVersion"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("StageName") != m.end() && !m["StageName"].empty()) {
      stageName = make_shared<string>(boost::any_cast<string>(m["StageName"]));
    }
  }


  virtual ~DescribeApiHistoryRequest() = default;
};
class DescribeApiHistoryResponseBodyConstantParametersConstantParameter : public Darabonba::Model {
public:
  shared_ptr<string> constantValue{};
  shared_ptr<string> description{};
  shared_ptr<string> location{};
  shared_ptr<string> serviceParameterName{};

  DescribeApiHistoryResponseBodyConstantParametersConstantParameter() {}

  explicit DescribeApiHistoryResponseBodyConstantParametersConstantParameter(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (constantValue) {
      res["ConstantValue"] = boost::any(*constantValue);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (serviceParameterName) {
      res["ServiceParameterName"] = boost::any(*serviceParameterName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConstantValue") != m.end() && !m["ConstantValue"].empty()) {
      constantValue = make_shared<string>(boost::any_cast<string>(m["ConstantValue"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("ServiceParameterName") != m.end() && !m["ServiceParameterName"].empty()) {
      serviceParameterName = make_shared<string>(boost::any_cast<string>(m["ServiceParameterName"]));
    }
  }


  virtual ~DescribeApiHistoryResponseBodyConstantParametersConstantParameter() = default;
};
class DescribeApiHistoryResponseBodyConstantParameters : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeApiHistoryResponseBodyConstantParametersConstantParameter>> constantParameter{};

  DescribeApiHistoryResponseBodyConstantParameters() {}

  explicit DescribeApiHistoryResponseBodyConstantParameters(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (constantParameter) {
      vector<boost::any> temp1;
      for(auto item1:*constantParameter){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ConstantParameter"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConstantParameter") != m.end() && !m["ConstantParameter"].empty()) {
      if (typeid(vector<boost::any>) == m["ConstantParameter"].type()) {
        vector<DescribeApiHistoryResponseBodyConstantParametersConstantParameter> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ConstantParameter"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeApiHistoryResponseBodyConstantParametersConstantParameter model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        constantParameter = make_shared<vector<DescribeApiHistoryResponseBodyConstantParametersConstantParameter>>(expect1);
      }
    }
  }


  virtual ~DescribeApiHistoryResponseBodyConstantParameters() = default;
};
class DescribeApiHistoryResponseBodyCustomSystemParametersCustomSystemParameter : public Darabonba::Model {
public:
  shared_ptr<string> demoValue{};
  shared_ptr<string> description{};
  shared_ptr<string> location{};
  shared_ptr<string> parameterName{};
  shared_ptr<string> serviceParameterName{};

  DescribeApiHistoryResponseBodyCustomSystemParametersCustomSystemParameter() {}

  explicit DescribeApiHistoryResponseBodyCustomSystemParametersCustomSystemParameter(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (demoValue) {
      res["DemoValue"] = boost::any(*demoValue);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (parameterName) {
      res["ParameterName"] = boost::any(*parameterName);
    }
    if (serviceParameterName) {
      res["ServiceParameterName"] = boost::any(*serviceParameterName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DemoValue") != m.end() && !m["DemoValue"].empty()) {
      demoValue = make_shared<string>(boost::any_cast<string>(m["DemoValue"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("ParameterName") != m.end() && !m["ParameterName"].empty()) {
      parameterName = make_shared<string>(boost::any_cast<string>(m["ParameterName"]));
    }
    if (m.find("ServiceParameterName") != m.end() && !m["ServiceParameterName"].empty()) {
      serviceParameterName = make_shared<string>(boost::any_cast<string>(m["ServiceParameterName"]));
    }
  }


  virtual ~DescribeApiHistoryResponseBodyCustomSystemParametersCustomSystemParameter() = default;
};
class DescribeApiHistoryResponseBodyCustomSystemParameters : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeApiHistoryResponseBodyCustomSystemParametersCustomSystemParameter>> customSystemParameter{};

  DescribeApiHistoryResponseBodyCustomSystemParameters() {}

  explicit DescribeApiHistoryResponseBodyCustomSystemParameters(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (customSystemParameter) {
      vector<boost::any> temp1;
      for(auto item1:*customSystemParameter){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CustomSystemParameter"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CustomSystemParameter") != m.end() && !m["CustomSystemParameter"].empty()) {
      if (typeid(vector<boost::any>) == m["CustomSystemParameter"].type()) {
        vector<DescribeApiHistoryResponseBodyCustomSystemParametersCustomSystemParameter> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CustomSystemParameter"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeApiHistoryResponseBodyCustomSystemParametersCustomSystemParameter model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        customSystemParameter = make_shared<vector<DescribeApiHistoryResponseBodyCustomSystemParametersCustomSystemParameter>>(expect1);
      }
    }
  }


  virtual ~DescribeApiHistoryResponseBodyCustomSystemParameters() = default;
};
class DescribeApiHistoryResponseBodyErrorCodeSamplesErrorCodeSample : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> description{};
  shared_ptr<string> message{};

  DescribeApiHistoryResponseBodyErrorCodeSamplesErrorCodeSample() {}

  explicit DescribeApiHistoryResponseBodyErrorCodeSamplesErrorCodeSample(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
  }


  virtual ~DescribeApiHistoryResponseBodyErrorCodeSamplesErrorCodeSample() = default;
};
class DescribeApiHistoryResponseBodyErrorCodeSamples : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeApiHistoryResponseBodyErrorCodeSamplesErrorCodeSample>> errorCodeSample{};

  DescribeApiHistoryResponseBodyErrorCodeSamples() {}

  explicit DescribeApiHistoryResponseBodyErrorCodeSamples(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCodeSample) {
      vector<boost::any> temp1;
      for(auto item1:*errorCodeSample){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ErrorCodeSample"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCodeSample") != m.end() && !m["ErrorCodeSample"].empty()) {
      if (typeid(vector<boost::any>) == m["ErrorCodeSample"].type()) {
        vector<DescribeApiHistoryResponseBodyErrorCodeSamplesErrorCodeSample> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ErrorCodeSample"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeApiHistoryResponseBodyErrorCodeSamplesErrorCodeSample model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        errorCodeSample = make_shared<vector<DescribeApiHistoryResponseBodyErrorCodeSamplesErrorCodeSample>>(expect1);
      }
    }
  }


  virtual ~DescribeApiHistoryResponseBodyErrorCodeSamples() = default;
};
class DescribeApiHistoryResponseBodyOpenIdConnectConfig : public Darabonba::Model {
public:
  shared_ptr<string> idTokenParamName{};
  shared_ptr<string> openIdApiType{};
  shared_ptr<string> publicKey{};
  shared_ptr<string> publicKeyId{};

  DescribeApiHistoryResponseBodyOpenIdConnectConfig() {}

  explicit DescribeApiHistoryResponseBodyOpenIdConnectConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (idTokenParamName) {
      res["IdTokenParamName"] = boost::any(*idTokenParamName);
    }
    if (openIdApiType) {
      res["OpenIdApiType"] = boost::any(*openIdApiType);
    }
    if (publicKey) {
      res["PublicKey"] = boost::any(*publicKey);
    }
    if (publicKeyId) {
      res["PublicKeyId"] = boost::any(*publicKeyId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IdTokenParamName") != m.end() && !m["IdTokenParamName"].empty()) {
      idTokenParamName = make_shared<string>(boost::any_cast<string>(m["IdTokenParamName"]));
    }
    if (m.find("OpenIdApiType") != m.end() && !m["OpenIdApiType"].empty()) {
      openIdApiType = make_shared<string>(boost::any_cast<string>(m["OpenIdApiType"]));
    }
    if (m.find("PublicKey") != m.end() && !m["PublicKey"].empty()) {
      publicKey = make_shared<string>(boost::any_cast<string>(m["PublicKey"]));
    }
    if (m.find("PublicKeyId") != m.end() && !m["PublicKeyId"].empty()) {
      publicKeyId = make_shared<string>(boost::any_cast<string>(m["PublicKeyId"]));
    }
  }


  virtual ~DescribeApiHistoryResponseBodyOpenIdConnectConfig() = default;
};
class DescribeApiHistoryResponseBodyRequestConfig : public Darabonba::Model {
public:
  shared_ptr<string> bodyFormat{};
  shared_ptr<string> bodyModel{};
  shared_ptr<string> postBodyDescription{};
  shared_ptr<string> requestHttpMethod{};
  shared_ptr<string> requestMode{};
  shared_ptr<string> requestPath{};
  shared_ptr<string> requestProtocol{};

  DescribeApiHistoryResponseBodyRequestConfig() {}

  explicit DescribeApiHistoryResponseBodyRequestConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bodyFormat) {
      res["BodyFormat"] = boost::any(*bodyFormat);
    }
    if (bodyModel) {
      res["BodyModel"] = boost::any(*bodyModel);
    }
    if (postBodyDescription) {
      res["PostBodyDescription"] = boost::any(*postBodyDescription);
    }
    if (requestHttpMethod) {
      res["RequestHttpMethod"] = boost::any(*requestHttpMethod);
    }
    if (requestMode) {
      res["RequestMode"] = boost::any(*requestMode);
    }
    if (requestPath) {
      res["RequestPath"] = boost::any(*requestPath);
    }
    if (requestProtocol) {
      res["RequestProtocol"] = boost::any(*requestProtocol);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BodyFormat") != m.end() && !m["BodyFormat"].empty()) {
      bodyFormat = make_shared<string>(boost::any_cast<string>(m["BodyFormat"]));
    }
    if (m.find("BodyModel") != m.end() && !m["BodyModel"].empty()) {
      bodyModel = make_shared<string>(boost::any_cast<string>(m["BodyModel"]));
    }
    if (m.find("PostBodyDescription") != m.end() && !m["PostBodyDescription"].empty()) {
      postBodyDescription = make_shared<string>(boost::any_cast<string>(m["PostBodyDescription"]));
    }
    if (m.find("RequestHttpMethod") != m.end() && !m["RequestHttpMethod"].empty()) {
      requestHttpMethod = make_shared<string>(boost::any_cast<string>(m["RequestHttpMethod"]));
    }
    if (m.find("RequestMode") != m.end() && !m["RequestMode"].empty()) {
      requestMode = make_shared<string>(boost::any_cast<string>(m["RequestMode"]));
    }
    if (m.find("RequestPath") != m.end() && !m["RequestPath"].empty()) {
      requestPath = make_shared<string>(boost::any_cast<string>(m["RequestPath"]));
    }
    if (m.find("RequestProtocol") != m.end() && !m["RequestProtocol"].empty()) {
      requestProtocol = make_shared<string>(boost::any_cast<string>(m["RequestProtocol"]));
    }
  }


  virtual ~DescribeApiHistoryResponseBodyRequestConfig() = default;
};
class DescribeApiHistoryResponseBodyRequestParametersRequestParameter : public Darabonba::Model {
public:
  shared_ptr<string> apiParameterName{};
  shared_ptr<string> arrayItemsType{};
  shared_ptr<string> defaultValue{};
  shared_ptr<string> demoValue{};
  shared_ptr<string> description{};
  shared_ptr<long> docOrder{};
  shared_ptr<string> docShow{};
  shared_ptr<string> enumValue{};
  shared_ptr<string> jsonScheme{};
  shared_ptr<string> location{};
  shared_ptr<long> maxLength{};
  shared_ptr<long> maxValue{};
  shared_ptr<long> minLength{};
  shared_ptr<long> minValue{};
  shared_ptr<string> parameterType{};
  shared_ptr<string> regularExpression{};
  shared_ptr<string> required{};

  DescribeApiHistoryResponseBodyRequestParametersRequestParameter() {}

  explicit DescribeApiHistoryResponseBodyRequestParametersRequestParameter(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiParameterName) {
      res["ApiParameterName"] = boost::any(*apiParameterName);
    }
    if (arrayItemsType) {
      res["ArrayItemsType"] = boost::any(*arrayItemsType);
    }
    if (defaultValue) {
      res["DefaultValue"] = boost::any(*defaultValue);
    }
    if (demoValue) {
      res["DemoValue"] = boost::any(*demoValue);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (docOrder) {
      res["DocOrder"] = boost::any(*docOrder);
    }
    if (docShow) {
      res["DocShow"] = boost::any(*docShow);
    }
    if (enumValue) {
      res["EnumValue"] = boost::any(*enumValue);
    }
    if (jsonScheme) {
      res["JsonScheme"] = boost::any(*jsonScheme);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (maxLength) {
      res["MaxLength"] = boost::any(*maxLength);
    }
    if (maxValue) {
      res["MaxValue"] = boost::any(*maxValue);
    }
    if (minLength) {
      res["MinLength"] = boost::any(*minLength);
    }
    if (minValue) {
      res["MinValue"] = boost::any(*minValue);
    }
    if (parameterType) {
      res["ParameterType"] = boost::any(*parameterType);
    }
    if (regularExpression) {
      res["RegularExpression"] = boost::any(*regularExpression);
    }
    if (required) {
      res["Required"] = boost::any(*required);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiParameterName") != m.end() && !m["ApiParameterName"].empty()) {
      apiParameterName = make_shared<string>(boost::any_cast<string>(m["ApiParameterName"]));
    }
    if (m.find("ArrayItemsType") != m.end() && !m["ArrayItemsType"].empty()) {
      arrayItemsType = make_shared<string>(boost::any_cast<string>(m["ArrayItemsType"]));
    }
    if (m.find("DefaultValue") != m.end() && !m["DefaultValue"].empty()) {
      defaultValue = make_shared<string>(boost::any_cast<string>(m["DefaultValue"]));
    }
    if (m.find("DemoValue") != m.end() && !m["DemoValue"].empty()) {
      demoValue = make_shared<string>(boost::any_cast<string>(m["DemoValue"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DocOrder") != m.end() && !m["DocOrder"].empty()) {
      docOrder = make_shared<long>(boost::any_cast<long>(m["DocOrder"]));
    }
    if (m.find("DocShow") != m.end() && !m["DocShow"].empty()) {
      docShow = make_shared<string>(boost::any_cast<string>(m["DocShow"]));
    }
    if (m.find("EnumValue") != m.end() && !m["EnumValue"].empty()) {
      enumValue = make_shared<string>(boost::any_cast<string>(m["EnumValue"]));
    }
    if (m.find("JsonScheme") != m.end() && !m["JsonScheme"].empty()) {
      jsonScheme = make_shared<string>(boost::any_cast<string>(m["JsonScheme"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("MaxLength") != m.end() && !m["MaxLength"].empty()) {
      maxLength = make_shared<long>(boost::any_cast<long>(m["MaxLength"]));
    }
    if (m.find("MaxValue") != m.end() && !m["MaxValue"].empty()) {
      maxValue = make_shared<long>(boost::any_cast<long>(m["MaxValue"]));
    }
    if (m.find("MinLength") != m.end() && !m["MinLength"].empty()) {
      minLength = make_shared<long>(boost::any_cast<long>(m["MinLength"]));
    }
    if (m.find("MinValue") != m.end() && !m["MinValue"].empty()) {
      minValue = make_shared<long>(boost::any_cast<long>(m["MinValue"]));
    }
    if (m.find("ParameterType") != m.end() && !m["ParameterType"].empty()) {
      parameterType = make_shared<string>(boost::any_cast<string>(m["ParameterType"]));
    }
    if (m.find("RegularExpression") != m.end() && !m["RegularExpression"].empty()) {
      regularExpression = make_shared<string>(boost::any_cast<string>(m["RegularExpression"]));
    }
    if (m.find("Required") != m.end() && !m["Required"].empty()) {
      required = make_shared<string>(boost::any_cast<string>(m["Required"]));
    }
  }


  virtual ~DescribeApiHistoryResponseBodyRequestParametersRequestParameter() = default;
};
class DescribeApiHistoryResponseBodyRequestParameters : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeApiHistoryResponseBodyRequestParametersRequestParameter>> requestParameter{};

  DescribeApiHistoryResponseBodyRequestParameters() {}

  explicit DescribeApiHistoryResponseBodyRequestParameters(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestParameter) {
      vector<boost::any> temp1;
      for(auto item1:*requestParameter){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RequestParameter"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestParameter") != m.end() && !m["RequestParameter"].empty()) {
      if (typeid(vector<boost::any>) == m["RequestParameter"].type()) {
        vector<DescribeApiHistoryResponseBodyRequestParametersRequestParameter> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RequestParameter"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeApiHistoryResponseBodyRequestParametersRequestParameter model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        requestParameter = make_shared<vector<DescribeApiHistoryResponseBodyRequestParametersRequestParameter>>(expect1);
      }
    }
  }


  virtual ~DescribeApiHistoryResponseBodyRequestParameters() = default;
};
class DescribeApiHistoryResponseBodyResultDescriptionsResultDescription : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<bool> hasChild{};
  shared_ptr<string> id{};
  shared_ptr<string> key{};
  shared_ptr<bool> mandatory{};
  shared_ptr<string> name{};
  shared_ptr<string> pid{};
  shared_ptr<string> type{};

  DescribeApiHistoryResponseBodyResultDescriptionsResultDescription() {}

  explicit DescribeApiHistoryResponseBodyResultDescriptionsResultDescription(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (hasChild) {
      res["HasChild"] = boost::any(*hasChild);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (mandatory) {
      res["Mandatory"] = boost::any(*mandatory);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (pid) {
      res["Pid"] = boost::any(*pid);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("HasChild") != m.end() && !m["HasChild"].empty()) {
      hasChild = make_shared<bool>(boost::any_cast<bool>(m["HasChild"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Mandatory") != m.end() && !m["Mandatory"].empty()) {
      mandatory = make_shared<bool>(boost::any_cast<bool>(m["Mandatory"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Pid") != m.end() && !m["Pid"].empty()) {
      pid = make_shared<string>(boost::any_cast<string>(m["Pid"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DescribeApiHistoryResponseBodyResultDescriptionsResultDescription() = default;
};
class DescribeApiHistoryResponseBodyResultDescriptions : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeApiHistoryResponseBodyResultDescriptionsResultDescription>> resultDescription{};

  DescribeApiHistoryResponseBodyResultDescriptions() {}

  explicit DescribeApiHistoryResponseBodyResultDescriptions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resultDescription) {
      vector<boost::any> temp1;
      for(auto item1:*resultDescription){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ResultDescription"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResultDescription") != m.end() && !m["ResultDescription"].empty()) {
      if (typeid(vector<boost::any>) == m["ResultDescription"].type()) {
        vector<DescribeApiHistoryResponseBodyResultDescriptionsResultDescription> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ResultDescription"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeApiHistoryResponseBodyResultDescriptionsResultDescription model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        resultDescription = make_shared<vector<DescribeApiHistoryResponseBodyResultDescriptionsResultDescription>>(expect1);
      }
    }
  }


  virtual ~DescribeApiHistoryResponseBodyResultDescriptions() = default;
};
class DescribeApiHistoryResponseBodyServiceConfigFunctionComputeConfig : public Darabonba::Model {
public:
  shared_ptr<string> contentTypeCatagory{};
  shared_ptr<string> contentTypeValue{};
  shared_ptr<string> fcBaseUrl{};
  shared_ptr<string> fcType{};
  shared_ptr<string> functionName{};
  shared_ptr<string> method{};
  shared_ptr<bool> onlyBusinessPath{};
  shared_ptr<string> path{};
  shared_ptr<string> qualifier{};
  shared_ptr<string> regionId{};
  shared_ptr<string> roleArn{};
  shared_ptr<string> serviceName{};

  DescribeApiHistoryResponseBodyServiceConfigFunctionComputeConfig() {}

  explicit DescribeApiHistoryResponseBodyServiceConfigFunctionComputeConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contentTypeCatagory) {
      res["ContentTypeCatagory"] = boost::any(*contentTypeCatagory);
    }
    if (contentTypeValue) {
      res["ContentTypeValue"] = boost::any(*contentTypeValue);
    }
    if (fcBaseUrl) {
      res["FcBaseUrl"] = boost::any(*fcBaseUrl);
    }
    if (fcType) {
      res["FcType"] = boost::any(*fcType);
    }
    if (functionName) {
      res["FunctionName"] = boost::any(*functionName);
    }
    if (method) {
      res["Method"] = boost::any(*method);
    }
    if (onlyBusinessPath) {
      res["OnlyBusinessPath"] = boost::any(*onlyBusinessPath);
    }
    if (path) {
      res["Path"] = boost::any(*path);
    }
    if (qualifier) {
      res["Qualifier"] = boost::any(*qualifier);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (roleArn) {
      res["RoleArn"] = boost::any(*roleArn);
    }
    if (serviceName) {
      res["ServiceName"] = boost::any(*serviceName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ContentTypeCatagory") != m.end() && !m["ContentTypeCatagory"].empty()) {
      contentTypeCatagory = make_shared<string>(boost::any_cast<string>(m["ContentTypeCatagory"]));
    }
    if (m.find("ContentTypeValue") != m.end() && !m["ContentTypeValue"].empty()) {
      contentTypeValue = make_shared<string>(boost::any_cast<string>(m["ContentTypeValue"]));
    }
    if (m.find("FcBaseUrl") != m.end() && !m["FcBaseUrl"].empty()) {
      fcBaseUrl = make_shared<string>(boost::any_cast<string>(m["FcBaseUrl"]));
    }
    if (m.find("FcType") != m.end() && !m["FcType"].empty()) {
      fcType = make_shared<string>(boost::any_cast<string>(m["FcType"]));
    }
    if (m.find("FunctionName") != m.end() && !m["FunctionName"].empty()) {
      functionName = make_shared<string>(boost::any_cast<string>(m["FunctionName"]));
    }
    if (m.find("Method") != m.end() && !m["Method"].empty()) {
      method = make_shared<string>(boost::any_cast<string>(m["Method"]));
    }
    if (m.find("OnlyBusinessPath") != m.end() && !m["OnlyBusinessPath"].empty()) {
      onlyBusinessPath = make_shared<bool>(boost::any_cast<bool>(m["OnlyBusinessPath"]));
    }
    if (m.find("Path") != m.end() && !m["Path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["Path"]));
    }
    if (m.find("Qualifier") != m.end() && !m["Qualifier"].empty()) {
      qualifier = make_shared<string>(boost::any_cast<string>(m["Qualifier"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("RoleArn") != m.end() && !m["RoleArn"].empty()) {
      roleArn = make_shared<string>(boost::any_cast<string>(m["RoleArn"]));
    }
    if (m.find("ServiceName") != m.end() && !m["ServiceName"].empty()) {
      serviceName = make_shared<string>(boost::any_cast<string>(m["ServiceName"]));
    }
  }


  virtual ~DescribeApiHistoryResponseBodyServiceConfigFunctionComputeConfig() = default;
};
class DescribeApiHistoryResponseBodyServiceConfigMockHeadersMockHeader : public Darabonba::Model {
public:
  shared_ptr<string> headerName{};
  shared_ptr<string> headerValue{};

  DescribeApiHistoryResponseBodyServiceConfigMockHeadersMockHeader() {}

  explicit DescribeApiHistoryResponseBodyServiceConfigMockHeadersMockHeader(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headerName) {
      res["HeaderName"] = boost::any(*headerName);
    }
    if (headerValue) {
      res["HeaderValue"] = boost::any(*headerValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HeaderName") != m.end() && !m["HeaderName"].empty()) {
      headerName = make_shared<string>(boost::any_cast<string>(m["HeaderName"]));
    }
    if (m.find("HeaderValue") != m.end() && !m["HeaderValue"].empty()) {
      headerValue = make_shared<string>(boost::any_cast<string>(m["HeaderValue"]));
    }
  }


  virtual ~DescribeApiHistoryResponseBodyServiceConfigMockHeadersMockHeader() = default;
};
class DescribeApiHistoryResponseBodyServiceConfigMockHeaders : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeApiHistoryResponseBodyServiceConfigMockHeadersMockHeader>> mockHeader{};

  DescribeApiHistoryResponseBodyServiceConfigMockHeaders() {}

  explicit DescribeApiHistoryResponseBodyServiceConfigMockHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mockHeader) {
      vector<boost::any> temp1;
      for(auto item1:*mockHeader){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["MockHeader"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MockHeader") != m.end() && !m["MockHeader"].empty()) {
      if (typeid(vector<boost::any>) == m["MockHeader"].type()) {
        vector<DescribeApiHistoryResponseBodyServiceConfigMockHeadersMockHeader> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["MockHeader"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeApiHistoryResponseBodyServiceConfigMockHeadersMockHeader model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        mockHeader = make_shared<vector<DescribeApiHistoryResponseBodyServiceConfigMockHeadersMockHeader>>(expect1);
      }
    }
  }


  virtual ~DescribeApiHistoryResponseBodyServiceConfigMockHeaders() = default;
};
class DescribeApiHistoryResponseBodyServiceConfigOssConfig : public Darabonba::Model {
public:
  shared_ptr<string> action{};
  shared_ptr<string> bucketName{};
  shared_ptr<string> key{};
  shared_ptr<string> ossRegionId{};

  DescribeApiHistoryResponseBodyServiceConfigOssConfig() {}

  explicit DescribeApiHistoryResponseBodyServiceConfigOssConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (action) {
      res["Action"] = boost::any(*action);
    }
    if (bucketName) {
      res["BucketName"] = boost::any(*bucketName);
    }
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (ossRegionId) {
      res["OssRegionId"] = boost::any(*ossRegionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Action") != m.end() && !m["Action"].empty()) {
      action = make_shared<string>(boost::any_cast<string>(m["Action"]));
    }
    if (m.find("BucketName") != m.end() && !m["BucketName"].empty()) {
      bucketName = make_shared<string>(boost::any_cast<string>(m["BucketName"]));
    }
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("OssRegionId") != m.end() && !m["OssRegionId"].empty()) {
      ossRegionId = make_shared<string>(boost::any_cast<string>(m["OssRegionId"]));
    }
  }


  virtual ~DescribeApiHistoryResponseBodyServiceConfigOssConfig() = default;
};
class DescribeApiHistoryResponseBodyServiceConfigVpcConfig : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> name{};
  shared_ptr<long> port{};
  shared_ptr<string> vpcId{};
  shared_ptr<string> vpcScheme{};

  DescribeApiHistoryResponseBodyServiceConfigVpcConfig() {}

  explicit DescribeApiHistoryResponseBodyServiceConfigVpcConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    if (vpcScheme) {
      res["VpcScheme"] = boost::any(*vpcScheme);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<long>(boost::any_cast<long>(m["Port"]));
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
    if (m.find("VpcScheme") != m.end() && !m["VpcScheme"].empty()) {
      vpcScheme = make_shared<string>(boost::any_cast<string>(m["VpcScheme"]));
    }
  }


  virtual ~DescribeApiHistoryResponseBodyServiceConfigVpcConfig() = default;
};
class DescribeApiHistoryResponseBodyServiceConfig : public Darabonba::Model {
public:
  shared_ptr<string> contentTypeCatagory{};
  shared_ptr<string> contentTypeValue{};
  shared_ptr<DescribeApiHistoryResponseBodyServiceConfigFunctionComputeConfig> functionComputeConfig{};
  shared_ptr<string> mock{};
  shared_ptr<DescribeApiHistoryResponseBodyServiceConfigMockHeaders> mockHeaders{};
  shared_ptr<string> mockResult{};
  shared_ptr<long> mockStatusCode{};
  shared_ptr<DescribeApiHistoryResponseBodyServiceConfigOssConfig> ossConfig{};
  shared_ptr<string> serviceAddress{};
  shared_ptr<string> serviceHttpMethod{};
  shared_ptr<string> servicePath{};
  shared_ptr<string> serviceProtocol{};
  shared_ptr<long> serviceTimeout{};
  shared_ptr<string> serviceVpcEnable{};
  shared_ptr<DescribeApiHistoryResponseBodyServiceConfigVpcConfig> vpcConfig{};
  shared_ptr<string> vpcId{};

  DescribeApiHistoryResponseBodyServiceConfig() {}

  explicit DescribeApiHistoryResponseBodyServiceConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contentTypeCatagory) {
      res["ContentTypeCatagory"] = boost::any(*contentTypeCatagory);
    }
    if (contentTypeValue) {
      res["ContentTypeValue"] = boost::any(*contentTypeValue);
    }
    if (functionComputeConfig) {
      res["FunctionComputeConfig"] = functionComputeConfig ? boost::any(functionComputeConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (mock) {
      res["Mock"] = boost::any(*mock);
    }
    if (mockHeaders) {
      res["MockHeaders"] = mockHeaders ? boost::any(mockHeaders->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (mockResult) {
      res["MockResult"] = boost::any(*mockResult);
    }
    if (mockStatusCode) {
      res["MockStatusCode"] = boost::any(*mockStatusCode);
    }
    if (ossConfig) {
      res["OssConfig"] = ossConfig ? boost::any(ossConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (serviceAddress) {
      res["ServiceAddress"] = boost::any(*serviceAddress);
    }
    if (serviceHttpMethod) {
      res["ServiceHttpMethod"] = boost::any(*serviceHttpMethod);
    }
    if (servicePath) {
      res["ServicePath"] = boost::any(*servicePath);
    }
    if (serviceProtocol) {
      res["ServiceProtocol"] = boost::any(*serviceProtocol);
    }
    if (serviceTimeout) {
      res["ServiceTimeout"] = boost::any(*serviceTimeout);
    }
    if (serviceVpcEnable) {
      res["ServiceVpcEnable"] = boost::any(*serviceVpcEnable);
    }
    if (vpcConfig) {
      res["VpcConfig"] = vpcConfig ? boost::any(vpcConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ContentTypeCatagory") != m.end() && !m["ContentTypeCatagory"].empty()) {
      contentTypeCatagory = make_shared<string>(boost::any_cast<string>(m["ContentTypeCatagory"]));
    }
    if (m.find("ContentTypeValue") != m.end() && !m["ContentTypeValue"].empty()) {
      contentTypeValue = make_shared<string>(boost::any_cast<string>(m["ContentTypeValue"]));
    }
    if (m.find("FunctionComputeConfig") != m.end() && !m["FunctionComputeConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["FunctionComputeConfig"].type()) {
        DescribeApiHistoryResponseBodyServiceConfigFunctionComputeConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FunctionComputeConfig"]));
        functionComputeConfig = make_shared<DescribeApiHistoryResponseBodyServiceConfigFunctionComputeConfig>(model1);
      }
    }
    if (m.find("Mock") != m.end() && !m["Mock"].empty()) {
      mock = make_shared<string>(boost::any_cast<string>(m["Mock"]));
    }
    if (m.find("MockHeaders") != m.end() && !m["MockHeaders"].empty()) {
      if (typeid(map<string, boost::any>) == m["MockHeaders"].type()) {
        DescribeApiHistoryResponseBodyServiceConfigMockHeaders model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MockHeaders"]));
        mockHeaders = make_shared<DescribeApiHistoryResponseBodyServiceConfigMockHeaders>(model1);
      }
    }
    if (m.find("MockResult") != m.end() && !m["MockResult"].empty()) {
      mockResult = make_shared<string>(boost::any_cast<string>(m["MockResult"]));
    }
    if (m.find("MockStatusCode") != m.end() && !m["MockStatusCode"].empty()) {
      mockStatusCode = make_shared<long>(boost::any_cast<long>(m["MockStatusCode"]));
    }
    if (m.find("OssConfig") != m.end() && !m["OssConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["OssConfig"].type()) {
        DescribeApiHistoryResponseBodyServiceConfigOssConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OssConfig"]));
        ossConfig = make_shared<DescribeApiHistoryResponseBodyServiceConfigOssConfig>(model1);
      }
    }
    if (m.find("ServiceAddress") != m.end() && !m["ServiceAddress"].empty()) {
      serviceAddress = make_shared<string>(boost::any_cast<string>(m["ServiceAddress"]));
    }
    if (m.find("ServiceHttpMethod") != m.end() && !m["ServiceHttpMethod"].empty()) {
      serviceHttpMethod = make_shared<string>(boost::any_cast<string>(m["ServiceHttpMethod"]));
    }
    if (m.find("ServicePath") != m.end() && !m["ServicePath"].empty()) {
      servicePath = make_shared<string>(boost::any_cast<string>(m["ServicePath"]));
    }
    if (m.find("ServiceProtocol") != m.end() && !m["ServiceProtocol"].empty()) {
      serviceProtocol = make_shared<string>(boost::any_cast<string>(m["ServiceProtocol"]));
    }
    if (m.find("ServiceTimeout") != m.end() && !m["ServiceTimeout"].empty()) {
      serviceTimeout = make_shared<long>(boost::any_cast<long>(m["ServiceTimeout"]));
    }
    if (m.find("ServiceVpcEnable") != m.end() && !m["ServiceVpcEnable"].empty()) {
      serviceVpcEnable = make_shared<string>(boost::any_cast<string>(m["ServiceVpcEnable"]));
    }
    if (m.find("VpcConfig") != m.end() && !m["VpcConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["VpcConfig"].type()) {
        DescribeApiHistoryResponseBodyServiceConfigVpcConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["VpcConfig"]));
        vpcConfig = make_shared<DescribeApiHistoryResponseBodyServiceConfigVpcConfig>(model1);
      }
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
  }


  virtual ~DescribeApiHistoryResponseBodyServiceConfig() = default;
};
class DescribeApiHistoryResponseBodyServiceParametersServiceParameter : public Darabonba::Model {
public:
  shared_ptr<string> location{};
  shared_ptr<string> parameterType{};
  shared_ptr<string> serviceParameterName{};

  DescribeApiHistoryResponseBodyServiceParametersServiceParameter() {}

  explicit DescribeApiHistoryResponseBodyServiceParametersServiceParameter(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (parameterType) {
      res["ParameterType"] = boost::any(*parameterType);
    }
    if (serviceParameterName) {
      res["ServiceParameterName"] = boost::any(*serviceParameterName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("ParameterType") != m.end() && !m["ParameterType"].empty()) {
      parameterType = make_shared<string>(boost::any_cast<string>(m["ParameterType"]));
    }
    if (m.find("ServiceParameterName") != m.end() && !m["ServiceParameterName"].empty()) {
      serviceParameterName = make_shared<string>(boost::any_cast<string>(m["ServiceParameterName"]));
    }
  }


  virtual ~DescribeApiHistoryResponseBodyServiceParametersServiceParameter() = default;
};
class DescribeApiHistoryResponseBodyServiceParameters : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeApiHistoryResponseBodyServiceParametersServiceParameter>> serviceParameter{};

  DescribeApiHistoryResponseBodyServiceParameters() {}

  explicit DescribeApiHistoryResponseBodyServiceParameters(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (serviceParameter) {
      vector<boost::any> temp1;
      for(auto item1:*serviceParameter){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ServiceParameter"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ServiceParameter") != m.end() && !m["ServiceParameter"].empty()) {
      if (typeid(vector<boost::any>) == m["ServiceParameter"].type()) {
        vector<DescribeApiHistoryResponseBodyServiceParametersServiceParameter> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ServiceParameter"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeApiHistoryResponseBodyServiceParametersServiceParameter model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        serviceParameter = make_shared<vector<DescribeApiHistoryResponseBodyServiceParametersServiceParameter>>(expect1);
      }
    }
  }


  virtual ~DescribeApiHistoryResponseBodyServiceParameters() = default;
};
class DescribeApiHistoryResponseBodyServiceParametersMapServiceParameterMap : public Darabonba::Model {
public:
  shared_ptr<string> requestParameterName{};
  shared_ptr<string> serviceParameterName{};

  DescribeApiHistoryResponseBodyServiceParametersMapServiceParameterMap() {}

  explicit DescribeApiHistoryResponseBodyServiceParametersMapServiceParameterMap(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestParameterName) {
      res["RequestParameterName"] = boost::any(*requestParameterName);
    }
    if (serviceParameterName) {
      res["ServiceParameterName"] = boost::any(*serviceParameterName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestParameterName") != m.end() && !m["RequestParameterName"].empty()) {
      requestParameterName = make_shared<string>(boost::any_cast<string>(m["RequestParameterName"]));
    }
    if (m.find("ServiceParameterName") != m.end() && !m["ServiceParameterName"].empty()) {
      serviceParameterName = make_shared<string>(boost::any_cast<string>(m["ServiceParameterName"]));
    }
  }


  virtual ~DescribeApiHistoryResponseBodyServiceParametersMapServiceParameterMap() = default;
};
class DescribeApiHistoryResponseBodyServiceParametersMap : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeApiHistoryResponseBodyServiceParametersMapServiceParameterMap>> serviceParameterMap{};

  DescribeApiHistoryResponseBodyServiceParametersMap() {}

  explicit DescribeApiHistoryResponseBodyServiceParametersMap(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (serviceParameterMap) {
      vector<boost::any> temp1;
      for(auto item1:*serviceParameterMap){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ServiceParameterMap"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ServiceParameterMap") != m.end() && !m["ServiceParameterMap"].empty()) {
      if (typeid(vector<boost::any>) == m["ServiceParameterMap"].type()) {
        vector<DescribeApiHistoryResponseBodyServiceParametersMapServiceParameterMap> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ServiceParameterMap"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeApiHistoryResponseBodyServiceParametersMapServiceParameterMap model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        serviceParameterMap = make_shared<vector<DescribeApiHistoryResponseBodyServiceParametersMapServiceParameterMap>>(expect1);
      }
    }
  }


  virtual ~DescribeApiHistoryResponseBodyServiceParametersMap() = default;
};
class DescribeApiHistoryResponseBodySystemParametersSystemParameter : public Darabonba::Model {
public:
  shared_ptr<string> demoValue{};
  shared_ptr<string> description{};
  shared_ptr<string> location{};
  shared_ptr<string> parameterName{};
  shared_ptr<string> serviceParameterName{};

  DescribeApiHistoryResponseBodySystemParametersSystemParameter() {}

  explicit DescribeApiHistoryResponseBodySystemParametersSystemParameter(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (demoValue) {
      res["DemoValue"] = boost::any(*demoValue);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (parameterName) {
      res["ParameterName"] = boost::any(*parameterName);
    }
    if (serviceParameterName) {
      res["ServiceParameterName"] = boost::any(*serviceParameterName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DemoValue") != m.end() && !m["DemoValue"].empty()) {
      demoValue = make_shared<string>(boost::any_cast<string>(m["DemoValue"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("ParameterName") != m.end() && !m["ParameterName"].empty()) {
      parameterName = make_shared<string>(boost::any_cast<string>(m["ParameterName"]));
    }
    if (m.find("ServiceParameterName") != m.end() && !m["ServiceParameterName"].empty()) {
      serviceParameterName = make_shared<string>(boost::any_cast<string>(m["ServiceParameterName"]));
    }
  }


  virtual ~DescribeApiHistoryResponseBodySystemParametersSystemParameter() = default;
};
class DescribeApiHistoryResponseBodySystemParameters : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeApiHistoryResponseBodySystemParametersSystemParameter>> systemParameter{};

  DescribeApiHistoryResponseBodySystemParameters() {}

  explicit DescribeApiHistoryResponseBodySystemParameters(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (systemParameter) {
      vector<boost::any> temp1;
      for(auto item1:*systemParameter){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SystemParameter"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SystemParameter") != m.end() && !m["SystemParameter"].empty()) {
      if (typeid(vector<boost::any>) == m["SystemParameter"].type()) {
        vector<DescribeApiHistoryResponseBodySystemParametersSystemParameter> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SystemParameter"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeApiHistoryResponseBodySystemParametersSystemParameter model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        systemParameter = make_shared<vector<DescribeApiHistoryResponseBodySystemParametersSystemParameter>>(expect1);
      }
    }
  }


  virtual ~DescribeApiHistoryResponseBodySystemParameters() = default;
};
class DescribeApiHistoryResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> allowSignatureMethod{};
  shared_ptr<string> apiId{};
  shared_ptr<string> apiName{};
  shared_ptr<string> appCodeAuthType{};
  shared_ptr<string> authType{};
  shared_ptr<DescribeApiHistoryResponseBodyConstantParameters> constantParameters{};
  shared_ptr<DescribeApiHistoryResponseBodyCustomSystemParameters> customSystemParameters{};
  shared_ptr<string> deployedTime{};
  shared_ptr<string> description{};
  shared_ptr<bool> disableInternet{};
  shared_ptr<DescribeApiHistoryResponseBodyErrorCodeSamples> errorCodeSamples{};
  shared_ptr<string> failResultSample{};
  shared_ptr<bool> forceNonceCheck{};
  shared_ptr<string> groupId{};
  shared_ptr<string> groupName{};
  shared_ptr<string> historyVersion{};
  shared_ptr<DescribeApiHistoryResponseBodyOpenIdConnectConfig> openIdConnectConfig{};
  shared_ptr<string> regionId{};
  shared_ptr<DescribeApiHistoryResponseBodyRequestConfig> requestConfig{};
  shared_ptr<string> requestId{};
  shared_ptr<DescribeApiHistoryResponseBodyRequestParameters> requestParameters{};
  shared_ptr<string> resultBodyModel{};
  shared_ptr<DescribeApiHistoryResponseBodyResultDescriptions> resultDescriptions{};
  shared_ptr<string> resultSample{};
  shared_ptr<string> resultType{};
  shared_ptr<DescribeApiHistoryResponseBodyServiceConfig> serviceConfig{};
  shared_ptr<DescribeApiHistoryResponseBodyServiceParameters> serviceParameters{};
  shared_ptr<DescribeApiHistoryResponseBodyServiceParametersMap> serviceParametersMap{};
  shared_ptr<string> stageName{};
  shared_ptr<string> status{};
  shared_ptr<DescribeApiHistoryResponseBodySystemParameters> systemParameters{};
  shared_ptr<string> visibility{};
  shared_ptr<string> webSocketApiType{};

  DescribeApiHistoryResponseBody() {}

  explicit DescribeApiHistoryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (allowSignatureMethod) {
      res["AllowSignatureMethod"] = boost::any(*allowSignatureMethod);
    }
    if (apiId) {
      res["ApiId"] = boost::any(*apiId);
    }
    if (apiName) {
      res["ApiName"] = boost::any(*apiName);
    }
    if (appCodeAuthType) {
      res["AppCodeAuthType"] = boost::any(*appCodeAuthType);
    }
    if (authType) {
      res["AuthType"] = boost::any(*authType);
    }
    if (constantParameters) {
      res["ConstantParameters"] = constantParameters ? boost::any(constantParameters->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (customSystemParameters) {
      res["CustomSystemParameters"] = customSystemParameters ? boost::any(customSystemParameters->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (deployedTime) {
      res["DeployedTime"] = boost::any(*deployedTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (disableInternet) {
      res["DisableInternet"] = boost::any(*disableInternet);
    }
    if (errorCodeSamples) {
      res["ErrorCodeSamples"] = errorCodeSamples ? boost::any(errorCodeSamples->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (failResultSample) {
      res["FailResultSample"] = boost::any(*failResultSample);
    }
    if (forceNonceCheck) {
      res["ForceNonceCheck"] = boost::any(*forceNonceCheck);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (historyVersion) {
      res["HistoryVersion"] = boost::any(*historyVersion);
    }
    if (openIdConnectConfig) {
      res["OpenIdConnectConfig"] = openIdConnectConfig ? boost::any(openIdConnectConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (requestConfig) {
      res["RequestConfig"] = requestConfig ? boost::any(requestConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (requestParameters) {
      res["RequestParameters"] = requestParameters ? boost::any(requestParameters->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (resultBodyModel) {
      res["ResultBodyModel"] = boost::any(*resultBodyModel);
    }
    if (resultDescriptions) {
      res["ResultDescriptions"] = resultDescriptions ? boost::any(resultDescriptions->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (resultSample) {
      res["ResultSample"] = boost::any(*resultSample);
    }
    if (resultType) {
      res["ResultType"] = boost::any(*resultType);
    }
    if (serviceConfig) {
      res["ServiceConfig"] = serviceConfig ? boost::any(serviceConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (serviceParameters) {
      res["ServiceParameters"] = serviceParameters ? boost::any(serviceParameters->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (serviceParametersMap) {
      res["ServiceParametersMap"] = serviceParametersMap ? boost::any(serviceParametersMap->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (stageName) {
      res["StageName"] = boost::any(*stageName);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (systemParameters) {
      res["SystemParameters"] = systemParameters ? boost::any(systemParameters->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (visibility) {
      res["Visibility"] = boost::any(*visibility);
    }
    if (webSocketApiType) {
      res["WebSocketApiType"] = boost::any(*webSocketApiType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AllowSignatureMethod") != m.end() && !m["AllowSignatureMethod"].empty()) {
      allowSignatureMethod = make_shared<string>(boost::any_cast<string>(m["AllowSignatureMethod"]));
    }
    if (m.find("ApiId") != m.end() && !m["ApiId"].empty()) {
      apiId = make_shared<string>(boost::any_cast<string>(m["ApiId"]));
    }
    if (m.find("ApiName") != m.end() && !m["ApiName"].empty()) {
      apiName = make_shared<string>(boost::any_cast<string>(m["ApiName"]));
    }
    if (m.find("AppCodeAuthType") != m.end() && !m["AppCodeAuthType"].empty()) {
      appCodeAuthType = make_shared<string>(boost::any_cast<string>(m["AppCodeAuthType"]));
    }
    if (m.find("AuthType") != m.end() && !m["AuthType"].empty()) {
      authType = make_shared<string>(boost::any_cast<string>(m["AuthType"]));
    }
    if (m.find("ConstantParameters") != m.end() && !m["ConstantParameters"].empty()) {
      if (typeid(map<string, boost::any>) == m["ConstantParameters"].type()) {
        DescribeApiHistoryResponseBodyConstantParameters model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ConstantParameters"]));
        constantParameters = make_shared<DescribeApiHistoryResponseBodyConstantParameters>(model1);
      }
    }
    if (m.find("CustomSystemParameters") != m.end() && !m["CustomSystemParameters"].empty()) {
      if (typeid(map<string, boost::any>) == m["CustomSystemParameters"].type()) {
        DescribeApiHistoryResponseBodyCustomSystemParameters model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CustomSystemParameters"]));
        customSystemParameters = make_shared<DescribeApiHistoryResponseBodyCustomSystemParameters>(model1);
      }
    }
    if (m.find("DeployedTime") != m.end() && !m["DeployedTime"].empty()) {
      deployedTime = make_shared<string>(boost::any_cast<string>(m["DeployedTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DisableInternet") != m.end() && !m["DisableInternet"].empty()) {
      disableInternet = make_shared<bool>(boost::any_cast<bool>(m["DisableInternet"]));
    }
    if (m.find("ErrorCodeSamples") != m.end() && !m["ErrorCodeSamples"].empty()) {
      if (typeid(map<string, boost::any>) == m["ErrorCodeSamples"].type()) {
        DescribeApiHistoryResponseBodyErrorCodeSamples model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ErrorCodeSamples"]));
        errorCodeSamples = make_shared<DescribeApiHistoryResponseBodyErrorCodeSamples>(model1);
      }
    }
    if (m.find("FailResultSample") != m.end() && !m["FailResultSample"].empty()) {
      failResultSample = make_shared<string>(boost::any_cast<string>(m["FailResultSample"]));
    }
    if (m.find("ForceNonceCheck") != m.end() && !m["ForceNonceCheck"].empty()) {
      forceNonceCheck = make_shared<bool>(boost::any_cast<bool>(m["ForceNonceCheck"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("HistoryVersion") != m.end() && !m["HistoryVersion"].empty()) {
      historyVersion = make_shared<string>(boost::any_cast<string>(m["HistoryVersion"]));
    }
    if (m.find("OpenIdConnectConfig") != m.end() && !m["OpenIdConnectConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["OpenIdConnectConfig"].type()) {
        DescribeApiHistoryResponseBodyOpenIdConnectConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OpenIdConnectConfig"]));
        openIdConnectConfig = make_shared<DescribeApiHistoryResponseBodyOpenIdConnectConfig>(model1);
      }
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("RequestConfig") != m.end() && !m["RequestConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["RequestConfig"].type()) {
        DescribeApiHistoryResponseBodyRequestConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RequestConfig"]));
        requestConfig = make_shared<DescribeApiHistoryResponseBodyRequestConfig>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("RequestParameters") != m.end() && !m["RequestParameters"].empty()) {
      if (typeid(map<string, boost::any>) == m["RequestParameters"].type()) {
        DescribeApiHistoryResponseBodyRequestParameters model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RequestParameters"]));
        requestParameters = make_shared<DescribeApiHistoryResponseBodyRequestParameters>(model1);
      }
    }
    if (m.find("ResultBodyModel") != m.end() && !m["ResultBodyModel"].empty()) {
      resultBodyModel = make_shared<string>(boost::any_cast<string>(m["ResultBodyModel"]));
    }
    if (m.find("ResultDescriptions") != m.end() && !m["ResultDescriptions"].empty()) {
      if (typeid(map<string, boost::any>) == m["ResultDescriptions"].type()) {
        DescribeApiHistoryResponseBodyResultDescriptions model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ResultDescriptions"]));
        resultDescriptions = make_shared<DescribeApiHistoryResponseBodyResultDescriptions>(model1);
      }
    }
    if (m.find("ResultSample") != m.end() && !m["ResultSample"].empty()) {
      resultSample = make_shared<string>(boost::any_cast<string>(m["ResultSample"]));
    }
    if (m.find("ResultType") != m.end() && !m["ResultType"].empty()) {
      resultType = make_shared<string>(boost::any_cast<string>(m["ResultType"]));
    }
    if (m.find("ServiceConfig") != m.end() && !m["ServiceConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["ServiceConfig"].type()) {
        DescribeApiHistoryResponseBodyServiceConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ServiceConfig"]));
        serviceConfig = make_shared<DescribeApiHistoryResponseBodyServiceConfig>(model1);
      }
    }
    if (m.find("ServiceParameters") != m.end() && !m["ServiceParameters"].empty()) {
      if (typeid(map<string, boost::any>) == m["ServiceParameters"].type()) {
        DescribeApiHistoryResponseBodyServiceParameters model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ServiceParameters"]));
        serviceParameters = make_shared<DescribeApiHistoryResponseBodyServiceParameters>(model1);
      }
    }
    if (m.find("ServiceParametersMap") != m.end() && !m["ServiceParametersMap"].empty()) {
      if (typeid(map<string, boost::any>) == m["ServiceParametersMap"].type()) {
        DescribeApiHistoryResponseBodyServiceParametersMap model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ServiceParametersMap"]));
        serviceParametersMap = make_shared<DescribeApiHistoryResponseBodyServiceParametersMap>(model1);
      }
    }
    if (m.find("StageName") != m.end() && !m["StageName"].empty()) {
      stageName = make_shared<string>(boost::any_cast<string>(m["StageName"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("SystemParameters") != m.end() && !m["SystemParameters"].empty()) {
      if (typeid(map<string, boost::any>) == m["SystemParameters"].type()) {
        DescribeApiHistoryResponseBodySystemParameters model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SystemParameters"]));
        systemParameters = make_shared<DescribeApiHistoryResponseBodySystemParameters>(model1);
      }
    }
    if (m.find("Visibility") != m.end() && !m["Visibility"].empty()) {
      visibility = make_shared<string>(boost::any_cast<string>(m["Visibility"]));
    }
    if (m.find("WebSocketApiType") != m.end() && !m["WebSocketApiType"].empty()) {
      webSocketApiType = make_shared<string>(boost::any_cast<string>(m["WebSocketApiType"]));
    }
  }


  virtual ~DescribeApiHistoryResponseBody() = default;
};
class DescribeApiHistoryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeApiHistoryResponseBody> body{};

  DescribeApiHistoryResponse() {}

  explicit DescribeApiHistoryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeApiHistoryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeApiHistoryResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeApiHistoryResponse() = default;
};
class DescribeApiIpControlsRequest : public Darabonba::Model {
public:
  shared_ptr<string> apiIds{};
  shared_ptr<string> groupId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> stageName{};

  DescribeApiIpControlsRequest() {}

  explicit DescribeApiIpControlsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiIds) {
      res["ApiIds"] = boost::any(*apiIds);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (stageName) {
      res["StageName"] = boost::any(*stageName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiIds") != m.end() && !m["ApiIds"].empty()) {
      apiIds = make_shared<string>(boost::any_cast<string>(m["ApiIds"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("StageName") != m.end() && !m["StageName"].empty()) {
      stageName = make_shared<string>(boost::any_cast<string>(m["StageName"]));
    }
  }


  virtual ~DescribeApiIpControlsRequest() = default;
};
class DescribeApiIpControlsResponseBodyApiIpControlsApiIpControlItem : public Darabonba::Model {
public:
  shared_ptr<string> apiId{};
  shared_ptr<string> apiName{};
  shared_ptr<string> boundTime{};
  shared_ptr<string> ipControlId{};
  shared_ptr<string> ipControlName{};

  DescribeApiIpControlsResponseBodyApiIpControlsApiIpControlItem() {}

  explicit DescribeApiIpControlsResponseBodyApiIpControlsApiIpControlItem(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiId) {
      res["ApiId"] = boost::any(*apiId);
    }
    if (apiName) {
      res["ApiName"] = boost::any(*apiName);
    }
    if (boundTime) {
      res["BoundTime"] = boost::any(*boundTime);
    }
    if (ipControlId) {
      res["IpControlId"] = boost::any(*ipControlId);
    }
    if (ipControlName) {
      res["IpControlName"] = boost::any(*ipControlName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiId") != m.end() && !m["ApiId"].empty()) {
      apiId = make_shared<string>(boost::any_cast<string>(m["ApiId"]));
    }
    if (m.find("ApiName") != m.end() && !m["ApiName"].empty()) {
      apiName = make_shared<string>(boost::any_cast<string>(m["ApiName"]));
    }
    if (m.find("BoundTime") != m.end() && !m["BoundTime"].empty()) {
      boundTime = make_shared<string>(boost::any_cast<string>(m["BoundTime"]));
    }
    if (m.find("IpControlId") != m.end() && !m["IpControlId"].empty()) {
      ipControlId = make_shared<string>(boost::any_cast<string>(m["IpControlId"]));
    }
    if (m.find("IpControlName") != m.end() && !m["IpControlName"].empty()) {
      ipControlName = make_shared<string>(boost::any_cast<string>(m["IpControlName"]));
    }
  }


  virtual ~DescribeApiIpControlsResponseBodyApiIpControlsApiIpControlItem() = default;
};
class DescribeApiIpControlsResponseBodyApiIpControls : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeApiIpControlsResponseBodyApiIpControlsApiIpControlItem>> apiIpControlItem{};

  DescribeApiIpControlsResponseBodyApiIpControls() {}

  explicit DescribeApiIpControlsResponseBodyApiIpControls(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiIpControlItem) {
      vector<boost::any> temp1;
      for(auto item1:*apiIpControlItem){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ApiIpControlItem"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiIpControlItem") != m.end() && !m["ApiIpControlItem"].empty()) {
      if (typeid(vector<boost::any>) == m["ApiIpControlItem"].type()) {
        vector<DescribeApiIpControlsResponseBodyApiIpControlsApiIpControlItem> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ApiIpControlItem"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeApiIpControlsResponseBodyApiIpControlsApiIpControlItem model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        apiIpControlItem = make_shared<vector<DescribeApiIpControlsResponseBodyApiIpControlsApiIpControlItem>>(expect1);
      }
    }
  }


  virtual ~DescribeApiIpControlsResponseBodyApiIpControls() = default;
};
class DescribeApiIpControlsResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeApiIpControlsResponseBodyApiIpControls> apiIpControls{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeApiIpControlsResponseBody() {}

  explicit DescribeApiIpControlsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiIpControls) {
      res["ApiIpControls"] = apiIpControls ? boost::any(apiIpControls->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiIpControls") != m.end() && !m["ApiIpControls"].empty()) {
      if (typeid(map<string, boost::any>) == m["ApiIpControls"].type()) {
        DescribeApiIpControlsResponseBodyApiIpControls model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ApiIpControls"]));
        apiIpControls = make_shared<DescribeApiIpControlsResponseBodyApiIpControls>(model1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeApiIpControlsResponseBody() = default;
};
class DescribeApiIpControlsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeApiIpControlsResponseBody> body{};

  DescribeApiIpControlsResponse() {}

  explicit DescribeApiIpControlsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeApiIpControlsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeApiIpControlsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeApiIpControlsResponse() = default;
};
class DescribeApiLatencyDataRequest : public Darabonba::Model {
public:
  shared_ptr<string> apiId{};
  shared_ptr<string> endTime{};
  shared_ptr<string> groupId{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> stageName{};
  shared_ptr<string> startTime{};

  DescribeApiLatencyDataRequest() {}

  explicit DescribeApiLatencyDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiId) {
      res["ApiId"] = boost::any(*apiId);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (stageName) {
      res["StageName"] = boost::any(*stageName);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiId") != m.end() && !m["ApiId"].empty()) {
      apiId = make_shared<string>(boost::any_cast<string>(m["ApiId"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("StageName") != m.end() && !m["StageName"].empty()) {
      stageName = make_shared<string>(boost::any_cast<string>(m["StageName"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeApiLatencyDataRequest() = default;
};
class DescribeApiLatencyDataResponseBodyCallLatencysMonitorItem : public Darabonba::Model {
public:
  shared_ptr<string> itemTime{};
  shared_ptr<string> itemValue{};

  DescribeApiLatencyDataResponseBodyCallLatencysMonitorItem() {}

  explicit DescribeApiLatencyDataResponseBodyCallLatencysMonitorItem(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (itemTime) {
      res["ItemTime"] = boost::any(*itemTime);
    }
    if (itemValue) {
      res["ItemValue"] = boost::any(*itemValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ItemTime") != m.end() && !m["ItemTime"].empty()) {
      itemTime = make_shared<string>(boost::any_cast<string>(m["ItemTime"]));
    }
    if (m.find("ItemValue") != m.end() && !m["ItemValue"].empty()) {
      itemValue = make_shared<string>(boost::any_cast<string>(m["ItemValue"]));
    }
  }


  virtual ~DescribeApiLatencyDataResponseBodyCallLatencysMonitorItem() = default;
};
class DescribeApiLatencyDataResponseBodyCallLatencys : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeApiLatencyDataResponseBodyCallLatencysMonitorItem>> monitorItem{};

  DescribeApiLatencyDataResponseBodyCallLatencys() {}

  explicit DescribeApiLatencyDataResponseBodyCallLatencys(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (monitorItem) {
      vector<boost::any> temp1;
      for(auto item1:*monitorItem){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["MonitorItem"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MonitorItem") != m.end() && !m["MonitorItem"].empty()) {
      if (typeid(vector<boost::any>) == m["MonitorItem"].type()) {
        vector<DescribeApiLatencyDataResponseBodyCallLatencysMonitorItem> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["MonitorItem"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeApiLatencyDataResponseBodyCallLatencysMonitorItem model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        monitorItem = make_shared<vector<DescribeApiLatencyDataResponseBodyCallLatencysMonitorItem>>(expect1);
      }
    }
  }


  virtual ~DescribeApiLatencyDataResponseBodyCallLatencys() = default;
};
class DescribeApiLatencyDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeApiLatencyDataResponseBodyCallLatencys> callLatencys{};
  shared_ptr<string> requestId{};

  DescribeApiLatencyDataResponseBody() {}

  explicit DescribeApiLatencyDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callLatencys) {
      res["CallLatencys"] = callLatencys ? boost::any(callLatencys->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallLatencys") != m.end() && !m["CallLatencys"].empty()) {
      if (typeid(map<string, boost::any>) == m["CallLatencys"].type()) {
        DescribeApiLatencyDataResponseBodyCallLatencys model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CallLatencys"]));
        callLatencys = make_shared<DescribeApiLatencyDataResponseBodyCallLatencys>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeApiLatencyDataResponseBody() = default;
};
class DescribeApiLatencyDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeApiLatencyDataResponseBody> body{};

  DescribeApiLatencyDataResponse() {}

  explicit DescribeApiLatencyDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeApiLatencyDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeApiLatencyDataResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeApiLatencyDataResponse() = default;
};
class DescribeApiMarketAttributesRequest : public Darabonba::Model {
public:
  shared_ptr<string> apiId{};
  shared_ptr<string> groupId{};
  shared_ptr<string> securityToken{};

  DescribeApiMarketAttributesRequest() {}

  explicit DescribeApiMarketAttributesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiId) {
      res["ApiId"] = boost::any(*apiId);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiId") != m.end() && !m["ApiId"].empty()) {
      apiId = make_shared<string>(boost::any_cast<string>(m["ApiId"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~DescribeApiMarketAttributesRequest() = default;
};
class DescribeApiMarketAttributesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> apiId{};
  shared_ptr<string> marketChargingMode{};
  shared_ptr<string> needCharging{};
  shared_ptr<string> requestId{};

  DescribeApiMarketAttributesResponseBody() {}

  explicit DescribeApiMarketAttributesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiId) {
      res["ApiId"] = boost::any(*apiId);
    }
    if (marketChargingMode) {
      res["MarketChargingMode"] = boost::any(*marketChargingMode);
    }
    if (needCharging) {
      res["NeedCharging"] = boost::any(*needCharging);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiId") != m.end() && !m["ApiId"].empty()) {
      apiId = make_shared<string>(boost::any_cast<string>(m["ApiId"]));
    }
    if (m.find("MarketChargingMode") != m.end() && !m["MarketChargingMode"].empty()) {
      marketChargingMode = make_shared<string>(boost::any_cast<string>(m["MarketChargingMode"]));
    }
    if (m.find("NeedCharging") != m.end() && !m["NeedCharging"].empty()) {
      needCharging = make_shared<string>(boost::any_cast<string>(m["NeedCharging"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeApiMarketAttributesResponseBody() = default;
};
class DescribeApiMarketAttributesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeApiMarketAttributesResponseBody> body{};

  DescribeApiMarketAttributesResponse() {}

  explicit DescribeApiMarketAttributesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeApiMarketAttributesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeApiMarketAttributesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeApiMarketAttributesResponse() = default;
};
class DescribeApiQpsDataRequest : public Darabonba::Model {
public:
  shared_ptr<string> apiId{};
  shared_ptr<string> endTime{};
  shared_ptr<string> groupId{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> stageName{};
  shared_ptr<string> startTime{};

  DescribeApiQpsDataRequest() {}

  explicit DescribeApiQpsDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiId) {
      res["ApiId"] = boost::any(*apiId);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (stageName) {
      res["StageName"] = boost::any(*stageName);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiId") != m.end() && !m["ApiId"].empty()) {
      apiId = make_shared<string>(boost::any_cast<string>(m["ApiId"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("StageName") != m.end() && !m["StageName"].empty()) {
      stageName = make_shared<string>(boost::any_cast<string>(m["StageName"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeApiQpsDataRequest() = default;
};
class DescribeApiQpsDataResponseBodyCallFailsMonitorItem : public Darabonba::Model {
public:
  shared_ptr<string> itemTime{};
  shared_ptr<string> itemValue{};

  DescribeApiQpsDataResponseBodyCallFailsMonitorItem() {}

  explicit DescribeApiQpsDataResponseBodyCallFailsMonitorItem(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (itemTime) {
      res["ItemTime"] = boost::any(*itemTime);
    }
    if (itemValue) {
      res["ItemValue"] = boost::any(*itemValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ItemTime") != m.end() && !m["ItemTime"].empty()) {
      itemTime = make_shared<string>(boost::any_cast<string>(m["ItemTime"]));
    }
    if (m.find("ItemValue") != m.end() && !m["ItemValue"].empty()) {
      itemValue = make_shared<string>(boost::any_cast<string>(m["ItemValue"]));
    }
  }


  virtual ~DescribeApiQpsDataResponseBodyCallFailsMonitorItem() = default;
};
class DescribeApiQpsDataResponseBodyCallFails : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeApiQpsDataResponseBodyCallFailsMonitorItem>> monitorItem{};

  DescribeApiQpsDataResponseBodyCallFails() {}

  explicit DescribeApiQpsDataResponseBodyCallFails(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (monitorItem) {
      vector<boost::any> temp1;
      for(auto item1:*monitorItem){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["MonitorItem"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MonitorItem") != m.end() && !m["MonitorItem"].empty()) {
      if (typeid(vector<boost::any>) == m["MonitorItem"].type()) {
        vector<DescribeApiQpsDataResponseBodyCallFailsMonitorItem> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["MonitorItem"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeApiQpsDataResponseBodyCallFailsMonitorItem model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        monitorItem = make_shared<vector<DescribeApiQpsDataResponseBodyCallFailsMonitorItem>>(expect1);
      }
    }
  }


  virtual ~DescribeApiQpsDataResponseBodyCallFails() = default;
};
class DescribeApiQpsDataResponseBodyCallSuccessesMonitorItem : public Darabonba::Model {
public:
  shared_ptr<string> itemTime{};
  shared_ptr<string> itemValue{};

  DescribeApiQpsDataResponseBodyCallSuccessesMonitorItem() {}

  explicit DescribeApiQpsDataResponseBodyCallSuccessesMonitorItem(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (itemTime) {
      res["ItemTime"] = boost::any(*itemTime);
    }
    if (itemValue) {
      res["ItemValue"] = boost::any(*itemValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ItemTime") != m.end() && !m["ItemTime"].empty()) {
      itemTime = make_shared<string>(boost::any_cast<string>(m["ItemTime"]));
    }
    if (m.find("ItemValue") != m.end() && !m["ItemValue"].empty()) {
      itemValue = make_shared<string>(boost::any_cast<string>(m["ItemValue"]));
    }
  }


  virtual ~DescribeApiQpsDataResponseBodyCallSuccessesMonitorItem() = default;
};
class DescribeApiQpsDataResponseBodyCallSuccesses : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeApiQpsDataResponseBodyCallSuccessesMonitorItem>> monitorItem{};

  DescribeApiQpsDataResponseBodyCallSuccesses() {}

  explicit DescribeApiQpsDataResponseBodyCallSuccesses(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (monitorItem) {
      vector<boost::any> temp1;
      for(auto item1:*monitorItem){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["MonitorItem"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MonitorItem") != m.end() && !m["MonitorItem"].empty()) {
      if (typeid(vector<boost::any>) == m["MonitorItem"].type()) {
        vector<DescribeApiQpsDataResponseBodyCallSuccessesMonitorItem> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["MonitorItem"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeApiQpsDataResponseBodyCallSuccessesMonitorItem model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        monitorItem = make_shared<vector<DescribeApiQpsDataResponseBodyCallSuccessesMonitorItem>>(expect1);
      }
    }
  }


  virtual ~DescribeApiQpsDataResponseBodyCallSuccesses() = default;
};
class DescribeApiQpsDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeApiQpsDataResponseBodyCallFails> callFails{};
  shared_ptr<DescribeApiQpsDataResponseBodyCallSuccesses> callSuccesses{};
  shared_ptr<string> requestId{};

  DescribeApiQpsDataResponseBody() {}

  explicit DescribeApiQpsDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callFails) {
      res["CallFails"] = callFails ? boost::any(callFails->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (callSuccesses) {
      res["CallSuccesses"] = callSuccesses ? boost::any(callSuccesses->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallFails") != m.end() && !m["CallFails"].empty()) {
      if (typeid(map<string, boost::any>) == m["CallFails"].type()) {
        DescribeApiQpsDataResponseBodyCallFails model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CallFails"]));
        callFails = make_shared<DescribeApiQpsDataResponseBodyCallFails>(model1);
      }
    }
    if (m.find("CallSuccesses") != m.end() && !m["CallSuccesses"].empty()) {
      if (typeid(map<string, boost::any>) == m["CallSuccesses"].type()) {
        DescribeApiQpsDataResponseBodyCallSuccesses model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CallSuccesses"]));
        callSuccesses = make_shared<DescribeApiQpsDataResponseBodyCallSuccesses>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeApiQpsDataResponseBody() = default;
};
class DescribeApiQpsDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeApiQpsDataResponseBody> body{};

  DescribeApiQpsDataResponse() {}

  explicit DescribeApiQpsDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeApiQpsDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeApiQpsDataResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeApiQpsDataResponse() = default;
};
class DescribeApiSignaturesRequest : public Darabonba::Model {
public:
  shared_ptr<string> apiIds{};
  shared_ptr<string> groupId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> stageName{};

  DescribeApiSignaturesRequest() {}

  explicit DescribeApiSignaturesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiIds) {
      res["ApiIds"] = boost::any(*apiIds);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (stageName) {
      res["StageName"] = boost::any(*stageName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiIds") != m.end() && !m["ApiIds"].empty()) {
      apiIds = make_shared<string>(boost::any_cast<string>(m["ApiIds"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("StageName") != m.end() && !m["StageName"].empty()) {
      stageName = make_shared<string>(boost::any_cast<string>(m["StageName"]));
    }
  }


  virtual ~DescribeApiSignaturesRequest() = default;
};
class DescribeApiSignaturesResponseBodyApiSignaturesApiSignatureItem : public Darabonba::Model {
public:
  shared_ptr<string> apiId{};
  shared_ptr<string> apiName{};
  shared_ptr<string> boundTime{};
  shared_ptr<string> signatureId{};
  shared_ptr<string> signatureName{};

  DescribeApiSignaturesResponseBodyApiSignaturesApiSignatureItem() {}

  explicit DescribeApiSignaturesResponseBodyApiSignaturesApiSignatureItem(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiId) {
      res["ApiId"] = boost::any(*apiId);
    }
    if (apiName) {
      res["ApiName"] = boost::any(*apiName);
    }
    if (boundTime) {
      res["BoundTime"] = boost::any(*boundTime);
    }
    if (signatureId) {
      res["SignatureId"] = boost::any(*signatureId);
    }
    if (signatureName) {
      res["SignatureName"] = boost::any(*signatureName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiId") != m.end() && !m["ApiId"].empty()) {
      apiId = make_shared<string>(boost::any_cast<string>(m["ApiId"]));
    }
    if (m.find("ApiName") != m.end() && !m["ApiName"].empty()) {
      apiName = make_shared<string>(boost::any_cast<string>(m["ApiName"]));
    }
    if (m.find("BoundTime") != m.end() && !m["BoundTime"].empty()) {
      boundTime = make_shared<string>(boost::any_cast<string>(m["BoundTime"]));
    }
    if (m.find("SignatureId") != m.end() && !m["SignatureId"].empty()) {
      signatureId = make_shared<string>(boost::any_cast<string>(m["SignatureId"]));
    }
    if (m.find("SignatureName") != m.end() && !m["SignatureName"].empty()) {
      signatureName = make_shared<string>(boost::any_cast<string>(m["SignatureName"]));
    }
  }


  virtual ~DescribeApiSignaturesResponseBodyApiSignaturesApiSignatureItem() = default;
};
class DescribeApiSignaturesResponseBodyApiSignatures : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeApiSignaturesResponseBodyApiSignaturesApiSignatureItem>> apiSignatureItem{};

  DescribeApiSignaturesResponseBodyApiSignatures() {}

  explicit DescribeApiSignaturesResponseBodyApiSignatures(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiSignatureItem) {
      vector<boost::any> temp1;
      for(auto item1:*apiSignatureItem){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ApiSignatureItem"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiSignatureItem") != m.end() && !m["ApiSignatureItem"].empty()) {
      if (typeid(vector<boost::any>) == m["ApiSignatureItem"].type()) {
        vector<DescribeApiSignaturesResponseBodyApiSignaturesApiSignatureItem> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ApiSignatureItem"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeApiSignaturesResponseBodyApiSignaturesApiSignatureItem model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        apiSignatureItem = make_shared<vector<DescribeApiSignaturesResponseBodyApiSignaturesApiSignatureItem>>(expect1);
      }
    }
  }


  virtual ~DescribeApiSignaturesResponseBodyApiSignatures() = default;
};
class DescribeApiSignaturesResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeApiSignaturesResponseBodyApiSignatures> apiSignatures{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeApiSignaturesResponseBody() {}

  explicit DescribeApiSignaturesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiSignatures) {
      res["ApiSignatures"] = apiSignatures ? boost::any(apiSignatures->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiSignatures") != m.end() && !m["ApiSignatures"].empty()) {
      if (typeid(map<string, boost::any>) == m["ApiSignatures"].type()) {
        DescribeApiSignaturesResponseBodyApiSignatures model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ApiSignatures"]));
        apiSignatures = make_shared<DescribeApiSignaturesResponseBodyApiSignatures>(model1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeApiSignaturesResponseBody() = default;
};
class DescribeApiSignaturesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeApiSignaturesResponseBody> body{};

  DescribeApiSignaturesResponse() {}

  explicit DescribeApiSignaturesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeApiSignaturesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeApiSignaturesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeApiSignaturesResponse() = default;
};
class DescribeApiTrafficControlsRequest : public Darabonba::Model {
public:
  shared_ptr<string> apiIds{};
  shared_ptr<string> groupId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> stageName{};

  DescribeApiTrafficControlsRequest() {}

  explicit DescribeApiTrafficControlsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiIds) {
      res["ApiIds"] = boost::any(*apiIds);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (stageName) {
      res["StageName"] = boost::any(*stageName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiIds") != m.end() && !m["ApiIds"].empty()) {
      apiIds = make_shared<string>(boost::any_cast<string>(m["ApiIds"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("StageName") != m.end() && !m["StageName"].empty()) {
      stageName = make_shared<string>(boost::any_cast<string>(m["StageName"]));
    }
  }


  virtual ~DescribeApiTrafficControlsRequest() = default;
};
class DescribeApiTrafficControlsResponseBodyApiTrafficControlsApiTrafficControlItem : public Darabonba::Model {
public:
  shared_ptr<string> apiId{};
  shared_ptr<string> apiName{};
  shared_ptr<string> boundTime{};
  shared_ptr<string> trafficControlId{};
  shared_ptr<string> trafficControlName{};

  DescribeApiTrafficControlsResponseBodyApiTrafficControlsApiTrafficControlItem() {}

  explicit DescribeApiTrafficControlsResponseBodyApiTrafficControlsApiTrafficControlItem(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiId) {
      res["ApiId"] = boost::any(*apiId);
    }
    if (apiName) {
      res["ApiName"] = boost::any(*apiName);
    }
    if (boundTime) {
      res["BoundTime"] = boost::any(*boundTime);
    }
    if (trafficControlId) {
      res["TrafficControlId"] = boost::any(*trafficControlId);
    }
    if (trafficControlName) {
      res["TrafficControlName"] = boost::any(*trafficControlName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiId") != m.end() && !m["ApiId"].empty()) {
      apiId = make_shared<string>(boost::any_cast<string>(m["ApiId"]));
    }
    if (m.find("ApiName") != m.end() && !m["ApiName"].empty()) {
      apiName = make_shared<string>(boost::any_cast<string>(m["ApiName"]));
    }
    if (m.find("BoundTime") != m.end() && !m["BoundTime"].empty()) {
      boundTime = make_shared<string>(boost::any_cast<string>(m["BoundTime"]));
    }
    if (m.find("TrafficControlId") != m.end() && !m["TrafficControlId"].empty()) {
      trafficControlId = make_shared<string>(boost::any_cast<string>(m["TrafficControlId"]));
    }
    if (m.find("TrafficControlName") != m.end() && !m["TrafficControlName"].empty()) {
      trafficControlName = make_shared<string>(boost::any_cast<string>(m["TrafficControlName"]));
    }
  }


  virtual ~DescribeApiTrafficControlsResponseBodyApiTrafficControlsApiTrafficControlItem() = default;
};
class DescribeApiTrafficControlsResponseBodyApiTrafficControls : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeApiTrafficControlsResponseBodyApiTrafficControlsApiTrafficControlItem>> apiTrafficControlItem{};

  DescribeApiTrafficControlsResponseBodyApiTrafficControls() {}

  explicit DescribeApiTrafficControlsResponseBodyApiTrafficControls(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiTrafficControlItem) {
      vector<boost::any> temp1;
      for(auto item1:*apiTrafficControlItem){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ApiTrafficControlItem"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiTrafficControlItem") != m.end() && !m["ApiTrafficControlItem"].empty()) {
      if (typeid(vector<boost::any>) == m["ApiTrafficControlItem"].type()) {
        vector<DescribeApiTrafficControlsResponseBodyApiTrafficControlsApiTrafficControlItem> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ApiTrafficControlItem"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeApiTrafficControlsResponseBodyApiTrafficControlsApiTrafficControlItem model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        apiTrafficControlItem = make_shared<vector<DescribeApiTrafficControlsResponseBodyApiTrafficControlsApiTrafficControlItem>>(expect1);
      }
    }
  }


  virtual ~DescribeApiTrafficControlsResponseBodyApiTrafficControls() = default;
};
class DescribeApiTrafficControlsResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeApiTrafficControlsResponseBodyApiTrafficControls> apiTrafficControls{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeApiTrafficControlsResponseBody() {}

  explicit DescribeApiTrafficControlsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiTrafficControls) {
      res["ApiTrafficControls"] = apiTrafficControls ? boost::any(apiTrafficControls->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiTrafficControls") != m.end() && !m["ApiTrafficControls"].empty()) {
      if (typeid(map<string, boost::any>) == m["ApiTrafficControls"].type()) {
        DescribeApiTrafficControlsResponseBodyApiTrafficControls model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ApiTrafficControls"]));
        apiTrafficControls = make_shared<DescribeApiTrafficControlsResponseBodyApiTrafficControls>(model1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeApiTrafficControlsResponseBody() = default;
};
class DescribeApiTrafficControlsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeApiTrafficControlsResponseBody> body{};

  DescribeApiTrafficControlsResponse() {}

  explicit DescribeApiTrafficControlsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeApiTrafficControlsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeApiTrafficControlsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeApiTrafficControlsResponse() = default;
};
class DescribeApiTrafficDataRequest : public Darabonba::Model {
public:
  shared_ptr<string> apiId{};
  shared_ptr<string> endTime{};
  shared_ptr<string> groupId{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> stageName{};
  shared_ptr<string> startTime{};

  DescribeApiTrafficDataRequest() {}

  explicit DescribeApiTrafficDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiId) {
      res["ApiId"] = boost::any(*apiId);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (stageName) {
      res["StageName"] = boost::any(*stageName);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiId") != m.end() && !m["ApiId"].empty()) {
      apiId = make_shared<string>(boost::any_cast<string>(m["ApiId"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("StageName") != m.end() && !m["StageName"].empty()) {
      stageName = make_shared<string>(boost::any_cast<string>(m["StageName"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeApiTrafficDataRequest() = default;
};
class DescribeApiTrafficDataResponseBodyCallDownloadsMonitorItem : public Darabonba::Model {
public:
  shared_ptr<string> itemTime{};
  shared_ptr<string> itemValue{};

  DescribeApiTrafficDataResponseBodyCallDownloadsMonitorItem() {}

  explicit DescribeApiTrafficDataResponseBodyCallDownloadsMonitorItem(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (itemTime) {
      res["ItemTime"] = boost::any(*itemTime);
    }
    if (itemValue) {
      res["ItemValue"] = boost::any(*itemValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ItemTime") != m.end() && !m["ItemTime"].empty()) {
      itemTime = make_shared<string>(boost::any_cast<string>(m["ItemTime"]));
    }
    if (m.find("ItemValue") != m.end() && !m["ItemValue"].empty()) {
      itemValue = make_shared<string>(boost::any_cast<string>(m["ItemValue"]));
    }
  }


  virtual ~DescribeApiTrafficDataResponseBodyCallDownloadsMonitorItem() = default;
};
class DescribeApiTrafficDataResponseBodyCallDownloads : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeApiTrafficDataResponseBodyCallDownloadsMonitorItem>> monitorItem{};

  DescribeApiTrafficDataResponseBodyCallDownloads() {}

  explicit DescribeApiTrafficDataResponseBodyCallDownloads(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (monitorItem) {
      vector<boost::any> temp1;
      for(auto item1:*monitorItem){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["MonitorItem"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MonitorItem") != m.end() && !m["MonitorItem"].empty()) {
      if (typeid(vector<boost::any>) == m["MonitorItem"].type()) {
        vector<DescribeApiTrafficDataResponseBodyCallDownloadsMonitorItem> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["MonitorItem"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeApiTrafficDataResponseBodyCallDownloadsMonitorItem model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        monitorItem = make_shared<vector<DescribeApiTrafficDataResponseBodyCallDownloadsMonitorItem>>(expect1);
      }
    }
  }


  virtual ~DescribeApiTrafficDataResponseBodyCallDownloads() = default;
};
class DescribeApiTrafficDataResponseBodyCallUploadsMonitorItem : public Darabonba::Model {
public:
  shared_ptr<string> itemTime{};
  shared_ptr<string> itemValue{};

  DescribeApiTrafficDataResponseBodyCallUploadsMonitorItem() {}

  explicit DescribeApiTrafficDataResponseBodyCallUploadsMonitorItem(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (itemTime) {
      res["ItemTime"] = boost::any(*itemTime);
    }
    if (itemValue) {
      res["ItemValue"] = boost::any(*itemValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ItemTime") != m.end() && !m["ItemTime"].empty()) {
      itemTime = make_shared<string>(boost::any_cast<string>(m["ItemTime"]));
    }
    if (m.find("ItemValue") != m.end() && !m["ItemValue"].empty()) {
      itemValue = make_shared<string>(boost::any_cast<string>(m["ItemValue"]));
    }
  }


  virtual ~DescribeApiTrafficDataResponseBodyCallUploadsMonitorItem() = default;
};
class DescribeApiTrafficDataResponseBodyCallUploads : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeApiTrafficDataResponseBodyCallUploadsMonitorItem>> monitorItem{};

  DescribeApiTrafficDataResponseBodyCallUploads() {}

  explicit DescribeApiTrafficDataResponseBodyCallUploads(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (monitorItem) {
      vector<boost::any> temp1;
      for(auto item1:*monitorItem){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["MonitorItem"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MonitorItem") != m.end() && !m["MonitorItem"].empty()) {
      if (typeid(vector<boost::any>) == m["MonitorItem"].type()) {
        vector<DescribeApiTrafficDataResponseBodyCallUploadsMonitorItem> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["MonitorItem"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeApiTrafficDataResponseBodyCallUploadsMonitorItem model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        monitorItem = make_shared<vector<DescribeApiTrafficDataResponseBodyCallUploadsMonitorItem>>(expect1);
      }
    }
  }


  virtual ~DescribeApiTrafficDataResponseBodyCallUploads() = default;
};
class DescribeApiTrafficDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeApiTrafficDataResponseBodyCallDownloads> callDownloads{};
  shared_ptr<DescribeApiTrafficDataResponseBodyCallUploads> callUploads{};
  shared_ptr<string> requestId{};

  DescribeApiTrafficDataResponseBody() {}

  explicit DescribeApiTrafficDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callDownloads) {
      res["CallDownloads"] = callDownloads ? boost::any(callDownloads->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (callUploads) {
      res["CallUploads"] = callUploads ? boost::any(callUploads->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallDownloads") != m.end() && !m["CallDownloads"].empty()) {
      if (typeid(map<string, boost::any>) == m["CallDownloads"].type()) {
        DescribeApiTrafficDataResponseBodyCallDownloads model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CallDownloads"]));
        callDownloads = make_shared<DescribeApiTrafficDataResponseBodyCallDownloads>(model1);
      }
    }
    if (m.find("CallUploads") != m.end() && !m["CallUploads"].empty()) {
      if (typeid(map<string, boost::any>) == m["CallUploads"].type()) {
        DescribeApiTrafficDataResponseBodyCallUploads model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CallUploads"]));
        callUploads = make_shared<DescribeApiTrafficDataResponseBodyCallUploads>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeApiTrafficDataResponseBody() = default;
};
class DescribeApiTrafficDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeApiTrafficDataResponseBody> body{};

  DescribeApiTrafficDataResponse() {}

  explicit DescribeApiTrafficDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeApiTrafficDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeApiTrafficDataResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeApiTrafficDataResponse() = default;
};
class DescribeApisRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  DescribeApisRequestTag() {}

  explicit DescribeApisRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeApisRequestTag() = default;
};
class DescribeApisRequest : public Darabonba::Model {
public:
  shared_ptr<string> apiId{};
  shared_ptr<string> apiName{};
  shared_ptr<string> catalogId{};
  shared_ptr<bool> enableTagAuth{};
  shared_ptr<string> groupId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> securityToken{};
  shared_ptr<vector<DescribeApisRequestTag>> tag{};
  shared_ptr<string> visibility{};

  DescribeApisRequest() {}

  explicit DescribeApisRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiId) {
      res["ApiId"] = boost::any(*apiId);
    }
    if (apiName) {
      res["ApiName"] = boost::any(*apiName);
    }
    if (catalogId) {
      res["CatalogId"] = boost::any(*catalogId);
    }
    if (enableTagAuth) {
      res["EnableTagAuth"] = boost::any(*enableTagAuth);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    if (visibility) {
      res["Visibility"] = boost::any(*visibility);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiId") != m.end() && !m["ApiId"].empty()) {
      apiId = make_shared<string>(boost::any_cast<string>(m["ApiId"]));
    }
    if (m.find("ApiName") != m.end() && !m["ApiName"].empty()) {
      apiName = make_shared<string>(boost::any_cast<string>(m["ApiName"]));
    }
    if (m.find("CatalogId") != m.end() && !m["CatalogId"].empty()) {
      catalogId = make_shared<string>(boost::any_cast<string>(m["CatalogId"]));
    }
    if (m.find("EnableTagAuth") != m.end() && !m["EnableTagAuth"].empty()) {
      enableTagAuth = make_shared<bool>(boost::any_cast<bool>(m["EnableTagAuth"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<DescribeApisRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeApisRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<DescribeApisRequestTag>>(expect1);
      }
    }
    if (m.find("Visibility") != m.end() && !m["Visibility"].empty()) {
      visibility = make_shared<string>(boost::any_cast<string>(m["Visibility"]));
    }
  }


  virtual ~DescribeApisRequest() = default;
};
class DescribeApisResponseBodyApiSummarysApiSummary : public Darabonba::Model {
public:
  shared_ptr<string> apiId{};
  shared_ptr<string> apiName{};
  shared_ptr<string> createdTime{};
  shared_ptr<string> description{};
  shared_ptr<string> groupId{};
  shared_ptr<string> groupName{};
  shared_ptr<string> modifiedTime{};
  shared_ptr<string> regionId{};
  shared_ptr<string> visibility{};

  DescribeApisResponseBodyApiSummarysApiSummary() {}

  explicit DescribeApisResponseBodyApiSummarysApiSummary(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiId) {
      res["ApiId"] = boost::any(*apiId);
    }
    if (apiName) {
      res["ApiName"] = boost::any(*apiName);
    }
    if (createdTime) {
      res["CreatedTime"] = boost::any(*createdTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (modifiedTime) {
      res["ModifiedTime"] = boost::any(*modifiedTime);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (visibility) {
      res["Visibility"] = boost::any(*visibility);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiId") != m.end() && !m["ApiId"].empty()) {
      apiId = make_shared<string>(boost::any_cast<string>(m["ApiId"]));
    }
    if (m.find("ApiName") != m.end() && !m["ApiName"].empty()) {
      apiName = make_shared<string>(boost::any_cast<string>(m["ApiName"]));
    }
    if (m.find("CreatedTime") != m.end() && !m["CreatedTime"].empty()) {
      createdTime = make_shared<string>(boost::any_cast<string>(m["CreatedTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("ModifiedTime") != m.end() && !m["ModifiedTime"].empty()) {
      modifiedTime = make_shared<string>(boost::any_cast<string>(m["ModifiedTime"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Visibility") != m.end() && !m["Visibility"].empty()) {
      visibility = make_shared<string>(boost::any_cast<string>(m["Visibility"]));
    }
  }


  virtual ~DescribeApisResponseBodyApiSummarysApiSummary() = default;
};
class DescribeApisResponseBodyApiSummarys : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeApisResponseBodyApiSummarysApiSummary>> apiSummary{};

  DescribeApisResponseBodyApiSummarys() {}

  explicit DescribeApisResponseBodyApiSummarys(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiSummary) {
      vector<boost::any> temp1;
      for(auto item1:*apiSummary){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ApiSummary"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiSummary") != m.end() && !m["ApiSummary"].empty()) {
      if (typeid(vector<boost::any>) == m["ApiSummary"].type()) {
        vector<DescribeApisResponseBodyApiSummarysApiSummary> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ApiSummary"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeApisResponseBodyApiSummarysApiSummary model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        apiSummary = make_shared<vector<DescribeApisResponseBodyApiSummarysApiSummary>>(expect1);
      }
    }
  }


  virtual ~DescribeApisResponseBodyApiSummarys() = default;
};
class DescribeApisResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeApisResponseBodyApiSummarys> apiSummarys{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeApisResponseBody() {}

  explicit DescribeApisResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiSummarys) {
      res["ApiSummarys"] = apiSummarys ? boost::any(apiSummarys->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiSummarys") != m.end() && !m["ApiSummarys"].empty()) {
      if (typeid(map<string, boost::any>) == m["ApiSummarys"].type()) {
        DescribeApisResponseBodyApiSummarys model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ApiSummarys"]));
        apiSummarys = make_shared<DescribeApisResponseBodyApiSummarys>(model1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeApisResponseBody() = default;
};
class DescribeApisResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeApisResponseBody> body{};

  DescribeApisResponse() {}

  explicit DescribeApisResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeApisResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeApisResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeApisResponse() = default;
};
class DescribeApisByAppRequest : public Darabonba::Model {
public:
  shared_ptr<string> apiName{};
  shared_ptr<string> apiUid{};
  shared_ptr<long> appId{};
  shared_ptr<string> method{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> path{};
  shared_ptr<string> securityToken{};

  DescribeApisByAppRequest() {}

  explicit DescribeApisByAppRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiName) {
      res["ApiName"] = boost::any(*apiName);
    }
    if (apiUid) {
      res["ApiUid"] = boost::any(*apiUid);
    }
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (method) {
      res["Method"] = boost::any(*method);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (path) {
      res["Path"] = boost::any(*path);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiName") != m.end() && !m["ApiName"].empty()) {
      apiName = make_shared<string>(boost::any_cast<string>(m["ApiName"]));
    }
    if (m.find("ApiUid") != m.end() && !m["ApiUid"].empty()) {
      apiUid = make_shared<string>(boost::any_cast<string>(m["ApiUid"]));
    }
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<long>(boost::any_cast<long>(m["AppId"]));
    }
    if (m.find("Method") != m.end() && !m["Method"].empty()) {
      method = make_shared<string>(boost::any_cast<string>(m["Method"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Path") != m.end() && !m["Path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["Path"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~DescribeApisByAppRequest() = default;
};
class DescribeApisByAppResponseBodyAppApiRelationInfosAppApiRelationInfo : public Darabonba::Model {
public:
  shared_ptr<string> apiId{};
  shared_ptr<string> apiName{};
  shared_ptr<string> authVaildTime{};
  shared_ptr<string> authorizationSource{};
  shared_ptr<string> createdTime{};
  shared_ptr<string> description{};
  shared_ptr<string> groupId{};
  shared_ptr<string> groupName{};
  shared_ptr<string> method{};
  shared_ptr<string> operator_{};
  shared_ptr<string> path{};
  shared_ptr<string> regionId{};
  shared_ptr<string> stageName{};

  DescribeApisByAppResponseBodyAppApiRelationInfosAppApiRelationInfo() {}

  explicit DescribeApisByAppResponseBodyAppApiRelationInfosAppApiRelationInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiId) {
      res["ApiId"] = boost::any(*apiId);
    }
    if (apiName) {
      res["ApiName"] = boost::any(*apiName);
    }
    if (authVaildTime) {
      res["AuthVaildTime"] = boost::any(*authVaildTime);
    }
    if (authorizationSource) {
      res["AuthorizationSource"] = boost::any(*authorizationSource);
    }
    if (createdTime) {
      res["CreatedTime"] = boost::any(*createdTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (method) {
      res["Method"] = boost::any(*method);
    }
    if (operator_) {
      res["Operator"] = boost::any(*operator_);
    }
    if (path) {
      res["Path"] = boost::any(*path);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (stageName) {
      res["StageName"] = boost::any(*stageName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiId") != m.end() && !m["ApiId"].empty()) {
      apiId = make_shared<string>(boost::any_cast<string>(m["ApiId"]));
    }
    if (m.find("ApiName") != m.end() && !m["ApiName"].empty()) {
      apiName = make_shared<string>(boost::any_cast<string>(m["ApiName"]));
    }
    if (m.find("AuthVaildTime") != m.end() && !m["AuthVaildTime"].empty()) {
      authVaildTime = make_shared<string>(boost::any_cast<string>(m["AuthVaildTime"]));
    }
    if (m.find("AuthorizationSource") != m.end() && !m["AuthorizationSource"].empty()) {
      authorizationSource = make_shared<string>(boost::any_cast<string>(m["AuthorizationSource"]));
    }
    if (m.find("CreatedTime") != m.end() && !m["CreatedTime"].empty()) {
      createdTime = make_shared<string>(boost::any_cast<string>(m["CreatedTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("Method") != m.end() && !m["Method"].empty()) {
      method = make_shared<string>(boost::any_cast<string>(m["Method"]));
    }
    if (m.find("Operator") != m.end() && !m["Operator"].empty()) {
      operator_ = make_shared<string>(boost::any_cast<string>(m["Operator"]));
    }
    if (m.find("Path") != m.end() && !m["Path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["Path"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("StageName") != m.end() && !m["StageName"].empty()) {
      stageName = make_shared<string>(boost::any_cast<string>(m["StageName"]));
    }
  }


  virtual ~DescribeApisByAppResponseBodyAppApiRelationInfosAppApiRelationInfo() = default;
};
class DescribeApisByAppResponseBodyAppApiRelationInfos : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeApisByAppResponseBodyAppApiRelationInfosAppApiRelationInfo>> appApiRelationInfo{};

  DescribeApisByAppResponseBodyAppApiRelationInfos() {}

  explicit DescribeApisByAppResponseBodyAppApiRelationInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appApiRelationInfo) {
      vector<boost::any> temp1;
      for(auto item1:*appApiRelationInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AppApiRelationInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppApiRelationInfo") != m.end() && !m["AppApiRelationInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["AppApiRelationInfo"].type()) {
        vector<DescribeApisByAppResponseBodyAppApiRelationInfosAppApiRelationInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AppApiRelationInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeApisByAppResponseBodyAppApiRelationInfosAppApiRelationInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        appApiRelationInfo = make_shared<vector<DescribeApisByAppResponseBodyAppApiRelationInfosAppApiRelationInfo>>(expect1);
      }
    }
  }


  virtual ~DescribeApisByAppResponseBodyAppApiRelationInfos() = default;
};
class DescribeApisByAppResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeApisByAppResponseBodyAppApiRelationInfos> appApiRelationInfos{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeApisByAppResponseBody() {}

  explicit DescribeApisByAppResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appApiRelationInfos) {
      res["AppApiRelationInfos"] = appApiRelationInfos ? boost::any(appApiRelationInfos->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppApiRelationInfos") != m.end() && !m["AppApiRelationInfos"].empty()) {
      if (typeid(map<string, boost::any>) == m["AppApiRelationInfos"].type()) {
        DescribeApisByAppResponseBodyAppApiRelationInfos model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AppApiRelationInfos"]));
        appApiRelationInfos = make_shared<DescribeApisByAppResponseBodyAppApiRelationInfos>(model1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeApisByAppResponseBody() = default;
};
class DescribeApisByAppResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeApisByAppResponseBody> body{};

  DescribeApisByAppResponse() {}

  explicit DescribeApisByAppResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeApisByAppResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeApisByAppResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeApisByAppResponse() = default;
};
class DescribeApisByIpControlRequest : public Darabonba::Model {
public:
  shared_ptr<string> ipControlId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> securityToken{};

  DescribeApisByIpControlRequest() {}

  explicit DescribeApisByIpControlRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ipControlId) {
      res["IpControlId"] = boost::any(*ipControlId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IpControlId") != m.end() && !m["IpControlId"].empty()) {
      ipControlId = make_shared<string>(boost::any_cast<string>(m["IpControlId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~DescribeApisByIpControlRequest() = default;
};
class DescribeApisByIpControlResponseBodyApiInfosApiInfo : public Darabonba::Model {
public:
  shared_ptr<string> apiId{};
  shared_ptr<string> apiName{};
  shared_ptr<string> boundTime{};
  shared_ptr<string> description{};
  shared_ptr<string> groupId{};
  shared_ptr<string> groupName{};
  shared_ptr<string> regionId{};
  shared_ptr<string> stageName{};
  shared_ptr<string> visibility{};

  DescribeApisByIpControlResponseBodyApiInfosApiInfo() {}

  explicit DescribeApisByIpControlResponseBodyApiInfosApiInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiId) {
      res["ApiId"] = boost::any(*apiId);
    }
    if (apiName) {
      res["ApiName"] = boost::any(*apiName);
    }
    if (boundTime) {
      res["BoundTime"] = boost::any(*boundTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (stageName) {
      res["StageName"] = boost::any(*stageName);
    }
    if (visibility) {
      res["Visibility"] = boost::any(*visibility);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiId") != m.end() && !m["ApiId"].empty()) {
      apiId = make_shared<string>(boost::any_cast<string>(m["ApiId"]));
    }
    if (m.find("ApiName") != m.end() && !m["ApiName"].empty()) {
      apiName = make_shared<string>(boost::any_cast<string>(m["ApiName"]));
    }
    if (m.find("BoundTime") != m.end() && !m["BoundTime"].empty()) {
      boundTime = make_shared<string>(boost::any_cast<string>(m["BoundTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("StageName") != m.end() && !m["StageName"].empty()) {
      stageName = make_shared<string>(boost::any_cast<string>(m["StageName"]));
    }
    if (m.find("Visibility") != m.end() && !m["Visibility"].empty()) {
      visibility = make_shared<string>(boost::any_cast<string>(m["Visibility"]));
    }
  }


  virtual ~DescribeApisByIpControlResponseBodyApiInfosApiInfo() = default;
};
class DescribeApisByIpControlResponseBodyApiInfos : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeApisByIpControlResponseBodyApiInfosApiInfo>> apiInfo{};

  DescribeApisByIpControlResponseBodyApiInfos() {}

  explicit DescribeApisByIpControlResponseBodyApiInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiInfo) {
      vector<boost::any> temp1;
      for(auto item1:*apiInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ApiInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiInfo") != m.end() && !m["ApiInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["ApiInfo"].type()) {
        vector<DescribeApisByIpControlResponseBodyApiInfosApiInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ApiInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeApisByIpControlResponseBodyApiInfosApiInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        apiInfo = make_shared<vector<DescribeApisByIpControlResponseBodyApiInfosApiInfo>>(expect1);
      }
    }
  }


  virtual ~DescribeApisByIpControlResponseBodyApiInfos() = default;
};
class DescribeApisByIpControlResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeApisByIpControlResponseBodyApiInfos> apiInfos{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeApisByIpControlResponseBody() {}

  explicit DescribeApisByIpControlResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiInfos) {
      res["ApiInfos"] = apiInfos ? boost::any(apiInfos->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiInfos") != m.end() && !m["ApiInfos"].empty()) {
      if (typeid(map<string, boost::any>) == m["ApiInfos"].type()) {
        DescribeApisByIpControlResponseBodyApiInfos model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ApiInfos"]));
        apiInfos = make_shared<DescribeApisByIpControlResponseBodyApiInfos>(model1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeApisByIpControlResponseBody() = default;
};
class DescribeApisByIpControlResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeApisByIpControlResponseBody> body{};

  DescribeApisByIpControlResponse() {}

  explicit DescribeApisByIpControlResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeApisByIpControlResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeApisByIpControlResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeApisByIpControlResponse() = default;
};
class DescribeApisBySignatureRequest : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> signatureId{};

  DescribeApisBySignatureRequest() {}

  explicit DescribeApisBySignatureRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (signatureId) {
      res["SignatureId"] = boost::any(*signatureId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("SignatureId") != m.end() && !m["SignatureId"].empty()) {
      signatureId = make_shared<string>(boost::any_cast<string>(m["SignatureId"]));
    }
  }


  virtual ~DescribeApisBySignatureRequest() = default;
};
class DescribeApisBySignatureResponseBodyApiInfosApiInfo : public Darabonba::Model {
public:
  shared_ptr<string> apiId{};
  shared_ptr<string> apiName{};
  shared_ptr<string> boundTime{};
  shared_ptr<string> description{};
  shared_ptr<string> groupId{};
  shared_ptr<string> groupName{};
  shared_ptr<string> regionId{};
  shared_ptr<string> stageName{};
  shared_ptr<string> visibility{};

  DescribeApisBySignatureResponseBodyApiInfosApiInfo() {}

  explicit DescribeApisBySignatureResponseBodyApiInfosApiInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiId) {
      res["ApiId"] = boost::any(*apiId);
    }
    if (apiName) {
      res["ApiName"] = boost::any(*apiName);
    }
    if (boundTime) {
      res["BoundTime"] = boost::any(*boundTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (stageName) {
      res["StageName"] = boost::any(*stageName);
    }
    if (visibility) {
      res["Visibility"] = boost::any(*visibility);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiId") != m.end() && !m["ApiId"].empty()) {
      apiId = make_shared<string>(boost::any_cast<string>(m["ApiId"]));
    }
    if (m.find("ApiName") != m.end() && !m["ApiName"].empty()) {
      apiName = make_shared<string>(boost::any_cast<string>(m["ApiName"]));
    }
    if (m.find("BoundTime") != m.end() && !m["BoundTime"].empty()) {
      boundTime = make_shared<string>(boost::any_cast<string>(m["BoundTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("StageName") != m.end() && !m["StageName"].empty()) {
      stageName = make_shared<string>(boost::any_cast<string>(m["StageName"]));
    }
    if (m.find("Visibility") != m.end() && !m["Visibility"].empty()) {
      visibility = make_shared<string>(boost::any_cast<string>(m["Visibility"]));
    }
  }


  virtual ~DescribeApisBySignatureResponseBodyApiInfosApiInfo() = default;
};
class DescribeApisBySignatureResponseBodyApiInfos : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeApisBySignatureResponseBodyApiInfosApiInfo>> apiInfo{};

  DescribeApisBySignatureResponseBodyApiInfos() {}

  explicit DescribeApisBySignatureResponseBodyApiInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiInfo) {
      vector<boost::any> temp1;
      for(auto item1:*apiInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ApiInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiInfo") != m.end() && !m["ApiInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["ApiInfo"].type()) {
        vector<DescribeApisBySignatureResponseBodyApiInfosApiInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ApiInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeApisBySignatureResponseBodyApiInfosApiInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        apiInfo = make_shared<vector<DescribeApisBySignatureResponseBodyApiInfosApiInfo>>(expect1);
      }
    }
  }


  virtual ~DescribeApisBySignatureResponseBodyApiInfos() = default;
};
class DescribeApisBySignatureResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeApisBySignatureResponseBodyApiInfos> apiInfos{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeApisBySignatureResponseBody() {}

  explicit DescribeApisBySignatureResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiInfos) {
      res["ApiInfos"] = apiInfos ? boost::any(apiInfos->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiInfos") != m.end() && !m["ApiInfos"].empty()) {
      if (typeid(map<string, boost::any>) == m["ApiInfos"].type()) {
        DescribeApisBySignatureResponseBodyApiInfos model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ApiInfos"]));
        apiInfos = make_shared<DescribeApisBySignatureResponseBodyApiInfos>(model1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeApisBySignatureResponseBody() = default;
};
class DescribeApisBySignatureResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeApisBySignatureResponseBody> body{};

  DescribeApisBySignatureResponse() {}

  explicit DescribeApisBySignatureResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeApisBySignatureResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeApisBySignatureResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeApisBySignatureResponse() = default;
};
class DescribeApisByTrafficControlRequest : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> trafficControlId{};

  DescribeApisByTrafficControlRequest() {}

  explicit DescribeApisByTrafficControlRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (trafficControlId) {
      res["TrafficControlId"] = boost::any(*trafficControlId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("TrafficControlId") != m.end() && !m["TrafficControlId"].empty()) {
      trafficControlId = make_shared<string>(boost::any_cast<string>(m["TrafficControlId"]));
    }
  }


  virtual ~DescribeApisByTrafficControlRequest() = default;
};
class DescribeApisByTrafficControlResponseBodyApiInfosApiInfo : public Darabonba::Model {
public:
  shared_ptr<string> apiId{};
  shared_ptr<string> apiName{};
  shared_ptr<string> boundTime{};
  shared_ptr<string> description{};
  shared_ptr<string> groupId{};
  shared_ptr<string> groupName{};
  shared_ptr<string> regionId{};
  shared_ptr<string> stageName{};
  shared_ptr<string> visibility{};

  DescribeApisByTrafficControlResponseBodyApiInfosApiInfo() {}

  explicit DescribeApisByTrafficControlResponseBodyApiInfosApiInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiId) {
      res["ApiId"] = boost::any(*apiId);
    }
    if (apiName) {
      res["ApiName"] = boost::any(*apiName);
    }
    if (boundTime) {
      res["BoundTime"] = boost::any(*boundTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (stageName) {
      res["StageName"] = boost::any(*stageName);
    }
    if (visibility) {
      res["Visibility"] = boost::any(*visibility);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiId") != m.end() && !m["ApiId"].empty()) {
      apiId = make_shared<string>(boost::any_cast<string>(m["ApiId"]));
    }
    if (m.find("ApiName") != m.end() && !m["ApiName"].empty()) {
      apiName = make_shared<string>(boost::any_cast<string>(m["ApiName"]));
    }
    if (m.find("BoundTime") != m.end() && !m["BoundTime"].empty()) {
      boundTime = make_shared<string>(boost::any_cast<string>(m["BoundTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("StageName") != m.end() && !m["StageName"].empty()) {
      stageName = make_shared<string>(boost::any_cast<string>(m["StageName"]));
    }
    if (m.find("Visibility") != m.end() && !m["Visibility"].empty()) {
      visibility = make_shared<string>(boost::any_cast<string>(m["Visibility"]));
    }
  }


  virtual ~DescribeApisByTrafficControlResponseBodyApiInfosApiInfo() = default;
};
class DescribeApisByTrafficControlResponseBodyApiInfos : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeApisByTrafficControlResponseBodyApiInfosApiInfo>> apiInfo{};

  DescribeApisByTrafficControlResponseBodyApiInfos() {}

  explicit DescribeApisByTrafficControlResponseBodyApiInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiInfo) {
      vector<boost::any> temp1;
      for(auto item1:*apiInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ApiInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiInfo") != m.end() && !m["ApiInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["ApiInfo"].type()) {
        vector<DescribeApisByTrafficControlResponseBodyApiInfosApiInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ApiInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeApisByTrafficControlResponseBodyApiInfosApiInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        apiInfo = make_shared<vector<DescribeApisByTrafficControlResponseBodyApiInfosApiInfo>>(expect1);
      }
    }
  }


  virtual ~DescribeApisByTrafficControlResponseBodyApiInfos() = default;
};
class DescribeApisByTrafficControlResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeApisByTrafficControlResponseBodyApiInfos> apiInfos{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeApisByTrafficControlResponseBody() {}

  explicit DescribeApisByTrafficControlResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiInfos) {
      res["ApiInfos"] = apiInfos ? boost::any(apiInfos->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiInfos") != m.end() && !m["ApiInfos"].empty()) {
      if (typeid(map<string, boost::any>) == m["ApiInfos"].type()) {
        DescribeApisByTrafficControlResponseBodyApiInfos model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ApiInfos"]));
        apiInfos = make_shared<DescribeApisByTrafficControlResponseBodyApiInfos>(model1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeApisByTrafficControlResponseBody() = default;
};
class DescribeApisByTrafficControlResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeApisByTrafficControlResponseBody> body{};

  DescribeApisByTrafficControlResponse() {}

  explicit DescribeApisByTrafficControlResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeApisByTrafficControlResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeApisByTrafficControlResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeApisByTrafficControlResponse() = default;
};
class DescribeAppRequest : public Darabonba::Model {
public:
  shared_ptr<long> appId{};
  shared_ptr<string> securityToken{};

  DescribeAppRequest() {}

  explicit DescribeAppRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<long>(boost::any_cast<long>(m["AppId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~DescribeAppRequest() = default;
};
class DescribeAppResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> appId{};
  shared_ptr<string> appName{};
  shared_ptr<string> createdTime{};
  shared_ptr<string> description{};
  shared_ptr<string> modifiedTime{};
  shared_ptr<string> requestId{};

  DescribeAppResponseBody() {}

  explicit DescribeAppResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (createdTime) {
      res["CreatedTime"] = boost::any(*createdTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (modifiedTime) {
      res["ModifiedTime"] = boost::any(*modifiedTime);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<long>(boost::any_cast<long>(m["AppId"]));
    }
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("CreatedTime") != m.end() && !m["CreatedTime"].empty()) {
      createdTime = make_shared<string>(boost::any_cast<string>(m["CreatedTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("ModifiedTime") != m.end() && !m["ModifiedTime"].empty()) {
      modifiedTime = make_shared<string>(boost::any_cast<string>(m["ModifiedTime"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeAppResponseBody() = default;
};
class DescribeAppResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeAppResponseBody> body{};

  DescribeAppResponse() {}

  explicit DescribeAppResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeAppResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeAppResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeAppResponse() = default;
};
class DescribeAppAttributesRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  DescribeAppAttributesRequestTag() {}

  explicit DescribeAppAttributesRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeAppAttributesRequestTag() = default;
};
class DescribeAppAttributesRequest : public Darabonba::Model {
public:
  shared_ptr<string> appCode{};
  shared_ptr<long> appId{};
  shared_ptr<string> appKey{};
  shared_ptr<string> appName{};
  shared_ptr<bool> enableTagAuth{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> sort{};
  shared_ptr<vector<DescribeAppAttributesRequestTag>> tag{};

  DescribeAppAttributesRequest() {}

  explicit DescribeAppAttributesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appCode) {
      res["AppCode"] = boost::any(*appCode);
    }
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (appKey) {
      res["AppKey"] = boost::any(*appKey);
    }
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (enableTagAuth) {
      res["EnableTagAuth"] = boost::any(*enableTagAuth);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (sort) {
      res["Sort"] = boost::any(*sort);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppCode") != m.end() && !m["AppCode"].empty()) {
      appCode = make_shared<string>(boost::any_cast<string>(m["AppCode"]));
    }
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<long>(boost::any_cast<long>(m["AppId"]));
    }
    if (m.find("AppKey") != m.end() && !m["AppKey"].empty()) {
      appKey = make_shared<string>(boost::any_cast<string>(m["AppKey"]));
    }
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("EnableTagAuth") != m.end() && !m["EnableTagAuth"].empty()) {
      enableTagAuth = make_shared<bool>(boost::any_cast<bool>(m["EnableTagAuth"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("Sort") != m.end() && !m["Sort"].empty()) {
      sort = make_shared<string>(boost::any_cast<string>(m["Sort"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<DescribeAppAttributesRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeAppAttributesRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<DescribeAppAttributesRequestTag>>(expect1);
      }
    }
  }


  virtual ~DescribeAppAttributesRequest() = default;
};
class DescribeAppAttributesResponseBodyAppsAppAttributeTagsTagInfo : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  DescribeAppAttributesResponseBodyAppsAppAttributeTagsTagInfo() {}

  explicit DescribeAppAttributesResponseBodyAppsAppAttributeTagsTagInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeAppAttributesResponseBodyAppsAppAttributeTagsTagInfo() = default;
};
class DescribeAppAttributesResponseBodyAppsAppAttributeTags : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeAppAttributesResponseBodyAppsAppAttributeTagsTagInfo>> tagInfo{};

  DescribeAppAttributesResponseBodyAppsAppAttributeTags() {}

  explicit DescribeAppAttributesResponseBodyAppsAppAttributeTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tagInfo) {
      vector<boost::any> temp1;
      for(auto item1:*tagInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TagInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TagInfo") != m.end() && !m["TagInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["TagInfo"].type()) {
        vector<DescribeAppAttributesResponseBodyAppsAppAttributeTagsTagInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TagInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeAppAttributesResponseBodyAppsAppAttributeTagsTagInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tagInfo = make_shared<vector<DescribeAppAttributesResponseBodyAppsAppAttributeTagsTagInfo>>(expect1);
      }
    }
  }


  virtual ~DescribeAppAttributesResponseBodyAppsAppAttributeTags() = default;
};
class DescribeAppAttributesResponseBodyAppsAppAttribute : public Darabonba::Model {
public:
  shared_ptr<long> appId{};
  shared_ptr<string> appName{};
  shared_ptr<string> createdTime{};
  shared_ptr<string> description{};
  shared_ptr<string> modifiedTime{};
  shared_ptr<DescribeAppAttributesResponseBodyAppsAppAttributeTags> tags{};

  DescribeAppAttributesResponseBodyAppsAppAttribute() {}

  explicit DescribeAppAttributesResponseBodyAppsAppAttribute(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (createdTime) {
      res["CreatedTime"] = boost::any(*createdTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (modifiedTime) {
      res["ModifiedTime"] = boost::any(*modifiedTime);
    }
    if (tags) {
      res["Tags"] = tags ? boost::any(tags->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<long>(boost::any_cast<long>(m["AppId"]));
    }
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("CreatedTime") != m.end() && !m["CreatedTime"].empty()) {
      createdTime = make_shared<string>(boost::any_cast<string>(m["CreatedTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("ModifiedTime") != m.end() && !m["ModifiedTime"].empty()) {
      modifiedTime = make_shared<string>(boost::any_cast<string>(m["ModifiedTime"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(map<string, boost::any>) == m["Tags"].type()) {
        DescribeAppAttributesResponseBodyAppsAppAttributeTags model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Tags"]));
        tags = make_shared<DescribeAppAttributesResponseBodyAppsAppAttributeTags>(model1);
      }
    }
  }


  virtual ~DescribeAppAttributesResponseBodyAppsAppAttribute() = default;
};
class DescribeAppAttributesResponseBodyApps : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeAppAttributesResponseBodyAppsAppAttribute>> appAttribute{};

  DescribeAppAttributesResponseBodyApps() {}

  explicit DescribeAppAttributesResponseBodyApps(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appAttribute) {
      vector<boost::any> temp1;
      for(auto item1:*appAttribute){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AppAttribute"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppAttribute") != m.end() && !m["AppAttribute"].empty()) {
      if (typeid(vector<boost::any>) == m["AppAttribute"].type()) {
        vector<DescribeAppAttributesResponseBodyAppsAppAttribute> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AppAttribute"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeAppAttributesResponseBodyAppsAppAttribute model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        appAttribute = make_shared<vector<DescribeAppAttributesResponseBodyAppsAppAttribute>>(expect1);
      }
    }
  }


  virtual ~DescribeAppAttributesResponseBodyApps() = default;
};
class DescribeAppAttributesResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeAppAttributesResponseBodyApps> apps{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeAppAttributesResponseBody() {}

  explicit DescribeAppAttributesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apps) {
      res["Apps"] = apps ? boost::any(apps->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Apps") != m.end() && !m["Apps"].empty()) {
      if (typeid(map<string, boost::any>) == m["Apps"].type()) {
        DescribeAppAttributesResponseBodyApps model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Apps"]));
        apps = make_shared<DescribeAppAttributesResponseBodyApps>(model1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeAppAttributesResponseBody() = default;
};
class DescribeAppAttributesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeAppAttributesResponseBody> body{};

  DescribeAppAttributesResponse() {}

  explicit DescribeAppAttributesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeAppAttributesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeAppAttributesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeAppAttributesResponse() = default;
};
class DescribeAppSecurityRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  DescribeAppSecurityRequestTag() {}

  explicit DescribeAppSecurityRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeAppSecurityRequestTag() = default;
};
class DescribeAppSecurityRequest : public Darabonba::Model {
public:
  shared_ptr<long> appId{};
  shared_ptr<string> securityToken{};
  shared_ptr<vector<DescribeAppSecurityRequestTag>> tag{};

  DescribeAppSecurityRequest() {}

  explicit DescribeAppSecurityRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<long>(boost::any_cast<long>(m["AppId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<DescribeAppSecurityRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeAppSecurityRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<DescribeAppSecurityRequestTag>>(expect1);
      }
    }
  }


  virtual ~DescribeAppSecurityRequest() = default;
};
class DescribeAppSecurityResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> appCode{};
  shared_ptr<string> appKey{};
  shared_ptr<string> appSecret{};
  shared_ptr<string> createdTime{};
  shared_ptr<string> modifiedTime{};
  shared_ptr<string> requestId{};

  DescribeAppSecurityResponseBody() {}

  explicit DescribeAppSecurityResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appCode) {
      res["AppCode"] = boost::any(*appCode);
    }
    if (appKey) {
      res["AppKey"] = boost::any(*appKey);
    }
    if (appSecret) {
      res["AppSecret"] = boost::any(*appSecret);
    }
    if (createdTime) {
      res["CreatedTime"] = boost::any(*createdTime);
    }
    if (modifiedTime) {
      res["ModifiedTime"] = boost::any(*modifiedTime);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppCode") != m.end() && !m["AppCode"].empty()) {
      appCode = make_shared<string>(boost::any_cast<string>(m["AppCode"]));
    }
    if (m.find("AppKey") != m.end() && !m["AppKey"].empty()) {
      appKey = make_shared<string>(boost::any_cast<string>(m["AppKey"]));
    }
    if (m.find("AppSecret") != m.end() && !m["AppSecret"].empty()) {
      appSecret = make_shared<string>(boost::any_cast<string>(m["AppSecret"]));
    }
    if (m.find("CreatedTime") != m.end() && !m["CreatedTime"].empty()) {
      createdTime = make_shared<string>(boost::any_cast<string>(m["CreatedTime"]));
    }
    if (m.find("ModifiedTime") != m.end() && !m["ModifiedTime"].empty()) {
      modifiedTime = make_shared<string>(boost::any_cast<string>(m["ModifiedTime"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeAppSecurityResponseBody() = default;
};
class DescribeAppSecurityResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeAppSecurityResponseBody> body{};

  DescribeAppSecurityResponse() {}

  explicit DescribeAppSecurityResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeAppSecurityResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeAppSecurityResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeAppSecurityResponse() = default;
};
class DescribeAppsRequest : public Darabonba::Model {
public:
  shared_ptr<long> appId{};
  shared_ptr<long> appOwner{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> securityToken{};

  DescribeAppsRequest() {}

  explicit DescribeAppsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (appOwner) {
      res["AppOwner"] = boost::any(*appOwner);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<long>(boost::any_cast<long>(m["AppId"]));
    }
    if (m.find("AppOwner") != m.end() && !m["AppOwner"].empty()) {
      appOwner = make_shared<long>(boost::any_cast<long>(m["AppOwner"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~DescribeAppsRequest() = default;
};
class DescribeAppsResponseBodyAppsAppItem : public Darabonba::Model {
public:
  shared_ptr<long> appId{};
  shared_ptr<string> appName{};
  shared_ptr<string> description{};

  DescribeAppsResponseBodyAppsAppItem() {}

  explicit DescribeAppsResponseBodyAppsAppItem(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<long>(boost::any_cast<long>(m["AppId"]));
    }
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
  }


  virtual ~DescribeAppsResponseBodyAppsAppItem() = default;
};
class DescribeAppsResponseBodyApps : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeAppsResponseBodyAppsAppItem>> appItem{};

  DescribeAppsResponseBodyApps() {}

  explicit DescribeAppsResponseBodyApps(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appItem) {
      vector<boost::any> temp1;
      for(auto item1:*appItem){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AppItem"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppItem") != m.end() && !m["AppItem"].empty()) {
      if (typeid(vector<boost::any>) == m["AppItem"].type()) {
        vector<DescribeAppsResponseBodyAppsAppItem> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AppItem"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeAppsResponseBodyAppsAppItem model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        appItem = make_shared<vector<DescribeAppsResponseBodyAppsAppItem>>(expect1);
      }
    }
  }


  virtual ~DescribeAppsResponseBodyApps() = default;
};
class DescribeAppsResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeAppsResponseBodyApps> apps{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeAppsResponseBody() {}

  explicit DescribeAppsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apps) {
      res["Apps"] = apps ? boost::any(apps->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Apps") != m.end() && !m["Apps"].empty()) {
      if (typeid(map<string, boost::any>) == m["Apps"].type()) {
        DescribeAppsResponseBodyApps model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Apps"]));
        apps = make_shared<DescribeAppsResponseBodyApps>(model1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeAppsResponseBody() = default;
};
class DescribeAppsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeAppsResponseBody> body{};

  DescribeAppsResponse() {}

  explicit DescribeAppsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeAppsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeAppsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeAppsResponse() = default;
};
class DescribeAuthorizedApisRequest : public Darabonba::Model {
public:
  shared_ptr<long> appId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> securityToken{};

  DescribeAuthorizedApisRequest() {}

  explicit DescribeAuthorizedApisRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<long>(boost::any_cast<long>(m["AppId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~DescribeAuthorizedApisRequest() = default;
};
class DescribeAuthorizedApisResponseBodyAuthorizedApisAuthorizedApi : public Darabonba::Model {
public:
  shared_ptr<string> apiId{};
  shared_ptr<string> apiName{};
  shared_ptr<string> authVaildTime{};
  shared_ptr<string> authorizationSource{};
  shared_ptr<string> authorizedTime{};
  shared_ptr<string> description{};
  shared_ptr<string> groupId{};
  shared_ptr<string> groupName{};
  shared_ptr<string> operator_{};
  shared_ptr<string> regionId{};
  shared_ptr<string> stageName{};

  DescribeAuthorizedApisResponseBodyAuthorizedApisAuthorizedApi() {}

  explicit DescribeAuthorizedApisResponseBodyAuthorizedApisAuthorizedApi(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiId) {
      res["ApiId"] = boost::any(*apiId);
    }
    if (apiName) {
      res["ApiName"] = boost::any(*apiName);
    }
    if (authVaildTime) {
      res["AuthVaildTime"] = boost::any(*authVaildTime);
    }
    if (authorizationSource) {
      res["AuthorizationSource"] = boost::any(*authorizationSource);
    }
    if (authorizedTime) {
      res["AuthorizedTime"] = boost::any(*authorizedTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (operator_) {
      res["Operator"] = boost::any(*operator_);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (stageName) {
      res["StageName"] = boost::any(*stageName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiId") != m.end() && !m["ApiId"].empty()) {
      apiId = make_shared<string>(boost::any_cast<string>(m["ApiId"]));
    }
    if (m.find("ApiName") != m.end() && !m["ApiName"].empty()) {
      apiName = make_shared<string>(boost::any_cast<string>(m["ApiName"]));
    }
    if (m.find("AuthVaildTime") != m.end() && !m["AuthVaildTime"].empty()) {
      authVaildTime = make_shared<string>(boost::any_cast<string>(m["AuthVaildTime"]));
    }
    if (m.find("AuthorizationSource") != m.end() && !m["AuthorizationSource"].empty()) {
      authorizationSource = make_shared<string>(boost::any_cast<string>(m["AuthorizationSource"]));
    }
    if (m.find("AuthorizedTime") != m.end() && !m["AuthorizedTime"].empty()) {
      authorizedTime = make_shared<string>(boost::any_cast<string>(m["AuthorizedTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("Operator") != m.end() && !m["Operator"].empty()) {
      operator_ = make_shared<string>(boost::any_cast<string>(m["Operator"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("StageName") != m.end() && !m["StageName"].empty()) {
      stageName = make_shared<string>(boost::any_cast<string>(m["StageName"]));
    }
  }


  virtual ~DescribeAuthorizedApisResponseBodyAuthorizedApisAuthorizedApi() = default;
};
class DescribeAuthorizedApisResponseBodyAuthorizedApis : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeAuthorizedApisResponseBodyAuthorizedApisAuthorizedApi>> authorizedApi{};

  DescribeAuthorizedApisResponseBodyAuthorizedApis() {}

  explicit DescribeAuthorizedApisResponseBodyAuthorizedApis(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (authorizedApi) {
      vector<boost::any> temp1;
      for(auto item1:*authorizedApi){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AuthorizedApi"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AuthorizedApi") != m.end() && !m["AuthorizedApi"].empty()) {
      if (typeid(vector<boost::any>) == m["AuthorizedApi"].type()) {
        vector<DescribeAuthorizedApisResponseBodyAuthorizedApisAuthorizedApi> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AuthorizedApi"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeAuthorizedApisResponseBodyAuthorizedApisAuthorizedApi model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        authorizedApi = make_shared<vector<DescribeAuthorizedApisResponseBodyAuthorizedApisAuthorizedApi>>(expect1);
      }
    }
  }


  virtual ~DescribeAuthorizedApisResponseBodyAuthorizedApis() = default;
};
class DescribeAuthorizedApisResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeAuthorizedApisResponseBodyAuthorizedApis> authorizedApis{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeAuthorizedApisResponseBody() {}

  explicit DescribeAuthorizedApisResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (authorizedApis) {
      res["AuthorizedApis"] = authorizedApis ? boost::any(authorizedApis->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AuthorizedApis") != m.end() && !m["AuthorizedApis"].empty()) {
      if (typeid(map<string, boost::any>) == m["AuthorizedApis"].type()) {
        DescribeAuthorizedApisResponseBodyAuthorizedApis model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AuthorizedApis"]));
        authorizedApis = make_shared<DescribeAuthorizedApisResponseBodyAuthorizedApis>(model1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeAuthorizedApisResponseBody() = default;
};
class DescribeAuthorizedApisResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeAuthorizedApisResponseBody> body{};

  DescribeAuthorizedApisResponse() {}

  explicit DescribeAuthorizedApisResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeAuthorizedApisResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeAuthorizedApisResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeAuthorizedApisResponse() = default;
};
class DescribeAuthorizedAppsRequest : public Darabonba::Model {
public:
  shared_ptr<string> apiId{};
  shared_ptr<long> appId{};
  shared_ptr<string> appName{};
  shared_ptr<long> appOwnerId{};
  shared_ptr<string> groupId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> stageName{};

  DescribeAuthorizedAppsRequest() {}

  explicit DescribeAuthorizedAppsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiId) {
      res["ApiId"] = boost::any(*apiId);
    }
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (appOwnerId) {
      res["AppOwnerId"] = boost::any(*appOwnerId);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (stageName) {
      res["StageName"] = boost::any(*stageName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiId") != m.end() && !m["ApiId"].empty()) {
      apiId = make_shared<string>(boost::any_cast<string>(m["ApiId"]));
    }
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<long>(boost::any_cast<long>(m["AppId"]));
    }
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("AppOwnerId") != m.end() && !m["AppOwnerId"].empty()) {
      appOwnerId = make_shared<long>(boost::any_cast<long>(m["AppOwnerId"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("StageName") != m.end() && !m["StageName"].empty()) {
      stageName = make_shared<string>(boost::any_cast<string>(m["StageName"]));
    }
  }


  virtual ~DescribeAuthorizedAppsRequest() = default;
};
class DescribeAuthorizedAppsResponseBodyAuthorizedAppsAuthorizedApp : public Darabonba::Model {
public:
  shared_ptr<long> appId{};
  shared_ptr<string> appName{};
  shared_ptr<string> authVaildTime{};
  shared_ptr<string> authorizationSource{};
  shared_ptr<string> authorizedTime{};
  shared_ptr<string> description{};
  shared_ptr<string> operator_{};
  shared_ptr<string> stageName{};

  DescribeAuthorizedAppsResponseBodyAuthorizedAppsAuthorizedApp() {}

  explicit DescribeAuthorizedAppsResponseBodyAuthorizedAppsAuthorizedApp(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (authVaildTime) {
      res["AuthVaildTime"] = boost::any(*authVaildTime);
    }
    if (authorizationSource) {
      res["AuthorizationSource"] = boost::any(*authorizationSource);
    }
    if (authorizedTime) {
      res["AuthorizedTime"] = boost::any(*authorizedTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (operator_) {
      res["Operator"] = boost::any(*operator_);
    }
    if (stageName) {
      res["StageName"] = boost::any(*stageName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<long>(boost::any_cast<long>(m["AppId"]));
    }
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("AuthVaildTime") != m.end() && !m["AuthVaildTime"].empty()) {
      authVaildTime = make_shared<string>(boost::any_cast<string>(m["AuthVaildTime"]));
    }
    if (m.find("AuthorizationSource") != m.end() && !m["AuthorizationSource"].empty()) {
      authorizationSource = make_shared<string>(boost::any_cast<string>(m["AuthorizationSource"]));
    }
    if (m.find("AuthorizedTime") != m.end() && !m["AuthorizedTime"].empty()) {
      authorizedTime = make_shared<string>(boost::any_cast<string>(m["AuthorizedTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Operator") != m.end() && !m["Operator"].empty()) {
      operator_ = make_shared<string>(boost::any_cast<string>(m["Operator"]));
    }
    if (m.find("StageName") != m.end() && !m["StageName"].empty()) {
      stageName = make_shared<string>(boost::any_cast<string>(m["StageName"]));
    }
  }


  virtual ~DescribeAuthorizedAppsResponseBodyAuthorizedAppsAuthorizedApp() = default;
};
class DescribeAuthorizedAppsResponseBodyAuthorizedApps : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeAuthorizedAppsResponseBodyAuthorizedAppsAuthorizedApp>> authorizedApp{};

  DescribeAuthorizedAppsResponseBodyAuthorizedApps() {}

  explicit DescribeAuthorizedAppsResponseBodyAuthorizedApps(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (authorizedApp) {
      vector<boost::any> temp1;
      for(auto item1:*authorizedApp){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AuthorizedApp"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AuthorizedApp") != m.end() && !m["AuthorizedApp"].empty()) {
      if (typeid(vector<boost::any>) == m["AuthorizedApp"].type()) {
        vector<DescribeAuthorizedAppsResponseBodyAuthorizedAppsAuthorizedApp> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AuthorizedApp"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeAuthorizedAppsResponseBodyAuthorizedAppsAuthorizedApp model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        authorizedApp = make_shared<vector<DescribeAuthorizedAppsResponseBodyAuthorizedAppsAuthorizedApp>>(expect1);
      }
    }
  }


  virtual ~DescribeAuthorizedAppsResponseBodyAuthorizedApps() = default;
};
class DescribeAuthorizedAppsResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeAuthorizedAppsResponseBodyAuthorizedApps> authorizedApps{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeAuthorizedAppsResponseBody() {}

  explicit DescribeAuthorizedAppsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (authorizedApps) {
      res["AuthorizedApps"] = authorizedApps ? boost::any(authorizedApps->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AuthorizedApps") != m.end() && !m["AuthorizedApps"].empty()) {
      if (typeid(map<string, boost::any>) == m["AuthorizedApps"].type()) {
        DescribeAuthorizedAppsResponseBodyAuthorizedApps model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AuthorizedApps"]));
        authorizedApps = make_shared<DescribeAuthorizedAppsResponseBodyAuthorizedApps>(model1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeAuthorizedAppsResponseBody() = default;
};
class DescribeAuthorizedAppsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeAuthorizedAppsResponseBody> body{};

  DescribeAuthorizedAppsResponse() {}

  explicit DescribeAuthorizedAppsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeAuthorizedAppsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeAuthorizedAppsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeAuthorizedAppsResponse() = default;
};
class DescribeDeployApiTaskRequest : public Darabonba::Model {
public:
  shared_ptr<string> operationUid{};
  shared_ptr<string> securityToken{};

  DescribeDeployApiTaskRequest() {}

  explicit DescribeDeployApiTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (operationUid) {
      res["OperationUid"] = boost::any(*operationUid);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OperationUid") != m.end() && !m["OperationUid"].empty()) {
      operationUid = make_shared<string>(boost::any_cast<string>(m["OperationUid"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~DescribeDeployApiTaskRequest() = default;
};
class DescribeDeployApiTaskResponseBodyDeployedResultsDeployedResult : public Darabonba::Model {
public:
  shared_ptr<string> apiUid{};
  shared_ptr<string> deployedStatus{};
  shared_ptr<string> errorMsg{};
  shared_ptr<string> groupId{};
  shared_ptr<string> stageName{};

  DescribeDeployApiTaskResponseBodyDeployedResultsDeployedResult() {}

  explicit DescribeDeployApiTaskResponseBodyDeployedResultsDeployedResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiUid) {
      res["ApiUid"] = boost::any(*apiUid);
    }
    if (deployedStatus) {
      res["DeployedStatus"] = boost::any(*deployedStatus);
    }
    if (errorMsg) {
      res["ErrorMsg"] = boost::any(*errorMsg);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (stageName) {
      res["StageName"] = boost::any(*stageName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiUid") != m.end() && !m["ApiUid"].empty()) {
      apiUid = make_shared<string>(boost::any_cast<string>(m["ApiUid"]));
    }
    if (m.find("DeployedStatus") != m.end() && !m["DeployedStatus"].empty()) {
      deployedStatus = make_shared<string>(boost::any_cast<string>(m["DeployedStatus"]));
    }
    if (m.find("ErrorMsg") != m.end() && !m["ErrorMsg"].empty()) {
      errorMsg = make_shared<string>(boost::any_cast<string>(m["ErrorMsg"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("StageName") != m.end() && !m["StageName"].empty()) {
      stageName = make_shared<string>(boost::any_cast<string>(m["StageName"]));
    }
  }


  virtual ~DescribeDeployApiTaskResponseBodyDeployedResultsDeployedResult() = default;
};
class DescribeDeployApiTaskResponseBodyDeployedResults : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDeployApiTaskResponseBodyDeployedResultsDeployedResult>> deployedResult{};

  DescribeDeployApiTaskResponseBodyDeployedResults() {}

  explicit DescribeDeployApiTaskResponseBodyDeployedResults(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deployedResult) {
      vector<boost::any> temp1;
      for(auto item1:*deployedResult){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DeployedResult"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeployedResult") != m.end() && !m["DeployedResult"].empty()) {
      if (typeid(vector<boost::any>) == m["DeployedResult"].type()) {
        vector<DescribeDeployApiTaskResponseBodyDeployedResultsDeployedResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DeployedResult"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDeployApiTaskResponseBodyDeployedResultsDeployedResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        deployedResult = make_shared<vector<DescribeDeployApiTaskResponseBodyDeployedResultsDeployedResult>>(expect1);
      }
    }
  }


  virtual ~DescribeDeployApiTaskResponseBodyDeployedResults() = default;
};
class DescribeDeployApiTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeDeployApiTaskResponseBodyDeployedResults> deployedResults{};
  shared_ptr<string> requestId{};

  DescribeDeployApiTaskResponseBody() {}

  explicit DescribeDeployApiTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deployedResults) {
      res["DeployedResults"] = deployedResults ? boost::any(deployedResults->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeployedResults") != m.end() && !m["DeployedResults"].empty()) {
      if (typeid(map<string, boost::any>) == m["DeployedResults"].type()) {
        DescribeDeployApiTaskResponseBodyDeployedResults model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DeployedResults"]));
        deployedResults = make_shared<DescribeDeployApiTaskResponseBodyDeployedResults>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeDeployApiTaskResponseBody() = default;
};
class DescribeDeployApiTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeDeployApiTaskResponseBody> body{};

  DescribeDeployApiTaskResponse() {}

  explicit DescribeDeployApiTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDeployApiTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDeployApiTaskResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDeployApiTaskResponse() = default;
};
class DescribeDeployedApiRequest : public Darabonba::Model {
public:
  shared_ptr<string> apiId{};
  shared_ptr<string> groupId{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> stageName{};

  DescribeDeployedApiRequest() {}

  explicit DescribeDeployedApiRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiId) {
      res["ApiId"] = boost::any(*apiId);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (stageName) {
      res["StageName"] = boost::any(*stageName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiId") != m.end() && !m["ApiId"].empty()) {
      apiId = make_shared<string>(boost::any_cast<string>(m["ApiId"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("StageName") != m.end() && !m["StageName"].empty()) {
      stageName = make_shared<string>(boost::any_cast<string>(m["StageName"]));
    }
  }


  virtual ~DescribeDeployedApiRequest() = default;
};
class DescribeDeployedApiResponseBodyConstantParametersConstantParameter : public Darabonba::Model {
public:
  shared_ptr<string> constantValue{};
  shared_ptr<string> description{};
  shared_ptr<string> location{};
  shared_ptr<string> serviceParameterName{};

  DescribeDeployedApiResponseBodyConstantParametersConstantParameter() {}

  explicit DescribeDeployedApiResponseBodyConstantParametersConstantParameter(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (constantValue) {
      res["ConstantValue"] = boost::any(*constantValue);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (serviceParameterName) {
      res["ServiceParameterName"] = boost::any(*serviceParameterName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConstantValue") != m.end() && !m["ConstantValue"].empty()) {
      constantValue = make_shared<string>(boost::any_cast<string>(m["ConstantValue"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("ServiceParameterName") != m.end() && !m["ServiceParameterName"].empty()) {
      serviceParameterName = make_shared<string>(boost::any_cast<string>(m["ServiceParameterName"]));
    }
  }


  virtual ~DescribeDeployedApiResponseBodyConstantParametersConstantParameter() = default;
};
class DescribeDeployedApiResponseBodyConstantParameters : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDeployedApiResponseBodyConstantParametersConstantParameter>> constantParameter{};

  DescribeDeployedApiResponseBodyConstantParameters() {}

  explicit DescribeDeployedApiResponseBodyConstantParameters(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (constantParameter) {
      vector<boost::any> temp1;
      for(auto item1:*constantParameter){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ConstantParameter"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConstantParameter") != m.end() && !m["ConstantParameter"].empty()) {
      if (typeid(vector<boost::any>) == m["ConstantParameter"].type()) {
        vector<DescribeDeployedApiResponseBodyConstantParametersConstantParameter> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ConstantParameter"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDeployedApiResponseBodyConstantParametersConstantParameter model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        constantParameter = make_shared<vector<DescribeDeployedApiResponseBodyConstantParametersConstantParameter>>(expect1);
      }
    }
  }


  virtual ~DescribeDeployedApiResponseBodyConstantParameters() = default;
};
class DescribeDeployedApiResponseBodyCustomSystemParametersCustomSystemParameter : public Darabonba::Model {
public:
  shared_ptr<string> demoValue{};
  shared_ptr<string> description{};
  shared_ptr<string> location{};
  shared_ptr<string> parameterName{};
  shared_ptr<string> serviceParameterName{};

  DescribeDeployedApiResponseBodyCustomSystemParametersCustomSystemParameter() {}

  explicit DescribeDeployedApiResponseBodyCustomSystemParametersCustomSystemParameter(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (demoValue) {
      res["DemoValue"] = boost::any(*demoValue);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (parameterName) {
      res["ParameterName"] = boost::any(*parameterName);
    }
    if (serviceParameterName) {
      res["ServiceParameterName"] = boost::any(*serviceParameterName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DemoValue") != m.end() && !m["DemoValue"].empty()) {
      demoValue = make_shared<string>(boost::any_cast<string>(m["DemoValue"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("ParameterName") != m.end() && !m["ParameterName"].empty()) {
      parameterName = make_shared<string>(boost::any_cast<string>(m["ParameterName"]));
    }
    if (m.find("ServiceParameterName") != m.end() && !m["ServiceParameterName"].empty()) {
      serviceParameterName = make_shared<string>(boost::any_cast<string>(m["ServiceParameterName"]));
    }
  }


  virtual ~DescribeDeployedApiResponseBodyCustomSystemParametersCustomSystemParameter() = default;
};
class DescribeDeployedApiResponseBodyCustomSystemParameters : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDeployedApiResponseBodyCustomSystemParametersCustomSystemParameter>> customSystemParameter{};

  DescribeDeployedApiResponseBodyCustomSystemParameters() {}

  explicit DescribeDeployedApiResponseBodyCustomSystemParameters(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (customSystemParameter) {
      vector<boost::any> temp1;
      for(auto item1:*customSystemParameter){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CustomSystemParameter"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CustomSystemParameter") != m.end() && !m["CustomSystemParameter"].empty()) {
      if (typeid(vector<boost::any>) == m["CustomSystemParameter"].type()) {
        vector<DescribeDeployedApiResponseBodyCustomSystemParametersCustomSystemParameter> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CustomSystemParameter"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDeployedApiResponseBodyCustomSystemParametersCustomSystemParameter model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        customSystemParameter = make_shared<vector<DescribeDeployedApiResponseBodyCustomSystemParametersCustomSystemParameter>>(expect1);
      }
    }
  }


  virtual ~DescribeDeployedApiResponseBodyCustomSystemParameters() = default;
};
class DescribeDeployedApiResponseBodyErrorCodeSamplesErrorCodeSample : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> description{};
  shared_ptr<string> message{};

  DescribeDeployedApiResponseBodyErrorCodeSamplesErrorCodeSample() {}

  explicit DescribeDeployedApiResponseBodyErrorCodeSamplesErrorCodeSample(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
  }


  virtual ~DescribeDeployedApiResponseBodyErrorCodeSamplesErrorCodeSample() = default;
};
class DescribeDeployedApiResponseBodyErrorCodeSamples : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDeployedApiResponseBodyErrorCodeSamplesErrorCodeSample>> errorCodeSample{};

  DescribeDeployedApiResponseBodyErrorCodeSamples() {}

  explicit DescribeDeployedApiResponseBodyErrorCodeSamples(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCodeSample) {
      vector<boost::any> temp1;
      for(auto item1:*errorCodeSample){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ErrorCodeSample"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCodeSample") != m.end() && !m["ErrorCodeSample"].empty()) {
      if (typeid(vector<boost::any>) == m["ErrorCodeSample"].type()) {
        vector<DescribeDeployedApiResponseBodyErrorCodeSamplesErrorCodeSample> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ErrorCodeSample"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDeployedApiResponseBodyErrorCodeSamplesErrorCodeSample model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        errorCodeSample = make_shared<vector<DescribeDeployedApiResponseBodyErrorCodeSamplesErrorCodeSample>>(expect1);
      }
    }
  }


  virtual ~DescribeDeployedApiResponseBodyErrorCodeSamples() = default;
};
class DescribeDeployedApiResponseBodyOpenIdConnectConfig : public Darabonba::Model {
public:
  shared_ptr<string> idTokenParamName{};
  shared_ptr<string> openIdApiType{};
  shared_ptr<string> publicKey{};
  shared_ptr<string> publicKeyId{};

  DescribeDeployedApiResponseBodyOpenIdConnectConfig() {}

  explicit DescribeDeployedApiResponseBodyOpenIdConnectConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (idTokenParamName) {
      res["IdTokenParamName"] = boost::any(*idTokenParamName);
    }
    if (openIdApiType) {
      res["OpenIdApiType"] = boost::any(*openIdApiType);
    }
    if (publicKey) {
      res["PublicKey"] = boost::any(*publicKey);
    }
    if (publicKeyId) {
      res["PublicKeyId"] = boost::any(*publicKeyId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IdTokenParamName") != m.end() && !m["IdTokenParamName"].empty()) {
      idTokenParamName = make_shared<string>(boost::any_cast<string>(m["IdTokenParamName"]));
    }
    if (m.find("OpenIdApiType") != m.end() && !m["OpenIdApiType"].empty()) {
      openIdApiType = make_shared<string>(boost::any_cast<string>(m["OpenIdApiType"]));
    }
    if (m.find("PublicKey") != m.end() && !m["PublicKey"].empty()) {
      publicKey = make_shared<string>(boost::any_cast<string>(m["PublicKey"]));
    }
    if (m.find("PublicKeyId") != m.end() && !m["PublicKeyId"].empty()) {
      publicKeyId = make_shared<string>(boost::any_cast<string>(m["PublicKeyId"]));
    }
  }


  virtual ~DescribeDeployedApiResponseBodyOpenIdConnectConfig() = default;
};
class DescribeDeployedApiResponseBodyRequestConfig : public Darabonba::Model {
public:
  shared_ptr<string> bodyFormat{};
  shared_ptr<string> bodyModel{};
  shared_ptr<string> postBodyDescription{};
  shared_ptr<string> requestHttpMethod{};
  shared_ptr<string> requestMode{};
  shared_ptr<string> requestPath{};
  shared_ptr<string> requestProtocol{};

  DescribeDeployedApiResponseBodyRequestConfig() {}

  explicit DescribeDeployedApiResponseBodyRequestConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bodyFormat) {
      res["BodyFormat"] = boost::any(*bodyFormat);
    }
    if (bodyModel) {
      res["BodyModel"] = boost::any(*bodyModel);
    }
    if (postBodyDescription) {
      res["PostBodyDescription"] = boost::any(*postBodyDescription);
    }
    if (requestHttpMethod) {
      res["RequestHttpMethod"] = boost::any(*requestHttpMethod);
    }
    if (requestMode) {
      res["RequestMode"] = boost::any(*requestMode);
    }
    if (requestPath) {
      res["RequestPath"] = boost::any(*requestPath);
    }
    if (requestProtocol) {
      res["RequestProtocol"] = boost::any(*requestProtocol);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BodyFormat") != m.end() && !m["BodyFormat"].empty()) {
      bodyFormat = make_shared<string>(boost::any_cast<string>(m["BodyFormat"]));
    }
    if (m.find("BodyModel") != m.end() && !m["BodyModel"].empty()) {
      bodyModel = make_shared<string>(boost::any_cast<string>(m["BodyModel"]));
    }
    if (m.find("PostBodyDescription") != m.end() && !m["PostBodyDescription"].empty()) {
      postBodyDescription = make_shared<string>(boost::any_cast<string>(m["PostBodyDescription"]));
    }
    if (m.find("RequestHttpMethod") != m.end() && !m["RequestHttpMethod"].empty()) {
      requestHttpMethod = make_shared<string>(boost::any_cast<string>(m["RequestHttpMethod"]));
    }
    if (m.find("RequestMode") != m.end() && !m["RequestMode"].empty()) {
      requestMode = make_shared<string>(boost::any_cast<string>(m["RequestMode"]));
    }
    if (m.find("RequestPath") != m.end() && !m["RequestPath"].empty()) {
      requestPath = make_shared<string>(boost::any_cast<string>(m["RequestPath"]));
    }
    if (m.find("RequestProtocol") != m.end() && !m["RequestProtocol"].empty()) {
      requestProtocol = make_shared<string>(boost::any_cast<string>(m["RequestProtocol"]));
    }
  }


  virtual ~DescribeDeployedApiResponseBodyRequestConfig() = default;
};
class DescribeDeployedApiResponseBodyRequestParametersRequestParameter : public Darabonba::Model {
public:
  shared_ptr<string> apiParameterName{};
  shared_ptr<string> arrayItemsType{};
  shared_ptr<string> defaultValue{};
  shared_ptr<string> demoValue{};
  shared_ptr<string> description{};
  shared_ptr<long> docOrder{};
  shared_ptr<string> docShow{};
  shared_ptr<string> enumValue{};
  shared_ptr<string> jsonScheme{};
  shared_ptr<string> location{};
  shared_ptr<long> maxLength{};
  shared_ptr<long> maxValue{};
  shared_ptr<long> minLength{};
  shared_ptr<long> minValue{};
  shared_ptr<string> parameterType{};
  shared_ptr<string> regularExpression{};
  shared_ptr<string> required{};

  DescribeDeployedApiResponseBodyRequestParametersRequestParameter() {}

  explicit DescribeDeployedApiResponseBodyRequestParametersRequestParameter(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiParameterName) {
      res["ApiParameterName"] = boost::any(*apiParameterName);
    }
    if (arrayItemsType) {
      res["ArrayItemsType"] = boost::any(*arrayItemsType);
    }
    if (defaultValue) {
      res["DefaultValue"] = boost::any(*defaultValue);
    }
    if (demoValue) {
      res["DemoValue"] = boost::any(*demoValue);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (docOrder) {
      res["DocOrder"] = boost::any(*docOrder);
    }
    if (docShow) {
      res["DocShow"] = boost::any(*docShow);
    }
    if (enumValue) {
      res["EnumValue"] = boost::any(*enumValue);
    }
    if (jsonScheme) {
      res["JsonScheme"] = boost::any(*jsonScheme);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (maxLength) {
      res["MaxLength"] = boost::any(*maxLength);
    }
    if (maxValue) {
      res["MaxValue"] = boost::any(*maxValue);
    }
    if (minLength) {
      res["MinLength"] = boost::any(*minLength);
    }
    if (minValue) {
      res["MinValue"] = boost::any(*minValue);
    }
    if (parameterType) {
      res["ParameterType"] = boost::any(*parameterType);
    }
    if (regularExpression) {
      res["RegularExpression"] = boost::any(*regularExpression);
    }
    if (required) {
      res["Required"] = boost::any(*required);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiParameterName") != m.end() && !m["ApiParameterName"].empty()) {
      apiParameterName = make_shared<string>(boost::any_cast<string>(m["ApiParameterName"]));
    }
    if (m.find("ArrayItemsType") != m.end() && !m["ArrayItemsType"].empty()) {
      arrayItemsType = make_shared<string>(boost::any_cast<string>(m["ArrayItemsType"]));
    }
    if (m.find("DefaultValue") != m.end() && !m["DefaultValue"].empty()) {
      defaultValue = make_shared<string>(boost::any_cast<string>(m["DefaultValue"]));
    }
    if (m.find("DemoValue") != m.end() && !m["DemoValue"].empty()) {
      demoValue = make_shared<string>(boost::any_cast<string>(m["DemoValue"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DocOrder") != m.end() && !m["DocOrder"].empty()) {
      docOrder = make_shared<long>(boost::any_cast<long>(m["DocOrder"]));
    }
    if (m.find("DocShow") != m.end() && !m["DocShow"].empty()) {
      docShow = make_shared<string>(boost::any_cast<string>(m["DocShow"]));
    }
    if (m.find("EnumValue") != m.end() && !m["EnumValue"].empty()) {
      enumValue = make_shared<string>(boost::any_cast<string>(m["EnumValue"]));
    }
    if (m.find("JsonScheme") != m.end() && !m["JsonScheme"].empty()) {
      jsonScheme = make_shared<string>(boost::any_cast<string>(m["JsonScheme"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("MaxLength") != m.end() && !m["MaxLength"].empty()) {
      maxLength = make_shared<long>(boost::any_cast<long>(m["MaxLength"]));
    }
    if (m.find("MaxValue") != m.end() && !m["MaxValue"].empty()) {
      maxValue = make_shared<long>(boost::any_cast<long>(m["MaxValue"]));
    }
    if (m.find("MinLength") != m.end() && !m["MinLength"].empty()) {
      minLength = make_shared<long>(boost::any_cast<long>(m["MinLength"]));
    }
    if (m.find("MinValue") != m.end() && !m["MinValue"].empty()) {
      minValue = make_shared<long>(boost::any_cast<long>(m["MinValue"]));
    }
    if (m.find("ParameterType") != m.end() && !m["ParameterType"].empty()) {
      parameterType = make_shared<string>(boost::any_cast<string>(m["ParameterType"]));
    }
    if (m.find("RegularExpression") != m.end() && !m["RegularExpression"].empty()) {
      regularExpression = make_shared<string>(boost::any_cast<string>(m["RegularExpression"]));
    }
    if (m.find("Required") != m.end() && !m["Required"].empty()) {
      required = make_shared<string>(boost::any_cast<string>(m["Required"]));
    }
  }


  virtual ~DescribeDeployedApiResponseBodyRequestParametersRequestParameter() = default;
};
class DescribeDeployedApiResponseBodyRequestParameters : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDeployedApiResponseBodyRequestParametersRequestParameter>> requestParameter{};

  DescribeDeployedApiResponseBodyRequestParameters() {}

  explicit DescribeDeployedApiResponseBodyRequestParameters(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestParameter) {
      vector<boost::any> temp1;
      for(auto item1:*requestParameter){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RequestParameter"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestParameter") != m.end() && !m["RequestParameter"].empty()) {
      if (typeid(vector<boost::any>) == m["RequestParameter"].type()) {
        vector<DescribeDeployedApiResponseBodyRequestParametersRequestParameter> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RequestParameter"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDeployedApiResponseBodyRequestParametersRequestParameter model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        requestParameter = make_shared<vector<DescribeDeployedApiResponseBodyRequestParametersRequestParameter>>(expect1);
      }
    }
  }


  virtual ~DescribeDeployedApiResponseBodyRequestParameters() = default;
};
class DescribeDeployedApiResponseBodyResultDescriptionsResultDescription : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<bool> hasChild{};
  shared_ptr<string> id{};
  shared_ptr<string> key{};
  shared_ptr<bool> mandatory{};
  shared_ptr<string> name{};
  shared_ptr<string> pid{};
  shared_ptr<string> type{};

  DescribeDeployedApiResponseBodyResultDescriptionsResultDescription() {}

  explicit DescribeDeployedApiResponseBodyResultDescriptionsResultDescription(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (hasChild) {
      res["HasChild"] = boost::any(*hasChild);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (mandatory) {
      res["Mandatory"] = boost::any(*mandatory);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (pid) {
      res["Pid"] = boost::any(*pid);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("HasChild") != m.end() && !m["HasChild"].empty()) {
      hasChild = make_shared<bool>(boost::any_cast<bool>(m["HasChild"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Mandatory") != m.end() && !m["Mandatory"].empty()) {
      mandatory = make_shared<bool>(boost::any_cast<bool>(m["Mandatory"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Pid") != m.end() && !m["Pid"].empty()) {
      pid = make_shared<string>(boost::any_cast<string>(m["Pid"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DescribeDeployedApiResponseBodyResultDescriptionsResultDescription() = default;
};
class DescribeDeployedApiResponseBodyResultDescriptions : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDeployedApiResponseBodyResultDescriptionsResultDescription>> resultDescription{};

  DescribeDeployedApiResponseBodyResultDescriptions() {}

  explicit DescribeDeployedApiResponseBodyResultDescriptions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resultDescription) {
      vector<boost::any> temp1;
      for(auto item1:*resultDescription){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ResultDescription"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResultDescription") != m.end() && !m["ResultDescription"].empty()) {
      if (typeid(vector<boost::any>) == m["ResultDescription"].type()) {
        vector<DescribeDeployedApiResponseBodyResultDescriptionsResultDescription> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ResultDescription"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDeployedApiResponseBodyResultDescriptionsResultDescription model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        resultDescription = make_shared<vector<DescribeDeployedApiResponseBodyResultDescriptionsResultDescription>>(expect1);
      }
    }
  }


  virtual ~DescribeDeployedApiResponseBodyResultDescriptions() = default;
};
class DescribeDeployedApiResponseBodyServiceConfigFunctionComputeConfig : public Darabonba::Model {
public:
  shared_ptr<string> contentTypeCatagory{};
  shared_ptr<string> contentTypeValue{};
  shared_ptr<string> fcBaseUrl{};
  shared_ptr<string> fcType{};
  shared_ptr<string> functionName{};
  shared_ptr<string> method{};
  shared_ptr<bool> onlyBusinessPath{};
  shared_ptr<string> path{};
  shared_ptr<string> qualifier{};
  shared_ptr<string> regionId{};
  shared_ptr<string> roleArn{};
  shared_ptr<string> serviceName{};

  DescribeDeployedApiResponseBodyServiceConfigFunctionComputeConfig() {}

  explicit DescribeDeployedApiResponseBodyServiceConfigFunctionComputeConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contentTypeCatagory) {
      res["ContentTypeCatagory"] = boost::any(*contentTypeCatagory);
    }
    if (contentTypeValue) {
      res["ContentTypeValue"] = boost::any(*contentTypeValue);
    }
    if (fcBaseUrl) {
      res["FcBaseUrl"] = boost::any(*fcBaseUrl);
    }
    if (fcType) {
      res["FcType"] = boost::any(*fcType);
    }
    if (functionName) {
      res["FunctionName"] = boost::any(*functionName);
    }
    if (method) {
      res["Method"] = boost::any(*method);
    }
    if (onlyBusinessPath) {
      res["OnlyBusinessPath"] = boost::any(*onlyBusinessPath);
    }
    if (path) {
      res["Path"] = boost::any(*path);
    }
    if (qualifier) {
      res["Qualifier"] = boost::any(*qualifier);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (roleArn) {
      res["RoleArn"] = boost::any(*roleArn);
    }
    if (serviceName) {
      res["ServiceName"] = boost::any(*serviceName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ContentTypeCatagory") != m.end() && !m["ContentTypeCatagory"].empty()) {
      contentTypeCatagory = make_shared<string>(boost::any_cast<string>(m["ContentTypeCatagory"]));
    }
    if (m.find("ContentTypeValue") != m.end() && !m["ContentTypeValue"].empty()) {
      contentTypeValue = make_shared<string>(boost::any_cast<string>(m["ContentTypeValue"]));
    }
    if (m.find("FcBaseUrl") != m.end() && !m["FcBaseUrl"].empty()) {
      fcBaseUrl = make_shared<string>(boost::any_cast<string>(m["FcBaseUrl"]));
    }
    if (m.find("FcType") != m.end() && !m["FcType"].empty()) {
      fcType = make_shared<string>(boost::any_cast<string>(m["FcType"]));
    }
    if (m.find("FunctionName") != m.end() && !m["FunctionName"].empty()) {
      functionName = make_shared<string>(boost::any_cast<string>(m["FunctionName"]));
    }
    if (m.find("Method") != m.end() && !m["Method"].empty()) {
      method = make_shared<string>(boost::any_cast<string>(m["Method"]));
    }
    if (m.find("OnlyBusinessPath") != m.end() && !m["OnlyBusinessPath"].empty()) {
      onlyBusinessPath = make_shared<bool>(boost::any_cast<bool>(m["OnlyBusinessPath"]));
    }
    if (m.find("Path") != m.end() && !m["Path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["Path"]));
    }
    if (m.find("Qualifier") != m.end() && !m["Qualifier"].empty()) {
      qualifier = make_shared<string>(boost::any_cast<string>(m["Qualifier"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("RoleArn") != m.end() && !m["RoleArn"].empty()) {
      roleArn = make_shared<string>(boost::any_cast<string>(m["RoleArn"]));
    }
    if (m.find("ServiceName") != m.end() && !m["ServiceName"].empty()) {
      serviceName = make_shared<string>(boost::any_cast<string>(m["ServiceName"]));
    }
  }


  virtual ~DescribeDeployedApiResponseBodyServiceConfigFunctionComputeConfig() = default;
};
class DescribeDeployedApiResponseBodyServiceConfigMockHeadersMockHeader : public Darabonba::Model {
public:
  shared_ptr<string> headerName{};
  shared_ptr<string> headerValue{};

  DescribeDeployedApiResponseBodyServiceConfigMockHeadersMockHeader() {}

  explicit DescribeDeployedApiResponseBodyServiceConfigMockHeadersMockHeader(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headerName) {
      res["HeaderName"] = boost::any(*headerName);
    }
    if (headerValue) {
      res["HeaderValue"] = boost::any(*headerValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HeaderName") != m.end() && !m["HeaderName"].empty()) {
      headerName = make_shared<string>(boost::any_cast<string>(m["HeaderName"]));
    }
    if (m.find("HeaderValue") != m.end() && !m["HeaderValue"].empty()) {
      headerValue = make_shared<string>(boost::any_cast<string>(m["HeaderValue"]));
    }
  }


  virtual ~DescribeDeployedApiResponseBodyServiceConfigMockHeadersMockHeader() = default;
};
class DescribeDeployedApiResponseBodyServiceConfigMockHeaders : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDeployedApiResponseBodyServiceConfigMockHeadersMockHeader>> mockHeader{};

  DescribeDeployedApiResponseBodyServiceConfigMockHeaders() {}

  explicit DescribeDeployedApiResponseBodyServiceConfigMockHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mockHeader) {
      vector<boost::any> temp1;
      for(auto item1:*mockHeader){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["MockHeader"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MockHeader") != m.end() && !m["MockHeader"].empty()) {
      if (typeid(vector<boost::any>) == m["MockHeader"].type()) {
        vector<DescribeDeployedApiResponseBodyServiceConfigMockHeadersMockHeader> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["MockHeader"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDeployedApiResponseBodyServiceConfigMockHeadersMockHeader model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        mockHeader = make_shared<vector<DescribeDeployedApiResponseBodyServiceConfigMockHeadersMockHeader>>(expect1);
      }
    }
  }


  virtual ~DescribeDeployedApiResponseBodyServiceConfigMockHeaders() = default;
};
class DescribeDeployedApiResponseBodyServiceConfigVpcConfig : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> name{};
  shared_ptr<long> port{};
  shared_ptr<string> vpcId{};

  DescribeDeployedApiResponseBodyServiceConfigVpcConfig() {}

  explicit DescribeDeployedApiResponseBodyServiceConfigVpcConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<long>(boost::any_cast<long>(m["Port"]));
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
  }


  virtual ~DescribeDeployedApiResponseBodyServiceConfigVpcConfig() = default;
};
class DescribeDeployedApiResponseBodyServiceConfig : public Darabonba::Model {
public:
  shared_ptr<DescribeDeployedApiResponseBodyServiceConfigFunctionComputeConfig> functionComputeConfig{};
  shared_ptr<string> mock{};
  shared_ptr<DescribeDeployedApiResponseBodyServiceConfigMockHeaders> mockHeaders{};
  shared_ptr<string> mockResult{};
  shared_ptr<long> mockStatusCode{};
  shared_ptr<string> serviceAddress{};
  shared_ptr<string> serviceHttpMethod{};
  shared_ptr<string> servicePath{};
  shared_ptr<string> serviceProtocol{};
  shared_ptr<long> serviceTimeout{};
  shared_ptr<string> serviceVpcEnable{};
  shared_ptr<DescribeDeployedApiResponseBodyServiceConfigVpcConfig> vpcConfig{};
  shared_ptr<string> vpcId{};

  DescribeDeployedApiResponseBodyServiceConfig() {}

  explicit DescribeDeployedApiResponseBodyServiceConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (functionComputeConfig) {
      res["FunctionComputeConfig"] = functionComputeConfig ? boost::any(functionComputeConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (mock) {
      res["Mock"] = boost::any(*mock);
    }
    if (mockHeaders) {
      res["MockHeaders"] = mockHeaders ? boost::any(mockHeaders->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (mockResult) {
      res["MockResult"] = boost::any(*mockResult);
    }
    if (mockStatusCode) {
      res["MockStatusCode"] = boost::any(*mockStatusCode);
    }
    if (serviceAddress) {
      res["ServiceAddress"] = boost::any(*serviceAddress);
    }
    if (serviceHttpMethod) {
      res["ServiceHttpMethod"] = boost::any(*serviceHttpMethod);
    }
    if (servicePath) {
      res["ServicePath"] = boost::any(*servicePath);
    }
    if (serviceProtocol) {
      res["ServiceProtocol"] = boost::any(*serviceProtocol);
    }
    if (serviceTimeout) {
      res["ServiceTimeout"] = boost::any(*serviceTimeout);
    }
    if (serviceVpcEnable) {
      res["ServiceVpcEnable"] = boost::any(*serviceVpcEnable);
    }
    if (vpcConfig) {
      res["VpcConfig"] = vpcConfig ? boost::any(vpcConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FunctionComputeConfig") != m.end() && !m["FunctionComputeConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["FunctionComputeConfig"].type()) {
        DescribeDeployedApiResponseBodyServiceConfigFunctionComputeConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FunctionComputeConfig"]));
        functionComputeConfig = make_shared<DescribeDeployedApiResponseBodyServiceConfigFunctionComputeConfig>(model1);
      }
    }
    if (m.find("Mock") != m.end() && !m["Mock"].empty()) {
      mock = make_shared<string>(boost::any_cast<string>(m["Mock"]));
    }
    if (m.find("MockHeaders") != m.end() && !m["MockHeaders"].empty()) {
      if (typeid(map<string, boost::any>) == m["MockHeaders"].type()) {
        DescribeDeployedApiResponseBodyServiceConfigMockHeaders model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MockHeaders"]));
        mockHeaders = make_shared<DescribeDeployedApiResponseBodyServiceConfigMockHeaders>(model1);
      }
    }
    if (m.find("MockResult") != m.end() && !m["MockResult"].empty()) {
      mockResult = make_shared<string>(boost::any_cast<string>(m["MockResult"]));
    }
    if (m.find("MockStatusCode") != m.end() && !m["MockStatusCode"].empty()) {
      mockStatusCode = make_shared<long>(boost::any_cast<long>(m["MockStatusCode"]));
    }
    if (m.find("ServiceAddress") != m.end() && !m["ServiceAddress"].empty()) {
      serviceAddress = make_shared<string>(boost::any_cast<string>(m["ServiceAddress"]));
    }
    if (m.find("ServiceHttpMethod") != m.end() && !m["ServiceHttpMethod"].empty()) {
      serviceHttpMethod = make_shared<string>(boost::any_cast<string>(m["ServiceHttpMethod"]));
    }
    if (m.find("ServicePath") != m.end() && !m["ServicePath"].empty()) {
      servicePath = make_shared<string>(boost::any_cast<string>(m["ServicePath"]));
    }
    if (m.find("ServiceProtocol") != m.end() && !m["ServiceProtocol"].empty()) {
      serviceProtocol = make_shared<string>(boost::any_cast<string>(m["ServiceProtocol"]));
    }
    if (m.find("ServiceTimeout") != m.end() && !m["ServiceTimeout"].empty()) {
      serviceTimeout = make_shared<long>(boost::any_cast<long>(m["ServiceTimeout"]));
    }
    if (m.find("ServiceVpcEnable") != m.end() && !m["ServiceVpcEnable"].empty()) {
      serviceVpcEnable = make_shared<string>(boost::any_cast<string>(m["ServiceVpcEnable"]));
    }
    if (m.find("VpcConfig") != m.end() && !m["VpcConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["VpcConfig"].type()) {
        DescribeDeployedApiResponseBodyServiceConfigVpcConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["VpcConfig"]));
        vpcConfig = make_shared<DescribeDeployedApiResponseBodyServiceConfigVpcConfig>(model1);
      }
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
  }


  virtual ~DescribeDeployedApiResponseBodyServiceConfig() = default;
};
class DescribeDeployedApiResponseBodyServiceParametersServiceParameter : public Darabonba::Model {
public:
  shared_ptr<string> location{};
  shared_ptr<string> parameterType{};
  shared_ptr<string> serviceParameterName{};

  DescribeDeployedApiResponseBodyServiceParametersServiceParameter() {}

  explicit DescribeDeployedApiResponseBodyServiceParametersServiceParameter(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (parameterType) {
      res["ParameterType"] = boost::any(*parameterType);
    }
    if (serviceParameterName) {
      res["ServiceParameterName"] = boost::any(*serviceParameterName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("ParameterType") != m.end() && !m["ParameterType"].empty()) {
      parameterType = make_shared<string>(boost::any_cast<string>(m["ParameterType"]));
    }
    if (m.find("ServiceParameterName") != m.end() && !m["ServiceParameterName"].empty()) {
      serviceParameterName = make_shared<string>(boost::any_cast<string>(m["ServiceParameterName"]));
    }
  }


  virtual ~DescribeDeployedApiResponseBodyServiceParametersServiceParameter() = default;
};
class DescribeDeployedApiResponseBodyServiceParameters : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDeployedApiResponseBodyServiceParametersServiceParameter>> serviceParameter{};

  DescribeDeployedApiResponseBodyServiceParameters() {}

  explicit DescribeDeployedApiResponseBodyServiceParameters(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (serviceParameter) {
      vector<boost::any> temp1;
      for(auto item1:*serviceParameter){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ServiceParameter"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ServiceParameter") != m.end() && !m["ServiceParameter"].empty()) {
      if (typeid(vector<boost::any>) == m["ServiceParameter"].type()) {
        vector<DescribeDeployedApiResponseBodyServiceParametersServiceParameter> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ServiceParameter"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDeployedApiResponseBodyServiceParametersServiceParameter model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        serviceParameter = make_shared<vector<DescribeDeployedApiResponseBodyServiceParametersServiceParameter>>(expect1);
      }
    }
  }


  virtual ~DescribeDeployedApiResponseBodyServiceParameters() = default;
};
class DescribeDeployedApiResponseBodyServiceParametersMapServiceParameterMap : public Darabonba::Model {
public:
  shared_ptr<string> requestParameterName{};
  shared_ptr<string> serviceParameterName{};

  DescribeDeployedApiResponseBodyServiceParametersMapServiceParameterMap() {}

  explicit DescribeDeployedApiResponseBodyServiceParametersMapServiceParameterMap(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestParameterName) {
      res["RequestParameterName"] = boost::any(*requestParameterName);
    }
    if (serviceParameterName) {
      res["ServiceParameterName"] = boost::any(*serviceParameterName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestParameterName") != m.end() && !m["RequestParameterName"].empty()) {
      requestParameterName = make_shared<string>(boost::any_cast<string>(m["RequestParameterName"]));
    }
    if (m.find("ServiceParameterName") != m.end() && !m["ServiceParameterName"].empty()) {
      serviceParameterName = make_shared<string>(boost::any_cast<string>(m["ServiceParameterName"]));
    }
  }


  virtual ~DescribeDeployedApiResponseBodyServiceParametersMapServiceParameterMap() = default;
};
class DescribeDeployedApiResponseBodyServiceParametersMap : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDeployedApiResponseBodyServiceParametersMapServiceParameterMap>> serviceParameterMap{};

  DescribeDeployedApiResponseBodyServiceParametersMap() {}

  explicit DescribeDeployedApiResponseBodyServiceParametersMap(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (serviceParameterMap) {
      vector<boost::any> temp1;
      for(auto item1:*serviceParameterMap){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ServiceParameterMap"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ServiceParameterMap") != m.end() && !m["ServiceParameterMap"].empty()) {
      if (typeid(vector<boost::any>) == m["ServiceParameterMap"].type()) {
        vector<DescribeDeployedApiResponseBodyServiceParametersMapServiceParameterMap> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ServiceParameterMap"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDeployedApiResponseBodyServiceParametersMapServiceParameterMap model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        serviceParameterMap = make_shared<vector<DescribeDeployedApiResponseBodyServiceParametersMapServiceParameterMap>>(expect1);
      }
    }
  }


  virtual ~DescribeDeployedApiResponseBodyServiceParametersMap() = default;
};
class DescribeDeployedApiResponseBodySystemParametersSystemParameter : public Darabonba::Model {
public:
  shared_ptr<string> demoValue{};
  shared_ptr<string> description{};
  shared_ptr<string> location{};
  shared_ptr<string> parameterName{};
  shared_ptr<string> serviceParameterName{};

  DescribeDeployedApiResponseBodySystemParametersSystemParameter() {}

  explicit DescribeDeployedApiResponseBodySystemParametersSystemParameter(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (demoValue) {
      res["DemoValue"] = boost::any(*demoValue);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (parameterName) {
      res["ParameterName"] = boost::any(*parameterName);
    }
    if (serviceParameterName) {
      res["ServiceParameterName"] = boost::any(*serviceParameterName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DemoValue") != m.end() && !m["DemoValue"].empty()) {
      demoValue = make_shared<string>(boost::any_cast<string>(m["DemoValue"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("ParameterName") != m.end() && !m["ParameterName"].empty()) {
      parameterName = make_shared<string>(boost::any_cast<string>(m["ParameterName"]));
    }
    if (m.find("ServiceParameterName") != m.end() && !m["ServiceParameterName"].empty()) {
      serviceParameterName = make_shared<string>(boost::any_cast<string>(m["ServiceParameterName"]));
    }
  }


  virtual ~DescribeDeployedApiResponseBodySystemParametersSystemParameter() = default;
};
class DescribeDeployedApiResponseBodySystemParameters : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDeployedApiResponseBodySystemParametersSystemParameter>> systemParameter{};

  DescribeDeployedApiResponseBodySystemParameters() {}

  explicit DescribeDeployedApiResponseBodySystemParameters(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (systemParameter) {
      vector<boost::any> temp1;
      for(auto item1:*systemParameter){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SystemParameter"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SystemParameter") != m.end() && !m["SystemParameter"].empty()) {
      if (typeid(vector<boost::any>) == m["SystemParameter"].type()) {
        vector<DescribeDeployedApiResponseBodySystemParametersSystemParameter> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SystemParameter"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDeployedApiResponseBodySystemParametersSystemParameter model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        systemParameter = make_shared<vector<DescribeDeployedApiResponseBodySystemParametersSystemParameter>>(expect1);
      }
    }
  }


  virtual ~DescribeDeployedApiResponseBodySystemParameters() = default;
};
class DescribeDeployedApiResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> allowSignatureMethod{};
  shared_ptr<string> apiId{};
  shared_ptr<string> apiName{};
  shared_ptr<string> authType{};
  shared_ptr<DescribeDeployedApiResponseBodyConstantParameters> constantParameters{};
  shared_ptr<DescribeDeployedApiResponseBodyCustomSystemParameters> customSystemParameters{};
  shared_ptr<string> deployedTime{};
  shared_ptr<string> description{};
  shared_ptr<bool> disableInternet{};
  shared_ptr<DescribeDeployedApiResponseBodyErrorCodeSamples> errorCodeSamples{};
  shared_ptr<string> failResultSample{};
  shared_ptr<bool> forceNonceCheck{};
  shared_ptr<string> groupId{};
  shared_ptr<string> groupName{};
  shared_ptr<DescribeDeployedApiResponseBodyOpenIdConnectConfig> openIdConnectConfig{};
  shared_ptr<string> regionId{};
  shared_ptr<DescribeDeployedApiResponseBodyRequestConfig> requestConfig{};
  shared_ptr<string> requestId{};
  shared_ptr<DescribeDeployedApiResponseBodyRequestParameters> requestParameters{};
  shared_ptr<string> resultBodyModel{};
  shared_ptr<DescribeDeployedApiResponseBodyResultDescriptions> resultDescriptions{};
  shared_ptr<string> resultSample{};
  shared_ptr<string> resultType{};
  shared_ptr<DescribeDeployedApiResponseBodyServiceConfig> serviceConfig{};
  shared_ptr<DescribeDeployedApiResponseBodyServiceParameters> serviceParameters{};
  shared_ptr<DescribeDeployedApiResponseBodyServiceParametersMap> serviceParametersMap{};
  shared_ptr<string> stageName{};
  shared_ptr<DescribeDeployedApiResponseBodySystemParameters> systemParameters{};
  shared_ptr<string> visibility{};

  DescribeDeployedApiResponseBody() {}

  explicit DescribeDeployedApiResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (allowSignatureMethod) {
      res["AllowSignatureMethod"] = boost::any(*allowSignatureMethod);
    }
    if (apiId) {
      res["ApiId"] = boost::any(*apiId);
    }
    if (apiName) {
      res["ApiName"] = boost::any(*apiName);
    }
    if (authType) {
      res["AuthType"] = boost::any(*authType);
    }
    if (constantParameters) {
      res["ConstantParameters"] = constantParameters ? boost::any(constantParameters->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (customSystemParameters) {
      res["CustomSystemParameters"] = customSystemParameters ? boost::any(customSystemParameters->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (deployedTime) {
      res["DeployedTime"] = boost::any(*deployedTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (disableInternet) {
      res["DisableInternet"] = boost::any(*disableInternet);
    }
    if (errorCodeSamples) {
      res["ErrorCodeSamples"] = errorCodeSamples ? boost::any(errorCodeSamples->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (failResultSample) {
      res["FailResultSample"] = boost::any(*failResultSample);
    }
    if (forceNonceCheck) {
      res["ForceNonceCheck"] = boost::any(*forceNonceCheck);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (openIdConnectConfig) {
      res["OpenIdConnectConfig"] = openIdConnectConfig ? boost::any(openIdConnectConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (requestConfig) {
      res["RequestConfig"] = requestConfig ? boost::any(requestConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (requestParameters) {
      res["RequestParameters"] = requestParameters ? boost::any(requestParameters->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (resultBodyModel) {
      res["ResultBodyModel"] = boost::any(*resultBodyModel);
    }
    if (resultDescriptions) {
      res["ResultDescriptions"] = resultDescriptions ? boost::any(resultDescriptions->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (resultSample) {
      res["ResultSample"] = boost::any(*resultSample);
    }
    if (resultType) {
      res["ResultType"] = boost::any(*resultType);
    }
    if (serviceConfig) {
      res["ServiceConfig"] = serviceConfig ? boost::any(serviceConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (serviceParameters) {
      res["ServiceParameters"] = serviceParameters ? boost::any(serviceParameters->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (serviceParametersMap) {
      res["ServiceParametersMap"] = serviceParametersMap ? boost::any(serviceParametersMap->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (stageName) {
      res["StageName"] = boost::any(*stageName);
    }
    if (systemParameters) {
      res["SystemParameters"] = systemParameters ? boost::any(systemParameters->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (visibility) {
      res["Visibility"] = boost::any(*visibility);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AllowSignatureMethod") != m.end() && !m["AllowSignatureMethod"].empty()) {
      allowSignatureMethod = make_shared<string>(boost::any_cast<string>(m["AllowSignatureMethod"]));
    }
    if (m.find("ApiId") != m.end() && !m["ApiId"].empty()) {
      apiId = make_shared<string>(boost::any_cast<string>(m["ApiId"]));
    }
    if (m.find("ApiName") != m.end() && !m["ApiName"].empty()) {
      apiName = make_shared<string>(boost::any_cast<string>(m["ApiName"]));
    }
    if (m.find("AuthType") != m.end() && !m["AuthType"].empty()) {
      authType = make_shared<string>(boost::any_cast<string>(m["AuthType"]));
    }
    if (m.find("ConstantParameters") != m.end() && !m["ConstantParameters"].empty()) {
      if (typeid(map<string, boost::any>) == m["ConstantParameters"].type()) {
        DescribeDeployedApiResponseBodyConstantParameters model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ConstantParameters"]));
        constantParameters = make_shared<DescribeDeployedApiResponseBodyConstantParameters>(model1);
      }
    }
    if (m.find("CustomSystemParameters") != m.end() && !m["CustomSystemParameters"].empty()) {
      if (typeid(map<string, boost::any>) == m["CustomSystemParameters"].type()) {
        DescribeDeployedApiResponseBodyCustomSystemParameters model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CustomSystemParameters"]));
        customSystemParameters = make_shared<DescribeDeployedApiResponseBodyCustomSystemParameters>(model1);
      }
    }
    if (m.find("DeployedTime") != m.end() && !m["DeployedTime"].empty()) {
      deployedTime = make_shared<string>(boost::any_cast<string>(m["DeployedTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DisableInternet") != m.end() && !m["DisableInternet"].empty()) {
      disableInternet = make_shared<bool>(boost::any_cast<bool>(m["DisableInternet"]));
    }
    if (m.find("ErrorCodeSamples") != m.end() && !m["ErrorCodeSamples"].empty()) {
      if (typeid(map<string, boost::any>) == m["ErrorCodeSamples"].type()) {
        DescribeDeployedApiResponseBodyErrorCodeSamples model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ErrorCodeSamples"]));
        errorCodeSamples = make_shared<DescribeDeployedApiResponseBodyErrorCodeSamples>(model1);
      }
    }
    if (m.find("FailResultSample") != m.end() && !m["FailResultSample"].empty()) {
      failResultSample = make_shared<string>(boost::any_cast<string>(m["FailResultSample"]));
    }
    if (m.find("ForceNonceCheck") != m.end() && !m["ForceNonceCheck"].empty()) {
      forceNonceCheck = make_shared<bool>(boost::any_cast<bool>(m["ForceNonceCheck"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("OpenIdConnectConfig") != m.end() && !m["OpenIdConnectConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["OpenIdConnectConfig"].type()) {
        DescribeDeployedApiResponseBodyOpenIdConnectConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OpenIdConnectConfig"]));
        openIdConnectConfig = make_shared<DescribeDeployedApiResponseBodyOpenIdConnectConfig>(model1);
      }
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("RequestConfig") != m.end() && !m["RequestConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["RequestConfig"].type()) {
        DescribeDeployedApiResponseBodyRequestConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RequestConfig"]));
        requestConfig = make_shared<DescribeDeployedApiResponseBodyRequestConfig>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("RequestParameters") != m.end() && !m["RequestParameters"].empty()) {
      if (typeid(map<string, boost::any>) == m["RequestParameters"].type()) {
        DescribeDeployedApiResponseBodyRequestParameters model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RequestParameters"]));
        requestParameters = make_shared<DescribeDeployedApiResponseBodyRequestParameters>(model1);
      }
    }
    if (m.find("ResultBodyModel") != m.end() && !m["ResultBodyModel"].empty()) {
      resultBodyModel = make_shared<string>(boost::any_cast<string>(m["ResultBodyModel"]));
    }
    if (m.find("ResultDescriptions") != m.end() && !m["ResultDescriptions"].empty()) {
      if (typeid(map<string, boost::any>) == m["ResultDescriptions"].type()) {
        DescribeDeployedApiResponseBodyResultDescriptions model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ResultDescriptions"]));
        resultDescriptions = make_shared<DescribeDeployedApiResponseBodyResultDescriptions>(model1);
      }
    }
    if (m.find("ResultSample") != m.end() && !m["ResultSample"].empty()) {
      resultSample = make_shared<string>(boost::any_cast<string>(m["ResultSample"]));
    }
    if (m.find("ResultType") != m.end() && !m["ResultType"].empty()) {
      resultType = make_shared<string>(boost::any_cast<string>(m["ResultType"]));
    }
    if (m.find("ServiceConfig") != m.end() && !m["ServiceConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["ServiceConfig"].type()) {
        DescribeDeployedApiResponseBodyServiceConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ServiceConfig"]));
        serviceConfig = make_shared<DescribeDeployedApiResponseBodyServiceConfig>(model1);
      }
    }
    if (m.find("ServiceParameters") != m.end() && !m["ServiceParameters"].empty()) {
      if (typeid(map<string, boost::any>) == m["ServiceParameters"].type()) {
        DescribeDeployedApiResponseBodyServiceParameters model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ServiceParameters"]));
        serviceParameters = make_shared<DescribeDeployedApiResponseBodyServiceParameters>(model1);
      }
    }
    if (m.find("ServiceParametersMap") != m.end() && !m["ServiceParametersMap"].empty()) {
      if (typeid(map<string, boost::any>) == m["ServiceParametersMap"].type()) {
        DescribeDeployedApiResponseBodyServiceParametersMap model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ServiceParametersMap"]));
        serviceParametersMap = make_shared<DescribeDeployedApiResponseBodyServiceParametersMap>(model1);
      }
    }
    if (m.find("StageName") != m.end() && !m["StageName"].empty()) {
      stageName = make_shared<string>(boost::any_cast<string>(m["StageName"]));
    }
    if (m.find("SystemParameters") != m.end() && !m["SystemParameters"].empty()) {
      if (typeid(map<string, boost::any>) == m["SystemParameters"].type()) {
        DescribeDeployedApiResponseBodySystemParameters model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SystemParameters"]));
        systemParameters = make_shared<DescribeDeployedApiResponseBodySystemParameters>(model1);
      }
    }
    if (m.find("Visibility") != m.end() && !m["Visibility"].empty()) {
      visibility = make_shared<string>(boost::any_cast<string>(m["Visibility"]));
    }
  }


  virtual ~DescribeDeployedApiResponseBody() = default;
};
class DescribeDeployedApiResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeDeployedApiResponseBody> body{};

  DescribeDeployedApiResponse() {}

  explicit DescribeDeployedApiResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDeployedApiResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDeployedApiResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDeployedApiResponse() = default;
};
class DescribeDeployedApisRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  DescribeDeployedApisRequestTag() {}

  explicit DescribeDeployedApisRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeDeployedApisRequestTag() = default;
};
class DescribeDeployedApisRequest : public Darabonba::Model {
public:
  shared_ptr<string> apiId{};
  shared_ptr<string> apiName{};
  shared_ptr<bool> enableTagAuth{};
  shared_ptr<string> groupId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> stageName{};
  shared_ptr<vector<DescribeDeployedApisRequestTag>> tag{};

  DescribeDeployedApisRequest() {}

  explicit DescribeDeployedApisRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiId) {
      res["ApiId"] = boost::any(*apiId);
    }
    if (apiName) {
      res["ApiName"] = boost::any(*apiName);
    }
    if (enableTagAuth) {
      res["EnableTagAuth"] = boost::any(*enableTagAuth);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (stageName) {
      res["StageName"] = boost::any(*stageName);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiId") != m.end() && !m["ApiId"].empty()) {
      apiId = make_shared<string>(boost::any_cast<string>(m["ApiId"]));
    }
    if (m.find("ApiName") != m.end() && !m["ApiName"].empty()) {
      apiName = make_shared<string>(boost::any_cast<string>(m["ApiName"]));
    }
    if (m.find("EnableTagAuth") != m.end() && !m["EnableTagAuth"].empty()) {
      enableTagAuth = make_shared<bool>(boost::any_cast<bool>(m["EnableTagAuth"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("StageName") != m.end() && !m["StageName"].empty()) {
      stageName = make_shared<string>(boost::any_cast<string>(m["StageName"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<DescribeDeployedApisRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDeployedApisRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<DescribeDeployedApisRequestTag>>(expect1);
      }
    }
  }


  virtual ~DescribeDeployedApisRequest() = default;
};
class DescribeDeployedApisResponseBodyDeployedApisDeployedApiItem : public Darabonba::Model {
public:
  shared_ptr<string> apiId{};
  shared_ptr<string> apiName{};
  shared_ptr<string> deployedTime{};
  shared_ptr<string> description{};
  shared_ptr<string> groupId{};
  shared_ptr<string> groupName{};
  shared_ptr<string> regionId{};
  shared_ptr<string> stageName{};
  shared_ptr<string> visibility{};

  DescribeDeployedApisResponseBodyDeployedApisDeployedApiItem() {}

  explicit DescribeDeployedApisResponseBodyDeployedApisDeployedApiItem(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiId) {
      res["ApiId"] = boost::any(*apiId);
    }
    if (apiName) {
      res["ApiName"] = boost::any(*apiName);
    }
    if (deployedTime) {
      res["DeployedTime"] = boost::any(*deployedTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (stageName) {
      res["StageName"] = boost::any(*stageName);
    }
    if (visibility) {
      res["Visibility"] = boost::any(*visibility);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiId") != m.end() && !m["ApiId"].empty()) {
      apiId = make_shared<string>(boost::any_cast<string>(m["ApiId"]));
    }
    if (m.find("ApiName") != m.end() && !m["ApiName"].empty()) {
      apiName = make_shared<string>(boost::any_cast<string>(m["ApiName"]));
    }
    if (m.find("DeployedTime") != m.end() && !m["DeployedTime"].empty()) {
      deployedTime = make_shared<string>(boost::any_cast<string>(m["DeployedTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("StageName") != m.end() && !m["StageName"].empty()) {
      stageName = make_shared<string>(boost::any_cast<string>(m["StageName"]));
    }
    if (m.find("Visibility") != m.end() && !m["Visibility"].empty()) {
      visibility = make_shared<string>(boost::any_cast<string>(m["Visibility"]));
    }
  }


  virtual ~DescribeDeployedApisResponseBodyDeployedApisDeployedApiItem() = default;
};
class DescribeDeployedApisResponseBodyDeployedApis : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDeployedApisResponseBodyDeployedApisDeployedApiItem>> deployedApiItem{};

  DescribeDeployedApisResponseBodyDeployedApis() {}

  explicit DescribeDeployedApisResponseBodyDeployedApis(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deployedApiItem) {
      vector<boost::any> temp1;
      for(auto item1:*deployedApiItem){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DeployedApiItem"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeployedApiItem") != m.end() && !m["DeployedApiItem"].empty()) {
      if (typeid(vector<boost::any>) == m["DeployedApiItem"].type()) {
        vector<DescribeDeployedApisResponseBodyDeployedApisDeployedApiItem> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DeployedApiItem"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDeployedApisResponseBodyDeployedApisDeployedApiItem model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        deployedApiItem = make_shared<vector<DescribeDeployedApisResponseBodyDeployedApisDeployedApiItem>>(expect1);
      }
    }
  }


  virtual ~DescribeDeployedApisResponseBodyDeployedApis() = default;
};
class DescribeDeployedApisResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeDeployedApisResponseBodyDeployedApis> deployedApis{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeDeployedApisResponseBody() {}

  explicit DescribeDeployedApisResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deployedApis) {
      res["DeployedApis"] = deployedApis ? boost::any(deployedApis->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeployedApis") != m.end() && !m["DeployedApis"].empty()) {
      if (typeid(map<string, boost::any>) == m["DeployedApis"].type()) {
        DescribeDeployedApisResponseBodyDeployedApis model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DeployedApis"]));
        deployedApis = make_shared<DescribeDeployedApisResponseBodyDeployedApis>(model1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeDeployedApisResponseBody() = default;
};
class DescribeDeployedApisResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeDeployedApisResponseBody> body{};

  DescribeDeployedApisResponse() {}

  explicit DescribeDeployedApisResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDeployedApisResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDeployedApisResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDeployedApisResponse() = default;
};
class DescribeDomainRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> groupId{};
  shared_ptr<string> securityToken{};

  DescribeDomainRequest() {}

  explicit DescribeDomainRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~DescribeDomainRequest() = default;
};
class DescribeDomainResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> certificateBody{};
  shared_ptr<string> certificateId{};
  shared_ptr<string> certificateName{};
  shared_ptr<string> certificatePrivateKey{};
  shared_ptr<string> domainBindingStatus{};
  shared_ptr<string> domainCNAMEStatus{};
  shared_ptr<string> domainLegalStatus{};
  shared_ptr<string> domainName{};
  shared_ptr<string> domainRemark{};
  shared_ptr<string> domainWebSocketStatus{};
  shared_ptr<string> groupId{};
  shared_ptr<string> requestId{};
  shared_ptr<string> subDomain{};

  DescribeDomainResponseBody() {}

  explicit DescribeDomainResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (certificateBody) {
      res["CertificateBody"] = boost::any(*certificateBody);
    }
    if (certificateId) {
      res["CertificateId"] = boost::any(*certificateId);
    }
    if (certificateName) {
      res["CertificateName"] = boost::any(*certificateName);
    }
    if (certificatePrivateKey) {
      res["CertificatePrivateKey"] = boost::any(*certificatePrivateKey);
    }
    if (domainBindingStatus) {
      res["DomainBindingStatus"] = boost::any(*domainBindingStatus);
    }
    if (domainCNAMEStatus) {
      res["DomainCNAMEStatus"] = boost::any(*domainCNAMEStatus);
    }
    if (domainLegalStatus) {
      res["DomainLegalStatus"] = boost::any(*domainLegalStatus);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (domainRemark) {
      res["DomainRemark"] = boost::any(*domainRemark);
    }
    if (domainWebSocketStatus) {
      res["DomainWebSocketStatus"] = boost::any(*domainWebSocketStatus);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (subDomain) {
      res["SubDomain"] = boost::any(*subDomain);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CertificateBody") != m.end() && !m["CertificateBody"].empty()) {
      certificateBody = make_shared<string>(boost::any_cast<string>(m["CertificateBody"]));
    }
    if (m.find("CertificateId") != m.end() && !m["CertificateId"].empty()) {
      certificateId = make_shared<string>(boost::any_cast<string>(m["CertificateId"]));
    }
    if (m.find("CertificateName") != m.end() && !m["CertificateName"].empty()) {
      certificateName = make_shared<string>(boost::any_cast<string>(m["CertificateName"]));
    }
    if (m.find("CertificatePrivateKey") != m.end() && !m["CertificatePrivateKey"].empty()) {
      certificatePrivateKey = make_shared<string>(boost::any_cast<string>(m["CertificatePrivateKey"]));
    }
    if (m.find("DomainBindingStatus") != m.end() && !m["DomainBindingStatus"].empty()) {
      domainBindingStatus = make_shared<string>(boost::any_cast<string>(m["DomainBindingStatus"]));
    }
    if (m.find("DomainCNAMEStatus") != m.end() && !m["DomainCNAMEStatus"].empty()) {
      domainCNAMEStatus = make_shared<string>(boost::any_cast<string>(m["DomainCNAMEStatus"]));
    }
    if (m.find("DomainLegalStatus") != m.end() && !m["DomainLegalStatus"].empty()) {
      domainLegalStatus = make_shared<string>(boost::any_cast<string>(m["DomainLegalStatus"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("DomainRemark") != m.end() && !m["DomainRemark"].empty()) {
      domainRemark = make_shared<string>(boost::any_cast<string>(m["DomainRemark"]));
    }
    if (m.find("DomainWebSocketStatus") != m.end() && !m["DomainWebSocketStatus"].empty()) {
      domainWebSocketStatus = make_shared<string>(boost::any_cast<string>(m["DomainWebSocketStatus"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SubDomain") != m.end() && !m["SubDomain"].empty()) {
      subDomain = make_shared<string>(boost::any_cast<string>(m["SubDomain"]));
    }
  }


  virtual ~DescribeDomainResponseBody() = default;
};
class DescribeDomainResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeDomainResponseBody> body{};

  DescribeDomainResponse() {}

  explicit DescribeDomainResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDomainResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDomainResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDomainResponse() = default;
};
class DescribeHistoryApisRequest : public Darabonba::Model {
public:
  shared_ptr<string> apiId{};
  shared_ptr<string> apiName{};
  shared_ptr<string> groupId{};
  shared_ptr<string> pageNumber{};
  shared_ptr<string> pageSize{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> stageName{};

  DescribeHistoryApisRequest() {}

  explicit DescribeHistoryApisRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiId) {
      res["ApiId"] = boost::any(*apiId);
    }
    if (apiName) {
      res["ApiName"] = boost::any(*apiName);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (stageName) {
      res["StageName"] = boost::any(*stageName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiId") != m.end() && !m["ApiId"].empty()) {
      apiId = make_shared<string>(boost::any_cast<string>(m["ApiId"]));
    }
    if (m.find("ApiName") != m.end() && !m["ApiName"].empty()) {
      apiName = make_shared<string>(boost::any_cast<string>(m["ApiName"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<string>(boost::any_cast<string>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<string>(boost::any_cast<string>(m["PageSize"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("StageName") != m.end() && !m["StageName"].empty()) {
      stageName = make_shared<string>(boost::any_cast<string>(m["StageName"]));
    }
  }


  virtual ~DescribeHistoryApisRequest() = default;
};
class DescribeHistoryApisResponseBodyApiHisItemsApiHisItem : public Darabonba::Model {
public:
  shared_ptr<string> apiId{};
  shared_ptr<string> apiName{};
  shared_ptr<string> deployedTime{};
  shared_ptr<string> description{};
  shared_ptr<string> groupId{};
  shared_ptr<string> groupName{};
  shared_ptr<string> historyVersion{};
  shared_ptr<string> regionId{};
  shared_ptr<string> stageName{};
  shared_ptr<string> status{};

  DescribeHistoryApisResponseBodyApiHisItemsApiHisItem() {}

  explicit DescribeHistoryApisResponseBodyApiHisItemsApiHisItem(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiId) {
      res["ApiId"] = boost::any(*apiId);
    }
    if (apiName) {
      res["ApiName"] = boost::any(*apiName);
    }
    if (deployedTime) {
      res["DeployedTime"] = boost::any(*deployedTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (historyVersion) {
      res["HistoryVersion"] = boost::any(*historyVersion);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (stageName) {
      res["StageName"] = boost::any(*stageName);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiId") != m.end() && !m["ApiId"].empty()) {
      apiId = make_shared<string>(boost::any_cast<string>(m["ApiId"]));
    }
    if (m.find("ApiName") != m.end() && !m["ApiName"].empty()) {
      apiName = make_shared<string>(boost::any_cast<string>(m["ApiName"]));
    }
    if (m.find("DeployedTime") != m.end() && !m["DeployedTime"].empty()) {
      deployedTime = make_shared<string>(boost::any_cast<string>(m["DeployedTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("HistoryVersion") != m.end() && !m["HistoryVersion"].empty()) {
      historyVersion = make_shared<string>(boost::any_cast<string>(m["HistoryVersion"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("StageName") != m.end() && !m["StageName"].empty()) {
      stageName = make_shared<string>(boost::any_cast<string>(m["StageName"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeHistoryApisResponseBodyApiHisItemsApiHisItem() = default;
};
class DescribeHistoryApisResponseBodyApiHisItems : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeHistoryApisResponseBodyApiHisItemsApiHisItem>> apiHisItem{};

  DescribeHistoryApisResponseBodyApiHisItems() {}

  explicit DescribeHistoryApisResponseBodyApiHisItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiHisItem) {
      vector<boost::any> temp1;
      for(auto item1:*apiHisItem){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ApiHisItem"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiHisItem") != m.end() && !m["ApiHisItem"].empty()) {
      if (typeid(vector<boost::any>) == m["ApiHisItem"].type()) {
        vector<DescribeHistoryApisResponseBodyApiHisItemsApiHisItem> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ApiHisItem"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeHistoryApisResponseBodyApiHisItemsApiHisItem model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        apiHisItem = make_shared<vector<DescribeHistoryApisResponseBodyApiHisItemsApiHisItem>>(expect1);
      }
    }
  }


  virtual ~DescribeHistoryApisResponseBodyApiHisItems() = default;
};
class DescribeHistoryApisResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeHistoryApisResponseBodyApiHisItems> apiHisItems{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeHistoryApisResponseBody() {}

  explicit DescribeHistoryApisResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiHisItems) {
      res["ApiHisItems"] = apiHisItems ? boost::any(apiHisItems->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiHisItems") != m.end() && !m["ApiHisItems"].empty()) {
      if (typeid(map<string, boost::any>) == m["ApiHisItems"].type()) {
        DescribeHistoryApisResponseBodyApiHisItems model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ApiHisItems"]));
        apiHisItems = make_shared<DescribeHistoryApisResponseBodyApiHisItems>(model1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeHistoryApisResponseBody() = default;
};
class DescribeHistoryApisResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeHistoryApisResponseBody> body{};

  DescribeHistoryApisResponse() {}

  explicit DescribeHistoryApisResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeHistoryApisResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeHistoryApisResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeHistoryApisResponse() = default;
};
class DescribeIpControlPolicyItemsRequest : public Darabonba::Model {
public:
  shared_ptr<string> ipControlId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> policyItemId{};
  shared_ptr<string> securityToken{};

  DescribeIpControlPolicyItemsRequest() {}

  explicit DescribeIpControlPolicyItemsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ipControlId) {
      res["IpControlId"] = boost::any(*ipControlId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (policyItemId) {
      res["PolicyItemId"] = boost::any(*policyItemId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IpControlId") != m.end() && !m["IpControlId"].empty()) {
      ipControlId = make_shared<string>(boost::any_cast<string>(m["IpControlId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("PolicyItemId") != m.end() && !m["PolicyItemId"].empty()) {
      policyItemId = make_shared<string>(boost::any_cast<string>(m["PolicyItemId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~DescribeIpControlPolicyItemsRequest() = default;
};
class DescribeIpControlPolicyItemsResponseBodyIpControlPolicyItemsIpControlPolicyItem : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> cidrIp{};
  shared_ptr<string> createTime{};
  shared_ptr<string> modifiedTime{};
  shared_ptr<string> policyItemId{};

  DescribeIpControlPolicyItemsResponseBodyIpControlPolicyItemsIpControlPolicyItem() {}

  explicit DescribeIpControlPolicyItemsResponseBodyIpControlPolicyItemsIpControlPolicyItem(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (cidrIp) {
      res["CidrIp"] = boost::any(*cidrIp);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (modifiedTime) {
      res["ModifiedTime"] = boost::any(*modifiedTime);
    }
    if (policyItemId) {
      res["PolicyItemId"] = boost::any(*policyItemId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("CidrIp") != m.end() && !m["CidrIp"].empty()) {
      cidrIp = make_shared<string>(boost::any_cast<string>(m["CidrIp"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("ModifiedTime") != m.end() && !m["ModifiedTime"].empty()) {
      modifiedTime = make_shared<string>(boost::any_cast<string>(m["ModifiedTime"]));
    }
    if (m.find("PolicyItemId") != m.end() && !m["PolicyItemId"].empty()) {
      policyItemId = make_shared<string>(boost::any_cast<string>(m["PolicyItemId"]));
    }
  }


  virtual ~DescribeIpControlPolicyItemsResponseBodyIpControlPolicyItemsIpControlPolicyItem() = default;
};
class DescribeIpControlPolicyItemsResponseBodyIpControlPolicyItems : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeIpControlPolicyItemsResponseBodyIpControlPolicyItemsIpControlPolicyItem>> ipControlPolicyItem{};

  DescribeIpControlPolicyItemsResponseBodyIpControlPolicyItems() {}

  explicit DescribeIpControlPolicyItemsResponseBodyIpControlPolicyItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ipControlPolicyItem) {
      vector<boost::any> temp1;
      for(auto item1:*ipControlPolicyItem){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["IpControlPolicyItem"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IpControlPolicyItem") != m.end() && !m["IpControlPolicyItem"].empty()) {
      if (typeid(vector<boost::any>) == m["IpControlPolicyItem"].type()) {
        vector<DescribeIpControlPolicyItemsResponseBodyIpControlPolicyItemsIpControlPolicyItem> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["IpControlPolicyItem"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeIpControlPolicyItemsResponseBodyIpControlPolicyItemsIpControlPolicyItem model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ipControlPolicyItem = make_shared<vector<DescribeIpControlPolicyItemsResponseBodyIpControlPolicyItemsIpControlPolicyItem>>(expect1);
      }
    }
  }


  virtual ~DescribeIpControlPolicyItemsResponseBodyIpControlPolicyItems() = default;
};
class DescribeIpControlPolicyItemsResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeIpControlPolicyItemsResponseBodyIpControlPolicyItems> ipControlPolicyItems{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeIpControlPolicyItemsResponseBody() {}

  explicit DescribeIpControlPolicyItemsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ipControlPolicyItems) {
      res["IpControlPolicyItems"] = ipControlPolicyItems ? boost::any(ipControlPolicyItems->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IpControlPolicyItems") != m.end() && !m["IpControlPolicyItems"].empty()) {
      if (typeid(map<string, boost::any>) == m["IpControlPolicyItems"].type()) {
        DescribeIpControlPolicyItemsResponseBodyIpControlPolicyItems model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["IpControlPolicyItems"]));
        ipControlPolicyItems = make_shared<DescribeIpControlPolicyItemsResponseBodyIpControlPolicyItems>(model1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeIpControlPolicyItemsResponseBody() = default;
};
class DescribeIpControlPolicyItemsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeIpControlPolicyItemsResponseBody> body{};

  DescribeIpControlPolicyItemsResponse() {}

  explicit DescribeIpControlPolicyItemsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeIpControlPolicyItemsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeIpControlPolicyItemsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeIpControlPolicyItemsResponse() = default;
};
class DescribeIpControlsRequest : public Darabonba::Model {
public:
  shared_ptr<string> ipControlId{};
  shared_ptr<string> ipControlName{};
  shared_ptr<string> ipControlType{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> securityToken{};

  DescribeIpControlsRequest() {}

  explicit DescribeIpControlsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ipControlId) {
      res["IpControlId"] = boost::any(*ipControlId);
    }
    if (ipControlName) {
      res["IpControlName"] = boost::any(*ipControlName);
    }
    if (ipControlType) {
      res["IpControlType"] = boost::any(*ipControlType);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IpControlId") != m.end() && !m["IpControlId"].empty()) {
      ipControlId = make_shared<string>(boost::any_cast<string>(m["IpControlId"]));
    }
    if (m.find("IpControlName") != m.end() && !m["IpControlName"].empty()) {
      ipControlName = make_shared<string>(boost::any_cast<string>(m["IpControlName"]));
    }
    if (m.find("IpControlType") != m.end() && !m["IpControlType"].empty()) {
      ipControlType = make_shared<string>(boost::any_cast<string>(m["IpControlType"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~DescribeIpControlsRequest() = default;
};
class DescribeIpControlsResponseBodyIpControlInfosIpControlInfo : public Darabonba::Model {
public:
  shared_ptr<string> createTime{};
  shared_ptr<string> description{};
  shared_ptr<string> ipControlId{};
  shared_ptr<string> ipControlName{};
  shared_ptr<string> ipControlType{};
  shared_ptr<string> modifiedTime{};
  shared_ptr<string> regionId{};

  DescribeIpControlsResponseBodyIpControlInfosIpControlInfo() {}

  explicit DescribeIpControlsResponseBodyIpControlInfosIpControlInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (ipControlId) {
      res["IpControlId"] = boost::any(*ipControlId);
    }
    if (ipControlName) {
      res["IpControlName"] = boost::any(*ipControlName);
    }
    if (ipControlType) {
      res["IpControlType"] = boost::any(*ipControlType);
    }
    if (modifiedTime) {
      res["ModifiedTime"] = boost::any(*modifiedTime);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("IpControlId") != m.end() && !m["IpControlId"].empty()) {
      ipControlId = make_shared<string>(boost::any_cast<string>(m["IpControlId"]));
    }
    if (m.find("IpControlName") != m.end() && !m["IpControlName"].empty()) {
      ipControlName = make_shared<string>(boost::any_cast<string>(m["IpControlName"]));
    }
    if (m.find("IpControlType") != m.end() && !m["IpControlType"].empty()) {
      ipControlType = make_shared<string>(boost::any_cast<string>(m["IpControlType"]));
    }
    if (m.find("ModifiedTime") != m.end() && !m["ModifiedTime"].empty()) {
      modifiedTime = make_shared<string>(boost::any_cast<string>(m["ModifiedTime"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DescribeIpControlsResponseBodyIpControlInfosIpControlInfo() = default;
};
class DescribeIpControlsResponseBodyIpControlInfos : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeIpControlsResponseBodyIpControlInfosIpControlInfo>> ipControlInfo{};

  DescribeIpControlsResponseBodyIpControlInfos() {}

  explicit DescribeIpControlsResponseBodyIpControlInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ipControlInfo) {
      vector<boost::any> temp1;
      for(auto item1:*ipControlInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["IpControlInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IpControlInfo") != m.end() && !m["IpControlInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["IpControlInfo"].type()) {
        vector<DescribeIpControlsResponseBodyIpControlInfosIpControlInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["IpControlInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeIpControlsResponseBodyIpControlInfosIpControlInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ipControlInfo = make_shared<vector<DescribeIpControlsResponseBodyIpControlInfosIpControlInfo>>(expect1);
      }
    }
  }


  virtual ~DescribeIpControlsResponseBodyIpControlInfos() = default;
};
class DescribeIpControlsResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeIpControlsResponseBodyIpControlInfos> ipControlInfos{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeIpControlsResponseBody() {}

  explicit DescribeIpControlsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ipControlInfos) {
      res["IpControlInfos"] = ipControlInfos ? boost::any(ipControlInfos->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IpControlInfos") != m.end() && !m["IpControlInfos"].empty()) {
      if (typeid(map<string, boost::any>) == m["IpControlInfos"].type()) {
        DescribeIpControlsResponseBodyIpControlInfos model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["IpControlInfos"]));
        ipControlInfos = make_shared<DescribeIpControlsResponseBodyIpControlInfos>(model1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeIpControlsResponseBody() = default;
};
class DescribeIpControlsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeIpControlsResponseBody> body{};

  DescribeIpControlsResponse() {}

  explicit DescribeIpControlsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeIpControlsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeIpControlsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeIpControlsResponse() = default;
};
class DescribeLogConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> logType{};
  shared_ptr<string> securityToken{};

  DescribeLogConfigRequest() {}

  explicit DescribeLogConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (logType) {
      res["LogType"] = boost::any(*logType);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LogType") != m.end() && !m["LogType"].empty()) {
      logType = make_shared<string>(boost::any_cast<string>(m["LogType"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~DescribeLogConfigRequest() = default;
};
class DescribeLogConfigResponseBodyLogInfosLogInfo : public Darabonba::Model {
public:
  shared_ptr<string> logType{};
  shared_ptr<string> regionId{};
  shared_ptr<string> slsLogStore{};
  shared_ptr<string> slsProject{};

  DescribeLogConfigResponseBodyLogInfosLogInfo() {}

  explicit DescribeLogConfigResponseBodyLogInfosLogInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (logType) {
      res["LogType"] = boost::any(*logType);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (slsLogStore) {
      res["SlsLogStore"] = boost::any(*slsLogStore);
    }
    if (slsProject) {
      res["SlsProject"] = boost::any(*slsProject);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LogType") != m.end() && !m["LogType"].empty()) {
      logType = make_shared<string>(boost::any_cast<string>(m["LogType"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SlsLogStore") != m.end() && !m["SlsLogStore"].empty()) {
      slsLogStore = make_shared<string>(boost::any_cast<string>(m["SlsLogStore"]));
    }
    if (m.find("SlsProject") != m.end() && !m["SlsProject"].empty()) {
      slsProject = make_shared<string>(boost::any_cast<string>(m["SlsProject"]));
    }
  }


  virtual ~DescribeLogConfigResponseBodyLogInfosLogInfo() = default;
};
class DescribeLogConfigResponseBodyLogInfos : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeLogConfigResponseBodyLogInfosLogInfo>> logInfo{};

  DescribeLogConfigResponseBodyLogInfos() {}

  explicit DescribeLogConfigResponseBodyLogInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (logInfo) {
      vector<boost::any> temp1;
      for(auto item1:*logInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["LogInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LogInfo") != m.end() && !m["LogInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["LogInfo"].type()) {
        vector<DescribeLogConfigResponseBodyLogInfosLogInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["LogInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeLogConfigResponseBodyLogInfosLogInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        logInfo = make_shared<vector<DescribeLogConfigResponseBodyLogInfosLogInfo>>(expect1);
      }
    }
  }


  virtual ~DescribeLogConfigResponseBodyLogInfos() = default;
};
class DescribeLogConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeLogConfigResponseBodyLogInfos> logInfos{};
  shared_ptr<string> requestId{};

  DescribeLogConfigResponseBody() {}

  explicit DescribeLogConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (logInfos) {
      res["LogInfos"] = logInfos ? boost::any(logInfos->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LogInfos") != m.end() && !m["LogInfos"].empty()) {
      if (typeid(map<string, boost::any>) == m["LogInfos"].type()) {
        DescribeLogConfigResponseBodyLogInfos model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LogInfos"]));
        logInfos = make_shared<DescribeLogConfigResponseBodyLogInfos>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeLogConfigResponseBody() = default;
};
class DescribeLogConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeLogConfigResponseBody> body{};

  DescribeLogConfigResponse() {}

  explicit DescribeLogConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeLogConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeLogConfigResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeLogConfigResponse() = default;
};
class DescribeMarketRemainsQuotaRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> securityToken{};

  DescribeMarketRemainsQuotaRequest() {}

  explicit DescribeMarketRemainsQuotaRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~DescribeMarketRemainsQuotaRequest() = default;
};
class DescribeMarketRemainsQuotaResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> remainsQuota{};
  shared_ptr<string> requestId{};

  DescribeMarketRemainsQuotaResponseBody() {}

  explicit DescribeMarketRemainsQuotaResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (remainsQuota) {
      res["RemainsQuota"] = boost::any(*remainsQuota);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RemainsQuota") != m.end() && !m["RemainsQuota"].empty()) {
      remainsQuota = make_shared<long>(boost::any_cast<long>(m["RemainsQuota"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeMarketRemainsQuotaResponseBody() = default;
};
class DescribeMarketRemainsQuotaResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeMarketRemainsQuotaResponseBody> body{};

  DescribeMarketRemainsQuotaResponse() {}

  explicit DescribeMarketRemainsQuotaResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeMarketRemainsQuotaResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeMarketRemainsQuotaResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeMarketRemainsQuotaResponse() = default;
};
class DescribeModelsRequest : public Darabonba::Model {
public:
  shared_ptr<string> groupId{};
  shared_ptr<string> modelId{};
  shared_ptr<string> modelName{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};

  DescribeModelsRequest() {}

  explicit DescribeModelsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (modelId) {
      res["ModelId"] = boost::any(*modelId);
    }
    if (modelName) {
      res["ModelName"] = boost::any(*modelName);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("ModelId") != m.end() && !m["ModelId"].empty()) {
      modelId = make_shared<string>(boost::any_cast<string>(m["ModelId"]));
    }
    if (m.find("ModelName") != m.end() && !m["ModelName"].empty()) {
      modelName = make_shared<string>(boost::any_cast<string>(m["ModelName"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~DescribeModelsRequest() = default;
};
class DescribeModelsResponseBodyModelDetailsModelDetail : public Darabonba::Model {
public:
  shared_ptr<string> createdTime{};
  shared_ptr<string> description{};
  shared_ptr<string> groupId{};
  shared_ptr<string> modelId{};
  shared_ptr<string> modelName{};
  shared_ptr<string> modelRef{};
  shared_ptr<string> modifiedTime{};
  shared_ptr<string> schema{};

  DescribeModelsResponseBodyModelDetailsModelDetail() {}

  explicit DescribeModelsResponseBodyModelDetailsModelDetail(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createdTime) {
      res["CreatedTime"] = boost::any(*createdTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (modelId) {
      res["ModelId"] = boost::any(*modelId);
    }
    if (modelName) {
      res["ModelName"] = boost::any(*modelName);
    }
    if (modelRef) {
      res["ModelRef"] = boost::any(*modelRef);
    }
    if (modifiedTime) {
      res["ModifiedTime"] = boost::any(*modifiedTime);
    }
    if (schema) {
      res["Schema"] = boost::any(*schema);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreatedTime") != m.end() && !m["CreatedTime"].empty()) {
      createdTime = make_shared<string>(boost::any_cast<string>(m["CreatedTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("ModelId") != m.end() && !m["ModelId"].empty()) {
      modelId = make_shared<string>(boost::any_cast<string>(m["ModelId"]));
    }
    if (m.find("ModelName") != m.end() && !m["ModelName"].empty()) {
      modelName = make_shared<string>(boost::any_cast<string>(m["ModelName"]));
    }
    if (m.find("ModelRef") != m.end() && !m["ModelRef"].empty()) {
      modelRef = make_shared<string>(boost::any_cast<string>(m["ModelRef"]));
    }
    if (m.find("ModifiedTime") != m.end() && !m["ModifiedTime"].empty()) {
      modifiedTime = make_shared<string>(boost::any_cast<string>(m["ModifiedTime"]));
    }
    if (m.find("Schema") != m.end() && !m["Schema"].empty()) {
      schema = make_shared<string>(boost::any_cast<string>(m["Schema"]));
    }
  }


  virtual ~DescribeModelsResponseBodyModelDetailsModelDetail() = default;
};
class DescribeModelsResponseBodyModelDetails : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeModelsResponseBodyModelDetailsModelDetail>> modelDetail{};

  DescribeModelsResponseBodyModelDetails() {}

  explicit DescribeModelsResponseBodyModelDetails(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (modelDetail) {
      vector<boost::any> temp1;
      for(auto item1:*modelDetail){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ModelDetail"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ModelDetail") != m.end() && !m["ModelDetail"].empty()) {
      if (typeid(vector<boost::any>) == m["ModelDetail"].type()) {
        vector<DescribeModelsResponseBodyModelDetailsModelDetail> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ModelDetail"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeModelsResponseBodyModelDetailsModelDetail model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        modelDetail = make_shared<vector<DescribeModelsResponseBodyModelDetailsModelDetail>>(expect1);
      }
    }
  }


  virtual ~DescribeModelsResponseBodyModelDetails() = default;
};
class DescribeModelsResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeModelsResponseBodyModelDetails> modelDetails{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeModelsResponseBody() {}

  explicit DescribeModelsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (modelDetails) {
      res["ModelDetails"] = modelDetails ? boost::any(modelDetails->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ModelDetails") != m.end() && !m["ModelDetails"].empty()) {
      if (typeid(map<string, boost::any>) == m["ModelDetails"].type()) {
        DescribeModelsResponseBodyModelDetails model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ModelDetails"]));
        modelDetails = make_shared<DescribeModelsResponseBodyModelDetails>(model1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeModelsResponseBody() = default;
};
class DescribeModelsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeModelsResponseBody> body{};

  DescribeModelsResponse() {}

  explicit DescribeModelsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeModelsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeModelsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeModelsResponse() = default;
};
class DescribePluginSchemasRequest : public Darabonba::Model {
public:
  shared_ptr<string> language{};
  shared_ptr<string> securityToken{};

  DescribePluginSchemasRequest() {}

  explicit DescribePluginSchemasRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (language) {
      res["Language"] = boost::any(*language);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Language") != m.end() && !m["Language"].empty()) {
      language = make_shared<string>(boost::any_cast<string>(m["Language"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~DescribePluginSchemasRequest() = default;
};
class DescribePluginSchemasResponseBodyPluginSchemasPluginSchema : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> documentId{};
  shared_ptr<string> name{};
  shared_ptr<bool> supportClassic{};
  shared_ptr<string> title{};

  DescribePluginSchemasResponseBodyPluginSchemasPluginSchema() {}

  explicit DescribePluginSchemasResponseBodyPluginSchemasPluginSchema(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (documentId) {
      res["DocumentId"] = boost::any(*documentId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (supportClassic) {
      res["SupportClassic"] = boost::any(*supportClassic);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DocumentId") != m.end() && !m["DocumentId"].empty()) {
      documentId = make_shared<string>(boost::any_cast<string>(m["DocumentId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("SupportClassic") != m.end() && !m["SupportClassic"].empty()) {
      supportClassic = make_shared<bool>(boost::any_cast<bool>(m["SupportClassic"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
  }


  virtual ~DescribePluginSchemasResponseBodyPluginSchemasPluginSchema() = default;
};
class DescribePluginSchemasResponseBodyPluginSchemas : public Darabonba::Model {
public:
  shared_ptr<vector<DescribePluginSchemasResponseBodyPluginSchemasPluginSchema>> pluginSchema{};

  DescribePluginSchemasResponseBodyPluginSchemas() {}

  explicit DescribePluginSchemasResponseBodyPluginSchemas(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pluginSchema) {
      vector<boost::any> temp1;
      for(auto item1:*pluginSchema){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PluginSchema"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PluginSchema") != m.end() && !m["PluginSchema"].empty()) {
      if (typeid(vector<boost::any>) == m["PluginSchema"].type()) {
        vector<DescribePluginSchemasResponseBodyPluginSchemasPluginSchema> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PluginSchema"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribePluginSchemasResponseBodyPluginSchemasPluginSchema model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        pluginSchema = make_shared<vector<DescribePluginSchemasResponseBodyPluginSchemasPluginSchema>>(expect1);
      }
    }
  }


  virtual ~DescribePluginSchemasResponseBodyPluginSchemas() = default;
};
class DescribePluginSchemasResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribePluginSchemasResponseBodyPluginSchemas> pluginSchemas{};
  shared_ptr<string> requestId{};

  DescribePluginSchemasResponseBody() {}

  explicit DescribePluginSchemasResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pluginSchemas) {
      res["PluginSchemas"] = pluginSchemas ? boost::any(pluginSchemas->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PluginSchemas") != m.end() && !m["PluginSchemas"].empty()) {
      if (typeid(map<string, boost::any>) == m["PluginSchemas"].type()) {
        DescribePluginSchemasResponseBodyPluginSchemas model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PluginSchemas"]));
        pluginSchemas = make_shared<DescribePluginSchemasResponseBodyPluginSchemas>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribePluginSchemasResponseBody() = default;
};
class DescribePluginSchemasResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribePluginSchemasResponseBody> body{};

  DescribePluginSchemasResponse() {}

  explicit DescribePluginSchemasResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribePluginSchemasResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribePluginSchemasResponseBody>(model1);
      }
    }
  }


  virtual ~DescribePluginSchemasResponse() = default;
};
class DescribePluginTemplatesRequest : public Darabonba::Model {
public:
  shared_ptr<string> language{};
  shared_ptr<string> pluginName{};
  shared_ptr<string> securityToken{};

  DescribePluginTemplatesRequest() {}

  explicit DescribePluginTemplatesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (language) {
      res["Language"] = boost::any(*language);
    }
    if (pluginName) {
      res["PluginName"] = boost::any(*pluginName);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Language") != m.end() && !m["Language"].empty()) {
      language = make_shared<string>(boost::any_cast<string>(m["Language"]));
    }
    if (m.find("PluginName") != m.end() && !m["PluginName"].empty()) {
      pluginName = make_shared<string>(boost::any_cast<string>(m["PluginName"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~DescribePluginTemplatesRequest() = default;
};
class DescribePluginTemplatesResponseBodyTemplatesTemplate : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> documentAnchor{};
  shared_ptr<string> documentId{};
  shared_ptr<string> sample{};
  shared_ptr<string> title{};

  DescribePluginTemplatesResponseBodyTemplatesTemplate() {}

  explicit DescribePluginTemplatesResponseBodyTemplatesTemplate(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (documentAnchor) {
      res["DocumentAnchor"] = boost::any(*documentAnchor);
    }
    if (documentId) {
      res["DocumentId"] = boost::any(*documentId);
    }
    if (sample) {
      res["Sample"] = boost::any(*sample);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DocumentAnchor") != m.end() && !m["DocumentAnchor"].empty()) {
      documentAnchor = make_shared<string>(boost::any_cast<string>(m["DocumentAnchor"]));
    }
    if (m.find("DocumentId") != m.end() && !m["DocumentId"].empty()) {
      documentId = make_shared<string>(boost::any_cast<string>(m["DocumentId"]));
    }
    if (m.find("Sample") != m.end() && !m["Sample"].empty()) {
      sample = make_shared<string>(boost::any_cast<string>(m["Sample"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
  }


  virtual ~DescribePluginTemplatesResponseBodyTemplatesTemplate() = default;
};
class DescribePluginTemplatesResponseBodyTemplates : public Darabonba::Model {
public:
  shared_ptr<vector<DescribePluginTemplatesResponseBodyTemplatesTemplate>> template_{};

  DescribePluginTemplatesResponseBodyTemplates() {}

  explicit DescribePluginTemplatesResponseBodyTemplates(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (template_) {
      vector<boost::any> temp1;
      for(auto item1:*template_){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Template"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Template") != m.end() && !m["Template"].empty()) {
      if (typeid(vector<boost::any>) == m["Template"].type()) {
        vector<DescribePluginTemplatesResponseBodyTemplatesTemplate> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Template"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribePluginTemplatesResponseBodyTemplatesTemplate model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        template_ = make_shared<vector<DescribePluginTemplatesResponseBodyTemplatesTemplate>>(expect1);
      }
    }
  }


  virtual ~DescribePluginTemplatesResponseBodyTemplates() = default;
};
class DescribePluginTemplatesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribePluginTemplatesResponseBodyTemplates> templates{};

  DescribePluginTemplatesResponseBody() {}

  explicit DescribePluginTemplatesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (templates) {
      res["Templates"] = templates ? boost::any(templates->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Templates") != m.end() && !m["Templates"].empty()) {
      if (typeid(map<string, boost::any>) == m["Templates"].type()) {
        DescribePluginTemplatesResponseBodyTemplates model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Templates"]));
        templates = make_shared<DescribePluginTemplatesResponseBodyTemplates>(model1);
      }
    }
  }


  virtual ~DescribePluginTemplatesResponseBody() = default;
};
class DescribePluginTemplatesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribePluginTemplatesResponseBody> body{};

  DescribePluginTemplatesResponse() {}

  explicit DescribePluginTemplatesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribePluginTemplatesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribePluginTemplatesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribePluginTemplatesResponse() = default;
};
class DescribePluginsRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  DescribePluginsRequestTag() {}

  explicit DescribePluginsRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribePluginsRequestTag() = default;
};
class DescribePluginsRequest : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> pluginId{};
  shared_ptr<string> pluginName{};
  shared_ptr<string> pluginType{};
  shared_ptr<string> securityToken{};
  shared_ptr<vector<DescribePluginsRequestTag>> tag{};

  DescribePluginsRequest() {}

  explicit DescribePluginsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (pluginId) {
      res["PluginId"] = boost::any(*pluginId);
    }
    if (pluginName) {
      res["PluginName"] = boost::any(*pluginName);
    }
    if (pluginType) {
      res["PluginType"] = boost::any(*pluginType);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("PluginId") != m.end() && !m["PluginId"].empty()) {
      pluginId = make_shared<string>(boost::any_cast<string>(m["PluginId"]));
    }
    if (m.find("PluginName") != m.end() && !m["PluginName"].empty()) {
      pluginName = make_shared<string>(boost::any_cast<string>(m["PluginName"]));
    }
    if (m.find("PluginType") != m.end() && !m["PluginType"].empty()) {
      pluginType = make_shared<string>(boost::any_cast<string>(m["PluginType"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<DescribePluginsRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribePluginsRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<DescribePluginsRequestTag>>(expect1);
      }
    }
  }


  virtual ~DescribePluginsRequest() = default;
};
class DescribePluginsResponseBodyPluginsPluginAttributeTagsTagInfo : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  DescribePluginsResponseBodyPluginsPluginAttributeTagsTagInfo() {}

  explicit DescribePluginsResponseBodyPluginsPluginAttributeTagsTagInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribePluginsResponseBodyPluginsPluginAttributeTagsTagInfo() = default;
};
class DescribePluginsResponseBodyPluginsPluginAttributeTags : public Darabonba::Model {
public:
  shared_ptr<vector<DescribePluginsResponseBodyPluginsPluginAttributeTagsTagInfo>> tagInfo{};

  DescribePluginsResponseBodyPluginsPluginAttributeTags() {}

  explicit DescribePluginsResponseBodyPluginsPluginAttributeTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tagInfo) {
      vector<boost::any> temp1;
      for(auto item1:*tagInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TagInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TagInfo") != m.end() && !m["TagInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["TagInfo"].type()) {
        vector<DescribePluginsResponseBodyPluginsPluginAttributeTagsTagInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TagInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribePluginsResponseBodyPluginsPluginAttributeTagsTagInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tagInfo = make_shared<vector<DescribePluginsResponseBodyPluginsPluginAttributeTagsTagInfo>>(expect1);
      }
    }
  }


  virtual ~DescribePluginsResponseBodyPluginsPluginAttributeTags() = default;
};
class DescribePluginsResponseBodyPluginsPluginAttribute : public Darabonba::Model {
public:
  shared_ptr<string> createdTime{};
  shared_ptr<long> description{};
  shared_ptr<string> modifiedTime{};
  shared_ptr<string> pluginData{};
  shared_ptr<string> pluginId{};
  shared_ptr<string> pluginName{};
  shared_ptr<string> pluginType{};
  shared_ptr<long> regionId{};
  shared_ptr<DescribePluginsResponseBodyPluginsPluginAttributeTags> tags{};

  DescribePluginsResponseBodyPluginsPluginAttribute() {}

  explicit DescribePluginsResponseBodyPluginsPluginAttribute(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createdTime) {
      res["CreatedTime"] = boost::any(*createdTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (modifiedTime) {
      res["ModifiedTime"] = boost::any(*modifiedTime);
    }
    if (pluginData) {
      res["PluginData"] = boost::any(*pluginData);
    }
    if (pluginId) {
      res["PluginId"] = boost::any(*pluginId);
    }
    if (pluginName) {
      res["PluginName"] = boost::any(*pluginName);
    }
    if (pluginType) {
      res["PluginType"] = boost::any(*pluginType);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (tags) {
      res["Tags"] = tags ? boost::any(tags->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreatedTime") != m.end() && !m["CreatedTime"].empty()) {
      createdTime = make_shared<string>(boost::any_cast<string>(m["CreatedTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<long>(boost::any_cast<long>(m["Description"]));
    }
    if (m.find("ModifiedTime") != m.end() && !m["ModifiedTime"].empty()) {
      modifiedTime = make_shared<string>(boost::any_cast<string>(m["ModifiedTime"]));
    }
    if (m.find("PluginData") != m.end() && !m["PluginData"].empty()) {
      pluginData = make_shared<string>(boost::any_cast<string>(m["PluginData"]));
    }
    if (m.find("PluginId") != m.end() && !m["PluginId"].empty()) {
      pluginId = make_shared<string>(boost::any_cast<string>(m["PluginId"]));
    }
    if (m.find("PluginName") != m.end() && !m["PluginName"].empty()) {
      pluginName = make_shared<string>(boost::any_cast<string>(m["PluginName"]));
    }
    if (m.find("PluginType") != m.end() && !m["PluginType"].empty()) {
      pluginType = make_shared<string>(boost::any_cast<string>(m["PluginType"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<long>(boost::any_cast<long>(m["RegionId"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(map<string, boost::any>) == m["Tags"].type()) {
        DescribePluginsResponseBodyPluginsPluginAttributeTags model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Tags"]));
        tags = make_shared<DescribePluginsResponseBodyPluginsPluginAttributeTags>(model1);
      }
    }
  }


  virtual ~DescribePluginsResponseBodyPluginsPluginAttribute() = default;
};
class DescribePluginsResponseBodyPlugins : public Darabonba::Model {
public:
  shared_ptr<vector<DescribePluginsResponseBodyPluginsPluginAttribute>> pluginAttribute{};

  DescribePluginsResponseBodyPlugins() {}

  explicit DescribePluginsResponseBodyPlugins(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pluginAttribute) {
      vector<boost::any> temp1;
      for(auto item1:*pluginAttribute){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PluginAttribute"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PluginAttribute") != m.end() && !m["PluginAttribute"].empty()) {
      if (typeid(vector<boost::any>) == m["PluginAttribute"].type()) {
        vector<DescribePluginsResponseBodyPluginsPluginAttribute> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PluginAttribute"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribePluginsResponseBodyPluginsPluginAttribute model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        pluginAttribute = make_shared<vector<DescribePluginsResponseBodyPluginsPluginAttribute>>(expect1);
      }
    }
  }


  virtual ~DescribePluginsResponseBodyPlugins() = default;
};
class DescribePluginsResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<DescribePluginsResponseBodyPlugins> plugins{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribePluginsResponseBody() {}

  explicit DescribePluginsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (plugins) {
      res["Plugins"] = plugins ? boost::any(plugins->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Plugins") != m.end() && !m["Plugins"].empty()) {
      if (typeid(map<string, boost::any>) == m["Plugins"].type()) {
        DescribePluginsResponseBodyPlugins model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Plugins"]));
        plugins = make_shared<DescribePluginsResponseBodyPlugins>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribePluginsResponseBody() = default;
};
class DescribePluginsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribePluginsResponseBody> body{};

  DescribePluginsResponse() {}

  explicit DescribePluginsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribePluginsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribePluginsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribePluginsResponse() = default;
};
class DescribePluginsByApiRequest : public Darabonba::Model {
public:
  shared_ptr<string> apiId{};
  shared_ptr<string> groupId{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> stageName{};

  DescribePluginsByApiRequest() {}

  explicit DescribePluginsByApiRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiId) {
      res["ApiId"] = boost::any(*apiId);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (stageName) {
      res["StageName"] = boost::any(*stageName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiId") != m.end() && !m["ApiId"].empty()) {
      apiId = make_shared<string>(boost::any_cast<string>(m["ApiId"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("StageName") != m.end() && !m["StageName"].empty()) {
      stageName = make_shared<string>(boost::any_cast<string>(m["StageName"]));
    }
  }


  virtual ~DescribePluginsByApiRequest() = default;
};
class DescribePluginsByApiResponseBodyPluginsPluginAttribute : public Darabonba::Model {
public:
  shared_ptr<string> createdTime{};
  shared_ptr<string> description{};
  shared_ptr<string> modifiedTime{};
  shared_ptr<string> pluginData{};
  shared_ptr<string> pluginId{};
  shared_ptr<string> pluginName{};
  shared_ptr<string> pluginType{};
  shared_ptr<string> regionId{};

  DescribePluginsByApiResponseBodyPluginsPluginAttribute() {}

  explicit DescribePluginsByApiResponseBodyPluginsPluginAttribute(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createdTime) {
      res["CreatedTime"] = boost::any(*createdTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (modifiedTime) {
      res["ModifiedTime"] = boost::any(*modifiedTime);
    }
    if (pluginData) {
      res["PluginData"] = boost::any(*pluginData);
    }
    if (pluginId) {
      res["PluginId"] = boost::any(*pluginId);
    }
    if (pluginName) {
      res["PluginName"] = boost::any(*pluginName);
    }
    if (pluginType) {
      res["PluginType"] = boost::any(*pluginType);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreatedTime") != m.end() && !m["CreatedTime"].empty()) {
      createdTime = make_shared<string>(boost::any_cast<string>(m["CreatedTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("ModifiedTime") != m.end() && !m["ModifiedTime"].empty()) {
      modifiedTime = make_shared<string>(boost::any_cast<string>(m["ModifiedTime"]));
    }
    if (m.find("PluginData") != m.end() && !m["PluginData"].empty()) {
      pluginData = make_shared<string>(boost::any_cast<string>(m["PluginData"]));
    }
    if (m.find("PluginId") != m.end() && !m["PluginId"].empty()) {
      pluginId = make_shared<string>(boost::any_cast<string>(m["PluginId"]));
    }
    if (m.find("PluginName") != m.end() && !m["PluginName"].empty()) {
      pluginName = make_shared<string>(boost::any_cast<string>(m["PluginName"]));
    }
    if (m.find("PluginType") != m.end() && !m["PluginType"].empty()) {
      pluginType = make_shared<string>(boost::any_cast<string>(m["PluginType"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DescribePluginsByApiResponseBodyPluginsPluginAttribute() = default;
};
class DescribePluginsByApiResponseBodyPlugins : public Darabonba::Model {
public:
  shared_ptr<vector<DescribePluginsByApiResponseBodyPluginsPluginAttribute>> pluginAttribute{};

  DescribePluginsByApiResponseBodyPlugins() {}

  explicit DescribePluginsByApiResponseBodyPlugins(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pluginAttribute) {
      vector<boost::any> temp1;
      for(auto item1:*pluginAttribute){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PluginAttribute"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PluginAttribute") != m.end() && !m["PluginAttribute"].empty()) {
      if (typeid(vector<boost::any>) == m["PluginAttribute"].type()) {
        vector<DescribePluginsByApiResponseBodyPluginsPluginAttribute> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PluginAttribute"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribePluginsByApiResponseBodyPluginsPluginAttribute model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        pluginAttribute = make_shared<vector<DescribePluginsByApiResponseBodyPluginsPluginAttribute>>(expect1);
      }
    }
  }


  virtual ~DescribePluginsByApiResponseBodyPlugins() = default;
};
class DescribePluginsByApiResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<DescribePluginsByApiResponseBodyPlugins> plugins{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribePluginsByApiResponseBody() {}

  explicit DescribePluginsByApiResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (plugins) {
      res["Plugins"] = plugins ? boost::any(plugins->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Plugins") != m.end() && !m["Plugins"].empty()) {
      if (typeid(map<string, boost::any>) == m["Plugins"].type()) {
        DescribePluginsByApiResponseBodyPlugins model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Plugins"]));
        plugins = make_shared<DescribePluginsByApiResponseBodyPlugins>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribePluginsByApiResponseBody() = default;
};
class DescribePluginsByApiResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribePluginsByApiResponseBody> body{};

  DescribePluginsByApiResponse() {}

  explicit DescribePluginsByApiResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribePluginsByApiResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribePluginsByApiResponseBody>(model1);
      }
    }
  }


  virtual ~DescribePluginsByApiResponse() = default;
};
class DescribePurchasedApiGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> groupId{};
  shared_ptr<string> securityToken{};

  DescribePurchasedApiGroupRequest() {}

  explicit DescribePurchasedApiGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~DescribePurchasedApiGroupRequest() = default;
};
class DescribePurchasedApiGroupResponseBodyDomainsDomainItem : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};

  DescribePurchasedApiGroupResponseBodyDomainsDomainItem() {}

  explicit DescribePurchasedApiGroupResponseBodyDomainsDomainItem(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
  }


  virtual ~DescribePurchasedApiGroupResponseBodyDomainsDomainItem() = default;
};
class DescribePurchasedApiGroupResponseBodyDomains : public Darabonba::Model {
public:
  shared_ptr<vector<DescribePurchasedApiGroupResponseBodyDomainsDomainItem>> domainItem{};

  DescribePurchasedApiGroupResponseBodyDomains() {}

  explicit DescribePurchasedApiGroupResponseBodyDomains(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainItem) {
      vector<boost::any> temp1;
      for(auto item1:*domainItem){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DomainItem"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainItem") != m.end() && !m["DomainItem"].empty()) {
      if (typeid(vector<boost::any>) == m["DomainItem"].type()) {
        vector<DescribePurchasedApiGroupResponseBodyDomainsDomainItem> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DomainItem"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribePurchasedApiGroupResponseBodyDomainsDomainItem model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        domainItem = make_shared<vector<DescribePurchasedApiGroupResponseBodyDomainsDomainItem>>(expect1);
      }
    }
  }


  virtual ~DescribePurchasedApiGroupResponseBodyDomains() = default;
};
class DescribePurchasedApiGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<DescribePurchasedApiGroupResponseBodyDomains> domains{};
  shared_ptr<string> groupId{};
  shared_ptr<string> groupName{};
  shared_ptr<string> purchasedTime{};
  shared_ptr<string> regionId{};
  shared_ptr<string> requestId{};
  shared_ptr<string> status{};

  DescribePurchasedApiGroupResponseBody() {}

  explicit DescribePurchasedApiGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (domains) {
      res["Domains"] = domains ? boost::any(domains->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (purchasedTime) {
      res["PurchasedTime"] = boost::any(*purchasedTime);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Domains") != m.end() && !m["Domains"].empty()) {
      if (typeid(map<string, boost::any>) == m["Domains"].type()) {
        DescribePurchasedApiGroupResponseBodyDomains model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Domains"]));
        domains = make_shared<DescribePurchasedApiGroupResponseBodyDomains>(model1);
      }
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("PurchasedTime") != m.end() && !m["PurchasedTime"].empty()) {
      purchasedTime = make_shared<string>(boost::any_cast<string>(m["PurchasedTime"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribePurchasedApiGroupResponseBody() = default;
};
class DescribePurchasedApiGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribePurchasedApiGroupResponseBody> body{};

  DescribePurchasedApiGroupResponse() {}

  explicit DescribePurchasedApiGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribePurchasedApiGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribePurchasedApiGroupResponseBody>(model1);
      }
    }
  }


  virtual ~DescribePurchasedApiGroupResponse() = default;
};
class DescribePurchasedApiGroupsRequest : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> securityToken{};

  DescribePurchasedApiGroupsRequest() {}

  explicit DescribePurchasedApiGroupsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~DescribePurchasedApiGroupsRequest() = default;
};
class DescribePurchasedApiGroupsResponseBodyPurchasedApiGroupAttributesPurchasedApiGroupAttribute : public Darabonba::Model {
public:
  shared_ptr<string> billingType{};
  shared_ptr<string> description{};
  shared_ptr<string> expireTime{};
  shared_ptr<string> groupId{};
  shared_ptr<string> groupName{};
  shared_ptr<long> invokeTimesMax{};
  shared_ptr<long> invokeTimesNow{};
  shared_ptr<string> purchasedTime{};
  shared_ptr<string> regionId{};
  shared_ptr<string> status{};

  DescribePurchasedApiGroupsResponseBodyPurchasedApiGroupAttributesPurchasedApiGroupAttribute() {}

  explicit DescribePurchasedApiGroupsResponseBodyPurchasedApiGroupAttributesPurchasedApiGroupAttribute(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (billingType) {
      res["BillingType"] = boost::any(*billingType);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (expireTime) {
      res["ExpireTime"] = boost::any(*expireTime);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (invokeTimesMax) {
      res["InvokeTimesMax"] = boost::any(*invokeTimesMax);
    }
    if (invokeTimesNow) {
      res["InvokeTimesNow"] = boost::any(*invokeTimesNow);
    }
    if (purchasedTime) {
      res["PurchasedTime"] = boost::any(*purchasedTime);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BillingType") != m.end() && !m["BillingType"].empty()) {
      billingType = make_shared<string>(boost::any_cast<string>(m["BillingType"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("ExpireTime") != m.end() && !m["ExpireTime"].empty()) {
      expireTime = make_shared<string>(boost::any_cast<string>(m["ExpireTime"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("InvokeTimesMax") != m.end() && !m["InvokeTimesMax"].empty()) {
      invokeTimesMax = make_shared<long>(boost::any_cast<long>(m["InvokeTimesMax"]));
    }
    if (m.find("InvokeTimesNow") != m.end() && !m["InvokeTimesNow"].empty()) {
      invokeTimesNow = make_shared<long>(boost::any_cast<long>(m["InvokeTimesNow"]));
    }
    if (m.find("PurchasedTime") != m.end() && !m["PurchasedTime"].empty()) {
      purchasedTime = make_shared<string>(boost::any_cast<string>(m["PurchasedTime"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribePurchasedApiGroupsResponseBodyPurchasedApiGroupAttributesPurchasedApiGroupAttribute() = default;
};
class DescribePurchasedApiGroupsResponseBodyPurchasedApiGroupAttributes : public Darabonba::Model {
public:
  shared_ptr<vector<DescribePurchasedApiGroupsResponseBodyPurchasedApiGroupAttributesPurchasedApiGroupAttribute>> purchasedApiGroupAttribute{};

  DescribePurchasedApiGroupsResponseBodyPurchasedApiGroupAttributes() {}

  explicit DescribePurchasedApiGroupsResponseBodyPurchasedApiGroupAttributes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (purchasedApiGroupAttribute) {
      vector<boost::any> temp1;
      for(auto item1:*purchasedApiGroupAttribute){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PurchasedApiGroupAttribute"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PurchasedApiGroupAttribute") != m.end() && !m["PurchasedApiGroupAttribute"].empty()) {
      if (typeid(vector<boost::any>) == m["PurchasedApiGroupAttribute"].type()) {
        vector<DescribePurchasedApiGroupsResponseBodyPurchasedApiGroupAttributesPurchasedApiGroupAttribute> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PurchasedApiGroupAttribute"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribePurchasedApiGroupsResponseBodyPurchasedApiGroupAttributesPurchasedApiGroupAttribute model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        purchasedApiGroupAttribute = make_shared<vector<DescribePurchasedApiGroupsResponseBodyPurchasedApiGroupAttributesPurchasedApiGroupAttribute>>(expect1);
      }
    }
  }


  virtual ~DescribePurchasedApiGroupsResponseBodyPurchasedApiGroupAttributes() = default;
};
class DescribePurchasedApiGroupsResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<DescribePurchasedApiGroupsResponseBodyPurchasedApiGroupAttributes> purchasedApiGroupAttributes{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribePurchasedApiGroupsResponseBody() {}

  explicit DescribePurchasedApiGroupsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (purchasedApiGroupAttributes) {
      res["PurchasedApiGroupAttributes"] = purchasedApiGroupAttributes ? boost::any(purchasedApiGroupAttributes->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("PurchasedApiGroupAttributes") != m.end() && !m["PurchasedApiGroupAttributes"].empty()) {
      if (typeid(map<string, boost::any>) == m["PurchasedApiGroupAttributes"].type()) {
        DescribePurchasedApiGroupsResponseBodyPurchasedApiGroupAttributes model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PurchasedApiGroupAttributes"]));
        purchasedApiGroupAttributes = make_shared<DescribePurchasedApiGroupsResponseBodyPurchasedApiGroupAttributes>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribePurchasedApiGroupsResponseBody() = default;
};
class DescribePurchasedApiGroupsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribePurchasedApiGroupsResponseBody> body{};

  DescribePurchasedApiGroupsResponse() {}

  explicit DescribePurchasedApiGroupsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribePurchasedApiGroupsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribePurchasedApiGroupsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribePurchasedApiGroupsResponse() = default;
};
class DescribePurchasedApisRequest : public Darabonba::Model {
public:
  shared_ptr<string> apiId{};
  shared_ptr<string> apiName{};
  shared_ptr<string> groupId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> stageName{};
  shared_ptr<string> visibility{};

  DescribePurchasedApisRequest() {}

  explicit DescribePurchasedApisRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiId) {
      res["ApiId"] = boost::any(*apiId);
    }
    if (apiName) {
      res["ApiName"] = boost::any(*apiName);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (stageName) {
      res["StageName"] = boost::any(*stageName);
    }
    if (visibility) {
      res["Visibility"] = boost::any(*visibility);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiId") != m.end() && !m["ApiId"].empty()) {
      apiId = make_shared<string>(boost::any_cast<string>(m["ApiId"]));
    }
    if (m.find("ApiName") != m.end() && !m["ApiName"].empty()) {
      apiName = make_shared<string>(boost::any_cast<string>(m["ApiName"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("StageName") != m.end() && !m["StageName"].empty()) {
      stageName = make_shared<string>(boost::any_cast<string>(m["StageName"]));
    }
    if (m.find("Visibility") != m.end() && !m["Visibility"].empty()) {
      visibility = make_shared<string>(boost::any_cast<string>(m["Visibility"]));
    }
  }


  virtual ~DescribePurchasedApisRequest() = default;
};
class DescribePurchasedApisResponseBodyPurchasedApisPurchasedApi : public Darabonba::Model {
public:
  shared_ptr<string> apiId{};
  shared_ptr<string> apiName{};
  shared_ptr<string> deployedTime{};
  shared_ptr<string> description{};
  shared_ptr<string> groupId{};
  shared_ptr<string> groupName{};
  shared_ptr<string> modifiedTime{};
  shared_ptr<string> purchasedTime{};
  shared_ptr<string> regionId{};
  shared_ptr<string> stageName{};
  shared_ptr<string> visibility{};

  DescribePurchasedApisResponseBodyPurchasedApisPurchasedApi() {}

  explicit DescribePurchasedApisResponseBodyPurchasedApisPurchasedApi(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiId) {
      res["ApiId"] = boost::any(*apiId);
    }
    if (apiName) {
      res["ApiName"] = boost::any(*apiName);
    }
    if (deployedTime) {
      res["DeployedTime"] = boost::any(*deployedTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (modifiedTime) {
      res["ModifiedTime"] = boost::any(*modifiedTime);
    }
    if (purchasedTime) {
      res["PurchasedTime"] = boost::any(*purchasedTime);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (stageName) {
      res["StageName"] = boost::any(*stageName);
    }
    if (visibility) {
      res["Visibility"] = boost::any(*visibility);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiId") != m.end() && !m["ApiId"].empty()) {
      apiId = make_shared<string>(boost::any_cast<string>(m["ApiId"]));
    }
    if (m.find("ApiName") != m.end() && !m["ApiName"].empty()) {
      apiName = make_shared<string>(boost::any_cast<string>(m["ApiName"]));
    }
    if (m.find("DeployedTime") != m.end() && !m["DeployedTime"].empty()) {
      deployedTime = make_shared<string>(boost::any_cast<string>(m["DeployedTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("ModifiedTime") != m.end() && !m["ModifiedTime"].empty()) {
      modifiedTime = make_shared<string>(boost::any_cast<string>(m["ModifiedTime"]));
    }
    if (m.find("PurchasedTime") != m.end() && !m["PurchasedTime"].empty()) {
      purchasedTime = make_shared<string>(boost::any_cast<string>(m["PurchasedTime"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("StageName") != m.end() && !m["StageName"].empty()) {
      stageName = make_shared<string>(boost::any_cast<string>(m["StageName"]));
    }
    if (m.find("Visibility") != m.end() && !m["Visibility"].empty()) {
      visibility = make_shared<string>(boost::any_cast<string>(m["Visibility"]));
    }
  }


  virtual ~DescribePurchasedApisResponseBodyPurchasedApisPurchasedApi() = default;
};
class DescribePurchasedApisResponseBodyPurchasedApis : public Darabonba::Model {
public:
  shared_ptr<vector<DescribePurchasedApisResponseBodyPurchasedApisPurchasedApi>> purchasedApi{};

  DescribePurchasedApisResponseBodyPurchasedApis() {}

  explicit DescribePurchasedApisResponseBodyPurchasedApis(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (purchasedApi) {
      vector<boost::any> temp1;
      for(auto item1:*purchasedApi){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PurchasedApi"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PurchasedApi") != m.end() && !m["PurchasedApi"].empty()) {
      if (typeid(vector<boost::any>) == m["PurchasedApi"].type()) {
        vector<DescribePurchasedApisResponseBodyPurchasedApisPurchasedApi> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PurchasedApi"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribePurchasedApisResponseBodyPurchasedApisPurchasedApi model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        purchasedApi = make_shared<vector<DescribePurchasedApisResponseBodyPurchasedApisPurchasedApi>>(expect1);
      }
    }
  }


  virtual ~DescribePurchasedApisResponseBodyPurchasedApis() = default;
};
class DescribePurchasedApisResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<DescribePurchasedApisResponseBodyPurchasedApis> purchasedApis{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribePurchasedApisResponseBody() {}

  explicit DescribePurchasedApisResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (purchasedApis) {
      res["PurchasedApis"] = purchasedApis ? boost::any(purchasedApis->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("PurchasedApis") != m.end() && !m["PurchasedApis"].empty()) {
      if (typeid(map<string, boost::any>) == m["PurchasedApis"].type()) {
        DescribePurchasedApisResponseBodyPurchasedApis model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PurchasedApis"]));
        purchasedApis = make_shared<DescribePurchasedApisResponseBodyPurchasedApis>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribePurchasedApisResponseBody() = default;
};
class DescribePurchasedApisResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribePurchasedApisResponseBody> body{};

  DescribePurchasedApisResponse() {}

  explicit DescribePurchasedApisResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribePurchasedApisResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribePurchasedApisResponseBody>(model1);
      }
    }
  }


  virtual ~DescribePurchasedApisResponse() = default;
};
class DescribeRegionsRequest : public Darabonba::Model {
public:
  shared_ptr<string> language{};
  shared_ptr<string> securityToken{};

  DescribeRegionsRequest() {}

  explicit DescribeRegionsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (language) {
      res["Language"] = boost::any(*language);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Language") != m.end() && !m["Language"].empty()) {
      language = make_shared<string>(boost::any_cast<string>(m["Language"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~DescribeRegionsRequest() = default;
};
class DescribeRegionsResponseBodyRegionsRegion : public Darabonba::Model {
public:
  shared_ptr<string> localName{};
  shared_ptr<string> regionEndpoint{};
  shared_ptr<string> regionId{};

  DescribeRegionsResponseBodyRegionsRegion() {}

  explicit DescribeRegionsResponseBodyRegionsRegion(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (localName) {
      res["LocalName"] = boost::any(*localName);
    }
    if (regionEndpoint) {
      res["RegionEndpoint"] = boost::any(*regionEndpoint);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LocalName") != m.end() && !m["LocalName"].empty()) {
      localName = make_shared<string>(boost::any_cast<string>(m["LocalName"]));
    }
    if (m.find("RegionEndpoint") != m.end() && !m["RegionEndpoint"].empty()) {
      regionEndpoint = make_shared<string>(boost::any_cast<string>(m["RegionEndpoint"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DescribeRegionsResponseBodyRegionsRegion() = default;
};
class DescribeRegionsResponseBodyRegions : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeRegionsResponseBodyRegionsRegion>> region{};

  DescribeRegionsResponseBodyRegions() {}

  explicit DescribeRegionsResponseBodyRegions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (region) {
      vector<boost::any> temp1;
      for(auto item1:*region){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Region"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      if (typeid(vector<boost::any>) == m["Region"].type()) {
        vector<DescribeRegionsResponseBodyRegionsRegion> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Region"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeRegionsResponseBodyRegionsRegion model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        region = make_shared<vector<DescribeRegionsResponseBodyRegionsRegion>>(expect1);
      }
    }
  }


  virtual ~DescribeRegionsResponseBodyRegions() = default;
};
class DescribeRegionsResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeRegionsResponseBodyRegions> regions{};
  shared_ptr<string> requestId{};

  DescribeRegionsResponseBody() {}

  explicit DescribeRegionsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (regions) {
      res["Regions"] = regions ? boost::any(regions->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Regions") != m.end() && !m["Regions"].empty()) {
      if (typeid(map<string, boost::any>) == m["Regions"].type()) {
        DescribeRegionsResponseBodyRegions model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Regions"]));
        regions = make_shared<DescribeRegionsResponseBodyRegions>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeRegionsResponseBody() = default;
};
class DescribeRegionsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeRegionsResponseBody> body{};

  DescribeRegionsResponse() {}

  explicit DescribeRegionsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeRegionsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeRegionsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeRegionsResponse() = default;
};
class DescribeSignaturesRequest : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> signatureId{};
  shared_ptr<string> signatureName{};

  DescribeSignaturesRequest() {}

  explicit DescribeSignaturesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (signatureId) {
      res["SignatureId"] = boost::any(*signatureId);
    }
    if (signatureName) {
      res["SignatureName"] = boost::any(*signatureName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("SignatureId") != m.end() && !m["SignatureId"].empty()) {
      signatureId = make_shared<string>(boost::any_cast<string>(m["SignatureId"]));
    }
    if (m.find("SignatureName") != m.end() && !m["SignatureName"].empty()) {
      signatureName = make_shared<string>(boost::any_cast<string>(m["SignatureName"]));
    }
  }


  virtual ~DescribeSignaturesRequest() = default;
};
class DescribeSignaturesResponseBodySignatureInfosSignatureInfo : public Darabonba::Model {
public:
  shared_ptr<string> createdTime{};
  shared_ptr<string> modifiedTime{};
  shared_ptr<string> regionId{};
  shared_ptr<string> signatureId{};
  shared_ptr<string> signatureKey{};
  shared_ptr<string> signatureName{};
  shared_ptr<string> signatureSecret{};

  DescribeSignaturesResponseBodySignatureInfosSignatureInfo() {}

  explicit DescribeSignaturesResponseBodySignatureInfosSignatureInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createdTime) {
      res["CreatedTime"] = boost::any(*createdTime);
    }
    if (modifiedTime) {
      res["ModifiedTime"] = boost::any(*modifiedTime);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (signatureId) {
      res["SignatureId"] = boost::any(*signatureId);
    }
    if (signatureKey) {
      res["SignatureKey"] = boost::any(*signatureKey);
    }
    if (signatureName) {
      res["SignatureName"] = boost::any(*signatureName);
    }
    if (signatureSecret) {
      res["SignatureSecret"] = boost::any(*signatureSecret);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreatedTime") != m.end() && !m["CreatedTime"].empty()) {
      createdTime = make_shared<string>(boost::any_cast<string>(m["CreatedTime"]));
    }
    if (m.find("ModifiedTime") != m.end() && !m["ModifiedTime"].empty()) {
      modifiedTime = make_shared<string>(boost::any_cast<string>(m["ModifiedTime"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SignatureId") != m.end() && !m["SignatureId"].empty()) {
      signatureId = make_shared<string>(boost::any_cast<string>(m["SignatureId"]));
    }
    if (m.find("SignatureKey") != m.end() && !m["SignatureKey"].empty()) {
      signatureKey = make_shared<string>(boost::any_cast<string>(m["SignatureKey"]));
    }
    if (m.find("SignatureName") != m.end() && !m["SignatureName"].empty()) {
      signatureName = make_shared<string>(boost::any_cast<string>(m["SignatureName"]));
    }
    if (m.find("SignatureSecret") != m.end() && !m["SignatureSecret"].empty()) {
      signatureSecret = make_shared<string>(boost::any_cast<string>(m["SignatureSecret"]));
    }
  }


  virtual ~DescribeSignaturesResponseBodySignatureInfosSignatureInfo() = default;
};
class DescribeSignaturesResponseBodySignatureInfos : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeSignaturesResponseBodySignatureInfosSignatureInfo>> signatureInfo{};

  DescribeSignaturesResponseBodySignatureInfos() {}

  explicit DescribeSignaturesResponseBodySignatureInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (signatureInfo) {
      vector<boost::any> temp1;
      for(auto item1:*signatureInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SignatureInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SignatureInfo") != m.end() && !m["SignatureInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["SignatureInfo"].type()) {
        vector<DescribeSignaturesResponseBodySignatureInfosSignatureInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SignatureInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeSignaturesResponseBodySignatureInfosSignatureInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        signatureInfo = make_shared<vector<DescribeSignaturesResponseBodySignatureInfosSignatureInfo>>(expect1);
      }
    }
  }


  virtual ~DescribeSignaturesResponseBodySignatureInfos() = default;
};
class DescribeSignaturesResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<DescribeSignaturesResponseBodySignatureInfos> signatureInfos{};
  shared_ptr<long> totalCount{};

  DescribeSignaturesResponseBody() {}

  explicit DescribeSignaturesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (signatureInfos) {
      res["SignatureInfos"] = signatureInfos ? boost::any(signatureInfos->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SignatureInfos") != m.end() && !m["SignatureInfos"].empty()) {
      if (typeid(map<string, boost::any>) == m["SignatureInfos"].type()) {
        DescribeSignaturesResponseBodySignatureInfos model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SignatureInfos"]));
        signatureInfos = make_shared<DescribeSignaturesResponseBodySignatureInfos>(model1);
      }
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeSignaturesResponseBody() = default;
};
class DescribeSignaturesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeSignaturesResponseBody> body{};

  DescribeSignaturesResponse() {}

  explicit DescribeSignaturesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeSignaturesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeSignaturesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeSignaturesResponse() = default;
};
class DescribeSignaturesByApiRequest : public Darabonba::Model {
public:
  shared_ptr<string> apiId{};
  shared_ptr<string> groupId{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> stageName{};

  DescribeSignaturesByApiRequest() {}

  explicit DescribeSignaturesByApiRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiId) {
      res["ApiId"] = boost::any(*apiId);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (stageName) {
      res["StageName"] = boost::any(*stageName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiId") != m.end() && !m["ApiId"].empty()) {
      apiId = make_shared<string>(boost::any_cast<string>(m["ApiId"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("StageName") != m.end() && !m["StageName"].empty()) {
      stageName = make_shared<string>(boost::any_cast<string>(m["StageName"]));
    }
  }


  virtual ~DescribeSignaturesByApiRequest() = default;
};
class DescribeSignaturesByApiResponseBodySignaturesSignatureItem : public Darabonba::Model {
public:
  shared_ptr<string> boundTime{};
  shared_ptr<string> signatureId{};
  shared_ptr<string> signatureName{};

  DescribeSignaturesByApiResponseBodySignaturesSignatureItem() {}

  explicit DescribeSignaturesByApiResponseBodySignaturesSignatureItem(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (boundTime) {
      res["BoundTime"] = boost::any(*boundTime);
    }
    if (signatureId) {
      res["SignatureId"] = boost::any(*signatureId);
    }
    if (signatureName) {
      res["SignatureName"] = boost::any(*signatureName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BoundTime") != m.end() && !m["BoundTime"].empty()) {
      boundTime = make_shared<string>(boost::any_cast<string>(m["BoundTime"]));
    }
    if (m.find("SignatureId") != m.end() && !m["SignatureId"].empty()) {
      signatureId = make_shared<string>(boost::any_cast<string>(m["SignatureId"]));
    }
    if (m.find("SignatureName") != m.end() && !m["SignatureName"].empty()) {
      signatureName = make_shared<string>(boost::any_cast<string>(m["SignatureName"]));
    }
  }


  virtual ~DescribeSignaturesByApiResponseBodySignaturesSignatureItem() = default;
};
class DescribeSignaturesByApiResponseBodySignatures : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeSignaturesByApiResponseBodySignaturesSignatureItem>> signatureItem{};

  DescribeSignaturesByApiResponseBodySignatures() {}

  explicit DescribeSignaturesByApiResponseBodySignatures(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (signatureItem) {
      vector<boost::any> temp1;
      for(auto item1:*signatureItem){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SignatureItem"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SignatureItem") != m.end() && !m["SignatureItem"].empty()) {
      if (typeid(vector<boost::any>) == m["SignatureItem"].type()) {
        vector<DescribeSignaturesByApiResponseBodySignaturesSignatureItem> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SignatureItem"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeSignaturesByApiResponseBodySignaturesSignatureItem model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        signatureItem = make_shared<vector<DescribeSignaturesByApiResponseBodySignaturesSignatureItem>>(expect1);
      }
    }
  }


  virtual ~DescribeSignaturesByApiResponseBodySignatures() = default;
};
class DescribeSignaturesByApiResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeSignaturesByApiResponseBodySignatures> signatures{};

  DescribeSignaturesByApiResponseBody() {}

  explicit DescribeSignaturesByApiResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (signatures) {
      res["Signatures"] = signatures ? boost::any(signatures->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Signatures") != m.end() && !m["Signatures"].empty()) {
      if (typeid(map<string, boost::any>) == m["Signatures"].type()) {
        DescribeSignaturesByApiResponseBodySignatures model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Signatures"]));
        signatures = make_shared<DescribeSignaturesByApiResponseBodySignatures>(model1);
      }
    }
  }


  virtual ~DescribeSignaturesByApiResponseBody() = default;
};
class DescribeSignaturesByApiResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeSignaturesByApiResponseBody> body{};

  DescribeSignaturesByApiResponse() {}

  explicit DescribeSignaturesByApiResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeSignaturesByApiResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeSignaturesByApiResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeSignaturesByApiResponse() = default;
};
class DescribeSystemParametersRequest : public Darabonba::Model {
public:
  shared_ptr<string> securityToken{};

  DescribeSystemParametersRequest() {}

  explicit DescribeSystemParametersRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~DescribeSystemParametersRequest() = default;
};
class DescribeSystemParametersResponseBodySystemParamsSystemParamItem : public Darabonba::Model {
public:
  shared_ptr<string> demoValue{};
  shared_ptr<string> description{};
  shared_ptr<string> paramName{};
  shared_ptr<string> paramType{};

  DescribeSystemParametersResponseBodySystemParamsSystemParamItem() {}

  explicit DescribeSystemParametersResponseBodySystemParamsSystemParamItem(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (demoValue) {
      res["DemoValue"] = boost::any(*demoValue);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (paramName) {
      res["ParamName"] = boost::any(*paramName);
    }
    if (paramType) {
      res["ParamType"] = boost::any(*paramType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DemoValue") != m.end() && !m["DemoValue"].empty()) {
      demoValue = make_shared<string>(boost::any_cast<string>(m["DemoValue"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("ParamName") != m.end() && !m["ParamName"].empty()) {
      paramName = make_shared<string>(boost::any_cast<string>(m["ParamName"]));
    }
    if (m.find("ParamType") != m.end() && !m["ParamType"].empty()) {
      paramType = make_shared<string>(boost::any_cast<string>(m["ParamType"]));
    }
  }


  virtual ~DescribeSystemParametersResponseBodySystemParamsSystemParamItem() = default;
};
class DescribeSystemParametersResponseBodySystemParams : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeSystemParametersResponseBodySystemParamsSystemParamItem>> systemParamItem{};

  DescribeSystemParametersResponseBodySystemParams() {}

  explicit DescribeSystemParametersResponseBodySystemParams(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (systemParamItem) {
      vector<boost::any> temp1;
      for(auto item1:*systemParamItem){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SystemParamItem"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SystemParamItem") != m.end() && !m["SystemParamItem"].empty()) {
      if (typeid(vector<boost::any>) == m["SystemParamItem"].type()) {
        vector<DescribeSystemParametersResponseBodySystemParamsSystemParamItem> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SystemParamItem"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeSystemParametersResponseBodySystemParamsSystemParamItem model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        systemParamItem = make_shared<vector<DescribeSystemParametersResponseBodySystemParamsSystemParamItem>>(expect1);
      }
    }
  }


  virtual ~DescribeSystemParametersResponseBodySystemParams() = default;
};
class DescribeSystemParametersResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeSystemParametersResponseBodySystemParams> systemParams{};

  DescribeSystemParametersResponseBody() {}

  explicit DescribeSystemParametersResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (systemParams) {
      res["SystemParams"] = systemParams ? boost::any(systemParams->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SystemParams") != m.end() && !m["SystemParams"].empty()) {
      if (typeid(map<string, boost::any>) == m["SystemParams"].type()) {
        DescribeSystemParametersResponseBodySystemParams model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SystemParams"]));
        systemParams = make_shared<DescribeSystemParametersResponseBodySystemParams>(model1);
      }
    }
  }


  virtual ~DescribeSystemParametersResponseBody() = default;
};
class DescribeSystemParametersResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeSystemParametersResponseBody> body{};

  DescribeSystemParametersResponse() {}

  explicit DescribeSystemParametersResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeSystemParametersResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeSystemParametersResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeSystemParametersResponse() = default;
};
class DescribeTrafficControlsRequest : public Darabonba::Model {
public:
  shared_ptr<string> apiId{};
  shared_ptr<string> groupId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> stageName{};
  shared_ptr<string> trafficControlId{};
  shared_ptr<string> trafficControlName{};

  DescribeTrafficControlsRequest() {}

  explicit DescribeTrafficControlsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiId) {
      res["ApiId"] = boost::any(*apiId);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (stageName) {
      res["StageName"] = boost::any(*stageName);
    }
    if (trafficControlId) {
      res["TrafficControlId"] = boost::any(*trafficControlId);
    }
    if (trafficControlName) {
      res["TrafficControlName"] = boost::any(*trafficControlName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiId") != m.end() && !m["ApiId"].empty()) {
      apiId = make_shared<string>(boost::any_cast<string>(m["ApiId"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("StageName") != m.end() && !m["StageName"].empty()) {
      stageName = make_shared<string>(boost::any_cast<string>(m["StageName"]));
    }
    if (m.find("TrafficControlId") != m.end() && !m["TrafficControlId"].empty()) {
      trafficControlId = make_shared<string>(boost::any_cast<string>(m["TrafficControlId"]));
    }
    if (m.find("TrafficControlName") != m.end() && !m["TrafficControlName"].empty()) {
      trafficControlName = make_shared<string>(boost::any_cast<string>(m["TrafficControlName"]));
    }
  }


  virtual ~DescribeTrafficControlsRequest() = default;
};
class DescribeTrafficControlsResponseBodyTrafficControlsTrafficControlSpecialPoliciesSpecialPolicySpecialsSpecial : public Darabonba::Model {
public:
  shared_ptr<string> specialKey{};
  shared_ptr<long> trafficValue{};

  DescribeTrafficControlsResponseBodyTrafficControlsTrafficControlSpecialPoliciesSpecialPolicySpecialsSpecial() {}

  explicit DescribeTrafficControlsResponseBodyTrafficControlsTrafficControlSpecialPoliciesSpecialPolicySpecialsSpecial(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (specialKey) {
      res["SpecialKey"] = boost::any(*specialKey);
    }
    if (trafficValue) {
      res["TrafficValue"] = boost::any(*trafficValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SpecialKey") != m.end() && !m["SpecialKey"].empty()) {
      specialKey = make_shared<string>(boost::any_cast<string>(m["SpecialKey"]));
    }
    if (m.find("TrafficValue") != m.end() && !m["TrafficValue"].empty()) {
      trafficValue = make_shared<long>(boost::any_cast<long>(m["TrafficValue"]));
    }
  }


  virtual ~DescribeTrafficControlsResponseBodyTrafficControlsTrafficControlSpecialPoliciesSpecialPolicySpecialsSpecial() = default;
};
class DescribeTrafficControlsResponseBodyTrafficControlsTrafficControlSpecialPoliciesSpecialPolicySpecials : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeTrafficControlsResponseBodyTrafficControlsTrafficControlSpecialPoliciesSpecialPolicySpecialsSpecial>> special{};

  DescribeTrafficControlsResponseBodyTrafficControlsTrafficControlSpecialPoliciesSpecialPolicySpecials() {}

  explicit DescribeTrafficControlsResponseBodyTrafficControlsTrafficControlSpecialPoliciesSpecialPolicySpecials(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (special) {
      vector<boost::any> temp1;
      for(auto item1:*special){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Special"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Special") != m.end() && !m["Special"].empty()) {
      if (typeid(vector<boost::any>) == m["Special"].type()) {
        vector<DescribeTrafficControlsResponseBodyTrafficControlsTrafficControlSpecialPoliciesSpecialPolicySpecialsSpecial> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Special"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeTrafficControlsResponseBodyTrafficControlsTrafficControlSpecialPoliciesSpecialPolicySpecialsSpecial model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        special = make_shared<vector<DescribeTrafficControlsResponseBodyTrafficControlsTrafficControlSpecialPoliciesSpecialPolicySpecialsSpecial>>(expect1);
      }
    }
  }


  virtual ~DescribeTrafficControlsResponseBodyTrafficControlsTrafficControlSpecialPoliciesSpecialPolicySpecials() = default;
};
class DescribeTrafficControlsResponseBodyTrafficControlsTrafficControlSpecialPoliciesSpecialPolicy : public Darabonba::Model {
public:
  shared_ptr<string> specialType{};
  shared_ptr<DescribeTrafficControlsResponseBodyTrafficControlsTrafficControlSpecialPoliciesSpecialPolicySpecials> specials{};

  DescribeTrafficControlsResponseBodyTrafficControlsTrafficControlSpecialPoliciesSpecialPolicy() {}

  explicit DescribeTrafficControlsResponseBodyTrafficControlsTrafficControlSpecialPoliciesSpecialPolicy(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (specialType) {
      res["SpecialType"] = boost::any(*specialType);
    }
    if (specials) {
      res["Specials"] = specials ? boost::any(specials->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SpecialType") != m.end() && !m["SpecialType"].empty()) {
      specialType = make_shared<string>(boost::any_cast<string>(m["SpecialType"]));
    }
    if (m.find("Specials") != m.end() && !m["Specials"].empty()) {
      if (typeid(map<string, boost::any>) == m["Specials"].type()) {
        DescribeTrafficControlsResponseBodyTrafficControlsTrafficControlSpecialPoliciesSpecialPolicySpecials model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Specials"]));
        specials = make_shared<DescribeTrafficControlsResponseBodyTrafficControlsTrafficControlSpecialPoliciesSpecialPolicySpecials>(model1);
      }
    }
  }


  virtual ~DescribeTrafficControlsResponseBodyTrafficControlsTrafficControlSpecialPoliciesSpecialPolicy() = default;
};
class DescribeTrafficControlsResponseBodyTrafficControlsTrafficControlSpecialPolicies : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeTrafficControlsResponseBodyTrafficControlsTrafficControlSpecialPoliciesSpecialPolicy>> specialPolicy{};

  DescribeTrafficControlsResponseBodyTrafficControlsTrafficControlSpecialPolicies() {}

  explicit DescribeTrafficControlsResponseBodyTrafficControlsTrafficControlSpecialPolicies(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (specialPolicy) {
      vector<boost::any> temp1;
      for(auto item1:*specialPolicy){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SpecialPolicy"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SpecialPolicy") != m.end() && !m["SpecialPolicy"].empty()) {
      if (typeid(vector<boost::any>) == m["SpecialPolicy"].type()) {
        vector<DescribeTrafficControlsResponseBodyTrafficControlsTrafficControlSpecialPoliciesSpecialPolicy> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SpecialPolicy"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeTrafficControlsResponseBodyTrafficControlsTrafficControlSpecialPoliciesSpecialPolicy model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        specialPolicy = make_shared<vector<DescribeTrafficControlsResponseBodyTrafficControlsTrafficControlSpecialPoliciesSpecialPolicy>>(expect1);
      }
    }
  }


  virtual ~DescribeTrafficControlsResponseBodyTrafficControlsTrafficControlSpecialPolicies() = default;
};
class DescribeTrafficControlsResponseBodyTrafficControlsTrafficControl : public Darabonba::Model {
public:
  shared_ptr<long> apiDefault{};
  shared_ptr<long> appDefault{};
  shared_ptr<string> createdTime{};
  shared_ptr<string> description{};
  shared_ptr<string> modifiedTime{};
  shared_ptr<DescribeTrafficControlsResponseBodyTrafficControlsTrafficControlSpecialPolicies> specialPolicies{};
  shared_ptr<string> trafficControlId{};
  shared_ptr<string> trafficControlName{};
  shared_ptr<string> trafficControlUnit{};
  shared_ptr<long> userDefault{};

  DescribeTrafficControlsResponseBodyTrafficControlsTrafficControl() {}

  explicit DescribeTrafficControlsResponseBodyTrafficControlsTrafficControl(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiDefault) {
      res["ApiDefault"] = boost::any(*apiDefault);
    }
    if (appDefault) {
      res["AppDefault"] = boost::any(*appDefault);
    }
    if (createdTime) {
      res["CreatedTime"] = boost::any(*createdTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (modifiedTime) {
      res["ModifiedTime"] = boost::any(*modifiedTime);
    }
    if (specialPolicies) {
      res["SpecialPolicies"] = specialPolicies ? boost::any(specialPolicies->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (trafficControlId) {
      res["TrafficControlId"] = boost::any(*trafficControlId);
    }
    if (trafficControlName) {
      res["TrafficControlName"] = boost::any(*trafficControlName);
    }
    if (trafficControlUnit) {
      res["TrafficControlUnit"] = boost::any(*trafficControlUnit);
    }
    if (userDefault) {
      res["UserDefault"] = boost::any(*userDefault);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiDefault") != m.end() && !m["ApiDefault"].empty()) {
      apiDefault = make_shared<long>(boost::any_cast<long>(m["ApiDefault"]));
    }
    if (m.find("AppDefault") != m.end() && !m["AppDefault"].empty()) {
      appDefault = make_shared<long>(boost::any_cast<long>(m["AppDefault"]));
    }
    if (m.find("CreatedTime") != m.end() && !m["CreatedTime"].empty()) {
      createdTime = make_shared<string>(boost::any_cast<string>(m["CreatedTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("ModifiedTime") != m.end() && !m["ModifiedTime"].empty()) {
      modifiedTime = make_shared<string>(boost::any_cast<string>(m["ModifiedTime"]));
    }
    if (m.find("SpecialPolicies") != m.end() && !m["SpecialPolicies"].empty()) {
      if (typeid(map<string, boost::any>) == m["SpecialPolicies"].type()) {
        DescribeTrafficControlsResponseBodyTrafficControlsTrafficControlSpecialPolicies model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SpecialPolicies"]));
        specialPolicies = make_shared<DescribeTrafficControlsResponseBodyTrafficControlsTrafficControlSpecialPolicies>(model1);
      }
    }
    if (m.find("TrafficControlId") != m.end() && !m["TrafficControlId"].empty()) {
      trafficControlId = make_shared<string>(boost::any_cast<string>(m["TrafficControlId"]));
    }
    if (m.find("TrafficControlName") != m.end() && !m["TrafficControlName"].empty()) {
      trafficControlName = make_shared<string>(boost::any_cast<string>(m["TrafficControlName"]));
    }
    if (m.find("TrafficControlUnit") != m.end() && !m["TrafficControlUnit"].empty()) {
      trafficControlUnit = make_shared<string>(boost::any_cast<string>(m["TrafficControlUnit"]));
    }
    if (m.find("UserDefault") != m.end() && !m["UserDefault"].empty()) {
      userDefault = make_shared<long>(boost::any_cast<long>(m["UserDefault"]));
    }
  }


  virtual ~DescribeTrafficControlsResponseBodyTrafficControlsTrafficControl() = default;
};
class DescribeTrafficControlsResponseBodyTrafficControls : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeTrafficControlsResponseBodyTrafficControlsTrafficControl>> trafficControl{};

  DescribeTrafficControlsResponseBodyTrafficControls() {}

  explicit DescribeTrafficControlsResponseBodyTrafficControls(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (trafficControl) {
      vector<boost::any> temp1;
      for(auto item1:*trafficControl){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TrafficControl"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TrafficControl") != m.end() && !m["TrafficControl"].empty()) {
      if (typeid(vector<boost::any>) == m["TrafficControl"].type()) {
        vector<DescribeTrafficControlsResponseBodyTrafficControlsTrafficControl> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TrafficControl"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeTrafficControlsResponseBodyTrafficControlsTrafficControl model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        trafficControl = make_shared<vector<DescribeTrafficControlsResponseBodyTrafficControlsTrafficControl>>(expect1);
      }
    }
  }


  virtual ~DescribeTrafficControlsResponseBodyTrafficControls() = default;
};
class DescribeTrafficControlsResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};
  shared_ptr<DescribeTrafficControlsResponseBodyTrafficControls> trafficControls{};

  DescribeTrafficControlsResponseBody() {}

  explicit DescribeTrafficControlsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (trafficControls) {
      res["TrafficControls"] = trafficControls ? boost::any(trafficControls->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("TrafficControls") != m.end() && !m["TrafficControls"].empty()) {
      if (typeid(map<string, boost::any>) == m["TrafficControls"].type()) {
        DescribeTrafficControlsResponseBodyTrafficControls model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TrafficControls"]));
        trafficControls = make_shared<DescribeTrafficControlsResponseBodyTrafficControls>(model1);
      }
    }
  }


  virtual ~DescribeTrafficControlsResponseBody() = default;
};
class DescribeTrafficControlsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeTrafficControlsResponseBody> body{};

  DescribeTrafficControlsResponse() {}

  explicit DescribeTrafficControlsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeTrafficControlsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeTrafficControlsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeTrafficControlsResponse() = default;
};
class DescribeTrafficControlsByApiRequest : public Darabonba::Model {
public:
  shared_ptr<string> apiId{};
  shared_ptr<string> groupId{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> stageName{};

  DescribeTrafficControlsByApiRequest() {}

  explicit DescribeTrafficControlsByApiRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiId) {
      res["ApiId"] = boost::any(*apiId);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (stageName) {
      res["StageName"] = boost::any(*stageName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiId") != m.end() && !m["ApiId"].empty()) {
      apiId = make_shared<string>(boost::any_cast<string>(m["ApiId"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("StageName") != m.end() && !m["StageName"].empty()) {
      stageName = make_shared<string>(boost::any_cast<string>(m["StageName"]));
    }
  }


  virtual ~DescribeTrafficControlsByApiRequest() = default;
};
class DescribeTrafficControlsByApiResponseBodyTrafficControlItemsTrafficControlItem : public Darabonba::Model {
public:
  shared_ptr<string> boundTime{};
  shared_ptr<string> trafficControlItemId{};
  shared_ptr<string> trafficControlItemName{};

  DescribeTrafficControlsByApiResponseBodyTrafficControlItemsTrafficControlItem() {}

  explicit DescribeTrafficControlsByApiResponseBodyTrafficControlItemsTrafficControlItem(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (boundTime) {
      res["BoundTime"] = boost::any(*boundTime);
    }
    if (trafficControlItemId) {
      res["TrafficControlItemId"] = boost::any(*trafficControlItemId);
    }
    if (trafficControlItemName) {
      res["TrafficControlItemName"] = boost::any(*trafficControlItemName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BoundTime") != m.end() && !m["BoundTime"].empty()) {
      boundTime = make_shared<string>(boost::any_cast<string>(m["BoundTime"]));
    }
    if (m.find("TrafficControlItemId") != m.end() && !m["TrafficControlItemId"].empty()) {
      trafficControlItemId = make_shared<string>(boost::any_cast<string>(m["TrafficControlItemId"]));
    }
    if (m.find("TrafficControlItemName") != m.end() && !m["TrafficControlItemName"].empty()) {
      trafficControlItemName = make_shared<string>(boost::any_cast<string>(m["TrafficControlItemName"]));
    }
  }


  virtual ~DescribeTrafficControlsByApiResponseBodyTrafficControlItemsTrafficControlItem() = default;
};
class DescribeTrafficControlsByApiResponseBodyTrafficControlItems : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeTrafficControlsByApiResponseBodyTrafficControlItemsTrafficControlItem>> trafficControlItem{};

  DescribeTrafficControlsByApiResponseBodyTrafficControlItems() {}

  explicit DescribeTrafficControlsByApiResponseBodyTrafficControlItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (trafficControlItem) {
      vector<boost::any> temp1;
      for(auto item1:*trafficControlItem){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TrafficControlItem"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TrafficControlItem") != m.end() && !m["TrafficControlItem"].empty()) {
      if (typeid(vector<boost::any>) == m["TrafficControlItem"].type()) {
        vector<DescribeTrafficControlsByApiResponseBodyTrafficControlItemsTrafficControlItem> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TrafficControlItem"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeTrafficControlsByApiResponseBodyTrafficControlItemsTrafficControlItem model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        trafficControlItem = make_shared<vector<DescribeTrafficControlsByApiResponseBodyTrafficControlItemsTrafficControlItem>>(expect1);
      }
    }
  }


  virtual ~DescribeTrafficControlsByApiResponseBodyTrafficControlItems() = default;
};
class DescribeTrafficControlsByApiResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeTrafficControlsByApiResponseBodyTrafficControlItems> trafficControlItems{};

  DescribeTrafficControlsByApiResponseBody() {}

  explicit DescribeTrafficControlsByApiResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (trafficControlItems) {
      res["TrafficControlItems"] = trafficControlItems ? boost::any(trafficControlItems->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TrafficControlItems") != m.end() && !m["TrafficControlItems"].empty()) {
      if (typeid(map<string, boost::any>) == m["TrafficControlItems"].type()) {
        DescribeTrafficControlsByApiResponseBodyTrafficControlItems model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TrafficControlItems"]));
        trafficControlItems = make_shared<DescribeTrafficControlsByApiResponseBodyTrafficControlItems>(model1);
      }
    }
  }


  virtual ~DescribeTrafficControlsByApiResponseBody() = default;
};
class DescribeTrafficControlsByApiResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeTrafficControlsByApiResponseBody> body{};

  DescribeTrafficControlsByApiResponse() {}

  explicit DescribeTrafficControlsByApiResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeTrafficControlsByApiResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeTrafficControlsByApiResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeTrafficControlsByApiResponse() = default;
};
class DescribeUpdateVpcInfoTaskRequest : public Darabonba::Model {
public:
  shared_ptr<string> operationUid{};
  shared_ptr<string> securityToken{};

  DescribeUpdateVpcInfoTaskRequest() {}

  explicit DescribeUpdateVpcInfoTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (operationUid) {
      res["OperationUid"] = boost::any(*operationUid);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OperationUid") != m.end() && !m["OperationUid"].empty()) {
      operationUid = make_shared<string>(boost::any_cast<string>(m["OperationUid"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~DescribeUpdateVpcInfoTaskRequest() = default;
};
class DescribeUpdateVpcInfoTaskResponseBodyApiUpdateVpcInfoResultsApiUpdateVpcInfoResult : public Darabonba::Model {
public:
  shared_ptr<string> apiName{};
  shared_ptr<string> apiUid{};
  shared_ptr<string> errorMsg{};
  shared_ptr<string> groupId{};
  shared_ptr<string> groupName{};
  shared_ptr<string> stageId{};
  shared_ptr<string> stageName{};
  shared_ptr<string> updateStatus{};

  DescribeUpdateVpcInfoTaskResponseBodyApiUpdateVpcInfoResultsApiUpdateVpcInfoResult() {}

  explicit DescribeUpdateVpcInfoTaskResponseBodyApiUpdateVpcInfoResultsApiUpdateVpcInfoResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiName) {
      res["ApiName"] = boost::any(*apiName);
    }
    if (apiUid) {
      res["ApiUid"] = boost::any(*apiUid);
    }
    if (errorMsg) {
      res["ErrorMsg"] = boost::any(*errorMsg);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (stageId) {
      res["StageId"] = boost::any(*stageId);
    }
    if (stageName) {
      res["StageName"] = boost::any(*stageName);
    }
    if (updateStatus) {
      res["UpdateStatus"] = boost::any(*updateStatus);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiName") != m.end() && !m["ApiName"].empty()) {
      apiName = make_shared<string>(boost::any_cast<string>(m["ApiName"]));
    }
    if (m.find("ApiUid") != m.end() && !m["ApiUid"].empty()) {
      apiUid = make_shared<string>(boost::any_cast<string>(m["ApiUid"]));
    }
    if (m.find("ErrorMsg") != m.end() && !m["ErrorMsg"].empty()) {
      errorMsg = make_shared<string>(boost::any_cast<string>(m["ErrorMsg"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("StageId") != m.end() && !m["StageId"].empty()) {
      stageId = make_shared<string>(boost::any_cast<string>(m["StageId"]));
    }
    if (m.find("StageName") != m.end() && !m["StageName"].empty()) {
      stageName = make_shared<string>(boost::any_cast<string>(m["StageName"]));
    }
    if (m.find("UpdateStatus") != m.end() && !m["UpdateStatus"].empty()) {
      updateStatus = make_shared<string>(boost::any_cast<string>(m["UpdateStatus"]));
    }
  }


  virtual ~DescribeUpdateVpcInfoTaskResponseBodyApiUpdateVpcInfoResultsApiUpdateVpcInfoResult() = default;
};
class DescribeUpdateVpcInfoTaskResponseBodyApiUpdateVpcInfoResults : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeUpdateVpcInfoTaskResponseBodyApiUpdateVpcInfoResultsApiUpdateVpcInfoResult>> apiUpdateVpcInfoResult{};

  DescribeUpdateVpcInfoTaskResponseBodyApiUpdateVpcInfoResults() {}

  explicit DescribeUpdateVpcInfoTaskResponseBodyApiUpdateVpcInfoResults(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiUpdateVpcInfoResult) {
      vector<boost::any> temp1;
      for(auto item1:*apiUpdateVpcInfoResult){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ApiUpdateVpcInfoResult"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiUpdateVpcInfoResult") != m.end() && !m["ApiUpdateVpcInfoResult"].empty()) {
      if (typeid(vector<boost::any>) == m["ApiUpdateVpcInfoResult"].type()) {
        vector<DescribeUpdateVpcInfoTaskResponseBodyApiUpdateVpcInfoResultsApiUpdateVpcInfoResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ApiUpdateVpcInfoResult"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeUpdateVpcInfoTaskResponseBodyApiUpdateVpcInfoResultsApiUpdateVpcInfoResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        apiUpdateVpcInfoResult = make_shared<vector<DescribeUpdateVpcInfoTaskResponseBodyApiUpdateVpcInfoResultsApiUpdateVpcInfoResult>>(expect1);
      }
    }
  }


  virtual ~DescribeUpdateVpcInfoTaskResponseBodyApiUpdateVpcInfoResults() = default;
};
class DescribeUpdateVpcInfoTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeUpdateVpcInfoTaskResponseBodyApiUpdateVpcInfoResults> apiUpdateVpcInfoResults{};
  shared_ptr<string> requestId{};

  DescribeUpdateVpcInfoTaskResponseBody() {}

  explicit DescribeUpdateVpcInfoTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiUpdateVpcInfoResults) {
      res["ApiUpdateVpcInfoResults"] = apiUpdateVpcInfoResults ? boost::any(apiUpdateVpcInfoResults->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiUpdateVpcInfoResults") != m.end() && !m["ApiUpdateVpcInfoResults"].empty()) {
      if (typeid(map<string, boost::any>) == m["ApiUpdateVpcInfoResults"].type()) {
        DescribeUpdateVpcInfoTaskResponseBodyApiUpdateVpcInfoResults model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ApiUpdateVpcInfoResults"]));
        apiUpdateVpcInfoResults = make_shared<DescribeUpdateVpcInfoTaskResponseBodyApiUpdateVpcInfoResults>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeUpdateVpcInfoTaskResponseBody() = default;
};
class DescribeUpdateVpcInfoTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeUpdateVpcInfoTaskResponseBody> body{};

  DescribeUpdateVpcInfoTaskResponse() {}

  explicit DescribeUpdateVpcInfoTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeUpdateVpcInfoTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeUpdateVpcInfoTaskResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeUpdateVpcInfoTaskResponse() = default;
};
class DescribeVpcAccessesRequest : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> vpcAccessId{};

  DescribeVpcAccessesRequest() {}

  explicit DescribeVpcAccessesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (vpcAccessId) {
      res["VpcAccessId"] = boost::any(*vpcAccessId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("VpcAccessId") != m.end() && !m["VpcAccessId"].empty()) {
      vpcAccessId = make_shared<string>(boost::any_cast<string>(m["VpcAccessId"]));
    }
  }


  virtual ~DescribeVpcAccessesRequest() = default;
};
class DescribeVpcAccessesResponseBodyVpcAccessAttributesVpcAccessAttribute : public Darabonba::Model {
public:
  shared_ptr<string> createdTime{};
  shared_ptr<string> description{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> name{};
  shared_ptr<long> port{};
  shared_ptr<string> regionId{};
  shared_ptr<string> vpcAccessId{};
  shared_ptr<string> vpcId{};

  DescribeVpcAccessesResponseBodyVpcAccessAttributesVpcAccessAttribute() {}

  explicit DescribeVpcAccessesResponseBodyVpcAccessAttributesVpcAccessAttribute(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createdTime) {
      res["CreatedTime"] = boost::any(*createdTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (vpcAccessId) {
      res["VpcAccessId"] = boost::any(*vpcAccessId);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreatedTime") != m.end() && !m["CreatedTime"].empty()) {
      createdTime = make_shared<string>(boost::any_cast<string>(m["CreatedTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<long>(boost::any_cast<long>(m["Port"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("VpcAccessId") != m.end() && !m["VpcAccessId"].empty()) {
      vpcAccessId = make_shared<string>(boost::any_cast<string>(m["VpcAccessId"]));
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
  }


  virtual ~DescribeVpcAccessesResponseBodyVpcAccessAttributesVpcAccessAttribute() = default;
};
class DescribeVpcAccessesResponseBodyVpcAccessAttributes : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeVpcAccessesResponseBodyVpcAccessAttributesVpcAccessAttribute>> vpcAccessAttribute{};

  DescribeVpcAccessesResponseBodyVpcAccessAttributes() {}

  explicit DescribeVpcAccessesResponseBodyVpcAccessAttributes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (vpcAccessAttribute) {
      vector<boost::any> temp1;
      for(auto item1:*vpcAccessAttribute){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["VpcAccessAttribute"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("VpcAccessAttribute") != m.end() && !m["VpcAccessAttribute"].empty()) {
      if (typeid(vector<boost::any>) == m["VpcAccessAttribute"].type()) {
        vector<DescribeVpcAccessesResponseBodyVpcAccessAttributesVpcAccessAttribute> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["VpcAccessAttribute"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeVpcAccessesResponseBodyVpcAccessAttributesVpcAccessAttribute model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        vpcAccessAttribute = make_shared<vector<DescribeVpcAccessesResponseBodyVpcAccessAttributesVpcAccessAttribute>>(expect1);
      }
    }
  }


  virtual ~DescribeVpcAccessesResponseBodyVpcAccessAttributes() = default;
};
class DescribeVpcAccessesResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};
  shared_ptr<DescribeVpcAccessesResponseBodyVpcAccessAttributes> vpcAccessAttributes{};

  DescribeVpcAccessesResponseBody() {}

  explicit DescribeVpcAccessesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (vpcAccessAttributes) {
      res["VpcAccessAttributes"] = vpcAccessAttributes ? boost::any(vpcAccessAttributes->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("VpcAccessAttributes") != m.end() && !m["VpcAccessAttributes"].empty()) {
      if (typeid(map<string, boost::any>) == m["VpcAccessAttributes"].type()) {
        DescribeVpcAccessesResponseBodyVpcAccessAttributes model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["VpcAccessAttributes"]));
        vpcAccessAttributes = make_shared<DescribeVpcAccessesResponseBodyVpcAccessAttributes>(model1);
      }
    }
  }


  virtual ~DescribeVpcAccessesResponseBody() = default;
};
class DescribeVpcAccessesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeVpcAccessesResponseBody> body{};

  DescribeVpcAccessesResponse() {}

  explicit DescribeVpcAccessesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeVpcAccessesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeVpcAccessesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeVpcAccessesResponse() = default;
};
class DescribeZonesRequest : public Darabonba::Model {
public:
  shared_ptr<string> language{};
  shared_ptr<string> securityToken{};

  DescribeZonesRequest() {}

  explicit DescribeZonesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (language) {
      res["Language"] = boost::any(*language);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Language") != m.end() && !m["Language"].empty()) {
      language = make_shared<string>(boost::any_cast<string>(m["Language"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~DescribeZonesRequest() = default;
};
class DescribeZonesResponseBodyZonesZone : public Darabonba::Model {
public:
  shared_ptr<string> localName{};
  shared_ptr<string> zoneId{};

  DescribeZonesResponseBodyZonesZone() {}

  explicit DescribeZonesResponseBodyZonesZone(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (localName) {
      res["LocalName"] = boost::any(*localName);
    }
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LocalName") != m.end() && !m["LocalName"].empty()) {
      localName = make_shared<string>(boost::any_cast<string>(m["LocalName"]));
    }
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["ZoneId"]));
    }
  }


  virtual ~DescribeZonesResponseBodyZonesZone() = default;
};
class DescribeZonesResponseBodyZones : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeZonesResponseBodyZonesZone>> zone{};

  DescribeZonesResponseBodyZones() {}

  explicit DescribeZonesResponseBodyZones(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (zone) {
      vector<boost::any> temp1;
      for(auto item1:*zone){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Zone"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Zone") != m.end() && !m["Zone"].empty()) {
      if (typeid(vector<boost::any>) == m["Zone"].type()) {
        vector<DescribeZonesResponseBodyZonesZone> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Zone"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeZonesResponseBodyZonesZone model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        zone = make_shared<vector<DescribeZonesResponseBodyZonesZone>>(expect1);
      }
    }
  }


  virtual ~DescribeZonesResponseBodyZones() = default;
};
class DescribeZonesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeZonesResponseBodyZones> zones{};

  DescribeZonesResponseBody() {}

  explicit DescribeZonesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (zones) {
      res["Zones"] = zones ? boost::any(zones->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Zones") != m.end() && !m["Zones"].empty()) {
      if (typeid(map<string, boost::any>) == m["Zones"].type()) {
        DescribeZonesResponseBodyZones model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Zones"]));
        zones = make_shared<DescribeZonesResponseBodyZones>(model1);
      }
    }
  }


  virtual ~DescribeZonesResponseBody() = default;
};
class DescribeZonesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeZonesResponseBody> body{};

  DescribeZonesResponse() {}

  explicit DescribeZonesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeZonesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeZonesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeZonesResponse() = default;
};
class DryRunSwaggerRequest : public Darabonba::Model {
public:
  shared_ptr<string> data{};
  shared_ptr<string> dataFormat{};
  shared_ptr<map<string, boost::any>> globalCondition{};
  shared_ptr<string> groupId{};
  shared_ptr<bool> overwrite{};
  shared_ptr<string> securityToken{};

  DryRunSwaggerRequest() {}

  explicit DryRunSwaggerRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (dataFormat) {
      res["DataFormat"] = boost::any(*dataFormat);
    }
    if (globalCondition) {
      res["GlobalCondition"] = boost::any(*globalCondition);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (overwrite) {
      res["Overwrite"] = boost::any(*overwrite);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("DataFormat") != m.end() && !m["DataFormat"].empty()) {
      dataFormat = make_shared<string>(boost::any_cast<string>(m["DataFormat"]));
    }
    if (m.find("GlobalCondition") != m.end() && !m["GlobalCondition"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["GlobalCondition"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      globalCondition = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("Overwrite") != m.end() && !m["Overwrite"].empty()) {
      overwrite = make_shared<bool>(boost::any_cast<bool>(m["Overwrite"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~DryRunSwaggerRequest() = default;
};
class DryRunSwaggerShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> data{};
  shared_ptr<string> dataFormat{};
  shared_ptr<string> globalConditionShrink{};
  shared_ptr<string> groupId{};
  shared_ptr<bool> overwrite{};
  shared_ptr<string> securityToken{};

  DryRunSwaggerShrinkRequest() {}

  explicit DryRunSwaggerShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (dataFormat) {
      res["DataFormat"] = boost::any(*dataFormat);
    }
    if (globalConditionShrink) {
      res["GlobalCondition"] = boost::any(*globalConditionShrink);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (overwrite) {
      res["Overwrite"] = boost::any(*overwrite);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("DataFormat") != m.end() && !m["DataFormat"].empty()) {
      dataFormat = make_shared<string>(boost::any_cast<string>(m["DataFormat"]));
    }
    if (m.find("GlobalCondition") != m.end() && !m["GlobalCondition"].empty()) {
      globalConditionShrink = make_shared<string>(boost::any_cast<string>(m["GlobalCondition"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("Overwrite") != m.end() && !m["Overwrite"].empty()) {
      overwrite = make_shared<bool>(boost::any_cast<bool>(m["Overwrite"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~DryRunSwaggerShrinkRequest() = default;
};
class DryRunSwaggerResponseBodyFailedApiImportSwaggerFailed : public Darabonba::Model {
public:
  shared_ptr<string> errorMsg{};
  shared_ptr<string> httpMethod{};
  shared_ptr<string> path{};

  DryRunSwaggerResponseBodyFailedApiImportSwaggerFailed() {}

  explicit DryRunSwaggerResponseBodyFailedApiImportSwaggerFailed(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorMsg) {
      res["ErrorMsg"] = boost::any(*errorMsg);
    }
    if (httpMethod) {
      res["HttpMethod"] = boost::any(*httpMethod);
    }
    if (path) {
      res["Path"] = boost::any(*path);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorMsg") != m.end() && !m["ErrorMsg"].empty()) {
      errorMsg = make_shared<string>(boost::any_cast<string>(m["ErrorMsg"]));
    }
    if (m.find("HttpMethod") != m.end() && !m["HttpMethod"].empty()) {
      httpMethod = make_shared<string>(boost::any_cast<string>(m["HttpMethod"]));
    }
    if (m.find("Path") != m.end() && !m["Path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["Path"]));
    }
  }


  virtual ~DryRunSwaggerResponseBodyFailedApiImportSwaggerFailed() = default;
};
class DryRunSwaggerResponseBodyFailed : public Darabonba::Model {
public:
  shared_ptr<vector<DryRunSwaggerResponseBodyFailedApiImportSwaggerFailed>> apiImportSwaggerFailed{};

  DryRunSwaggerResponseBodyFailed() {}

  explicit DryRunSwaggerResponseBodyFailed(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiImportSwaggerFailed) {
      vector<boost::any> temp1;
      for(auto item1:*apiImportSwaggerFailed){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ApiImportSwaggerFailed"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiImportSwaggerFailed") != m.end() && !m["ApiImportSwaggerFailed"].empty()) {
      if (typeid(vector<boost::any>) == m["ApiImportSwaggerFailed"].type()) {
        vector<DryRunSwaggerResponseBodyFailedApiImportSwaggerFailed> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ApiImportSwaggerFailed"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DryRunSwaggerResponseBodyFailedApiImportSwaggerFailed model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        apiImportSwaggerFailed = make_shared<vector<DryRunSwaggerResponseBodyFailedApiImportSwaggerFailed>>(expect1);
      }
    }
  }


  virtual ~DryRunSwaggerResponseBodyFailed() = default;
};
class DryRunSwaggerResponseBodyModelFailedApiImportModelFailed : public Darabonba::Model {
public:
  shared_ptr<string> errorMsg{};
  shared_ptr<string> groupId{};
  shared_ptr<string> modelName{};

  DryRunSwaggerResponseBodyModelFailedApiImportModelFailed() {}

  explicit DryRunSwaggerResponseBodyModelFailedApiImportModelFailed(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorMsg) {
      res["ErrorMsg"] = boost::any(*errorMsg);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (modelName) {
      res["ModelName"] = boost::any(*modelName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorMsg") != m.end() && !m["ErrorMsg"].empty()) {
      errorMsg = make_shared<string>(boost::any_cast<string>(m["ErrorMsg"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("ModelName") != m.end() && !m["ModelName"].empty()) {
      modelName = make_shared<string>(boost::any_cast<string>(m["ModelName"]));
    }
  }


  virtual ~DryRunSwaggerResponseBodyModelFailedApiImportModelFailed() = default;
};
class DryRunSwaggerResponseBodyModelFailed : public Darabonba::Model {
public:
  shared_ptr<vector<DryRunSwaggerResponseBodyModelFailedApiImportModelFailed>> apiImportModelFailed{};

  DryRunSwaggerResponseBodyModelFailed() {}

  explicit DryRunSwaggerResponseBodyModelFailed(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiImportModelFailed) {
      vector<boost::any> temp1;
      for(auto item1:*apiImportModelFailed){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ApiImportModelFailed"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiImportModelFailed") != m.end() && !m["ApiImportModelFailed"].empty()) {
      if (typeid(vector<boost::any>) == m["ApiImportModelFailed"].type()) {
        vector<DryRunSwaggerResponseBodyModelFailedApiImportModelFailed> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ApiImportModelFailed"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DryRunSwaggerResponseBodyModelFailedApiImportModelFailed model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        apiImportModelFailed = make_shared<vector<DryRunSwaggerResponseBodyModelFailedApiImportModelFailed>>(expect1);
      }
    }
  }


  virtual ~DryRunSwaggerResponseBodyModelFailed() = default;
};
class DryRunSwaggerResponseBodyModelSuccessApiImportModelSuccess : public Darabonba::Model {
public:
  shared_ptr<string> groupId{};
  shared_ptr<string> modelName{};
  shared_ptr<string> modelOperation{};
  shared_ptr<string> modelUid{};

  DryRunSwaggerResponseBodyModelSuccessApiImportModelSuccess() {}

  explicit DryRunSwaggerResponseBodyModelSuccessApiImportModelSuccess(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (modelName) {
      res["ModelName"] = boost::any(*modelName);
    }
    if (modelOperation) {
      res["ModelOperation"] = boost::any(*modelOperation);
    }
    if (modelUid) {
      res["ModelUid"] = boost::any(*modelUid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("ModelName") != m.end() && !m["ModelName"].empty()) {
      modelName = make_shared<string>(boost::any_cast<string>(m["ModelName"]));
    }
    if (m.find("ModelOperation") != m.end() && !m["ModelOperation"].empty()) {
      modelOperation = make_shared<string>(boost::any_cast<string>(m["ModelOperation"]));
    }
    if (m.find("ModelUid") != m.end() && !m["ModelUid"].empty()) {
      modelUid = make_shared<string>(boost::any_cast<string>(m["ModelUid"]));
    }
  }


  virtual ~DryRunSwaggerResponseBodyModelSuccessApiImportModelSuccess() = default;
};
class DryRunSwaggerResponseBodyModelSuccess : public Darabonba::Model {
public:
  shared_ptr<vector<DryRunSwaggerResponseBodyModelSuccessApiImportModelSuccess>> apiImportModelSuccess{};

  DryRunSwaggerResponseBodyModelSuccess() {}

  explicit DryRunSwaggerResponseBodyModelSuccess(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiImportModelSuccess) {
      vector<boost::any> temp1;
      for(auto item1:*apiImportModelSuccess){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ApiImportModelSuccess"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiImportModelSuccess") != m.end() && !m["ApiImportModelSuccess"].empty()) {
      if (typeid(vector<boost::any>) == m["ApiImportModelSuccess"].type()) {
        vector<DryRunSwaggerResponseBodyModelSuccessApiImportModelSuccess> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ApiImportModelSuccess"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DryRunSwaggerResponseBodyModelSuccessApiImportModelSuccess model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        apiImportModelSuccess = make_shared<vector<DryRunSwaggerResponseBodyModelSuccessApiImportModelSuccess>>(expect1);
      }
    }
  }


  virtual ~DryRunSwaggerResponseBodyModelSuccess() = default;
};
class DryRunSwaggerResponseBodySuccessApiDryRunSwaggerSuccess : public Darabonba::Model {
public:
  shared_ptr<string> apiOperation{};
  shared_ptr<string> apiSwagger{};
  shared_ptr<string> apiUid{};
  shared_ptr<string> httpMethod{};
  shared_ptr<string> path{};

  DryRunSwaggerResponseBodySuccessApiDryRunSwaggerSuccess() {}

  explicit DryRunSwaggerResponseBodySuccessApiDryRunSwaggerSuccess(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiOperation) {
      res["ApiOperation"] = boost::any(*apiOperation);
    }
    if (apiSwagger) {
      res["ApiSwagger"] = boost::any(*apiSwagger);
    }
    if (apiUid) {
      res["ApiUid"] = boost::any(*apiUid);
    }
    if (httpMethod) {
      res["HttpMethod"] = boost::any(*httpMethod);
    }
    if (path) {
      res["Path"] = boost::any(*path);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiOperation") != m.end() && !m["ApiOperation"].empty()) {
      apiOperation = make_shared<string>(boost::any_cast<string>(m["ApiOperation"]));
    }
    if (m.find("ApiSwagger") != m.end() && !m["ApiSwagger"].empty()) {
      apiSwagger = make_shared<string>(boost::any_cast<string>(m["ApiSwagger"]));
    }
    if (m.find("ApiUid") != m.end() && !m["ApiUid"].empty()) {
      apiUid = make_shared<string>(boost::any_cast<string>(m["ApiUid"]));
    }
    if (m.find("HttpMethod") != m.end() && !m["HttpMethod"].empty()) {
      httpMethod = make_shared<string>(boost::any_cast<string>(m["HttpMethod"]));
    }
    if (m.find("Path") != m.end() && !m["Path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["Path"]));
    }
  }


  virtual ~DryRunSwaggerResponseBodySuccessApiDryRunSwaggerSuccess() = default;
};
class DryRunSwaggerResponseBodySuccess : public Darabonba::Model {
public:
  shared_ptr<vector<DryRunSwaggerResponseBodySuccessApiDryRunSwaggerSuccess>> apiDryRunSwaggerSuccess{};

  DryRunSwaggerResponseBodySuccess() {}

  explicit DryRunSwaggerResponseBodySuccess(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiDryRunSwaggerSuccess) {
      vector<boost::any> temp1;
      for(auto item1:*apiDryRunSwaggerSuccess){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ApiDryRunSwaggerSuccess"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiDryRunSwaggerSuccess") != m.end() && !m["ApiDryRunSwaggerSuccess"].empty()) {
      if (typeid(vector<boost::any>) == m["ApiDryRunSwaggerSuccess"].type()) {
        vector<DryRunSwaggerResponseBodySuccessApiDryRunSwaggerSuccess> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ApiDryRunSwaggerSuccess"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DryRunSwaggerResponseBodySuccessApiDryRunSwaggerSuccess model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        apiDryRunSwaggerSuccess = make_shared<vector<DryRunSwaggerResponseBodySuccessApiDryRunSwaggerSuccess>>(expect1);
      }
    }
  }


  virtual ~DryRunSwaggerResponseBodySuccess() = default;
};
class DryRunSwaggerResponseBody : public Darabonba::Model {
public:
  shared_ptr<DryRunSwaggerResponseBodyFailed> failed{};
  shared_ptr<string> globalCondition{};
  shared_ptr<DryRunSwaggerResponseBodyModelFailed> modelFailed{};
  shared_ptr<DryRunSwaggerResponseBodyModelSuccess> modelSuccess{};
  shared_ptr<string> requestId{};
  shared_ptr<DryRunSwaggerResponseBodySuccess> success{};

  DryRunSwaggerResponseBody() {}

  explicit DryRunSwaggerResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (failed) {
      res["Failed"] = failed ? boost::any(failed->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (globalCondition) {
      res["GlobalCondition"] = boost::any(*globalCondition);
    }
    if (modelFailed) {
      res["ModelFailed"] = modelFailed ? boost::any(modelFailed->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (modelSuccess) {
      res["ModelSuccess"] = modelSuccess ? boost::any(modelSuccess->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = success ? boost::any(success->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Failed") != m.end() && !m["Failed"].empty()) {
      if (typeid(map<string, boost::any>) == m["Failed"].type()) {
        DryRunSwaggerResponseBodyFailed model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Failed"]));
        failed = make_shared<DryRunSwaggerResponseBodyFailed>(model1);
      }
    }
    if (m.find("GlobalCondition") != m.end() && !m["GlobalCondition"].empty()) {
      globalCondition = make_shared<string>(boost::any_cast<string>(m["GlobalCondition"]));
    }
    if (m.find("ModelFailed") != m.end() && !m["ModelFailed"].empty()) {
      if (typeid(map<string, boost::any>) == m["ModelFailed"].type()) {
        DryRunSwaggerResponseBodyModelFailed model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ModelFailed"]));
        modelFailed = make_shared<DryRunSwaggerResponseBodyModelFailed>(model1);
      }
    }
    if (m.find("ModelSuccess") != m.end() && !m["ModelSuccess"].empty()) {
      if (typeid(map<string, boost::any>) == m["ModelSuccess"].type()) {
        DryRunSwaggerResponseBodyModelSuccess model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ModelSuccess"]));
        modelSuccess = make_shared<DryRunSwaggerResponseBodyModelSuccess>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      if (typeid(map<string, boost::any>) == m["Success"].type()) {
        DryRunSwaggerResponseBodySuccess model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Success"]));
        success = make_shared<DryRunSwaggerResponseBodySuccess>(model1);
      }
    }
  }


  virtual ~DryRunSwaggerResponseBody() = default;
};
class DryRunSwaggerResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DryRunSwaggerResponseBody> body{};

  DryRunSwaggerResponse() {}

  explicit DryRunSwaggerResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DryRunSwaggerResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DryRunSwaggerResponseBody>(model1);
      }
    }
  }


  virtual ~DryRunSwaggerResponse() = default;
};
class ImportSwaggerRequest : public Darabonba::Model {
public:
  shared_ptr<string> data{};
  shared_ptr<string> dataFormat{};
  shared_ptr<bool> dryRun{};
  shared_ptr<map<string, boost::any>> globalCondition{};
  shared_ptr<string> groupId{};
  shared_ptr<bool> overwrite{};
  shared_ptr<string> securityToken{};

  ImportSwaggerRequest() {}

  explicit ImportSwaggerRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (dataFormat) {
      res["DataFormat"] = boost::any(*dataFormat);
    }
    if (dryRun) {
      res["DryRun"] = boost::any(*dryRun);
    }
    if (globalCondition) {
      res["GlobalCondition"] = boost::any(*globalCondition);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (overwrite) {
      res["Overwrite"] = boost::any(*overwrite);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("DataFormat") != m.end() && !m["DataFormat"].empty()) {
      dataFormat = make_shared<string>(boost::any_cast<string>(m["DataFormat"]));
    }
    if (m.find("DryRun") != m.end() && !m["DryRun"].empty()) {
      dryRun = make_shared<bool>(boost::any_cast<bool>(m["DryRun"]));
    }
    if (m.find("GlobalCondition") != m.end() && !m["GlobalCondition"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["GlobalCondition"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      globalCondition = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("Overwrite") != m.end() && !m["Overwrite"].empty()) {
      overwrite = make_shared<bool>(boost::any_cast<bool>(m["Overwrite"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~ImportSwaggerRequest() = default;
};
class ImportSwaggerShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> data{};
  shared_ptr<string> dataFormat{};
  shared_ptr<bool> dryRun{};
  shared_ptr<string> globalConditionShrink{};
  shared_ptr<string> groupId{};
  shared_ptr<bool> overwrite{};
  shared_ptr<string> securityToken{};

  ImportSwaggerShrinkRequest() {}

  explicit ImportSwaggerShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (dataFormat) {
      res["DataFormat"] = boost::any(*dataFormat);
    }
    if (dryRun) {
      res["DryRun"] = boost::any(*dryRun);
    }
    if (globalConditionShrink) {
      res["GlobalCondition"] = boost::any(*globalConditionShrink);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (overwrite) {
      res["Overwrite"] = boost::any(*overwrite);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("DataFormat") != m.end() && !m["DataFormat"].empty()) {
      dataFormat = make_shared<string>(boost::any_cast<string>(m["DataFormat"]));
    }
    if (m.find("DryRun") != m.end() && !m["DryRun"].empty()) {
      dryRun = make_shared<bool>(boost::any_cast<bool>(m["DryRun"]));
    }
    if (m.find("GlobalCondition") != m.end() && !m["GlobalCondition"].empty()) {
      globalConditionShrink = make_shared<string>(boost::any_cast<string>(m["GlobalCondition"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("Overwrite") != m.end() && !m["Overwrite"].empty()) {
      overwrite = make_shared<bool>(boost::any_cast<bool>(m["Overwrite"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~ImportSwaggerShrinkRequest() = default;
};
class ImportSwaggerResponseBodyFailedApiImportSwaggerFailed : public Darabonba::Model {
public:
  shared_ptr<string> errorMsg{};
  shared_ptr<string> httpMethod{};
  shared_ptr<string> path{};

  ImportSwaggerResponseBodyFailedApiImportSwaggerFailed() {}

  explicit ImportSwaggerResponseBodyFailedApiImportSwaggerFailed(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorMsg) {
      res["ErrorMsg"] = boost::any(*errorMsg);
    }
    if (httpMethod) {
      res["HttpMethod"] = boost::any(*httpMethod);
    }
    if (path) {
      res["Path"] = boost::any(*path);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorMsg") != m.end() && !m["ErrorMsg"].empty()) {
      errorMsg = make_shared<string>(boost::any_cast<string>(m["ErrorMsg"]));
    }
    if (m.find("HttpMethod") != m.end() && !m["HttpMethod"].empty()) {
      httpMethod = make_shared<string>(boost::any_cast<string>(m["HttpMethod"]));
    }
    if (m.find("Path") != m.end() && !m["Path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["Path"]));
    }
  }


  virtual ~ImportSwaggerResponseBodyFailedApiImportSwaggerFailed() = default;
};
class ImportSwaggerResponseBodyFailed : public Darabonba::Model {
public:
  shared_ptr<vector<ImportSwaggerResponseBodyFailedApiImportSwaggerFailed>> apiImportSwaggerFailed{};

  ImportSwaggerResponseBodyFailed() {}

  explicit ImportSwaggerResponseBodyFailed(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiImportSwaggerFailed) {
      vector<boost::any> temp1;
      for(auto item1:*apiImportSwaggerFailed){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ApiImportSwaggerFailed"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiImportSwaggerFailed") != m.end() && !m["ApiImportSwaggerFailed"].empty()) {
      if (typeid(vector<boost::any>) == m["ApiImportSwaggerFailed"].type()) {
        vector<ImportSwaggerResponseBodyFailedApiImportSwaggerFailed> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ApiImportSwaggerFailed"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ImportSwaggerResponseBodyFailedApiImportSwaggerFailed model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        apiImportSwaggerFailed = make_shared<vector<ImportSwaggerResponseBodyFailedApiImportSwaggerFailed>>(expect1);
      }
    }
  }


  virtual ~ImportSwaggerResponseBodyFailed() = default;
};
class ImportSwaggerResponseBodyModelFailedApiImportModelFailed : public Darabonba::Model {
public:
  shared_ptr<string> errorMsg{};
  shared_ptr<string> groupId{};
  shared_ptr<string> modelName{};

  ImportSwaggerResponseBodyModelFailedApiImportModelFailed() {}

  explicit ImportSwaggerResponseBodyModelFailedApiImportModelFailed(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorMsg) {
      res["ErrorMsg"] = boost::any(*errorMsg);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (modelName) {
      res["ModelName"] = boost::any(*modelName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorMsg") != m.end() && !m["ErrorMsg"].empty()) {
      errorMsg = make_shared<string>(boost::any_cast<string>(m["ErrorMsg"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("ModelName") != m.end() && !m["ModelName"].empty()) {
      modelName = make_shared<string>(boost::any_cast<string>(m["ModelName"]));
    }
  }


  virtual ~ImportSwaggerResponseBodyModelFailedApiImportModelFailed() = default;
};
class ImportSwaggerResponseBodyModelFailed : public Darabonba::Model {
public:
  shared_ptr<vector<ImportSwaggerResponseBodyModelFailedApiImportModelFailed>> apiImportModelFailed{};

  ImportSwaggerResponseBodyModelFailed() {}

  explicit ImportSwaggerResponseBodyModelFailed(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiImportModelFailed) {
      vector<boost::any> temp1;
      for(auto item1:*apiImportModelFailed){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ApiImportModelFailed"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiImportModelFailed") != m.end() && !m["ApiImportModelFailed"].empty()) {
      if (typeid(vector<boost::any>) == m["ApiImportModelFailed"].type()) {
        vector<ImportSwaggerResponseBodyModelFailedApiImportModelFailed> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ApiImportModelFailed"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ImportSwaggerResponseBodyModelFailedApiImportModelFailed model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        apiImportModelFailed = make_shared<vector<ImportSwaggerResponseBodyModelFailedApiImportModelFailed>>(expect1);
      }
    }
  }


  virtual ~ImportSwaggerResponseBodyModelFailed() = default;
};
class ImportSwaggerResponseBodyModelSuccessApiImportModelSuccess : public Darabonba::Model {
public:
  shared_ptr<string> groupId{};
  shared_ptr<string> modelName{};
  shared_ptr<string> modelOperation{};
  shared_ptr<string> modelUid{};

  ImportSwaggerResponseBodyModelSuccessApiImportModelSuccess() {}

  explicit ImportSwaggerResponseBodyModelSuccessApiImportModelSuccess(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (modelName) {
      res["ModelName"] = boost::any(*modelName);
    }
    if (modelOperation) {
      res["ModelOperation"] = boost::any(*modelOperation);
    }
    if (modelUid) {
      res["ModelUid"] = boost::any(*modelUid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("ModelName") != m.end() && !m["ModelName"].empty()) {
      modelName = make_shared<string>(boost::any_cast<string>(m["ModelName"]));
    }
    if (m.find("ModelOperation") != m.end() && !m["ModelOperation"].empty()) {
      modelOperation = make_shared<string>(boost::any_cast<string>(m["ModelOperation"]));
    }
    if (m.find("ModelUid") != m.end() && !m["ModelUid"].empty()) {
      modelUid = make_shared<string>(boost::any_cast<string>(m["ModelUid"]));
    }
  }


  virtual ~ImportSwaggerResponseBodyModelSuccessApiImportModelSuccess() = default;
};
class ImportSwaggerResponseBodyModelSuccess : public Darabonba::Model {
public:
  shared_ptr<vector<ImportSwaggerResponseBodyModelSuccessApiImportModelSuccess>> apiImportModelSuccess{};

  ImportSwaggerResponseBodyModelSuccess() {}

  explicit ImportSwaggerResponseBodyModelSuccess(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiImportModelSuccess) {
      vector<boost::any> temp1;
      for(auto item1:*apiImportModelSuccess){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ApiImportModelSuccess"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiImportModelSuccess") != m.end() && !m["ApiImportModelSuccess"].empty()) {
      if (typeid(vector<boost::any>) == m["ApiImportModelSuccess"].type()) {
        vector<ImportSwaggerResponseBodyModelSuccessApiImportModelSuccess> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ApiImportModelSuccess"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ImportSwaggerResponseBodyModelSuccessApiImportModelSuccess model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        apiImportModelSuccess = make_shared<vector<ImportSwaggerResponseBodyModelSuccessApiImportModelSuccess>>(expect1);
      }
    }
  }


  virtual ~ImportSwaggerResponseBodyModelSuccess() = default;
};
class ImportSwaggerResponseBodySuccessApiImportSwaggerSuccess : public Darabonba::Model {
public:
  shared_ptr<string> apiOperation{};
  shared_ptr<string> apiUid{};
  shared_ptr<string> httpMethod{};
  shared_ptr<string> path{};

  ImportSwaggerResponseBodySuccessApiImportSwaggerSuccess() {}

  explicit ImportSwaggerResponseBodySuccessApiImportSwaggerSuccess(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiOperation) {
      res["ApiOperation"] = boost::any(*apiOperation);
    }
    if (apiUid) {
      res["ApiUid"] = boost::any(*apiUid);
    }
    if (httpMethod) {
      res["HttpMethod"] = boost::any(*httpMethod);
    }
    if (path) {
      res["Path"] = boost::any(*path);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiOperation") != m.end() && !m["ApiOperation"].empty()) {
      apiOperation = make_shared<string>(boost::any_cast<string>(m["ApiOperation"]));
    }
    if (m.find("ApiUid") != m.end() && !m["ApiUid"].empty()) {
      apiUid = make_shared<string>(boost::any_cast<string>(m["ApiUid"]));
    }
    if (m.find("HttpMethod") != m.end() && !m["HttpMethod"].empty()) {
      httpMethod = make_shared<string>(boost::any_cast<string>(m["HttpMethod"]));
    }
    if (m.find("Path") != m.end() && !m["Path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["Path"]));
    }
  }


  virtual ~ImportSwaggerResponseBodySuccessApiImportSwaggerSuccess() = default;
};
class ImportSwaggerResponseBodySuccess : public Darabonba::Model {
public:
  shared_ptr<vector<ImportSwaggerResponseBodySuccessApiImportSwaggerSuccess>> apiImportSwaggerSuccess{};

  ImportSwaggerResponseBodySuccess() {}

  explicit ImportSwaggerResponseBodySuccess(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiImportSwaggerSuccess) {
      vector<boost::any> temp1;
      for(auto item1:*apiImportSwaggerSuccess){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ApiImportSwaggerSuccess"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiImportSwaggerSuccess") != m.end() && !m["ApiImportSwaggerSuccess"].empty()) {
      if (typeid(vector<boost::any>) == m["ApiImportSwaggerSuccess"].type()) {
        vector<ImportSwaggerResponseBodySuccessApiImportSwaggerSuccess> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ApiImportSwaggerSuccess"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ImportSwaggerResponseBodySuccessApiImportSwaggerSuccess model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        apiImportSwaggerSuccess = make_shared<vector<ImportSwaggerResponseBodySuccessApiImportSwaggerSuccess>>(expect1);
      }
    }
  }


  virtual ~ImportSwaggerResponseBodySuccess() = default;
};
class ImportSwaggerResponseBody : public Darabonba::Model {
public:
  shared_ptr<ImportSwaggerResponseBodyFailed> failed{};
  shared_ptr<ImportSwaggerResponseBodyModelFailed> modelFailed{};
  shared_ptr<ImportSwaggerResponseBodyModelSuccess> modelSuccess{};
  shared_ptr<string> requestId{};
  shared_ptr<ImportSwaggerResponseBodySuccess> success{};

  ImportSwaggerResponseBody() {}

  explicit ImportSwaggerResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (failed) {
      res["Failed"] = failed ? boost::any(failed->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (modelFailed) {
      res["ModelFailed"] = modelFailed ? boost::any(modelFailed->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (modelSuccess) {
      res["ModelSuccess"] = modelSuccess ? boost::any(modelSuccess->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = success ? boost::any(success->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Failed") != m.end() && !m["Failed"].empty()) {
      if (typeid(map<string, boost::any>) == m["Failed"].type()) {
        ImportSwaggerResponseBodyFailed model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Failed"]));
        failed = make_shared<ImportSwaggerResponseBodyFailed>(model1);
      }
    }
    if (m.find("ModelFailed") != m.end() && !m["ModelFailed"].empty()) {
      if (typeid(map<string, boost::any>) == m["ModelFailed"].type()) {
        ImportSwaggerResponseBodyModelFailed model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ModelFailed"]));
        modelFailed = make_shared<ImportSwaggerResponseBodyModelFailed>(model1);
      }
    }
    if (m.find("ModelSuccess") != m.end() && !m["ModelSuccess"].empty()) {
      if (typeid(map<string, boost::any>) == m["ModelSuccess"].type()) {
        ImportSwaggerResponseBodyModelSuccess model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ModelSuccess"]));
        modelSuccess = make_shared<ImportSwaggerResponseBodyModelSuccess>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      if (typeid(map<string, boost::any>) == m["Success"].type()) {
        ImportSwaggerResponseBodySuccess model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Success"]));
        success = make_shared<ImportSwaggerResponseBodySuccess>(model1);
      }
    }
  }


  virtual ~ImportSwaggerResponseBody() = default;
};
class ImportSwaggerResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ImportSwaggerResponseBody> body{};

  ImportSwaggerResponse() {}

  explicit ImportSwaggerResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ImportSwaggerResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ImportSwaggerResponseBody>(model1);
      }
    }
  }


  virtual ~ImportSwaggerResponse() = default;
};
class ListTagResourcesRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  ListTagResourcesRequestTag() {}

  explicit ListTagResourcesRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~ListTagResourcesRequestTag() = default;
};
class ListTagResourcesRequest : public Darabonba::Model {
public:
  shared_ptr<string> nextToken{};
  shared_ptr<vector<string>> resourceId{};
  shared_ptr<string> resourceType{};
  shared_ptr<vector<ListTagResourcesRequestTag>> tag{};

  ListTagResourcesRequest() {}

  explicit ListTagResourcesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ResourceId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ResourceId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      resourceId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<ListTagResourcesRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListTagResourcesRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<ListTagResourcesRequestTag>>(expect1);
      }
    }
  }


  virtual ~ListTagResourcesRequest() = default;
};
class ListTagResourcesResponseBodyTagResourcesTagResource : public Darabonba::Model {
public:
  shared_ptr<string> resourceId{};
  shared_ptr<string> resourceType{};
  shared_ptr<string> tagKey{};
  shared_ptr<string> tagValue{};

  ListTagResourcesResponseBodyTagResourcesTagResource() {}

  explicit ListTagResourcesResponseBodyTagResourcesTagResource(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (tagKey) {
      res["TagKey"] = boost::any(*tagKey);
    }
    if (tagValue) {
      res["TagValue"] = boost::any(*tagValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      resourceId = make_shared<string>(boost::any_cast<string>(m["ResourceId"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("TagKey") != m.end() && !m["TagKey"].empty()) {
      tagKey = make_shared<string>(boost::any_cast<string>(m["TagKey"]));
    }
    if (m.find("TagValue") != m.end() && !m["TagValue"].empty()) {
      tagValue = make_shared<string>(boost::any_cast<string>(m["TagValue"]));
    }
  }


  virtual ~ListTagResourcesResponseBodyTagResourcesTagResource() = default;
};
class ListTagResourcesResponseBodyTagResources : public Darabonba::Model {
public:
  shared_ptr<vector<ListTagResourcesResponseBodyTagResourcesTagResource>> tagResource{};

  ListTagResourcesResponseBodyTagResources() {}

  explicit ListTagResourcesResponseBodyTagResources(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tagResource) {
      vector<boost::any> temp1;
      for(auto item1:*tagResource){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TagResource"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TagResource") != m.end() && !m["TagResource"].empty()) {
      if (typeid(vector<boost::any>) == m["TagResource"].type()) {
        vector<ListTagResourcesResponseBodyTagResourcesTagResource> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TagResource"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListTagResourcesResponseBodyTagResourcesTagResource model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tagResource = make_shared<vector<ListTagResourcesResponseBodyTagResourcesTagResource>>(expect1);
      }
    }
  }


  virtual ~ListTagResourcesResponseBodyTagResources() = default;
};
class ListTagResourcesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> nextToken{};
  shared_ptr<string> requestId{};
  shared_ptr<ListTagResourcesResponseBodyTagResources> tagResources{};

  ListTagResourcesResponseBody() {}

  explicit ListTagResourcesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (tagResources) {
      res["TagResources"] = tagResources ? boost::any(tagResources->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TagResources") != m.end() && !m["TagResources"].empty()) {
      if (typeid(map<string, boost::any>) == m["TagResources"].type()) {
        ListTagResourcesResponseBodyTagResources model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TagResources"]));
        tagResources = make_shared<ListTagResourcesResponseBodyTagResources>(model1);
      }
    }
  }


  virtual ~ListTagResourcesResponseBody() = default;
};
class ListTagResourcesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListTagResourcesResponseBody> body{};

  ListTagResourcesResponse() {}

  explicit ListTagResourcesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListTagResourcesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListTagResourcesResponseBody>(model1);
      }
    }
  }


  virtual ~ListTagResourcesResponse() = default;
};
class ModifyApiRequest : public Darabonba::Model {
public:
  shared_ptr<string> allowSignatureMethod{};
  shared_ptr<string> apiId{};
  shared_ptr<string> apiName{};
  shared_ptr<string> appCodeAuthType{};
  shared_ptr<string> authType{};
  shared_ptr<string> constantParameters{};
  shared_ptr<string> description{};
  shared_ptr<bool> disableInternet{};
  shared_ptr<string> errorCodeSamples{};
  shared_ptr<string> failResultSample{};
  shared_ptr<bool> forceNonceCheck{};
  shared_ptr<string> groupId{};
  shared_ptr<string> openIdConnectConfig{};
  shared_ptr<string> requestConfig{};
  shared_ptr<string> requestParameters{};
  shared_ptr<string> resultBodyModel{};
  shared_ptr<string> resultDescriptions{};
  shared_ptr<string> resultSample{};
  shared_ptr<string> resultType{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> serviceConfig{};
  shared_ptr<string> serviceParameters{};
  shared_ptr<string> serviceParametersMap{};
  shared_ptr<string> systemParameters{};
  shared_ptr<string> visibility{};
  shared_ptr<string> webSocketApiType{};

  ModifyApiRequest() {}

  explicit ModifyApiRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (allowSignatureMethod) {
      res["AllowSignatureMethod"] = boost::any(*allowSignatureMethod);
    }
    if (apiId) {
      res["ApiId"] = boost::any(*apiId);
    }
    if (apiName) {
      res["ApiName"] = boost::any(*apiName);
    }
    if (appCodeAuthType) {
      res["AppCodeAuthType"] = boost::any(*appCodeAuthType);
    }
    if (authType) {
      res["AuthType"] = boost::any(*authType);
    }
    if (constantParameters) {
      res["ConstantParameters"] = boost::any(*constantParameters);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (disableInternet) {
      res["DisableInternet"] = boost::any(*disableInternet);
    }
    if (errorCodeSamples) {
      res["ErrorCodeSamples"] = boost::any(*errorCodeSamples);
    }
    if (failResultSample) {
      res["FailResultSample"] = boost::any(*failResultSample);
    }
    if (forceNonceCheck) {
      res["ForceNonceCheck"] = boost::any(*forceNonceCheck);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (openIdConnectConfig) {
      res["OpenIdConnectConfig"] = boost::any(*openIdConnectConfig);
    }
    if (requestConfig) {
      res["RequestConfig"] = boost::any(*requestConfig);
    }
    if (requestParameters) {
      res["RequestParameters"] = boost::any(*requestParameters);
    }
    if (resultBodyModel) {
      res["ResultBodyModel"] = boost::any(*resultBodyModel);
    }
    if (resultDescriptions) {
      res["ResultDescriptions"] = boost::any(*resultDescriptions);
    }
    if (resultSample) {
      res["ResultSample"] = boost::any(*resultSample);
    }
    if (resultType) {
      res["ResultType"] = boost::any(*resultType);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (serviceConfig) {
      res["ServiceConfig"] = boost::any(*serviceConfig);
    }
    if (serviceParameters) {
      res["ServiceParameters"] = boost::any(*serviceParameters);
    }
    if (serviceParametersMap) {
      res["ServiceParametersMap"] = boost::any(*serviceParametersMap);
    }
    if (systemParameters) {
      res["SystemParameters"] = boost::any(*systemParameters);
    }
    if (visibility) {
      res["Visibility"] = boost::any(*visibility);
    }
    if (webSocketApiType) {
      res["WebSocketApiType"] = boost::any(*webSocketApiType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AllowSignatureMethod") != m.end() && !m["AllowSignatureMethod"].empty()) {
      allowSignatureMethod = make_shared<string>(boost::any_cast<string>(m["AllowSignatureMethod"]));
    }
    if (m.find("ApiId") != m.end() && !m["ApiId"].empty()) {
      apiId = make_shared<string>(boost::any_cast<string>(m["ApiId"]));
    }
    if (m.find("ApiName") != m.end() && !m["ApiName"].empty()) {
      apiName = make_shared<string>(boost::any_cast<string>(m["ApiName"]));
    }
    if (m.find("AppCodeAuthType") != m.end() && !m["AppCodeAuthType"].empty()) {
      appCodeAuthType = make_shared<string>(boost::any_cast<string>(m["AppCodeAuthType"]));
    }
    if (m.find("AuthType") != m.end() && !m["AuthType"].empty()) {
      authType = make_shared<string>(boost::any_cast<string>(m["AuthType"]));
    }
    if (m.find("ConstantParameters") != m.end() && !m["ConstantParameters"].empty()) {
      constantParameters = make_shared<string>(boost::any_cast<string>(m["ConstantParameters"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DisableInternet") != m.end() && !m["DisableInternet"].empty()) {
      disableInternet = make_shared<bool>(boost::any_cast<bool>(m["DisableInternet"]));
    }
    if (m.find("ErrorCodeSamples") != m.end() && !m["ErrorCodeSamples"].empty()) {
      errorCodeSamples = make_shared<string>(boost::any_cast<string>(m["ErrorCodeSamples"]));
    }
    if (m.find("FailResultSample") != m.end() && !m["FailResultSample"].empty()) {
      failResultSample = make_shared<string>(boost::any_cast<string>(m["FailResultSample"]));
    }
    if (m.find("ForceNonceCheck") != m.end() && !m["ForceNonceCheck"].empty()) {
      forceNonceCheck = make_shared<bool>(boost::any_cast<bool>(m["ForceNonceCheck"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("OpenIdConnectConfig") != m.end() && !m["OpenIdConnectConfig"].empty()) {
      openIdConnectConfig = make_shared<string>(boost::any_cast<string>(m["OpenIdConnectConfig"]));
    }
    if (m.find("RequestConfig") != m.end() && !m["RequestConfig"].empty()) {
      requestConfig = make_shared<string>(boost::any_cast<string>(m["RequestConfig"]));
    }
    if (m.find("RequestParameters") != m.end() && !m["RequestParameters"].empty()) {
      requestParameters = make_shared<string>(boost::any_cast<string>(m["RequestParameters"]));
    }
    if (m.find("ResultBodyModel") != m.end() && !m["ResultBodyModel"].empty()) {
      resultBodyModel = make_shared<string>(boost::any_cast<string>(m["ResultBodyModel"]));
    }
    if (m.find("ResultDescriptions") != m.end() && !m["ResultDescriptions"].empty()) {
      resultDescriptions = make_shared<string>(boost::any_cast<string>(m["ResultDescriptions"]));
    }
    if (m.find("ResultSample") != m.end() && !m["ResultSample"].empty()) {
      resultSample = make_shared<string>(boost::any_cast<string>(m["ResultSample"]));
    }
    if (m.find("ResultType") != m.end() && !m["ResultType"].empty()) {
      resultType = make_shared<string>(boost::any_cast<string>(m["ResultType"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("ServiceConfig") != m.end() && !m["ServiceConfig"].empty()) {
      serviceConfig = make_shared<string>(boost::any_cast<string>(m["ServiceConfig"]));
    }
    if (m.find("ServiceParameters") != m.end() && !m["ServiceParameters"].empty()) {
      serviceParameters = make_shared<string>(boost::any_cast<string>(m["ServiceParameters"]));
    }
    if (m.find("ServiceParametersMap") != m.end() && !m["ServiceParametersMap"].empty()) {
      serviceParametersMap = make_shared<string>(boost::any_cast<string>(m["ServiceParametersMap"]));
    }
    if (m.find("SystemParameters") != m.end() && !m["SystemParameters"].empty()) {
      systemParameters = make_shared<string>(boost::any_cast<string>(m["SystemParameters"]));
    }
    if (m.find("Visibility") != m.end() && !m["Visibility"].empty()) {
      visibility = make_shared<string>(boost::any_cast<string>(m["Visibility"]));
    }
    if (m.find("WebSocketApiType") != m.end() && !m["WebSocketApiType"].empty()) {
      webSocketApiType = make_shared<string>(boost::any_cast<string>(m["WebSocketApiType"]));
    }
  }


  virtual ~ModifyApiRequest() = default;
};
class ModifyApiResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyApiResponseBody() {}

  explicit ModifyApiResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyApiResponseBody() = default;
};
class ModifyApiResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ModifyApiResponseBody> body{};

  ModifyApiResponse() {}

  explicit ModifyApiResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyApiResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyApiResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyApiResponse() = default;
};
class ModifyApiGroupRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  ModifyApiGroupRequestTag() {}

  explicit ModifyApiGroupRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~ModifyApiGroupRequestTag() = default;
};
class ModifyApiGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> basePath{};
  shared_ptr<string> compatibleFlags{};
  shared_ptr<string> customTraceConfig{};
  shared_ptr<string> customerConfigs{};
  shared_ptr<string> defaultDomain{};
  shared_ptr<string> description{};
  shared_ptr<string> groupId{};
  shared_ptr<string> groupName{};
  shared_ptr<string> passthroughHeaders{};
  shared_ptr<string> rpcPattern{};
  shared_ptr<string> securityToken{};
  shared_ptr<vector<ModifyApiGroupRequestTag>> tag{};
  shared_ptr<string> userLogConfig{};

  ModifyApiGroupRequest() {}

  explicit ModifyApiGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (basePath) {
      res["BasePath"] = boost::any(*basePath);
    }
    if (compatibleFlags) {
      res["CompatibleFlags"] = boost::any(*compatibleFlags);
    }
    if (customTraceConfig) {
      res["CustomTraceConfig"] = boost::any(*customTraceConfig);
    }
    if (customerConfigs) {
      res["CustomerConfigs"] = boost::any(*customerConfigs);
    }
    if (defaultDomain) {
      res["DefaultDomain"] = boost::any(*defaultDomain);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (passthroughHeaders) {
      res["PassthroughHeaders"] = boost::any(*passthroughHeaders);
    }
    if (rpcPattern) {
      res["RpcPattern"] = boost::any(*rpcPattern);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    if (userLogConfig) {
      res["UserLogConfig"] = boost::any(*userLogConfig);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BasePath") != m.end() && !m["BasePath"].empty()) {
      basePath = make_shared<string>(boost::any_cast<string>(m["BasePath"]));
    }
    if (m.find("CompatibleFlags") != m.end() && !m["CompatibleFlags"].empty()) {
      compatibleFlags = make_shared<string>(boost::any_cast<string>(m["CompatibleFlags"]));
    }
    if (m.find("CustomTraceConfig") != m.end() && !m["CustomTraceConfig"].empty()) {
      customTraceConfig = make_shared<string>(boost::any_cast<string>(m["CustomTraceConfig"]));
    }
    if (m.find("CustomerConfigs") != m.end() && !m["CustomerConfigs"].empty()) {
      customerConfigs = make_shared<string>(boost::any_cast<string>(m["CustomerConfigs"]));
    }
    if (m.find("DefaultDomain") != m.end() && !m["DefaultDomain"].empty()) {
      defaultDomain = make_shared<string>(boost::any_cast<string>(m["DefaultDomain"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("PassthroughHeaders") != m.end() && !m["PassthroughHeaders"].empty()) {
      passthroughHeaders = make_shared<string>(boost::any_cast<string>(m["PassthroughHeaders"]));
    }
    if (m.find("RpcPattern") != m.end() && !m["RpcPattern"].empty()) {
      rpcPattern = make_shared<string>(boost::any_cast<string>(m["RpcPattern"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<ModifyApiGroupRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ModifyApiGroupRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<ModifyApiGroupRequestTag>>(expect1);
      }
    }
    if (m.find("UserLogConfig") != m.end() && !m["UserLogConfig"].empty()) {
      userLogConfig = make_shared<string>(boost::any_cast<string>(m["UserLogConfig"]));
    }
  }


  virtual ~ModifyApiGroupRequest() = default;
};
class ModifyApiGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> basePath{};
  shared_ptr<string> description{};
  shared_ptr<string> groupId{};
  shared_ptr<string> groupName{};
  shared_ptr<string> requestId{};
  shared_ptr<string> subDomain{};

  ModifyApiGroupResponseBody() {}

  explicit ModifyApiGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (basePath) {
      res["BasePath"] = boost::any(*basePath);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (subDomain) {
      res["SubDomain"] = boost::any(*subDomain);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BasePath") != m.end() && !m["BasePath"].empty()) {
      basePath = make_shared<string>(boost::any_cast<string>(m["BasePath"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SubDomain") != m.end() && !m["SubDomain"].empty()) {
      subDomain = make_shared<string>(boost::any_cast<string>(m["SubDomain"]));
    }
  }


  virtual ~ModifyApiGroupResponseBody() = default;
};
class ModifyApiGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ModifyApiGroupResponseBody> body{};

  ModifyApiGroupResponse() {}

  explicit ModifyApiGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyApiGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyApiGroupResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyApiGroupResponse() = default;
};
class ModifyApiGroupVpcWhitelistRequest : public Darabonba::Model {
public:
  shared_ptr<string> groupId{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> vpcIds{};

  ModifyApiGroupVpcWhitelistRequest() {}

  explicit ModifyApiGroupVpcWhitelistRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (vpcIds) {
      res["VpcIds"] = boost::any(*vpcIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("VpcIds") != m.end() && !m["VpcIds"].empty()) {
      vpcIds = make_shared<string>(boost::any_cast<string>(m["VpcIds"]));
    }
  }


  virtual ~ModifyApiGroupVpcWhitelistRequest() = default;
};
class ModifyApiGroupVpcWhitelistResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyApiGroupVpcWhitelistResponseBody() {}

  explicit ModifyApiGroupVpcWhitelistResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyApiGroupVpcWhitelistResponseBody() = default;
};
class ModifyApiGroupVpcWhitelistResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ModifyApiGroupVpcWhitelistResponseBody> body{};

  ModifyApiGroupVpcWhitelistResponse() {}

  explicit ModifyApiGroupVpcWhitelistResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyApiGroupVpcWhitelistResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyApiGroupVpcWhitelistResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyApiGroupVpcWhitelistResponse() = default;
};
class ModifyAppRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  ModifyAppRequestTag() {}

  explicit ModifyAppRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~ModifyAppRequestTag() = default;
};
class ModifyAppRequest : public Darabonba::Model {
public:
  shared_ptr<long> appId{};
  shared_ptr<string> appName{};
  shared_ptr<string> description{};
  shared_ptr<string> securityToken{};
  shared_ptr<vector<ModifyAppRequestTag>> tag{};

  ModifyAppRequest() {}

  explicit ModifyAppRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<long>(boost::any_cast<long>(m["AppId"]));
    }
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<ModifyAppRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ModifyAppRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<ModifyAppRequestTag>>(expect1);
      }
    }
  }


  virtual ~ModifyAppRequest() = default;
};
class ModifyAppResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyAppResponseBody() {}

  explicit ModifyAppResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyAppResponseBody() = default;
};
class ModifyAppResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ModifyAppResponseBody> body{};

  ModifyAppResponse() {}

  explicit ModifyAppResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyAppResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyAppResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyAppResponse() = default;
};
class ModifyInstanceSpecRequest : public Darabonba::Model {
public:
  shared_ptr<bool> autoPay{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> instanceSpec{};
  shared_ptr<string> token{};

  ModifyInstanceSpecRequest() {}

  explicit ModifyInstanceSpecRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (autoPay) {
      res["AutoPay"] = boost::any(*autoPay);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (instanceSpec) {
      res["InstanceSpec"] = boost::any(*instanceSpec);
    }
    if (token) {
      res["Token"] = boost::any(*token);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AutoPay") != m.end() && !m["AutoPay"].empty()) {
      autoPay = make_shared<bool>(boost::any_cast<bool>(m["AutoPay"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("InstanceSpec") != m.end() && !m["InstanceSpec"].empty()) {
      instanceSpec = make_shared<string>(boost::any_cast<string>(m["InstanceSpec"]));
    }
    if (m.find("Token") != m.end() && !m["Token"].empty()) {
      token = make_shared<string>(boost::any_cast<string>(m["Token"]));
    }
  }


  virtual ~ModifyInstanceSpecRequest() = default;
};
class ModifyInstanceSpecResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyInstanceSpecResponseBody() {}

  explicit ModifyInstanceSpecResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyInstanceSpecResponseBody() = default;
};
class ModifyInstanceSpecResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ModifyInstanceSpecResponseBody> body{};

  ModifyInstanceSpecResponse() {}

  explicit ModifyInstanceSpecResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyInstanceSpecResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyInstanceSpecResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyInstanceSpecResponse() = default;
};
class ModifyIpControlRequest : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> ipControlId{};
  shared_ptr<string> ipControlName{};
  shared_ptr<string> securityToken{};

  ModifyIpControlRequest() {}

  explicit ModifyIpControlRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (ipControlId) {
      res["IpControlId"] = boost::any(*ipControlId);
    }
    if (ipControlName) {
      res["IpControlName"] = boost::any(*ipControlName);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("IpControlId") != m.end() && !m["IpControlId"].empty()) {
      ipControlId = make_shared<string>(boost::any_cast<string>(m["IpControlId"]));
    }
    if (m.find("IpControlName") != m.end() && !m["IpControlName"].empty()) {
      ipControlName = make_shared<string>(boost::any_cast<string>(m["IpControlName"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~ModifyIpControlRequest() = default;
};
class ModifyIpControlResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyIpControlResponseBody() {}

  explicit ModifyIpControlResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyIpControlResponseBody() = default;
};
class ModifyIpControlResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ModifyIpControlResponseBody> body{};

  ModifyIpControlResponse() {}

  explicit ModifyIpControlResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyIpControlResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyIpControlResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyIpControlResponse() = default;
};
class ModifyIpControlPolicyItemRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> cidrIp{};
  shared_ptr<string> ipControlId{};
  shared_ptr<string> policyItemId{};
  shared_ptr<string> securityToken{};

  ModifyIpControlPolicyItemRequest() {}

  explicit ModifyIpControlPolicyItemRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (cidrIp) {
      res["CidrIp"] = boost::any(*cidrIp);
    }
    if (ipControlId) {
      res["IpControlId"] = boost::any(*ipControlId);
    }
    if (policyItemId) {
      res["PolicyItemId"] = boost::any(*policyItemId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("CidrIp") != m.end() && !m["CidrIp"].empty()) {
      cidrIp = make_shared<string>(boost::any_cast<string>(m["CidrIp"]));
    }
    if (m.find("IpControlId") != m.end() && !m["IpControlId"].empty()) {
      ipControlId = make_shared<string>(boost::any_cast<string>(m["IpControlId"]));
    }
    if (m.find("PolicyItemId") != m.end() && !m["PolicyItemId"].empty()) {
      policyItemId = make_shared<string>(boost::any_cast<string>(m["PolicyItemId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~ModifyIpControlPolicyItemRequest() = default;
};
class ModifyIpControlPolicyItemResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyIpControlPolicyItemResponseBody() {}

  explicit ModifyIpControlPolicyItemResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyIpControlPolicyItemResponseBody() = default;
};
class ModifyIpControlPolicyItemResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ModifyIpControlPolicyItemResponseBody> body{};

  ModifyIpControlPolicyItemResponse() {}

  explicit ModifyIpControlPolicyItemResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyIpControlPolicyItemResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyIpControlPolicyItemResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyIpControlPolicyItemResponse() = default;
};
class ModifyLogConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> logType{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> slsLogStore{};
  shared_ptr<string> slsProject{};

  ModifyLogConfigRequest() {}

  explicit ModifyLogConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (logType) {
      res["LogType"] = boost::any(*logType);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (slsLogStore) {
      res["SlsLogStore"] = boost::any(*slsLogStore);
    }
    if (slsProject) {
      res["SlsProject"] = boost::any(*slsProject);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LogType") != m.end() && !m["LogType"].empty()) {
      logType = make_shared<string>(boost::any_cast<string>(m["LogType"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("SlsLogStore") != m.end() && !m["SlsLogStore"].empty()) {
      slsLogStore = make_shared<string>(boost::any_cast<string>(m["SlsLogStore"]));
    }
    if (m.find("SlsProject") != m.end() && !m["SlsProject"].empty()) {
      slsProject = make_shared<string>(boost::any_cast<string>(m["SlsProject"]));
    }
  }


  virtual ~ModifyLogConfigRequest() = default;
};
class ModifyLogConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyLogConfigResponseBody() {}

  explicit ModifyLogConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyLogConfigResponseBody() = default;
};
class ModifyLogConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ModifyLogConfigResponseBody> body{};

  ModifyLogConfigResponse() {}

  explicit ModifyLogConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyLogConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyLogConfigResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyLogConfigResponse() = default;
};
class ModifyModelRequest : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> groupId{};
  shared_ptr<string> modelName{};
  shared_ptr<string> newModelName{};
  shared_ptr<string> schema{};

  ModifyModelRequest() {}

  explicit ModifyModelRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (modelName) {
      res["ModelName"] = boost::any(*modelName);
    }
    if (newModelName) {
      res["NewModelName"] = boost::any(*newModelName);
    }
    if (schema) {
      res["Schema"] = boost::any(*schema);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("ModelName") != m.end() && !m["ModelName"].empty()) {
      modelName = make_shared<string>(boost::any_cast<string>(m["ModelName"]));
    }
    if (m.find("NewModelName") != m.end() && !m["NewModelName"].empty()) {
      newModelName = make_shared<string>(boost::any_cast<string>(m["NewModelName"]));
    }
    if (m.find("Schema") != m.end() && !m["Schema"].empty()) {
      schema = make_shared<string>(boost::any_cast<string>(m["Schema"]));
    }
  }


  virtual ~ModifyModelRequest() = default;
};
class ModifyModelResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyModelResponseBody() {}

  explicit ModifyModelResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyModelResponseBody() = default;
};
class ModifyModelResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ModifyModelResponseBody> body{};

  ModifyModelResponse() {}

  explicit ModifyModelResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyModelResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyModelResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyModelResponse() = default;
};
class ModifyPluginRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  ModifyPluginRequestTag() {}

  explicit ModifyPluginRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~ModifyPluginRequestTag() = default;
};
class ModifyPluginRequest : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> pluginData{};
  shared_ptr<string> pluginId{};
  shared_ptr<string> pluginName{};
  shared_ptr<string> securityToken{};
  shared_ptr<vector<ModifyPluginRequestTag>> tag{};

  ModifyPluginRequest() {}

  explicit ModifyPluginRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (pluginData) {
      res["PluginData"] = boost::any(*pluginData);
    }
    if (pluginId) {
      res["PluginId"] = boost::any(*pluginId);
    }
    if (pluginName) {
      res["PluginName"] = boost::any(*pluginName);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("PluginData") != m.end() && !m["PluginData"].empty()) {
      pluginData = make_shared<string>(boost::any_cast<string>(m["PluginData"]));
    }
    if (m.find("PluginId") != m.end() && !m["PluginId"].empty()) {
      pluginId = make_shared<string>(boost::any_cast<string>(m["PluginId"]));
    }
    if (m.find("PluginName") != m.end() && !m["PluginName"].empty()) {
      pluginName = make_shared<string>(boost::any_cast<string>(m["PluginName"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<ModifyPluginRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ModifyPluginRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<ModifyPluginRequestTag>>(expect1);
      }
    }
  }


  virtual ~ModifyPluginRequest() = default;
};
class ModifyPluginResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyPluginResponseBody() {}

  explicit ModifyPluginResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyPluginResponseBody() = default;
};
class ModifyPluginResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ModifyPluginResponseBody> body{};

  ModifyPluginResponse() {}

  explicit ModifyPluginResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyPluginResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyPluginResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyPluginResponse() = default;
};
class ModifySignatureRequest : public Darabonba::Model {
public:
  shared_ptr<string> securityToken{};
  shared_ptr<string> signatureId{};
  shared_ptr<string> signatureKey{};
  shared_ptr<string> signatureName{};
  shared_ptr<string> signatureSecret{};

  ModifySignatureRequest() {}

  explicit ModifySignatureRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (signatureId) {
      res["SignatureId"] = boost::any(*signatureId);
    }
    if (signatureKey) {
      res["SignatureKey"] = boost::any(*signatureKey);
    }
    if (signatureName) {
      res["SignatureName"] = boost::any(*signatureName);
    }
    if (signatureSecret) {
      res["SignatureSecret"] = boost::any(*signatureSecret);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("SignatureId") != m.end() && !m["SignatureId"].empty()) {
      signatureId = make_shared<string>(boost::any_cast<string>(m["SignatureId"]));
    }
    if (m.find("SignatureKey") != m.end() && !m["SignatureKey"].empty()) {
      signatureKey = make_shared<string>(boost::any_cast<string>(m["SignatureKey"]));
    }
    if (m.find("SignatureName") != m.end() && !m["SignatureName"].empty()) {
      signatureName = make_shared<string>(boost::any_cast<string>(m["SignatureName"]));
    }
    if (m.find("SignatureSecret") != m.end() && !m["SignatureSecret"].empty()) {
      signatureSecret = make_shared<string>(boost::any_cast<string>(m["SignatureSecret"]));
    }
  }


  virtual ~ModifySignatureRequest() = default;
};
class ModifySignatureResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> signatureId{};
  shared_ptr<string> signatureName{};

  ModifySignatureResponseBody() {}

  explicit ModifySignatureResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (signatureId) {
      res["SignatureId"] = boost::any(*signatureId);
    }
    if (signatureName) {
      res["SignatureName"] = boost::any(*signatureName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SignatureId") != m.end() && !m["SignatureId"].empty()) {
      signatureId = make_shared<string>(boost::any_cast<string>(m["SignatureId"]));
    }
    if (m.find("SignatureName") != m.end() && !m["SignatureName"].empty()) {
      signatureName = make_shared<string>(boost::any_cast<string>(m["SignatureName"]));
    }
  }


  virtual ~ModifySignatureResponseBody() = default;
};
class ModifySignatureResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ModifySignatureResponseBody> body{};

  ModifySignatureResponse() {}

  explicit ModifySignatureResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifySignatureResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifySignatureResponseBody>(model1);
      }
    }
  }


  virtual ~ModifySignatureResponse() = default;
};
class ModifyTrafficControlRequest : public Darabonba::Model {
public:
  shared_ptr<long> apiDefault{};
  shared_ptr<long> appDefault{};
  shared_ptr<string> description{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> trafficControlId{};
  shared_ptr<string> trafficControlName{};
  shared_ptr<string> trafficControlUnit{};
  shared_ptr<long> userDefault{};

  ModifyTrafficControlRequest() {}

  explicit ModifyTrafficControlRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiDefault) {
      res["ApiDefault"] = boost::any(*apiDefault);
    }
    if (appDefault) {
      res["AppDefault"] = boost::any(*appDefault);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (trafficControlId) {
      res["TrafficControlId"] = boost::any(*trafficControlId);
    }
    if (trafficControlName) {
      res["TrafficControlName"] = boost::any(*trafficControlName);
    }
    if (trafficControlUnit) {
      res["TrafficControlUnit"] = boost::any(*trafficControlUnit);
    }
    if (userDefault) {
      res["UserDefault"] = boost::any(*userDefault);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiDefault") != m.end() && !m["ApiDefault"].empty()) {
      apiDefault = make_shared<long>(boost::any_cast<long>(m["ApiDefault"]));
    }
    if (m.find("AppDefault") != m.end() && !m["AppDefault"].empty()) {
      appDefault = make_shared<long>(boost::any_cast<long>(m["AppDefault"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("TrafficControlId") != m.end() && !m["TrafficControlId"].empty()) {
      trafficControlId = make_shared<string>(boost::any_cast<string>(m["TrafficControlId"]));
    }
    if (m.find("TrafficControlName") != m.end() && !m["TrafficControlName"].empty()) {
      trafficControlName = make_shared<string>(boost::any_cast<string>(m["TrafficControlName"]));
    }
    if (m.find("TrafficControlUnit") != m.end() && !m["TrafficControlUnit"].empty()) {
      trafficControlUnit = make_shared<string>(boost::any_cast<string>(m["TrafficControlUnit"]));
    }
    if (m.find("UserDefault") != m.end() && !m["UserDefault"].empty()) {
      userDefault = make_shared<long>(boost::any_cast<long>(m["UserDefault"]));
    }
  }


  virtual ~ModifyTrafficControlRequest() = default;
};
class ModifyTrafficControlResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyTrafficControlResponseBody() {}

  explicit ModifyTrafficControlResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyTrafficControlResponseBody() = default;
};
class ModifyTrafficControlResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ModifyTrafficControlResponseBody> body{};

  ModifyTrafficControlResponse() {}

  explicit ModifyTrafficControlResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyTrafficControlResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyTrafficControlResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyTrafficControlResponse() = default;
};
class OpenApiGatewayServiceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> orderId{};
  shared_ptr<string> requestId{};

  OpenApiGatewayServiceResponseBody() {}

  explicit OpenApiGatewayServiceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (orderId) {
      res["OrderId"] = boost::any(*orderId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OrderId") != m.end() && !m["OrderId"].empty()) {
      orderId = make_shared<string>(boost::any_cast<string>(m["OrderId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~OpenApiGatewayServiceResponseBody() = default;
};
class OpenApiGatewayServiceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<OpenApiGatewayServiceResponseBody> body{};

  OpenApiGatewayServiceResponse() {}

  explicit OpenApiGatewayServiceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        OpenApiGatewayServiceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<OpenApiGatewayServiceResponseBody>(model1);
      }
    }
  }


  virtual ~OpenApiGatewayServiceResponse() = default;
};
class ReactivateDomainRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> groupId{};
  shared_ptr<string> securityToken{};

  ReactivateDomainRequest() {}

  explicit ReactivateDomainRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~ReactivateDomainRequest() = default;
};
class ReactivateDomainResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ReactivateDomainResponseBody() {}

  explicit ReactivateDomainResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ReactivateDomainResponseBody() = default;
};
class ReactivateDomainResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ReactivateDomainResponseBody> body{};

  ReactivateDomainResponse() {}

  explicit ReactivateDomainResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ReactivateDomainResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ReactivateDomainResponseBody>(model1);
      }
    }
  }


  virtual ~ReactivateDomainResponse() = default;
};
class RemoveApisAuthoritiesRequest : public Darabonba::Model {
public:
  shared_ptr<string> apiIds{};
  shared_ptr<long> appId{};
  shared_ptr<string> description{};
  shared_ptr<string> groupId{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> stageName{};

  RemoveApisAuthoritiesRequest() {}

  explicit RemoveApisAuthoritiesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiIds) {
      res["ApiIds"] = boost::any(*apiIds);
    }
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (stageName) {
      res["StageName"] = boost::any(*stageName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiIds") != m.end() && !m["ApiIds"].empty()) {
      apiIds = make_shared<string>(boost::any_cast<string>(m["ApiIds"]));
    }
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<long>(boost::any_cast<long>(m["AppId"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("StageName") != m.end() && !m["StageName"].empty()) {
      stageName = make_shared<string>(boost::any_cast<string>(m["StageName"]));
    }
  }


  virtual ~RemoveApisAuthoritiesRequest() = default;
};
class RemoveApisAuthoritiesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  RemoveApisAuthoritiesResponseBody() {}

  explicit RemoveApisAuthoritiesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RemoveApisAuthoritiesResponseBody() = default;
};
class RemoveApisAuthoritiesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<RemoveApisAuthoritiesResponseBody> body{};

  RemoveApisAuthoritiesResponse() {}

  explicit RemoveApisAuthoritiesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RemoveApisAuthoritiesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RemoveApisAuthoritiesResponseBody>(model1);
      }
    }
  }


  virtual ~RemoveApisAuthoritiesResponse() = default;
};
class RemoveAppsAuthoritiesRequest : public Darabonba::Model {
public:
  shared_ptr<string> apiId{};
  shared_ptr<string> appIds{};
  shared_ptr<string> groupId{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> stageName{};

  RemoveAppsAuthoritiesRequest() {}

  explicit RemoveAppsAuthoritiesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiId) {
      res["ApiId"] = boost::any(*apiId);
    }
    if (appIds) {
      res["AppIds"] = boost::any(*appIds);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (stageName) {
      res["StageName"] = boost::any(*stageName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiId") != m.end() && !m["ApiId"].empty()) {
      apiId = make_shared<string>(boost::any_cast<string>(m["ApiId"]));
    }
    if (m.find("AppIds") != m.end() && !m["AppIds"].empty()) {
      appIds = make_shared<string>(boost::any_cast<string>(m["AppIds"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("StageName") != m.end() && !m["StageName"].empty()) {
      stageName = make_shared<string>(boost::any_cast<string>(m["StageName"]));
    }
  }


  virtual ~RemoveAppsAuthoritiesRequest() = default;
};
class RemoveAppsAuthoritiesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  RemoveAppsAuthoritiesResponseBody() {}

  explicit RemoveAppsAuthoritiesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RemoveAppsAuthoritiesResponseBody() = default;
};
class RemoveAppsAuthoritiesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<RemoveAppsAuthoritiesResponseBody> body{};

  RemoveAppsAuthoritiesResponse() {}

  explicit RemoveAppsAuthoritiesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RemoveAppsAuthoritiesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RemoveAppsAuthoritiesResponseBody>(model1);
      }
    }
  }


  virtual ~RemoveAppsAuthoritiesResponse() = default;
};
class RemoveIpControlApisRequest : public Darabonba::Model {
public:
  shared_ptr<string> apiIds{};
  shared_ptr<string> groupId{};
  shared_ptr<string> ipControlId{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> stageName{};

  RemoveIpControlApisRequest() {}

  explicit RemoveIpControlApisRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiIds) {
      res["ApiIds"] = boost::any(*apiIds);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (ipControlId) {
      res["IpControlId"] = boost::any(*ipControlId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (stageName) {
      res["StageName"] = boost::any(*stageName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiIds") != m.end() && !m["ApiIds"].empty()) {
      apiIds = make_shared<string>(boost::any_cast<string>(m["ApiIds"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("IpControlId") != m.end() && !m["IpControlId"].empty()) {
      ipControlId = make_shared<string>(boost::any_cast<string>(m["IpControlId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("StageName") != m.end() && !m["StageName"].empty()) {
      stageName = make_shared<string>(boost::any_cast<string>(m["StageName"]));
    }
  }


  virtual ~RemoveIpControlApisRequest() = default;
};
class RemoveIpControlApisResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  RemoveIpControlApisResponseBody() {}

  explicit RemoveIpControlApisResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RemoveIpControlApisResponseBody() = default;
};
class RemoveIpControlApisResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<RemoveIpControlApisResponseBody> body{};

  RemoveIpControlApisResponse() {}

  explicit RemoveIpControlApisResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RemoveIpControlApisResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RemoveIpControlApisResponseBody>(model1);
      }
    }
  }


  virtual ~RemoveIpControlApisResponse() = default;
};
class RemoveIpControlPolicyItemRequest : public Darabonba::Model {
public:
  shared_ptr<string> ipControlId{};
  shared_ptr<string> policyItemIds{};
  shared_ptr<string> securityToken{};

  RemoveIpControlPolicyItemRequest() {}

  explicit RemoveIpControlPolicyItemRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ipControlId) {
      res["IpControlId"] = boost::any(*ipControlId);
    }
    if (policyItemIds) {
      res["PolicyItemIds"] = boost::any(*policyItemIds);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IpControlId") != m.end() && !m["IpControlId"].empty()) {
      ipControlId = make_shared<string>(boost::any_cast<string>(m["IpControlId"]));
    }
    if (m.find("PolicyItemIds") != m.end() && !m["PolicyItemIds"].empty()) {
      policyItemIds = make_shared<string>(boost::any_cast<string>(m["PolicyItemIds"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~RemoveIpControlPolicyItemRequest() = default;
};
class RemoveIpControlPolicyItemResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  RemoveIpControlPolicyItemResponseBody() {}

  explicit RemoveIpControlPolicyItemResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RemoveIpControlPolicyItemResponseBody() = default;
};
class RemoveIpControlPolicyItemResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<RemoveIpControlPolicyItemResponseBody> body{};

  RemoveIpControlPolicyItemResponse() {}

  explicit RemoveIpControlPolicyItemResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RemoveIpControlPolicyItemResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RemoveIpControlPolicyItemResponseBody>(model1);
      }
    }
  }


  virtual ~RemoveIpControlPolicyItemResponse() = default;
};
class RemoveSignatureApisRequest : public Darabonba::Model {
public:
  shared_ptr<string> apiIds{};
  shared_ptr<string> groupId{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> signatureId{};
  shared_ptr<string> stageName{};

  RemoveSignatureApisRequest() {}

  explicit RemoveSignatureApisRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiIds) {
      res["ApiIds"] = boost::any(*apiIds);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (signatureId) {
      res["SignatureId"] = boost::any(*signatureId);
    }
    if (stageName) {
      res["StageName"] = boost::any(*stageName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiIds") != m.end() && !m["ApiIds"].empty()) {
      apiIds = make_shared<string>(boost::any_cast<string>(m["ApiIds"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("SignatureId") != m.end() && !m["SignatureId"].empty()) {
      signatureId = make_shared<string>(boost::any_cast<string>(m["SignatureId"]));
    }
    if (m.find("StageName") != m.end() && !m["StageName"].empty()) {
      stageName = make_shared<string>(boost::any_cast<string>(m["StageName"]));
    }
  }


  virtual ~RemoveSignatureApisRequest() = default;
};
class RemoveSignatureApisResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  RemoveSignatureApisResponseBody() {}

  explicit RemoveSignatureApisResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RemoveSignatureApisResponseBody() = default;
};
class RemoveSignatureApisResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<RemoveSignatureApisResponseBody> body{};

  RemoveSignatureApisResponse() {}

  explicit RemoveSignatureApisResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RemoveSignatureApisResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RemoveSignatureApisResponseBody>(model1);
      }
    }
  }


  virtual ~RemoveSignatureApisResponse() = default;
};
class RemoveTrafficControlApisRequest : public Darabonba::Model {
public:
  shared_ptr<string> apiIds{};
  shared_ptr<string> groupId{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> stageName{};
  shared_ptr<string> trafficControlId{};

  RemoveTrafficControlApisRequest() {}

  explicit RemoveTrafficControlApisRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiIds) {
      res["ApiIds"] = boost::any(*apiIds);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (stageName) {
      res["StageName"] = boost::any(*stageName);
    }
    if (trafficControlId) {
      res["TrafficControlId"] = boost::any(*trafficControlId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiIds") != m.end() && !m["ApiIds"].empty()) {
      apiIds = make_shared<string>(boost::any_cast<string>(m["ApiIds"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("StageName") != m.end() && !m["StageName"].empty()) {
      stageName = make_shared<string>(boost::any_cast<string>(m["StageName"]));
    }
    if (m.find("TrafficControlId") != m.end() && !m["TrafficControlId"].empty()) {
      trafficControlId = make_shared<string>(boost::any_cast<string>(m["TrafficControlId"]));
    }
  }


  virtual ~RemoveTrafficControlApisRequest() = default;
};
class RemoveTrafficControlApisResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  RemoveTrafficControlApisResponseBody() {}

  explicit RemoveTrafficControlApisResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RemoveTrafficControlApisResponseBody() = default;
};
class RemoveTrafficControlApisResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<RemoveTrafficControlApisResponseBody> body{};

  RemoveTrafficControlApisResponse() {}

  explicit RemoveTrafficControlApisResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RemoveTrafficControlApisResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RemoveTrafficControlApisResponseBody>(model1);
      }
    }
  }


  virtual ~RemoveTrafficControlApisResponse() = default;
};
class RemoveVpcAccessRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<bool> needBatchWork{};
  shared_ptr<long> port{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> vpcId{};

  RemoveVpcAccessRequest() {}

  explicit RemoveVpcAccessRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (needBatchWork) {
      res["NeedBatchWork"] = boost::any(*needBatchWork);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("NeedBatchWork") != m.end() && !m["NeedBatchWork"].empty()) {
      needBatchWork = make_shared<bool>(boost::any_cast<bool>(m["NeedBatchWork"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<long>(boost::any_cast<long>(m["Port"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
  }


  virtual ~RemoveVpcAccessRequest() = default;
};
class RemoveVpcAccessResponseBodyApisApi : public Darabonba::Model {
public:
  shared_ptr<string> apiId{};
  shared_ptr<string> groupId{};
  shared_ptr<string> stageId{};

  RemoveVpcAccessResponseBodyApisApi() {}

  explicit RemoveVpcAccessResponseBodyApisApi(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiId) {
      res["ApiId"] = boost::any(*apiId);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (stageId) {
      res["StageId"] = boost::any(*stageId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiId") != m.end() && !m["ApiId"].empty()) {
      apiId = make_shared<string>(boost::any_cast<string>(m["ApiId"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("StageId") != m.end() && !m["StageId"].empty()) {
      stageId = make_shared<string>(boost::any_cast<string>(m["StageId"]));
    }
  }


  virtual ~RemoveVpcAccessResponseBodyApisApi() = default;
};
class RemoveVpcAccessResponseBodyApis : public Darabonba::Model {
public:
  shared_ptr<vector<RemoveVpcAccessResponseBodyApisApi>> api{};

  RemoveVpcAccessResponseBodyApis() {}

  explicit RemoveVpcAccessResponseBodyApis(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (api) {
      vector<boost::any> temp1;
      for(auto item1:*api){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Api"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Api") != m.end() && !m["Api"].empty()) {
      if (typeid(vector<boost::any>) == m["Api"].type()) {
        vector<RemoveVpcAccessResponseBodyApisApi> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Api"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            RemoveVpcAccessResponseBodyApisApi model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        api = make_shared<vector<RemoveVpcAccessResponseBodyApisApi>>(expect1);
      }
    }
  }


  virtual ~RemoveVpcAccessResponseBodyApis() = default;
};
class RemoveVpcAccessResponseBody : public Darabonba::Model {
public:
  shared_ptr<RemoveVpcAccessResponseBodyApis> apis{};
  shared_ptr<string> requestId{};

  RemoveVpcAccessResponseBody() {}

  explicit RemoveVpcAccessResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apis) {
      res["Apis"] = apis ? boost::any(apis->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Apis") != m.end() && !m["Apis"].empty()) {
      if (typeid(map<string, boost::any>) == m["Apis"].type()) {
        RemoveVpcAccessResponseBodyApis model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Apis"]));
        apis = make_shared<RemoveVpcAccessResponseBodyApis>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RemoveVpcAccessResponseBody() = default;
};
class RemoveVpcAccessResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<RemoveVpcAccessResponseBody> body{};

  RemoveVpcAccessResponse() {}

  explicit RemoveVpcAccessResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RemoveVpcAccessResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RemoveVpcAccessResponseBody>(model1);
      }
    }
  }


  virtual ~RemoveVpcAccessResponse() = default;
};
class RemoveVpcAccessAndAbolishApisRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<bool> needBatchWork{};
  shared_ptr<long> port{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> vpcId{};

  RemoveVpcAccessAndAbolishApisRequest() {}

  explicit RemoveVpcAccessAndAbolishApisRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (needBatchWork) {
      res["NeedBatchWork"] = boost::any(*needBatchWork);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("NeedBatchWork") != m.end() && !m["NeedBatchWork"].empty()) {
      needBatchWork = make_shared<bool>(boost::any_cast<bool>(m["NeedBatchWork"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<long>(boost::any_cast<long>(m["Port"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
  }


  virtual ~RemoveVpcAccessAndAbolishApisRequest() = default;
};
class RemoveVpcAccessAndAbolishApisResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> operationId{};
  shared_ptr<string> requestId{};

  RemoveVpcAccessAndAbolishApisResponseBody() {}

  explicit RemoveVpcAccessAndAbolishApisResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (operationId) {
      res["OperationId"] = boost::any(*operationId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OperationId") != m.end() && !m["OperationId"].empty()) {
      operationId = make_shared<string>(boost::any_cast<string>(m["OperationId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RemoveVpcAccessAndAbolishApisResponseBody() = default;
};
class RemoveVpcAccessAndAbolishApisResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<RemoveVpcAccessAndAbolishApisResponseBody> body{};

  RemoveVpcAccessAndAbolishApisResponse() {}

  explicit RemoveVpcAccessAndAbolishApisResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RemoveVpcAccessAndAbolishApisResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RemoveVpcAccessAndAbolishApisResponseBody>(model1);
      }
    }
  }


  virtual ~RemoveVpcAccessAndAbolishApisResponse() = default;
};
class ResetAppCodeRequest : public Darabonba::Model {
public:
  shared_ptr<string> appCode{};
  shared_ptr<string> securityToken{};

  ResetAppCodeRequest() {}

  explicit ResetAppCodeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appCode) {
      res["AppCode"] = boost::any(*appCode);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppCode") != m.end() && !m["AppCode"].empty()) {
      appCode = make_shared<string>(boost::any_cast<string>(m["AppCode"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~ResetAppCodeRequest() = default;
};
class ResetAppCodeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ResetAppCodeResponseBody() {}

  explicit ResetAppCodeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ResetAppCodeResponseBody() = default;
};
class ResetAppCodeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ResetAppCodeResponseBody> body{};

  ResetAppCodeResponse() {}

  explicit ResetAppCodeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ResetAppCodeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ResetAppCodeResponseBody>(model1);
      }
    }
  }


  virtual ~ResetAppCodeResponse() = default;
};
class ResetAppSecretRequest : public Darabonba::Model {
public:
  shared_ptr<string> appKey{};
  shared_ptr<string> securityToken{};

  ResetAppSecretRequest() {}

  explicit ResetAppSecretRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appKey) {
      res["AppKey"] = boost::any(*appKey);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppKey") != m.end() && !m["AppKey"].empty()) {
      appKey = make_shared<string>(boost::any_cast<string>(m["AppKey"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~ResetAppSecretRequest() = default;
};
class ResetAppSecretResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ResetAppSecretResponseBody() {}

  explicit ResetAppSecretResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ResetAppSecretResponseBody() = default;
};
class ResetAppSecretResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ResetAppSecretResponseBody> body{};

  ResetAppSecretResponse() {}

  explicit ResetAppSecretResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ResetAppSecretResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ResetAppSecretResponseBody>(model1);
      }
    }
  }


  virtual ~ResetAppSecretResponse() = default;
};
class SdkGenerateByAppRequest : public Darabonba::Model {
public:
  shared_ptr<long> appId{};
  shared_ptr<string> language{};
  shared_ptr<string> securityToken{};

  SdkGenerateByAppRequest() {}

  explicit SdkGenerateByAppRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (language) {
      res["Language"] = boost::any(*language);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<long>(boost::any_cast<long>(m["AppId"]));
    }
    if (m.find("Language") != m.end() && !m["Language"].empty()) {
      language = make_shared<string>(boost::any_cast<string>(m["Language"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~SdkGenerateByAppRequest() = default;
};
class SdkGenerateByAppResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> downloadLink{};
  shared_ptr<string> requestId{};

  SdkGenerateByAppResponseBody() {}

  explicit SdkGenerateByAppResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (downloadLink) {
      res["DownloadLink"] = boost::any(*downloadLink);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DownloadLink") != m.end() && !m["DownloadLink"].empty()) {
      downloadLink = make_shared<string>(boost::any_cast<string>(m["DownloadLink"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SdkGenerateByAppResponseBody() = default;
};
class SdkGenerateByAppResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<SdkGenerateByAppResponseBody> body{};

  SdkGenerateByAppResponse() {}

  explicit SdkGenerateByAppResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SdkGenerateByAppResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SdkGenerateByAppResponseBody>(model1);
      }
    }
  }


  virtual ~SdkGenerateByAppResponse() = default;
};
class SdkGenerateByGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> groupId{};
  shared_ptr<string> language{};
  shared_ptr<string> securityToken{};

  SdkGenerateByGroupRequest() {}

  explicit SdkGenerateByGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (language) {
      res["Language"] = boost::any(*language);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("Language") != m.end() && !m["Language"].empty()) {
      language = make_shared<string>(boost::any_cast<string>(m["Language"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~SdkGenerateByGroupRequest() = default;
};
class SdkGenerateByGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> downloadLink{};
  shared_ptr<string> requestId{};

  SdkGenerateByGroupResponseBody() {}

  explicit SdkGenerateByGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (downloadLink) {
      res["DownloadLink"] = boost::any(*downloadLink);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DownloadLink") != m.end() && !m["DownloadLink"].empty()) {
      downloadLink = make_shared<string>(boost::any_cast<string>(m["DownloadLink"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SdkGenerateByGroupResponseBody() = default;
};
class SdkGenerateByGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<SdkGenerateByGroupResponseBody> body{};

  SdkGenerateByGroupResponse() {}

  explicit SdkGenerateByGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SdkGenerateByGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SdkGenerateByGroupResponseBody>(model1);
      }
    }
  }


  virtual ~SdkGenerateByGroupResponse() = default;
};
class SetApisAuthoritiesRequest : public Darabonba::Model {
public:
  shared_ptr<string> apiIds{};
  shared_ptr<long> appId{};
  shared_ptr<string> authValidTime{};
  shared_ptr<string> description{};
  shared_ptr<string> groupId{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> stageName{};

  SetApisAuthoritiesRequest() {}

  explicit SetApisAuthoritiesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiIds) {
      res["ApiIds"] = boost::any(*apiIds);
    }
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (authValidTime) {
      res["AuthValidTime"] = boost::any(*authValidTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (stageName) {
      res["StageName"] = boost::any(*stageName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiIds") != m.end() && !m["ApiIds"].empty()) {
      apiIds = make_shared<string>(boost::any_cast<string>(m["ApiIds"]));
    }
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<long>(boost::any_cast<long>(m["AppId"]));
    }
    if (m.find("AuthValidTime") != m.end() && !m["AuthValidTime"].empty()) {
      authValidTime = make_shared<string>(boost::any_cast<string>(m["AuthValidTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("StageName") != m.end() && !m["StageName"].empty()) {
      stageName = make_shared<string>(boost::any_cast<string>(m["StageName"]));
    }
  }


  virtual ~SetApisAuthoritiesRequest() = default;
};
class SetApisAuthoritiesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  SetApisAuthoritiesResponseBody() {}

  explicit SetApisAuthoritiesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SetApisAuthoritiesResponseBody() = default;
};
class SetApisAuthoritiesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<SetApisAuthoritiesResponseBody> body{};

  SetApisAuthoritiesResponse() {}

  explicit SetApisAuthoritiesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SetApisAuthoritiesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SetApisAuthoritiesResponseBody>(model1);
      }
    }
  }


  virtual ~SetApisAuthoritiesResponse() = default;
};
class SetAppsAuthoritiesRequest : public Darabonba::Model {
public:
  shared_ptr<string> apiId{};
  shared_ptr<string> appIds{};
  shared_ptr<string> authValidTime{};
  shared_ptr<string> description{};
  shared_ptr<string> groupId{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> stageName{};

  SetAppsAuthoritiesRequest() {}

  explicit SetAppsAuthoritiesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiId) {
      res["ApiId"] = boost::any(*apiId);
    }
    if (appIds) {
      res["AppIds"] = boost::any(*appIds);
    }
    if (authValidTime) {
      res["AuthValidTime"] = boost::any(*authValidTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (stageName) {
      res["StageName"] = boost::any(*stageName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiId") != m.end() && !m["ApiId"].empty()) {
      apiId = make_shared<string>(boost::any_cast<string>(m["ApiId"]));
    }
    if (m.find("AppIds") != m.end() && !m["AppIds"].empty()) {
      appIds = make_shared<string>(boost::any_cast<string>(m["AppIds"]));
    }
    if (m.find("AuthValidTime") != m.end() && !m["AuthValidTime"].empty()) {
      authValidTime = make_shared<string>(boost::any_cast<string>(m["AuthValidTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("StageName") != m.end() && !m["StageName"].empty()) {
      stageName = make_shared<string>(boost::any_cast<string>(m["StageName"]));
    }
  }


  virtual ~SetAppsAuthoritiesRequest() = default;
};
class SetAppsAuthoritiesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  SetAppsAuthoritiesResponseBody() {}

  explicit SetAppsAuthoritiesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SetAppsAuthoritiesResponseBody() = default;
};
class SetAppsAuthoritiesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<SetAppsAuthoritiesResponseBody> body{};

  SetAppsAuthoritiesResponse() {}

  explicit SetAppsAuthoritiesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SetAppsAuthoritiesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SetAppsAuthoritiesResponseBody>(model1);
      }
    }
  }


  virtual ~SetAppsAuthoritiesResponse() = default;
};
class SetDomainRequest : public Darabonba::Model {
public:
  shared_ptr<string> bindStageName{};
  shared_ptr<string> customDomainType{};
  shared_ptr<string> domainName{};
  shared_ptr<string> groupId{};
  shared_ptr<bool> isForce{};

  SetDomainRequest() {}

  explicit SetDomainRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bindStageName) {
      res["BindStageName"] = boost::any(*bindStageName);
    }
    if (customDomainType) {
      res["CustomDomainType"] = boost::any(*customDomainType);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (isForce) {
      res["IsForce"] = boost::any(*isForce);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BindStageName") != m.end() && !m["BindStageName"].empty()) {
      bindStageName = make_shared<string>(boost::any_cast<string>(m["BindStageName"]));
    }
    if (m.find("CustomDomainType") != m.end() && !m["CustomDomainType"].empty()) {
      customDomainType = make_shared<string>(boost::any_cast<string>(m["CustomDomainType"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("IsForce") != m.end() && !m["IsForce"].empty()) {
      isForce = make_shared<bool>(boost::any_cast<bool>(m["IsForce"]));
    }
  }


  virtual ~SetDomainRequest() = default;
};
class SetDomainResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> domainBindingStatus{};
  shared_ptr<string> domainLegalStatus{};
  shared_ptr<string> domainName{};
  shared_ptr<string> domainRemark{};
  shared_ptr<string> domainWebSocketStatus{};
  shared_ptr<string> groupId{};
  shared_ptr<string> requestId{};
  shared_ptr<string> subDomain{};

  SetDomainResponseBody() {}

  explicit SetDomainResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainBindingStatus) {
      res["DomainBindingStatus"] = boost::any(*domainBindingStatus);
    }
    if (domainLegalStatus) {
      res["DomainLegalStatus"] = boost::any(*domainLegalStatus);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (domainRemark) {
      res["DomainRemark"] = boost::any(*domainRemark);
    }
    if (domainWebSocketStatus) {
      res["DomainWebSocketStatus"] = boost::any(*domainWebSocketStatus);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (subDomain) {
      res["SubDomain"] = boost::any(*subDomain);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainBindingStatus") != m.end() && !m["DomainBindingStatus"].empty()) {
      domainBindingStatus = make_shared<string>(boost::any_cast<string>(m["DomainBindingStatus"]));
    }
    if (m.find("DomainLegalStatus") != m.end() && !m["DomainLegalStatus"].empty()) {
      domainLegalStatus = make_shared<string>(boost::any_cast<string>(m["DomainLegalStatus"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("DomainRemark") != m.end() && !m["DomainRemark"].empty()) {
      domainRemark = make_shared<string>(boost::any_cast<string>(m["DomainRemark"]));
    }
    if (m.find("DomainWebSocketStatus") != m.end() && !m["DomainWebSocketStatus"].empty()) {
      domainWebSocketStatus = make_shared<string>(boost::any_cast<string>(m["DomainWebSocketStatus"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SubDomain") != m.end() && !m["SubDomain"].empty()) {
      subDomain = make_shared<string>(boost::any_cast<string>(m["SubDomain"]));
    }
  }


  virtual ~SetDomainResponseBody() = default;
};
class SetDomainResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<SetDomainResponseBody> body{};

  SetDomainResponse() {}

  explicit SetDomainResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SetDomainResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SetDomainResponseBody>(model1);
      }
    }
  }


  virtual ~SetDomainResponse() = default;
};
class SetDomainCertificateRequest : public Darabonba::Model {
public:
  shared_ptr<string> caCertificateBody{};
  shared_ptr<string> certificateBody{};
  shared_ptr<string> certificateName{};
  shared_ptr<string> certificatePrivateKey{};
  shared_ptr<string> domainName{};
  shared_ptr<string> groupId{};
  shared_ptr<string> securityToken{};

  SetDomainCertificateRequest() {}

  explicit SetDomainCertificateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (caCertificateBody) {
      res["CaCertificateBody"] = boost::any(*caCertificateBody);
    }
    if (certificateBody) {
      res["CertificateBody"] = boost::any(*certificateBody);
    }
    if (certificateName) {
      res["CertificateName"] = boost::any(*certificateName);
    }
    if (certificatePrivateKey) {
      res["CertificatePrivateKey"] = boost::any(*certificatePrivateKey);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CaCertificateBody") != m.end() && !m["CaCertificateBody"].empty()) {
      caCertificateBody = make_shared<string>(boost::any_cast<string>(m["CaCertificateBody"]));
    }
    if (m.find("CertificateBody") != m.end() && !m["CertificateBody"].empty()) {
      certificateBody = make_shared<string>(boost::any_cast<string>(m["CertificateBody"]));
    }
    if (m.find("CertificateName") != m.end() && !m["CertificateName"].empty()) {
      certificateName = make_shared<string>(boost::any_cast<string>(m["CertificateName"]));
    }
    if (m.find("CertificatePrivateKey") != m.end() && !m["CertificatePrivateKey"].empty()) {
      certificatePrivateKey = make_shared<string>(boost::any_cast<string>(m["CertificatePrivateKey"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~SetDomainCertificateRequest() = default;
};
class SetDomainCertificateResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  SetDomainCertificateResponseBody() {}

  explicit SetDomainCertificateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SetDomainCertificateResponseBody() = default;
};
class SetDomainCertificateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<SetDomainCertificateResponseBody> body{};

  SetDomainCertificateResponse() {}

  explicit SetDomainCertificateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SetDomainCertificateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SetDomainCertificateResponseBody>(model1);
      }
    }
  }


  virtual ~SetDomainCertificateResponse() = default;
};
class SetDomainWebSocketStatusRequest : public Darabonba::Model {
public:
  shared_ptr<string> actionValue{};
  shared_ptr<string> domainName{};
  shared_ptr<string> groupId{};
  shared_ptr<string> securityToken{};

  SetDomainWebSocketStatusRequest() {}

  explicit SetDomainWebSocketStatusRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (actionValue) {
      res["ActionValue"] = boost::any(*actionValue);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ActionValue") != m.end() && !m["ActionValue"].empty()) {
      actionValue = make_shared<string>(boost::any_cast<string>(m["ActionValue"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~SetDomainWebSocketStatusRequest() = default;
};
class SetDomainWebSocketStatusResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  SetDomainWebSocketStatusResponseBody() {}

  explicit SetDomainWebSocketStatusResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SetDomainWebSocketStatusResponseBody() = default;
};
class SetDomainWebSocketStatusResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<SetDomainWebSocketStatusResponseBody> body{};

  SetDomainWebSocketStatusResponse() {}

  explicit SetDomainWebSocketStatusResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SetDomainWebSocketStatusResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SetDomainWebSocketStatusResponseBody>(model1);
      }
    }
  }


  virtual ~SetDomainWebSocketStatusResponse() = default;
};
class SetIpControlApisRequest : public Darabonba::Model {
public:
  shared_ptr<string> apiIds{};
  shared_ptr<string> groupId{};
  shared_ptr<string> ipControlId{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> stageName{};

  SetIpControlApisRequest() {}

  explicit SetIpControlApisRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiIds) {
      res["ApiIds"] = boost::any(*apiIds);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (ipControlId) {
      res["IpControlId"] = boost::any(*ipControlId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (stageName) {
      res["StageName"] = boost::any(*stageName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiIds") != m.end() && !m["ApiIds"].empty()) {
      apiIds = make_shared<string>(boost::any_cast<string>(m["ApiIds"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("IpControlId") != m.end() && !m["IpControlId"].empty()) {
      ipControlId = make_shared<string>(boost::any_cast<string>(m["IpControlId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("StageName") != m.end() && !m["StageName"].empty()) {
      stageName = make_shared<string>(boost::any_cast<string>(m["StageName"]));
    }
  }


  virtual ~SetIpControlApisRequest() = default;
};
class SetIpControlApisResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  SetIpControlApisResponseBody() {}

  explicit SetIpControlApisResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SetIpControlApisResponseBody() = default;
};
class SetIpControlApisResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<SetIpControlApisResponseBody> body{};

  SetIpControlApisResponse() {}

  explicit SetIpControlApisResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SetIpControlApisResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SetIpControlApisResponseBody>(model1);
      }
    }
  }


  virtual ~SetIpControlApisResponse() = default;
};
class SetSignatureApisRequest : public Darabonba::Model {
public:
  shared_ptr<string> apiIds{};
  shared_ptr<string> groupId{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> signatureId{};
  shared_ptr<string> stageName{};

  SetSignatureApisRequest() {}

  explicit SetSignatureApisRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiIds) {
      res["ApiIds"] = boost::any(*apiIds);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (signatureId) {
      res["SignatureId"] = boost::any(*signatureId);
    }
    if (stageName) {
      res["StageName"] = boost::any(*stageName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiIds") != m.end() && !m["ApiIds"].empty()) {
      apiIds = make_shared<string>(boost::any_cast<string>(m["ApiIds"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("SignatureId") != m.end() && !m["SignatureId"].empty()) {
      signatureId = make_shared<string>(boost::any_cast<string>(m["SignatureId"]));
    }
    if (m.find("StageName") != m.end() && !m["StageName"].empty()) {
      stageName = make_shared<string>(boost::any_cast<string>(m["StageName"]));
    }
  }


  virtual ~SetSignatureApisRequest() = default;
};
class SetSignatureApisResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  SetSignatureApisResponseBody() {}

  explicit SetSignatureApisResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SetSignatureApisResponseBody() = default;
};
class SetSignatureApisResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<SetSignatureApisResponseBody> body{};

  SetSignatureApisResponse() {}

  explicit SetSignatureApisResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SetSignatureApisResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SetSignatureApisResponseBody>(model1);
      }
    }
  }


  virtual ~SetSignatureApisResponse() = default;
};
class SetTrafficControlApisRequest : public Darabonba::Model {
public:
  shared_ptr<string> apiIds{};
  shared_ptr<string> groupId{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> stageName{};
  shared_ptr<string> trafficControlId{};

  SetTrafficControlApisRequest() {}

  explicit SetTrafficControlApisRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiIds) {
      res["ApiIds"] = boost::any(*apiIds);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (stageName) {
      res["StageName"] = boost::any(*stageName);
    }
    if (trafficControlId) {
      res["TrafficControlId"] = boost::any(*trafficControlId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiIds") != m.end() && !m["ApiIds"].empty()) {
      apiIds = make_shared<string>(boost::any_cast<string>(m["ApiIds"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("StageName") != m.end() && !m["StageName"].empty()) {
      stageName = make_shared<string>(boost::any_cast<string>(m["StageName"]));
    }
    if (m.find("TrafficControlId") != m.end() && !m["TrafficControlId"].empty()) {
      trafficControlId = make_shared<string>(boost::any_cast<string>(m["TrafficControlId"]));
    }
  }


  virtual ~SetTrafficControlApisRequest() = default;
};
class SetTrafficControlApisResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  SetTrafficControlApisResponseBody() {}

  explicit SetTrafficControlApisResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SetTrafficControlApisResponseBody() = default;
};
class SetTrafficControlApisResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<SetTrafficControlApisResponseBody> body{};

  SetTrafficControlApisResponse() {}

  explicit SetTrafficControlApisResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SetTrafficControlApisResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SetTrafficControlApisResponseBody>(model1);
      }
    }
  }


  virtual ~SetTrafficControlApisResponse() = default;
};
class SetVpcAccessRequest : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> name{};
  shared_ptr<long> port{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> vpcId{};

  SetVpcAccessRequest() {}

  explicit SetVpcAccessRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<long>(boost::any_cast<long>(m["Port"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
  }


  virtual ~SetVpcAccessRequest() = default;
};
class SetVpcAccessResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  SetVpcAccessResponseBody() {}

  explicit SetVpcAccessResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SetVpcAccessResponseBody() = default;
};
class SetVpcAccessResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<SetVpcAccessResponseBody> body{};

  SetVpcAccessResponse() {}

  explicit SetVpcAccessResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SetVpcAccessResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SetVpcAccessResponseBody>(model1);
      }
    }
  }


  virtual ~SetVpcAccessResponse() = default;
};
class SetWildcardDomainPatternsRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> groupId{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> wildcardDomainPatterns{};

  SetWildcardDomainPatternsRequest() {}

  explicit SetWildcardDomainPatternsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (wildcardDomainPatterns) {
      res["WildcardDomainPatterns"] = boost::any(*wildcardDomainPatterns);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("WildcardDomainPatterns") != m.end() && !m["WildcardDomainPatterns"].empty()) {
      wildcardDomainPatterns = make_shared<string>(boost::any_cast<string>(m["WildcardDomainPatterns"]));
    }
  }


  virtual ~SetWildcardDomainPatternsRequest() = default;
};
class SetWildcardDomainPatternsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  SetWildcardDomainPatternsResponseBody() {}

  explicit SetWildcardDomainPatternsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SetWildcardDomainPatternsResponseBody() = default;
};
class SetWildcardDomainPatternsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<SetWildcardDomainPatternsResponseBody> body{};

  SetWildcardDomainPatternsResponse() {}

  explicit SetWildcardDomainPatternsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SetWildcardDomainPatternsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SetWildcardDomainPatternsResponseBody>(model1);
      }
    }
  }


  virtual ~SetWildcardDomainPatternsResponse() = default;
};
class SwitchApiRequest : public Darabonba::Model {
public:
  shared_ptr<string> apiId{};
  shared_ptr<string> description{};
  shared_ptr<string> groupId{};
  shared_ptr<string> historyVersion{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> stageName{};

  SwitchApiRequest() {}

  explicit SwitchApiRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiId) {
      res["ApiId"] = boost::any(*apiId);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (historyVersion) {
      res["HistoryVersion"] = boost::any(*historyVersion);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (stageName) {
      res["StageName"] = boost::any(*stageName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiId") != m.end() && !m["ApiId"].empty()) {
      apiId = make_shared<string>(boost::any_cast<string>(m["ApiId"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("HistoryVersion") != m.end() && !m["HistoryVersion"].empty()) {
      historyVersion = make_shared<string>(boost::any_cast<string>(m["HistoryVersion"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("StageName") != m.end() && !m["StageName"].empty()) {
      stageName = make_shared<string>(boost::any_cast<string>(m["StageName"]));
    }
  }


  virtual ~SwitchApiRequest() = default;
};
class SwitchApiResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  SwitchApiResponseBody() {}

  explicit SwitchApiResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SwitchApiResponseBody() = default;
};
class SwitchApiResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<SwitchApiResponseBody> body{};

  SwitchApiResponse() {}

  explicit SwitchApiResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SwitchApiResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SwitchApiResponseBody>(model1);
      }
    }
  }


  virtual ~SwitchApiResponse() = default;
};
class TagResourcesRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  TagResourcesRequestTag() {}

  explicit TagResourcesRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~TagResourcesRequestTag() = default;
};
class TagResourcesRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> resourceId{};
  shared_ptr<string> resourceType{};
  shared_ptr<string> securityToken{};
  shared_ptr<vector<TagResourcesRequestTag>> tag{};

  TagResourcesRequest() {}

  explicit TagResourcesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ResourceId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ResourceId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      resourceId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<TagResourcesRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            TagResourcesRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<TagResourcesRequestTag>>(expect1);
      }
    }
  }


  virtual ~TagResourcesRequest() = default;
};
class TagResourcesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  TagResourcesResponseBody() {}

  explicit TagResourcesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~TagResourcesResponseBody() = default;
};
class TagResourcesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<TagResourcesResponseBody> body{};

  TagResourcesResponse() {}

  explicit TagResourcesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        TagResourcesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<TagResourcesResponseBody>(model1);
      }
    }
  }


  virtual ~TagResourcesResponse() = default;
};
class UntagResourcesRequest : public Darabonba::Model {
public:
  shared_ptr<bool> all{};
  shared_ptr<vector<string>> resourceId{};
  shared_ptr<string> resourceType{};
  shared_ptr<string> securityToken{};
  shared_ptr<vector<string>> tagKey{};

  UntagResourcesRequest() {}

  explicit UntagResourcesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (all) {
      res["All"] = boost::any(*all);
    }
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (tagKey) {
      res["TagKey"] = boost::any(*tagKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("All") != m.end() && !m["All"].empty()) {
      all = make_shared<bool>(boost::any_cast<bool>(m["All"]));
    }
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ResourceId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ResourceId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      resourceId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("TagKey") != m.end() && !m["TagKey"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["TagKey"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["TagKey"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      tagKey = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~UntagResourcesRequest() = default;
};
class UntagResourcesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UntagResourcesResponseBody() {}

  explicit UntagResourcesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UntagResourcesResponseBody() = default;
};
class UntagResourcesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<UntagResourcesResponseBody> body{};

  UntagResourcesResponse() {}

  explicit UntagResourcesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UntagResourcesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UntagResourcesResponseBody>(model1);
      }
    }
  }


  virtual ~UntagResourcesResponse() = default;
};
class Client : Alibabacloud_OpenApi::Client {
public:
  explicit Client(const shared_ptr<Alibabacloud_OpenApi::Config>& config);
  string getEndpoint(shared_ptr<string> productId,
                     shared_ptr<string> regionId,
                     shared_ptr<string> endpointRule,
                     shared_ptr<string> network,
                     shared_ptr<string> suffix,
                     shared_ptr<map<string, string>> endpointMap,
                     shared_ptr<string> endpoint);
  AbolishApiResponse abolishApiWithOptions(shared_ptr<AbolishApiRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AbolishApiResponse abolishApi(shared_ptr<AbolishApiRequest> request);
  AddIpControlPolicyItemResponse addIpControlPolicyItemWithOptions(shared_ptr<AddIpControlPolicyItemRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddIpControlPolicyItemResponse addIpControlPolicyItem(shared_ptr<AddIpControlPolicyItemRequest> request);
  AddTrafficSpecialControlResponse addTrafficSpecialControlWithOptions(shared_ptr<AddTrafficSpecialControlRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddTrafficSpecialControlResponse addTrafficSpecialControl(shared_ptr<AddTrafficSpecialControlRequest> request);
  AttachPluginResponse attachPluginWithOptions(shared_ptr<AttachPluginRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AttachPluginResponse attachPlugin(shared_ptr<AttachPluginRequest> request);
  BatchAbolishApisResponse batchAbolishApisWithOptions(shared_ptr<BatchAbolishApisRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  BatchAbolishApisResponse batchAbolishApis(shared_ptr<BatchAbolishApisRequest> request);
  BatchDeployApisResponse batchDeployApisWithOptions(shared_ptr<BatchDeployApisRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  BatchDeployApisResponse batchDeployApis(shared_ptr<BatchDeployApisRequest> request);
  CreateApiResponse createApiWithOptions(shared_ptr<CreateApiRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateApiResponse createApi(shared_ptr<CreateApiRequest> request);
  CreateApiGroupResponse createApiGroupWithOptions(shared_ptr<CreateApiGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateApiGroupResponse createApiGroup(shared_ptr<CreateApiGroupRequest> request);
  CreateApiStageVariableResponse createApiStageVariableWithOptions(shared_ptr<CreateApiStageVariableRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateApiStageVariableResponse createApiStageVariable(shared_ptr<CreateApiStageVariableRequest> request);
  CreateAppResponse createAppWithOptions(shared_ptr<CreateAppRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateAppResponse createApp(shared_ptr<CreateAppRequest> request);
  CreateInstanceResponse createInstanceWithOptions(shared_ptr<CreateInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateInstanceResponse createInstance(shared_ptr<CreateInstanceRequest> request);
  CreateIntranetDomainResponse createIntranetDomainWithOptions(shared_ptr<CreateIntranetDomainRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateIntranetDomainResponse createIntranetDomain(shared_ptr<CreateIntranetDomainRequest> request);
  CreateIpControlResponse createIpControlWithOptions(shared_ptr<CreateIpControlRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateIpControlResponse createIpControl(shared_ptr<CreateIpControlRequest> request);
  CreateLogConfigResponse createLogConfigWithOptions(shared_ptr<CreateLogConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateLogConfigResponse createLogConfig(shared_ptr<CreateLogConfigRequest> request);
  CreateModelResponse createModelWithOptions(shared_ptr<CreateModelRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateModelResponse createModel(shared_ptr<CreateModelRequest> request);
  CreateMonitorGroupResponse createMonitorGroupWithOptions(shared_ptr<CreateMonitorGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateMonitorGroupResponse createMonitorGroup(shared_ptr<CreateMonitorGroupRequest> request);
  CreatePluginResponse createPluginWithOptions(shared_ptr<CreatePluginRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreatePluginResponse createPlugin(shared_ptr<CreatePluginRequest> request);
  CreateSignatureResponse createSignatureWithOptions(shared_ptr<CreateSignatureRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateSignatureResponse createSignature(shared_ptr<CreateSignatureRequest> request);
  CreateTrafficControlResponse createTrafficControlWithOptions(shared_ptr<CreateTrafficControlRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateTrafficControlResponse createTrafficControl(shared_ptr<CreateTrafficControlRequest> request);
  DeleteAllTrafficSpecialControlResponse deleteAllTrafficSpecialControlWithOptions(shared_ptr<DeleteAllTrafficSpecialControlRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteAllTrafficSpecialControlResponse deleteAllTrafficSpecialControl(shared_ptr<DeleteAllTrafficSpecialControlRequest> request);
  DeleteApiResponse deleteApiWithOptions(shared_ptr<DeleteApiRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteApiResponse deleteApi(shared_ptr<DeleteApiRequest> request);
  DeleteApiGroupResponse deleteApiGroupWithOptions(shared_ptr<DeleteApiGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteApiGroupResponse deleteApiGroup(shared_ptr<DeleteApiGroupRequest> request);
  DeleteApiStageVariableResponse deleteApiStageVariableWithOptions(shared_ptr<DeleteApiStageVariableRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteApiStageVariableResponse deleteApiStageVariable(shared_ptr<DeleteApiStageVariableRequest> request);
  DeleteAppResponse deleteAppWithOptions(shared_ptr<DeleteAppRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteAppResponse deleteApp(shared_ptr<DeleteAppRequest> request);
  DeleteDomainResponse deleteDomainWithOptions(shared_ptr<DeleteDomainRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteDomainResponse deleteDomain(shared_ptr<DeleteDomainRequest> request);
  DeleteDomainCertificateResponse deleteDomainCertificateWithOptions(shared_ptr<DeleteDomainCertificateRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteDomainCertificateResponse deleteDomainCertificate(shared_ptr<DeleteDomainCertificateRequest> request);
  DeleteInstanceResponse deleteInstanceWithOptions(shared_ptr<DeleteInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteInstanceResponse deleteInstance(shared_ptr<DeleteInstanceRequest> request);
  DeleteIpControlResponse deleteIpControlWithOptions(shared_ptr<DeleteIpControlRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteIpControlResponse deleteIpControl(shared_ptr<DeleteIpControlRequest> request);
  DeleteLogConfigResponse deleteLogConfigWithOptions(shared_ptr<DeleteLogConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteLogConfigResponse deleteLogConfig(shared_ptr<DeleteLogConfigRequest> request);
  DeleteModelResponse deleteModelWithOptions(shared_ptr<DeleteModelRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteModelResponse deleteModel(shared_ptr<DeleteModelRequest> request);
  DeletePluginResponse deletePluginWithOptions(shared_ptr<DeletePluginRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeletePluginResponse deletePlugin(shared_ptr<DeletePluginRequest> request);
  DeleteSignatureResponse deleteSignatureWithOptions(shared_ptr<DeleteSignatureRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteSignatureResponse deleteSignature(shared_ptr<DeleteSignatureRequest> request);
  DeleteTrafficControlResponse deleteTrafficControlWithOptions(shared_ptr<DeleteTrafficControlRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteTrafficControlResponse deleteTrafficControl(shared_ptr<DeleteTrafficControlRequest> request);
  DeleteTrafficSpecialControlResponse deleteTrafficSpecialControlWithOptions(shared_ptr<DeleteTrafficSpecialControlRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteTrafficSpecialControlResponse deleteTrafficSpecialControl(shared_ptr<DeleteTrafficSpecialControlRequest> request);
  DeployApiResponse deployApiWithOptions(shared_ptr<DeployApiRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeployApiResponse deployApi(shared_ptr<DeployApiRequest> request);
  DescribeAbolishApiTaskResponse describeAbolishApiTaskWithOptions(shared_ptr<DescribeAbolishApiTaskRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeAbolishApiTaskResponse describeAbolishApiTask(shared_ptr<DescribeAbolishApiTaskRequest> request);
  DescribeApiResponse describeApiWithOptions(shared_ptr<DescribeApiRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeApiResponse describeApi(shared_ptr<DescribeApiRequest> request);
  DescribeApiDocResponse describeApiDocWithOptions(shared_ptr<DescribeApiDocRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeApiDocResponse describeApiDoc(shared_ptr<DescribeApiDocRequest> request);
  DescribeApiGroupResponse describeApiGroupWithOptions(shared_ptr<DescribeApiGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeApiGroupResponse describeApiGroup(shared_ptr<DescribeApiGroupRequest> request);
  DescribeApiGroupVpcWhitelistResponse describeApiGroupVpcWhitelistWithOptions(shared_ptr<DescribeApiGroupVpcWhitelistRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeApiGroupVpcWhitelistResponse describeApiGroupVpcWhitelist(shared_ptr<DescribeApiGroupVpcWhitelistRequest> request);
  DescribeApiGroupsResponse describeApiGroupsWithOptions(shared_ptr<DescribeApiGroupsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeApiGroupsResponse describeApiGroups(shared_ptr<DescribeApiGroupsRequest> request);
  DescribeApiHistoriesResponse describeApiHistoriesWithOptions(shared_ptr<DescribeApiHistoriesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeApiHistoriesResponse describeApiHistories(shared_ptr<DescribeApiHistoriesRequest> request);
  DescribeApiHistoryResponse describeApiHistoryWithOptions(shared_ptr<DescribeApiHistoryRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeApiHistoryResponse describeApiHistory(shared_ptr<DescribeApiHistoryRequest> request);
  DescribeApiIpControlsResponse describeApiIpControlsWithOptions(shared_ptr<DescribeApiIpControlsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeApiIpControlsResponse describeApiIpControls(shared_ptr<DescribeApiIpControlsRequest> request);
  DescribeApiLatencyDataResponse describeApiLatencyDataWithOptions(shared_ptr<DescribeApiLatencyDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeApiLatencyDataResponse describeApiLatencyData(shared_ptr<DescribeApiLatencyDataRequest> request);
  DescribeApiMarketAttributesResponse describeApiMarketAttributesWithOptions(shared_ptr<DescribeApiMarketAttributesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeApiMarketAttributesResponse describeApiMarketAttributes(shared_ptr<DescribeApiMarketAttributesRequest> request);
  DescribeApiQpsDataResponse describeApiQpsDataWithOptions(shared_ptr<DescribeApiQpsDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeApiQpsDataResponse describeApiQpsData(shared_ptr<DescribeApiQpsDataRequest> request);
  DescribeApiSignaturesResponse describeApiSignaturesWithOptions(shared_ptr<DescribeApiSignaturesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeApiSignaturesResponse describeApiSignatures(shared_ptr<DescribeApiSignaturesRequest> request);
  DescribeApiTrafficControlsResponse describeApiTrafficControlsWithOptions(shared_ptr<DescribeApiTrafficControlsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeApiTrafficControlsResponse describeApiTrafficControls(shared_ptr<DescribeApiTrafficControlsRequest> request);
  DescribeApiTrafficDataResponse describeApiTrafficDataWithOptions(shared_ptr<DescribeApiTrafficDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeApiTrafficDataResponse describeApiTrafficData(shared_ptr<DescribeApiTrafficDataRequest> request);
  DescribeApisResponse describeApisWithOptions(shared_ptr<DescribeApisRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeApisResponse describeApis(shared_ptr<DescribeApisRequest> request);
  DescribeApisByAppResponse describeApisByAppWithOptions(shared_ptr<DescribeApisByAppRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeApisByAppResponse describeApisByApp(shared_ptr<DescribeApisByAppRequest> request);
  DescribeApisByIpControlResponse describeApisByIpControlWithOptions(shared_ptr<DescribeApisByIpControlRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeApisByIpControlResponse describeApisByIpControl(shared_ptr<DescribeApisByIpControlRequest> request);
  DescribeApisBySignatureResponse describeApisBySignatureWithOptions(shared_ptr<DescribeApisBySignatureRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeApisBySignatureResponse describeApisBySignature(shared_ptr<DescribeApisBySignatureRequest> request);
  DescribeApisByTrafficControlResponse describeApisByTrafficControlWithOptions(shared_ptr<DescribeApisByTrafficControlRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeApisByTrafficControlResponse describeApisByTrafficControl(shared_ptr<DescribeApisByTrafficControlRequest> request);
  DescribeAppResponse describeAppWithOptions(shared_ptr<DescribeAppRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeAppResponse describeApp(shared_ptr<DescribeAppRequest> request);
  DescribeAppAttributesResponse describeAppAttributesWithOptions(shared_ptr<DescribeAppAttributesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeAppAttributesResponse describeAppAttributes(shared_ptr<DescribeAppAttributesRequest> request);
  DescribeAppSecurityResponse describeAppSecurityWithOptions(shared_ptr<DescribeAppSecurityRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeAppSecurityResponse describeAppSecurity(shared_ptr<DescribeAppSecurityRequest> request);
  DescribeAppsResponse describeAppsWithOptions(shared_ptr<DescribeAppsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeAppsResponse describeApps(shared_ptr<DescribeAppsRequest> request);
  DescribeAuthorizedApisResponse describeAuthorizedApisWithOptions(shared_ptr<DescribeAuthorizedApisRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeAuthorizedApisResponse describeAuthorizedApis(shared_ptr<DescribeAuthorizedApisRequest> request);
  DescribeAuthorizedAppsResponse describeAuthorizedAppsWithOptions(shared_ptr<DescribeAuthorizedAppsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeAuthorizedAppsResponse describeAuthorizedApps(shared_ptr<DescribeAuthorizedAppsRequest> request);
  DescribeDeployApiTaskResponse describeDeployApiTaskWithOptions(shared_ptr<DescribeDeployApiTaskRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDeployApiTaskResponse describeDeployApiTask(shared_ptr<DescribeDeployApiTaskRequest> request);
  DescribeDeployedApiResponse describeDeployedApiWithOptions(shared_ptr<DescribeDeployedApiRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDeployedApiResponse describeDeployedApi(shared_ptr<DescribeDeployedApiRequest> request);
  DescribeDeployedApisResponse describeDeployedApisWithOptions(shared_ptr<DescribeDeployedApisRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDeployedApisResponse describeDeployedApis(shared_ptr<DescribeDeployedApisRequest> request);
  DescribeDomainResponse describeDomainWithOptions(shared_ptr<DescribeDomainRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDomainResponse describeDomain(shared_ptr<DescribeDomainRequest> request);
  DescribeHistoryApisResponse describeHistoryApisWithOptions(shared_ptr<DescribeHistoryApisRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeHistoryApisResponse describeHistoryApis(shared_ptr<DescribeHistoryApisRequest> request);
  DescribeIpControlPolicyItemsResponse describeIpControlPolicyItemsWithOptions(shared_ptr<DescribeIpControlPolicyItemsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeIpControlPolicyItemsResponse describeIpControlPolicyItems(shared_ptr<DescribeIpControlPolicyItemsRequest> request);
  DescribeIpControlsResponse describeIpControlsWithOptions(shared_ptr<DescribeIpControlsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeIpControlsResponse describeIpControls(shared_ptr<DescribeIpControlsRequest> request);
  DescribeLogConfigResponse describeLogConfigWithOptions(shared_ptr<DescribeLogConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeLogConfigResponse describeLogConfig(shared_ptr<DescribeLogConfigRequest> request);
  DescribeMarketRemainsQuotaResponse describeMarketRemainsQuotaWithOptions(shared_ptr<DescribeMarketRemainsQuotaRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeMarketRemainsQuotaResponse describeMarketRemainsQuota(shared_ptr<DescribeMarketRemainsQuotaRequest> request);
  DescribeModelsResponse describeModelsWithOptions(shared_ptr<DescribeModelsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeModelsResponse describeModels(shared_ptr<DescribeModelsRequest> request);
  DescribePluginSchemasResponse describePluginSchemasWithOptions(shared_ptr<DescribePluginSchemasRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribePluginSchemasResponse describePluginSchemas(shared_ptr<DescribePluginSchemasRequest> request);
  DescribePluginTemplatesResponse describePluginTemplatesWithOptions(shared_ptr<DescribePluginTemplatesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribePluginTemplatesResponse describePluginTemplates(shared_ptr<DescribePluginTemplatesRequest> request);
  DescribePluginsResponse describePluginsWithOptions(shared_ptr<DescribePluginsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribePluginsResponse describePlugins(shared_ptr<DescribePluginsRequest> request);
  DescribePluginsByApiResponse describePluginsByApiWithOptions(shared_ptr<DescribePluginsByApiRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribePluginsByApiResponse describePluginsByApi(shared_ptr<DescribePluginsByApiRequest> request);
  DescribePurchasedApiGroupResponse describePurchasedApiGroupWithOptions(shared_ptr<DescribePurchasedApiGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribePurchasedApiGroupResponse describePurchasedApiGroup(shared_ptr<DescribePurchasedApiGroupRequest> request);
  DescribePurchasedApiGroupsResponse describePurchasedApiGroupsWithOptions(shared_ptr<DescribePurchasedApiGroupsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribePurchasedApiGroupsResponse describePurchasedApiGroups(shared_ptr<DescribePurchasedApiGroupsRequest> request);
  DescribePurchasedApisResponse describePurchasedApisWithOptions(shared_ptr<DescribePurchasedApisRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribePurchasedApisResponse describePurchasedApis(shared_ptr<DescribePurchasedApisRequest> request);
  DescribeRegionsResponse describeRegionsWithOptions(shared_ptr<DescribeRegionsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeRegionsResponse describeRegions(shared_ptr<DescribeRegionsRequest> request);
  DescribeSignaturesResponse describeSignaturesWithOptions(shared_ptr<DescribeSignaturesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeSignaturesResponse describeSignatures(shared_ptr<DescribeSignaturesRequest> request);
  DescribeSignaturesByApiResponse describeSignaturesByApiWithOptions(shared_ptr<DescribeSignaturesByApiRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeSignaturesByApiResponse describeSignaturesByApi(shared_ptr<DescribeSignaturesByApiRequest> request);
  DescribeSystemParametersResponse describeSystemParametersWithOptions(shared_ptr<DescribeSystemParametersRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeSystemParametersResponse describeSystemParameters(shared_ptr<DescribeSystemParametersRequest> request);
  DescribeTrafficControlsResponse describeTrafficControlsWithOptions(shared_ptr<DescribeTrafficControlsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeTrafficControlsResponse describeTrafficControls(shared_ptr<DescribeTrafficControlsRequest> request);
  DescribeTrafficControlsByApiResponse describeTrafficControlsByApiWithOptions(shared_ptr<DescribeTrafficControlsByApiRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeTrafficControlsByApiResponse describeTrafficControlsByApi(shared_ptr<DescribeTrafficControlsByApiRequest> request);
  DescribeUpdateVpcInfoTaskResponse describeUpdateVpcInfoTaskWithOptions(shared_ptr<DescribeUpdateVpcInfoTaskRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeUpdateVpcInfoTaskResponse describeUpdateVpcInfoTask(shared_ptr<DescribeUpdateVpcInfoTaskRequest> request);
  DescribeVpcAccessesResponse describeVpcAccessesWithOptions(shared_ptr<DescribeVpcAccessesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeVpcAccessesResponse describeVpcAccesses(shared_ptr<DescribeVpcAccessesRequest> request);
  DescribeZonesResponse describeZonesWithOptions(shared_ptr<DescribeZonesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeZonesResponse describeZones(shared_ptr<DescribeZonesRequest> request);
  DryRunSwaggerResponse dryRunSwaggerWithOptions(shared_ptr<DryRunSwaggerRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DryRunSwaggerResponse dryRunSwagger(shared_ptr<DryRunSwaggerRequest> request);
  ImportSwaggerResponse importSwaggerWithOptions(shared_ptr<ImportSwaggerRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ImportSwaggerResponse importSwagger(shared_ptr<ImportSwaggerRequest> request);
  ListTagResourcesResponse listTagResourcesWithOptions(shared_ptr<ListTagResourcesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListTagResourcesResponse listTagResources(shared_ptr<ListTagResourcesRequest> request);
  ModifyApiResponse modifyApiWithOptions(shared_ptr<ModifyApiRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyApiResponse modifyApi(shared_ptr<ModifyApiRequest> request);
  ModifyApiGroupResponse modifyApiGroupWithOptions(shared_ptr<ModifyApiGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyApiGroupResponse modifyApiGroup(shared_ptr<ModifyApiGroupRequest> request);
  ModifyApiGroupVpcWhitelistResponse modifyApiGroupVpcWhitelistWithOptions(shared_ptr<ModifyApiGroupVpcWhitelistRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyApiGroupVpcWhitelistResponse modifyApiGroupVpcWhitelist(shared_ptr<ModifyApiGroupVpcWhitelistRequest> request);
  ModifyAppResponse modifyAppWithOptions(shared_ptr<ModifyAppRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyAppResponse modifyApp(shared_ptr<ModifyAppRequest> request);
  ModifyInstanceSpecResponse modifyInstanceSpecWithOptions(shared_ptr<ModifyInstanceSpecRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyInstanceSpecResponse modifyInstanceSpec(shared_ptr<ModifyInstanceSpecRequest> request);
  ModifyIpControlResponse modifyIpControlWithOptions(shared_ptr<ModifyIpControlRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyIpControlResponse modifyIpControl(shared_ptr<ModifyIpControlRequest> request);
  ModifyIpControlPolicyItemResponse modifyIpControlPolicyItemWithOptions(shared_ptr<ModifyIpControlPolicyItemRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyIpControlPolicyItemResponse modifyIpControlPolicyItem(shared_ptr<ModifyIpControlPolicyItemRequest> request);
  ModifyLogConfigResponse modifyLogConfigWithOptions(shared_ptr<ModifyLogConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyLogConfigResponse modifyLogConfig(shared_ptr<ModifyLogConfigRequest> request);
  ModifyModelResponse modifyModelWithOptions(shared_ptr<ModifyModelRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyModelResponse modifyModel(shared_ptr<ModifyModelRequest> request);
  ModifyPluginResponse modifyPluginWithOptions(shared_ptr<ModifyPluginRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyPluginResponse modifyPlugin(shared_ptr<ModifyPluginRequest> request);
  ModifySignatureResponse modifySignatureWithOptions(shared_ptr<ModifySignatureRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifySignatureResponse modifySignature(shared_ptr<ModifySignatureRequest> request);
  ModifyTrafficControlResponse modifyTrafficControlWithOptions(shared_ptr<ModifyTrafficControlRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyTrafficControlResponse modifyTrafficControl(shared_ptr<ModifyTrafficControlRequest> request);
  OpenApiGatewayServiceResponse openApiGatewayServiceWithOptions(shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  OpenApiGatewayServiceResponse openApiGatewayService();
  ReactivateDomainResponse reactivateDomainWithOptions(shared_ptr<ReactivateDomainRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ReactivateDomainResponse reactivateDomain(shared_ptr<ReactivateDomainRequest> request);
  RemoveApisAuthoritiesResponse removeApisAuthoritiesWithOptions(shared_ptr<RemoveApisAuthoritiesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RemoveApisAuthoritiesResponse removeApisAuthorities(shared_ptr<RemoveApisAuthoritiesRequest> request);
  RemoveAppsAuthoritiesResponse removeAppsAuthoritiesWithOptions(shared_ptr<RemoveAppsAuthoritiesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RemoveAppsAuthoritiesResponse removeAppsAuthorities(shared_ptr<RemoveAppsAuthoritiesRequest> request);
  RemoveIpControlApisResponse removeIpControlApisWithOptions(shared_ptr<RemoveIpControlApisRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RemoveIpControlApisResponse removeIpControlApis(shared_ptr<RemoveIpControlApisRequest> request);
  RemoveIpControlPolicyItemResponse removeIpControlPolicyItemWithOptions(shared_ptr<RemoveIpControlPolicyItemRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RemoveIpControlPolicyItemResponse removeIpControlPolicyItem(shared_ptr<RemoveIpControlPolicyItemRequest> request);
  RemoveSignatureApisResponse removeSignatureApisWithOptions(shared_ptr<RemoveSignatureApisRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RemoveSignatureApisResponse removeSignatureApis(shared_ptr<RemoveSignatureApisRequest> request);
  RemoveTrafficControlApisResponse removeTrafficControlApisWithOptions(shared_ptr<RemoveTrafficControlApisRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RemoveTrafficControlApisResponse removeTrafficControlApis(shared_ptr<RemoveTrafficControlApisRequest> request);
  RemoveVpcAccessResponse removeVpcAccessWithOptions(shared_ptr<RemoveVpcAccessRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RemoveVpcAccessResponse removeVpcAccess(shared_ptr<RemoveVpcAccessRequest> request);
  RemoveVpcAccessAndAbolishApisResponse removeVpcAccessAndAbolishApisWithOptions(shared_ptr<RemoveVpcAccessAndAbolishApisRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RemoveVpcAccessAndAbolishApisResponse removeVpcAccessAndAbolishApis(shared_ptr<RemoveVpcAccessAndAbolishApisRequest> request);
  ResetAppCodeResponse resetAppCodeWithOptions(shared_ptr<ResetAppCodeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ResetAppCodeResponse resetAppCode(shared_ptr<ResetAppCodeRequest> request);
  ResetAppSecretResponse resetAppSecretWithOptions(shared_ptr<ResetAppSecretRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ResetAppSecretResponse resetAppSecret(shared_ptr<ResetAppSecretRequest> request);
  SdkGenerateByAppResponse sdkGenerateByAppWithOptions(shared_ptr<SdkGenerateByAppRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SdkGenerateByAppResponse sdkGenerateByApp(shared_ptr<SdkGenerateByAppRequest> request);
  SdkGenerateByGroupResponse sdkGenerateByGroupWithOptions(shared_ptr<SdkGenerateByGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SdkGenerateByGroupResponse sdkGenerateByGroup(shared_ptr<SdkGenerateByGroupRequest> request);
  SetApisAuthoritiesResponse setApisAuthoritiesWithOptions(shared_ptr<SetApisAuthoritiesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SetApisAuthoritiesResponse setApisAuthorities(shared_ptr<SetApisAuthoritiesRequest> request);
  SetAppsAuthoritiesResponse setAppsAuthoritiesWithOptions(shared_ptr<SetAppsAuthoritiesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SetAppsAuthoritiesResponse setAppsAuthorities(shared_ptr<SetAppsAuthoritiesRequest> request);
  SetDomainResponse setDomainWithOptions(shared_ptr<SetDomainRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SetDomainResponse setDomain(shared_ptr<SetDomainRequest> request);
  SetDomainCertificateResponse setDomainCertificateWithOptions(shared_ptr<SetDomainCertificateRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SetDomainCertificateResponse setDomainCertificate(shared_ptr<SetDomainCertificateRequest> request);
  SetDomainWebSocketStatusResponse setDomainWebSocketStatusWithOptions(shared_ptr<SetDomainWebSocketStatusRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SetDomainWebSocketStatusResponse setDomainWebSocketStatus(shared_ptr<SetDomainWebSocketStatusRequest> request);
  SetIpControlApisResponse setIpControlApisWithOptions(shared_ptr<SetIpControlApisRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SetIpControlApisResponse setIpControlApis(shared_ptr<SetIpControlApisRequest> request);
  SetSignatureApisResponse setSignatureApisWithOptions(shared_ptr<SetSignatureApisRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SetSignatureApisResponse setSignatureApis(shared_ptr<SetSignatureApisRequest> request);
  SetTrafficControlApisResponse setTrafficControlApisWithOptions(shared_ptr<SetTrafficControlApisRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SetTrafficControlApisResponse setTrafficControlApis(shared_ptr<SetTrafficControlApisRequest> request);
  SetVpcAccessResponse setVpcAccessWithOptions(shared_ptr<SetVpcAccessRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SetVpcAccessResponse setVpcAccess(shared_ptr<SetVpcAccessRequest> request);
  SetWildcardDomainPatternsResponse setWildcardDomainPatternsWithOptions(shared_ptr<SetWildcardDomainPatternsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SetWildcardDomainPatternsResponse setWildcardDomainPatterns(shared_ptr<SetWildcardDomainPatternsRequest> request);
  SwitchApiResponse switchApiWithOptions(shared_ptr<SwitchApiRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SwitchApiResponse switchApi(shared_ptr<SwitchApiRequest> request);
  TagResourcesResponse tagResourcesWithOptions(shared_ptr<TagResourcesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  TagResourcesResponse tagResources(shared_ptr<TagResourcesRequest> request);
  UntagResourcesResponse untagResourcesWithOptions(shared_ptr<UntagResourcesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UntagResourcesResponse untagResources(shared_ptr<UntagResourcesRequest> request);

  virtual ~Client() = default;
};
} // namespace Alibabacloud_CloudAPI20160714

#endif
