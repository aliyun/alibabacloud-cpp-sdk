// This file is auto-generated, don't edit it. Thanks.

#ifndef ALIBABACLOUD_CLOUDAPI20160714_H_
#define ALIBABACLOUD_CLOUDAPI20160714_H_

#include <alibabacloud/open_api.hpp>
#include <boost/any.hpp>
#include <darabonba/core.hpp>
#include <darabonba/util.hpp>
#include <iostream>
#include <map>
#include <vector>

using namespace std;

namespace Alibabacloud_CloudAPI20160714 {
class AbolishApiRequest : public Darabonba::Model {
public:
  shared_ptr<string> apiId{};
  shared_ptr<string> groupId{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> stageName{};

  AbolishApiRequest() {}

  explicit AbolishApiRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiId) {
      res["ApiId"] = boost::any(*apiId);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (stageName) {
      res["StageName"] = boost::any(*stageName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiId") != m.end() && !m["ApiId"].empty()) {
      apiId = make_shared<string>(boost::any_cast<string>(m["ApiId"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("StageName") != m.end() && !m["StageName"].empty()) {
      stageName = make_shared<string>(boost::any_cast<string>(m["StageName"]));
    }
  }


  virtual ~AbolishApiRequest() = default;
};
class AbolishApiResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  AbolishApiResponseBody() {}

  explicit AbolishApiResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AbolishApiResponseBody() = default;
};
class AbolishApiResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AbolishApiResponseBody> body{};

  AbolishApiResponse() {}

  explicit AbolishApiResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AbolishApiResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AbolishApiResponseBody>(model1);
      }
    }
  }


  virtual ~AbolishApiResponse() = default;
};
class AddAccessControlListEntryRequest : public Darabonba::Model {
public:
  shared_ptr<string> aclEntrys{};
  shared_ptr<string> aclId{};
  shared_ptr<string> securityToken{};

  AddAccessControlListEntryRequest() {}

  explicit AddAccessControlListEntryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aclEntrys) {
      res["AclEntrys"] = boost::any(*aclEntrys);
    }
    if (aclId) {
      res["AclId"] = boost::any(*aclId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AclEntrys") != m.end() && !m["AclEntrys"].empty()) {
      aclEntrys = make_shared<string>(boost::any_cast<string>(m["AclEntrys"]));
    }
    if (m.find("AclId") != m.end() && !m["AclId"].empty()) {
      aclId = make_shared<string>(boost::any_cast<string>(m["AclId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~AddAccessControlListEntryRequest() = default;
};
class AddAccessControlListEntryResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  AddAccessControlListEntryResponseBody() {}

  explicit AddAccessControlListEntryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AddAccessControlListEntryResponseBody() = default;
};
class AddAccessControlListEntryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddAccessControlListEntryResponseBody> body{};

  AddAccessControlListEntryResponse() {}

  explicit AddAccessControlListEntryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddAccessControlListEntryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddAccessControlListEntryResponseBody>(model1);
      }
    }
  }


  virtual ~AddAccessControlListEntryResponse() = default;
};
class AddIpControlPolicyItemRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> cidrIp{};
  shared_ptr<string> ipControlId{};
  shared_ptr<string> securityToken{};

  AddIpControlPolicyItemRequest() {}

  explicit AddIpControlPolicyItemRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (cidrIp) {
      res["CidrIp"] = boost::any(*cidrIp);
    }
    if (ipControlId) {
      res["IpControlId"] = boost::any(*ipControlId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("CidrIp") != m.end() && !m["CidrIp"].empty()) {
      cidrIp = make_shared<string>(boost::any_cast<string>(m["CidrIp"]));
    }
    if (m.find("IpControlId") != m.end() && !m["IpControlId"].empty()) {
      ipControlId = make_shared<string>(boost::any_cast<string>(m["IpControlId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~AddIpControlPolicyItemRequest() = default;
};
class AddIpControlPolicyItemResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> policyItemId{};
  shared_ptr<string> requestId{};

  AddIpControlPolicyItemResponseBody() {}

  explicit AddIpControlPolicyItemResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (policyItemId) {
      res["PolicyItemId"] = boost::any(*policyItemId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PolicyItemId") != m.end() && !m["PolicyItemId"].empty()) {
      policyItemId = make_shared<string>(boost::any_cast<string>(m["PolicyItemId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AddIpControlPolicyItemResponseBody() = default;
};
class AddIpControlPolicyItemResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddIpControlPolicyItemResponseBody> body{};

  AddIpControlPolicyItemResponse() {}

  explicit AddIpControlPolicyItemResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddIpControlPolicyItemResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddIpControlPolicyItemResponseBody>(model1);
      }
    }
  }


  virtual ~AddIpControlPolicyItemResponse() = default;
};
class AddTrafficSpecialControlRequest : public Darabonba::Model {
public:
  shared_ptr<string> securityToken{};
  shared_ptr<string> specialKey{};
  shared_ptr<string> specialType{};
  shared_ptr<string> trafficControlId{};
  shared_ptr<long> trafficValue{};

  AddTrafficSpecialControlRequest() {}

  explicit AddTrafficSpecialControlRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (specialKey) {
      res["SpecialKey"] = boost::any(*specialKey);
    }
    if (specialType) {
      res["SpecialType"] = boost::any(*specialType);
    }
    if (trafficControlId) {
      res["TrafficControlId"] = boost::any(*trafficControlId);
    }
    if (trafficValue) {
      res["TrafficValue"] = boost::any(*trafficValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("SpecialKey") != m.end() && !m["SpecialKey"].empty()) {
      specialKey = make_shared<string>(boost::any_cast<string>(m["SpecialKey"]));
    }
    if (m.find("SpecialType") != m.end() && !m["SpecialType"].empty()) {
      specialType = make_shared<string>(boost::any_cast<string>(m["SpecialType"]));
    }
    if (m.find("TrafficControlId") != m.end() && !m["TrafficControlId"].empty()) {
      trafficControlId = make_shared<string>(boost::any_cast<string>(m["TrafficControlId"]));
    }
    if (m.find("TrafficValue") != m.end() && !m["TrafficValue"].empty()) {
      trafficValue = make_shared<long>(boost::any_cast<long>(m["TrafficValue"]));
    }
  }


  virtual ~AddTrafficSpecialControlRequest() = default;
};
class AddTrafficSpecialControlResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  AddTrafficSpecialControlResponseBody() {}

  explicit AddTrafficSpecialControlResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AddTrafficSpecialControlResponseBody() = default;
};
class AddTrafficSpecialControlResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddTrafficSpecialControlResponseBody> body{};

  AddTrafficSpecialControlResponse() {}

  explicit AddTrafficSpecialControlResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddTrafficSpecialControlResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddTrafficSpecialControlResponseBody>(model1);
      }
    }
  }


  virtual ~AddTrafficSpecialControlResponse() = default;
};
class AttachApiProductRequestApis : public Darabonba::Model {
public:
  shared_ptr<string> apiId{};
  shared_ptr<string> stageName{};

  AttachApiProductRequestApis() {}

  explicit AttachApiProductRequestApis(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiId) {
      res["ApiId"] = boost::any(*apiId);
    }
    if (stageName) {
      res["StageName"] = boost::any(*stageName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiId") != m.end() && !m["ApiId"].empty()) {
      apiId = make_shared<string>(boost::any_cast<string>(m["ApiId"]));
    }
    if (m.find("StageName") != m.end() && !m["StageName"].empty()) {
      stageName = make_shared<string>(boost::any_cast<string>(m["StageName"]));
    }
  }


  virtual ~AttachApiProductRequestApis() = default;
};
class AttachApiProductRequest : public Darabonba::Model {
public:
  shared_ptr<string> apiProductId{};
  shared_ptr<vector<AttachApiProductRequestApis>> apis{};
  shared_ptr<string> securityToken{};

  AttachApiProductRequest() {}

  explicit AttachApiProductRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiProductId) {
      res["ApiProductId"] = boost::any(*apiProductId);
    }
    if (apis) {
      vector<boost::any> temp1;
      for(auto item1:*apis){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Apis"] = boost::any(temp1);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiProductId") != m.end() && !m["ApiProductId"].empty()) {
      apiProductId = make_shared<string>(boost::any_cast<string>(m["ApiProductId"]));
    }
    if (m.find("Apis") != m.end() && !m["Apis"].empty()) {
      if (typeid(vector<boost::any>) == m["Apis"].type()) {
        vector<AttachApiProductRequestApis> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Apis"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            AttachApiProductRequestApis model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        apis = make_shared<vector<AttachApiProductRequestApis>>(expect1);
      }
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~AttachApiProductRequest() = default;
};
class AttachApiProductResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  AttachApiProductResponseBody() {}

  explicit AttachApiProductResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AttachApiProductResponseBody() = default;
};
class AttachApiProductResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AttachApiProductResponseBody> body{};

  AttachApiProductResponse() {}

  explicit AttachApiProductResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AttachApiProductResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AttachApiProductResponseBody>(model1);
      }
    }
  }


  virtual ~AttachApiProductResponse() = default;
};
class AttachPluginRequest : public Darabonba::Model {
public:
  shared_ptr<string> apiId{};
  shared_ptr<string> apiIds{};
  shared_ptr<string> groupId{};
  shared_ptr<string> pluginId{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> stageName{};

  AttachPluginRequest() {}

  explicit AttachPluginRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiId) {
      res["ApiId"] = boost::any(*apiId);
    }
    if (apiIds) {
      res["ApiIds"] = boost::any(*apiIds);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (pluginId) {
      res["PluginId"] = boost::any(*pluginId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (stageName) {
      res["StageName"] = boost::any(*stageName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiId") != m.end() && !m["ApiId"].empty()) {
      apiId = make_shared<string>(boost::any_cast<string>(m["ApiId"]));
    }
    if (m.find("ApiIds") != m.end() && !m["ApiIds"].empty()) {
      apiIds = make_shared<string>(boost::any_cast<string>(m["ApiIds"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("PluginId") != m.end() && !m["PluginId"].empty()) {
      pluginId = make_shared<string>(boost::any_cast<string>(m["PluginId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("StageName") != m.end() && !m["StageName"].empty()) {
      stageName = make_shared<string>(boost::any_cast<string>(m["StageName"]));
    }
  }


  virtual ~AttachPluginRequest() = default;
};
class AttachPluginResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  AttachPluginResponseBody() {}

  explicit AttachPluginResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AttachPluginResponseBody() = default;
};
class AttachPluginResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AttachPluginResponseBody> body{};

  AttachPluginResponse() {}

  explicit AttachPluginResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AttachPluginResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AttachPluginResponseBody>(model1);
      }
    }
  }


  virtual ~AttachPluginResponse() = default;
};
class BatchAbolishApisRequestApi : public Darabonba::Model {
public:
  shared_ptr<string> apiUid{};
  shared_ptr<string> groupId{};
  shared_ptr<string> stageId{};
  shared_ptr<string> stageName{};

  BatchAbolishApisRequestApi() {}

  explicit BatchAbolishApisRequestApi(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiUid) {
      res["ApiUid"] = boost::any(*apiUid);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (stageId) {
      res["StageId"] = boost::any(*stageId);
    }
    if (stageName) {
      res["StageName"] = boost::any(*stageName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiUid") != m.end() && !m["ApiUid"].empty()) {
      apiUid = make_shared<string>(boost::any_cast<string>(m["ApiUid"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("StageId") != m.end() && !m["StageId"].empty()) {
      stageId = make_shared<string>(boost::any_cast<string>(m["StageId"]));
    }
    if (m.find("StageName") != m.end() && !m["StageName"].empty()) {
      stageName = make_shared<string>(boost::any_cast<string>(m["StageName"]));
    }
  }


  virtual ~BatchAbolishApisRequestApi() = default;
};
class BatchAbolishApisRequest : public Darabonba::Model {
public:
  shared_ptr<vector<BatchAbolishApisRequestApi>> api{};
  shared_ptr<string> securityToken{};

  BatchAbolishApisRequest() {}

  explicit BatchAbolishApisRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (api) {
      vector<boost::any> temp1;
      for(auto item1:*api){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Api"] = boost::any(temp1);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Api") != m.end() && !m["Api"].empty()) {
      if (typeid(vector<boost::any>) == m["Api"].type()) {
        vector<BatchAbolishApisRequestApi> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Api"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            BatchAbolishApisRequestApi model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        api = make_shared<vector<BatchAbolishApisRequestApi>>(expect1);
      }
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~BatchAbolishApisRequest() = default;
};
class BatchAbolishApisResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> operationId{};
  shared_ptr<string> requestId{};

  BatchAbolishApisResponseBody() {}

  explicit BatchAbolishApisResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (operationId) {
      res["OperationId"] = boost::any(*operationId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OperationId") != m.end() && !m["OperationId"].empty()) {
      operationId = make_shared<string>(boost::any_cast<string>(m["OperationId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~BatchAbolishApisResponseBody() = default;
};
class BatchAbolishApisResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<BatchAbolishApisResponseBody> body{};

  BatchAbolishApisResponse() {}

  explicit BatchAbolishApisResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        BatchAbolishApisResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<BatchAbolishApisResponseBody>(model1);
      }
    }
  }


  virtual ~BatchAbolishApisResponse() = default;
};
class BatchDeployApisRequestApi : public Darabonba::Model {
public:
  shared_ptr<string> apiUid{};
  shared_ptr<string> groupId{};

  BatchDeployApisRequestApi() {}

  explicit BatchDeployApisRequestApi(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiUid) {
      res["ApiUid"] = boost::any(*apiUid);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiUid") != m.end() && !m["ApiUid"].empty()) {
      apiUid = make_shared<string>(boost::any_cast<string>(m["ApiUid"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
  }


  virtual ~BatchDeployApisRequestApi() = default;
};
class BatchDeployApisRequest : public Darabonba::Model {
public:
  shared_ptr<vector<BatchDeployApisRequestApi>> api{};
  shared_ptr<string> description{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> stageName{};

  BatchDeployApisRequest() {}

  explicit BatchDeployApisRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (api) {
      vector<boost::any> temp1;
      for(auto item1:*api){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Api"] = boost::any(temp1);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (stageName) {
      res["StageName"] = boost::any(*stageName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Api") != m.end() && !m["Api"].empty()) {
      if (typeid(vector<boost::any>) == m["Api"].type()) {
        vector<BatchDeployApisRequestApi> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Api"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            BatchDeployApisRequestApi model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        api = make_shared<vector<BatchDeployApisRequestApi>>(expect1);
      }
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("StageName") != m.end() && !m["StageName"].empty()) {
      stageName = make_shared<string>(boost::any_cast<string>(m["StageName"]));
    }
  }


  virtual ~BatchDeployApisRequest() = default;
};
class BatchDeployApisResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> operationId{};
  shared_ptr<string> requestId{};

  BatchDeployApisResponseBody() {}

  explicit BatchDeployApisResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (operationId) {
      res["OperationId"] = boost::any(*operationId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OperationId") != m.end() && !m["OperationId"].empty()) {
      operationId = make_shared<string>(boost::any_cast<string>(m["OperationId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~BatchDeployApisResponseBody() = default;
};
class BatchDeployApisResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<BatchDeployApisResponseBody> body{};

  BatchDeployApisResponse() {}

  explicit BatchDeployApisResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        BatchDeployApisResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<BatchDeployApisResponseBody>(model1);
      }
    }
  }


  virtual ~BatchDeployApisResponse() = default;
};
class CreateAccessControlListRequest : public Darabonba::Model {
public:
  shared_ptr<string> aclName{};
  shared_ptr<string> addressIPVersion{};
  shared_ptr<string> securityToken{};

  CreateAccessControlListRequest() {}

  explicit CreateAccessControlListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aclName) {
      res["AclName"] = boost::any(*aclName);
    }
    if (addressIPVersion) {
      res["AddressIPVersion"] = boost::any(*addressIPVersion);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AclName") != m.end() && !m["AclName"].empty()) {
      aclName = make_shared<string>(boost::any_cast<string>(m["AclName"]));
    }
    if (m.find("AddressIPVersion") != m.end() && !m["AddressIPVersion"].empty()) {
      addressIPVersion = make_shared<string>(boost::any_cast<string>(m["AddressIPVersion"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~CreateAccessControlListRequest() = default;
};
class CreateAccessControlListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> aclId{};
  shared_ptr<string> requestId{};

  CreateAccessControlListResponseBody() {}

  explicit CreateAccessControlListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aclId) {
      res["AclId"] = boost::any(*aclId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AclId") != m.end() && !m["AclId"].empty()) {
      aclId = make_shared<string>(boost::any_cast<string>(m["AclId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateAccessControlListResponseBody() = default;
};
class CreateAccessControlListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateAccessControlListResponseBody> body{};

  CreateAccessControlListResponse() {}

  explicit CreateAccessControlListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateAccessControlListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateAccessControlListResponseBody>(model1);
      }
    }
  }


  virtual ~CreateAccessControlListResponse() = default;
};
class CreateApiRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  CreateApiRequestTag() {}

  explicit CreateApiRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~CreateApiRequestTag() = default;
};
class CreateApiRequest : public Darabonba::Model {
public:
  shared_ptr<string> allowSignatureMethod{};
  shared_ptr<string> apiName{};
  shared_ptr<string> appCodeAuthType{};
  shared_ptr<string> authType{};
  shared_ptr<bool> backendEnable{};
  shared_ptr<string> backendId{};
  shared_ptr<string> constantParameters{};
  shared_ptr<string> description{};
  shared_ptr<bool> disableInternet{};
  shared_ptr<string> errorCodeSamples{};
  shared_ptr<string> failResultSample{};
  shared_ptr<bool> forceNonceCheck{};
  shared_ptr<string> groupId{};
  shared_ptr<string> openIdConnectConfig{};
  shared_ptr<string> requestConfig{};
  shared_ptr<string> requestParameters{};
  shared_ptr<string> resultBodyModel{};
  shared_ptr<string> resultDescriptions{};
  shared_ptr<string> resultSample{};
  shared_ptr<string> resultType{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> serviceConfig{};
  shared_ptr<string> serviceParameters{};
  shared_ptr<string> serviceParametersMap{};
  shared_ptr<string> systemParameters{};
  shared_ptr<vector<CreateApiRequestTag>> tag{};
  shared_ptr<string> visibility{};
  shared_ptr<string> webSocketApiType{};

  CreateApiRequest() {}

  explicit CreateApiRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (allowSignatureMethod) {
      res["AllowSignatureMethod"] = boost::any(*allowSignatureMethod);
    }
    if (apiName) {
      res["ApiName"] = boost::any(*apiName);
    }
    if (appCodeAuthType) {
      res["AppCodeAuthType"] = boost::any(*appCodeAuthType);
    }
    if (authType) {
      res["AuthType"] = boost::any(*authType);
    }
    if (backendEnable) {
      res["BackendEnable"] = boost::any(*backendEnable);
    }
    if (backendId) {
      res["BackendId"] = boost::any(*backendId);
    }
    if (constantParameters) {
      res["ConstantParameters"] = boost::any(*constantParameters);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (disableInternet) {
      res["DisableInternet"] = boost::any(*disableInternet);
    }
    if (errorCodeSamples) {
      res["ErrorCodeSamples"] = boost::any(*errorCodeSamples);
    }
    if (failResultSample) {
      res["FailResultSample"] = boost::any(*failResultSample);
    }
    if (forceNonceCheck) {
      res["ForceNonceCheck"] = boost::any(*forceNonceCheck);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (openIdConnectConfig) {
      res["OpenIdConnectConfig"] = boost::any(*openIdConnectConfig);
    }
    if (requestConfig) {
      res["RequestConfig"] = boost::any(*requestConfig);
    }
    if (requestParameters) {
      res["RequestParameters"] = boost::any(*requestParameters);
    }
    if (resultBodyModel) {
      res["ResultBodyModel"] = boost::any(*resultBodyModel);
    }
    if (resultDescriptions) {
      res["ResultDescriptions"] = boost::any(*resultDescriptions);
    }
    if (resultSample) {
      res["ResultSample"] = boost::any(*resultSample);
    }
    if (resultType) {
      res["ResultType"] = boost::any(*resultType);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (serviceConfig) {
      res["ServiceConfig"] = boost::any(*serviceConfig);
    }
    if (serviceParameters) {
      res["ServiceParameters"] = boost::any(*serviceParameters);
    }
    if (serviceParametersMap) {
      res["ServiceParametersMap"] = boost::any(*serviceParametersMap);
    }
    if (systemParameters) {
      res["SystemParameters"] = boost::any(*systemParameters);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    if (visibility) {
      res["Visibility"] = boost::any(*visibility);
    }
    if (webSocketApiType) {
      res["WebSocketApiType"] = boost::any(*webSocketApiType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AllowSignatureMethod") != m.end() && !m["AllowSignatureMethod"].empty()) {
      allowSignatureMethod = make_shared<string>(boost::any_cast<string>(m["AllowSignatureMethod"]));
    }
    if (m.find("ApiName") != m.end() && !m["ApiName"].empty()) {
      apiName = make_shared<string>(boost::any_cast<string>(m["ApiName"]));
    }
    if (m.find("AppCodeAuthType") != m.end() && !m["AppCodeAuthType"].empty()) {
      appCodeAuthType = make_shared<string>(boost::any_cast<string>(m["AppCodeAuthType"]));
    }
    if (m.find("AuthType") != m.end() && !m["AuthType"].empty()) {
      authType = make_shared<string>(boost::any_cast<string>(m["AuthType"]));
    }
    if (m.find("BackendEnable") != m.end() && !m["BackendEnable"].empty()) {
      backendEnable = make_shared<bool>(boost::any_cast<bool>(m["BackendEnable"]));
    }
    if (m.find("BackendId") != m.end() && !m["BackendId"].empty()) {
      backendId = make_shared<string>(boost::any_cast<string>(m["BackendId"]));
    }
    if (m.find("ConstantParameters") != m.end() && !m["ConstantParameters"].empty()) {
      constantParameters = make_shared<string>(boost::any_cast<string>(m["ConstantParameters"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DisableInternet") != m.end() && !m["DisableInternet"].empty()) {
      disableInternet = make_shared<bool>(boost::any_cast<bool>(m["DisableInternet"]));
    }
    if (m.find("ErrorCodeSamples") != m.end() && !m["ErrorCodeSamples"].empty()) {
      errorCodeSamples = make_shared<string>(boost::any_cast<string>(m["ErrorCodeSamples"]));
    }
    if (m.find("FailResultSample") != m.end() && !m["FailResultSample"].empty()) {
      failResultSample = make_shared<string>(boost::any_cast<string>(m["FailResultSample"]));
    }
    if (m.find("ForceNonceCheck") != m.end() && !m["ForceNonceCheck"].empty()) {
      forceNonceCheck = make_shared<bool>(boost::any_cast<bool>(m["ForceNonceCheck"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("OpenIdConnectConfig") != m.end() && !m["OpenIdConnectConfig"].empty()) {
      openIdConnectConfig = make_shared<string>(boost::any_cast<string>(m["OpenIdConnectConfig"]));
    }
    if (m.find("RequestConfig") != m.end() && !m["RequestConfig"].empty()) {
      requestConfig = make_shared<string>(boost::any_cast<string>(m["RequestConfig"]));
    }
    if (m.find("RequestParameters") != m.end() && !m["RequestParameters"].empty()) {
      requestParameters = make_shared<string>(boost::any_cast<string>(m["RequestParameters"]));
    }
    if (m.find("ResultBodyModel") != m.end() && !m["ResultBodyModel"].empty()) {
      resultBodyModel = make_shared<string>(boost::any_cast<string>(m["ResultBodyModel"]));
    }
    if (m.find("ResultDescriptions") != m.end() && !m["ResultDescriptions"].empty()) {
      resultDescriptions = make_shared<string>(boost::any_cast<string>(m["ResultDescriptions"]));
    }
    if (m.find("ResultSample") != m.end() && !m["ResultSample"].empty()) {
      resultSample = make_shared<string>(boost::any_cast<string>(m["ResultSample"]));
    }
    if (m.find("ResultType") != m.end() && !m["ResultType"].empty()) {
      resultType = make_shared<string>(boost::any_cast<string>(m["ResultType"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("ServiceConfig") != m.end() && !m["ServiceConfig"].empty()) {
      serviceConfig = make_shared<string>(boost::any_cast<string>(m["ServiceConfig"]));
    }
    if (m.find("ServiceParameters") != m.end() && !m["ServiceParameters"].empty()) {
      serviceParameters = make_shared<string>(boost::any_cast<string>(m["ServiceParameters"]));
    }
    if (m.find("ServiceParametersMap") != m.end() && !m["ServiceParametersMap"].empty()) {
      serviceParametersMap = make_shared<string>(boost::any_cast<string>(m["ServiceParametersMap"]));
    }
    if (m.find("SystemParameters") != m.end() && !m["SystemParameters"].empty()) {
      systemParameters = make_shared<string>(boost::any_cast<string>(m["SystemParameters"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<CreateApiRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateApiRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<CreateApiRequestTag>>(expect1);
      }
    }
    if (m.find("Visibility") != m.end() && !m["Visibility"].empty()) {
      visibility = make_shared<string>(boost::any_cast<string>(m["Visibility"]));
    }
    if (m.find("WebSocketApiType") != m.end() && !m["WebSocketApiType"].empty()) {
      webSocketApiType = make_shared<string>(boost::any_cast<string>(m["WebSocketApiType"]));
    }
  }


  virtual ~CreateApiRequest() = default;
};
class CreateApiResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> apiId{};
  shared_ptr<string> requestId{};

  CreateApiResponseBody() {}

  explicit CreateApiResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiId) {
      res["ApiId"] = boost::any(*apiId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiId") != m.end() && !m["ApiId"].empty()) {
      apiId = make_shared<string>(boost::any_cast<string>(m["ApiId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateApiResponseBody() = default;
};
class CreateApiResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateApiResponseBody> body{};

  CreateApiResponse() {}

  explicit CreateApiResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateApiResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateApiResponseBody>(model1);
      }
    }
  }


  virtual ~CreateApiResponse() = default;
};
class CreateApiGroupRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  CreateApiGroupRequestTag() {}

  explicit CreateApiGroupRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~CreateApiGroupRequestTag() = default;
};
class CreateApiGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> basePath{};
  shared_ptr<string> description{};
  shared_ptr<string> groupName{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> securityToken{};
  shared_ptr<vector<CreateApiGroupRequestTag>> tag{};

  CreateApiGroupRequest() {}

  explicit CreateApiGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (basePath) {
      res["BasePath"] = boost::any(*basePath);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BasePath") != m.end() && !m["BasePath"].empty()) {
      basePath = make_shared<string>(boost::any_cast<string>(m["BasePath"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<CreateApiGroupRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateApiGroupRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<CreateApiGroupRequestTag>>(expect1);
      }
    }
  }


  virtual ~CreateApiGroupRequest() = default;
};
class CreateApiGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> basePath{};
  shared_ptr<string> description{};
  shared_ptr<string> groupId{};
  shared_ptr<string> groupName{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> instanceType{};
  shared_ptr<string> requestId{};
  shared_ptr<string> subDomain{};
  shared_ptr<bool> tagStatus{};

  CreateApiGroupResponseBody() {}

  explicit CreateApiGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (basePath) {
      res["BasePath"] = boost::any(*basePath);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (subDomain) {
      res["SubDomain"] = boost::any(*subDomain);
    }
    if (tagStatus) {
      res["TagStatus"] = boost::any(*tagStatus);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BasePath") != m.end() && !m["BasePath"].empty()) {
      basePath = make_shared<string>(boost::any_cast<string>(m["BasePath"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SubDomain") != m.end() && !m["SubDomain"].empty()) {
      subDomain = make_shared<string>(boost::any_cast<string>(m["SubDomain"]));
    }
    if (m.find("TagStatus") != m.end() && !m["TagStatus"].empty()) {
      tagStatus = make_shared<bool>(boost::any_cast<bool>(m["TagStatus"]));
    }
  }


  virtual ~CreateApiGroupResponseBody() = default;
};
class CreateApiGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateApiGroupResponseBody> body{};

  CreateApiGroupResponse() {}

  explicit CreateApiGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateApiGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateApiGroupResponseBody>(model1);
      }
    }
  }


  virtual ~CreateApiGroupResponse() = default;
};
class CreateApiStageVariableRequest : public Darabonba::Model {
public:
  shared_ptr<string> groupId{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> stageId{};
  shared_ptr<string> stageRouteModel{};
  shared_ptr<bool> supportRoute{};
  shared_ptr<string> variableName{};
  shared_ptr<string> variableValue{};

  CreateApiStageVariableRequest() {}

  explicit CreateApiStageVariableRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (stageId) {
      res["StageId"] = boost::any(*stageId);
    }
    if (stageRouteModel) {
      res["StageRouteModel"] = boost::any(*stageRouteModel);
    }
    if (supportRoute) {
      res["SupportRoute"] = boost::any(*supportRoute);
    }
    if (variableName) {
      res["VariableName"] = boost::any(*variableName);
    }
    if (variableValue) {
      res["VariableValue"] = boost::any(*variableValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("StageId") != m.end() && !m["StageId"].empty()) {
      stageId = make_shared<string>(boost::any_cast<string>(m["StageId"]));
    }
    if (m.find("StageRouteModel") != m.end() && !m["StageRouteModel"].empty()) {
      stageRouteModel = make_shared<string>(boost::any_cast<string>(m["StageRouteModel"]));
    }
    if (m.find("SupportRoute") != m.end() && !m["SupportRoute"].empty()) {
      supportRoute = make_shared<bool>(boost::any_cast<bool>(m["SupportRoute"]));
    }
    if (m.find("VariableName") != m.end() && !m["VariableName"].empty()) {
      variableName = make_shared<string>(boost::any_cast<string>(m["VariableName"]));
    }
    if (m.find("VariableValue") != m.end() && !m["VariableValue"].empty()) {
      variableValue = make_shared<string>(boost::any_cast<string>(m["VariableValue"]));
    }
  }


  virtual ~CreateApiStageVariableRequest() = default;
};
class CreateApiStageVariableResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  CreateApiStageVariableResponseBody() {}

  explicit CreateApiStageVariableResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateApiStageVariableResponseBody() = default;
};
class CreateApiStageVariableResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateApiStageVariableResponseBody> body{};

  CreateApiStageVariableResponse() {}

  explicit CreateApiStageVariableResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateApiStageVariableResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateApiStageVariableResponseBody>(model1);
      }
    }
  }


  virtual ~CreateApiStageVariableResponse() = default;
};
class CreateAppRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  CreateAppRequestTag() {}

  explicit CreateAppRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~CreateAppRequestTag() = default;
};
class CreateAppRequest : public Darabonba::Model {
public:
  shared_ptr<string> appCode{};
  shared_ptr<string> appKey{};
  shared_ptr<string> appName{};
  shared_ptr<string> appSecret{};
  shared_ptr<string> description{};
  shared_ptr<string> extend{};
  shared_ptr<string> securityToken{};
  shared_ptr<vector<CreateAppRequestTag>> tag{};

  CreateAppRequest() {}

  explicit CreateAppRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appCode) {
      res["AppCode"] = boost::any(*appCode);
    }
    if (appKey) {
      res["AppKey"] = boost::any(*appKey);
    }
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (appSecret) {
      res["AppSecret"] = boost::any(*appSecret);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (extend) {
      res["Extend"] = boost::any(*extend);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppCode") != m.end() && !m["AppCode"].empty()) {
      appCode = make_shared<string>(boost::any_cast<string>(m["AppCode"]));
    }
    if (m.find("AppKey") != m.end() && !m["AppKey"].empty()) {
      appKey = make_shared<string>(boost::any_cast<string>(m["AppKey"]));
    }
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("AppSecret") != m.end() && !m["AppSecret"].empty()) {
      appSecret = make_shared<string>(boost::any_cast<string>(m["AppSecret"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Extend") != m.end() && !m["Extend"].empty()) {
      extend = make_shared<string>(boost::any_cast<string>(m["Extend"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<CreateAppRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateAppRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<CreateAppRequestTag>>(expect1);
      }
    }
  }


  virtual ~CreateAppRequest() = default;
};
class CreateAppResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> appId{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> tagStatus{};

  CreateAppResponseBody() {}

  explicit CreateAppResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (tagStatus) {
      res["TagStatus"] = boost::any(*tagStatus);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<long>(boost::any_cast<long>(m["AppId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TagStatus") != m.end() && !m["TagStatus"].empty()) {
      tagStatus = make_shared<bool>(boost::any_cast<bool>(m["TagStatus"]));
    }
  }


  virtual ~CreateAppResponseBody() = default;
};
class CreateAppResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateAppResponseBody> body{};

  CreateAppResponse() {}

  explicit CreateAppResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateAppResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateAppResponseBody>(model1);
      }
    }
  }


  virtual ~CreateAppResponse() = default;
};
class CreateAppCodeRequest : public Darabonba::Model {
public:
  shared_ptr<string> appCode{};
  shared_ptr<string> appId{};

  CreateAppCodeRequest() {}

  explicit CreateAppCodeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appCode) {
      res["AppCode"] = boost::any(*appCode);
    }
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppCode") != m.end() && !m["AppCode"].empty()) {
      appCode = make_shared<string>(boost::any_cast<string>(m["AppCode"]));
    }
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
  }


  virtual ~CreateAppCodeRequest() = default;
};
class CreateAppCodeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  CreateAppCodeResponseBody() {}

  explicit CreateAppCodeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateAppCodeResponseBody() = default;
};
class CreateAppCodeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateAppCodeResponseBody> body{};

  CreateAppCodeResponse() {}

  explicit CreateAppCodeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateAppCodeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateAppCodeResponseBody>(model1);
      }
    }
  }


  virtual ~CreateAppCodeResponse() = default;
};
class CreateAppKeyRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> appKey{};
  shared_ptr<string> appSecret{};

  CreateAppKeyRequest() {}

  explicit CreateAppKeyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (appKey) {
      res["AppKey"] = boost::any(*appKey);
    }
    if (appSecret) {
      res["AppSecret"] = boost::any(*appSecret);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("AppKey") != m.end() && !m["AppKey"].empty()) {
      appKey = make_shared<string>(boost::any_cast<string>(m["AppKey"]));
    }
    if (m.find("AppSecret") != m.end() && !m["AppSecret"].empty()) {
      appSecret = make_shared<string>(boost::any_cast<string>(m["AppSecret"]));
    }
  }


  virtual ~CreateAppKeyRequest() = default;
};
class CreateAppKeyResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  CreateAppKeyResponseBody() {}

  explicit CreateAppKeyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateAppKeyResponseBody() = default;
};
class CreateAppKeyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateAppKeyResponseBody> body{};

  CreateAppKeyResponse() {}

  explicit CreateAppKeyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateAppKeyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateAppKeyResponseBody>(model1);
      }
    }
  }


  virtual ~CreateAppKeyResponse() = default;
};
class CreateBackendRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  CreateBackendRequestTag() {}

  explicit CreateBackendRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~CreateBackendRequestTag() = default;
};
class CreateBackendRequest : public Darabonba::Model {
public:
  shared_ptr<string> backendName{};
  shared_ptr<string> backendType{};
  shared_ptr<bool> createEventBridgeServiceLinkedRole{};
  shared_ptr<bool> createSlr{};
  shared_ptr<string> description{};
  shared_ptr<string> securityToken{};
  shared_ptr<vector<CreateBackendRequestTag>> tag{};

  CreateBackendRequest() {}

  explicit CreateBackendRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (backendName) {
      res["BackendName"] = boost::any(*backendName);
    }
    if (backendType) {
      res["BackendType"] = boost::any(*backendType);
    }
    if (createEventBridgeServiceLinkedRole) {
      res["CreateEventBridgeServiceLinkedRole"] = boost::any(*createEventBridgeServiceLinkedRole);
    }
    if (createSlr) {
      res["CreateSlr"] = boost::any(*createSlr);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BackendName") != m.end() && !m["BackendName"].empty()) {
      backendName = make_shared<string>(boost::any_cast<string>(m["BackendName"]));
    }
    if (m.find("BackendType") != m.end() && !m["BackendType"].empty()) {
      backendType = make_shared<string>(boost::any_cast<string>(m["BackendType"]));
    }
    if (m.find("CreateEventBridgeServiceLinkedRole") != m.end() && !m["CreateEventBridgeServiceLinkedRole"].empty()) {
      createEventBridgeServiceLinkedRole = make_shared<bool>(boost::any_cast<bool>(m["CreateEventBridgeServiceLinkedRole"]));
    }
    if (m.find("CreateSlr") != m.end() && !m["CreateSlr"].empty()) {
      createSlr = make_shared<bool>(boost::any_cast<bool>(m["CreateSlr"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<CreateBackendRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateBackendRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<CreateBackendRequestTag>>(expect1);
      }
    }
  }


  virtual ~CreateBackendRequest() = default;
};
class CreateBackendResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> backendId{};
  shared_ptr<string> requestId{};

  CreateBackendResponseBody() {}

  explicit CreateBackendResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (backendId) {
      res["BackendId"] = boost::any(*backendId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BackendId") != m.end() && !m["BackendId"].empty()) {
      backendId = make_shared<string>(boost::any_cast<string>(m["BackendId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateBackendResponseBody() = default;
};
class CreateBackendResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateBackendResponseBody> body{};

  CreateBackendResponse() {}

  explicit CreateBackendResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateBackendResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateBackendResponseBody>(model1);
      }
    }
  }


  virtual ~CreateBackendResponse() = default;
};
class CreateBackendModelRequest : public Darabonba::Model {
public:
  shared_ptr<string> backendId{};
  shared_ptr<string> backendModelData{};
  shared_ptr<string> backendType{};
  shared_ptr<string> description{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> stageName{};

  CreateBackendModelRequest() {}

  explicit CreateBackendModelRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (backendId) {
      res["BackendId"] = boost::any(*backendId);
    }
    if (backendModelData) {
      res["BackendModelData"] = boost::any(*backendModelData);
    }
    if (backendType) {
      res["BackendType"] = boost::any(*backendType);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (stageName) {
      res["StageName"] = boost::any(*stageName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BackendId") != m.end() && !m["BackendId"].empty()) {
      backendId = make_shared<string>(boost::any_cast<string>(m["BackendId"]));
    }
    if (m.find("BackendModelData") != m.end() && !m["BackendModelData"].empty()) {
      backendModelData = make_shared<string>(boost::any_cast<string>(m["BackendModelData"]));
    }
    if (m.find("BackendType") != m.end() && !m["BackendType"].empty()) {
      backendType = make_shared<string>(boost::any_cast<string>(m["BackendType"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("StageName") != m.end() && !m["StageName"].empty()) {
      stageName = make_shared<string>(boost::any_cast<string>(m["StageName"]));
    }
  }


  virtual ~CreateBackendModelRequest() = default;
};
class CreateBackendModelResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> backendModelId{};
  shared_ptr<string> requestId{};

  CreateBackendModelResponseBody() {}

  explicit CreateBackendModelResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (backendModelId) {
      res["BackendModelId"] = boost::any(*backendModelId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BackendModelId") != m.end() && !m["BackendModelId"].empty()) {
      backendModelId = make_shared<string>(boost::any_cast<string>(m["BackendModelId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateBackendModelResponseBody() = default;
};
class CreateBackendModelResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateBackendModelResponseBody> body{};

  CreateBackendModelResponse() {}

  explicit CreateBackendModelResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateBackendModelResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateBackendModelResponseBody>(model1);
      }
    }
  }


  virtual ~CreateBackendModelResponse() = default;
};
class CreateDatasetRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  CreateDatasetRequestTag() {}

  explicit CreateDatasetRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~CreateDatasetRequestTag() = default;
};
class CreateDatasetRequest : public Darabonba::Model {
public:
  shared_ptr<string> datasetName{};
  shared_ptr<string> datasetType{};
  shared_ptr<string> securityToken{};
  shared_ptr<vector<CreateDatasetRequestTag>> tag{};

  CreateDatasetRequest() {}

  explicit CreateDatasetRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (datasetName) {
      res["DatasetName"] = boost::any(*datasetName);
    }
    if (datasetType) {
      res["DatasetType"] = boost::any(*datasetType);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DatasetName") != m.end() && !m["DatasetName"].empty()) {
      datasetName = make_shared<string>(boost::any_cast<string>(m["DatasetName"]));
    }
    if (m.find("DatasetType") != m.end() && !m["DatasetType"].empty()) {
      datasetType = make_shared<string>(boost::any_cast<string>(m["DatasetType"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<CreateDatasetRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateDatasetRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<CreateDatasetRequestTag>>(expect1);
      }
    }
  }


  virtual ~CreateDatasetRequest() = default;
};
class CreateDatasetResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> datasetId{};
  shared_ptr<string> requestId{};

  CreateDatasetResponseBody() {}

  explicit CreateDatasetResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (datasetId) {
      res["DatasetId"] = boost::any(*datasetId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DatasetId") != m.end() && !m["DatasetId"].empty()) {
      datasetId = make_shared<string>(boost::any_cast<string>(m["DatasetId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateDatasetResponseBody() = default;
};
class CreateDatasetResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateDatasetResponseBody> body{};

  CreateDatasetResponse() {}

  explicit CreateDatasetResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateDatasetResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateDatasetResponseBody>(model1);
      }
    }
  }


  virtual ~CreateDatasetResponse() = default;
};
class CreateDatasetItemRequest : public Darabonba::Model {
public:
  shared_ptr<string> datasetId{};
  shared_ptr<string> description{};
  shared_ptr<string> expiredTime{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> value{};

  CreateDatasetItemRequest() {}

  explicit CreateDatasetItemRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (datasetId) {
      res["DatasetId"] = boost::any(*datasetId);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (expiredTime) {
      res["ExpiredTime"] = boost::any(*expiredTime);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DatasetId") != m.end() && !m["DatasetId"].empty()) {
      datasetId = make_shared<string>(boost::any_cast<string>(m["DatasetId"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("ExpiredTime") != m.end() && !m["ExpiredTime"].empty()) {
      expiredTime = make_shared<string>(boost::any_cast<string>(m["ExpiredTime"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~CreateDatasetItemRequest() = default;
};
class CreateDatasetItemResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> datasetItemId{};
  shared_ptr<string> requestId{};

  CreateDatasetItemResponseBody() {}

  explicit CreateDatasetItemResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (datasetItemId) {
      res["DatasetItemId"] = boost::any(*datasetItemId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DatasetItemId") != m.end() && !m["DatasetItemId"].empty()) {
      datasetItemId = make_shared<string>(boost::any_cast<string>(m["DatasetItemId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateDatasetItemResponseBody() = default;
};
class CreateDatasetItemResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateDatasetItemResponseBody> body{};

  CreateDatasetItemResponse() {}

  explicit CreateDatasetItemResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateDatasetItemResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateDatasetItemResponseBody>(model1);
      }
    }
  }


  virtual ~CreateDatasetItemResponse() = default;
};
class CreateInstanceRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  CreateInstanceRequestTag() {}

  explicit CreateInstanceRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~CreateInstanceRequestTag() = default;
};
class CreateInstanceRequestZoneVSwitchSecurityGroup : public Darabonba::Model {
public:
  shared_ptr<string> cidrBlock{};
  shared_ptr<string> securityGroupId{};
  shared_ptr<string> vSwitchId{};
  shared_ptr<string> zoneId{};

  CreateInstanceRequestZoneVSwitchSecurityGroup() {}

  explicit CreateInstanceRequestZoneVSwitchSecurityGroup(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cidrBlock) {
      res["CidrBlock"] = boost::any(*cidrBlock);
    }
    if (securityGroupId) {
      res["SecurityGroupId"] = boost::any(*securityGroupId);
    }
    if (vSwitchId) {
      res["VSwitchId"] = boost::any(*vSwitchId);
    }
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CidrBlock") != m.end() && !m["CidrBlock"].empty()) {
      cidrBlock = make_shared<string>(boost::any_cast<string>(m["CidrBlock"]));
    }
    if (m.find("SecurityGroupId") != m.end() && !m["SecurityGroupId"].empty()) {
      securityGroupId = make_shared<string>(boost::any_cast<string>(m["SecurityGroupId"]));
    }
    if (m.find("VSwitchId") != m.end() && !m["VSwitchId"].empty()) {
      vSwitchId = make_shared<string>(boost::any_cast<string>(m["VSwitchId"]));
    }
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["ZoneId"]));
    }
  }


  virtual ~CreateInstanceRequestZoneVSwitchSecurityGroup() = default;
};
class CreateInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<bool> autoPay{};
  shared_ptr<string> chargeType{};
  shared_ptr<long> duration{};
  shared_ptr<string> httpsPolicy{};
  shared_ptr<string> instanceCidr{};
  shared_ptr<string> instanceName{};
  shared_ptr<string> instanceSpec{};
  shared_ptr<string> instanceType{};
  shared_ptr<string> pricingCycle{};
  shared_ptr<vector<CreateInstanceRequestTag>> tag{};
  shared_ptr<string> token{};
  shared_ptr<string> userVpcId{};
  shared_ptr<string> zoneId{};
  shared_ptr<vector<CreateInstanceRequestZoneVSwitchSecurityGroup>> zoneVSwitchSecurityGroup{};

  CreateInstanceRequest() {}

  explicit CreateInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (autoPay) {
      res["AutoPay"] = boost::any(*autoPay);
    }
    if (chargeType) {
      res["ChargeType"] = boost::any(*chargeType);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (httpsPolicy) {
      res["HttpsPolicy"] = boost::any(*httpsPolicy);
    }
    if (instanceCidr) {
      res["InstanceCidr"] = boost::any(*instanceCidr);
    }
    if (instanceName) {
      res["InstanceName"] = boost::any(*instanceName);
    }
    if (instanceSpec) {
      res["InstanceSpec"] = boost::any(*instanceSpec);
    }
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (pricingCycle) {
      res["PricingCycle"] = boost::any(*pricingCycle);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    if (token) {
      res["Token"] = boost::any(*token);
    }
    if (userVpcId) {
      res["UserVpcId"] = boost::any(*userVpcId);
    }
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    if (zoneVSwitchSecurityGroup) {
      vector<boost::any> temp1;
      for(auto item1:*zoneVSwitchSecurityGroup){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ZoneVSwitchSecurityGroup"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AutoPay") != m.end() && !m["AutoPay"].empty()) {
      autoPay = make_shared<bool>(boost::any_cast<bool>(m["AutoPay"]));
    }
    if (m.find("ChargeType") != m.end() && !m["ChargeType"].empty()) {
      chargeType = make_shared<string>(boost::any_cast<string>(m["ChargeType"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<long>(boost::any_cast<long>(m["Duration"]));
    }
    if (m.find("HttpsPolicy") != m.end() && !m["HttpsPolicy"].empty()) {
      httpsPolicy = make_shared<string>(boost::any_cast<string>(m["HttpsPolicy"]));
    }
    if (m.find("InstanceCidr") != m.end() && !m["InstanceCidr"].empty()) {
      instanceCidr = make_shared<string>(boost::any_cast<string>(m["InstanceCidr"]));
    }
    if (m.find("InstanceName") != m.end() && !m["InstanceName"].empty()) {
      instanceName = make_shared<string>(boost::any_cast<string>(m["InstanceName"]));
    }
    if (m.find("InstanceSpec") != m.end() && !m["InstanceSpec"].empty()) {
      instanceSpec = make_shared<string>(boost::any_cast<string>(m["InstanceSpec"]));
    }
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("PricingCycle") != m.end() && !m["PricingCycle"].empty()) {
      pricingCycle = make_shared<string>(boost::any_cast<string>(m["PricingCycle"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<CreateInstanceRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateInstanceRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<CreateInstanceRequestTag>>(expect1);
      }
    }
    if (m.find("Token") != m.end() && !m["Token"].empty()) {
      token = make_shared<string>(boost::any_cast<string>(m["Token"]));
    }
    if (m.find("UserVpcId") != m.end() && !m["UserVpcId"].empty()) {
      userVpcId = make_shared<string>(boost::any_cast<string>(m["UserVpcId"]));
    }
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["ZoneId"]));
    }
    if (m.find("ZoneVSwitchSecurityGroup") != m.end() && !m["ZoneVSwitchSecurityGroup"].empty()) {
      if (typeid(vector<boost::any>) == m["ZoneVSwitchSecurityGroup"].type()) {
        vector<CreateInstanceRequestZoneVSwitchSecurityGroup> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ZoneVSwitchSecurityGroup"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateInstanceRequestZoneVSwitchSecurityGroup model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        zoneVSwitchSecurityGroup = make_shared<vector<CreateInstanceRequestZoneVSwitchSecurityGroup>>(expect1);
      }
    }
  }


  virtual ~CreateInstanceRequest() = default;
};
class CreateInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> tagStatus{};

  CreateInstanceResponseBody() {}

  explicit CreateInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (tagStatus) {
      res["TagStatus"] = boost::any(*tagStatus);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TagStatus") != m.end() && !m["TagStatus"].empty()) {
      tagStatus = make_shared<bool>(boost::any_cast<bool>(m["TagStatus"]));
    }
  }


  virtual ~CreateInstanceResponseBody() = default;
};
class CreateInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateInstanceResponseBody> body{};

  CreateInstanceResponse() {}

  explicit CreateInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~CreateInstanceResponse() = default;
};
class CreateIntranetDomainRequest : public Darabonba::Model {
public:
  shared_ptr<string> groupId{};
  shared_ptr<string> securityToken{};

  CreateIntranetDomainRequest() {}

  explicit CreateIntranetDomainRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~CreateIntranetDomainRequest() = default;
};
class CreateIntranetDomainResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> requestId{};

  CreateIntranetDomainResponseBody() {}

  explicit CreateIntranetDomainResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateIntranetDomainResponseBody() = default;
};
class CreateIntranetDomainResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateIntranetDomainResponseBody> body{};

  CreateIntranetDomainResponse() {}

  explicit CreateIntranetDomainResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateIntranetDomainResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateIntranetDomainResponseBody>(model1);
      }
    }
  }


  virtual ~CreateIntranetDomainResponse() = default;
};
class CreateIpControlRequestIpControlPolicys : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> cidrIp{};

  CreateIpControlRequestIpControlPolicys() {}

  explicit CreateIpControlRequestIpControlPolicys(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (cidrIp) {
      res["CidrIp"] = boost::any(*cidrIp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("CidrIp") != m.end() && !m["CidrIp"].empty()) {
      cidrIp = make_shared<string>(boost::any_cast<string>(m["CidrIp"]));
    }
  }


  virtual ~CreateIpControlRequestIpControlPolicys() = default;
};
class CreateIpControlRequest : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> ipControlName{};
  shared_ptr<vector<CreateIpControlRequestIpControlPolicys>> ipControlPolicys{};
  shared_ptr<string> ipControlType{};
  shared_ptr<string> securityToken{};

  CreateIpControlRequest() {}

  explicit CreateIpControlRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (ipControlName) {
      res["IpControlName"] = boost::any(*ipControlName);
    }
    if (ipControlPolicys) {
      vector<boost::any> temp1;
      for(auto item1:*ipControlPolicys){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["IpControlPolicys"] = boost::any(temp1);
    }
    if (ipControlType) {
      res["IpControlType"] = boost::any(*ipControlType);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("IpControlName") != m.end() && !m["IpControlName"].empty()) {
      ipControlName = make_shared<string>(boost::any_cast<string>(m["IpControlName"]));
    }
    if (m.find("IpControlPolicys") != m.end() && !m["IpControlPolicys"].empty()) {
      if (typeid(vector<boost::any>) == m["IpControlPolicys"].type()) {
        vector<CreateIpControlRequestIpControlPolicys> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["IpControlPolicys"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateIpControlRequestIpControlPolicys model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ipControlPolicys = make_shared<vector<CreateIpControlRequestIpControlPolicys>>(expect1);
      }
    }
    if (m.find("IpControlType") != m.end() && !m["IpControlType"].empty()) {
      ipControlType = make_shared<string>(boost::any_cast<string>(m["IpControlType"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~CreateIpControlRequest() = default;
};
class CreateIpControlResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> ipControlId{};
  shared_ptr<string> requestId{};

  CreateIpControlResponseBody() {}

  explicit CreateIpControlResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ipControlId) {
      res["IpControlId"] = boost::any(*ipControlId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IpControlId") != m.end() && !m["IpControlId"].empty()) {
      ipControlId = make_shared<string>(boost::any_cast<string>(m["IpControlId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateIpControlResponseBody() = default;
};
class CreateIpControlResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateIpControlResponseBody> body{};

  CreateIpControlResponse() {}

  explicit CreateIpControlResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateIpControlResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateIpControlResponseBody>(model1);
      }
    }
  }


  virtual ~CreateIpControlResponse() = default;
};
class CreateLogConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> logType{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> slsLogStore{};
  shared_ptr<string> slsProject{};

  CreateLogConfigRequest() {}

  explicit CreateLogConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (logType) {
      res["LogType"] = boost::any(*logType);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (slsLogStore) {
      res["SlsLogStore"] = boost::any(*slsLogStore);
    }
    if (slsProject) {
      res["SlsProject"] = boost::any(*slsProject);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LogType") != m.end() && !m["LogType"].empty()) {
      logType = make_shared<string>(boost::any_cast<string>(m["LogType"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("SlsLogStore") != m.end() && !m["SlsLogStore"].empty()) {
      slsLogStore = make_shared<string>(boost::any_cast<string>(m["SlsLogStore"]));
    }
    if (m.find("SlsProject") != m.end() && !m["SlsProject"].empty()) {
      slsProject = make_shared<string>(boost::any_cast<string>(m["SlsProject"]));
    }
  }


  virtual ~CreateLogConfigRequest() = default;
};
class CreateLogConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  CreateLogConfigResponseBody() {}

  explicit CreateLogConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateLogConfigResponseBody() = default;
};
class CreateLogConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateLogConfigResponseBody> body{};

  CreateLogConfigResponse() {}

  explicit CreateLogConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateLogConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateLogConfigResponseBody>(model1);
      }
    }
  }


  virtual ~CreateLogConfigResponse() = default;
};
class CreateModelRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  CreateModelRequestTag() {}

  explicit CreateModelRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~CreateModelRequestTag() = default;
};
class CreateModelRequest : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> groupId{};
  shared_ptr<string> modelName{};
  shared_ptr<string> schema{};
  shared_ptr<vector<CreateModelRequestTag>> tag{};

  CreateModelRequest() {}

  explicit CreateModelRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (modelName) {
      res["ModelName"] = boost::any(*modelName);
    }
    if (schema) {
      res["Schema"] = boost::any(*schema);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("ModelName") != m.end() && !m["ModelName"].empty()) {
      modelName = make_shared<string>(boost::any_cast<string>(m["ModelName"]));
    }
    if (m.find("Schema") != m.end() && !m["Schema"].empty()) {
      schema = make_shared<string>(boost::any_cast<string>(m["Schema"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<CreateModelRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateModelRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<CreateModelRequestTag>>(expect1);
      }
    }
  }


  virtual ~CreateModelRequest() = default;
};
class CreateModelResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> createdTime{};
  shared_ptr<string> description{};
  shared_ptr<string> groupId{};
  shared_ptr<string> modelId{};
  shared_ptr<string> modelName{};
  shared_ptr<string> modelRef{};
  shared_ptr<string> modifiedTime{};
  shared_ptr<string> regionId{};
  shared_ptr<string> requestId{};
  shared_ptr<string> schema{};

  CreateModelResponseBody() {}

  explicit CreateModelResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createdTime) {
      res["CreatedTime"] = boost::any(*createdTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (modelId) {
      res["ModelId"] = boost::any(*modelId);
    }
    if (modelName) {
      res["ModelName"] = boost::any(*modelName);
    }
    if (modelRef) {
      res["ModelRef"] = boost::any(*modelRef);
    }
    if (modifiedTime) {
      res["ModifiedTime"] = boost::any(*modifiedTime);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (schema) {
      res["Schema"] = boost::any(*schema);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreatedTime") != m.end() && !m["CreatedTime"].empty()) {
      createdTime = make_shared<string>(boost::any_cast<string>(m["CreatedTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("ModelId") != m.end() && !m["ModelId"].empty()) {
      modelId = make_shared<string>(boost::any_cast<string>(m["ModelId"]));
    }
    if (m.find("ModelName") != m.end() && !m["ModelName"].empty()) {
      modelName = make_shared<string>(boost::any_cast<string>(m["ModelName"]));
    }
    if (m.find("ModelRef") != m.end() && !m["ModelRef"].empty()) {
      modelRef = make_shared<string>(boost::any_cast<string>(m["ModelRef"]));
    }
    if (m.find("ModifiedTime") != m.end() && !m["ModifiedTime"].empty()) {
      modifiedTime = make_shared<string>(boost::any_cast<string>(m["ModifiedTime"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Schema") != m.end() && !m["Schema"].empty()) {
      schema = make_shared<string>(boost::any_cast<string>(m["Schema"]));
    }
  }


  virtual ~CreateModelResponseBody() = default;
};
class CreateModelResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateModelResponseBody> body{};

  CreateModelResponse() {}

  explicit CreateModelResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateModelResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateModelResponseBody>(model1);
      }
    }
  }


  virtual ~CreateModelResponse() = default;
};
class CreateMonitorGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> auth{};
  shared_ptr<string> groupId{};
  shared_ptr<long> rawMonitorGroupId{};
  shared_ptr<string> securityToken{};

  CreateMonitorGroupRequest() {}

  explicit CreateMonitorGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (auth) {
      res["Auth"] = boost::any(*auth);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (rawMonitorGroupId) {
      res["RawMonitorGroupId"] = boost::any(*rawMonitorGroupId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Auth") != m.end() && !m["Auth"].empty()) {
      auth = make_shared<string>(boost::any_cast<string>(m["Auth"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("RawMonitorGroupId") != m.end() && !m["RawMonitorGroupId"].empty()) {
      rawMonitorGroupId = make_shared<long>(boost::any_cast<long>(m["RawMonitorGroupId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~CreateMonitorGroupRequest() = default;
};
class CreateMonitorGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> monitorGroupId{};
  shared_ptr<string> requestId{};

  CreateMonitorGroupResponseBody() {}

  explicit CreateMonitorGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (monitorGroupId) {
      res["MonitorGroupId"] = boost::any(*monitorGroupId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MonitorGroupId") != m.end() && !m["MonitorGroupId"].empty()) {
      monitorGroupId = make_shared<long>(boost::any_cast<long>(m["MonitorGroupId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateMonitorGroupResponseBody() = default;
};
class CreateMonitorGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateMonitorGroupResponseBody> body{};

  CreateMonitorGroupResponse() {}

  explicit CreateMonitorGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateMonitorGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateMonitorGroupResponseBody>(model1);
      }
    }
  }


  virtual ~CreateMonitorGroupResponse() = default;
};
class CreatePluginRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  CreatePluginRequestTag() {}

  explicit CreatePluginRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~CreatePluginRequestTag() = default;
};
class CreatePluginRequest : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> pluginData{};
  shared_ptr<string> pluginName{};
  shared_ptr<string> pluginType{};
  shared_ptr<string> securityToken{};
  shared_ptr<vector<CreatePluginRequestTag>> tag{};

  CreatePluginRequest() {}

  explicit CreatePluginRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (pluginData) {
      res["PluginData"] = boost::any(*pluginData);
    }
    if (pluginName) {
      res["PluginName"] = boost::any(*pluginName);
    }
    if (pluginType) {
      res["PluginType"] = boost::any(*pluginType);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("PluginData") != m.end() && !m["PluginData"].empty()) {
      pluginData = make_shared<string>(boost::any_cast<string>(m["PluginData"]));
    }
    if (m.find("PluginName") != m.end() && !m["PluginName"].empty()) {
      pluginName = make_shared<string>(boost::any_cast<string>(m["PluginName"]));
    }
    if (m.find("PluginType") != m.end() && !m["PluginType"].empty()) {
      pluginType = make_shared<string>(boost::any_cast<string>(m["PluginType"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<CreatePluginRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreatePluginRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<CreatePluginRequestTag>>(expect1);
      }
    }
  }


  virtual ~CreatePluginRequest() = default;
};
class CreatePluginResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> pluginId{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> tagStatus{};

  CreatePluginResponseBody() {}

  explicit CreatePluginResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pluginId) {
      res["PluginId"] = boost::any(*pluginId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (tagStatus) {
      res["TagStatus"] = boost::any(*tagStatus);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PluginId") != m.end() && !m["PluginId"].empty()) {
      pluginId = make_shared<string>(boost::any_cast<string>(m["PluginId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TagStatus") != m.end() && !m["TagStatus"].empty()) {
      tagStatus = make_shared<bool>(boost::any_cast<bool>(m["TagStatus"]));
    }
  }


  virtual ~CreatePluginResponseBody() = default;
};
class CreatePluginResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreatePluginResponseBody> body{};

  CreatePluginResponse() {}

  explicit CreatePluginResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreatePluginResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreatePluginResponseBody>(model1);
      }
    }
  }


  virtual ~CreatePluginResponse() = default;
};
class CreateSignatureRequest : public Darabonba::Model {
public:
  shared_ptr<string> securityToken{};
  shared_ptr<string> signatureKey{};
  shared_ptr<string> signatureName{};
  shared_ptr<string> signatureSecret{};

  CreateSignatureRequest() {}

  explicit CreateSignatureRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (signatureKey) {
      res["SignatureKey"] = boost::any(*signatureKey);
    }
    if (signatureName) {
      res["SignatureName"] = boost::any(*signatureName);
    }
    if (signatureSecret) {
      res["SignatureSecret"] = boost::any(*signatureSecret);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("SignatureKey") != m.end() && !m["SignatureKey"].empty()) {
      signatureKey = make_shared<string>(boost::any_cast<string>(m["SignatureKey"]));
    }
    if (m.find("SignatureName") != m.end() && !m["SignatureName"].empty()) {
      signatureName = make_shared<string>(boost::any_cast<string>(m["SignatureName"]));
    }
    if (m.find("SignatureSecret") != m.end() && !m["SignatureSecret"].empty()) {
      signatureSecret = make_shared<string>(boost::any_cast<string>(m["SignatureSecret"]));
    }
  }


  virtual ~CreateSignatureRequest() = default;
};
class CreateSignatureResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> signatureId{};
  shared_ptr<string> signatureName{};

  CreateSignatureResponseBody() {}

  explicit CreateSignatureResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (signatureId) {
      res["SignatureId"] = boost::any(*signatureId);
    }
    if (signatureName) {
      res["SignatureName"] = boost::any(*signatureName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SignatureId") != m.end() && !m["SignatureId"].empty()) {
      signatureId = make_shared<string>(boost::any_cast<string>(m["SignatureId"]));
    }
    if (m.find("SignatureName") != m.end() && !m["SignatureName"].empty()) {
      signatureName = make_shared<string>(boost::any_cast<string>(m["SignatureName"]));
    }
  }


  virtual ~CreateSignatureResponseBody() = default;
};
class CreateSignatureResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateSignatureResponseBody> body{};

  CreateSignatureResponse() {}

  explicit CreateSignatureResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateSignatureResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateSignatureResponseBody>(model1);
      }
    }
  }


  virtual ~CreateSignatureResponse() = default;
};
class CreateTrafficControlRequest : public Darabonba::Model {
public:
  shared_ptr<long> apiDefault{};
  shared_ptr<long> appDefault{};
  shared_ptr<string> description{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> trafficControlName{};
  shared_ptr<string> trafficControlUnit{};
  shared_ptr<long> userDefault{};

  CreateTrafficControlRequest() {}

  explicit CreateTrafficControlRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiDefault) {
      res["ApiDefault"] = boost::any(*apiDefault);
    }
    if (appDefault) {
      res["AppDefault"] = boost::any(*appDefault);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (trafficControlName) {
      res["TrafficControlName"] = boost::any(*trafficControlName);
    }
    if (trafficControlUnit) {
      res["TrafficControlUnit"] = boost::any(*trafficControlUnit);
    }
    if (userDefault) {
      res["UserDefault"] = boost::any(*userDefault);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiDefault") != m.end() && !m["ApiDefault"].empty()) {
      apiDefault = make_shared<long>(boost::any_cast<long>(m["ApiDefault"]));
    }
    if (m.find("AppDefault") != m.end() && !m["AppDefault"].empty()) {
      appDefault = make_shared<long>(boost::any_cast<long>(m["AppDefault"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("TrafficControlName") != m.end() && !m["TrafficControlName"].empty()) {
      trafficControlName = make_shared<string>(boost::any_cast<string>(m["TrafficControlName"]));
    }
    if (m.find("TrafficControlUnit") != m.end() && !m["TrafficControlUnit"].empty()) {
      trafficControlUnit = make_shared<string>(boost::any_cast<string>(m["TrafficControlUnit"]));
    }
    if (m.find("UserDefault") != m.end() && !m["UserDefault"].empty()) {
      userDefault = make_shared<long>(boost::any_cast<long>(m["UserDefault"]));
    }
  }


  virtual ~CreateTrafficControlRequest() = default;
};
class CreateTrafficControlResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> trafficControlId{};

  CreateTrafficControlResponseBody() {}

  explicit CreateTrafficControlResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (trafficControlId) {
      res["TrafficControlId"] = boost::any(*trafficControlId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TrafficControlId") != m.end() && !m["TrafficControlId"].empty()) {
      trafficControlId = make_shared<string>(boost::any_cast<string>(m["TrafficControlId"]));
    }
  }


  virtual ~CreateTrafficControlResponseBody() = default;
};
class CreateTrafficControlResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateTrafficControlResponseBody> body{};

  CreateTrafficControlResponse() {}

  explicit CreateTrafficControlResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateTrafficControlResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateTrafficControlResponseBody>(model1);
      }
    }
  }


  virtual ~CreateTrafficControlResponse() = default;
};
class DeleteAccessControlListRequest : public Darabonba::Model {
public:
  shared_ptr<string> aclId{};
  shared_ptr<string> securityToken{};

  DeleteAccessControlListRequest() {}

  explicit DeleteAccessControlListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aclId) {
      res["AclId"] = boost::any(*aclId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AclId") != m.end() && !m["AclId"].empty()) {
      aclId = make_shared<string>(boost::any_cast<string>(m["AclId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~DeleteAccessControlListRequest() = default;
};
class DeleteAccessControlListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteAccessControlListResponseBody() {}

  explicit DeleteAccessControlListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteAccessControlListResponseBody() = default;
};
class DeleteAccessControlListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteAccessControlListResponseBody> body{};

  DeleteAccessControlListResponse() {}

  explicit DeleteAccessControlListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteAccessControlListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteAccessControlListResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteAccessControlListResponse() = default;
};
class DeleteAllTrafficSpecialControlRequest : public Darabonba::Model {
public:
  shared_ptr<string> securityToken{};
  shared_ptr<string> trafficControlId{};

  DeleteAllTrafficSpecialControlRequest() {}

  explicit DeleteAllTrafficSpecialControlRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (trafficControlId) {
      res["TrafficControlId"] = boost::any(*trafficControlId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("TrafficControlId") != m.end() && !m["TrafficControlId"].empty()) {
      trafficControlId = make_shared<string>(boost::any_cast<string>(m["TrafficControlId"]));
    }
  }


  virtual ~DeleteAllTrafficSpecialControlRequest() = default;
};
class DeleteAllTrafficSpecialControlResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteAllTrafficSpecialControlResponseBody() {}

  explicit DeleteAllTrafficSpecialControlResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteAllTrafficSpecialControlResponseBody() = default;
};
class DeleteAllTrafficSpecialControlResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteAllTrafficSpecialControlResponseBody> body{};

  DeleteAllTrafficSpecialControlResponse() {}

  explicit DeleteAllTrafficSpecialControlResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteAllTrafficSpecialControlResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteAllTrafficSpecialControlResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteAllTrafficSpecialControlResponse() = default;
};
class DeleteApiRequest : public Darabonba::Model {
public:
  shared_ptr<string> apiId{};
  shared_ptr<string> groupId{};
  shared_ptr<string> securityToken{};

  DeleteApiRequest() {}

  explicit DeleteApiRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiId) {
      res["ApiId"] = boost::any(*apiId);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiId") != m.end() && !m["ApiId"].empty()) {
      apiId = make_shared<string>(boost::any_cast<string>(m["ApiId"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~DeleteApiRequest() = default;
};
class DeleteApiResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteApiResponseBody() {}

  explicit DeleteApiResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteApiResponseBody() = default;
};
class DeleteApiResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteApiResponseBody> body{};

  DeleteApiResponse() {}

  explicit DeleteApiResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteApiResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteApiResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteApiResponse() = default;
};
class DeleteApiGroupRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  DeleteApiGroupRequestTag() {}

  explicit DeleteApiGroupRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DeleteApiGroupRequestTag() = default;
};
class DeleteApiGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> groupId{};
  shared_ptr<string> securityToken{};
  shared_ptr<vector<DeleteApiGroupRequestTag>> tag{};

  DeleteApiGroupRequest() {}

  explicit DeleteApiGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<DeleteApiGroupRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DeleteApiGroupRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<DeleteApiGroupRequestTag>>(expect1);
      }
    }
  }


  virtual ~DeleteApiGroupRequest() = default;
};
class DeleteApiGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteApiGroupResponseBody() {}

  explicit DeleteApiGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteApiGroupResponseBody() = default;
};
class DeleteApiGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteApiGroupResponseBody> body{};

  DeleteApiGroupResponse() {}

  explicit DeleteApiGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteApiGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteApiGroupResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteApiGroupResponse() = default;
};
class DeleteApiProductRequest : public Darabonba::Model {
public:
  shared_ptr<string> apiProductId{};
  shared_ptr<string> securityToken{};

  DeleteApiProductRequest() {}

  explicit DeleteApiProductRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiProductId) {
      res["ApiProductId"] = boost::any(*apiProductId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiProductId") != m.end() && !m["ApiProductId"].empty()) {
      apiProductId = make_shared<string>(boost::any_cast<string>(m["ApiProductId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~DeleteApiProductRequest() = default;
};
class DeleteApiProductResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteApiProductResponseBody() {}

  explicit DeleteApiProductResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteApiProductResponseBody() = default;
};
class DeleteApiProductResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteApiProductResponseBody> body{};

  DeleteApiProductResponse() {}

  explicit DeleteApiProductResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteApiProductResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteApiProductResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteApiProductResponse() = default;
};
class DeleteApiStageVariableRequest : public Darabonba::Model {
public:
  shared_ptr<string> groupId{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> stageId{};
  shared_ptr<string> variableName{};

  DeleteApiStageVariableRequest() {}

  explicit DeleteApiStageVariableRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (stageId) {
      res["StageId"] = boost::any(*stageId);
    }
    if (variableName) {
      res["VariableName"] = boost::any(*variableName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("StageId") != m.end() && !m["StageId"].empty()) {
      stageId = make_shared<string>(boost::any_cast<string>(m["StageId"]));
    }
    if (m.find("VariableName") != m.end() && !m["VariableName"].empty()) {
      variableName = make_shared<string>(boost::any_cast<string>(m["VariableName"]));
    }
  }


  virtual ~DeleteApiStageVariableRequest() = default;
};
class DeleteApiStageVariableResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteApiStageVariableResponseBody() {}

  explicit DeleteApiStageVariableResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteApiStageVariableResponseBody() = default;
};
class DeleteApiStageVariableResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteApiStageVariableResponseBody> body{};

  DeleteApiStageVariableResponse() {}

  explicit DeleteApiStageVariableResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteApiStageVariableResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteApiStageVariableResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteApiStageVariableResponse() = default;
};
class DeleteAppRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  DeleteAppRequestTag() {}

  explicit DeleteAppRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DeleteAppRequestTag() = default;
};
class DeleteAppRequest : public Darabonba::Model {
public:
  shared_ptr<long> appId{};
  shared_ptr<string> securityToken{};
  shared_ptr<vector<DeleteAppRequestTag>> tag{};

  DeleteAppRequest() {}

  explicit DeleteAppRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<long>(boost::any_cast<long>(m["AppId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<DeleteAppRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DeleteAppRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<DeleteAppRequestTag>>(expect1);
      }
    }
  }


  virtual ~DeleteAppRequest() = default;
};
class DeleteAppResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteAppResponseBody() {}

  explicit DeleteAppResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteAppResponseBody() = default;
};
class DeleteAppResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteAppResponseBody> body{};

  DeleteAppResponse() {}

  explicit DeleteAppResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteAppResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteAppResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteAppResponse() = default;
};
class DeleteAppCodeRequest : public Darabonba::Model {
public:
  shared_ptr<string> appCode{};
  shared_ptr<string> appId{};

  DeleteAppCodeRequest() {}

  explicit DeleteAppCodeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appCode) {
      res["AppCode"] = boost::any(*appCode);
    }
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppCode") != m.end() && !m["AppCode"].empty()) {
      appCode = make_shared<string>(boost::any_cast<string>(m["AppCode"]));
    }
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
  }


  virtual ~DeleteAppCodeRequest() = default;
};
class DeleteAppCodeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteAppCodeResponseBody() {}

  explicit DeleteAppCodeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteAppCodeResponseBody() = default;
};
class DeleteAppCodeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteAppCodeResponseBody> body{};

  DeleteAppCodeResponse() {}

  explicit DeleteAppCodeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteAppCodeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteAppCodeResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteAppCodeResponse() = default;
};
class DeleteAppKeyRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> appKey{};

  DeleteAppKeyRequest() {}

  explicit DeleteAppKeyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (appKey) {
      res["AppKey"] = boost::any(*appKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("AppKey") != m.end() && !m["AppKey"].empty()) {
      appKey = make_shared<string>(boost::any_cast<string>(m["AppKey"]));
    }
  }


  virtual ~DeleteAppKeyRequest() = default;
};
class DeleteAppKeyResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteAppKeyResponseBody() {}

  explicit DeleteAppKeyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteAppKeyResponseBody() = default;
};
class DeleteAppKeyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteAppKeyResponseBody> body{};

  DeleteAppKeyResponse() {}

  explicit DeleteAppKeyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteAppKeyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteAppKeyResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteAppKeyResponse() = default;
};
class DeleteBackendRequest : public Darabonba::Model {
public:
  shared_ptr<string> backendId{};
  shared_ptr<string> securityToken{};

  DeleteBackendRequest() {}

  explicit DeleteBackendRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (backendId) {
      res["BackendId"] = boost::any(*backendId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BackendId") != m.end() && !m["BackendId"].empty()) {
      backendId = make_shared<string>(boost::any_cast<string>(m["BackendId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~DeleteBackendRequest() = default;
};
class DeleteBackendResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteBackendResponseBody() {}

  explicit DeleteBackendResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteBackendResponseBody() = default;
};
class DeleteBackendResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteBackendResponseBody> body{};

  DeleteBackendResponse() {}

  explicit DeleteBackendResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteBackendResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteBackendResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteBackendResponse() = default;
};
class DeleteBackendModelRequest : public Darabonba::Model {
public:
  shared_ptr<string> backendId{};
  shared_ptr<string> backendModelId{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> stageName{};

  DeleteBackendModelRequest() {}

  explicit DeleteBackendModelRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (backendId) {
      res["BackendId"] = boost::any(*backendId);
    }
    if (backendModelId) {
      res["BackendModelId"] = boost::any(*backendModelId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (stageName) {
      res["StageName"] = boost::any(*stageName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BackendId") != m.end() && !m["BackendId"].empty()) {
      backendId = make_shared<string>(boost::any_cast<string>(m["BackendId"]));
    }
    if (m.find("BackendModelId") != m.end() && !m["BackendModelId"].empty()) {
      backendModelId = make_shared<string>(boost::any_cast<string>(m["BackendModelId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("StageName") != m.end() && !m["StageName"].empty()) {
      stageName = make_shared<string>(boost::any_cast<string>(m["StageName"]));
    }
  }


  virtual ~DeleteBackendModelRequest() = default;
};
class DeleteBackendModelResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> operationId{};
  shared_ptr<string> requestId{};

  DeleteBackendModelResponseBody() {}

  explicit DeleteBackendModelResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (operationId) {
      res["OperationId"] = boost::any(*operationId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OperationId") != m.end() && !m["OperationId"].empty()) {
      operationId = make_shared<string>(boost::any_cast<string>(m["OperationId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteBackendModelResponseBody() = default;
};
class DeleteBackendModelResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteBackendModelResponseBody> body{};

  DeleteBackendModelResponse() {}

  explicit DeleteBackendModelResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteBackendModelResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteBackendModelResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteBackendModelResponse() = default;
};
class DeleteDatasetRequest : public Darabonba::Model {
public:
  shared_ptr<string> datasetId{};
  shared_ptr<string> securityToken{};

  DeleteDatasetRequest() {}

  explicit DeleteDatasetRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (datasetId) {
      res["DatasetId"] = boost::any(*datasetId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DatasetId") != m.end() && !m["DatasetId"].empty()) {
      datasetId = make_shared<string>(boost::any_cast<string>(m["DatasetId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~DeleteDatasetRequest() = default;
};
class DeleteDatasetResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteDatasetResponseBody() {}

  explicit DeleteDatasetResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteDatasetResponseBody() = default;
};
class DeleteDatasetResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteDatasetResponseBody> body{};

  DeleteDatasetResponse() {}

  explicit DeleteDatasetResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteDatasetResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteDatasetResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteDatasetResponse() = default;
};
class DeleteDatasetItemRequest : public Darabonba::Model {
public:
  shared_ptr<string> datasetId{};
  shared_ptr<string> datasetItemId{};
  shared_ptr<string> securityToken{};

  DeleteDatasetItemRequest() {}

  explicit DeleteDatasetItemRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (datasetId) {
      res["DatasetId"] = boost::any(*datasetId);
    }
    if (datasetItemId) {
      res["DatasetItemId"] = boost::any(*datasetItemId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DatasetId") != m.end() && !m["DatasetId"].empty()) {
      datasetId = make_shared<string>(boost::any_cast<string>(m["DatasetId"]));
    }
    if (m.find("DatasetItemId") != m.end() && !m["DatasetItemId"].empty()) {
      datasetItemId = make_shared<string>(boost::any_cast<string>(m["DatasetItemId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~DeleteDatasetItemRequest() = default;
};
class DeleteDatasetItemResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteDatasetItemResponseBody() {}

  explicit DeleteDatasetItemResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteDatasetItemResponseBody() = default;
};
class DeleteDatasetItemResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteDatasetItemResponseBody> body{};

  DeleteDatasetItemResponse() {}

  explicit DeleteDatasetItemResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteDatasetItemResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteDatasetItemResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteDatasetItemResponse() = default;
};
class DeleteDomainRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> groupId{};
  shared_ptr<string> securityToken{};

  DeleteDomainRequest() {}

  explicit DeleteDomainRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~DeleteDomainRequest() = default;
};
class DeleteDomainResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteDomainResponseBody() {}

  explicit DeleteDomainResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteDomainResponseBody() = default;
};
class DeleteDomainResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteDomainResponseBody> body{};

  DeleteDomainResponse() {}

  explicit DeleteDomainResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteDomainResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteDomainResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteDomainResponse() = default;
};
class DeleteDomainCertificateRequest : public Darabonba::Model {
public:
  shared_ptr<string> certificateId{};
  shared_ptr<string> domainName{};
  shared_ptr<string> groupId{};
  shared_ptr<string> securityToken{};

  DeleteDomainCertificateRequest() {}

  explicit DeleteDomainCertificateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (certificateId) {
      res["CertificateId"] = boost::any(*certificateId);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CertificateId") != m.end() && !m["CertificateId"].empty()) {
      certificateId = make_shared<string>(boost::any_cast<string>(m["CertificateId"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~DeleteDomainCertificateRequest() = default;
};
class DeleteDomainCertificateResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteDomainCertificateResponseBody() {}

  explicit DeleteDomainCertificateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteDomainCertificateResponseBody() = default;
};
class DeleteDomainCertificateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteDomainCertificateResponseBody> body{};

  DeleteDomainCertificateResponse() {}

  explicit DeleteDomainCertificateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteDomainCertificateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteDomainCertificateResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteDomainCertificateResponse() = default;
};
class DeleteInstanceRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  DeleteInstanceRequestTag() {}

  explicit DeleteInstanceRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DeleteInstanceRequestTag() = default;
};
class DeleteInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<vector<DeleteInstanceRequestTag>> tag{};

  DeleteInstanceRequest() {}

  explicit DeleteInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<DeleteInstanceRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DeleteInstanceRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<DeleteInstanceRequestTag>>(expect1);
      }
    }
  }


  virtual ~DeleteInstanceRequest() = default;
};
class DeleteInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteInstanceResponseBody() {}

  explicit DeleteInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteInstanceResponseBody() = default;
};
class DeleteInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteInstanceResponseBody> body{};

  DeleteInstanceResponse() {}

  explicit DeleteInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteInstanceResponse() = default;
};
class DeleteIpControlRequest : public Darabonba::Model {
public:
  shared_ptr<string> ipControlId{};
  shared_ptr<string> securityToken{};

  DeleteIpControlRequest() {}

  explicit DeleteIpControlRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ipControlId) {
      res["IpControlId"] = boost::any(*ipControlId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IpControlId") != m.end() && !m["IpControlId"].empty()) {
      ipControlId = make_shared<string>(boost::any_cast<string>(m["IpControlId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~DeleteIpControlRequest() = default;
};
class DeleteIpControlResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteIpControlResponseBody() {}

  explicit DeleteIpControlResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteIpControlResponseBody() = default;
};
class DeleteIpControlResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteIpControlResponseBody> body{};

  DeleteIpControlResponse() {}

  explicit DeleteIpControlResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteIpControlResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteIpControlResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteIpControlResponse() = default;
};
class DeleteLogConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> logType{};
  shared_ptr<string> securityToken{};

  DeleteLogConfigRequest() {}

  explicit DeleteLogConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (logType) {
      res["LogType"] = boost::any(*logType);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LogType") != m.end() && !m["LogType"].empty()) {
      logType = make_shared<string>(boost::any_cast<string>(m["LogType"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~DeleteLogConfigRequest() = default;
};
class DeleteLogConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteLogConfigResponseBody() {}

  explicit DeleteLogConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteLogConfigResponseBody() = default;
};
class DeleteLogConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteLogConfigResponseBody> body{};

  DeleteLogConfigResponse() {}

  explicit DeleteLogConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteLogConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteLogConfigResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteLogConfigResponse() = default;
};
class DeleteModelRequest : public Darabonba::Model {
public:
  shared_ptr<string> groupId{};
  shared_ptr<string> modelName{};

  DeleteModelRequest() {}

  explicit DeleteModelRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (modelName) {
      res["ModelName"] = boost::any(*modelName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("ModelName") != m.end() && !m["ModelName"].empty()) {
      modelName = make_shared<string>(boost::any_cast<string>(m["ModelName"]));
    }
  }


  virtual ~DeleteModelRequest() = default;
};
class DeleteModelResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteModelResponseBody() {}

  explicit DeleteModelResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteModelResponseBody() = default;
};
class DeleteModelResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteModelResponseBody> body{};

  DeleteModelResponse() {}

  explicit DeleteModelResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteModelResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteModelResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteModelResponse() = default;
};
class DeleteMonitorGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> groupId{};
  shared_ptr<long> rawMonitorGroupId{};
  shared_ptr<string> securityToken{};

  DeleteMonitorGroupRequest() {}

  explicit DeleteMonitorGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (rawMonitorGroupId) {
      res["RawMonitorGroupId"] = boost::any(*rawMonitorGroupId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("RawMonitorGroupId") != m.end() && !m["RawMonitorGroupId"].empty()) {
      rawMonitorGroupId = make_shared<long>(boost::any_cast<long>(m["RawMonitorGroupId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~DeleteMonitorGroupRequest() = default;
};
class DeleteMonitorGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteMonitorGroupResponseBody() {}

  explicit DeleteMonitorGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteMonitorGroupResponseBody() = default;
};
class DeleteMonitorGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteMonitorGroupResponseBody> body{};

  DeleteMonitorGroupResponse() {}

  explicit DeleteMonitorGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteMonitorGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteMonitorGroupResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteMonitorGroupResponse() = default;
};
class DeletePluginRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  DeletePluginRequestTag() {}

  explicit DeletePluginRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DeletePluginRequestTag() = default;
};
class DeletePluginRequest : public Darabonba::Model {
public:
  shared_ptr<string> pluginId{};
  shared_ptr<string> securityToken{};
  shared_ptr<vector<DeletePluginRequestTag>> tag{};

  DeletePluginRequest() {}

  explicit DeletePluginRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pluginId) {
      res["PluginId"] = boost::any(*pluginId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PluginId") != m.end() && !m["PluginId"].empty()) {
      pluginId = make_shared<string>(boost::any_cast<string>(m["PluginId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<DeletePluginRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DeletePluginRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<DeletePluginRequestTag>>(expect1);
      }
    }
  }


  virtual ~DeletePluginRequest() = default;
};
class DeletePluginResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeletePluginResponseBody() {}

  explicit DeletePluginResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeletePluginResponseBody() = default;
};
class DeletePluginResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeletePluginResponseBody> body{};

  DeletePluginResponse() {}

  explicit DeletePluginResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeletePluginResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeletePluginResponseBody>(model1);
      }
    }
  }


  virtual ~DeletePluginResponse() = default;
};
class DeleteSignatureRequest : public Darabonba::Model {
public:
  shared_ptr<string> securityToken{};
  shared_ptr<string> signatureId{};

  DeleteSignatureRequest() {}

  explicit DeleteSignatureRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (signatureId) {
      res["SignatureId"] = boost::any(*signatureId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("SignatureId") != m.end() && !m["SignatureId"].empty()) {
      signatureId = make_shared<string>(boost::any_cast<string>(m["SignatureId"]));
    }
  }


  virtual ~DeleteSignatureRequest() = default;
};
class DeleteSignatureResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteSignatureResponseBody() {}

  explicit DeleteSignatureResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteSignatureResponseBody() = default;
};
class DeleteSignatureResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteSignatureResponseBody> body{};

  DeleteSignatureResponse() {}

  explicit DeleteSignatureResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteSignatureResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteSignatureResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteSignatureResponse() = default;
};
class DeleteTrafficControlRequest : public Darabonba::Model {
public:
  shared_ptr<string> securityToken{};
  shared_ptr<string> trafficControlId{};

  DeleteTrafficControlRequest() {}

  explicit DeleteTrafficControlRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (trafficControlId) {
      res["TrafficControlId"] = boost::any(*trafficControlId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("TrafficControlId") != m.end() && !m["TrafficControlId"].empty()) {
      trafficControlId = make_shared<string>(boost::any_cast<string>(m["TrafficControlId"]));
    }
  }


  virtual ~DeleteTrafficControlRequest() = default;
};
class DeleteTrafficControlResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteTrafficControlResponseBody() {}

  explicit DeleteTrafficControlResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteTrafficControlResponseBody() = default;
};
class DeleteTrafficControlResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteTrafficControlResponseBody> body{};

  DeleteTrafficControlResponse() {}

  explicit DeleteTrafficControlResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteTrafficControlResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteTrafficControlResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteTrafficControlResponse() = default;
};
class DeleteTrafficSpecialControlRequest : public Darabonba::Model {
public:
  shared_ptr<string> securityToken{};
  shared_ptr<string> specialKey{};
  shared_ptr<string> specialType{};
  shared_ptr<string> trafficControlId{};

  DeleteTrafficSpecialControlRequest() {}

  explicit DeleteTrafficSpecialControlRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (specialKey) {
      res["SpecialKey"] = boost::any(*specialKey);
    }
    if (specialType) {
      res["SpecialType"] = boost::any(*specialType);
    }
    if (trafficControlId) {
      res["TrafficControlId"] = boost::any(*trafficControlId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("SpecialKey") != m.end() && !m["SpecialKey"].empty()) {
      specialKey = make_shared<string>(boost::any_cast<string>(m["SpecialKey"]));
    }
    if (m.find("SpecialType") != m.end() && !m["SpecialType"].empty()) {
      specialType = make_shared<string>(boost::any_cast<string>(m["SpecialType"]));
    }
    if (m.find("TrafficControlId") != m.end() && !m["TrafficControlId"].empty()) {
      trafficControlId = make_shared<string>(boost::any_cast<string>(m["TrafficControlId"]));
    }
  }


  virtual ~DeleteTrafficSpecialControlRequest() = default;
};
class DeleteTrafficSpecialControlResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteTrafficSpecialControlResponseBody() {}

  explicit DeleteTrafficSpecialControlResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteTrafficSpecialControlResponseBody() = default;
};
class DeleteTrafficSpecialControlResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteTrafficSpecialControlResponseBody> body{};

  DeleteTrafficSpecialControlResponse() {}

  explicit DeleteTrafficSpecialControlResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteTrafficSpecialControlResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteTrafficSpecialControlResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteTrafficSpecialControlResponse() = default;
};
class DeployApiRequest : public Darabonba::Model {
public:
  shared_ptr<string> apiId{};
  shared_ptr<string> description{};
  shared_ptr<string> groupId{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> stageName{};

  DeployApiRequest() {}

  explicit DeployApiRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiId) {
      res["ApiId"] = boost::any(*apiId);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (stageName) {
      res["StageName"] = boost::any(*stageName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiId") != m.end() && !m["ApiId"].empty()) {
      apiId = make_shared<string>(boost::any_cast<string>(m["ApiId"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("StageName") != m.end() && !m["StageName"].empty()) {
      stageName = make_shared<string>(boost::any_cast<string>(m["StageName"]));
    }
  }


  virtual ~DeployApiRequest() = default;
};
class DeployApiResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeployApiResponseBody() {}

  explicit DeployApiResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeployApiResponseBody() = default;
};
class DeployApiResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeployApiResponseBody> body{};

  DeployApiResponse() {}

  explicit DeployApiResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeployApiResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeployApiResponseBody>(model1);
      }
    }
  }


  virtual ~DeployApiResponse() = default;
};
class DescribeAbolishApiTaskRequest : public Darabonba::Model {
public:
  shared_ptr<string> operationUid{};
  shared_ptr<string> securityToken{};

  DescribeAbolishApiTaskRequest() {}

  explicit DescribeAbolishApiTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (operationUid) {
      res["OperationUid"] = boost::any(*operationUid);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OperationUid") != m.end() && !m["OperationUid"].empty()) {
      operationUid = make_shared<string>(boost::any_cast<string>(m["OperationUid"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~DescribeAbolishApiTaskRequest() = default;
};
class DescribeAbolishApiTaskResponseBodyApiAbolishResultsApiAbolishResult : public Darabonba::Model {
public:
  shared_ptr<string> abolishStatus{};
  shared_ptr<string> apiName{};
  shared_ptr<string> apiUid{};
  shared_ptr<string> errorMsg{};
  shared_ptr<string> groupId{};
  shared_ptr<string> groupName{};
  shared_ptr<string> stageId{};
  shared_ptr<string> stageName{};

  DescribeAbolishApiTaskResponseBodyApiAbolishResultsApiAbolishResult() {}

  explicit DescribeAbolishApiTaskResponseBodyApiAbolishResultsApiAbolishResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (abolishStatus) {
      res["AbolishStatus"] = boost::any(*abolishStatus);
    }
    if (apiName) {
      res["ApiName"] = boost::any(*apiName);
    }
    if (apiUid) {
      res["ApiUid"] = boost::any(*apiUid);
    }
    if (errorMsg) {
      res["ErrorMsg"] = boost::any(*errorMsg);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (stageId) {
      res["StageId"] = boost::any(*stageId);
    }
    if (stageName) {
      res["StageName"] = boost::any(*stageName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AbolishStatus") != m.end() && !m["AbolishStatus"].empty()) {
      abolishStatus = make_shared<string>(boost::any_cast<string>(m["AbolishStatus"]));
    }
    if (m.find("ApiName") != m.end() && !m["ApiName"].empty()) {
      apiName = make_shared<string>(boost::any_cast<string>(m["ApiName"]));
    }
    if (m.find("ApiUid") != m.end() && !m["ApiUid"].empty()) {
      apiUid = make_shared<string>(boost::any_cast<string>(m["ApiUid"]));
    }
    if (m.find("ErrorMsg") != m.end() && !m["ErrorMsg"].empty()) {
      errorMsg = make_shared<string>(boost::any_cast<string>(m["ErrorMsg"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("StageId") != m.end() && !m["StageId"].empty()) {
      stageId = make_shared<string>(boost::any_cast<string>(m["StageId"]));
    }
    if (m.find("StageName") != m.end() && !m["StageName"].empty()) {
      stageName = make_shared<string>(boost::any_cast<string>(m["StageName"]));
    }
  }


  virtual ~DescribeAbolishApiTaskResponseBodyApiAbolishResultsApiAbolishResult() = default;
};
class DescribeAbolishApiTaskResponseBodyApiAbolishResults : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeAbolishApiTaskResponseBodyApiAbolishResultsApiAbolishResult>> apiAbolishResult{};

  DescribeAbolishApiTaskResponseBodyApiAbolishResults() {}

  explicit DescribeAbolishApiTaskResponseBodyApiAbolishResults(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiAbolishResult) {
      vector<boost::any> temp1;
      for(auto item1:*apiAbolishResult){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ApiAbolishResult"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiAbolishResult") != m.end() && !m["ApiAbolishResult"].empty()) {
      if (typeid(vector<boost::any>) == m["ApiAbolishResult"].type()) {
        vector<DescribeAbolishApiTaskResponseBodyApiAbolishResultsApiAbolishResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ApiAbolishResult"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeAbolishApiTaskResponseBodyApiAbolishResultsApiAbolishResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        apiAbolishResult = make_shared<vector<DescribeAbolishApiTaskResponseBodyApiAbolishResultsApiAbolishResult>>(expect1);
      }
    }
  }


  virtual ~DescribeAbolishApiTaskResponseBodyApiAbolishResults() = default;
};
class DescribeAbolishApiTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeAbolishApiTaskResponseBodyApiAbolishResults> apiAbolishResults{};
  shared_ptr<string> requestId{};

  DescribeAbolishApiTaskResponseBody() {}

  explicit DescribeAbolishApiTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiAbolishResults) {
      res["ApiAbolishResults"] = apiAbolishResults ? boost::any(apiAbolishResults->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiAbolishResults") != m.end() && !m["ApiAbolishResults"].empty()) {
      if (typeid(map<string, boost::any>) == m["ApiAbolishResults"].type()) {
        DescribeAbolishApiTaskResponseBodyApiAbolishResults model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ApiAbolishResults"]));
        apiAbolishResults = make_shared<DescribeAbolishApiTaskResponseBodyApiAbolishResults>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeAbolishApiTaskResponseBody() = default;
};
class DescribeAbolishApiTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeAbolishApiTaskResponseBody> body{};

  DescribeAbolishApiTaskResponse() {}

  explicit DescribeAbolishApiTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeAbolishApiTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeAbolishApiTaskResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeAbolishApiTaskResponse() = default;
};
class DescribeAccessControlListAttributeRequest : public Darabonba::Model {
public:
  shared_ptr<string> aclId{};
  shared_ptr<string> securityToken{};

  DescribeAccessControlListAttributeRequest() {}

  explicit DescribeAccessControlListAttributeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aclId) {
      res["AclId"] = boost::any(*aclId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AclId") != m.end() && !m["AclId"].empty()) {
      aclId = make_shared<string>(boost::any_cast<string>(m["AclId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~DescribeAccessControlListAttributeRequest() = default;
};
class DescribeAccessControlListAttributeResponseBodyAclEntrysAclEntry : public Darabonba::Model {
public:
  shared_ptr<string> aclEntryComment{};
  shared_ptr<string> aclEntryIp{};

  DescribeAccessControlListAttributeResponseBodyAclEntrysAclEntry() {}

  explicit DescribeAccessControlListAttributeResponseBodyAclEntrysAclEntry(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aclEntryComment) {
      res["AclEntryComment"] = boost::any(*aclEntryComment);
    }
    if (aclEntryIp) {
      res["AclEntryIp"] = boost::any(*aclEntryIp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AclEntryComment") != m.end() && !m["AclEntryComment"].empty()) {
      aclEntryComment = make_shared<string>(boost::any_cast<string>(m["AclEntryComment"]));
    }
    if (m.find("AclEntryIp") != m.end() && !m["AclEntryIp"].empty()) {
      aclEntryIp = make_shared<string>(boost::any_cast<string>(m["AclEntryIp"]));
    }
  }


  virtual ~DescribeAccessControlListAttributeResponseBodyAclEntrysAclEntry() = default;
};
class DescribeAccessControlListAttributeResponseBodyAclEntrys : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeAccessControlListAttributeResponseBodyAclEntrysAclEntry>> aclEntry{};

  DescribeAccessControlListAttributeResponseBodyAclEntrys() {}

  explicit DescribeAccessControlListAttributeResponseBodyAclEntrys(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aclEntry) {
      vector<boost::any> temp1;
      for(auto item1:*aclEntry){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AclEntry"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AclEntry") != m.end() && !m["AclEntry"].empty()) {
      if (typeid(vector<boost::any>) == m["AclEntry"].type()) {
        vector<DescribeAccessControlListAttributeResponseBodyAclEntrysAclEntry> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AclEntry"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeAccessControlListAttributeResponseBodyAclEntrysAclEntry model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        aclEntry = make_shared<vector<DescribeAccessControlListAttributeResponseBodyAclEntrysAclEntry>>(expect1);
      }
    }
  }


  virtual ~DescribeAccessControlListAttributeResponseBodyAclEntrys() = default;
};
class DescribeAccessControlListAttributeResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeAccessControlListAttributeResponseBodyAclEntrys> aclEntrys{};
  shared_ptr<string> aclId{};
  shared_ptr<string> aclName{};
  shared_ptr<string> addressIPVersion{};
  shared_ptr<string> requestId{};

  DescribeAccessControlListAttributeResponseBody() {}

  explicit DescribeAccessControlListAttributeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aclEntrys) {
      res["AclEntrys"] = aclEntrys ? boost::any(aclEntrys->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (aclId) {
      res["AclId"] = boost::any(*aclId);
    }
    if (aclName) {
      res["AclName"] = boost::any(*aclName);
    }
    if (addressIPVersion) {
      res["AddressIPVersion"] = boost::any(*addressIPVersion);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AclEntrys") != m.end() && !m["AclEntrys"].empty()) {
      if (typeid(map<string, boost::any>) == m["AclEntrys"].type()) {
        DescribeAccessControlListAttributeResponseBodyAclEntrys model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AclEntrys"]));
        aclEntrys = make_shared<DescribeAccessControlListAttributeResponseBodyAclEntrys>(model1);
      }
    }
    if (m.find("AclId") != m.end() && !m["AclId"].empty()) {
      aclId = make_shared<string>(boost::any_cast<string>(m["AclId"]));
    }
    if (m.find("AclName") != m.end() && !m["AclName"].empty()) {
      aclName = make_shared<string>(boost::any_cast<string>(m["AclName"]));
    }
    if (m.find("AddressIPVersion") != m.end() && !m["AddressIPVersion"].empty()) {
      addressIPVersion = make_shared<string>(boost::any_cast<string>(m["AddressIPVersion"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeAccessControlListAttributeResponseBody() = default;
};
class DescribeAccessControlListAttributeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeAccessControlListAttributeResponseBody> body{};

  DescribeAccessControlListAttributeResponse() {}

  explicit DescribeAccessControlListAttributeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeAccessControlListAttributeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeAccessControlListAttributeResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeAccessControlListAttributeResponse() = default;
};
class DescribeAccessControlListsRequest : public Darabonba::Model {
public:
  shared_ptr<string> aclName{};
  shared_ptr<string> addressIPVersion{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> securityToken{};

  DescribeAccessControlListsRequest() {}

  explicit DescribeAccessControlListsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aclName) {
      res["AclName"] = boost::any(*aclName);
    }
    if (addressIPVersion) {
      res["AddressIPVersion"] = boost::any(*addressIPVersion);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AclName") != m.end() && !m["AclName"].empty()) {
      aclName = make_shared<string>(boost::any_cast<string>(m["AclName"]));
    }
    if (m.find("AddressIPVersion") != m.end() && !m["AddressIPVersion"].empty()) {
      addressIPVersion = make_shared<string>(boost::any_cast<string>(m["AddressIPVersion"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~DescribeAccessControlListsRequest() = default;
};
class DescribeAccessControlListsResponseBodyAclsAcl : public Darabonba::Model {
public:
  shared_ptr<string> aclId{};
  shared_ptr<string> aclName{};
  shared_ptr<string> addressIPVersion{};

  DescribeAccessControlListsResponseBodyAclsAcl() {}

  explicit DescribeAccessControlListsResponseBodyAclsAcl(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aclId) {
      res["AclId"] = boost::any(*aclId);
    }
    if (aclName) {
      res["AclName"] = boost::any(*aclName);
    }
    if (addressIPVersion) {
      res["AddressIPVersion"] = boost::any(*addressIPVersion);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AclId") != m.end() && !m["AclId"].empty()) {
      aclId = make_shared<string>(boost::any_cast<string>(m["AclId"]));
    }
    if (m.find("AclName") != m.end() && !m["AclName"].empty()) {
      aclName = make_shared<string>(boost::any_cast<string>(m["AclName"]));
    }
    if (m.find("AddressIPVersion") != m.end() && !m["AddressIPVersion"].empty()) {
      addressIPVersion = make_shared<string>(boost::any_cast<string>(m["AddressIPVersion"]));
    }
  }


  virtual ~DescribeAccessControlListsResponseBodyAclsAcl() = default;
};
class DescribeAccessControlListsResponseBodyAcls : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeAccessControlListsResponseBodyAclsAcl>> acl{};

  DescribeAccessControlListsResponseBodyAcls() {}

  explicit DescribeAccessControlListsResponseBodyAcls(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acl) {
      vector<boost::any> temp1;
      for(auto item1:*acl){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Acl"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Acl") != m.end() && !m["Acl"].empty()) {
      if (typeid(vector<boost::any>) == m["Acl"].type()) {
        vector<DescribeAccessControlListsResponseBodyAclsAcl> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Acl"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeAccessControlListsResponseBodyAclsAcl model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        acl = make_shared<vector<DescribeAccessControlListsResponseBodyAclsAcl>>(expect1);
      }
    }
  }


  virtual ~DescribeAccessControlListsResponseBodyAcls() = default;
};
class DescribeAccessControlListsResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeAccessControlListsResponseBodyAcls> acls{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeAccessControlListsResponseBody() {}

  explicit DescribeAccessControlListsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acls) {
      res["Acls"] = acls ? boost::any(acls->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Acls") != m.end() && !m["Acls"].empty()) {
      if (typeid(map<string, boost::any>) == m["Acls"].type()) {
        DescribeAccessControlListsResponseBodyAcls model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Acls"]));
        acls = make_shared<DescribeAccessControlListsResponseBodyAcls>(model1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeAccessControlListsResponseBody() = default;
};
class DescribeAccessControlListsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeAccessControlListsResponseBody> body{};

  DescribeAccessControlListsResponse() {}

  explicit DescribeAccessControlListsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeAccessControlListsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeAccessControlListsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeAccessControlListsResponse() = default;
};
class DescribeApiRequest : public Darabonba::Model {
public:
  shared_ptr<string> apiId{};
  shared_ptr<string> groupId{};
  shared_ptr<string> securityToken{};

  DescribeApiRequest() {}

  explicit DescribeApiRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiId) {
      res["ApiId"] = boost::any(*apiId);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiId") != m.end() && !m["ApiId"].empty()) {
      apiId = make_shared<string>(boost::any_cast<string>(m["ApiId"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~DescribeApiRequest() = default;
};
class DescribeApiResponseBodyBackendConfig : public Darabonba::Model {
public:
  shared_ptr<string> backendId{};
  shared_ptr<string> backendName{};
  shared_ptr<string> backendType{};

  DescribeApiResponseBodyBackendConfig() {}

  explicit DescribeApiResponseBodyBackendConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (backendId) {
      res["BackendId"] = boost::any(*backendId);
    }
    if (backendName) {
      res["BackendName"] = boost::any(*backendName);
    }
    if (backendType) {
      res["BackendType"] = boost::any(*backendType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BackendId") != m.end() && !m["BackendId"].empty()) {
      backendId = make_shared<string>(boost::any_cast<string>(m["BackendId"]));
    }
    if (m.find("BackendName") != m.end() && !m["BackendName"].empty()) {
      backendName = make_shared<string>(boost::any_cast<string>(m["BackendName"]));
    }
    if (m.find("BackendType") != m.end() && !m["BackendType"].empty()) {
      backendType = make_shared<string>(boost::any_cast<string>(m["BackendType"]));
    }
  }


  virtual ~DescribeApiResponseBodyBackendConfig() = default;
};
class DescribeApiResponseBodyConstantParametersConstantParameter : public Darabonba::Model {
public:
  shared_ptr<string> constantValue{};
  shared_ptr<string> description{};
  shared_ptr<string> location{};
  shared_ptr<string> serviceParameterName{};

  DescribeApiResponseBodyConstantParametersConstantParameter() {}

  explicit DescribeApiResponseBodyConstantParametersConstantParameter(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (constantValue) {
      res["ConstantValue"] = boost::any(*constantValue);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (serviceParameterName) {
      res["ServiceParameterName"] = boost::any(*serviceParameterName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConstantValue") != m.end() && !m["ConstantValue"].empty()) {
      constantValue = make_shared<string>(boost::any_cast<string>(m["ConstantValue"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("ServiceParameterName") != m.end() && !m["ServiceParameterName"].empty()) {
      serviceParameterName = make_shared<string>(boost::any_cast<string>(m["ServiceParameterName"]));
    }
  }


  virtual ~DescribeApiResponseBodyConstantParametersConstantParameter() = default;
};
class DescribeApiResponseBodyConstantParameters : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeApiResponseBodyConstantParametersConstantParameter>> constantParameter{};

  DescribeApiResponseBodyConstantParameters() {}

  explicit DescribeApiResponseBodyConstantParameters(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (constantParameter) {
      vector<boost::any> temp1;
      for(auto item1:*constantParameter){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ConstantParameter"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConstantParameter") != m.end() && !m["ConstantParameter"].empty()) {
      if (typeid(vector<boost::any>) == m["ConstantParameter"].type()) {
        vector<DescribeApiResponseBodyConstantParametersConstantParameter> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ConstantParameter"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeApiResponseBodyConstantParametersConstantParameter model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        constantParameter = make_shared<vector<DescribeApiResponseBodyConstantParametersConstantParameter>>(expect1);
      }
    }
  }


  virtual ~DescribeApiResponseBodyConstantParameters() = default;
};
class DescribeApiResponseBodyCustomSystemParametersCustomSystemParameter : public Darabonba::Model {
public:
  shared_ptr<string> demoValue{};
  shared_ptr<string> description{};
  shared_ptr<string> location{};
  shared_ptr<string> parameterName{};
  shared_ptr<string> serviceParameterName{};

  DescribeApiResponseBodyCustomSystemParametersCustomSystemParameter() {}

  explicit DescribeApiResponseBodyCustomSystemParametersCustomSystemParameter(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (demoValue) {
      res["DemoValue"] = boost::any(*demoValue);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (parameterName) {
      res["ParameterName"] = boost::any(*parameterName);
    }
    if (serviceParameterName) {
      res["ServiceParameterName"] = boost::any(*serviceParameterName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DemoValue") != m.end() && !m["DemoValue"].empty()) {
      demoValue = make_shared<string>(boost::any_cast<string>(m["DemoValue"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("ParameterName") != m.end() && !m["ParameterName"].empty()) {
      parameterName = make_shared<string>(boost::any_cast<string>(m["ParameterName"]));
    }
    if (m.find("ServiceParameterName") != m.end() && !m["ServiceParameterName"].empty()) {
      serviceParameterName = make_shared<string>(boost::any_cast<string>(m["ServiceParameterName"]));
    }
  }


  virtual ~DescribeApiResponseBodyCustomSystemParametersCustomSystemParameter() = default;
};
class DescribeApiResponseBodyCustomSystemParameters : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeApiResponseBodyCustomSystemParametersCustomSystemParameter>> customSystemParameter{};

  DescribeApiResponseBodyCustomSystemParameters() {}

  explicit DescribeApiResponseBodyCustomSystemParameters(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (customSystemParameter) {
      vector<boost::any> temp1;
      for(auto item1:*customSystemParameter){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CustomSystemParameter"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CustomSystemParameter") != m.end() && !m["CustomSystemParameter"].empty()) {
      if (typeid(vector<boost::any>) == m["CustomSystemParameter"].type()) {
        vector<DescribeApiResponseBodyCustomSystemParametersCustomSystemParameter> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CustomSystemParameter"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeApiResponseBodyCustomSystemParametersCustomSystemParameter model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        customSystemParameter = make_shared<vector<DescribeApiResponseBodyCustomSystemParametersCustomSystemParameter>>(expect1);
      }
    }
  }


  virtual ~DescribeApiResponseBodyCustomSystemParameters() = default;
};
class DescribeApiResponseBodyDeployedInfosDeployedInfo : public Darabonba::Model {
public:
  shared_ptr<string> deployedStatus{};
  shared_ptr<string> effectiveVersion{};
  shared_ptr<string> stageName{};

  DescribeApiResponseBodyDeployedInfosDeployedInfo() {}

  explicit DescribeApiResponseBodyDeployedInfosDeployedInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deployedStatus) {
      res["DeployedStatus"] = boost::any(*deployedStatus);
    }
    if (effectiveVersion) {
      res["EffectiveVersion"] = boost::any(*effectiveVersion);
    }
    if (stageName) {
      res["StageName"] = boost::any(*stageName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeployedStatus") != m.end() && !m["DeployedStatus"].empty()) {
      deployedStatus = make_shared<string>(boost::any_cast<string>(m["DeployedStatus"]));
    }
    if (m.find("EffectiveVersion") != m.end() && !m["EffectiveVersion"].empty()) {
      effectiveVersion = make_shared<string>(boost::any_cast<string>(m["EffectiveVersion"]));
    }
    if (m.find("StageName") != m.end() && !m["StageName"].empty()) {
      stageName = make_shared<string>(boost::any_cast<string>(m["StageName"]));
    }
  }


  virtual ~DescribeApiResponseBodyDeployedInfosDeployedInfo() = default;
};
class DescribeApiResponseBodyDeployedInfos : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeApiResponseBodyDeployedInfosDeployedInfo>> deployedInfo{};

  DescribeApiResponseBodyDeployedInfos() {}

  explicit DescribeApiResponseBodyDeployedInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deployedInfo) {
      vector<boost::any> temp1;
      for(auto item1:*deployedInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DeployedInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeployedInfo") != m.end() && !m["DeployedInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["DeployedInfo"].type()) {
        vector<DescribeApiResponseBodyDeployedInfosDeployedInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DeployedInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeApiResponseBodyDeployedInfosDeployedInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        deployedInfo = make_shared<vector<DescribeApiResponseBodyDeployedInfosDeployedInfo>>(expect1);
      }
    }
  }


  virtual ~DescribeApiResponseBodyDeployedInfos() = default;
};
class DescribeApiResponseBodyErrorCodeSamplesErrorCodeSample : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> description{};
  shared_ptr<string> message{};
  shared_ptr<string> model{};

  DescribeApiResponseBodyErrorCodeSamplesErrorCodeSample() {}

  explicit DescribeApiResponseBodyErrorCodeSamplesErrorCodeSample(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (model) {
      res["Model"] = boost::any(*model);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Model") != m.end() && !m["Model"].empty()) {
      model = make_shared<string>(boost::any_cast<string>(m["Model"]));
    }
  }


  virtual ~DescribeApiResponseBodyErrorCodeSamplesErrorCodeSample() = default;
};
class DescribeApiResponseBodyErrorCodeSamples : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeApiResponseBodyErrorCodeSamplesErrorCodeSample>> errorCodeSample{};

  DescribeApiResponseBodyErrorCodeSamples() {}

  explicit DescribeApiResponseBodyErrorCodeSamples(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCodeSample) {
      vector<boost::any> temp1;
      for(auto item1:*errorCodeSample){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ErrorCodeSample"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCodeSample") != m.end() && !m["ErrorCodeSample"].empty()) {
      if (typeid(vector<boost::any>) == m["ErrorCodeSample"].type()) {
        vector<DescribeApiResponseBodyErrorCodeSamplesErrorCodeSample> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ErrorCodeSample"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeApiResponseBodyErrorCodeSamplesErrorCodeSample model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        errorCodeSample = make_shared<vector<DescribeApiResponseBodyErrorCodeSamplesErrorCodeSample>>(expect1);
      }
    }
  }


  virtual ~DescribeApiResponseBodyErrorCodeSamples() = default;
};
class DescribeApiResponseBodyOpenIdConnectConfig : public Darabonba::Model {
public:
  shared_ptr<string> idTokenParamName{};
  shared_ptr<string> openIdApiType{};
  shared_ptr<string> publicKey{};
  shared_ptr<string> publicKeyId{};

  DescribeApiResponseBodyOpenIdConnectConfig() {}

  explicit DescribeApiResponseBodyOpenIdConnectConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (idTokenParamName) {
      res["IdTokenParamName"] = boost::any(*idTokenParamName);
    }
    if (openIdApiType) {
      res["OpenIdApiType"] = boost::any(*openIdApiType);
    }
    if (publicKey) {
      res["PublicKey"] = boost::any(*publicKey);
    }
    if (publicKeyId) {
      res["PublicKeyId"] = boost::any(*publicKeyId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IdTokenParamName") != m.end() && !m["IdTokenParamName"].empty()) {
      idTokenParamName = make_shared<string>(boost::any_cast<string>(m["IdTokenParamName"]));
    }
    if (m.find("OpenIdApiType") != m.end() && !m["OpenIdApiType"].empty()) {
      openIdApiType = make_shared<string>(boost::any_cast<string>(m["OpenIdApiType"]));
    }
    if (m.find("PublicKey") != m.end() && !m["PublicKey"].empty()) {
      publicKey = make_shared<string>(boost::any_cast<string>(m["PublicKey"]));
    }
    if (m.find("PublicKeyId") != m.end() && !m["PublicKeyId"].empty()) {
      publicKeyId = make_shared<string>(boost::any_cast<string>(m["PublicKeyId"]));
    }
  }


  virtual ~DescribeApiResponseBodyOpenIdConnectConfig() = default;
};
class DescribeApiResponseBodyRequestConfig : public Darabonba::Model {
public:
  shared_ptr<string> bodyFormat{};
  shared_ptr<string> bodyModel{};
  shared_ptr<string> postBodyDescription{};
  shared_ptr<string> requestHttpMethod{};
  shared_ptr<string> requestMode{};
  shared_ptr<string> requestPath{};
  shared_ptr<string> requestProtocol{};

  DescribeApiResponseBodyRequestConfig() {}

  explicit DescribeApiResponseBodyRequestConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bodyFormat) {
      res["BodyFormat"] = boost::any(*bodyFormat);
    }
    if (bodyModel) {
      res["BodyModel"] = boost::any(*bodyModel);
    }
    if (postBodyDescription) {
      res["PostBodyDescription"] = boost::any(*postBodyDescription);
    }
    if (requestHttpMethod) {
      res["RequestHttpMethod"] = boost::any(*requestHttpMethod);
    }
    if (requestMode) {
      res["RequestMode"] = boost::any(*requestMode);
    }
    if (requestPath) {
      res["RequestPath"] = boost::any(*requestPath);
    }
    if (requestProtocol) {
      res["RequestProtocol"] = boost::any(*requestProtocol);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BodyFormat") != m.end() && !m["BodyFormat"].empty()) {
      bodyFormat = make_shared<string>(boost::any_cast<string>(m["BodyFormat"]));
    }
    if (m.find("BodyModel") != m.end() && !m["BodyModel"].empty()) {
      bodyModel = make_shared<string>(boost::any_cast<string>(m["BodyModel"]));
    }
    if (m.find("PostBodyDescription") != m.end() && !m["PostBodyDescription"].empty()) {
      postBodyDescription = make_shared<string>(boost::any_cast<string>(m["PostBodyDescription"]));
    }
    if (m.find("RequestHttpMethod") != m.end() && !m["RequestHttpMethod"].empty()) {
      requestHttpMethod = make_shared<string>(boost::any_cast<string>(m["RequestHttpMethod"]));
    }
    if (m.find("RequestMode") != m.end() && !m["RequestMode"].empty()) {
      requestMode = make_shared<string>(boost::any_cast<string>(m["RequestMode"]));
    }
    if (m.find("RequestPath") != m.end() && !m["RequestPath"].empty()) {
      requestPath = make_shared<string>(boost::any_cast<string>(m["RequestPath"]));
    }
    if (m.find("RequestProtocol") != m.end() && !m["RequestProtocol"].empty()) {
      requestProtocol = make_shared<string>(boost::any_cast<string>(m["RequestProtocol"]));
    }
  }


  virtual ~DescribeApiResponseBodyRequestConfig() = default;
};
class DescribeApiResponseBodyRequestParametersRequestParameter : public Darabonba::Model {
public:
  shared_ptr<string> apiParameterName{};
  shared_ptr<string> arrayItemsType{};
  shared_ptr<string> defaultValue{};
  shared_ptr<string> demoValue{};
  shared_ptr<string> description{};
  shared_ptr<long> docOrder{};
  shared_ptr<string> docShow{};
  shared_ptr<string> enumValue{};
  shared_ptr<string> jsonScheme{};
  shared_ptr<string> location{};
  shared_ptr<long> maxLength{};
  shared_ptr<long> maxValue{};
  shared_ptr<long> minLength{};
  shared_ptr<long> minValue{};
  shared_ptr<string> parameterType{};
  shared_ptr<string> regularExpression{};
  shared_ptr<string> required{};

  DescribeApiResponseBodyRequestParametersRequestParameter() {}

  explicit DescribeApiResponseBodyRequestParametersRequestParameter(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiParameterName) {
      res["ApiParameterName"] = boost::any(*apiParameterName);
    }
    if (arrayItemsType) {
      res["ArrayItemsType"] = boost::any(*arrayItemsType);
    }
    if (defaultValue) {
      res["DefaultValue"] = boost::any(*defaultValue);
    }
    if (demoValue) {
      res["DemoValue"] = boost::any(*demoValue);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (docOrder) {
      res["DocOrder"] = boost::any(*docOrder);
    }
    if (docShow) {
      res["DocShow"] = boost::any(*docShow);
    }
    if (enumValue) {
      res["EnumValue"] = boost::any(*enumValue);
    }
    if (jsonScheme) {
      res["JsonScheme"] = boost::any(*jsonScheme);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (maxLength) {
      res["MaxLength"] = boost::any(*maxLength);
    }
    if (maxValue) {
      res["MaxValue"] = boost::any(*maxValue);
    }
    if (minLength) {
      res["MinLength"] = boost::any(*minLength);
    }
    if (minValue) {
      res["MinValue"] = boost::any(*minValue);
    }
    if (parameterType) {
      res["ParameterType"] = boost::any(*parameterType);
    }
    if (regularExpression) {
      res["RegularExpression"] = boost::any(*regularExpression);
    }
    if (required) {
      res["Required"] = boost::any(*required);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiParameterName") != m.end() && !m["ApiParameterName"].empty()) {
      apiParameterName = make_shared<string>(boost::any_cast<string>(m["ApiParameterName"]));
    }
    if (m.find("ArrayItemsType") != m.end() && !m["ArrayItemsType"].empty()) {
      arrayItemsType = make_shared<string>(boost::any_cast<string>(m["ArrayItemsType"]));
    }
    if (m.find("DefaultValue") != m.end() && !m["DefaultValue"].empty()) {
      defaultValue = make_shared<string>(boost::any_cast<string>(m["DefaultValue"]));
    }
    if (m.find("DemoValue") != m.end() && !m["DemoValue"].empty()) {
      demoValue = make_shared<string>(boost::any_cast<string>(m["DemoValue"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DocOrder") != m.end() && !m["DocOrder"].empty()) {
      docOrder = make_shared<long>(boost::any_cast<long>(m["DocOrder"]));
    }
    if (m.find("DocShow") != m.end() && !m["DocShow"].empty()) {
      docShow = make_shared<string>(boost::any_cast<string>(m["DocShow"]));
    }
    if (m.find("EnumValue") != m.end() && !m["EnumValue"].empty()) {
      enumValue = make_shared<string>(boost::any_cast<string>(m["EnumValue"]));
    }
    if (m.find("JsonScheme") != m.end() && !m["JsonScheme"].empty()) {
      jsonScheme = make_shared<string>(boost::any_cast<string>(m["JsonScheme"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("MaxLength") != m.end() && !m["MaxLength"].empty()) {
      maxLength = make_shared<long>(boost::any_cast<long>(m["MaxLength"]));
    }
    if (m.find("MaxValue") != m.end() && !m["MaxValue"].empty()) {
      maxValue = make_shared<long>(boost::any_cast<long>(m["MaxValue"]));
    }
    if (m.find("MinLength") != m.end() && !m["MinLength"].empty()) {
      minLength = make_shared<long>(boost::any_cast<long>(m["MinLength"]));
    }
    if (m.find("MinValue") != m.end() && !m["MinValue"].empty()) {
      minValue = make_shared<long>(boost::any_cast<long>(m["MinValue"]));
    }
    if (m.find("ParameterType") != m.end() && !m["ParameterType"].empty()) {
      parameterType = make_shared<string>(boost::any_cast<string>(m["ParameterType"]));
    }
    if (m.find("RegularExpression") != m.end() && !m["RegularExpression"].empty()) {
      regularExpression = make_shared<string>(boost::any_cast<string>(m["RegularExpression"]));
    }
    if (m.find("Required") != m.end() && !m["Required"].empty()) {
      required = make_shared<string>(boost::any_cast<string>(m["Required"]));
    }
  }


  virtual ~DescribeApiResponseBodyRequestParametersRequestParameter() = default;
};
class DescribeApiResponseBodyRequestParameters : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeApiResponseBodyRequestParametersRequestParameter>> requestParameter{};

  DescribeApiResponseBodyRequestParameters() {}

  explicit DescribeApiResponseBodyRequestParameters(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestParameter) {
      vector<boost::any> temp1;
      for(auto item1:*requestParameter){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RequestParameter"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestParameter") != m.end() && !m["RequestParameter"].empty()) {
      if (typeid(vector<boost::any>) == m["RequestParameter"].type()) {
        vector<DescribeApiResponseBodyRequestParametersRequestParameter> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RequestParameter"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeApiResponseBodyRequestParametersRequestParameter model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        requestParameter = make_shared<vector<DescribeApiResponseBodyRequestParametersRequestParameter>>(expect1);
      }
    }
  }


  virtual ~DescribeApiResponseBodyRequestParameters() = default;
};
class DescribeApiResponseBodyServiceConfigEventBridgeConfig : public Darabonba::Model {
public:
  shared_ptr<string> eventBridgeRegionId{};
  shared_ptr<string> eventBus{};
  shared_ptr<string> eventSource{};
  shared_ptr<string> roleArn{};

  DescribeApiResponseBodyServiceConfigEventBridgeConfig() {}

  explicit DescribeApiResponseBodyServiceConfigEventBridgeConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (eventBridgeRegionId) {
      res["EventBridgeRegionId"] = boost::any(*eventBridgeRegionId);
    }
    if (eventBus) {
      res["EventBus"] = boost::any(*eventBus);
    }
    if (eventSource) {
      res["EventSource"] = boost::any(*eventSource);
    }
    if (roleArn) {
      res["RoleArn"] = boost::any(*roleArn);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EventBridgeRegionId") != m.end() && !m["EventBridgeRegionId"].empty()) {
      eventBridgeRegionId = make_shared<string>(boost::any_cast<string>(m["EventBridgeRegionId"]));
    }
    if (m.find("EventBus") != m.end() && !m["EventBus"].empty()) {
      eventBus = make_shared<string>(boost::any_cast<string>(m["EventBus"]));
    }
    if (m.find("EventSource") != m.end() && !m["EventSource"].empty()) {
      eventSource = make_shared<string>(boost::any_cast<string>(m["EventSource"]));
    }
    if (m.find("RoleArn") != m.end() && !m["RoleArn"].empty()) {
      roleArn = make_shared<string>(boost::any_cast<string>(m["RoleArn"]));
    }
  }


  virtual ~DescribeApiResponseBodyServiceConfigEventBridgeConfig() = default;
};
class DescribeApiResponseBodyServiceConfigFunctionComputeConfig : public Darabonba::Model {
public:
  shared_ptr<string> contentTypeCatagory{};
  shared_ptr<string> contentTypeValue{};
  shared_ptr<string> fcBaseUrl{};
  shared_ptr<string> fcType{};
  shared_ptr<string> functionName{};
  shared_ptr<string> method{};
  shared_ptr<bool> onlyBusinessPath{};
  shared_ptr<string> path{};
  shared_ptr<string> qualifier{};
  shared_ptr<string> regionId{};
  shared_ptr<string> roleArn{};
  shared_ptr<string> serviceName{};

  DescribeApiResponseBodyServiceConfigFunctionComputeConfig() {}

  explicit DescribeApiResponseBodyServiceConfigFunctionComputeConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contentTypeCatagory) {
      res["ContentTypeCatagory"] = boost::any(*contentTypeCatagory);
    }
    if (contentTypeValue) {
      res["ContentTypeValue"] = boost::any(*contentTypeValue);
    }
    if (fcBaseUrl) {
      res["FcBaseUrl"] = boost::any(*fcBaseUrl);
    }
    if (fcType) {
      res["FcType"] = boost::any(*fcType);
    }
    if (functionName) {
      res["FunctionName"] = boost::any(*functionName);
    }
    if (method) {
      res["Method"] = boost::any(*method);
    }
    if (onlyBusinessPath) {
      res["OnlyBusinessPath"] = boost::any(*onlyBusinessPath);
    }
    if (path) {
      res["Path"] = boost::any(*path);
    }
    if (qualifier) {
      res["Qualifier"] = boost::any(*qualifier);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (roleArn) {
      res["RoleArn"] = boost::any(*roleArn);
    }
    if (serviceName) {
      res["ServiceName"] = boost::any(*serviceName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ContentTypeCatagory") != m.end() && !m["ContentTypeCatagory"].empty()) {
      contentTypeCatagory = make_shared<string>(boost::any_cast<string>(m["ContentTypeCatagory"]));
    }
    if (m.find("ContentTypeValue") != m.end() && !m["ContentTypeValue"].empty()) {
      contentTypeValue = make_shared<string>(boost::any_cast<string>(m["ContentTypeValue"]));
    }
    if (m.find("FcBaseUrl") != m.end() && !m["FcBaseUrl"].empty()) {
      fcBaseUrl = make_shared<string>(boost::any_cast<string>(m["FcBaseUrl"]));
    }
    if (m.find("FcType") != m.end() && !m["FcType"].empty()) {
      fcType = make_shared<string>(boost::any_cast<string>(m["FcType"]));
    }
    if (m.find("FunctionName") != m.end() && !m["FunctionName"].empty()) {
      functionName = make_shared<string>(boost::any_cast<string>(m["FunctionName"]));
    }
    if (m.find("Method") != m.end() && !m["Method"].empty()) {
      method = make_shared<string>(boost::any_cast<string>(m["Method"]));
    }
    if (m.find("OnlyBusinessPath") != m.end() && !m["OnlyBusinessPath"].empty()) {
      onlyBusinessPath = make_shared<bool>(boost::any_cast<bool>(m["OnlyBusinessPath"]));
    }
    if (m.find("Path") != m.end() && !m["Path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["Path"]));
    }
    if (m.find("Qualifier") != m.end() && !m["Qualifier"].empty()) {
      qualifier = make_shared<string>(boost::any_cast<string>(m["Qualifier"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("RoleArn") != m.end() && !m["RoleArn"].empty()) {
      roleArn = make_shared<string>(boost::any_cast<string>(m["RoleArn"]));
    }
    if (m.find("ServiceName") != m.end() && !m["ServiceName"].empty()) {
      serviceName = make_shared<string>(boost::any_cast<string>(m["ServiceName"]));
    }
  }


  virtual ~DescribeApiResponseBodyServiceConfigFunctionComputeConfig() = default;
};
class DescribeApiResponseBodyServiceConfigMockHeadersMockHeader : public Darabonba::Model {
public:
  shared_ptr<string> headerName{};
  shared_ptr<string> headerValue{};

  DescribeApiResponseBodyServiceConfigMockHeadersMockHeader() {}

  explicit DescribeApiResponseBodyServiceConfigMockHeadersMockHeader(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headerName) {
      res["HeaderName"] = boost::any(*headerName);
    }
    if (headerValue) {
      res["HeaderValue"] = boost::any(*headerValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HeaderName") != m.end() && !m["HeaderName"].empty()) {
      headerName = make_shared<string>(boost::any_cast<string>(m["HeaderName"]));
    }
    if (m.find("HeaderValue") != m.end() && !m["HeaderValue"].empty()) {
      headerValue = make_shared<string>(boost::any_cast<string>(m["HeaderValue"]));
    }
  }


  virtual ~DescribeApiResponseBodyServiceConfigMockHeadersMockHeader() = default;
};
class DescribeApiResponseBodyServiceConfigMockHeaders : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeApiResponseBodyServiceConfigMockHeadersMockHeader>> mockHeader{};

  DescribeApiResponseBodyServiceConfigMockHeaders() {}

  explicit DescribeApiResponseBodyServiceConfigMockHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mockHeader) {
      vector<boost::any> temp1;
      for(auto item1:*mockHeader){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["MockHeader"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MockHeader") != m.end() && !m["MockHeader"].empty()) {
      if (typeid(vector<boost::any>) == m["MockHeader"].type()) {
        vector<DescribeApiResponseBodyServiceConfigMockHeadersMockHeader> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["MockHeader"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeApiResponseBodyServiceConfigMockHeadersMockHeader model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        mockHeader = make_shared<vector<DescribeApiResponseBodyServiceConfigMockHeadersMockHeader>>(expect1);
      }
    }
  }


  virtual ~DescribeApiResponseBodyServiceConfigMockHeaders() = default;
};
class DescribeApiResponseBodyServiceConfigOssConfig : public Darabonba::Model {
public:
  shared_ptr<string> action{};
  shared_ptr<string> bucketName{};
  shared_ptr<string> key{};
  shared_ptr<string> ossRegionId{};

  DescribeApiResponseBodyServiceConfigOssConfig() {}

  explicit DescribeApiResponseBodyServiceConfigOssConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (action) {
      res["Action"] = boost::any(*action);
    }
    if (bucketName) {
      res["BucketName"] = boost::any(*bucketName);
    }
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (ossRegionId) {
      res["OssRegionId"] = boost::any(*ossRegionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Action") != m.end() && !m["Action"].empty()) {
      action = make_shared<string>(boost::any_cast<string>(m["Action"]));
    }
    if (m.find("BucketName") != m.end() && !m["BucketName"].empty()) {
      bucketName = make_shared<string>(boost::any_cast<string>(m["BucketName"]));
    }
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("OssRegionId") != m.end() && !m["OssRegionId"].empty()) {
      ossRegionId = make_shared<string>(boost::any_cast<string>(m["OssRegionId"]));
    }
  }


  virtual ~DescribeApiResponseBodyServiceConfigOssConfig() = default;
};
class DescribeApiResponseBodyServiceConfigVpcConfig : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> name{};
  shared_ptr<long> port{};
  shared_ptr<string> vpcId{};
  shared_ptr<string> vpcScheme{};

  DescribeApiResponseBodyServiceConfigVpcConfig() {}

  explicit DescribeApiResponseBodyServiceConfigVpcConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    if (vpcScheme) {
      res["VpcScheme"] = boost::any(*vpcScheme);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<long>(boost::any_cast<long>(m["Port"]));
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
    if (m.find("VpcScheme") != m.end() && !m["VpcScheme"].empty()) {
      vpcScheme = make_shared<string>(boost::any_cast<string>(m["VpcScheme"]));
    }
  }


  virtual ~DescribeApiResponseBodyServiceConfigVpcConfig() = default;
};
class DescribeApiResponseBodyServiceConfig : public Darabonba::Model {
public:
  shared_ptr<string> aoneAppName{};
  shared_ptr<string> contentTypeCatagory{};
  shared_ptr<string> contentTypeValue{};
  shared_ptr<DescribeApiResponseBodyServiceConfigEventBridgeConfig> eventBridgeConfig{};
  shared_ptr<DescribeApiResponseBodyServiceConfigFunctionComputeConfig> functionComputeConfig{};
  shared_ptr<string> mock{};
  shared_ptr<DescribeApiResponseBodyServiceConfigMockHeaders> mockHeaders{};
  shared_ptr<string> mockResult{};
  shared_ptr<long> mockStatusCode{};
  shared_ptr<DescribeApiResponseBodyServiceConfigOssConfig> ossConfig{};
  shared_ptr<string> serviceAddress{};
  shared_ptr<string> serviceHttpMethod{};
  shared_ptr<string> servicePath{};
  shared_ptr<string> serviceProtocol{};
  shared_ptr<long> serviceTimeout{};
  shared_ptr<string> serviceVpcEnable{};
  shared_ptr<DescribeApiResponseBodyServiceConfigVpcConfig> vpcConfig{};

  DescribeApiResponseBodyServiceConfig() {}

  explicit DescribeApiResponseBodyServiceConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aoneAppName) {
      res["AoneAppName"] = boost::any(*aoneAppName);
    }
    if (contentTypeCatagory) {
      res["ContentTypeCatagory"] = boost::any(*contentTypeCatagory);
    }
    if (contentTypeValue) {
      res["ContentTypeValue"] = boost::any(*contentTypeValue);
    }
    if (eventBridgeConfig) {
      res["EventBridgeConfig"] = eventBridgeConfig ? boost::any(eventBridgeConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (functionComputeConfig) {
      res["FunctionComputeConfig"] = functionComputeConfig ? boost::any(functionComputeConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (mock) {
      res["Mock"] = boost::any(*mock);
    }
    if (mockHeaders) {
      res["MockHeaders"] = mockHeaders ? boost::any(mockHeaders->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (mockResult) {
      res["MockResult"] = boost::any(*mockResult);
    }
    if (mockStatusCode) {
      res["MockStatusCode"] = boost::any(*mockStatusCode);
    }
    if (ossConfig) {
      res["OssConfig"] = ossConfig ? boost::any(ossConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (serviceAddress) {
      res["ServiceAddress"] = boost::any(*serviceAddress);
    }
    if (serviceHttpMethod) {
      res["ServiceHttpMethod"] = boost::any(*serviceHttpMethod);
    }
    if (servicePath) {
      res["ServicePath"] = boost::any(*servicePath);
    }
    if (serviceProtocol) {
      res["ServiceProtocol"] = boost::any(*serviceProtocol);
    }
    if (serviceTimeout) {
      res["ServiceTimeout"] = boost::any(*serviceTimeout);
    }
    if (serviceVpcEnable) {
      res["ServiceVpcEnable"] = boost::any(*serviceVpcEnable);
    }
    if (vpcConfig) {
      res["VpcConfig"] = vpcConfig ? boost::any(vpcConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AoneAppName") != m.end() && !m["AoneAppName"].empty()) {
      aoneAppName = make_shared<string>(boost::any_cast<string>(m["AoneAppName"]));
    }
    if (m.find("ContentTypeCatagory") != m.end() && !m["ContentTypeCatagory"].empty()) {
      contentTypeCatagory = make_shared<string>(boost::any_cast<string>(m["ContentTypeCatagory"]));
    }
    if (m.find("ContentTypeValue") != m.end() && !m["ContentTypeValue"].empty()) {
      contentTypeValue = make_shared<string>(boost::any_cast<string>(m["ContentTypeValue"]));
    }
    if (m.find("EventBridgeConfig") != m.end() && !m["EventBridgeConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["EventBridgeConfig"].type()) {
        DescribeApiResponseBodyServiceConfigEventBridgeConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["EventBridgeConfig"]));
        eventBridgeConfig = make_shared<DescribeApiResponseBodyServiceConfigEventBridgeConfig>(model1);
      }
    }
    if (m.find("FunctionComputeConfig") != m.end() && !m["FunctionComputeConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["FunctionComputeConfig"].type()) {
        DescribeApiResponseBodyServiceConfigFunctionComputeConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FunctionComputeConfig"]));
        functionComputeConfig = make_shared<DescribeApiResponseBodyServiceConfigFunctionComputeConfig>(model1);
      }
    }
    if (m.find("Mock") != m.end() && !m["Mock"].empty()) {
      mock = make_shared<string>(boost::any_cast<string>(m["Mock"]));
    }
    if (m.find("MockHeaders") != m.end() && !m["MockHeaders"].empty()) {
      if (typeid(map<string, boost::any>) == m["MockHeaders"].type()) {
        DescribeApiResponseBodyServiceConfigMockHeaders model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MockHeaders"]));
        mockHeaders = make_shared<DescribeApiResponseBodyServiceConfigMockHeaders>(model1);
      }
    }
    if (m.find("MockResult") != m.end() && !m["MockResult"].empty()) {
      mockResult = make_shared<string>(boost::any_cast<string>(m["MockResult"]));
    }
    if (m.find("MockStatusCode") != m.end() && !m["MockStatusCode"].empty()) {
      mockStatusCode = make_shared<long>(boost::any_cast<long>(m["MockStatusCode"]));
    }
    if (m.find("OssConfig") != m.end() && !m["OssConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["OssConfig"].type()) {
        DescribeApiResponseBodyServiceConfigOssConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OssConfig"]));
        ossConfig = make_shared<DescribeApiResponseBodyServiceConfigOssConfig>(model1);
      }
    }
    if (m.find("ServiceAddress") != m.end() && !m["ServiceAddress"].empty()) {
      serviceAddress = make_shared<string>(boost::any_cast<string>(m["ServiceAddress"]));
    }
    if (m.find("ServiceHttpMethod") != m.end() && !m["ServiceHttpMethod"].empty()) {
      serviceHttpMethod = make_shared<string>(boost::any_cast<string>(m["ServiceHttpMethod"]));
    }
    if (m.find("ServicePath") != m.end() && !m["ServicePath"].empty()) {
      servicePath = make_shared<string>(boost::any_cast<string>(m["ServicePath"]));
    }
    if (m.find("ServiceProtocol") != m.end() && !m["ServiceProtocol"].empty()) {
      serviceProtocol = make_shared<string>(boost::any_cast<string>(m["ServiceProtocol"]));
    }
    if (m.find("ServiceTimeout") != m.end() && !m["ServiceTimeout"].empty()) {
      serviceTimeout = make_shared<long>(boost::any_cast<long>(m["ServiceTimeout"]));
    }
    if (m.find("ServiceVpcEnable") != m.end() && !m["ServiceVpcEnable"].empty()) {
      serviceVpcEnable = make_shared<string>(boost::any_cast<string>(m["ServiceVpcEnable"]));
    }
    if (m.find("VpcConfig") != m.end() && !m["VpcConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["VpcConfig"].type()) {
        DescribeApiResponseBodyServiceConfigVpcConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["VpcConfig"]));
        vpcConfig = make_shared<DescribeApiResponseBodyServiceConfigVpcConfig>(model1);
      }
    }
  }


  virtual ~DescribeApiResponseBodyServiceConfig() = default;
};
class DescribeApiResponseBodyServiceParametersServiceParameter : public Darabonba::Model {
public:
  shared_ptr<string> location{};
  shared_ptr<string> parameterType{};
  shared_ptr<string> serviceParameterName{};

  DescribeApiResponseBodyServiceParametersServiceParameter() {}

  explicit DescribeApiResponseBodyServiceParametersServiceParameter(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (parameterType) {
      res["ParameterType"] = boost::any(*parameterType);
    }
    if (serviceParameterName) {
      res["ServiceParameterName"] = boost::any(*serviceParameterName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("ParameterType") != m.end() && !m["ParameterType"].empty()) {
      parameterType = make_shared<string>(boost::any_cast<string>(m["ParameterType"]));
    }
    if (m.find("ServiceParameterName") != m.end() && !m["ServiceParameterName"].empty()) {
      serviceParameterName = make_shared<string>(boost::any_cast<string>(m["ServiceParameterName"]));
    }
  }


  virtual ~DescribeApiResponseBodyServiceParametersServiceParameter() = default;
};
class DescribeApiResponseBodyServiceParameters : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeApiResponseBodyServiceParametersServiceParameter>> serviceParameter{};

  DescribeApiResponseBodyServiceParameters() {}

  explicit DescribeApiResponseBodyServiceParameters(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (serviceParameter) {
      vector<boost::any> temp1;
      for(auto item1:*serviceParameter){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ServiceParameter"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ServiceParameter") != m.end() && !m["ServiceParameter"].empty()) {
      if (typeid(vector<boost::any>) == m["ServiceParameter"].type()) {
        vector<DescribeApiResponseBodyServiceParametersServiceParameter> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ServiceParameter"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeApiResponseBodyServiceParametersServiceParameter model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        serviceParameter = make_shared<vector<DescribeApiResponseBodyServiceParametersServiceParameter>>(expect1);
      }
    }
  }


  virtual ~DescribeApiResponseBodyServiceParameters() = default;
};
class DescribeApiResponseBodyServiceParametersMapServiceParameterMap : public Darabonba::Model {
public:
  shared_ptr<string> requestParameterName{};
  shared_ptr<string> serviceParameterName{};

  DescribeApiResponseBodyServiceParametersMapServiceParameterMap() {}

  explicit DescribeApiResponseBodyServiceParametersMapServiceParameterMap(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestParameterName) {
      res["RequestParameterName"] = boost::any(*requestParameterName);
    }
    if (serviceParameterName) {
      res["ServiceParameterName"] = boost::any(*serviceParameterName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestParameterName") != m.end() && !m["RequestParameterName"].empty()) {
      requestParameterName = make_shared<string>(boost::any_cast<string>(m["RequestParameterName"]));
    }
    if (m.find("ServiceParameterName") != m.end() && !m["ServiceParameterName"].empty()) {
      serviceParameterName = make_shared<string>(boost::any_cast<string>(m["ServiceParameterName"]));
    }
  }


  virtual ~DescribeApiResponseBodyServiceParametersMapServiceParameterMap() = default;
};
class DescribeApiResponseBodyServiceParametersMap : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeApiResponseBodyServiceParametersMapServiceParameterMap>> serviceParameterMap{};

  DescribeApiResponseBodyServiceParametersMap() {}

  explicit DescribeApiResponseBodyServiceParametersMap(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (serviceParameterMap) {
      vector<boost::any> temp1;
      for(auto item1:*serviceParameterMap){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ServiceParameterMap"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ServiceParameterMap") != m.end() && !m["ServiceParameterMap"].empty()) {
      if (typeid(vector<boost::any>) == m["ServiceParameterMap"].type()) {
        vector<DescribeApiResponseBodyServiceParametersMapServiceParameterMap> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ServiceParameterMap"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeApiResponseBodyServiceParametersMapServiceParameterMap model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        serviceParameterMap = make_shared<vector<DescribeApiResponseBodyServiceParametersMapServiceParameterMap>>(expect1);
      }
    }
  }


  virtual ~DescribeApiResponseBodyServiceParametersMap() = default;
};
class DescribeApiResponseBodySystemParametersSystemParameter : public Darabonba::Model {
public:
  shared_ptr<string> demoValue{};
  shared_ptr<string> description{};
  shared_ptr<string> location{};
  shared_ptr<string> parameterName{};
  shared_ptr<string> serviceParameterName{};

  DescribeApiResponseBodySystemParametersSystemParameter() {}

  explicit DescribeApiResponseBodySystemParametersSystemParameter(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (demoValue) {
      res["DemoValue"] = boost::any(*demoValue);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (parameterName) {
      res["ParameterName"] = boost::any(*parameterName);
    }
    if (serviceParameterName) {
      res["ServiceParameterName"] = boost::any(*serviceParameterName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DemoValue") != m.end() && !m["DemoValue"].empty()) {
      demoValue = make_shared<string>(boost::any_cast<string>(m["DemoValue"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("ParameterName") != m.end() && !m["ParameterName"].empty()) {
      parameterName = make_shared<string>(boost::any_cast<string>(m["ParameterName"]));
    }
    if (m.find("ServiceParameterName") != m.end() && !m["ServiceParameterName"].empty()) {
      serviceParameterName = make_shared<string>(boost::any_cast<string>(m["ServiceParameterName"]));
    }
  }


  virtual ~DescribeApiResponseBodySystemParametersSystemParameter() = default;
};
class DescribeApiResponseBodySystemParameters : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeApiResponseBodySystemParametersSystemParameter>> systemParameter{};

  DescribeApiResponseBodySystemParameters() {}

  explicit DescribeApiResponseBodySystemParameters(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (systemParameter) {
      vector<boost::any> temp1;
      for(auto item1:*systemParameter){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SystemParameter"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SystemParameter") != m.end() && !m["SystemParameter"].empty()) {
      if (typeid(vector<boost::any>) == m["SystemParameter"].type()) {
        vector<DescribeApiResponseBodySystemParametersSystemParameter> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SystemParameter"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeApiResponseBodySystemParametersSystemParameter model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        systemParameter = make_shared<vector<DescribeApiResponseBodySystemParametersSystemParameter>>(expect1);
      }
    }
  }


  virtual ~DescribeApiResponseBodySystemParameters() = default;
};
class DescribeApiResponseBodyTagListTag : public Darabonba::Model {
public:
  shared_ptr<string> tagKey{};
  shared_ptr<string> tagValue{};

  DescribeApiResponseBodyTagListTag() {}

  explicit DescribeApiResponseBodyTagListTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tagKey) {
      res["TagKey"] = boost::any(*tagKey);
    }
    if (tagValue) {
      res["TagValue"] = boost::any(*tagValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TagKey") != m.end() && !m["TagKey"].empty()) {
      tagKey = make_shared<string>(boost::any_cast<string>(m["TagKey"]));
    }
    if (m.find("TagValue") != m.end() && !m["TagValue"].empty()) {
      tagValue = make_shared<string>(boost::any_cast<string>(m["TagValue"]));
    }
  }


  virtual ~DescribeApiResponseBodyTagListTag() = default;
};
class DescribeApiResponseBodyTagList : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeApiResponseBodyTagListTag>> tag{};

  DescribeApiResponseBodyTagList() {}

  explicit DescribeApiResponseBodyTagList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<DescribeApiResponseBodyTagListTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeApiResponseBodyTagListTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<DescribeApiResponseBodyTagListTag>>(expect1);
      }
    }
  }


  virtual ~DescribeApiResponseBodyTagList() = default;
};
class DescribeApiResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> allowSignatureMethod{};
  shared_ptr<string> apiId{};
  shared_ptr<string> apiName{};
  shared_ptr<string> appCodeAuthType{};
  shared_ptr<string> authType{};
  shared_ptr<DescribeApiResponseBodyBackendConfig> backendConfig{};
  shared_ptr<bool> backendEnable{};
  shared_ptr<DescribeApiResponseBodyConstantParameters> constantParameters{};
  shared_ptr<string> createdTime{};
  shared_ptr<DescribeApiResponseBodyCustomSystemParameters> customSystemParameters{};
  shared_ptr<DescribeApiResponseBodyDeployedInfos> deployedInfos{};
  shared_ptr<string> description{};
  shared_ptr<bool> disableInternet{};
  shared_ptr<DescribeApiResponseBodyErrorCodeSamples> errorCodeSamples{};
  shared_ptr<string> failResultSample{};
  shared_ptr<bool> forceNonceCheck{};
  shared_ptr<string> groupId{};
  shared_ptr<string> groupName{};
  shared_ptr<string> mock{};
  shared_ptr<string> mockResult{};
  shared_ptr<string> modifiedTime{};
  shared_ptr<DescribeApiResponseBodyOpenIdConnectConfig> openIdConnectConfig{};
  shared_ptr<string> regionId{};
  shared_ptr<DescribeApiResponseBodyRequestConfig> requestConfig{};
  shared_ptr<string> requestId{};
  shared_ptr<DescribeApiResponseBodyRequestParameters> requestParameters{};
  shared_ptr<string> resultBodyModel{};
  shared_ptr<string> resultSample{};
  shared_ptr<string> resultType{};
  shared_ptr<DescribeApiResponseBodyServiceConfig> serviceConfig{};
  shared_ptr<DescribeApiResponseBodyServiceParameters> serviceParameters{};
  shared_ptr<DescribeApiResponseBodyServiceParametersMap> serviceParametersMap{};
  shared_ptr<DescribeApiResponseBodySystemParameters> systemParameters{};
  shared_ptr<DescribeApiResponseBodyTagList> tagList{};
  shared_ptr<string> visibility{};
  shared_ptr<string> webSocketApiType{};

  DescribeApiResponseBody() {}

  explicit DescribeApiResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (allowSignatureMethod) {
      res["AllowSignatureMethod"] = boost::any(*allowSignatureMethod);
    }
    if (apiId) {
      res["ApiId"] = boost::any(*apiId);
    }
    if (apiName) {
      res["ApiName"] = boost::any(*apiName);
    }
    if (appCodeAuthType) {
      res["AppCodeAuthType"] = boost::any(*appCodeAuthType);
    }
    if (authType) {
      res["AuthType"] = boost::any(*authType);
    }
    if (backendConfig) {
      res["BackendConfig"] = backendConfig ? boost::any(backendConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (backendEnable) {
      res["BackendEnable"] = boost::any(*backendEnable);
    }
    if (constantParameters) {
      res["ConstantParameters"] = constantParameters ? boost::any(constantParameters->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (createdTime) {
      res["CreatedTime"] = boost::any(*createdTime);
    }
    if (customSystemParameters) {
      res["CustomSystemParameters"] = customSystemParameters ? boost::any(customSystemParameters->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (deployedInfos) {
      res["DeployedInfos"] = deployedInfos ? boost::any(deployedInfos->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (disableInternet) {
      res["DisableInternet"] = boost::any(*disableInternet);
    }
    if (errorCodeSamples) {
      res["ErrorCodeSamples"] = errorCodeSamples ? boost::any(errorCodeSamples->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (failResultSample) {
      res["FailResultSample"] = boost::any(*failResultSample);
    }
    if (forceNonceCheck) {
      res["ForceNonceCheck"] = boost::any(*forceNonceCheck);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (mock) {
      res["Mock"] = boost::any(*mock);
    }
    if (mockResult) {
      res["MockResult"] = boost::any(*mockResult);
    }
    if (modifiedTime) {
      res["ModifiedTime"] = boost::any(*modifiedTime);
    }
    if (openIdConnectConfig) {
      res["OpenIdConnectConfig"] = openIdConnectConfig ? boost::any(openIdConnectConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (requestConfig) {
      res["RequestConfig"] = requestConfig ? boost::any(requestConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (requestParameters) {
      res["RequestParameters"] = requestParameters ? boost::any(requestParameters->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (resultBodyModel) {
      res["ResultBodyModel"] = boost::any(*resultBodyModel);
    }
    if (resultSample) {
      res["ResultSample"] = boost::any(*resultSample);
    }
    if (resultType) {
      res["ResultType"] = boost::any(*resultType);
    }
    if (serviceConfig) {
      res["ServiceConfig"] = serviceConfig ? boost::any(serviceConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (serviceParameters) {
      res["ServiceParameters"] = serviceParameters ? boost::any(serviceParameters->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (serviceParametersMap) {
      res["ServiceParametersMap"] = serviceParametersMap ? boost::any(serviceParametersMap->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (systemParameters) {
      res["SystemParameters"] = systemParameters ? boost::any(systemParameters->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (tagList) {
      res["TagList"] = tagList ? boost::any(tagList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (visibility) {
      res["Visibility"] = boost::any(*visibility);
    }
    if (webSocketApiType) {
      res["WebSocketApiType"] = boost::any(*webSocketApiType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AllowSignatureMethod") != m.end() && !m["AllowSignatureMethod"].empty()) {
      allowSignatureMethod = make_shared<string>(boost::any_cast<string>(m["AllowSignatureMethod"]));
    }
    if (m.find("ApiId") != m.end() && !m["ApiId"].empty()) {
      apiId = make_shared<string>(boost::any_cast<string>(m["ApiId"]));
    }
    if (m.find("ApiName") != m.end() && !m["ApiName"].empty()) {
      apiName = make_shared<string>(boost::any_cast<string>(m["ApiName"]));
    }
    if (m.find("AppCodeAuthType") != m.end() && !m["AppCodeAuthType"].empty()) {
      appCodeAuthType = make_shared<string>(boost::any_cast<string>(m["AppCodeAuthType"]));
    }
    if (m.find("AuthType") != m.end() && !m["AuthType"].empty()) {
      authType = make_shared<string>(boost::any_cast<string>(m["AuthType"]));
    }
    if (m.find("BackendConfig") != m.end() && !m["BackendConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["BackendConfig"].type()) {
        DescribeApiResponseBodyBackendConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["BackendConfig"]));
        backendConfig = make_shared<DescribeApiResponseBodyBackendConfig>(model1);
      }
    }
    if (m.find("BackendEnable") != m.end() && !m["BackendEnable"].empty()) {
      backendEnable = make_shared<bool>(boost::any_cast<bool>(m["BackendEnable"]));
    }
    if (m.find("ConstantParameters") != m.end() && !m["ConstantParameters"].empty()) {
      if (typeid(map<string, boost::any>) == m["ConstantParameters"].type()) {
        DescribeApiResponseBodyConstantParameters model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ConstantParameters"]));
        constantParameters = make_shared<DescribeApiResponseBodyConstantParameters>(model1);
      }
    }
    if (m.find("CreatedTime") != m.end() && !m["CreatedTime"].empty()) {
      createdTime = make_shared<string>(boost::any_cast<string>(m["CreatedTime"]));
    }
    if (m.find("CustomSystemParameters") != m.end() && !m["CustomSystemParameters"].empty()) {
      if (typeid(map<string, boost::any>) == m["CustomSystemParameters"].type()) {
        DescribeApiResponseBodyCustomSystemParameters model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CustomSystemParameters"]));
        customSystemParameters = make_shared<DescribeApiResponseBodyCustomSystemParameters>(model1);
      }
    }
    if (m.find("DeployedInfos") != m.end() && !m["DeployedInfos"].empty()) {
      if (typeid(map<string, boost::any>) == m["DeployedInfos"].type()) {
        DescribeApiResponseBodyDeployedInfos model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DeployedInfos"]));
        deployedInfos = make_shared<DescribeApiResponseBodyDeployedInfos>(model1);
      }
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DisableInternet") != m.end() && !m["DisableInternet"].empty()) {
      disableInternet = make_shared<bool>(boost::any_cast<bool>(m["DisableInternet"]));
    }
    if (m.find("ErrorCodeSamples") != m.end() && !m["ErrorCodeSamples"].empty()) {
      if (typeid(map<string, boost::any>) == m["ErrorCodeSamples"].type()) {
        DescribeApiResponseBodyErrorCodeSamples model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ErrorCodeSamples"]));
        errorCodeSamples = make_shared<DescribeApiResponseBodyErrorCodeSamples>(model1);
      }
    }
    if (m.find("FailResultSample") != m.end() && !m["FailResultSample"].empty()) {
      failResultSample = make_shared<string>(boost::any_cast<string>(m["FailResultSample"]));
    }
    if (m.find("ForceNonceCheck") != m.end() && !m["ForceNonceCheck"].empty()) {
      forceNonceCheck = make_shared<bool>(boost::any_cast<bool>(m["ForceNonceCheck"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("Mock") != m.end() && !m["Mock"].empty()) {
      mock = make_shared<string>(boost::any_cast<string>(m["Mock"]));
    }
    if (m.find("MockResult") != m.end() && !m["MockResult"].empty()) {
      mockResult = make_shared<string>(boost::any_cast<string>(m["MockResult"]));
    }
    if (m.find("ModifiedTime") != m.end() && !m["ModifiedTime"].empty()) {
      modifiedTime = make_shared<string>(boost::any_cast<string>(m["ModifiedTime"]));
    }
    if (m.find("OpenIdConnectConfig") != m.end() && !m["OpenIdConnectConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["OpenIdConnectConfig"].type()) {
        DescribeApiResponseBodyOpenIdConnectConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OpenIdConnectConfig"]));
        openIdConnectConfig = make_shared<DescribeApiResponseBodyOpenIdConnectConfig>(model1);
      }
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("RequestConfig") != m.end() && !m["RequestConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["RequestConfig"].type()) {
        DescribeApiResponseBodyRequestConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RequestConfig"]));
        requestConfig = make_shared<DescribeApiResponseBodyRequestConfig>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("RequestParameters") != m.end() && !m["RequestParameters"].empty()) {
      if (typeid(map<string, boost::any>) == m["RequestParameters"].type()) {
        DescribeApiResponseBodyRequestParameters model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RequestParameters"]));
        requestParameters = make_shared<DescribeApiResponseBodyRequestParameters>(model1);
      }
    }
    if (m.find("ResultBodyModel") != m.end() && !m["ResultBodyModel"].empty()) {
      resultBodyModel = make_shared<string>(boost::any_cast<string>(m["ResultBodyModel"]));
    }
    if (m.find("ResultSample") != m.end() && !m["ResultSample"].empty()) {
      resultSample = make_shared<string>(boost::any_cast<string>(m["ResultSample"]));
    }
    if (m.find("ResultType") != m.end() && !m["ResultType"].empty()) {
      resultType = make_shared<string>(boost::any_cast<string>(m["ResultType"]));
    }
    if (m.find("ServiceConfig") != m.end() && !m["ServiceConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["ServiceConfig"].type()) {
        DescribeApiResponseBodyServiceConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ServiceConfig"]));
        serviceConfig = make_shared<DescribeApiResponseBodyServiceConfig>(model1);
      }
    }
    if (m.find("ServiceParameters") != m.end() && !m["ServiceParameters"].empty()) {
      if (typeid(map<string, boost::any>) == m["ServiceParameters"].type()) {
        DescribeApiResponseBodyServiceParameters model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ServiceParameters"]));
        serviceParameters = make_shared<DescribeApiResponseBodyServiceParameters>(model1);
      }
    }
    if (m.find("ServiceParametersMap") != m.end() && !m["ServiceParametersMap"].empty()) {
      if (typeid(map<string, boost::any>) == m["ServiceParametersMap"].type()) {
        DescribeApiResponseBodyServiceParametersMap model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ServiceParametersMap"]));
        serviceParametersMap = make_shared<DescribeApiResponseBodyServiceParametersMap>(model1);
      }
    }
    if (m.find("SystemParameters") != m.end() && !m["SystemParameters"].empty()) {
      if (typeid(map<string, boost::any>) == m["SystemParameters"].type()) {
        DescribeApiResponseBodySystemParameters model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SystemParameters"]));
        systemParameters = make_shared<DescribeApiResponseBodySystemParameters>(model1);
      }
    }
    if (m.find("TagList") != m.end() && !m["TagList"].empty()) {
      if (typeid(map<string, boost::any>) == m["TagList"].type()) {
        DescribeApiResponseBodyTagList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TagList"]));
        tagList = make_shared<DescribeApiResponseBodyTagList>(model1);
      }
    }
    if (m.find("Visibility") != m.end() && !m["Visibility"].empty()) {
      visibility = make_shared<string>(boost::any_cast<string>(m["Visibility"]));
    }
    if (m.find("WebSocketApiType") != m.end() && !m["WebSocketApiType"].empty()) {
      webSocketApiType = make_shared<string>(boost::any_cast<string>(m["WebSocketApiType"]));
    }
  }


  virtual ~DescribeApiResponseBody() = default;
};
class DescribeApiResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeApiResponseBody> body{};

  DescribeApiResponse() {}

  explicit DescribeApiResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeApiResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeApiResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeApiResponse() = default;
};
class DescribeApiDocRequest : public Darabonba::Model {
public:
  shared_ptr<string> apiId{};
  shared_ptr<string> groupId{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> stageName{};

  DescribeApiDocRequest() {}

  explicit DescribeApiDocRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiId) {
      res["ApiId"] = boost::any(*apiId);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (stageName) {
      res["StageName"] = boost::any(*stageName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiId") != m.end() && !m["ApiId"].empty()) {
      apiId = make_shared<string>(boost::any_cast<string>(m["ApiId"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("StageName") != m.end() && !m["StageName"].empty()) {
      stageName = make_shared<string>(boost::any_cast<string>(m["StageName"]));
    }
  }


  virtual ~DescribeApiDocRequest() = default;
};
class DescribeApiDocResponseBodyErrorCodeSamplesErrorCodeSample : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> description{};
  shared_ptr<string> message{};

  DescribeApiDocResponseBodyErrorCodeSamplesErrorCodeSample() {}

  explicit DescribeApiDocResponseBodyErrorCodeSamplesErrorCodeSample(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
  }


  virtual ~DescribeApiDocResponseBodyErrorCodeSamplesErrorCodeSample() = default;
};
class DescribeApiDocResponseBodyErrorCodeSamples : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeApiDocResponseBodyErrorCodeSamplesErrorCodeSample>> errorCodeSample{};

  DescribeApiDocResponseBodyErrorCodeSamples() {}

  explicit DescribeApiDocResponseBodyErrorCodeSamples(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCodeSample) {
      vector<boost::any> temp1;
      for(auto item1:*errorCodeSample){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ErrorCodeSample"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCodeSample") != m.end() && !m["ErrorCodeSample"].empty()) {
      if (typeid(vector<boost::any>) == m["ErrorCodeSample"].type()) {
        vector<DescribeApiDocResponseBodyErrorCodeSamplesErrorCodeSample> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ErrorCodeSample"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeApiDocResponseBodyErrorCodeSamplesErrorCodeSample model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        errorCodeSample = make_shared<vector<DescribeApiDocResponseBodyErrorCodeSamplesErrorCodeSample>>(expect1);
      }
    }
  }


  virtual ~DescribeApiDocResponseBodyErrorCodeSamples() = default;
};
class DescribeApiDocResponseBodyRequestConfig : public Darabonba::Model {
public:
  shared_ptr<string> bodyFormat{};
  shared_ptr<string> postBodyDescription{};
  shared_ptr<string> requestHttpMethod{};
  shared_ptr<string> requestMode{};
  shared_ptr<string> requestPath{};
  shared_ptr<string> requestProtocol{};

  DescribeApiDocResponseBodyRequestConfig() {}

  explicit DescribeApiDocResponseBodyRequestConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bodyFormat) {
      res["BodyFormat"] = boost::any(*bodyFormat);
    }
    if (postBodyDescription) {
      res["PostBodyDescription"] = boost::any(*postBodyDescription);
    }
    if (requestHttpMethod) {
      res["RequestHttpMethod"] = boost::any(*requestHttpMethod);
    }
    if (requestMode) {
      res["RequestMode"] = boost::any(*requestMode);
    }
    if (requestPath) {
      res["RequestPath"] = boost::any(*requestPath);
    }
    if (requestProtocol) {
      res["RequestProtocol"] = boost::any(*requestProtocol);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BodyFormat") != m.end() && !m["BodyFormat"].empty()) {
      bodyFormat = make_shared<string>(boost::any_cast<string>(m["BodyFormat"]));
    }
    if (m.find("PostBodyDescription") != m.end() && !m["PostBodyDescription"].empty()) {
      postBodyDescription = make_shared<string>(boost::any_cast<string>(m["PostBodyDescription"]));
    }
    if (m.find("RequestHttpMethod") != m.end() && !m["RequestHttpMethod"].empty()) {
      requestHttpMethod = make_shared<string>(boost::any_cast<string>(m["RequestHttpMethod"]));
    }
    if (m.find("RequestMode") != m.end() && !m["RequestMode"].empty()) {
      requestMode = make_shared<string>(boost::any_cast<string>(m["RequestMode"]));
    }
    if (m.find("RequestPath") != m.end() && !m["RequestPath"].empty()) {
      requestPath = make_shared<string>(boost::any_cast<string>(m["RequestPath"]));
    }
    if (m.find("RequestProtocol") != m.end() && !m["RequestProtocol"].empty()) {
      requestProtocol = make_shared<string>(boost::any_cast<string>(m["RequestProtocol"]));
    }
  }


  virtual ~DescribeApiDocResponseBodyRequestConfig() = default;
};
class DescribeApiDocResponseBodyRequestParametersRequestParameter : public Darabonba::Model {
public:
  shared_ptr<string> apiParameterName{};
  shared_ptr<string> arrayItemsType{};
  shared_ptr<string> defaultValue{};
  shared_ptr<string> demoValue{};
  shared_ptr<string> description{};
  shared_ptr<long> docOrder{};
  shared_ptr<string> docShow{};
  shared_ptr<string> enumValue{};
  shared_ptr<string> jsonScheme{};
  shared_ptr<string> location{};
  shared_ptr<long> maxLength{};
  shared_ptr<long> maxValue{};
  shared_ptr<long> minLength{};
  shared_ptr<long> minValue{};
  shared_ptr<string> parameterType{};
  shared_ptr<string> regularExpression{};
  shared_ptr<string> required{};

  DescribeApiDocResponseBodyRequestParametersRequestParameter() {}

  explicit DescribeApiDocResponseBodyRequestParametersRequestParameter(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiParameterName) {
      res["ApiParameterName"] = boost::any(*apiParameterName);
    }
    if (arrayItemsType) {
      res["ArrayItemsType"] = boost::any(*arrayItemsType);
    }
    if (defaultValue) {
      res["DefaultValue"] = boost::any(*defaultValue);
    }
    if (demoValue) {
      res["DemoValue"] = boost::any(*demoValue);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (docOrder) {
      res["DocOrder"] = boost::any(*docOrder);
    }
    if (docShow) {
      res["DocShow"] = boost::any(*docShow);
    }
    if (enumValue) {
      res["EnumValue"] = boost::any(*enumValue);
    }
    if (jsonScheme) {
      res["JsonScheme"] = boost::any(*jsonScheme);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (maxLength) {
      res["MaxLength"] = boost::any(*maxLength);
    }
    if (maxValue) {
      res["MaxValue"] = boost::any(*maxValue);
    }
    if (minLength) {
      res["MinLength"] = boost::any(*minLength);
    }
    if (minValue) {
      res["MinValue"] = boost::any(*minValue);
    }
    if (parameterType) {
      res["ParameterType"] = boost::any(*parameterType);
    }
    if (regularExpression) {
      res["RegularExpression"] = boost::any(*regularExpression);
    }
    if (required) {
      res["Required"] = boost::any(*required);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiParameterName") != m.end() && !m["ApiParameterName"].empty()) {
      apiParameterName = make_shared<string>(boost::any_cast<string>(m["ApiParameterName"]));
    }
    if (m.find("ArrayItemsType") != m.end() && !m["ArrayItemsType"].empty()) {
      arrayItemsType = make_shared<string>(boost::any_cast<string>(m["ArrayItemsType"]));
    }
    if (m.find("DefaultValue") != m.end() && !m["DefaultValue"].empty()) {
      defaultValue = make_shared<string>(boost::any_cast<string>(m["DefaultValue"]));
    }
    if (m.find("DemoValue") != m.end() && !m["DemoValue"].empty()) {
      demoValue = make_shared<string>(boost::any_cast<string>(m["DemoValue"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DocOrder") != m.end() && !m["DocOrder"].empty()) {
      docOrder = make_shared<long>(boost::any_cast<long>(m["DocOrder"]));
    }
    if (m.find("DocShow") != m.end() && !m["DocShow"].empty()) {
      docShow = make_shared<string>(boost::any_cast<string>(m["DocShow"]));
    }
    if (m.find("EnumValue") != m.end() && !m["EnumValue"].empty()) {
      enumValue = make_shared<string>(boost::any_cast<string>(m["EnumValue"]));
    }
    if (m.find("JsonScheme") != m.end() && !m["JsonScheme"].empty()) {
      jsonScheme = make_shared<string>(boost::any_cast<string>(m["JsonScheme"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("MaxLength") != m.end() && !m["MaxLength"].empty()) {
      maxLength = make_shared<long>(boost::any_cast<long>(m["MaxLength"]));
    }
    if (m.find("MaxValue") != m.end() && !m["MaxValue"].empty()) {
      maxValue = make_shared<long>(boost::any_cast<long>(m["MaxValue"]));
    }
    if (m.find("MinLength") != m.end() && !m["MinLength"].empty()) {
      minLength = make_shared<long>(boost::any_cast<long>(m["MinLength"]));
    }
    if (m.find("MinValue") != m.end() && !m["MinValue"].empty()) {
      minValue = make_shared<long>(boost::any_cast<long>(m["MinValue"]));
    }
    if (m.find("ParameterType") != m.end() && !m["ParameterType"].empty()) {
      parameterType = make_shared<string>(boost::any_cast<string>(m["ParameterType"]));
    }
    if (m.find("RegularExpression") != m.end() && !m["RegularExpression"].empty()) {
      regularExpression = make_shared<string>(boost::any_cast<string>(m["RegularExpression"]));
    }
    if (m.find("Required") != m.end() && !m["Required"].empty()) {
      required = make_shared<string>(boost::any_cast<string>(m["Required"]));
    }
  }


  virtual ~DescribeApiDocResponseBodyRequestParametersRequestParameter() = default;
};
class DescribeApiDocResponseBodyRequestParameters : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeApiDocResponseBodyRequestParametersRequestParameter>> requestParameter{};

  DescribeApiDocResponseBodyRequestParameters() {}

  explicit DescribeApiDocResponseBodyRequestParameters(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestParameter) {
      vector<boost::any> temp1;
      for(auto item1:*requestParameter){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RequestParameter"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestParameter") != m.end() && !m["RequestParameter"].empty()) {
      if (typeid(vector<boost::any>) == m["RequestParameter"].type()) {
        vector<DescribeApiDocResponseBodyRequestParametersRequestParameter> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RequestParameter"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeApiDocResponseBodyRequestParametersRequestParameter model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        requestParameter = make_shared<vector<DescribeApiDocResponseBodyRequestParametersRequestParameter>>(expect1);
      }
    }
  }


  virtual ~DescribeApiDocResponseBodyRequestParameters() = default;
};
class DescribeApiDocResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> apiId{};
  shared_ptr<string> apiName{};
  shared_ptr<string> authType{};
  shared_ptr<string> deployedTime{};
  shared_ptr<string> description{};
  shared_ptr<bool> disableInternet{};
  shared_ptr<DescribeApiDocResponseBodyErrorCodeSamples> errorCodeSamples{};
  shared_ptr<string> failResultSample{};
  shared_ptr<bool> forceNonceCheck{};
  shared_ptr<string> groupId{};
  shared_ptr<string> groupName{};
  shared_ptr<string> regionId{};
  shared_ptr<DescribeApiDocResponseBodyRequestConfig> requestConfig{};
  shared_ptr<string> requestId{};
  shared_ptr<DescribeApiDocResponseBodyRequestParameters> requestParameters{};
  shared_ptr<string> resultSample{};
  shared_ptr<string> resultType{};
  shared_ptr<string> stageName{};
  shared_ptr<string> visibility{};

  DescribeApiDocResponseBody() {}

  explicit DescribeApiDocResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiId) {
      res["ApiId"] = boost::any(*apiId);
    }
    if (apiName) {
      res["ApiName"] = boost::any(*apiName);
    }
    if (authType) {
      res["AuthType"] = boost::any(*authType);
    }
    if (deployedTime) {
      res["DeployedTime"] = boost::any(*deployedTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (disableInternet) {
      res["DisableInternet"] = boost::any(*disableInternet);
    }
    if (errorCodeSamples) {
      res["ErrorCodeSamples"] = errorCodeSamples ? boost::any(errorCodeSamples->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (failResultSample) {
      res["FailResultSample"] = boost::any(*failResultSample);
    }
    if (forceNonceCheck) {
      res["ForceNonceCheck"] = boost::any(*forceNonceCheck);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (requestConfig) {
      res["RequestConfig"] = requestConfig ? boost::any(requestConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (requestParameters) {
      res["RequestParameters"] = requestParameters ? boost::any(requestParameters->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (resultSample) {
      res["ResultSample"] = boost::any(*resultSample);
    }
    if (resultType) {
      res["ResultType"] = boost::any(*resultType);
    }
    if (stageName) {
      res["StageName"] = boost::any(*stageName);
    }
    if (visibility) {
      res["Visibility"] = boost::any(*visibility);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiId") != m.end() && !m["ApiId"].empty()) {
      apiId = make_shared<string>(boost::any_cast<string>(m["ApiId"]));
    }
    if (m.find("ApiName") != m.end() && !m["ApiName"].empty()) {
      apiName = make_shared<string>(boost::any_cast<string>(m["ApiName"]));
    }
    if (m.find("AuthType") != m.end() && !m["AuthType"].empty()) {
      authType = make_shared<string>(boost::any_cast<string>(m["AuthType"]));
    }
    if (m.find("DeployedTime") != m.end() && !m["DeployedTime"].empty()) {
      deployedTime = make_shared<string>(boost::any_cast<string>(m["DeployedTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DisableInternet") != m.end() && !m["DisableInternet"].empty()) {
      disableInternet = make_shared<bool>(boost::any_cast<bool>(m["DisableInternet"]));
    }
    if (m.find("ErrorCodeSamples") != m.end() && !m["ErrorCodeSamples"].empty()) {
      if (typeid(map<string, boost::any>) == m["ErrorCodeSamples"].type()) {
        DescribeApiDocResponseBodyErrorCodeSamples model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ErrorCodeSamples"]));
        errorCodeSamples = make_shared<DescribeApiDocResponseBodyErrorCodeSamples>(model1);
      }
    }
    if (m.find("FailResultSample") != m.end() && !m["FailResultSample"].empty()) {
      failResultSample = make_shared<string>(boost::any_cast<string>(m["FailResultSample"]));
    }
    if (m.find("ForceNonceCheck") != m.end() && !m["ForceNonceCheck"].empty()) {
      forceNonceCheck = make_shared<bool>(boost::any_cast<bool>(m["ForceNonceCheck"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("RequestConfig") != m.end() && !m["RequestConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["RequestConfig"].type()) {
        DescribeApiDocResponseBodyRequestConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RequestConfig"]));
        requestConfig = make_shared<DescribeApiDocResponseBodyRequestConfig>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("RequestParameters") != m.end() && !m["RequestParameters"].empty()) {
      if (typeid(map<string, boost::any>) == m["RequestParameters"].type()) {
        DescribeApiDocResponseBodyRequestParameters model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RequestParameters"]));
        requestParameters = make_shared<DescribeApiDocResponseBodyRequestParameters>(model1);
      }
    }
    if (m.find("ResultSample") != m.end() && !m["ResultSample"].empty()) {
      resultSample = make_shared<string>(boost::any_cast<string>(m["ResultSample"]));
    }
    if (m.find("ResultType") != m.end() && !m["ResultType"].empty()) {
      resultType = make_shared<string>(boost::any_cast<string>(m["ResultType"]));
    }
    if (m.find("StageName") != m.end() && !m["StageName"].empty()) {
      stageName = make_shared<string>(boost::any_cast<string>(m["StageName"]));
    }
    if (m.find("Visibility") != m.end() && !m["Visibility"].empty()) {
      visibility = make_shared<string>(boost::any_cast<string>(m["Visibility"]));
    }
  }


  virtual ~DescribeApiDocResponseBody() = default;
};
class DescribeApiDocResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeApiDocResponseBody> body{};

  DescribeApiDocResponse() {}

  explicit DescribeApiDocResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeApiDocResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeApiDocResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeApiDocResponse() = default;
};
class DescribeApiGroupRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  DescribeApiGroupRequestTag() {}

  explicit DescribeApiGroupRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeApiGroupRequestTag() = default;
};
class DescribeApiGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> groupId{};
  shared_ptr<string> securityToken{};
  shared_ptr<vector<DescribeApiGroupRequestTag>> tag{};

  DescribeApiGroupRequest() {}

  explicit DescribeApiGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<DescribeApiGroupRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeApiGroupRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<DescribeApiGroupRequestTag>>(expect1);
      }
    }
  }


  virtual ~DescribeApiGroupRequest() = default;
};
class DescribeApiGroupResponseBodyCustomDomainsDomainItem : public Darabonba::Model {
public:
  shared_ptr<string> bindStageAlias{};
  shared_ptr<string> bindStageName{};
  shared_ptr<string> certificateId{};
  shared_ptr<string> certificateName{};
  shared_ptr<long> certificateValidEnd{};
  shared_ptr<long> certificateValidStart{};
  shared_ptr<string> customDomainType{};
  shared_ptr<string> domainBindingStatus{};
  shared_ptr<string> domainCNAMEStatus{};
  shared_ptr<string> domainLegalStatus{};
  shared_ptr<string> domainName{};
  shared_ptr<string> domainRemark{};
  shared_ptr<string> domainWebSocketStatus{};
  shared_ptr<bool> isHttpRedirectToHttps{};
  shared_ptr<string> wildcardDomainPatterns{};

  DescribeApiGroupResponseBodyCustomDomainsDomainItem() {}

  explicit DescribeApiGroupResponseBodyCustomDomainsDomainItem(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bindStageAlias) {
      res["BindStageAlias"] = boost::any(*bindStageAlias);
    }
    if (bindStageName) {
      res["BindStageName"] = boost::any(*bindStageName);
    }
    if (certificateId) {
      res["CertificateId"] = boost::any(*certificateId);
    }
    if (certificateName) {
      res["CertificateName"] = boost::any(*certificateName);
    }
    if (certificateValidEnd) {
      res["CertificateValidEnd"] = boost::any(*certificateValidEnd);
    }
    if (certificateValidStart) {
      res["CertificateValidStart"] = boost::any(*certificateValidStart);
    }
    if (customDomainType) {
      res["CustomDomainType"] = boost::any(*customDomainType);
    }
    if (domainBindingStatus) {
      res["DomainBindingStatus"] = boost::any(*domainBindingStatus);
    }
    if (domainCNAMEStatus) {
      res["DomainCNAMEStatus"] = boost::any(*domainCNAMEStatus);
    }
    if (domainLegalStatus) {
      res["DomainLegalStatus"] = boost::any(*domainLegalStatus);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (domainRemark) {
      res["DomainRemark"] = boost::any(*domainRemark);
    }
    if (domainWebSocketStatus) {
      res["DomainWebSocketStatus"] = boost::any(*domainWebSocketStatus);
    }
    if (isHttpRedirectToHttps) {
      res["IsHttpRedirectToHttps"] = boost::any(*isHttpRedirectToHttps);
    }
    if (wildcardDomainPatterns) {
      res["WildcardDomainPatterns"] = boost::any(*wildcardDomainPatterns);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BindStageAlias") != m.end() && !m["BindStageAlias"].empty()) {
      bindStageAlias = make_shared<string>(boost::any_cast<string>(m["BindStageAlias"]));
    }
    if (m.find("BindStageName") != m.end() && !m["BindStageName"].empty()) {
      bindStageName = make_shared<string>(boost::any_cast<string>(m["BindStageName"]));
    }
    if (m.find("CertificateId") != m.end() && !m["CertificateId"].empty()) {
      certificateId = make_shared<string>(boost::any_cast<string>(m["CertificateId"]));
    }
    if (m.find("CertificateName") != m.end() && !m["CertificateName"].empty()) {
      certificateName = make_shared<string>(boost::any_cast<string>(m["CertificateName"]));
    }
    if (m.find("CertificateValidEnd") != m.end() && !m["CertificateValidEnd"].empty()) {
      certificateValidEnd = make_shared<long>(boost::any_cast<long>(m["CertificateValidEnd"]));
    }
    if (m.find("CertificateValidStart") != m.end() && !m["CertificateValidStart"].empty()) {
      certificateValidStart = make_shared<long>(boost::any_cast<long>(m["CertificateValidStart"]));
    }
    if (m.find("CustomDomainType") != m.end() && !m["CustomDomainType"].empty()) {
      customDomainType = make_shared<string>(boost::any_cast<string>(m["CustomDomainType"]));
    }
    if (m.find("DomainBindingStatus") != m.end() && !m["DomainBindingStatus"].empty()) {
      domainBindingStatus = make_shared<string>(boost::any_cast<string>(m["DomainBindingStatus"]));
    }
    if (m.find("DomainCNAMEStatus") != m.end() && !m["DomainCNAMEStatus"].empty()) {
      domainCNAMEStatus = make_shared<string>(boost::any_cast<string>(m["DomainCNAMEStatus"]));
    }
    if (m.find("DomainLegalStatus") != m.end() && !m["DomainLegalStatus"].empty()) {
      domainLegalStatus = make_shared<string>(boost::any_cast<string>(m["DomainLegalStatus"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("DomainRemark") != m.end() && !m["DomainRemark"].empty()) {
      domainRemark = make_shared<string>(boost::any_cast<string>(m["DomainRemark"]));
    }
    if (m.find("DomainWebSocketStatus") != m.end() && !m["DomainWebSocketStatus"].empty()) {
      domainWebSocketStatus = make_shared<string>(boost::any_cast<string>(m["DomainWebSocketStatus"]));
    }
    if (m.find("IsHttpRedirectToHttps") != m.end() && !m["IsHttpRedirectToHttps"].empty()) {
      isHttpRedirectToHttps = make_shared<bool>(boost::any_cast<bool>(m["IsHttpRedirectToHttps"]));
    }
    if (m.find("WildcardDomainPatterns") != m.end() && !m["WildcardDomainPatterns"].empty()) {
      wildcardDomainPatterns = make_shared<string>(boost::any_cast<string>(m["WildcardDomainPatterns"]));
    }
  }


  virtual ~DescribeApiGroupResponseBodyCustomDomainsDomainItem() = default;
};
class DescribeApiGroupResponseBodyCustomDomains : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeApiGroupResponseBodyCustomDomainsDomainItem>> domainItem{};

  DescribeApiGroupResponseBodyCustomDomains() {}

  explicit DescribeApiGroupResponseBodyCustomDomains(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainItem) {
      vector<boost::any> temp1;
      for(auto item1:*domainItem){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DomainItem"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainItem") != m.end() && !m["DomainItem"].empty()) {
      if (typeid(vector<boost::any>) == m["DomainItem"].type()) {
        vector<DescribeApiGroupResponseBodyCustomDomainsDomainItem> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DomainItem"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeApiGroupResponseBodyCustomDomainsDomainItem model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        domainItem = make_shared<vector<DescribeApiGroupResponseBodyCustomDomainsDomainItem>>(expect1);
      }
    }
  }


  virtual ~DescribeApiGroupResponseBodyCustomDomains() = default;
};
class DescribeApiGroupResponseBodyStageItemsStageInfo : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> stageId{};
  shared_ptr<string> stageName{};

  DescribeApiGroupResponseBodyStageItemsStageInfo() {}

  explicit DescribeApiGroupResponseBodyStageItemsStageInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (stageId) {
      res["StageId"] = boost::any(*stageId);
    }
    if (stageName) {
      res["StageName"] = boost::any(*stageName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("StageId") != m.end() && !m["StageId"].empty()) {
      stageId = make_shared<string>(boost::any_cast<string>(m["StageId"]));
    }
    if (m.find("StageName") != m.end() && !m["StageName"].empty()) {
      stageName = make_shared<string>(boost::any_cast<string>(m["StageName"]));
    }
  }


  virtual ~DescribeApiGroupResponseBodyStageItemsStageInfo() = default;
};
class DescribeApiGroupResponseBodyStageItems : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeApiGroupResponseBodyStageItemsStageInfo>> stageInfo{};

  DescribeApiGroupResponseBodyStageItems() {}

  explicit DescribeApiGroupResponseBodyStageItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (stageInfo) {
      vector<boost::any> temp1;
      for(auto item1:*stageInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["StageInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("StageInfo") != m.end() && !m["StageInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["StageInfo"].type()) {
        vector<DescribeApiGroupResponseBodyStageItemsStageInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["StageInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeApiGroupResponseBodyStageItemsStageInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        stageInfo = make_shared<vector<DescribeApiGroupResponseBodyStageItemsStageInfo>>(expect1);
      }
    }
  }


  virtual ~DescribeApiGroupResponseBodyStageItems() = default;
};
class DescribeApiGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> basePath{};
  shared_ptr<string> billingStatus{};
  shared_ptr<bool> cloudMarketCommodity{};
  shared_ptr<string> cmsMonitorGroup{};
  shared_ptr<string> compatibleFlags{};
  shared_ptr<string> createdTime{};
  shared_ptr<DescribeApiGroupResponseBodyCustomDomains> customDomains{};
  shared_ptr<string> customTraceConfig{};
  shared_ptr<string> customerConfigs{};
  shared_ptr<string> dedicatedInstanceType{};
  shared_ptr<string> defaultDomain{};
  shared_ptr<string> description{};
  shared_ptr<bool> disableInnerDomain{};
  shared_ptr<string> groupId{};
  shared_ptr<string> groupName{};
  shared_ptr<string> httpsPolicy{};
  shared_ptr<string> illegalStatus{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> instanceType{};
  shared_ptr<string> ipv6Status{};
  shared_ptr<string> migrationError{};
  shared_ptr<string> migrationStatus{};
  shared_ptr<string> modifiedTime{};
  shared_ptr<string> passthroughHeaders{};
  shared_ptr<string> regionId{};
  shared_ptr<string> requestId{};
  shared_ptr<DescribeApiGroupResponseBodyStageItems> stageItems{};
  shared_ptr<string> status{};
  shared_ptr<string> subDomain{};
  shared_ptr<long> trafficLimit{};
  shared_ptr<string> userLogConfig{};
  shared_ptr<string> vpcDomain{};
  shared_ptr<string> vpcSlbIntranetDomain{};

  DescribeApiGroupResponseBody() {}

  explicit DescribeApiGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (basePath) {
      res["BasePath"] = boost::any(*basePath);
    }
    if (billingStatus) {
      res["BillingStatus"] = boost::any(*billingStatus);
    }
    if (cloudMarketCommodity) {
      res["CloudMarketCommodity"] = boost::any(*cloudMarketCommodity);
    }
    if (cmsMonitorGroup) {
      res["CmsMonitorGroup"] = boost::any(*cmsMonitorGroup);
    }
    if (compatibleFlags) {
      res["CompatibleFlags"] = boost::any(*compatibleFlags);
    }
    if (createdTime) {
      res["CreatedTime"] = boost::any(*createdTime);
    }
    if (customDomains) {
      res["CustomDomains"] = customDomains ? boost::any(customDomains->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (customTraceConfig) {
      res["CustomTraceConfig"] = boost::any(*customTraceConfig);
    }
    if (customerConfigs) {
      res["CustomerConfigs"] = boost::any(*customerConfigs);
    }
    if (dedicatedInstanceType) {
      res["DedicatedInstanceType"] = boost::any(*dedicatedInstanceType);
    }
    if (defaultDomain) {
      res["DefaultDomain"] = boost::any(*defaultDomain);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (disableInnerDomain) {
      res["DisableInnerDomain"] = boost::any(*disableInnerDomain);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (httpsPolicy) {
      res["HttpsPolicy"] = boost::any(*httpsPolicy);
    }
    if (illegalStatus) {
      res["IllegalStatus"] = boost::any(*illegalStatus);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (ipv6Status) {
      res["Ipv6Status"] = boost::any(*ipv6Status);
    }
    if (migrationError) {
      res["MigrationError"] = boost::any(*migrationError);
    }
    if (migrationStatus) {
      res["MigrationStatus"] = boost::any(*migrationStatus);
    }
    if (modifiedTime) {
      res["ModifiedTime"] = boost::any(*modifiedTime);
    }
    if (passthroughHeaders) {
      res["PassthroughHeaders"] = boost::any(*passthroughHeaders);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (stageItems) {
      res["StageItems"] = stageItems ? boost::any(stageItems->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (subDomain) {
      res["SubDomain"] = boost::any(*subDomain);
    }
    if (trafficLimit) {
      res["TrafficLimit"] = boost::any(*trafficLimit);
    }
    if (userLogConfig) {
      res["UserLogConfig"] = boost::any(*userLogConfig);
    }
    if (vpcDomain) {
      res["VpcDomain"] = boost::any(*vpcDomain);
    }
    if (vpcSlbIntranetDomain) {
      res["VpcSlbIntranetDomain"] = boost::any(*vpcSlbIntranetDomain);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BasePath") != m.end() && !m["BasePath"].empty()) {
      basePath = make_shared<string>(boost::any_cast<string>(m["BasePath"]));
    }
    if (m.find("BillingStatus") != m.end() && !m["BillingStatus"].empty()) {
      billingStatus = make_shared<string>(boost::any_cast<string>(m["BillingStatus"]));
    }
    if (m.find("CloudMarketCommodity") != m.end() && !m["CloudMarketCommodity"].empty()) {
      cloudMarketCommodity = make_shared<bool>(boost::any_cast<bool>(m["CloudMarketCommodity"]));
    }
    if (m.find("CmsMonitorGroup") != m.end() && !m["CmsMonitorGroup"].empty()) {
      cmsMonitorGroup = make_shared<string>(boost::any_cast<string>(m["CmsMonitorGroup"]));
    }
    if (m.find("CompatibleFlags") != m.end() && !m["CompatibleFlags"].empty()) {
      compatibleFlags = make_shared<string>(boost::any_cast<string>(m["CompatibleFlags"]));
    }
    if (m.find("CreatedTime") != m.end() && !m["CreatedTime"].empty()) {
      createdTime = make_shared<string>(boost::any_cast<string>(m["CreatedTime"]));
    }
    if (m.find("CustomDomains") != m.end() && !m["CustomDomains"].empty()) {
      if (typeid(map<string, boost::any>) == m["CustomDomains"].type()) {
        DescribeApiGroupResponseBodyCustomDomains model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CustomDomains"]));
        customDomains = make_shared<DescribeApiGroupResponseBodyCustomDomains>(model1);
      }
    }
    if (m.find("CustomTraceConfig") != m.end() && !m["CustomTraceConfig"].empty()) {
      customTraceConfig = make_shared<string>(boost::any_cast<string>(m["CustomTraceConfig"]));
    }
    if (m.find("CustomerConfigs") != m.end() && !m["CustomerConfigs"].empty()) {
      customerConfigs = make_shared<string>(boost::any_cast<string>(m["CustomerConfigs"]));
    }
    if (m.find("DedicatedInstanceType") != m.end() && !m["DedicatedInstanceType"].empty()) {
      dedicatedInstanceType = make_shared<string>(boost::any_cast<string>(m["DedicatedInstanceType"]));
    }
    if (m.find("DefaultDomain") != m.end() && !m["DefaultDomain"].empty()) {
      defaultDomain = make_shared<string>(boost::any_cast<string>(m["DefaultDomain"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DisableInnerDomain") != m.end() && !m["DisableInnerDomain"].empty()) {
      disableInnerDomain = make_shared<bool>(boost::any_cast<bool>(m["DisableInnerDomain"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("HttpsPolicy") != m.end() && !m["HttpsPolicy"].empty()) {
      httpsPolicy = make_shared<string>(boost::any_cast<string>(m["HttpsPolicy"]));
    }
    if (m.find("IllegalStatus") != m.end() && !m["IllegalStatus"].empty()) {
      illegalStatus = make_shared<string>(boost::any_cast<string>(m["IllegalStatus"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("Ipv6Status") != m.end() && !m["Ipv6Status"].empty()) {
      ipv6Status = make_shared<string>(boost::any_cast<string>(m["Ipv6Status"]));
    }
    if (m.find("MigrationError") != m.end() && !m["MigrationError"].empty()) {
      migrationError = make_shared<string>(boost::any_cast<string>(m["MigrationError"]));
    }
    if (m.find("MigrationStatus") != m.end() && !m["MigrationStatus"].empty()) {
      migrationStatus = make_shared<string>(boost::any_cast<string>(m["MigrationStatus"]));
    }
    if (m.find("ModifiedTime") != m.end() && !m["ModifiedTime"].empty()) {
      modifiedTime = make_shared<string>(boost::any_cast<string>(m["ModifiedTime"]));
    }
    if (m.find("PassthroughHeaders") != m.end() && !m["PassthroughHeaders"].empty()) {
      passthroughHeaders = make_shared<string>(boost::any_cast<string>(m["PassthroughHeaders"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("StageItems") != m.end() && !m["StageItems"].empty()) {
      if (typeid(map<string, boost::any>) == m["StageItems"].type()) {
        DescribeApiGroupResponseBodyStageItems model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["StageItems"]));
        stageItems = make_shared<DescribeApiGroupResponseBodyStageItems>(model1);
      }
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("SubDomain") != m.end() && !m["SubDomain"].empty()) {
      subDomain = make_shared<string>(boost::any_cast<string>(m["SubDomain"]));
    }
    if (m.find("TrafficLimit") != m.end() && !m["TrafficLimit"].empty()) {
      trafficLimit = make_shared<long>(boost::any_cast<long>(m["TrafficLimit"]));
    }
    if (m.find("UserLogConfig") != m.end() && !m["UserLogConfig"].empty()) {
      userLogConfig = make_shared<string>(boost::any_cast<string>(m["UserLogConfig"]));
    }
    if (m.find("VpcDomain") != m.end() && !m["VpcDomain"].empty()) {
      vpcDomain = make_shared<string>(boost::any_cast<string>(m["VpcDomain"]));
    }
    if (m.find("VpcSlbIntranetDomain") != m.end() && !m["VpcSlbIntranetDomain"].empty()) {
      vpcSlbIntranetDomain = make_shared<string>(boost::any_cast<string>(m["VpcSlbIntranetDomain"]));
    }
  }


  virtual ~DescribeApiGroupResponseBody() = default;
};
class DescribeApiGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeApiGroupResponseBody> body{};

  DescribeApiGroupResponse() {}

  explicit DescribeApiGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeApiGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeApiGroupResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeApiGroupResponse() = default;
};
class DescribeApiGroupVpcWhitelistRequest : public Darabonba::Model {
public:
  shared_ptr<string> groupId{};
  shared_ptr<string> securityToken{};

  DescribeApiGroupVpcWhitelistRequest() {}

  explicit DescribeApiGroupVpcWhitelistRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~DescribeApiGroupVpcWhitelistRequest() = default;
};
class DescribeApiGroupVpcWhitelistResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> vpcIds{};

  DescribeApiGroupVpcWhitelistResponseBody() {}

  explicit DescribeApiGroupVpcWhitelistResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (vpcIds) {
      res["VpcIds"] = boost::any(*vpcIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("VpcIds") != m.end() && !m["VpcIds"].empty()) {
      vpcIds = make_shared<string>(boost::any_cast<string>(m["VpcIds"]));
    }
  }


  virtual ~DescribeApiGroupVpcWhitelistResponseBody() = default;
};
class DescribeApiGroupVpcWhitelistResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeApiGroupVpcWhitelistResponseBody> body{};

  DescribeApiGroupVpcWhitelistResponse() {}

  explicit DescribeApiGroupVpcWhitelistResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeApiGroupVpcWhitelistResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeApiGroupVpcWhitelistResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeApiGroupVpcWhitelistResponse() = default;
};
class DescribeApiGroupsRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  DescribeApiGroupsRequestTag() {}

  explicit DescribeApiGroupsRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeApiGroupsRequestTag() = default;
};
class DescribeApiGroupsRequest : public Darabonba::Model {
public:
  shared_ptr<bool> enableTagAuth{};
  shared_ptr<string> groupId{};
  shared_ptr<string> groupName{};
  shared_ptr<string> instanceId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> sort{};
  shared_ptr<vector<DescribeApiGroupsRequestTag>> tag{};

  DescribeApiGroupsRequest() {}

  explicit DescribeApiGroupsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (enableTagAuth) {
      res["EnableTagAuth"] = boost::any(*enableTagAuth);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (sort) {
      res["Sort"] = boost::any(*sort);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EnableTagAuth") != m.end() && !m["EnableTagAuth"].empty()) {
      enableTagAuth = make_shared<bool>(boost::any_cast<bool>(m["EnableTagAuth"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("Sort") != m.end() && !m["Sort"].empty()) {
      sort = make_shared<string>(boost::any_cast<string>(m["Sort"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<DescribeApiGroupsRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeApiGroupsRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<DescribeApiGroupsRequestTag>>(expect1);
      }
    }
  }


  virtual ~DescribeApiGroupsRequest() = default;
};
class DescribeApiGroupsResponseBodyApiGroupAttributesApiGroupAttributeTagsTagInfo : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  DescribeApiGroupsResponseBodyApiGroupAttributesApiGroupAttributeTagsTagInfo() {}

  explicit DescribeApiGroupsResponseBodyApiGroupAttributesApiGroupAttributeTagsTagInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeApiGroupsResponseBodyApiGroupAttributesApiGroupAttributeTagsTagInfo() = default;
};
class DescribeApiGroupsResponseBodyApiGroupAttributesApiGroupAttributeTags : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeApiGroupsResponseBodyApiGroupAttributesApiGroupAttributeTagsTagInfo>> tagInfo{};

  DescribeApiGroupsResponseBodyApiGroupAttributesApiGroupAttributeTags() {}

  explicit DescribeApiGroupsResponseBodyApiGroupAttributesApiGroupAttributeTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tagInfo) {
      vector<boost::any> temp1;
      for(auto item1:*tagInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TagInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TagInfo") != m.end() && !m["TagInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["TagInfo"].type()) {
        vector<DescribeApiGroupsResponseBodyApiGroupAttributesApiGroupAttributeTagsTagInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TagInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeApiGroupsResponseBodyApiGroupAttributesApiGroupAttributeTagsTagInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tagInfo = make_shared<vector<DescribeApiGroupsResponseBodyApiGroupAttributesApiGroupAttributeTagsTagInfo>>(expect1);
      }
    }
  }


  virtual ~DescribeApiGroupsResponseBodyApiGroupAttributesApiGroupAttributeTags() = default;
};
class DescribeApiGroupsResponseBodyApiGroupAttributesApiGroupAttribute : public Darabonba::Model {
public:
  shared_ptr<string> basePath{};
  shared_ptr<string> billingStatus{};
  shared_ptr<string> createdTime{};
  shared_ptr<string> description{};
  shared_ptr<string> groupId{};
  shared_ptr<string> groupName{};
  shared_ptr<string> httpsPolicy{};
  shared_ptr<string> illegalStatus{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> instanceType{};
  shared_ptr<string> modifiedTime{};
  shared_ptr<string> regionId{};
  shared_ptr<string> subDomain{};
  shared_ptr<DescribeApiGroupsResponseBodyApiGroupAttributesApiGroupAttributeTags> tags{};
  shared_ptr<long> trafficLimit{};

  DescribeApiGroupsResponseBodyApiGroupAttributesApiGroupAttribute() {}

  explicit DescribeApiGroupsResponseBodyApiGroupAttributesApiGroupAttribute(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (basePath) {
      res["BasePath"] = boost::any(*basePath);
    }
    if (billingStatus) {
      res["BillingStatus"] = boost::any(*billingStatus);
    }
    if (createdTime) {
      res["CreatedTime"] = boost::any(*createdTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (httpsPolicy) {
      res["HttpsPolicy"] = boost::any(*httpsPolicy);
    }
    if (illegalStatus) {
      res["IllegalStatus"] = boost::any(*illegalStatus);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (modifiedTime) {
      res["ModifiedTime"] = boost::any(*modifiedTime);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (subDomain) {
      res["SubDomain"] = boost::any(*subDomain);
    }
    if (tags) {
      res["Tags"] = tags ? boost::any(tags->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (trafficLimit) {
      res["TrafficLimit"] = boost::any(*trafficLimit);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BasePath") != m.end() && !m["BasePath"].empty()) {
      basePath = make_shared<string>(boost::any_cast<string>(m["BasePath"]));
    }
    if (m.find("BillingStatus") != m.end() && !m["BillingStatus"].empty()) {
      billingStatus = make_shared<string>(boost::any_cast<string>(m["BillingStatus"]));
    }
    if (m.find("CreatedTime") != m.end() && !m["CreatedTime"].empty()) {
      createdTime = make_shared<string>(boost::any_cast<string>(m["CreatedTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("HttpsPolicy") != m.end() && !m["HttpsPolicy"].empty()) {
      httpsPolicy = make_shared<string>(boost::any_cast<string>(m["HttpsPolicy"]));
    }
    if (m.find("IllegalStatus") != m.end() && !m["IllegalStatus"].empty()) {
      illegalStatus = make_shared<string>(boost::any_cast<string>(m["IllegalStatus"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("ModifiedTime") != m.end() && !m["ModifiedTime"].empty()) {
      modifiedTime = make_shared<string>(boost::any_cast<string>(m["ModifiedTime"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SubDomain") != m.end() && !m["SubDomain"].empty()) {
      subDomain = make_shared<string>(boost::any_cast<string>(m["SubDomain"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(map<string, boost::any>) == m["Tags"].type()) {
        DescribeApiGroupsResponseBodyApiGroupAttributesApiGroupAttributeTags model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Tags"]));
        tags = make_shared<DescribeApiGroupsResponseBodyApiGroupAttributesApiGroupAttributeTags>(model1);
      }
    }
    if (m.find("TrafficLimit") != m.end() && !m["TrafficLimit"].empty()) {
      trafficLimit = make_shared<long>(boost::any_cast<long>(m["TrafficLimit"]));
    }
  }


  virtual ~DescribeApiGroupsResponseBodyApiGroupAttributesApiGroupAttribute() = default;
};
class DescribeApiGroupsResponseBodyApiGroupAttributes : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeApiGroupsResponseBodyApiGroupAttributesApiGroupAttribute>> apiGroupAttribute{};

  DescribeApiGroupsResponseBodyApiGroupAttributes() {}

  explicit DescribeApiGroupsResponseBodyApiGroupAttributes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiGroupAttribute) {
      vector<boost::any> temp1;
      for(auto item1:*apiGroupAttribute){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ApiGroupAttribute"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiGroupAttribute") != m.end() && !m["ApiGroupAttribute"].empty()) {
      if (typeid(vector<boost::any>) == m["ApiGroupAttribute"].type()) {
        vector<DescribeApiGroupsResponseBodyApiGroupAttributesApiGroupAttribute> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ApiGroupAttribute"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeApiGroupsResponseBodyApiGroupAttributesApiGroupAttribute model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        apiGroupAttribute = make_shared<vector<DescribeApiGroupsResponseBodyApiGroupAttributesApiGroupAttribute>>(expect1);
      }
    }
  }


  virtual ~DescribeApiGroupsResponseBodyApiGroupAttributes() = default;
};
class DescribeApiGroupsResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeApiGroupsResponseBodyApiGroupAttributes> apiGroupAttributes{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeApiGroupsResponseBody() {}

  explicit DescribeApiGroupsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiGroupAttributes) {
      res["ApiGroupAttributes"] = apiGroupAttributes ? boost::any(apiGroupAttributes->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiGroupAttributes") != m.end() && !m["ApiGroupAttributes"].empty()) {
      if (typeid(map<string, boost::any>) == m["ApiGroupAttributes"].type()) {
        DescribeApiGroupsResponseBodyApiGroupAttributes model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ApiGroupAttributes"]));
        apiGroupAttributes = make_shared<DescribeApiGroupsResponseBodyApiGroupAttributes>(model1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeApiGroupsResponseBody() = default;
};
class DescribeApiGroupsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeApiGroupsResponseBody> body{};

  DescribeApiGroupsResponse() {}

  explicit DescribeApiGroupsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeApiGroupsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeApiGroupsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeApiGroupsResponse() = default;
};
class DescribeApiHistoriesRequest : public Darabonba::Model {
public:
  shared_ptr<string> apiId{};
  shared_ptr<string> apiName{};
  shared_ptr<string> groupId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> stageName{};

  DescribeApiHistoriesRequest() {}

  explicit DescribeApiHistoriesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiId) {
      res["ApiId"] = boost::any(*apiId);
    }
    if (apiName) {
      res["ApiName"] = boost::any(*apiName);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (stageName) {
      res["StageName"] = boost::any(*stageName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiId") != m.end() && !m["ApiId"].empty()) {
      apiId = make_shared<string>(boost::any_cast<string>(m["ApiId"]));
    }
    if (m.find("ApiName") != m.end() && !m["ApiName"].empty()) {
      apiName = make_shared<string>(boost::any_cast<string>(m["ApiName"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("StageName") != m.end() && !m["StageName"].empty()) {
      stageName = make_shared<string>(boost::any_cast<string>(m["StageName"]));
    }
  }


  virtual ~DescribeApiHistoriesRequest() = default;
};
class DescribeApiHistoriesResponseBodyApiHisItemsApiHisItem : public Darabonba::Model {
public:
  shared_ptr<string> apiId{};
  shared_ptr<string> apiName{};
  shared_ptr<string> deployedTime{};
  shared_ptr<string> description{};
  shared_ptr<string> groupId{};
  shared_ptr<string> groupName{};
  shared_ptr<string> historyVersion{};
  shared_ptr<string> regionId{};
  shared_ptr<string> stageName{};
  shared_ptr<string> status{};

  DescribeApiHistoriesResponseBodyApiHisItemsApiHisItem() {}

  explicit DescribeApiHistoriesResponseBodyApiHisItemsApiHisItem(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiId) {
      res["ApiId"] = boost::any(*apiId);
    }
    if (apiName) {
      res["ApiName"] = boost::any(*apiName);
    }
    if (deployedTime) {
      res["DeployedTime"] = boost::any(*deployedTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (historyVersion) {
      res["HistoryVersion"] = boost::any(*historyVersion);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (stageName) {
      res["StageName"] = boost::any(*stageName);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiId") != m.end() && !m["ApiId"].empty()) {
      apiId = make_shared<string>(boost::any_cast<string>(m["ApiId"]));
    }
    if (m.find("ApiName") != m.end() && !m["ApiName"].empty()) {
      apiName = make_shared<string>(boost::any_cast<string>(m["ApiName"]));
    }
    if (m.find("DeployedTime") != m.end() && !m["DeployedTime"].empty()) {
      deployedTime = make_shared<string>(boost::any_cast<string>(m["DeployedTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("HistoryVersion") != m.end() && !m["HistoryVersion"].empty()) {
      historyVersion = make_shared<string>(boost::any_cast<string>(m["HistoryVersion"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("StageName") != m.end() && !m["StageName"].empty()) {
      stageName = make_shared<string>(boost::any_cast<string>(m["StageName"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeApiHistoriesResponseBodyApiHisItemsApiHisItem() = default;
};
class DescribeApiHistoriesResponseBodyApiHisItems : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeApiHistoriesResponseBodyApiHisItemsApiHisItem>> apiHisItem{};

  DescribeApiHistoriesResponseBodyApiHisItems() {}

  explicit DescribeApiHistoriesResponseBodyApiHisItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiHisItem) {
      vector<boost::any> temp1;
      for(auto item1:*apiHisItem){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ApiHisItem"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiHisItem") != m.end() && !m["ApiHisItem"].empty()) {
      if (typeid(vector<boost::any>) == m["ApiHisItem"].type()) {
        vector<DescribeApiHistoriesResponseBodyApiHisItemsApiHisItem> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ApiHisItem"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeApiHistoriesResponseBodyApiHisItemsApiHisItem model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        apiHisItem = make_shared<vector<DescribeApiHistoriesResponseBodyApiHisItemsApiHisItem>>(expect1);
      }
    }
  }


  virtual ~DescribeApiHistoriesResponseBodyApiHisItems() = default;
};
class DescribeApiHistoriesResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeApiHistoriesResponseBodyApiHisItems> apiHisItems{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeApiHistoriesResponseBody() {}

  explicit DescribeApiHistoriesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiHisItems) {
      res["ApiHisItems"] = apiHisItems ? boost::any(apiHisItems->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiHisItems") != m.end() && !m["ApiHisItems"].empty()) {
      if (typeid(map<string, boost::any>) == m["ApiHisItems"].type()) {
        DescribeApiHistoriesResponseBodyApiHisItems model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ApiHisItems"]));
        apiHisItems = make_shared<DescribeApiHistoriesResponseBodyApiHisItems>(model1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeApiHistoriesResponseBody() = default;
};
class DescribeApiHistoriesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeApiHistoriesResponseBody> body{};

  DescribeApiHistoriesResponse() {}

  explicit DescribeApiHistoriesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeApiHistoriesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeApiHistoriesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeApiHistoriesResponse() = default;
};
class DescribeApiHistoryRequest : public Darabonba::Model {
public:
  shared_ptr<string> apiId{};
  shared_ptr<string> groupId{};
  shared_ptr<string> historyVersion{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> stageName{};

  DescribeApiHistoryRequest() {}

  explicit DescribeApiHistoryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiId) {
      res["ApiId"] = boost::any(*apiId);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (historyVersion) {
      res["HistoryVersion"] = boost::any(*historyVersion);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (stageName) {
      res["StageName"] = boost::any(*stageName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiId") != m.end() && !m["ApiId"].empty()) {
      apiId = make_shared<string>(boost::any_cast<string>(m["ApiId"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("HistoryVersion") != m.end() && !m["HistoryVersion"].empty()) {
      historyVersion = make_shared<string>(boost::any_cast<string>(m["HistoryVersion"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("StageName") != m.end() && !m["StageName"].empty()) {
      stageName = make_shared<string>(boost::any_cast<string>(m["StageName"]));
    }
  }


  virtual ~DescribeApiHistoryRequest() = default;
};
class DescribeApiHistoryResponseBodyBackendConfig : public Darabonba::Model {
public:
  shared_ptr<string> backendId{};
  shared_ptr<string> backendName{};
  shared_ptr<string> backendType{};

  DescribeApiHistoryResponseBodyBackendConfig() {}

  explicit DescribeApiHistoryResponseBodyBackendConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (backendId) {
      res["BackendId"] = boost::any(*backendId);
    }
    if (backendName) {
      res["BackendName"] = boost::any(*backendName);
    }
    if (backendType) {
      res["BackendType"] = boost::any(*backendType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BackendId") != m.end() && !m["BackendId"].empty()) {
      backendId = make_shared<string>(boost::any_cast<string>(m["BackendId"]));
    }
    if (m.find("BackendName") != m.end() && !m["BackendName"].empty()) {
      backendName = make_shared<string>(boost::any_cast<string>(m["BackendName"]));
    }
    if (m.find("BackendType") != m.end() && !m["BackendType"].empty()) {
      backendType = make_shared<string>(boost::any_cast<string>(m["BackendType"]));
    }
  }


  virtual ~DescribeApiHistoryResponseBodyBackendConfig() = default;
};
class DescribeApiHistoryResponseBodyConstantParametersConstantParameter : public Darabonba::Model {
public:
  shared_ptr<string> constantValue{};
  shared_ptr<string> description{};
  shared_ptr<string> location{};
  shared_ptr<string> serviceParameterName{};

  DescribeApiHistoryResponseBodyConstantParametersConstantParameter() {}

  explicit DescribeApiHistoryResponseBodyConstantParametersConstantParameter(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (constantValue) {
      res["ConstantValue"] = boost::any(*constantValue);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (serviceParameterName) {
      res["ServiceParameterName"] = boost::any(*serviceParameterName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConstantValue") != m.end() && !m["ConstantValue"].empty()) {
      constantValue = make_shared<string>(boost::any_cast<string>(m["ConstantValue"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("ServiceParameterName") != m.end() && !m["ServiceParameterName"].empty()) {
      serviceParameterName = make_shared<string>(boost::any_cast<string>(m["ServiceParameterName"]));
    }
  }


  virtual ~DescribeApiHistoryResponseBodyConstantParametersConstantParameter() = default;
};
class DescribeApiHistoryResponseBodyConstantParameters : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeApiHistoryResponseBodyConstantParametersConstantParameter>> constantParameter{};

  DescribeApiHistoryResponseBodyConstantParameters() {}

  explicit DescribeApiHistoryResponseBodyConstantParameters(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (constantParameter) {
      vector<boost::any> temp1;
      for(auto item1:*constantParameter){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ConstantParameter"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConstantParameter") != m.end() && !m["ConstantParameter"].empty()) {
      if (typeid(vector<boost::any>) == m["ConstantParameter"].type()) {
        vector<DescribeApiHistoryResponseBodyConstantParametersConstantParameter> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ConstantParameter"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeApiHistoryResponseBodyConstantParametersConstantParameter model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        constantParameter = make_shared<vector<DescribeApiHistoryResponseBodyConstantParametersConstantParameter>>(expect1);
      }
    }
  }


  virtual ~DescribeApiHistoryResponseBodyConstantParameters() = default;
};
class DescribeApiHistoryResponseBodyCustomSystemParametersCustomSystemParameter : public Darabonba::Model {
public:
  shared_ptr<string> demoValue{};
  shared_ptr<string> description{};
  shared_ptr<string> location{};
  shared_ptr<string> parameterName{};
  shared_ptr<string> serviceParameterName{};

  DescribeApiHistoryResponseBodyCustomSystemParametersCustomSystemParameter() {}

  explicit DescribeApiHistoryResponseBodyCustomSystemParametersCustomSystemParameter(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (demoValue) {
      res["DemoValue"] = boost::any(*demoValue);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (parameterName) {
      res["ParameterName"] = boost::any(*parameterName);
    }
    if (serviceParameterName) {
      res["ServiceParameterName"] = boost::any(*serviceParameterName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DemoValue") != m.end() && !m["DemoValue"].empty()) {
      demoValue = make_shared<string>(boost::any_cast<string>(m["DemoValue"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("ParameterName") != m.end() && !m["ParameterName"].empty()) {
      parameterName = make_shared<string>(boost::any_cast<string>(m["ParameterName"]));
    }
    if (m.find("ServiceParameterName") != m.end() && !m["ServiceParameterName"].empty()) {
      serviceParameterName = make_shared<string>(boost::any_cast<string>(m["ServiceParameterName"]));
    }
  }


  virtual ~DescribeApiHistoryResponseBodyCustomSystemParametersCustomSystemParameter() = default;
};
class DescribeApiHistoryResponseBodyCustomSystemParameters : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeApiHistoryResponseBodyCustomSystemParametersCustomSystemParameter>> customSystemParameter{};

  DescribeApiHistoryResponseBodyCustomSystemParameters() {}

  explicit DescribeApiHistoryResponseBodyCustomSystemParameters(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (customSystemParameter) {
      vector<boost::any> temp1;
      for(auto item1:*customSystemParameter){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CustomSystemParameter"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CustomSystemParameter") != m.end() && !m["CustomSystemParameter"].empty()) {
      if (typeid(vector<boost::any>) == m["CustomSystemParameter"].type()) {
        vector<DescribeApiHistoryResponseBodyCustomSystemParametersCustomSystemParameter> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CustomSystemParameter"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeApiHistoryResponseBodyCustomSystemParametersCustomSystemParameter model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        customSystemParameter = make_shared<vector<DescribeApiHistoryResponseBodyCustomSystemParametersCustomSystemParameter>>(expect1);
      }
    }
  }


  virtual ~DescribeApiHistoryResponseBodyCustomSystemParameters() = default;
};
class DescribeApiHistoryResponseBodyErrorCodeSamplesErrorCodeSample : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> description{};
  shared_ptr<string> message{};

  DescribeApiHistoryResponseBodyErrorCodeSamplesErrorCodeSample() {}

  explicit DescribeApiHistoryResponseBodyErrorCodeSamplesErrorCodeSample(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
  }


  virtual ~DescribeApiHistoryResponseBodyErrorCodeSamplesErrorCodeSample() = default;
};
class DescribeApiHistoryResponseBodyErrorCodeSamples : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeApiHistoryResponseBodyErrorCodeSamplesErrorCodeSample>> errorCodeSample{};

  DescribeApiHistoryResponseBodyErrorCodeSamples() {}

  explicit DescribeApiHistoryResponseBodyErrorCodeSamples(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCodeSample) {
      vector<boost::any> temp1;
      for(auto item1:*errorCodeSample){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ErrorCodeSample"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCodeSample") != m.end() && !m["ErrorCodeSample"].empty()) {
      if (typeid(vector<boost::any>) == m["ErrorCodeSample"].type()) {
        vector<DescribeApiHistoryResponseBodyErrorCodeSamplesErrorCodeSample> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ErrorCodeSample"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeApiHistoryResponseBodyErrorCodeSamplesErrorCodeSample model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        errorCodeSample = make_shared<vector<DescribeApiHistoryResponseBodyErrorCodeSamplesErrorCodeSample>>(expect1);
      }
    }
  }


  virtual ~DescribeApiHistoryResponseBodyErrorCodeSamples() = default;
};
class DescribeApiHistoryResponseBodyOpenIdConnectConfig : public Darabonba::Model {
public:
  shared_ptr<string> idTokenParamName{};
  shared_ptr<string> openIdApiType{};
  shared_ptr<string> publicKey{};
  shared_ptr<string> publicKeyId{};

  DescribeApiHistoryResponseBodyOpenIdConnectConfig() {}

  explicit DescribeApiHistoryResponseBodyOpenIdConnectConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (idTokenParamName) {
      res["IdTokenParamName"] = boost::any(*idTokenParamName);
    }
    if (openIdApiType) {
      res["OpenIdApiType"] = boost::any(*openIdApiType);
    }
    if (publicKey) {
      res["PublicKey"] = boost::any(*publicKey);
    }
    if (publicKeyId) {
      res["PublicKeyId"] = boost::any(*publicKeyId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IdTokenParamName") != m.end() && !m["IdTokenParamName"].empty()) {
      idTokenParamName = make_shared<string>(boost::any_cast<string>(m["IdTokenParamName"]));
    }
    if (m.find("OpenIdApiType") != m.end() && !m["OpenIdApiType"].empty()) {
      openIdApiType = make_shared<string>(boost::any_cast<string>(m["OpenIdApiType"]));
    }
    if (m.find("PublicKey") != m.end() && !m["PublicKey"].empty()) {
      publicKey = make_shared<string>(boost::any_cast<string>(m["PublicKey"]));
    }
    if (m.find("PublicKeyId") != m.end() && !m["PublicKeyId"].empty()) {
      publicKeyId = make_shared<string>(boost::any_cast<string>(m["PublicKeyId"]));
    }
  }


  virtual ~DescribeApiHistoryResponseBodyOpenIdConnectConfig() = default;
};
class DescribeApiHistoryResponseBodyRequestConfig : public Darabonba::Model {
public:
  shared_ptr<string> bodyFormat{};
  shared_ptr<string> bodyModel{};
  shared_ptr<string> postBodyDescription{};
  shared_ptr<string> requestHttpMethod{};
  shared_ptr<string> requestMode{};
  shared_ptr<string> requestPath{};
  shared_ptr<string> requestProtocol{};

  DescribeApiHistoryResponseBodyRequestConfig() {}

  explicit DescribeApiHistoryResponseBodyRequestConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bodyFormat) {
      res["BodyFormat"] = boost::any(*bodyFormat);
    }
    if (bodyModel) {
      res["BodyModel"] = boost::any(*bodyModel);
    }
    if (postBodyDescription) {
      res["PostBodyDescription"] = boost::any(*postBodyDescription);
    }
    if (requestHttpMethod) {
      res["RequestHttpMethod"] = boost::any(*requestHttpMethod);
    }
    if (requestMode) {
      res["RequestMode"] = boost::any(*requestMode);
    }
    if (requestPath) {
      res["RequestPath"] = boost::any(*requestPath);
    }
    if (requestProtocol) {
      res["RequestProtocol"] = boost::any(*requestProtocol);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BodyFormat") != m.end() && !m["BodyFormat"].empty()) {
      bodyFormat = make_shared<string>(boost::any_cast<string>(m["BodyFormat"]));
    }
    if (m.find("BodyModel") != m.end() && !m["BodyModel"].empty()) {
      bodyModel = make_shared<string>(boost::any_cast<string>(m["BodyModel"]));
    }
    if (m.find("PostBodyDescription") != m.end() && !m["PostBodyDescription"].empty()) {
      postBodyDescription = make_shared<string>(boost::any_cast<string>(m["PostBodyDescription"]));
    }
    if (m.find("RequestHttpMethod") != m.end() && !m["RequestHttpMethod"].empty()) {
      requestHttpMethod = make_shared<string>(boost::any_cast<string>(m["RequestHttpMethod"]));
    }
    if (m.find("RequestMode") != m.end() && !m["RequestMode"].empty()) {
      requestMode = make_shared<string>(boost::any_cast<string>(m["RequestMode"]));
    }
    if (m.find("RequestPath") != m.end() && !m["RequestPath"].empty()) {
      requestPath = make_shared<string>(boost::any_cast<string>(m["RequestPath"]));
    }
    if (m.find("RequestProtocol") != m.end() && !m["RequestProtocol"].empty()) {
      requestProtocol = make_shared<string>(boost::any_cast<string>(m["RequestProtocol"]));
    }
  }


  virtual ~DescribeApiHistoryResponseBodyRequestConfig() = default;
};
class DescribeApiHistoryResponseBodyRequestParametersRequestParameter : public Darabonba::Model {
public:
  shared_ptr<string> apiParameterName{};
  shared_ptr<string> arrayItemsType{};
  shared_ptr<string> defaultValue{};
  shared_ptr<string> demoValue{};
  shared_ptr<string> description{};
  shared_ptr<long> docOrder{};
  shared_ptr<string> docShow{};
  shared_ptr<string> enumValue{};
  shared_ptr<string> jsonScheme{};
  shared_ptr<string> location{};
  shared_ptr<long> maxLength{};
  shared_ptr<long> maxValue{};
  shared_ptr<long> minLength{};
  shared_ptr<long> minValue{};
  shared_ptr<string> parameterType{};
  shared_ptr<string> regularExpression{};
  shared_ptr<string> required{};

  DescribeApiHistoryResponseBodyRequestParametersRequestParameter() {}

  explicit DescribeApiHistoryResponseBodyRequestParametersRequestParameter(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiParameterName) {
      res["ApiParameterName"] = boost::any(*apiParameterName);
    }
    if (arrayItemsType) {
      res["ArrayItemsType"] = boost::any(*arrayItemsType);
    }
    if (defaultValue) {
      res["DefaultValue"] = boost::any(*defaultValue);
    }
    if (demoValue) {
      res["DemoValue"] = boost::any(*demoValue);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (docOrder) {
      res["DocOrder"] = boost::any(*docOrder);
    }
    if (docShow) {
      res["DocShow"] = boost::any(*docShow);
    }
    if (enumValue) {
      res["EnumValue"] = boost::any(*enumValue);
    }
    if (jsonScheme) {
      res["JsonScheme"] = boost::any(*jsonScheme);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (maxLength) {
      res["MaxLength"] = boost::any(*maxLength);
    }
    if (maxValue) {
      res["MaxValue"] = boost::any(*maxValue);
    }
    if (minLength) {
      res["MinLength"] = boost::any(*minLength);
    }
    if (minValue) {
      res["MinValue"] = boost::any(*minValue);
    }
    if (parameterType) {
      res["ParameterType"] = boost::any(*parameterType);
    }
    if (regularExpression) {
      res["RegularExpression"] = boost::any(*regularExpression);
    }
    if (required) {
      res["Required"] = boost::any(*required);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiParameterName") != m.end() && !m["ApiParameterName"].empty()) {
      apiParameterName = make_shared<string>(boost::any_cast<string>(m["ApiParameterName"]));
    }
    if (m.find("ArrayItemsType") != m.end() && !m["ArrayItemsType"].empty()) {
      arrayItemsType = make_shared<string>(boost::any_cast<string>(m["ArrayItemsType"]));
    }
    if (m.find("DefaultValue") != m.end() && !m["DefaultValue"].empty()) {
      defaultValue = make_shared<string>(boost::any_cast<string>(m["DefaultValue"]));
    }
    if (m.find("DemoValue") != m.end() && !m["DemoValue"].empty()) {
      demoValue = make_shared<string>(boost::any_cast<string>(m["DemoValue"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DocOrder") != m.end() && !m["DocOrder"].empty()) {
      docOrder = make_shared<long>(boost::any_cast<long>(m["DocOrder"]));
    }
    if (m.find("DocShow") != m.end() && !m["DocShow"].empty()) {
      docShow = make_shared<string>(boost::any_cast<string>(m["DocShow"]));
    }
    if (m.find("EnumValue") != m.end() && !m["EnumValue"].empty()) {
      enumValue = make_shared<string>(boost::any_cast<string>(m["EnumValue"]));
    }
    if (m.find("JsonScheme") != m.end() && !m["JsonScheme"].empty()) {
      jsonScheme = make_shared<string>(boost::any_cast<string>(m["JsonScheme"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("MaxLength") != m.end() && !m["MaxLength"].empty()) {
      maxLength = make_shared<long>(boost::any_cast<long>(m["MaxLength"]));
    }
    if (m.find("MaxValue") != m.end() && !m["MaxValue"].empty()) {
      maxValue = make_shared<long>(boost::any_cast<long>(m["MaxValue"]));
    }
    if (m.find("MinLength") != m.end() && !m["MinLength"].empty()) {
      minLength = make_shared<long>(boost::any_cast<long>(m["MinLength"]));
    }
    if (m.find("MinValue") != m.end() && !m["MinValue"].empty()) {
      minValue = make_shared<long>(boost::any_cast<long>(m["MinValue"]));
    }
    if (m.find("ParameterType") != m.end() && !m["ParameterType"].empty()) {
      parameterType = make_shared<string>(boost::any_cast<string>(m["ParameterType"]));
    }
    if (m.find("RegularExpression") != m.end() && !m["RegularExpression"].empty()) {
      regularExpression = make_shared<string>(boost::any_cast<string>(m["RegularExpression"]));
    }
    if (m.find("Required") != m.end() && !m["Required"].empty()) {
      required = make_shared<string>(boost::any_cast<string>(m["Required"]));
    }
  }


  virtual ~DescribeApiHistoryResponseBodyRequestParametersRequestParameter() = default;
};
class DescribeApiHistoryResponseBodyRequestParameters : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeApiHistoryResponseBodyRequestParametersRequestParameter>> requestParameter{};

  DescribeApiHistoryResponseBodyRequestParameters() {}

  explicit DescribeApiHistoryResponseBodyRequestParameters(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestParameter) {
      vector<boost::any> temp1;
      for(auto item1:*requestParameter){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RequestParameter"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestParameter") != m.end() && !m["RequestParameter"].empty()) {
      if (typeid(vector<boost::any>) == m["RequestParameter"].type()) {
        vector<DescribeApiHistoryResponseBodyRequestParametersRequestParameter> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RequestParameter"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeApiHistoryResponseBodyRequestParametersRequestParameter model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        requestParameter = make_shared<vector<DescribeApiHistoryResponseBodyRequestParametersRequestParameter>>(expect1);
      }
    }
  }


  virtual ~DescribeApiHistoryResponseBodyRequestParameters() = default;
};
class DescribeApiHistoryResponseBodyResultDescriptionsResultDescription : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<bool> hasChild{};
  shared_ptr<string> id{};
  shared_ptr<string> key{};
  shared_ptr<bool> mandatory{};
  shared_ptr<string> name{};
  shared_ptr<string> pid{};
  shared_ptr<string> type{};

  DescribeApiHistoryResponseBodyResultDescriptionsResultDescription() {}

  explicit DescribeApiHistoryResponseBodyResultDescriptionsResultDescription(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (hasChild) {
      res["HasChild"] = boost::any(*hasChild);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (mandatory) {
      res["Mandatory"] = boost::any(*mandatory);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (pid) {
      res["Pid"] = boost::any(*pid);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("HasChild") != m.end() && !m["HasChild"].empty()) {
      hasChild = make_shared<bool>(boost::any_cast<bool>(m["HasChild"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Mandatory") != m.end() && !m["Mandatory"].empty()) {
      mandatory = make_shared<bool>(boost::any_cast<bool>(m["Mandatory"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Pid") != m.end() && !m["Pid"].empty()) {
      pid = make_shared<string>(boost::any_cast<string>(m["Pid"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DescribeApiHistoryResponseBodyResultDescriptionsResultDescription() = default;
};
class DescribeApiHistoryResponseBodyResultDescriptions : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeApiHistoryResponseBodyResultDescriptionsResultDescription>> resultDescription{};

  DescribeApiHistoryResponseBodyResultDescriptions() {}

  explicit DescribeApiHistoryResponseBodyResultDescriptions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resultDescription) {
      vector<boost::any> temp1;
      for(auto item1:*resultDescription){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ResultDescription"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResultDescription") != m.end() && !m["ResultDescription"].empty()) {
      if (typeid(vector<boost::any>) == m["ResultDescription"].type()) {
        vector<DescribeApiHistoryResponseBodyResultDescriptionsResultDescription> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ResultDescription"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeApiHistoryResponseBodyResultDescriptionsResultDescription model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        resultDescription = make_shared<vector<DescribeApiHistoryResponseBodyResultDescriptionsResultDescription>>(expect1);
      }
    }
  }


  virtual ~DescribeApiHistoryResponseBodyResultDescriptions() = default;
};
class DescribeApiHistoryResponseBodyServiceConfigEventBridgeConfig : public Darabonba::Model {
public:
  shared_ptr<string> eventBridgeRegionId{};
  shared_ptr<string> eventBus{};
  shared_ptr<string> eventSource{};
  shared_ptr<string> roleArn{};

  DescribeApiHistoryResponseBodyServiceConfigEventBridgeConfig() {}

  explicit DescribeApiHistoryResponseBodyServiceConfigEventBridgeConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (eventBridgeRegionId) {
      res["EventBridgeRegionId"] = boost::any(*eventBridgeRegionId);
    }
    if (eventBus) {
      res["EventBus"] = boost::any(*eventBus);
    }
    if (eventSource) {
      res["EventSource"] = boost::any(*eventSource);
    }
    if (roleArn) {
      res["RoleArn"] = boost::any(*roleArn);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EventBridgeRegionId") != m.end() && !m["EventBridgeRegionId"].empty()) {
      eventBridgeRegionId = make_shared<string>(boost::any_cast<string>(m["EventBridgeRegionId"]));
    }
    if (m.find("EventBus") != m.end() && !m["EventBus"].empty()) {
      eventBus = make_shared<string>(boost::any_cast<string>(m["EventBus"]));
    }
    if (m.find("EventSource") != m.end() && !m["EventSource"].empty()) {
      eventSource = make_shared<string>(boost::any_cast<string>(m["EventSource"]));
    }
    if (m.find("RoleArn") != m.end() && !m["RoleArn"].empty()) {
      roleArn = make_shared<string>(boost::any_cast<string>(m["RoleArn"]));
    }
  }


  virtual ~DescribeApiHistoryResponseBodyServiceConfigEventBridgeConfig() = default;
};
class DescribeApiHistoryResponseBodyServiceConfigFunctionComputeConfig : public Darabonba::Model {
public:
  shared_ptr<string> contentTypeCatagory{};
  shared_ptr<string> contentTypeValue{};
  shared_ptr<string> fcBaseUrl{};
  shared_ptr<string> fcType{};
  shared_ptr<string> functionName{};
  shared_ptr<string> method{};
  shared_ptr<bool> onlyBusinessPath{};
  shared_ptr<string> path{};
  shared_ptr<string> qualifier{};
  shared_ptr<string> regionId{};
  shared_ptr<string> roleArn{};
  shared_ptr<string> serviceName{};

  DescribeApiHistoryResponseBodyServiceConfigFunctionComputeConfig() {}

  explicit DescribeApiHistoryResponseBodyServiceConfigFunctionComputeConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contentTypeCatagory) {
      res["ContentTypeCatagory"] = boost::any(*contentTypeCatagory);
    }
    if (contentTypeValue) {
      res["ContentTypeValue"] = boost::any(*contentTypeValue);
    }
    if (fcBaseUrl) {
      res["FcBaseUrl"] = boost::any(*fcBaseUrl);
    }
    if (fcType) {
      res["FcType"] = boost::any(*fcType);
    }
    if (functionName) {
      res["FunctionName"] = boost::any(*functionName);
    }
    if (method) {
      res["Method"] = boost::any(*method);
    }
    if (onlyBusinessPath) {
      res["OnlyBusinessPath"] = boost::any(*onlyBusinessPath);
    }
    if (path) {
      res["Path"] = boost::any(*path);
    }
    if (qualifier) {
      res["Qualifier"] = boost::any(*qualifier);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (roleArn) {
      res["RoleArn"] = boost::any(*roleArn);
    }
    if (serviceName) {
      res["ServiceName"] = boost::any(*serviceName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ContentTypeCatagory") != m.end() && !m["ContentTypeCatagory"].empty()) {
      contentTypeCatagory = make_shared<string>(boost::any_cast<string>(m["ContentTypeCatagory"]));
    }
    if (m.find("ContentTypeValue") != m.end() && !m["ContentTypeValue"].empty()) {
      contentTypeValue = make_shared<string>(boost::any_cast<string>(m["ContentTypeValue"]));
    }
    if (m.find("FcBaseUrl") != m.end() && !m["FcBaseUrl"].empty()) {
      fcBaseUrl = make_shared<string>(boost::any_cast<string>(m["FcBaseUrl"]));
    }
    if (m.find("FcType") != m.end() && !m["FcType"].empty()) {
      fcType = make_shared<string>(boost::any_cast<string>(m["FcType"]));
    }
    if (m.find("FunctionName") != m.end() && !m["FunctionName"].empty()) {
      functionName = make_shared<string>(boost::any_cast<string>(m["FunctionName"]));
    }
    if (m.find("Method") != m.end() && !m["Method"].empty()) {
      method = make_shared<string>(boost::any_cast<string>(m["Method"]));
    }
    if (m.find("OnlyBusinessPath") != m.end() && !m["OnlyBusinessPath"].empty()) {
      onlyBusinessPath = make_shared<bool>(boost::any_cast<bool>(m["OnlyBusinessPath"]));
    }
    if (m.find("Path") != m.end() && !m["Path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["Path"]));
    }
    if (m.find("Qualifier") != m.end() && !m["Qualifier"].empty()) {
      qualifier = make_shared<string>(boost::any_cast<string>(m["Qualifier"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("RoleArn") != m.end() && !m["RoleArn"].empty()) {
      roleArn = make_shared<string>(boost::any_cast<string>(m["RoleArn"]));
    }
    if (m.find("ServiceName") != m.end() && !m["ServiceName"].empty()) {
      serviceName = make_shared<string>(boost::any_cast<string>(m["ServiceName"]));
    }
  }


  virtual ~DescribeApiHistoryResponseBodyServiceConfigFunctionComputeConfig() = default;
};
class DescribeApiHistoryResponseBodyServiceConfigMockHeadersMockHeader : public Darabonba::Model {
public:
  shared_ptr<string> headerName{};
  shared_ptr<string> headerValue{};

  DescribeApiHistoryResponseBodyServiceConfigMockHeadersMockHeader() {}

  explicit DescribeApiHistoryResponseBodyServiceConfigMockHeadersMockHeader(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headerName) {
      res["HeaderName"] = boost::any(*headerName);
    }
    if (headerValue) {
      res["HeaderValue"] = boost::any(*headerValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HeaderName") != m.end() && !m["HeaderName"].empty()) {
      headerName = make_shared<string>(boost::any_cast<string>(m["HeaderName"]));
    }
    if (m.find("HeaderValue") != m.end() && !m["HeaderValue"].empty()) {
      headerValue = make_shared<string>(boost::any_cast<string>(m["HeaderValue"]));
    }
  }


  virtual ~DescribeApiHistoryResponseBodyServiceConfigMockHeadersMockHeader() = default;
};
class DescribeApiHistoryResponseBodyServiceConfigMockHeaders : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeApiHistoryResponseBodyServiceConfigMockHeadersMockHeader>> mockHeader{};

  DescribeApiHistoryResponseBodyServiceConfigMockHeaders() {}

  explicit DescribeApiHistoryResponseBodyServiceConfigMockHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mockHeader) {
      vector<boost::any> temp1;
      for(auto item1:*mockHeader){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["MockHeader"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MockHeader") != m.end() && !m["MockHeader"].empty()) {
      if (typeid(vector<boost::any>) == m["MockHeader"].type()) {
        vector<DescribeApiHistoryResponseBodyServiceConfigMockHeadersMockHeader> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["MockHeader"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeApiHistoryResponseBodyServiceConfigMockHeadersMockHeader model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        mockHeader = make_shared<vector<DescribeApiHistoryResponseBodyServiceConfigMockHeadersMockHeader>>(expect1);
      }
    }
  }


  virtual ~DescribeApiHistoryResponseBodyServiceConfigMockHeaders() = default;
};
class DescribeApiHistoryResponseBodyServiceConfigOssConfig : public Darabonba::Model {
public:
  shared_ptr<string> action{};
  shared_ptr<string> bucketName{};
  shared_ptr<string> key{};
  shared_ptr<string> ossRegionId{};

  DescribeApiHistoryResponseBodyServiceConfigOssConfig() {}

  explicit DescribeApiHistoryResponseBodyServiceConfigOssConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (action) {
      res["Action"] = boost::any(*action);
    }
    if (bucketName) {
      res["BucketName"] = boost::any(*bucketName);
    }
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (ossRegionId) {
      res["OssRegionId"] = boost::any(*ossRegionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Action") != m.end() && !m["Action"].empty()) {
      action = make_shared<string>(boost::any_cast<string>(m["Action"]));
    }
    if (m.find("BucketName") != m.end() && !m["BucketName"].empty()) {
      bucketName = make_shared<string>(boost::any_cast<string>(m["BucketName"]));
    }
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("OssRegionId") != m.end() && !m["OssRegionId"].empty()) {
      ossRegionId = make_shared<string>(boost::any_cast<string>(m["OssRegionId"]));
    }
  }


  virtual ~DescribeApiHistoryResponseBodyServiceConfigOssConfig() = default;
};
class DescribeApiHistoryResponseBodyServiceConfigVpcConfig : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> name{};
  shared_ptr<long> port{};
  shared_ptr<string> vpcId{};
  shared_ptr<string> vpcScheme{};

  DescribeApiHistoryResponseBodyServiceConfigVpcConfig() {}

  explicit DescribeApiHistoryResponseBodyServiceConfigVpcConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    if (vpcScheme) {
      res["VpcScheme"] = boost::any(*vpcScheme);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<long>(boost::any_cast<long>(m["Port"]));
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
    if (m.find("VpcScheme") != m.end() && !m["VpcScheme"].empty()) {
      vpcScheme = make_shared<string>(boost::any_cast<string>(m["VpcScheme"]));
    }
  }


  virtual ~DescribeApiHistoryResponseBodyServiceConfigVpcConfig() = default;
};
class DescribeApiHistoryResponseBodyServiceConfig : public Darabonba::Model {
public:
  shared_ptr<string> contentTypeCatagory{};
  shared_ptr<string> contentTypeValue{};
  shared_ptr<DescribeApiHistoryResponseBodyServiceConfigEventBridgeConfig> eventBridgeConfig{};
  shared_ptr<DescribeApiHistoryResponseBodyServiceConfigFunctionComputeConfig> functionComputeConfig{};
  shared_ptr<string> mock{};
  shared_ptr<DescribeApiHistoryResponseBodyServiceConfigMockHeaders> mockHeaders{};
  shared_ptr<string> mockResult{};
  shared_ptr<long> mockStatusCode{};
  shared_ptr<DescribeApiHistoryResponseBodyServiceConfigOssConfig> ossConfig{};
  shared_ptr<string> serviceAddress{};
  shared_ptr<string> serviceHttpMethod{};
  shared_ptr<string> servicePath{};
  shared_ptr<string> serviceProtocol{};
  shared_ptr<long> serviceTimeout{};
  shared_ptr<string> serviceVpcEnable{};
  shared_ptr<DescribeApiHistoryResponseBodyServiceConfigVpcConfig> vpcConfig{};
  shared_ptr<string> vpcId{};

  DescribeApiHistoryResponseBodyServiceConfig() {}

  explicit DescribeApiHistoryResponseBodyServiceConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contentTypeCatagory) {
      res["ContentTypeCatagory"] = boost::any(*contentTypeCatagory);
    }
    if (contentTypeValue) {
      res["ContentTypeValue"] = boost::any(*contentTypeValue);
    }
    if (eventBridgeConfig) {
      res["EventBridgeConfig"] = eventBridgeConfig ? boost::any(eventBridgeConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (functionComputeConfig) {
      res["FunctionComputeConfig"] = functionComputeConfig ? boost::any(functionComputeConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (mock) {
      res["Mock"] = boost::any(*mock);
    }
    if (mockHeaders) {
      res["MockHeaders"] = mockHeaders ? boost::any(mockHeaders->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (mockResult) {
      res["MockResult"] = boost::any(*mockResult);
    }
    if (mockStatusCode) {
      res["MockStatusCode"] = boost::any(*mockStatusCode);
    }
    if (ossConfig) {
      res["OssConfig"] = ossConfig ? boost::any(ossConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (serviceAddress) {
      res["ServiceAddress"] = boost::any(*serviceAddress);
    }
    if (serviceHttpMethod) {
      res["ServiceHttpMethod"] = boost::any(*serviceHttpMethod);
    }
    if (servicePath) {
      res["ServicePath"] = boost::any(*servicePath);
    }
    if (serviceProtocol) {
      res["ServiceProtocol"] = boost::any(*serviceProtocol);
    }
    if (serviceTimeout) {
      res["ServiceTimeout"] = boost::any(*serviceTimeout);
    }
    if (serviceVpcEnable) {
      res["ServiceVpcEnable"] = boost::any(*serviceVpcEnable);
    }
    if (vpcConfig) {
      res["VpcConfig"] = vpcConfig ? boost::any(vpcConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ContentTypeCatagory") != m.end() && !m["ContentTypeCatagory"].empty()) {
      contentTypeCatagory = make_shared<string>(boost::any_cast<string>(m["ContentTypeCatagory"]));
    }
    if (m.find("ContentTypeValue") != m.end() && !m["ContentTypeValue"].empty()) {
      contentTypeValue = make_shared<string>(boost::any_cast<string>(m["ContentTypeValue"]));
    }
    if (m.find("EventBridgeConfig") != m.end() && !m["EventBridgeConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["EventBridgeConfig"].type()) {
        DescribeApiHistoryResponseBodyServiceConfigEventBridgeConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["EventBridgeConfig"]));
        eventBridgeConfig = make_shared<DescribeApiHistoryResponseBodyServiceConfigEventBridgeConfig>(model1);
      }
    }
    if (m.find("FunctionComputeConfig") != m.end() && !m["FunctionComputeConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["FunctionComputeConfig"].type()) {
        DescribeApiHistoryResponseBodyServiceConfigFunctionComputeConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FunctionComputeConfig"]));
        functionComputeConfig = make_shared<DescribeApiHistoryResponseBodyServiceConfigFunctionComputeConfig>(model1);
      }
    }
    if (m.find("Mock") != m.end() && !m["Mock"].empty()) {
      mock = make_shared<string>(boost::any_cast<string>(m["Mock"]));
    }
    if (m.find("MockHeaders") != m.end() && !m["MockHeaders"].empty()) {
      if (typeid(map<string, boost::any>) == m["MockHeaders"].type()) {
        DescribeApiHistoryResponseBodyServiceConfigMockHeaders model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MockHeaders"]));
        mockHeaders = make_shared<DescribeApiHistoryResponseBodyServiceConfigMockHeaders>(model1);
      }
    }
    if (m.find("MockResult") != m.end() && !m["MockResult"].empty()) {
      mockResult = make_shared<string>(boost::any_cast<string>(m["MockResult"]));
    }
    if (m.find("MockStatusCode") != m.end() && !m["MockStatusCode"].empty()) {
      mockStatusCode = make_shared<long>(boost::any_cast<long>(m["MockStatusCode"]));
    }
    if (m.find("OssConfig") != m.end() && !m["OssConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["OssConfig"].type()) {
        DescribeApiHistoryResponseBodyServiceConfigOssConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OssConfig"]));
        ossConfig = make_shared<DescribeApiHistoryResponseBodyServiceConfigOssConfig>(model1);
      }
    }
    if (m.find("ServiceAddress") != m.end() && !m["ServiceAddress"].empty()) {
      serviceAddress = make_shared<string>(boost::any_cast<string>(m["ServiceAddress"]));
    }
    if (m.find("ServiceHttpMethod") != m.end() && !m["ServiceHttpMethod"].empty()) {
      serviceHttpMethod = make_shared<string>(boost::any_cast<string>(m["ServiceHttpMethod"]));
    }
    if (m.find("ServicePath") != m.end() && !m["ServicePath"].empty()) {
      servicePath = make_shared<string>(boost::any_cast<string>(m["ServicePath"]));
    }
    if (m.find("ServiceProtocol") != m.end() && !m["ServiceProtocol"].empty()) {
      serviceProtocol = make_shared<string>(boost::any_cast<string>(m["ServiceProtocol"]));
    }
    if (m.find("ServiceTimeout") != m.end() && !m["ServiceTimeout"].empty()) {
      serviceTimeout = make_shared<long>(boost::any_cast<long>(m["ServiceTimeout"]));
    }
    if (m.find("ServiceVpcEnable") != m.end() && !m["ServiceVpcEnable"].empty()) {
      serviceVpcEnable = make_shared<string>(boost::any_cast<string>(m["ServiceVpcEnable"]));
    }
    if (m.find("VpcConfig") != m.end() && !m["VpcConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["VpcConfig"].type()) {
        DescribeApiHistoryResponseBodyServiceConfigVpcConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["VpcConfig"]));
        vpcConfig = make_shared<DescribeApiHistoryResponseBodyServiceConfigVpcConfig>(model1);
      }
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
  }


  virtual ~DescribeApiHistoryResponseBodyServiceConfig() = default;
};
class DescribeApiHistoryResponseBodyServiceParametersServiceParameter : public Darabonba::Model {
public:
  shared_ptr<string> location{};
  shared_ptr<string> parameterType{};
  shared_ptr<string> serviceParameterName{};

  DescribeApiHistoryResponseBodyServiceParametersServiceParameter() {}

  explicit DescribeApiHistoryResponseBodyServiceParametersServiceParameter(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (parameterType) {
      res["ParameterType"] = boost::any(*parameterType);
    }
    if (serviceParameterName) {
      res["ServiceParameterName"] = boost::any(*serviceParameterName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("ParameterType") != m.end() && !m["ParameterType"].empty()) {
      parameterType = make_shared<string>(boost::any_cast<string>(m["ParameterType"]));
    }
    if (m.find("ServiceParameterName") != m.end() && !m["ServiceParameterName"].empty()) {
      serviceParameterName = make_shared<string>(boost::any_cast<string>(m["ServiceParameterName"]));
    }
  }


  virtual ~DescribeApiHistoryResponseBodyServiceParametersServiceParameter() = default;
};
class DescribeApiHistoryResponseBodyServiceParameters : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeApiHistoryResponseBodyServiceParametersServiceParameter>> serviceParameter{};

  DescribeApiHistoryResponseBodyServiceParameters() {}

  explicit DescribeApiHistoryResponseBodyServiceParameters(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (serviceParameter) {
      vector<boost::any> temp1;
      for(auto item1:*serviceParameter){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ServiceParameter"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ServiceParameter") != m.end() && !m["ServiceParameter"].empty()) {
      if (typeid(vector<boost::any>) == m["ServiceParameter"].type()) {
        vector<DescribeApiHistoryResponseBodyServiceParametersServiceParameter> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ServiceParameter"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeApiHistoryResponseBodyServiceParametersServiceParameter model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        serviceParameter = make_shared<vector<DescribeApiHistoryResponseBodyServiceParametersServiceParameter>>(expect1);
      }
    }
  }


  virtual ~DescribeApiHistoryResponseBodyServiceParameters() = default;
};
class DescribeApiHistoryResponseBodyServiceParametersMapServiceParameterMap : public Darabonba::Model {
public:
  shared_ptr<string> requestParameterName{};
  shared_ptr<string> serviceParameterName{};

  DescribeApiHistoryResponseBodyServiceParametersMapServiceParameterMap() {}

  explicit DescribeApiHistoryResponseBodyServiceParametersMapServiceParameterMap(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestParameterName) {
      res["RequestParameterName"] = boost::any(*requestParameterName);
    }
    if (serviceParameterName) {
      res["ServiceParameterName"] = boost::any(*serviceParameterName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestParameterName") != m.end() && !m["RequestParameterName"].empty()) {
      requestParameterName = make_shared<string>(boost::any_cast<string>(m["RequestParameterName"]));
    }
    if (m.find("ServiceParameterName") != m.end() && !m["ServiceParameterName"].empty()) {
      serviceParameterName = make_shared<string>(boost::any_cast<string>(m["ServiceParameterName"]));
    }
  }


  virtual ~DescribeApiHistoryResponseBodyServiceParametersMapServiceParameterMap() = default;
};
class DescribeApiHistoryResponseBodyServiceParametersMap : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeApiHistoryResponseBodyServiceParametersMapServiceParameterMap>> serviceParameterMap{};

  DescribeApiHistoryResponseBodyServiceParametersMap() {}

  explicit DescribeApiHistoryResponseBodyServiceParametersMap(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (serviceParameterMap) {
      vector<boost::any> temp1;
      for(auto item1:*serviceParameterMap){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ServiceParameterMap"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ServiceParameterMap") != m.end() && !m["ServiceParameterMap"].empty()) {
      if (typeid(vector<boost::any>) == m["ServiceParameterMap"].type()) {
        vector<DescribeApiHistoryResponseBodyServiceParametersMapServiceParameterMap> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ServiceParameterMap"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeApiHistoryResponseBodyServiceParametersMapServiceParameterMap model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        serviceParameterMap = make_shared<vector<DescribeApiHistoryResponseBodyServiceParametersMapServiceParameterMap>>(expect1);
      }
    }
  }


  virtual ~DescribeApiHistoryResponseBodyServiceParametersMap() = default;
};
class DescribeApiHistoryResponseBodySystemParametersSystemParameter : public Darabonba::Model {
public:
  shared_ptr<string> demoValue{};
  shared_ptr<string> description{};
  shared_ptr<string> location{};
  shared_ptr<string> parameterName{};
  shared_ptr<string> serviceParameterName{};

  DescribeApiHistoryResponseBodySystemParametersSystemParameter() {}

  explicit DescribeApiHistoryResponseBodySystemParametersSystemParameter(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (demoValue) {
      res["DemoValue"] = boost::any(*demoValue);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (parameterName) {
      res["ParameterName"] = boost::any(*parameterName);
    }
    if (serviceParameterName) {
      res["ServiceParameterName"] = boost::any(*serviceParameterName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DemoValue") != m.end() && !m["DemoValue"].empty()) {
      demoValue = make_shared<string>(boost::any_cast<string>(m["DemoValue"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("ParameterName") != m.end() && !m["ParameterName"].empty()) {
      parameterName = make_shared<string>(boost::any_cast<string>(m["ParameterName"]));
    }
    if (m.find("ServiceParameterName") != m.end() && !m["ServiceParameterName"].empty()) {
      serviceParameterName = make_shared<string>(boost::any_cast<string>(m["ServiceParameterName"]));
    }
  }


  virtual ~DescribeApiHistoryResponseBodySystemParametersSystemParameter() = default;
};
class DescribeApiHistoryResponseBodySystemParameters : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeApiHistoryResponseBodySystemParametersSystemParameter>> systemParameter{};

  DescribeApiHistoryResponseBodySystemParameters() {}

  explicit DescribeApiHistoryResponseBodySystemParameters(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (systemParameter) {
      vector<boost::any> temp1;
      for(auto item1:*systemParameter){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SystemParameter"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SystemParameter") != m.end() && !m["SystemParameter"].empty()) {
      if (typeid(vector<boost::any>) == m["SystemParameter"].type()) {
        vector<DescribeApiHistoryResponseBodySystemParametersSystemParameter> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SystemParameter"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeApiHistoryResponseBodySystemParametersSystemParameter model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        systemParameter = make_shared<vector<DescribeApiHistoryResponseBodySystemParametersSystemParameter>>(expect1);
      }
    }
  }


  virtual ~DescribeApiHistoryResponseBodySystemParameters() = default;
};
class DescribeApiHistoryResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> allowSignatureMethod{};
  shared_ptr<string> apiId{};
  shared_ptr<string> apiName{};
  shared_ptr<string> appCodeAuthType{};
  shared_ptr<string> authType{};
  shared_ptr<DescribeApiHistoryResponseBodyBackendConfig> backendConfig{};
  shared_ptr<bool> backendEnable{};
  shared_ptr<DescribeApiHistoryResponseBodyConstantParameters> constantParameters{};
  shared_ptr<DescribeApiHistoryResponseBodyCustomSystemParameters> customSystemParameters{};
  shared_ptr<string> deployedTime{};
  shared_ptr<string> description{};
  shared_ptr<bool> disableInternet{};
  shared_ptr<DescribeApiHistoryResponseBodyErrorCodeSamples> errorCodeSamples{};
  shared_ptr<string> failResultSample{};
  shared_ptr<bool> forceNonceCheck{};
  shared_ptr<string> groupId{};
  shared_ptr<string> groupName{};
  shared_ptr<string> historyVersion{};
  shared_ptr<DescribeApiHistoryResponseBodyOpenIdConnectConfig> openIdConnectConfig{};
  shared_ptr<string> regionId{};
  shared_ptr<DescribeApiHistoryResponseBodyRequestConfig> requestConfig{};
  shared_ptr<string> requestId{};
  shared_ptr<DescribeApiHistoryResponseBodyRequestParameters> requestParameters{};
  shared_ptr<string> resultBodyModel{};
  shared_ptr<DescribeApiHistoryResponseBodyResultDescriptions> resultDescriptions{};
  shared_ptr<string> resultSample{};
  shared_ptr<string> resultType{};
  shared_ptr<DescribeApiHistoryResponseBodyServiceConfig> serviceConfig{};
  shared_ptr<DescribeApiHistoryResponseBodyServiceParameters> serviceParameters{};
  shared_ptr<DescribeApiHistoryResponseBodyServiceParametersMap> serviceParametersMap{};
  shared_ptr<string> stageName{};
  shared_ptr<string> status{};
  shared_ptr<DescribeApiHistoryResponseBodySystemParameters> systemParameters{};
  shared_ptr<string> visibility{};
  shared_ptr<string> webSocketApiType{};

  DescribeApiHistoryResponseBody() {}

  explicit DescribeApiHistoryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (allowSignatureMethod) {
      res["AllowSignatureMethod"] = boost::any(*allowSignatureMethod);
    }
    if (apiId) {
      res["ApiId"] = boost::any(*apiId);
    }
    if (apiName) {
      res["ApiName"] = boost::any(*apiName);
    }
    if (appCodeAuthType) {
      res["AppCodeAuthType"] = boost::any(*appCodeAuthType);
    }
    if (authType) {
      res["AuthType"] = boost::any(*authType);
    }
    if (backendConfig) {
      res["BackendConfig"] = backendConfig ? boost::any(backendConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (backendEnable) {
      res["BackendEnable"] = boost::any(*backendEnable);
    }
    if (constantParameters) {
      res["ConstantParameters"] = constantParameters ? boost::any(constantParameters->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (customSystemParameters) {
      res["CustomSystemParameters"] = customSystemParameters ? boost::any(customSystemParameters->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (deployedTime) {
      res["DeployedTime"] = boost::any(*deployedTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (disableInternet) {
      res["DisableInternet"] = boost::any(*disableInternet);
    }
    if (errorCodeSamples) {
      res["ErrorCodeSamples"] = errorCodeSamples ? boost::any(errorCodeSamples->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (failResultSample) {
      res["FailResultSample"] = boost::any(*failResultSample);
    }
    if (forceNonceCheck) {
      res["ForceNonceCheck"] = boost::any(*forceNonceCheck);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (historyVersion) {
      res["HistoryVersion"] = boost::any(*historyVersion);
    }
    if (openIdConnectConfig) {
      res["OpenIdConnectConfig"] = openIdConnectConfig ? boost::any(openIdConnectConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (requestConfig) {
      res["RequestConfig"] = requestConfig ? boost::any(requestConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (requestParameters) {
      res["RequestParameters"] = requestParameters ? boost::any(requestParameters->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (resultBodyModel) {
      res["ResultBodyModel"] = boost::any(*resultBodyModel);
    }
    if (resultDescriptions) {
      res["ResultDescriptions"] = resultDescriptions ? boost::any(resultDescriptions->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (resultSample) {
      res["ResultSample"] = boost::any(*resultSample);
    }
    if (resultType) {
      res["ResultType"] = boost::any(*resultType);
    }
    if (serviceConfig) {
      res["ServiceConfig"] = serviceConfig ? boost::any(serviceConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (serviceParameters) {
      res["ServiceParameters"] = serviceParameters ? boost::any(serviceParameters->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (serviceParametersMap) {
      res["ServiceParametersMap"] = serviceParametersMap ? boost::any(serviceParametersMap->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (stageName) {
      res["StageName"] = boost::any(*stageName);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (systemParameters) {
      res["SystemParameters"] = systemParameters ? boost::any(systemParameters->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (visibility) {
      res["Visibility"] = boost::any(*visibility);
    }
    if (webSocketApiType) {
      res["WebSocketApiType"] = boost::any(*webSocketApiType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AllowSignatureMethod") != m.end() && !m["AllowSignatureMethod"].empty()) {
      allowSignatureMethod = make_shared<string>(boost::any_cast<string>(m["AllowSignatureMethod"]));
    }
    if (m.find("ApiId") != m.end() && !m["ApiId"].empty()) {
      apiId = make_shared<string>(boost::any_cast<string>(m["ApiId"]));
    }
    if (m.find("ApiName") != m.end() && !m["ApiName"].empty()) {
      apiName = make_shared<string>(boost::any_cast<string>(m["ApiName"]));
    }
    if (m.find("AppCodeAuthType") != m.end() && !m["AppCodeAuthType"].empty()) {
      appCodeAuthType = make_shared<string>(boost::any_cast<string>(m["AppCodeAuthType"]));
    }
    if (m.find("AuthType") != m.end() && !m["AuthType"].empty()) {
      authType = make_shared<string>(boost::any_cast<string>(m["AuthType"]));
    }
    if (m.find("BackendConfig") != m.end() && !m["BackendConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["BackendConfig"].type()) {
        DescribeApiHistoryResponseBodyBackendConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["BackendConfig"]));
        backendConfig = make_shared<DescribeApiHistoryResponseBodyBackendConfig>(model1);
      }
    }
    if (m.find("BackendEnable") != m.end() && !m["BackendEnable"].empty()) {
      backendEnable = make_shared<bool>(boost::any_cast<bool>(m["BackendEnable"]));
    }
    if (m.find("ConstantParameters") != m.end() && !m["ConstantParameters"].empty()) {
      if (typeid(map<string, boost::any>) == m["ConstantParameters"].type()) {
        DescribeApiHistoryResponseBodyConstantParameters model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ConstantParameters"]));
        constantParameters = make_shared<DescribeApiHistoryResponseBodyConstantParameters>(model1);
      }
    }
    if (m.find("CustomSystemParameters") != m.end() && !m["CustomSystemParameters"].empty()) {
      if (typeid(map<string, boost::any>) == m["CustomSystemParameters"].type()) {
        DescribeApiHistoryResponseBodyCustomSystemParameters model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CustomSystemParameters"]));
        customSystemParameters = make_shared<DescribeApiHistoryResponseBodyCustomSystemParameters>(model1);
      }
    }
    if (m.find("DeployedTime") != m.end() && !m["DeployedTime"].empty()) {
      deployedTime = make_shared<string>(boost::any_cast<string>(m["DeployedTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DisableInternet") != m.end() && !m["DisableInternet"].empty()) {
      disableInternet = make_shared<bool>(boost::any_cast<bool>(m["DisableInternet"]));
    }
    if (m.find("ErrorCodeSamples") != m.end() && !m["ErrorCodeSamples"].empty()) {
      if (typeid(map<string, boost::any>) == m["ErrorCodeSamples"].type()) {
        DescribeApiHistoryResponseBodyErrorCodeSamples model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ErrorCodeSamples"]));
        errorCodeSamples = make_shared<DescribeApiHistoryResponseBodyErrorCodeSamples>(model1);
      }
    }
    if (m.find("FailResultSample") != m.end() && !m["FailResultSample"].empty()) {
      failResultSample = make_shared<string>(boost::any_cast<string>(m["FailResultSample"]));
    }
    if (m.find("ForceNonceCheck") != m.end() && !m["ForceNonceCheck"].empty()) {
      forceNonceCheck = make_shared<bool>(boost::any_cast<bool>(m["ForceNonceCheck"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("HistoryVersion") != m.end() && !m["HistoryVersion"].empty()) {
      historyVersion = make_shared<string>(boost::any_cast<string>(m["HistoryVersion"]));
    }
    if (m.find("OpenIdConnectConfig") != m.end() && !m["OpenIdConnectConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["OpenIdConnectConfig"].type()) {
        DescribeApiHistoryResponseBodyOpenIdConnectConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OpenIdConnectConfig"]));
        openIdConnectConfig = make_shared<DescribeApiHistoryResponseBodyOpenIdConnectConfig>(model1);
      }
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("RequestConfig") != m.end() && !m["RequestConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["RequestConfig"].type()) {
        DescribeApiHistoryResponseBodyRequestConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RequestConfig"]));
        requestConfig = make_shared<DescribeApiHistoryResponseBodyRequestConfig>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("RequestParameters") != m.end() && !m["RequestParameters"].empty()) {
      if (typeid(map<string, boost::any>) == m["RequestParameters"].type()) {
        DescribeApiHistoryResponseBodyRequestParameters model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RequestParameters"]));
        requestParameters = make_shared<DescribeApiHistoryResponseBodyRequestParameters>(model1);
      }
    }
    if (m.find("ResultBodyModel") != m.end() && !m["ResultBodyModel"].empty()) {
      resultBodyModel = make_shared<string>(boost::any_cast<string>(m["ResultBodyModel"]));
    }
    if (m.find("ResultDescriptions") != m.end() && !m["ResultDescriptions"].empty()) {
      if (typeid(map<string, boost::any>) == m["ResultDescriptions"].type()) {
        DescribeApiHistoryResponseBodyResultDescriptions model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ResultDescriptions"]));
        resultDescriptions = make_shared<DescribeApiHistoryResponseBodyResultDescriptions>(model1);
      }
    }
    if (m.find("ResultSample") != m.end() && !m["ResultSample"].empty()) {
      resultSample = make_shared<string>(boost::any_cast<string>(m["ResultSample"]));
    }
    if (m.find("ResultType") != m.end() && !m["ResultType"].empty()) {
      resultType = make_shared<string>(boost::any_cast<string>(m["ResultType"]));
    }
    if (m.find("ServiceConfig") != m.end() && !m["ServiceConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["ServiceConfig"].type()) {
        DescribeApiHistoryResponseBodyServiceConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ServiceConfig"]));
        serviceConfig = make_shared<DescribeApiHistoryResponseBodyServiceConfig>(model1);
      }
    }
    if (m.find("ServiceParameters") != m.end() && !m["ServiceParameters"].empty()) {
      if (typeid(map<string, boost::any>) == m["ServiceParameters"].type()) {
        DescribeApiHistoryResponseBodyServiceParameters model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ServiceParameters"]));
        serviceParameters = make_shared<DescribeApiHistoryResponseBodyServiceParameters>(model1);
      }
    }
    if (m.find("ServiceParametersMap") != m.end() && !m["ServiceParametersMap"].empty()) {
      if (typeid(map<string, boost::any>) == m["ServiceParametersMap"].type()) {
        DescribeApiHistoryResponseBodyServiceParametersMap model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ServiceParametersMap"]));
        serviceParametersMap = make_shared<DescribeApiHistoryResponseBodyServiceParametersMap>(model1);
      }
    }
    if (m.find("StageName") != m.end() && !m["StageName"].empty()) {
      stageName = make_shared<string>(boost::any_cast<string>(m["StageName"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("SystemParameters") != m.end() && !m["SystemParameters"].empty()) {
      if (typeid(map<string, boost::any>) == m["SystemParameters"].type()) {
        DescribeApiHistoryResponseBodySystemParameters model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SystemParameters"]));
        systemParameters = make_shared<DescribeApiHistoryResponseBodySystemParameters>(model1);
      }
    }
    if (m.find("Visibility") != m.end() && !m["Visibility"].empty()) {
      visibility = make_shared<string>(boost::any_cast<string>(m["Visibility"]));
    }
    if (m.find("WebSocketApiType") != m.end() && !m["WebSocketApiType"].empty()) {
      webSocketApiType = make_shared<string>(boost::any_cast<string>(m["WebSocketApiType"]));
    }
  }


  virtual ~DescribeApiHistoryResponseBody() = default;
};
class DescribeApiHistoryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeApiHistoryResponseBody> body{};

  DescribeApiHistoryResponse() {}

  explicit DescribeApiHistoryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeApiHistoryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeApiHistoryResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeApiHistoryResponse() = default;
};
class DescribeApiIpControlsRequest : public Darabonba::Model {
public:
  shared_ptr<string> apiIds{};
  shared_ptr<string> groupId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> stageName{};

  DescribeApiIpControlsRequest() {}

  explicit DescribeApiIpControlsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiIds) {
      res["ApiIds"] = boost::any(*apiIds);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (stageName) {
      res["StageName"] = boost::any(*stageName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiIds") != m.end() && !m["ApiIds"].empty()) {
      apiIds = make_shared<string>(boost::any_cast<string>(m["ApiIds"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("StageName") != m.end() && !m["StageName"].empty()) {
      stageName = make_shared<string>(boost::any_cast<string>(m["StageName"]));
    }
  }


  virtual ~DescribeApiIpControlsRequest() = default;
};
class DescribeApiIpControlsResponseBodyApiIpControlsApiIpControlItem : public Darabonba::Model {
public:
  shared_ptr<string> apiId{};
  shared_ptr<string> apiName{};
  shared_ptr<string> boundTime{};
  shared_ptr<string> ipControlId{};
  shared_ptr<string> ipControlName{};

  DescribeApiIpControlsResponseBodyApiIpControlsApiIpControlItem() {}

  explicit DescribeApiIpControlsResponseBodyApiIpControlsApiIpControlItem(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiId) {
      res["ApiId"] = boost::any(*apiId);
    }
    if (apiName) {
      res["ApiName"] = boost::any(*apiName);
    }
    if (boundTime) {
      res["BoundTime"] = boost::any(*boundTime);
    }
    if (ipControlId) {
      res["IpControlId"] = boost::any(*ipControlId);
    }
    if (ipControlName) {
      res["IpControlName"] = boost::any(*ipControlName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiId") != m.end() && !m["ApiId"].empty()) {
      apiId = make_shared<string>(boost::any_cast<string>(m["ApiId"]));
    }
    if (m.find("ApiName") != m.end() && !m["ApiName"].empty()) {
      apiName = make_shared<string>(boost::any_cast<string>(m["ApiName"]));
    }
    if (m.find("BoundTime") != m.end() && !m["BoundTime"].empty()) {
      boundTime = make_shared<string>(boost::any_cast<string>(m["BoundTime"]));
    }
    if (m.find("IpControlId") != m.end() && !m["IpControlId"].empty()) {
      ipControlId = make_shared<string>(boost::any_cast<string>(m["IpControlId"]));
    }
    if (m.find("IpControlName") != m.end() && !m["IpControlName"].empty()) {
      ipControlName = make_shared<string>(boost::any_cast<string>(m["IpControlName"]));
    }
  }


  virtual ~DescribeApiIpControlsResponseBodyApiIpControlsApiIpControlItem() = default;
};
class DescribeApiIpControlsResponseBodyApiIpControls : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeApiIpControlsResponseBodyApiIpControlsApiIpControlItem>> apiIpControlItem{};

  DescribeApiIpControlsResponseBodyApiIpControls() {}

  explicit DescribeApiIpControlsResponseBodyApiIpControls(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiIpControlItem) {
      vector<boost::any> temp1;
      for(auto item1:*apiIpControlItem){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ApiIpControlItem"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiIpControlItem") != m.end() && !m["ApiIpControlItem"].empty()) {
      if (typeid(vector<boost::any>) == m["ApiIpControlItem"].type()) {
        vector<DescribeApiIpControlsResponseBodyApiIpControlsApiIpControlItem> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ApiIpControlItem"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeApiIpControlsResponseBodyApiIpControlsApiIpControlItem model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        apiIpControlItem = make_shared<vector<DescribeApiIpControlsResponseBodyApiIpControlsApiIpControlItem>>(expect1);
      }
    }
  }


  virtual ~DescribeApiIpControlsResponseBodyApiIpControls() = default;
};
class DescribeApiIpControlsResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeApiIpControlsResponseBodyApiIpControls> apiIpControls{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeApiIpControlsResponseBody() {}

  explicit DescribeApiIpControlsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiIpControls) {
      res["ApiIpControls"] = apiIpControls ? boost::any(apiIpControls->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiIpControls") != m.end() && !m["ApiIpControls"].empty()) {
      if (typeid(map<string, boost::any>) == m["ApiIpControls"].type()) {
        DescribeApiIpControlsResponseBodyApiIpControls model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ApiIpControls"]));
        apiIpControls = make_shared<DescribeApiIpControlsResponseBodyApiIpControls>(model1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeApiIpControlsResponseBody() = default;
};
class DescribeApiIpControlsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeApiIpControlsResponseBody> body{};

  DescribeApiIpControlsResponse() {}

  explicit DescribeApiIpControlsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeApiIpControlsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeApiIpControlsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeApiIpControlsResponse() = default;
};
class DescribeApiLatencyDataRequest : public Darabonba::Model {
public:
  shared_ptr<string> apiId{};
  shared_ptr<string> endTime{};
  shared_ptr<string> groupId{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> stageName{};
  shared_ptr<string> startTime{};

  DescribeApiLatencyDataRequest() {}

  explicit DescribeApiLatencyDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiId) {
      res["ApiId"] = boost::any(*apiId);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (stageName) {
      res["StageName"] = boost::any(*stageName);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiId") != m.end() && !m["ApiId"].empty()) {
      apiId = make_shared<string>(boost::any_cast<string>(m["ApiId"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("StageName") != m.end() && !m["StageName"].empty()) {
      stageName = make_shared<string>(boost::any_cast<string>(m["StageName"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeApiLatencyDataRequest() = default;
};
class DescribeApiLatencyDataResponseBodyCallLatencysMonitorItem : public Darabonba::Model {
public:
  shared_ptr<string> itemTime{};
  shared_ptr<string> itemValue{};

  DescribeApiLatencyDataResponseBodyCallLatencysMonitorItem() {}

  explicit DescribeApiLatencyDataResponseBodyCallLatencysMonitorItem(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (itemTime) {
      res["ItemTime"] = boost::any(*itemTime);
    }
    if (itemValue) {
      res["ItemValue"] = boost::any(*itemValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ItemTime") != m.end() && !m["ItemTime"].empty()) {
      itemTime = make_shared<string>(boost::any_cast<string>(m["ItemTime"]));
    }
    if (m.find("ItemValue") != m.end() && !m["ItemValue"].empty()) {
      itemValue = make_shared<string>(boost::any_cast<string>(m["ItemValue"]));
    }
  }


  virtual ~DescribeApiLatencyDataResponseBodyCallLatencysMonitorItem() = default;
};
class DescribeApiLatencyDataResponseBodyCallLatencys : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeApiLatencyDataResponseBodyCallLatencysMonitorItem>> monitorItem{};

  DescribeApiLatencyDataResponseBodyCallLatencys() {}

  explicit DescribeApiLatencyDataResponseBodyCallLatencys(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (monitorItem) {
      vector<boost::any> temp1;
      for(auto item1:*monitorItem){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["MonitorItem"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MonitorItem") != m.end() && !m["MonitorItem"].empty()) {
      if (typeid(vector<boost::any>) == m["MonitorItem"].type()) {
        vector<DescribeApiLatencyDataResponseBodyCallLatencysMonitorItem> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["MonitorItem"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeApiLatencyDataResponseBodyCallLatencysMonitorItem model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        monitorItem = make_shared<vector<DescribeApiLatencyDataResponseBodyCallLatencysMonitorItem>>(expect1);
      }
    }
  }


  virtual ~DescribeApiLatencyDataResponseBodyCallLatencys() = default;
};
class DescribeApiLatencyDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeApiLatencyDataResponseBodyCallLatencys> callLatencys{};
  shared_ptr<string> requestId{};

  DescribeApiLatencyDataResponseBody() {}

  explicit DescribeApiLatencyDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callLatencys) {
      res["CallLatencys"] = callLatencys ? boost::any(callLatencys->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallLatencys") != m.end() && !m["CallLatencys"].empty()) {
      if (typeid(map<string, boost::any>) == m["CallLatencys"].type()) {
        DescribeApiLatencyDataResponseBodyCallLatencys model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CallLatencys"]));
        callLatencys = make_shared<DescribeApiLatencyDataResponseBodyCallLatencys>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeApiLatencyDataResponseBody() = default;
};
class DescribeApiLatencyDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeApiLatencyDataResponseBody> body{};

  DescribeApiLatencyDataResponse() {}

  explicit DescribeApiLatencyDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeApiLatencyDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeApiLatencyDataResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeApiLatencyDataResponse() = default;
};
class DescribeApiMarketAttributesRequest : public Darabonba::Model {
public:
  shared_ptr<string> apiId{};
  shared_ptr<string> groupId{};
  shared_ptr<string> securityToken{};

  DescribeApiMarketAttributesRequest() {}

  explicit DescribeApiMarketAttributesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiId) {
      res["ApiId"] = boost::any(*apiId);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiId") != m.end() && !m["ApiId"].empty()) {
      apiId = make_shared<string>(boost::any_cast<string>(m["ApiId"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~DescribeApiMarketAttributesRequest() = default;
};
class DescribeApiMarketAttributesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> apiId{};
  shared_ptr<string> marketChargingMode{};
  shared_ptr<string> needCharging{};
  shared_ptr<string> requestId{};

  DescribeApiMarketAttributesResponseBody() {}

  explicit DescribeApiMarketAttributesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiId) {
      res["ApiId"] = boost::any(*apiId);
    }
    if (marketChargingMode) {
      res["MarketChargingMode"] = boost::any(*marketChargingMode);
    }
    if (needCharging) {
      res["NeedCharging"] = boost::any(*needCharging);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiId") != m.end() && !m["ApiId"].empty()) {
      apiId = make_shared<string>(boost::any_cast<string>(m["ApiId"]));
    }
    if (m.find("MarketChargingMode") != m.end() && !m["MarketChargingMode"].empty()) {
      marketChargingMode = make_shared<string>(boost::any_cast<string>(m["MarketChargingMode"]));
    }
    if (m.find("NeedCharging") != m.end() && !m["NeedCharging"].empty()) {
      needCharging = make_shared<string>(boost::any_cast<string>(m["NeedCharging"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeApiMarketAttributesResponseBody() = default;
};
class DescribeApiMarketAttributesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeApiMarketAttributesResponseBody> body{};

  DescribeApiMarketAttributesResponse() {}

  explicit DescribeApiMarketAttributesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeApiMarketAttributesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeApiMarketAttributesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeApiMarketAttributesResponse() = default;
};
class DescribeApiProductApisRequest : public Darabonba::Model {
public:
  shared_ptr<string> apiProductId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> securityToken{};

  DescribeApiProductApisRequest() {}

  explicit DescribeApiProductApisRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiProductId) {
      res["ApiProductId"] = boost::any(*apiProductId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiProductId") != m.end() && !m["ApiProductId"].empty()) {
      apiProductId = make_shared<string>(boost::any_cast<string>(m["ApiProductId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~DescribeApiProductApisRequest() = default;
};
class DescribeApiProductApisResponseBodyApiInfoListApiInfo : public Darabonba::Model {
public:
  shared_ptr<string> apiId{};
  shared_ptr<string> apiName{};
  shared_ptr<string> description{};
  shared_ptr<string> groupId{};
  shared_ptr<string> groupName{};
  shared_ptr<string> method{};
  shared_ptr<string> path{};
  shared_ptr<string> regionId{};
  shared_ptr<string> stageName{};

  DescribeApiProductApisResponseBodyApiInfoListApiInfo() {}

  explicit DescribeApiProductApisResponseBodyApiInfoListApiInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiId) {
      res["ApiId"] = boost::any(*apiId);
    }
    if (apiName) {
      res["ApiName"] = boost::any(*apiName);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (method) {
      res["Method"] = boost::any(*method);
    }
    if (path) {
      res["Path"] = boost::any(*path);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (stageName) {
      res["StageName"] = boost::any(*stageName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiId") != m.end() && !m["ApiId"].empty()) {
      apiId = make_shared<string>(boost::any_cast<string>(m["ApiId"]));
    }
    if (m.find("ApiName") != m.end() && !m["ApiName"].empty()) {
      apiName = make_shared<string>(boost::any_cast<string>(m["ApiName"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("Method") != m.end() && !m["Method"].empty()) {
      method = make_shared<string>(boost::any_cast<string>(m["Method"]));
    }
    if (m.find("Path") != m.end() && !m["Path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["Path"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("StageName") != m.end() && !m["StageName"].empty()) {
      stageName = make_shared<string>(boost::any_cast<string>(m["StageName"]));
    }
  }


  virtual ~DescribeApiProductApisResponseBodyApiInfoListApiInfo() = default;
};
class DescribeApiProductApisResponseBodyApiInfoList : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeApiProductApisResponseBodyApiInfoListApiInfo>> apiInfo{};

  DescribeApiProductApisResponseBodyApiInfoList() {}

  explicit DescribeApiProductApisResponseBodyApiInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiInfo) {
      vector<boost::any> temp1;
      for(auto item1:*apiInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ApiInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiInfo") != m.end() && !m["ApiInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["ApiInfo"].type()) {
        vector<DescribeApiProductApisResponseBodyApiInfoListApiInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ApiInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeApiProductApisResponseBodyApiInfoListApiInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        apiInfo = make_shared<vector<DescribeApiProductApisResponseBodyApiInfoListApiInfo>>(expect1);
      }
    }
  }


  virtual ~DescribeApiProductApisResponseBodyApiInfoList() = default;
};
class DescribeApiProductApisResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeApiProductApisResponseBodyApiInfoList> apiInfoList{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeApiProductApisResponseBody() {}

  explicit DescribeApiProductApisResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiInfoList) {
      res["ApiInfoList"] = apiInfoList ? boost::any(apiInfoList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiInfoList") != m.end() && !m["ApiInfoList"].empty()) {
      if (typeid(map<string, boost::any>) == m["ApiInfoList"].type()) {
        DescribeApiProductApisResponseBodyApiInfoList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ApiInfoList"]));
        apiInfoList = make_shared<DescribeApiProductApisResponseBodyApiInfoList>(model1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeApiProductApisResponseBody() = default;
};
class DescribeApiProductApisResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeApiProductApisResponseBody> body{};

  DescribeApiProductApisResponse() {}

  explicit DescribeApiProductApisResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeApiProductApisResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeApiProductApisResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeApiProductApisResponse() = default;
};
class DescribeApiProductsByAppRequest : public Darabonba::Model {
public:
  shared_ptr<long> appId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> securityToken{};

  DescribeApiProductsByAppRequest() {}

  explicit DescribeApiProductsByAppRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<long>(boost::any_cast<long>(m["AppId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~DescribeApiProductsByAppRequest() = default;
};
class DescribeApiProductsByAppResponseBodyApiProductInfoListApiProductInfo : public Darabonba::Model {
public:
  shared_ptr<string> apiProductId{};

  DescribeApiProductsByAppResponseBodyApiProductInfoListApiProductInfo() {}

  explicit DescribeApiProductsByAppResponseBodyApiProductInfoListApiProductInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiProductId) {
      res["ApiProductId"] = boost::any(*apiProductId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiProductId") != m.end() && !m["ApiProductId"].empty()) {
      apiProductId = make_shared<string>(boost::any_cast<string>(m["ApiProductId"]));
    }
  }


  virtual ~DescribeApiProductsByAppResponseBodyApiProductInfoListApiProductInfo() = default;
};
class DescribeApiProductsByAppResponseBodyApiProductInfoList : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeApiProductsByAppResponseBodyApiProductInfoListApiProductInfo>> apiProductInfo{};

  DescribeApiProductsByAppResponseBodyApiProductInfoList() {}

  explicit DescribeApiProductsByAppResponseBodyApiProductInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiProductInfo) {
      vector<boost::any> temp1;
      for(auto item1:*apiProductInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ApiProductInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiProductInfo") != m.end() && !m["ApiProductInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["ApiProductInfo"].type()) {
        vector<DescribeApiProductsByAppResponseBodyApiProductInfoListApiProductInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ApiProductInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeApiProductsByAppResponseBodyApiProductInfoListApiProductInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        apiProductInfo = make_shared<vector<DescribeApiProductsByAppResponseBodyApiProductInfoListApiProductInfo>>(expect1);
      }
    }
  }


  virtual ~DescribeApiProductsByAppResponseBodyApiProductInfoList() = default;
};
class DescribeApiProductsByAppResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeApiProductsByAppResponseBodyApiProductInfoList> apiProductInfoList{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeApiProductsByAppResponseBody() {}

  explicit DescribeApiProductsByAppResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiProductInfoList) {
      res["ApiProductInfoList"] = apiProductInfoList ? boost::any(apiProductInfoList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiProductInfoList") != m.end() && !m["ApiProductInfoList"].empty()) {
      if (typeid(map<string, boost::any>) == m["ApiProductInfoList"].type()) {
        DescribeApiProductsByAppResponseBodyApiProductInfoList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ApiProductInfoList"]));
        apiProductInfoList = make_shared<DescribeApiProductsByAppResponseBodyApiProductInfoList>(model1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeApiProductsByAppResponseBody() = default;
};
class DescribeApiProductsByAppResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeApiProductsByAppResponseBody> body{};

  DescribeApiProductsByAppResponse() {}

  explicit DescribeApiProductsByAppResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeApiProductsByAppResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeApiProductsByAppResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeApiProductsByAppResponse() = default;
};
class DescribeApiQpsDataRequest : public Darabonba::Model {
public:
  shared_ptr<string> apiId{};
  shared_ptr<string> endTime{};
  shared_ptr<string> groupId{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> stageName{};
  shared_ptr<string> startTime{};

  DescribeApiQpsDataRequest() {}

  explicit DescribeApiQpsDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiId) {
      res["ApiId"] = boost::any(*apiId);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (stageName) {
      res["StageName"] = boost::any(*stageName);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiId") != m.end() && !m["ApiId"].empty()) {
      apiId = make_shared<string>(boost::any_cast<string>(m["ApiId"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("StageName") != m.end() && !m["StageName"].empty()) {
      stageName = make_shared<string>(boost::any_cast<string>(m["StageName"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeApiQpsDataRequest() = default;
};
class DescribeApiQpsDataResponseBodyCallFailsMonitorItem : public Darabonba::Model {
public:
  shared_ptr<string> itemTime{};
  shared_ptr<string> itemValue{};

  DescribeApiQpsDataResponseBodyCallFailsMonitorItem() {}

  explicit DescribeApiQpsDataResponseBodyCallFailsMonitorItem(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (itemTime) {
      res["ItemTime"] = boost::any(*itemTime);
    }
    if (itemValue) {
      res["ItemValue"] = boost::any(*itemValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ItemTime") != m.end() && !m["ItemTime"].empty()) {
      itemTime = make_shared<string>(boost::any_cast<string>(m["ItemTime"]));
    }
    if (m.find("ItemValue") != m.end() && !m["ItemValue"].empty()) {
      itemValue = make_shared<string>(boost::any_cast<string>(m["ItemValue"]));
    }
  }


  virtual ~DescribeApiQpsDataResponseBodyCallFailsMonitorItem() = default;
};
class DescribeApiQpsDataResponseBodyCallFails : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeApiQpsDataResponseBodyCallFailsMonitorItem>> monitorItem{};

  DescribeApiQpsDataResponseBodyCallFails() {}

  explicit DescribeApiQpsDataResponseBodyCallFails(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (monitorItem) {
      vector<boost::any> temp1;
      for(auto item1:*monitorItem){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["MonitorItem"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MonitorItem") != m.end() && !m["MonitorItem"].empty()) {
      if (typeid(vector<boost::any>) == m["MonitorItem"].type()) {
        vector<DescribeApiQpsDataResponseBodyCallFailsMonitorItem> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["MonitorItem"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeApiQpsDataResponseBodyCallFailsMonitorItem model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        monitorItem = make_shared<vector<DescribeApiQpsDataResponseBodyCallFailsMonitorItem>>(expect1);
      }
    }
  }


  virtual ~DescribeApiQpsDataResponseBodyCallFails() = default;
};
class DescribeApiQpsDataResponseBodyCallSuccessesMonitorItem : public Darabonba::Model {
public:
  shared_ptr<string> itemTime{};
  shared_ptr<string> itemValue{};

  DescribeApiQpsDataResponseBodyCallSuccessesMonitorItem() {}

  explicit DescribeApiQpsDataResponseBodyCallSuccessesMonitorItem(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (itemTime) {
      res["ItemTime"] = boost::any(*itemTime);
    }
    if (itemValue) {
      res["ItemValue"] = boost::any(*itemValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ItemTime") != m.end() && !m["ItemTime"].empty()) {
      itemTime = make_shared<string>(boost::any_cast<string>(m["ItemTime"]));
    }
    if (m.find("ItemValue") != m.end() && !m["ItemValue"].empty()) {
      itemValue = make_shared<string>(boost::any_cast<string>(m["ItemValue"]));
    }
  }


  virtual ~DescribeApiQpsDataResponseBodyCallSuccessesMonitorItem() = default;
};
class DescribeApiQpsDataResponseBodyCallSuccesses : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeApiQpsDataResponseBodyCallSuccessesMonitorItem>> monitorItem{};

  DescribeApiQpsDataResponseBodyCallSuccesses() {}

  explicit DescribeApiQpsDataResponseBodyCallSuccesses(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (monitorItem) {
      vector<boost::any> temp1;
      for(auto item1:*monitorItem){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["MonitorItem"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MonitorItem") != m.end() && !m["MonitorItem"].empty()) {
      if (typeid(vector<boost::any>) == m["MonitorItem"].type()) {
        vector<DescribeApiQpsDataResponseBodyCallSuccessesMonitorItem> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["MonitorItem"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeApiQpsDataResponseBodyCallSuccessesMonitorItem model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        monitorItem = make_shared<vector<DescribeApiQpsDataResponseBodyCallSuccessesMonitorItem>>(expect1);
      }
    }
  }


  virtual ~DescribeApiQpsDataResponseBodyCallSuccesses() = default;
};
class DescribeApiQpsDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeApiQpsDataResponseBodyCallFails> callFails{};
  shared_ptr<DescribeApiQpsDataResponseBodyCallSuccesses> callSuccesses{};
  shared_ptr<string> requestId{};

  DescribeApiQpsDataResponseBody() {}

  explicit DescribeApiQpsDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callFails) {
      res["CallFails"] = callFails ? boost::any(callFails->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (callSuccesses) {
      res["CallSuccesses"] = callSuccesses ? boost::any(callSuccesses->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallFails") != m.end() && !m["CallFails"].empty()) {
      if (typeid(map<string, boost::any>) == m["CallFails"].type()) {
        DescribeApiQpsDataResponseBodyCallFails model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CallFails"]));
        callFails = make_shared<DescribeApiQpsDataResponseBodyCallFails>(model1);
      }
    }
    if (m.find("CallSuccesses") != m.end() && !m["CallSuccesses"].empty()) {
      if (typeid(map<string, boost::any>) == m["CallSuccesses"].type()) {
        DescribeApiQpsDataResponseBodyCallSuccesses model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CallSuccesses"]));
        callSuccesses = make_shared<DescribeApiQpsDataResponseBodyCallSuccesses>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeApiQpsDataResponseBody() = default;
};
class DescribeApiQpsDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeApiQpsDataResponseBody> body{};

  DescribeApiQpsDataResponse() {}

  explicit DescribeApiQpsDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeApiQpsDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeApiQpsDataResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeApiQpsDataResponse() = default;
};
class DescribeApiSignaturesRequest : public Darabonba::Model {
public:
  shared_ptr<string> apiIds{};
  shared_ptr<string> groupId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> stageName{};

  DescribeApiSignaturesRequest() {}

  explicit DescribeApiSignaturesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiIds) {
      res["ApiIds"] = boost::any(*apiIds);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (stageName) {
      res["StageName"] = boost::any(*stageName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiIds") != m.end() && !m["ApiIds"].empty()) {
      apiIds = make_shared<string>(boost::any_cast<string>(m["ApiIds"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("StageName") != m.end() && !m["StageName"].empty()) {
      stageName = make_shared<string>(boost::any_cast<string>(m["StageName"]));
    }
  }


  virtual ~DescribeApiSignaturesRequest() = default;
};
class DescribeApiSignaturesResponseBodyApiSignaturesApiSignatureItem : public Darabonba::Model {
public:
  shared_ptr<string> apiId{};
  shared_ptr<string> apiName{};
  shared_ptr<string> boundTime{};
  shared_ptr<string> signatureId{};
  shared_ptr<string> signatureName{};

  DescribeApiSignaturesResponseBodyApiSignaturesApiSignatureItem() {}

  explicit DescribeApiSignaturesResponseBodyApiSignaturesApiSignatureItem(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiId) {
      res["ApiId"] = boost::any(*apiId);
    }
    if (apiName) {
      res["ApiName"] = boost::any(*apiName);
    }
    if (boundTime) {
      res["BoundTime"] = boost::any(*boundTime);
    }
    if (signatureId) {
      res["SignatureId"] = boost::any(*signatureId);
    }
    if (signatureName) {
      res["SignatureName"] = boost::any(*signatureName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiId") != m.end() && !m["ApiId"].empty()) {
      apiId = make_shared<string>(boost::any_cast<string>(m["ApiId"]));
    }
    if (m.find("ApiName") != m.end() && !m["ApiName"].empty()) {
      apiName = make_shared<string>(boost::any_cast<string>(m["ApiName"]));
    }
    if (m.find("BoundTime") != m.end() && !m["BoundTime"].empty()) {
      boundTime = make_shared<string>(boost::any_cast<string>(m["BoundTime"]));
    }
    if (m.find("SignatureId") != m.end() && !m["SignatureId"].empty()) {
      signatureId = make_shared<string>(boost::any_cast<string>(m["SignatureId"]));
    }
    if (m.find("SignatureName") != m.end() && !m["SignatureName"].empty()) {
      signatureName = make_shared<string>(boost::any_cast<string>(m["SignatureName"]));
    }
  }


  virtual ~DescribeApiSignaturesResponseBodyApiSignaturesApiSignatureItem() = default;
};
class DescribeApiSignaturesResponseBodyApiSignatures : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeApiSignaturesResponseBodyApiSignaturesApiSignatureItem>> apiSignatureItem{};

  DescribeApiSignaturesResponseBodyApiSignatures() {}

  explicit DescribeApiSignaturesResponseBodyApiSignatures(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiSignatureItem) {
      vector<boost::any> temp1;
      for(auto item1:*apiSignatureItem){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ApiSignatureItem"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiSignatureItem") != m.end() && !m["ApiSignatureItem"].empty()) {
      if (typeid(vector<boost::any>) == m["ApiSignatureItem"].type()) {
        vector<DescribeApiSignaturesResponseBodyApiSignaturesApiSignatureItem> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ApiSignatureItem"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeApiSignaturesResponseBodyApiSignaturesApiSignatureItem model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        apiSignatureItem = make_shared<vector<DescribeApiSignaturesResponseBodyApiSignaturesApiSignatureItem>>(expect1);
      }
    }
  }


  virtual ~DescribeApiSignaturesResponseBodyApiSignatures() = default;
};
class DescribeApiSignaturesResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeApiSignaturesResponseBodyApiSignatures> apiSignatures{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeApiSignaturesResponseBody() {}

  explicit DescribeApiSignaturesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiSignatures) {
      res["ApiSignatures"] = apiSignatures ? boost::any(apiSignatures->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiSignatures") != m.end() && !m["ApiSignatures"].empty()) {
      if (typeid(map<string, boost::any>) == m["ApiSignatures"].type()) {
        DescribeApiSignaturesResponseBodyApiSignatures model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ApiSignatures"]));
        apiSignatures = make_shared<DescribeApiSignaturesResponseBodyApiSignatures>(model1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeApiSignaturesResponseBody() = default;
};
class DescribeApiSignaturesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeApiSignaturesResponseBody> body{};

  DescribeApiSignaturesResponse() {}

  explicit DescribeApiSignaturesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeApiSignaturesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeApiSignaturesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeApiSignaturesResponse() = default;
};
class DescribeApiTrafficControlsRequest : public Darabonba::Model {
public:
  shared_ptr<string> apiIds{};
  shared_ptr<string> groupId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> stageName{};

  DescribeApiTrafficControlsRequest() {}

  explicit DescribeApiTrafficControlsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiIds) {
      res["ApiIds"] = boost::any(*apiIds);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (stageName) {
      res["StageName"] = boost::any(*stageName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiIds") != m.end() && !m["ApiIds"].empty()) {
      apiIds = make_shared<string>(boost::any_cast<string>(m["ApiIds"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("StageName") != m.end() && !m["StageName"].empty()) {
      stageName = make_shared<string>(boost::any_cast<string>(m["StageName"]));
    }
  }


  virtual ~DescribeApiTrafficControlsRequest() = default;
};
class DescribeApiTrafficControlsResponseBodyApiTrafficControlsApiTrafficControlItem : public Darabonba::Model {
public:
  shared_ptr<string> apiId{};
  shared_ptr<string> apiName{};
  shared_ptr<string> boundTime{};
  shared_ptr<string> trafficControlId{};
  shared_ptr<string> trafficControlName{};

  DescribeApiTrafficControlsResponseBodyApiTrafficControlsApiTrafficControlItem() {}

  explicit DescribeApiTrafficControlsResponseBodyApiTrafficControlsApiTrafficControlItem(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiId) {
      res["ApiId"] = boost::any(*apiId);
    }
    if (apiName) {
      res["ApiName"] = boost::any(*apiName);
    }
    if (boundTime) {
      res["BoundTime"] = boost::any(*boundTime);
    }
    if (trafficControlId) {
      res["TrafficControlId"] = boost::any(*trafficControlId);
    }
    if (trafficControlName) {
      res["TrafficControlName"] = boost::any(*trafficControlName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiId") != m.end() && !m["ApiId"].empty()) {
      apiId = make_shared<string>(boost::any_cast<string>(m["ApiId"]));
    }
    if (m.find("ApiName") != m.end() && !m["ApiName"].empty()) {
      apiName = make_shared<string>(boost::any_cast<string>(m["ApiName"]));
    }
    if (m.find("BoundTime") != m.end() && !m["BoundTime"].empty()) {
      boundTime = make_shared<string>(boost::any_cast<string>(m["BoundTime"]));
    }
    if (m.find("TrafficControlId") != m.end() && !m["TrafficControlId"].empty()) {
      trafficControlId = make_shared<string>(boost::any_cast<string>(m["TrafficControlId"]));
    }
    if (m.find("TrafficControlName") != m.end() && !m["TrafficControlName"].empty()) {
      trafficControlName = make_shared<string>(boost::any_cast<string>(m["TrafficControlName"]));
    }
  }


  virtual ~DescribeApiTrafficControlsResponseBodyApiTrafficControlsApiTrafficControlItem() = default;
};
class DescribeApiTrafficControlsResponseBodyApiTrafficControls : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeApiTrafficControlsResponseBodyApiTrafficControlsApiTrafficControlItem>> apiTrafficControlItem{};

  DescribeApiTrafficControlsResponseBodyApiTrafficControls() {}

  explicit DescribeApiTrafficControlsResponseBodyApiTrafficControls(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiTrafficControlItem) {
      vector<boost::any> temp1;
      for(auto item1:*apiTrafficControlItem){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ApiTrafficControlItem"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiTrafficControlItem") != m.end() && !m["ApiTrafficControlItem"].empty()) {
      if (typeid(vector<boost::any>) == m["ApiTrafficControlItem"].type()) {
        vector<DescribeApiTrafficControlsResponseBodyApiTrafficControlsApiTrafficControlItem> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ApiTrafficControlItem"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeApiTrafficControlsResponseBodyApiTrafficControlsApiTrafficControlItem model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        apiTrafficControlItem = make_shared<vector<DescribeApiTrafficControlsResponseBodyApiTrafficControlsApiTrafficControlItem>>(expect1);
      }
    }
  }


  virtual ~DescribeApiTrafficControlsResponseBodyApiTrafficControls() = default;
};
class DescribeApiTrafficControlsResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeApiTrafficControlsResponseBodyApiTrafficControls> apiTrafficControls{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeApiTrafficControlsResponseBody() {}

  explicit DescribeApiTrafficControlsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiTrafficControls) {
      res["ApiTrafficControls"] = apiTrafficControls ? boost::any(apiTrafficControls->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiTrafficControls") != m.end() && !m["ApiTrafficControls"].empty()) {
      if (typeid(map<string, boost::any>) == m["ApiTrafficControls"].type()) {
        DescribeApiTrafficControlsResponseBodyApiTrafficControls model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ApiTrafficControls"]));
        apiTrafficControls = make_shared<DescribeApiTrafficControlsResponseBodyApiTrafficControls>(model1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeApiTrafficControlsResponseBody() = default;
};
class DescribeApiTrafficControlsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeApiTrafficControlsResponseBody> body{};

  DescribeApiTrafficControlsResponse() {}

  explicit DescribeApiTrafficControlsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeApiTrafficControlsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeApiTrafficControlsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeApiTrafficControlsResponse() = default;
};
class DescribeApiTrafficDataRequest : public Darabonba::Model {
public:
  shared_ptr<string> apiId{};
  shared_ptr<string> endTime{};
  shared_ptr<string> groupId{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> stageName{};
  shared_ptr<string> startTime{};

  DescribeApiTrafficDataRequest() {}

  explicit DescribeApiTrafficDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiId) {
      res["ApiId"] = boost::any(*apiId);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (stageName) {
      res["StageName"] = boost::any(*stageName);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiId") != m.end() && !m["ApiId"].empty()) {
      apiId = make_shared<string>(boost::any_cast<string>(m["ApiId"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("StageName") != m.end() && !m["StageName"].empty()) {
      stageName = make_shared<string>(boost::any_cast<string>(m["StageName"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeApiTrafficDataRequest() = default;
};
class DescribeApiTrafficDataResponseBodyCallDownloadsMonitorItem : public Darabonba::Model {
public:
  shared_ptr<string> itemTime{};
  shared_ptr<string> itemValue{};

  DescribeApiTrafficDataResponseBodyCallDownloadsMonitorItem() {}

  explicit DescribeApiTrafficDataResponseBodyCallDownloadsMonitorItem(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (itemTime) {
      res["ItemTime"] = boost::any(*itemTime);
    }
    if (itemValue) {
      res["ItemValue"] = boost::any(*itemValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ItemTime") != m.end() && !m["ItemTime"].empty()) {
      itemTime = make_shared<string>(boost::any_cast<string>(m["ItemTime"]));
    }
    if (m.find("ItemValue") != m.end() && !m["ItemValue"].empty()) {
      itemValue = make_shared<string>(boost::any_cast<string>(m["ItemValue"]));
    }
  }


  virtual ~DescribeApiTrafficDataResponseBodyCallDownloadsMonitorItem() = default;
};
class DescribeApiTrafficDataResponseBodyCallDownloads : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeApiTrafficDataResponseBodyCallDownloadsMonitorItem>> monitorItem{};

  DescribeApiTrafficDataResponseBodyCallDownloads() {}

  explicit DescribeApiTrafficDataResponseBodyCallDownloads(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (monitorItem) {
      vector<boost::any> temp1;
      for(auto item1:*monitorItem){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["MonitorItem"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MonitorItem") != m.end() && !m["MonitorItem"].empty()) {
      if (typeid(vector<boost::any>) == m["MonitorItem"].type()) {
        vector<DescribeApiTrafficDataResponseBodyCallDownloadsMonitorItem> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["MonitorItem"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeApiTrafficDataResponseBodyCallDownloadsMonitorItem model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        monitorItem = make_shared<vector<DescribeApiTrafficDataResponseBodyCallDownloadsMonitorItem>>(expect1);
      }
    }
  }


  virtual ~DescribeApiTrafficDataResponseBodyCallDownloads() = default;
};
class DescribeApiTrafficDataResponseBodyCallUploadsMonitorItem : public Darabonba::Model {
public:
  shared_ptr<string> itemTime{};
  shared_ptr<string> itemValue{};

  DescribeApiTrafficDataResponseBodyCallUploadsMonitorItem() {}

  explicit DescribeApiTrafficDataResponseBodyCallUploadsMonitorItem(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (itemTime) {
      res["ItemTime"] = boost::any(*itemTime);
    }
    if (itemValue) {
      res["ItemValue"] = boost::any(*itemValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ItemTime") != m.end() && !m["ItemTime"].empty()) {
      itemTime = make_shared<string>(boost::any_cast<string>(m["ItemTime"]));
    }
    if (m.find("ItemValue") != m.end() && !m["ItemValue"].empty()) {
      itemValue = make_shared<string>(boost::any_cast<string>(m["ItemValue"]));
    }
  }


  virtual ~DescribeApiTrafficDataResponseBodyCallUploadsMonitorItem() = default;
};
class DescribeApiTrafficDataResponseBodyCallUploads : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeApiTrafficDataResponseBodyCallUploadsMonitorItem>> monitorItem{};

  DescribeApiTrafficDataResponseBodyCallUploads() {}

  explicit DescribeApiTrafficDataResponseBodyCallUploads(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (monitorItem) {
      vector<boost::any> temp1;
      for(auto item1:*monitorItem){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["MonitorItem"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MonitorItem") != m.end() && !m["MonitorItem"].empty()) {
      if (typeid(vector<boost::any>) == m["MonitorItem"].type()) {
        vector<DescribeApiTrafficDataResponseBodyCallUploadsMonitorItem> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["MonitorItem"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeApiTrafficDataResponseBodyCallUploadsMonitorItem model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        monitorItem = make_shared<vector<DescribeApiTrafficDataResponseBodyCallUploadsMonitorItem>>(expect1);
      }
    }
  }


  virtual ~DescribeApiTrafficDataResponseBodyCallUploads() = default;
};
class DescribeApiTrafficDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeApiTrafficDataResponseBodyCallDownloads> callDownloads{};
  shared_ptr<DescribeApiTrafficDataResponseBodyCallUploads> callUploads{};
  shared_ptr<string> requestId{};

  DescribeApiTrafficDataResponseBody() {}

  explicit DescribeApiTrafficDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callDownloads) {
      res["CallDownloads"] = callDownloads ? boost::any(callDownloads->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (callUploads) {
      res["CallUploads"] = callUploads ? boost::any(callUploads->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallDownloads") != m.end() && !m["CallDownloads"].empty()) {
      if (typeid(map<string, boost::any>) == m["CallDownloads"].type()) {
        DescribeApiTrafficDataResponseBodyCallDownloads model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CallDownloads"]));
        callDownloads = make_shared<DescribeApiTrafficDataResponseBodyCallDownloads>(model1);
      }
    }
    if (m.find("CallUploads") != m.end() && !m["CallUploads"].empty()) {
      if (typeid(map<string, boost::any>) == m["CallUploads"].type()) {
        DescribeApiTrafficDataResponseBodyCallUploads model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CallUploads"]));
        callUploads = make_shared<DescribeApiTrafficDataResponseBodyCallUploads>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeApiTrafficDataResponseBody() = default;
};
class DescribeApiTrafficDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeApiTrafficDataResponseBody> body{};

  DescribeApiTrafficDataResponse() {}

  explicit DescribeApiTrafficDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeApiTrafficDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeApiTrafficDataResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeApiTrafficDataResponse() = default;
};
class DescribeApisRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  DescribeApisRequestTag() {}

  explicit DescribeApisRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeApisRequestTag() = default;
};
class DescribeApisRequest : public Darabonba::Model {
public:
  shared_ptr<string> apiId{};
  shared_ptr<string> apiMethod{};
  shared_ptr<string> apiName{};
  shared_ptr<string> apiPath{};
  shared_ptr<string> catalogId{};
  shared_ptr<bool> enableTagAuth{};
  shared_ptr<string> groupId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> stageName{};
  shared_ptr<vector<DescribeApisRequestTag>> tag{};
  shared_ptr<bool> unDeployed{};
  shared_ptr<string> visibility{};

  DescribeApisRequest() {}

  explicit DescribeApisRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiId) {
      res["ApiId"] = boost::any(*apiId);
    }
    if (apiMethod) {
      res["ApiMethod"] = boost::any(*apiMethod);
    }
    if (apiName) {
      res["ApiName"] = boost::any(*apiName);
    }
    if (apiPath) {
      res["ApiPath"] = boost::any(*apiPath);
    }
    if (catalogId) {
      res["CatalogId"] = boost::any(*catalogId);
    }
    if (enableTagAuth) {
      res["EnableTagAuth"] = boost::any(*enableTagAuth);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (stageName) {
      res["StageName"] = boost::any(*stageName);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    if (unDeployed) {
      res["UnDeployed"] = boost::any(*unDeployed);
    }
    if (visibility) {
      res["Visibility"] = boost::any(*visibility);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiId") != m.end() && !m["ApiId"].empty()) {
      apiId = make_shared<string>(boost::any_cast<string>(m["ApiId"]));
    }
    if (m.find("ApiMethod") != m.end() && !m["ApiMethod"].empty()) {
      apiMethod = make_shared<string>(boost::any_cast<string>(m["ApiMethod"]));
    }
    if (m.find("ApiName") != m.end() && !m["ApiName"].empty()) {
      apiName = make_shared<string>(boost::any_cast<string>(m["ApiName"]));
    }
    if (m.find("ApiPath") != m.end() && !m["ApiPath"].empty()) {
      apiPath = make_shared<string>(boost::any_cast<string>(m["ApiPath"]));
    }
    if (m.find("CatalogId") != m.end() && !m["CatalogId"].empty()) {
      catalogId = make_shared<string>(boost::any_cast<string>(m["CatalogId"]));
    }
    if (m.find("EnableTagAuth") != m.end() && !m["EnableTagAuth"].empty()) {
      enableTagAuth = make_shared<bool>(boost::any_cast<bool>(m["EnableTagAuth"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("StageName") != m.end() && !m["StageName"].empty()) {
      stageName = make_shared<string>(boost::any_cast<string>(m["StageName"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<DescribeApisRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeApisRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<DescribeApisRequestTag>>(expect1);
      }
    }
    if (m.find("UnDeployed") != m.end() && !m["UnDeployed"].empty()) {
      unDeployed = make_shared<bool>(boost::any_cast<bool>(m["UnDeployed"]));
    }
    if (m.find("Visibility") != m.end() && !m["Visibility"].empty()) {
      visibility = make_shared<string>(boost::any_cast<string>(m["Visibility"]));
    }
  }


  virtual ~DescribeApisRequest() = default;
};
class DescribeApisResponseBodyApiSummarysApiSummaryDeployedInfosDeployedInfo : public Darabonba::Model {
public:
  shared_ptr<string> deployedStatus{};
  shared_ptr<string> effectiveVersion{};
  shared_ptr<string> stageName{};

  DescribeApisResponseBodyApiSummarysApiSummaryDeployedInfosDeployedInfo() {}

  explicit DescribeApisResponseBodyApiSummarysApiSummaryDeployedInfosDeployedInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deployedStatus) {
      res["DeployedStatus"] = boost::any(*deployedStatus);
    }
    if (effectiveVersion) {
      res["EffectiveVersion"] = boost::any(*effectiveVersion);
    }
    if (stageName) {
      res["StageName"] = boost::any(*stageName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeployedStatus") != m.end() && !m["DeployedStatus"].empty()) {
      deployedStatus = make_shared<string>(boost::any_cast<string>(m["DeployedStatus"]));
    }
    if (m.find("EffectiveVersion") != m.end() && !m["EffectiveVersion"].empty()) {
      effectiveVersion = make_shared<string>(boost::any_cast<string>(m["EffectiveVersion"]));
    }
    if (m.find("StageName") != m.end() && !m["StageName"].empty()) {
      stageName = make_shared<string>(boost::any_cast<string>(m["StageName"]));
    }
  }


  virtual ~DescribeApisResponseBodyApiSummarysApiSummaryDeployedInfosDeployedInfo() = default;
};
class DescribeApisResponseBodyApiSummarysApiSummaryDeployedInfos : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeApisResponseBodyApiSummarysApiSummaryDeployedInfosDeployedInfo>> deployedInfo{};

  DescribeApisResponseBodyApiSummarysApiSummaryDeployedInfos() {}

  explicit DescribeApisResponseBodyApiSummarysApiSummaryDeployedInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deployedInfo) {
      vector<boost::any> temp1;
      for(auto item1:*deployedInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DeployedInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeployedInfo") != m.end() && !m["DeployedInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["DeployedInfo"].type()) {
        vector<DescribeApisResponseBodyApiSummarysApiSummaryDeployedInfosDeployedInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DeployedInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeApisResponseBodyApiSummarysApiSummaryDeployedInfosDeployedInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        deployedInfo = make_shared<vector<DescribeApisResponseBodyApiSummarysApiSummaryDeployedInfosDeployedInfo>>(expect1);
      }
    }
  }


  virtual ~DescribeApisResponseBodyApiSummarysApiSummaryDeployedInfos() = default;
};
class DescribeApisResponseBodyApiSummarysApiSummaryTagListTag : public Darabonba::Model {
public:
  shared_ptr<string> tagKey{};
  shared_ptr<string> tagValue{};

  DescribeApisResponseBodyApiSummarysApiSummaryTagListTag() {}

  explicit DescribeApisResponseBodyApiSummarysApiSummaryTagListTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tagKey) {
      res["TagKey"] = boost::any(*tagKey);
    }
    if (tagValue) {
      res["TagValue"] = boost::any(*tagValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TagKey") != m.end() && !m["TagKey"].empty()) {
      tagKey = make_shared<string>(boost::any_cast<string>(m["TagKey"]));
    }
    if (m.find("TagValue") != m.end() && !m["TagValue"].empty()) {
      tagValue = make_shared<string>(boost::any_cast<string>(m["TagValue"]));
    }
  }


  virtual ~DescribeApisResponseBodyApiSummarysApiSummaryTagListTag() = default;
};
class DescribeApisResponseBodyApiSummarysApiSummaryTagList : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeApisResponseBodyApiSummarysApiSummaryTagListTag>> tag{};

  DescribeApisResponseBodyApiSummarysApiSummaryTagList() {}

  explicit DescribeApisResponseBodyApiSummarysApiSummaryTagList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<DescribeApisResponseBodyApiSummarysApiSummaryTagListTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeApisResponseBodyApiSummarysApiSummaryTagListTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<DescribeApisResponseBodyApiSummarysApiSummaryTagListTag>>(expect1);
      }
    }
  }


  virtual ~DescribeApisResponseBodyApiSummarysApiSummaryTagList() = default;
};
class DescribeApisResponseBodyApiSummarysApiSummary : public Darabonba::Model {
public:
  shared_ptr<string> apiId{};
  shared_ptr<string> apiMethod{};
  shared_ptr<string> apiName{};
  shared_ptr<string> apiPath{};
  shared_ptr<string> createdTime{};
  shared_ptr<DescribeApisResponseBodyApiSummarysApiSummaryDeployedInfos> deployedInfos{};
  shared_ptr<string> description{};
  shared_ptr<string> groupId{};
  shared_ptr<string> groupName{};
  shared_ptr<string> modifiedTime{};
  shared_ptr<string> regionId{};
  shared_ptr<DescribeApisResponseBodyApiSummarysApiSummaryTagList> tagList{};
  shared_ptr<string> visibility{};

  DescribeApisResponseBodyApiSummarysApiSummary() {}

  explicit DescribeApisResponseBodyApiSummarysApiSummary(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiId) {
      res["ApiId"] = boost::any(*apiId);
    }
    if (apiMethod) {
      res["ApiMethod"] = boost::any(*apiMethod);
    }
    if (apiName) {
      res["ApiName"] = boost::any(*apiName);
    }
    if (apiPath) {
      res["ApiPath"] = boost::any(*apiPath);
    }
    if (createdTime) {
      res["CreatedTime"] = boost::any(*createdTime);
    }
    if (deployedInfos) {
      res["DeployedInfos"] = deployedInfos ? boost::any(deployedInfos->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (modifiedTime) {
      res["ModifiedTime"] = boost::any(*modifiedTime);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (tagList) {
      res["TagList"] = tagList ? boost::any(tagList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (visibility) {
      res["Visibility"] = boost::any(*visibility);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiId") != m.end() && !m["ApiId"].empty()) {
      apiId = make_shared<string>(boost::any_cast<string>(m["ApiId"]));
    }
    if (m.find("ApiMethod") != m.end() && !m["ApiMethod"].empty()) {
      apiMethod = make_shared<string>(boost::any_cast<string>(m["ApiMethod"]));
    }
    if (m.find("ApiName") != m.end() && !m["ApiName"].empty()) {
      apiName = make_shared<string>(boost::any_cast<string>(m["ApiName"]));
    }
    if (m.find("ApiPath") != m.end() && !m["ApiPath"].empty()) {
      apiPath = make_shared<string>(boost::any_cast<string>(m["ApiPath"]));
    }
    if (m.find("CreatedTime") != m.end() && !m["CreatedTime"].empty()) {
      createdTime = make_shared<string>(boost::any_cast<string>(m["CreatedTime"]));
    }
    if (m.find("DeployedInfos") != m.end() && !m["DeployedInfos"].empty()) {
      if (typeid(map<string, boost::any>) == m["DeployedInfos"].type()) {
        DescribeApisResponseBodyApiSummarysApiSummaryDeployedInfos model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DeployedInfos"]));
        deployedInfos = make_shared<DescribeApisResponseBodyApiSummarysApiSummaryDeployedInfos>(model1);
      }
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("ModifiedTime") != m.end() && !m["ModifiedTime"].empty()) {
      modifiedTime = make_shared<string>(boost::any_cast<string>(m["ModifiedTime"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("TagList") != m.end() && !m["TagList"].empty()) {
      if (typeid(map<string, boost::any>) == m["TagList"].type()) {
        DescribeApisResponseBodyApiSummarysApiSummaryTagList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TagList"]));
        tagList = make_shared<DescribeApisResponseBodyApiSummarysApiSummaryTagList>(model1);
      }
    }
    if (m.find("Visibility") != m.end() && !m["Visibility"].empty()) {
      visibility = make_shared<string>(boost::any_cast<string>(m["Visibility"]));
    }
  }


  virtual ~DescribeApisResponseBodyApiSummarysApiSummary() = default;
};
class DescribeApisResponseBodyApiSummarys : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeApisResponseBodyApiSummarysApiSummary>> apiSummary{};

  DescribeApisResponseBodyApiSummarys() {}

  explicit DescribeApisResponseBodyApiSummarys(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiSummary) {
      vector<boost::any> temp1;
      for(auto item1:*apiSummary){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ApiSummary"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiSummary") != m.end() && !m["ApiSummary"].empty()) {
      if (typeid(vector<boost::any>) == m["ApiSummary"].type()) {
        vector<DescribeApisResponseBodyApiSummarysApiSummary> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ApiSummary"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeApisResponseBodyApiSummarysApiSummary model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        apiSummary = make_shared<vector<DescribeApisResponseBodyApiSummarysApiSummary>>(expect1);
      }
    }
  }


  virtual ~DescribeApisResponseBodyApiSummarys() = default;
};
class DescribeApisResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeApisResponseBodyApiSummarys> apiSummarys{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeApisResponseBody() {}

  explicit DescribeApisResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiSummarys) {
      res["ApiSummarys"] = apiSummarys ? boost::any(apiSummarys->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiSummarys") != m.end() && !m["ApiSummarys"].empty()) {
      if (typeid(map<string, boost::any>) == m["ApiSummarys"].type()) {
        DescribeApisResponseBodyApiSummarys model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ApiSummarys"]));
        apiSummarys = make_shared<DescribeApisResponseBodyApiSummarys>(model1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeApisResponseBody() = default;
};
class DescribeApisResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeApisResponseBody> body{};

  DescribeApisResponse() {}

  explicit DescribeApisResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeApisResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeApisResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeApisResponse() = default;
};
class DescribeApisByAppRequest : public Darabonba::Model {
public:
  shared_ptr<string> apiName{};
  shared_ptr<string> apiUid{};
  shared_ptr<long> appId{};
  shared_ptr<string> description{};
  shared_ptr<string> method{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> path{};
  shared_ptr<string> securityToken{};

  DescribeApisByAppRequest() {}

  explicit DescribeApisByAppRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiName) {
      res["ApiName"] = boost::any(*apiName);
    }
    if (apiUid) {
      res["ApiUid"] = boost::any(*apiUid);
    }
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (method) {
      res["Method"] = boost::any(*method);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (path) {
      res["Path"] = boost::any(*path);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiName") != m.end() && !m["ApiName"].empty()) {
      apiName = make_shared<string>(boost::any_cast<string>(m["ApiName"]));
    }
    if (m.find("ApiUid") != m.end() && !m["ApiUid"].empty()) {
      apiUid = make_shared<string>(boost::any_cast<string>(m["ApiUid"]));
    }
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<long>(boost::any_cast<long>(m["AppId"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Method") != m.end() && !m["Method"].empty()) {
      method = make_shared<string>(boost::any_cast<string>(m["Method"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Path") != m.end() && !m["Path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["Path"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~DescribeApisByAppRequest() = default;
};
class DescribeApisByAppResponseBodyAppApiRelationInfosAppApiRelationInfo : public Darabonba::Model {
public:
  shared_ptr<string> apiId{};
  shared_ptr<string> apiName{};
  shared_ptr<string> authVaildTime{};
  shared_ptr<string> authorizationSource{};
  shared_ptr<string> createdTime{};
  shared_ptr<string> description{};
  shared_ptr<string> groupId{};
  shared_ptr<string> groupName{};
  shared_ptr<string> method{};
  shared_ptr<string> operator_{};
  shared_ptr<string> path{};
  shared_ptr<string> regionId{};
  shared_ptr<string> stageAlias{};
  shared_ptr<string> stageName{};

  DescribeApisByAppResponseBodyAppApiRelationInfosAppApiRelationInfo() {}

  explicit DescribeApisByAppResponseBodyAppApiRelationInfosAppApiRelationInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiId) {
      res["ApiId"] = boost::any(*apiId);
    }
    if (apiName) {
      res["ApiName"] = boost::any(*apiName);
    }
    if (authVaildTime) {
      res["AuthVaildTime"] = boost::any(*authVaildTime);
    }
    if (authorizationSource) {
      res["AuthorizationSource"] = boost::any(*authorizationSource);
    }
    if (createdTime) {
      res["CreatedTime"] = boost::any(*createdTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (method) {
      res["Method"] = boost::any(*method);
    }
    if (operator_) {
      res["Operator"] = boost::any(*operator_);
    }
    if (path) {
      res["Path"] = boost::any(*path);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (stageAlias) {
      res["StageAlias"] = boost::any(*stageAlias);
    }
    if (stageName) {
      res["StageName"] = boost::any(*stageName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiId") != m.end() && !m["ApiId"].empty()) {
      apiId = make_shared<string>(boost::any_cast<string>(m["ApiId"]));
    }
    if (m.find("ApiName") != m.end() && !m["ApiName"].empty()) {
      apiName = make_shared<string>(boost::any_cast<string>(m["ApiName"]));
    }
    if (m.find("AuthVaildTime") != m.end() && !m["AuthVaildTime"].empty()) {
      authVaildTime = make_shared<string>(boost::any_cast<string>(m["AuthVaildTime"]));
    }
    if (m.find("AuthorizationSource") != m.end() && !m["AuthorizationSource"].empty()) {
      authorizationSource = make_shared<string>(boost::any_cast<string>(m["AuthorizationSource"]));
    }
    if (m.find("CreatedTime") != m.end() && !m["CreatedTime"].empty()) {
      createdTime = make_shared<string>(boost::any_cast<string>(m["CreatedTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("Method") != m.end() && !m["Method"].empty()) {
      method = make_shared<string>(boost::any_cast<string>(m["Method"]));
    }
    if (m.find("Operator") != m.end() && !m["Operator"].empty()) {
      operator_ = make_shared<string>(boost::any_cast<string>(m["Operator"]));
    }
    if (m.find("Path") != m.end() && !m["Path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["Path"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("StageAlias") != m.end() && !m["StageAlias"].empty()) {
      stageAlias = make_shared<string>(boost::any_cast<string>(m["StageAlias"]));
    }
    if (m.find("StageName") != m.end() && !m["StageName"].empty()) {
      stageName = make_shared<string>(boost::any_cast<string>(m["StageName"]));
    }
  }


  virtual ~DescribeApisByAppResponseBodyAppApiRelationInfosAppApiRelationInfo() = default;
};
class DescribeApisByAppResponseBodyAppApiRelationInfos : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeApisByAppResponseBodyAppApiRelationInfosAppApiRelationInfo>> appApiRelationInfo{};

  DescribeApisByAppResponseBodyAppApiRelationInfos() {}

  explicit DescribeApisByAppResponseBodyAppApiRelationInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appApiRelationInfo) {
      vector<boost::any> temp1;
      for(auto item1:*appApiRelationInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AppApiRelationInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppApiRelationInfo") != m.end() && !m["AppApiRelationInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["AppApiRelationInfo"].type()) {
        vector<DescribeApisByAppResponseBodyAppApiRelationInfosAppApiRelationInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AppApiRelationInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeApisByAppResponseBodyAppApiRelationInfosAppApiRelationInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        appApiRelationInfo = make_shared<vector<DescribeApisByAppResponseBodyAppApiRelationInfosAppApiRelationInfo>>(expect1);
      }
    }
  }


  virtual ~DescribeApisByAppResponseBodyAppApiRelationInfos() = default;
};
class DescribeApisByAppResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeApisByAppResponseBodyAppApiRelationInfos> appApiRelationInfos{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeApisByAppResponseBody() {}

  explicit DescribeApisByAppResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appApiRelationInfos) {
      res["AppApiRelationInfos"] = appApiRelationInfos ? boost::any(appApiRelationInfos->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppApiRelationInfos") != m.end() && !m["AppApiRelationInfos"].empty()) {
      if (typeid(map<string, boost::any>) == m["AppApiRelationInfos"].type()) {
        DescribeApisByAppResponseBodyAppApiRelationInfos model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AppApiRelationInfos"]));
        appApiRelationInfos = make_shared<DescribeApisByAppResponseBodyAppApiRelationInfos>(model1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeApisByAppResponseBody() = default;
};
class DescribeApisByAppResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeApisByAppResponseBody> body{};

  DescribeApisByAppResponse() {}

  explicit DescribeApisByAppResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeApisByAppResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeApisByAppResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeApisByAppResponse() = default;
};
class DescribeApisByBackendRequest : public Darabonba::Model {
public:
  shared_ptr<string> backendId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> stageName{};

  DescribeApisByBackendRequest() {}

  explicit DescribeApisByBackendRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (backendId) {
      res["BackendId"] = boost::any(*backendId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (stageName) {
      res["StageName"] = boost::any(*stageName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BackendId") != m.end() && !m["BackendId"].empty()) {
      backendId = make_shared<string>(boost::any_cast<string>(m["BackendId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("StageName") != m.end() && !m["StageName"].empty()) {
      stageName = make_shared<string>(boost::any_cast<string>(m["StageName"]));
    }
  }


  virtual ~DescribeApisByBackendRequest() = default;
};
class DescribeApisByBackendResponseBodyApiInfoListApiInfo : public Darabonba::Model {
public:
  shared_ptr<string> apiId{};
  shared_ptr<string> apiName{};
  shared_ptr<string> description{};
  shared_ptr<string> groupId{};
  shared_ptr<string> groupName{};
  shared_ptr<string> method{};
  shared_ptr<string> path{};

  DescribeApisByBackendResponseBodyApiInfoListApiInfo() {}

  explicit DescribeApisByBackendResponseBodyApiInfoListApiInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiId) {
      res["ApiId"] = boost::any(*apiId);
    }
    if (apiName) {
      res["ApiName"] = boost::any(*apiName);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (method) {
      res["Method"] = boost::any(*method);
    }
    if (path) {
      res["Path"] = boost::any(*path);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiId") != m.end() && !m["ApiId"].empty()) {
      apiId = make_shared<string>(boost::any_cast<string>(m["ApiId"]));
    }
    if (m.find("ApiName") != m.end() && !m["ApiName"].empty()) {
      apiName = make_shared<string>(boost::any_cast<string>(m["ApiName"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("Method") != m.end() && !m["Method"].empty()) {
      method = make_shared<string>(boost::any_cast<string>(m["Method"]));
    }
    if (m.find("Path") != m.end() && !m["Path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["Path"]));
    }
  }


  virtual ~DescribeApisByBackendResponseBodyApiInfoListApiInfo() = default;
};
class DescribeApisByBackendResponseBodyApiInfoList : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeApisByBackendResponseBodyApiInfoListApiInfo>> apiInfo{};

  DescribeApisByBackendResponseBodyApiInfoList() {}

  explicit DescribeApisByBackendResponseBodyApiInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiInfo) {
      vector<boost::any> temp1;
      for(auto item1:*apiInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ApiInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiInfo") != m.end() && !m["ApiInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["ApiInfo"].type()) {
        vector<DescribeApisByBackendResponseBodyApiInfoListApiInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ApiInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeApisByBackendResponseBodyApiInfoListApiInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        apiInfo = make_shared<vector<DescribeApisByBackendResponseBodyApiInfoListApiInfo>>(expect1);
      }
    }
  }


  virtual ~DescribeApisByBackendResponseBodyApiInfoList() = default;
};
class DescribeApisByBackendResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeApisByBackendResponseBodyApiInfoList> apiInfoList{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeApisByBackendResponseBody() {}

  explicit DescribeApisByBackendResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiInfoList) {
      res["ApiInfoList"] = apiInfoList ? boost::any(apiInfoList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiInfoList") != m.end() && !m["ApiInfoList"].empty()) {
      if (typeid(map<string, boost::any>) == m["ApiInfoList"].type()) {
        DescribeApisByBackendResponseBodyApiInfoList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ApiInfoList"]));
        apiInfoList = make_shared<DescribeApisByBackendResponseBodyApiInfoList>(model1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeApisByBackendResponseBody() = default;
};
class DescribeApisByBackendResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeApisByBackendResponseBody> body{};

  DescribeApisByBackendResponse() {}

  explicit DescribeApisByBackendResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeApisByBackendResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeApisByBackendResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeApisByBackendResponse() = default;
};
class DescribeApisByIpControlRequest : public Darabonba::Model {
public:
  shared_ptr<string> ipControlId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> securityToken{};

  DescribeApisByIpControlRequest() {}

  explicit DescribeApisByIpControlRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ipControlId) {
      res["IpControlId"] = boost::any(*ipControlId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IpControlId") != m.end() && !m["IpControlId"].empty()) {
      ipControlId = make_shared<string>(boost::any_cast<string>(m["IpControlId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~DescribeApisByIpControlRequest() = default;
};
class DescribeApisByIpControlResponseBodyApiInfosApiInfo : public Darabonba::Model {
public:
  shared_ptr<string> apiId{};
  shared_ptr<string> apiName{};
  shared_ptr<string> boundTime{};
  shared_ptr<string> description{};
  shared_ptr<string> groupId{};
  shared_ptr<string> groupName{};
  shared_ptr<string> regionId{};
  shared_ptr<string> stageName{};
  shared_ptr<string> visibility{};

  DescribeApisByIpControlResponseBodyApiInfosApiInfo() {}

  explicit DescribeApisByIpControlResponseBodyApiInfosApiInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiId) {
      res["ApiId"] = boost::any(*apiId);
    }
    if (apiName) {
      res["ApiName"] = boost::any(*apiName);
    }
    if (boundTime) {
      res["BoundTime"] = boost::any(*boundTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (stageName) {
      res["StageName"] = boost::any(*stageName);
    }
    if (visibility) {
      res["Visibility"] = boost::any(*visibility);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiId") != m.end() && !m["ApiId"].empty()) {
      apiId = make_shared<string>(boost::any_cast<string>(m["ApiId"]));
    }
    if (m.find("ApiName") != m.end() && !m["ApiName"].empty()) {
      apiName = make_shared<string>(boost::any_cast<string>(m["ApiName"]));
    }
    if (m.find("BoundTime") != m.end() && !m["BoundTime"].empty()) {
      boundTime = make_shared<string>(boost::any_cast<string>(m["BoundTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("StageName") != m.end() && !m["StageName"].empty()) {
      stageName = make_shared<string>(boost::any_cast<string>(m["StageName"]));
    }
    if (m.find("Visibility") != m.end() && !m["Visibility"].empty()) {
      visibility = make_shared<string>(boost::any_cast<string>(m["Visibility"]));
    }
  }


  virtual ~DescribeApisByIpControlResponseBodyApiInfosApiInfo() = default;
};
class DescribeApisByIpControlResponseBodyApiInfos : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeApisByIpControlResponseBodyApiInfosApiInfo>> apiInfo{};

  DescribeApisByIpControlResponseBodyApiInfos() {}

  explicit DescribeApisByIpControlResponseBodyApiInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiInfo) {
      vector<boost::any> temp1;
      for(auto item1:*apiInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ApiInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiInfo") != m.end() && !m["ApiInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["ApiInfo"].type()) {
        vector<DescribeApisByIpControlResponseBodyApiInfosApiInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ApiInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeApisByIpControlResponseBodyApiInfosApiInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        apiInfo = make_shared<vector<DescribeApisByIpControlResponseBodyApiInfosApiInfo>>(expect1);
      }
    }
  }


  virtual ~DescribeApisByIpControlResponseBodyApiInfos() = default;
};
class DescribeApisByIpControlResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeApisByIpControlResponseBodyApiInfos> apiInfos{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeApisByIpControlResponseBody() {}

  explicit DescribeApisByIpControlResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiInfos) {
      res["ApiInfos"] = apiInfos ? boost::any(apiInfos->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiInfos") != m.end() && !m["ApiInfos"].empty()) {
      if (typeid(map<string, boost::any>) == m["ApiInfos"].type()) {
        DescribeApisByIpControlResponseBodyApiInfos model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ApiInfos"]));
        apiInfos = make_shared<DescribeApisByIpControlResponseBodyApiInfos>(model1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeApisByIpControlResponseBody() = default;
};
class DescribeApisByIpControlResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeApisByIpControlResponseBody> body{};

  DescribeApisByIpControlResponse() {}

  explicit DescribeApisByIpControlResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeApisByIpControlResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeApisByIpControlResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeApisByIpControlResponse() = default;
};
class DescribeApisBySignatureRequest : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> signatureId{};

  DescribeApisBySignatureRequest() {}

  explicit DescribeApisBySignatureRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (signatureId) {
      res["SignatureId"] = boost::any(*signatureId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("SignatureId") != m.end() && !m["SignatureId"].empty()) {
      signatureId = make_shared<string>(boost::any_cast<string>(m["SignatureId"]));
    }
  }


  virtual ~DescribeApisBySignatureRequest() = default;
};
class DescribeApisBySignatureResponseBodyApiInfosApiInfo : public Darabonba::Model {
public:
  shared_ptr<string> apiId{};
  shared_ptr<string> apiName{};
  shared_ptr<string> boundTime{};
  shared_ptr<string> description{};
  shared_ptr<string> groupId{};
  shared_ptr<string> groupName{};
  shared_ptr<string> regionId{};
  shared_ptr<string> stageName{};
  shared_ptr<string> visibility{};

  DescribeApisBySignatureResponseBodyApiInfosApiInfo() {}

  explicit DescribeApisBySignatureResponseBodyApiInfosApiInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiId) {
      res["ApiId"] = boost::any(*apiId);
    }
    if (apiName) {
      res["ApiName"] = boost::any(*apiName);
    }
    if (boundTime) {
      res["BoundTime"] = boost::any(*boundTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (stageName) {
      res["StageName"] = boost::any(*stageName);
    }
    if (visibility) {
      res["Visibility"] = boost::any(*visibility);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiId") != m.end() && !m["ApiId"].empty()) {
      apiId = make_shared<string>(boost::any_cast<string>(m["ApiId"]));
    }
    if (m.find("ApiName") != m.end() && !m["ApiName"].empty()) {
      apiName = make_shared<string>(boost::any_cast<string>(m["ApiName"]));
    }
    if (m.find("BoundTime") != m.end() && !m["BoundTime"].empty()) {
      boundTime = make_shared<string>(boost::any_cast<string>(m["BoundTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("StageName") != m.end() && !m["StageName"].empty()) {
      stageName = make_shared<string>(boost::any_cast<string>(m["StageName"]));
    }
    if (m.find("Visibility") != m.end() && !m["Visibility"].empty()) {
      visibility = make_shared<string>(boost::any_cast<string>(m["Visibility"]));
    }
  }


  virtual ~DescribeApisBySignatureResponseBodyApiInfosApiInfo() = default;
};
class DescribeApisBySignatureResponseBodyApiInfos : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeApisBySignatureResponseBodyApiInfosApiInfo>> apiInfo{};

  DescribeApisBySignatureResponseBodyApiInfos() {}

  explicit DescribeApisBySignatureResponseBodyApiInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiInfo) {
      vector<boost::any> temp1;
      for(auto item1:*apiInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ApiInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiInfo") != m.end() && !m["ApiInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["ApiInfo"].type()) {
        vector<DescribeApisBySignatureResponseBodyApiInfosApiInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ApiInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeApisBySignatureResponseBodyApiInfosApiInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        apiInfo = make_shared<vector<DescribeApisBySignatureResponseBodyApiInfosApiInfo>>(expect1);
      }
    }
  }


  virtual ~DescribeApisBySignatureResponseBodyApiInfos() = default;
};
class DescribeApisBySignatureResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeApisBySignatureResponseBodyApiInfos> apiInfos{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeApisBySignatureResponseBody() {}

  explicit DescribeApisBySignatureResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiInfos) {
      res["ApiInfos"] = apiInfos ? boost::any(apiInfos->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiInfos") != m.end() && !m["ApiInfos"].empty()) {
      if (typeid(map<string, boost::any>) == m["ApiInfos"].type()) {
        DescribeApisBySignatureResponseBodyApiInfos model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ApiInfos"]));
        apiInfos = make_shared<DescribeApisBySignatureResponseBodyApiInfos>(model1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeApisBySignatureResponseBody() = default;
};
class DescribeApisBySignatureResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeApisBySignatureResponseBody> body{};

  DescribeApisBySignatureResponse() {}

  explicit DescribeApisBySignatureResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeApisBySignatureResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeApisBySignatureResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeApisBySignatureResponse() = default;
};
class DescribeApisByTrafficControlRequest : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> trafficControlId{};

  DescribeApisByTrafficControlRequest() {}

  explicit DescribeApisByTrafficControlRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (trafficControlId) {
      res["TrafficControlId"] = boost::any(*trafficControlId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("TrafficControlId") != m.end() && !m["TrafficControlId"].empty()) {
      trafficControlId = make_shared<string>(boost::any_cast<string>(m["TrafficControlId"]));
    }
  }


  virtual ~DescribeApisByTrafficControlRequest() = default;
};
class DescribeApisByTrafficControlResponseBodyApiInfosApiInfo : public Darabonba::Model {
public:
  shared_ptr<string> apiId{};
  shared_ptr<string> apiName{};
  shared_ptr<string> boundTime{};
  shared_ptr<string> description{};
  shared_ptr<string> groupId{};
  shared_ptr<string> groupName{};
  shared_ptr<string> regionId{};
  shared_ptr<string> stageName{};
  shared_ptr<string> visibility{};

  DescribeApisByTrafficControlResponseBodyApiInfosApiInfo() {}

  explicit DescribeApisByTrafficControlResponseBodyApiInfosApiInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiId) {
      res["ApiId"] = boost::any(*apiId);
    }
    if (apiName) {
      res["ApiName"] = boost::any(*apiName);
    }
    if (boundTime) {
      res["BoundTime"] = boost::any(*boundTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (stageName) {
      res["StageName"] = boost::any(*stageName);
    }
    if (visibility) {
      res["Visibility"] = boost::any(*visibility);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiId") != m.end() && !m["ApiId"].empty()) {
      apiId = make_shared<string>(boost::any_cast<string>(m["ApiId"]));
    }
    if (m.find("ApiName") != m.end() && !m["ApiName"].empty()) {
      apiName = make_shared<string>(boost::any_cast<string>(m["ApiName"]));
    }
    if (m.find("BoundTime") != m.end() && !m["BoundTime"].empty()) {
      boundTime = make_shared<string>(boost::any_cast<string>(m["BoundTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("StageName") != m.end() && !m["StageName"].empty()) {
      stageName = make_shared<string>(boost::any_cast<string>(m["StageName"]));
    }
    if (m.find("Visibility") != m.end() && !m["Visibility"].empty()) {
      visibility = make_shared<string>(boost::any_cast<string>(m["Visibility"]));
    }
  }


  virtual ~DescribeApisByTrafficControlResponseBodyApiInfosApiInfo() = default;
};
class DescribeApisByTrafficControlResponseBodyApiInfos : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeApisByTrafficControlResponseBodyApiInfosApiInfo>> apiInfo{};

  DescribeApisByTrafficControlResponseBodyApiInfos() {}

  explicit DescribeApisByTrafficControlResponseBodyApiInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiInfo) {
      vector<boost::any> temp1;
      for(auto item1:*apiInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ApiInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiInfo") != m.end() && !m["ApiInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["ApiInfo"].type()) {
        vector<DescribeApisByTrafficControlResponseBodyApiInfosApiInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ApiInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeApisByTrafficControlResponseBodyApiInfosApiInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        apiInfo = make_shared<vector<DescribeApisByTrafficControlResponseBodyApiInfosApiInfo>>(expect1);
      }
    }
  }


  virtual ~DescribeApisByTrafficControlResponseBodyApiInfos() = default;
};
class DescribeApisByTrafficControlResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeApisByTrafficControlResponseBodyApiInfos> apiInfos{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeApisByTrafficControlResponseBody() {}

  explicit DescribeApisByTrafficControlResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiInfos) {
      res["ApiInfos"] = apiInfos ? boost::any(apiInfos->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiInfos") != m.end() && !m["ApiInfos"].empty()) {
      if (typeid(map<string, boost::any>) == m["ApiInfos"].type()) {
        DescribeApisByTrafficControlResponseBodyApiInfos model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ApiInfos"]));
        apiInfos = make_shared<DescribeApisByTrafficControlResponseBodyApiInfos>(model1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeApisByTrafficControlResponseBody() = default;
};
class DescribeApisByTrafficControlResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeApisByTrafficControlResponseBody> body{};

  DescribeApisByTrafficControlResponse() {}

  explicit DescribeApisByTrafficControlResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeApisByTrafficControlResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeApisByTrafficControlResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeApisByTrafficControlResponse() = default;
};
class DescribeApisByVpcAccessRequest : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> vpcName{};

  DescribeApisByVpcAccessRequest() {}

  explicit DescribeApisByVpcAccessRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (vpcName) {
      res["VpcName"] = boost::any(*vpcName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("VpcName") != m.end() && !m["VpcName"].empty()) {
      vpcName = make_shared<string>(boost::any_cast<string>(m["VpcName"]));
    }
  }


  virtual ~DescribeApisByVpcAccessRequest() = default;
};
class DescribeApisByVpcAccessResponseBodyApiVpcAccessInfosApiVpcAccessInfo : public Darabonba::Model {
public:
  shared_ptr<string> apiId{};
  shared_ptr<string> apiName{};
  shared_ptr<string> description{};
  shared_ptr<string> groupId{};
  shared_ptr<string> groupName{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> method{};
  shared_ptr<string> path{};
  shared_ptr<long> port{};
  shared_ptr<string> regionId{};
  shared_ptr<string> stageId{};
  shared_ptr<string> stageName{};
  shared_ptr<string> vpcId{};
  shared_ptr<string> vpcName{};

  DescribeApisByVpcAccessResponseBodyApiVpcAccessInfosApiVpcAccessInfo() {}

  explicit DescribeApisByVpcAccessResponseBodyApiVpcAccessInfosApiVpcAccessInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiId) {
      res["ApiId"] = boost::any(*apiId);
    }
    if (apiName) {
      res["ApiName"] = boost::any(*apiName);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (method) {
      res["Method"] = boost::any(*method);
    }
    if (path) {
      res["Path"] = boost::any(*path);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (stageId) {
      res["StageId"] = boost::any(*stageId);
    }
    if (stageName) {
      res["StageName"] = boost::any(*stageName);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    if (vpcName) {
      res["VpcName"] = boost::any(*vpcName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiId") != m.end() && !m["ApiId"].empty()) {
      apiId = make_shared<string>(boost::any_cast<string>(m["ApiId"]));
    }
    if (m.find("ApiName") != m.end() && !m["ApiName"].empty()) {
      apiName = make_shared<string>(boost::any_cast<string>(m["ApiName"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Method") != m.end() && !m["Method"].empty()) {
      method = make_shared<string>(boost::any_cast<string>(m["Method"]));
    }
    if (m.find("Path") != m.end() && !m["Path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["Path"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<long>(boost::any_cast<long>(m["Port"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("StageId") != m.end() && !m["StageId"].empty()) {
      stageId = make_shared<string>(boost::any_cast<string>(m["StageId"]));
    }
    if (m.find("StageName") != m.end() && !m["StageName"].empty()) {
      stageName = make_shared<string>(boost::any_cast<string>(m["StageName"]));
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
    if (m.find("VpcName") != m.end() && !m["VpcName"].empty()) {
      vpcName = make_shared<string>(boost::any_cast<string>(m["VpcName"]));
    }
  }


  virtual ~DescribeApisByVpcAccessResponseBodyApiVpcAccessInfosApiVpcAccessInfo() = default;
};
class DescribeApisByVpcAccessResponseBodyApiVpcAccessInfos : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeApisByVpcAccessResponseBodyApiVpcAccessInfosApiVpcAccessInfo>> apiVpcAccessInfo{};

  DescribeApisByVpcAccessResponseBodyApiVpcAccessInfos() {}

  explicit DescribeApisByVpcAccessResponseBodyApiVpcAccessInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiVpcAccessInfo) {
      vector<boost::any> temp1;
      for(auto item1:*apiVpcAccessInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ApiVpcAccessInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiVpcAccessInfo") != m.end() && !m["ApiVpcAccessInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["ApiVpcAccessInfo"].type()) {
        vector<DescribeApisByVpcAccessResponseBodyApiVpcAccessInfosApiVpcAccessInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ApiVpcAccessInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeApisByVpcAccessResponseBodyApiVpcAccessInfosApiVpcAccessInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        apiVpcAccessInfo = make_shared<vector<DescribeApisByVpcAccessResponseBodyApiVpcAccessInfosApiVpcAccessInfo>>(expect1);
      }
    }
  }


  virtual ~DescribeApisByVpcAccessResponseBodyApiVpcAccessInfos() = default;
};
class DescribeApisByVpcAccessResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeApisByVpcAccessResponseBodyApiVpcAccessInfos> apiVpcAccessInfos{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeApisByVpcAccessResponseBody() {}

  explicit DescribeApisByVpcAccessResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiVpcAccessInfos) {
      res["ApiVpcAccessInfos"] = apiVpcAccessInfos ? boost::any(apiVpcAccessInfos->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiVpcAccessInfos") != m.end() && !m["ApiVpcAccessInfos"].empty()) {
      if (typeid(map<string, boost::any>) == m["ApiVpcAccessInfos"].type()) {
        DescribeApisByVpcAccessResponseBodyApiVpcAccessInfos model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ApiVpcAccessInfos"]));
        apiVpcAccessInfos = make_shared<DescribeApisByVpcAccessResponseBodyApiVpcAccessInfos>(model1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeApisByVpcAccessResponseBody() = default;
};
class DescribeApisByVpcAccessResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeApisByVpcAccessResponseBody> body{};

  DescribeApisByVpcAccessResponse() {}

  explicit DescribeApisByVpcAccessResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeApisByVpcAccessResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeApisByVpcAccessResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeApisByVpcAccessResponse() = default;
};
class DescribeApisWithStageNameIntegratedByAppRequest : public Darabonba::Model {
public:
  shared_ptr<string> apiName{};
  shared_ptr<string> apiUid{};
  shared_ptr<long> appId{};
  shared_ptr<string> description{};
  shared_ptr<string> method{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> path{};
  shared_ptr<string> securityToken{};

  DescribeApisWithStageNameIntegratedByAppRequest() {}

  explicit DescribeApisWithStageNameIntegratedByAppRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiName) {
      res["ApiName"] = boost::any(*apiName);
    }
    if (apiUid) {
      res["ApiUid"] = boost::any(*apiUid);
    }
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (method) {
      res["Method"] = boost::any(*method);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (path) {
      res["Path"] = boost::any(*path);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiName") != m.end() && !m["ApiName"].empty()) {
      apiName = make_shared<string>(boost::any_cast<string>(m["ApiName"]));
    }
    if (m.find("ApiUid") != m.end() && !m["ApiUid"].empty()) {
      apiUid = make_shared<string>(boost::any_cast<string>(m["ApiUid"]));
    }
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<long>(boost::any_cast<long>(m["AppId"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Method") != m.end() && !m["Method"].empty()) {
      method = make_shared<string>(boost::any_cast<string>(m["Method"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Path") != m.end() && !m["Path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["Path"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~DescribeApisWithStageNameIntegratedByAppRequest() = default;
};
class DescribeApisWithStageNameIntegratedByAppResponseBodyAppApiRelationInfosAppApiRelationInfo : public Darabonba::Model {
public:
  shared_ptr<string> apiId{};
  shared_ptr<string> apiName{};
  shared_ptr<string> authorizationSource{};
  shared_ptr<string> createdTime{};
  shared_ptr<string> description{};
  shared_ptr<string> groupId{};
  shared_ptr<string> groupName{};
  shared_ptr<string> method{};
  shared_ptr<string> operator_{};
  shared_ptr<string> path{};
  shared_ptr<string> regionId{};
  shared_ptr<map<string, string>> stageNameAndAuth{};

  DescribeApisWithStageNameIntegratedByAppResponseBodyAppApiRelationInfosAppApiRelationInfo() {}

  explicit DescribeApisWithStageNameIntegratedByAppResponseBodyAppApiRelationInfosAppApiRelationInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiId) {
      res["ApiId"] = boost::any(*apiId);
    }
    if (apiName) {
      res["ApiName"] = boost::any(*apiName);
    }
    if (authorizationSource) {
      res["AuthorizationSource"] = boost::any(*authorizationSource);
    }
    if (createdTime) {
      res["CreatedTime"] = boost::any(*createdTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (method) {
      res["Method"] = boost::any(*method);
    }
    if (operator_) {
      res["Operator"] = boost::any(*operator_);
    }
    if (path) {
      res["Path"] = boost::any(*path);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (stageNameAndAuth) {
      res["StageNameAndAuth"] = boost::any(*stageNameAndAuth);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiId") != m.end() && !m["ApiId"].empty()) {
      apiId = make_shared<string>(boost::any_cast<string>(m["ApiId"]));
    }
    if (m.find("ApiName") != m.end() && !m["ApiName"].empty()) {
      apiName = make_shared<string>(boost::any_cast<string>(m["ApiName"]));
    }
    if (m.find("AuthorizationSource") != m.end() && !m["AuthorizationSource"].empty()) {
      authorizationSource = make_shared<string>(boost::any_cast<string>(m["AuthorizationSource"]));
    }
    if (m.find("CreatedTime") != m.end() && !m["CreatedTime"].empty()) {
      createdTime = make_shared<string>(boost::any_cast<string>(m["CreatedTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("Method") != m.end() && !m["Method"].empty()) {
      method = make_shared<string>(boost::any_cast<string>(m["Method"]));
    }
    if (m.find("Operator") != m.end() && !m["Operator"].empty()) {
      operator_ = make_shared<string>(boost::any_cast<string>(m["Operator"]));
    }
    if (m.find("Path") != m.end() && !m["Path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["Path"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("StageNameAndAuth") != m.end() && !m["StageNameAndAuth"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["StageNameAndAuth"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      stageNameAndAuth = make_shared<map<string, string>>(toMap1);
    }
  }


  virtual ~DescribeApisWithStageNameIntegratedByAppResponseBodyAppApiRelationInfosAppApiRelationInfo() = default;
};
class DescribeApisWithStageNameIntegratedByAppResponseBodyAppApiRelationInfos : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeApisWithStageNameIntegratedByAppResponseBodyAppApiRelationInfosAppApiRelationInfo>> appApiRelationInfo{};

  DescribeApisWithStageNameIntegratedByAppResponseBodyAppApiRelationInfos() {}

  explicit DescribeApisWithStageNameIntegratedByAppResponseBodyAppApiRelationInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appApiRelationInfo) {
      vector<boost::any> temp1;
      for(auto item1:*appApiRelationInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AppApiRelationInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppApiRelationInfo") != m.end() && !m["AppApiRelationInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["AppApiRelationInfo"].type()) {
        vector<DescribeApisWithStageNameIntegratedByAppResponseBodyAppApiRelationInfosAppApiRelationInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AppApiRelationInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeApisWithStageNameIntegratedByAppResponseBodyAppApiRelationInfosAppApiRelationInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        appApiRelationInfo = make_shared<vector<DescribeApisWithStageNameIntegratedByAppResponseBodyAppApiRelationInfosAppApiRelationInfo>>(expect1);
      }
    }
  }


  virtual ~DescribeApisWithStageNameIntegratedByAppResponseBodyAppApiRelationInfos() = default;
};
class DescribeApisWithStageNameIntegratedByAppResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeApisWithStageNameIntegratedByAppResponseBodyAppApiRelationInfos> appApiRelationInfos{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeApisWithStageNameIntegratedByAppResponseBody() {}

  explicit DescribeApisWithStageNameIntegratedByAppResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appApiRelationInfos) {
      res["AppApiRelationInfos"] = appApiRelationInfos ? boost::any(appApiRelationInfos->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppApiRelationInfos") != m.end() && !m["AppApiRelationInfos"].empty()) {
      if (typeid(map<string, boost::any>) == m["AppApiRelationInfos"].type()) {
        DescribeApisWithStageNameIntegratedByAppResponseBodyAppApiRelationInfos model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AppApiRelationInfos"]));
        appApiRelationInfos = make_shared<DescribeApisWithStageNameIntegratedByAppResponseBodyAppApiRelationInfos>(model1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeApisWithStageNameIntegratedByAppResponseBody() = default;
};
class DescribeApisWithStageNameIntegratedByAppResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeApisWithStageNameIntegratedByAppResponseBody> body{};

  DescribeApisWithStageNameIntegratedByAppResponse() {}

  explicit DescribeApisWithStageNameIntegratedByAppResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeApisWithStageNameIntegratedByAppResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeApisWithStageNameIntegratedByAppResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeApisWithStageNameIntegratedByAppResponse() = default;
};
class DescribeAppRequest : public Darabonba::Model {
public:
  shared_ptr<long> appId{};
  shared_ptr<string> securityToken{};

  DescribeAppRequest() {}

  explicit DescribeAppRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<long>(boost::any_cast<long>(m["AppId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~DescribeAppRequest() = default;
};
class DescribeAppResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> appId{};
  shared_ptr<string> appName{};
  shared_ptr<string> createdTime{};
  shared_ptr<string> description{};
  shared_ptr<string> extend{};
  shared_ptr<string> modifiedTime{};
  shared_ptr<string> requestId{};

  DescribeAppResponseBody() {}

  explicit DescribeAppResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (createdTime) {
      res["CreatedTime"] = boost::any(*createdTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (extend) {
      res["Extend"] = boost::any(*extend);
    }
    if (modifiedTime) {
      res["ModifiedTime"] = boost::any(*modifiedTime);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<long>(boost::any_cast<long>(m["AppId"]));
    }
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("CreatedTime") != m.end() && !m["CreatedTime"].empty()) {
      createdTime = make_shared<string>(boost::any_cast<string>(m["CreatedTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Extend") != m.end() && !m["Extend"].empty()) {
      extend = make_shared<string>(boost::any_cast<string>(m["Extend"]));
    }
    if (m.find("ModifiedTime") != m.end() && !m["ModifiedTime"].empty()) {
      modifiedTime = make_shared<string>(boost::any_cast<string>(m["ModifiedTime"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeAppResponseBody() = default;
};
class DescribeAppResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeAppResponseBody> body{};

  DescribeAppResponse() {}

  explicit DescribeAppResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeAppResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeAppResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeAppResponse() = default;
};
class DescribeAppAttributesRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  DescribeAppAttributesRequestTag() {}

  explicit DescribeAppAttributesRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeAppAttributesRequestTag() = default;
};
class DescribeAppAttributesRequest : public Darabonba::Model {
public:
  shared_ptr<string> appCode{};
  shared_ptr<long> appId{};
  shared_ptr<string> appKey{};
  shared_ptr<string> appName{};
  shared_ptr<bool> enableTagAuth{};
  shared_ptr<string> extend{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> sort{};
  shared_ptr<vector<DescribeAppAttributesRequestTag>> tag{};

  DescribeAppAttributesRequest() {}

  explicit DescribeAppAttributesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appCode) {
      res["AppCode"] = boost::any(*appCode);
    }
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (appKey) {
      res["AppKey"] = boost::any(*appKey);
    }
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (enableTagAuth) {
      res["EnableTagAuth"] = boost::any(*enableTagAuth);
    }
    if (extend) {
      res["Extend"] = boost::any(*extend);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (sort) {
      res["Sort"] = boost::any(*sort);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppCode") != m.end() && !m["AppCode"].empty()) {
      appCode = make_shared<string>(boost::any_cast<string>(m["AppCode"]));
    }
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<long>(boost::any_cast<long>(m["AppId"]));
    }
    if (m.find("AppKey") != m.end() && !m["AppKey"].empty()) {
      appKey = make_shared<string>(boost::any_cast<string>(m["AppKey"]));
    }
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("EnableTagAuth") != m.end() && !m["EnableTagAuth"].empty()) {
      enableTagAuth = make_shared<bool>(boost::any_cast<bool>(m["EnableTagAuth"]));
    }
    if (m.find("Extend") != m.end() && !m["Extend"].empty()) {
      extend = make_shared<string>(boost::any_cast<string>(m["Extend"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("Sort") != m.end() && !m["Sort"].empty()) {
      sort = make_shared<string>(boost::any_cast<string>(m["Sort"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<DescribeAppAttributesRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeAppAttributesRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<DescribeAppAttributesRequestTag>>(expect1);
      }
    }
  }


  virtual ~DescribeAppAttributesRequest() = default;
};
class DescribeAppAttributesResponseBodyAppsAppAttributeTagsTagInfo : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  DescribeAppAttributesResponseBodyAppsAppAttributeTagsTagInfo() {}

  explicit DescribeAppAttributesResponseBodyAppsAppAttributeTagsTagInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeAppAttributesResponseBodyAppsAppAttributeTagsTagInfo() = default;
};
class DescribeAppAttributesResponseBodyAppsAppAttributeTags : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeAppAttributesResponseBodyAppsAppAttributeTagsTagInfo>> tagInfo{};

  DescribeAppAttributesResponseBodyAppsAppAttributeTags() {}

  explicit DescribeAppAttributesResponseBodyAppsAppAttributeTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tagInfo) {
      vector<boost::any> temp1;
      for(auto item1:*tagInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TagInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TagInfo") != m.end() && !m["TagInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["TagInfo"].type()) {
        vector<DescribeAppAttributesResponseBodyAppsAppAttributeTagsTagInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TagInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeAppAttributesResponseBodyAppsAppAttributeTagsTagInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tagInfo = make_shared<vector<DescribeAppAttributesResponseBodyAppsAppAttributeTagsTagInfo>>(expect1);
      }
    }
  }


  virtual ~DescribeAppAttributesResponseBodyAppsAppAttributeTags() = default;
};
class DescribeAppAttributesResponseBodyAppsAppAttribute : public Darabonba::Model {
public:
  shared_ptr<long> appId{};
  shared_ptr<string> appName{};
  shared_ptr<string> createdTime{};
  shared_ptr<string> description{};
  shared_ptr<string> extend{};
  shared_ptr<string> modifiedTime{};
  shared_ptr<DescribeAppAttributesResponseBodyAppsAppAttributeTags> tags{};

  DescribeAppAttributesResponseBodyAppsAppAttribute() {}

  explicit DescribeAppAttributesResponseBodyAppsAppAttribute(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (createdTime) {
      res["CreatedTime"] = boost::any(*createdTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (extend) {
      res["Extend"] = boost::any(*extend);
    }
    if (modifiedTime) {
      res["ModifiedTime"] = boost::any(*modifiedTime);
    }
    if (tags) {
      res["Tags"] = tags ? boost::any(tags->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<long>(boost::any_cast<long>(m["AppId"]));
    }
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("CreatedTime") != m.end() && !m["CreatedTime"].empty()) {
      createdTime = make_shared<string>(boost::any_cast<string>(m["CreatedTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Extend") != m.end() && !m["Extend"].empty()) {
      extend = make_shared<string>(boost::any_cast<string>(m["Extend"]));
    }
    if (m.find("ModifiedTime") != m.end() && !m["ModifiedTime"].empty()) {
      modifiedTime = make_shared<string>(boost::any_cast<string>(m["ModifiedTime"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(map<string, boost::any>) == m["Tags"].type()) {
        DescribeAppAttributesResponseBodyAppsAppAttributeTags model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Tags"]));
        tags = make_shared<DescribeAppAttributesResponseBodyAppsAppAttributeTags>(model1);
      }
    }
  }


  virtual ~DescribeAppAttributesResponseBodyAppsAppAttribute() = default;
};
class DescribeAppAttributesResponseBodyApps : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeAppAttributesResponseBodyAppsAppAttribute>> appAttribute{};

  DescribeAppAttributesResponseBodyApps() {}

  explicit DescribeAppAttributesResponseBodyApps(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appAttribute) {
      vector<boost::any> temp1;
      for(auto item1:*appAttribute){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AppAttribute"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppAttribute") != m.end() && !m["AppAttribute"].empty()) {
      if (typeid(vector<boost::any>) == m["AppAttribute"].type()) {
        vector<DescribeAppAttributesResponseBodyAppsAppAttribute> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AppAttribute"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeAppAttributesResponseBodyAppsAppAttribute model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        appAttribute = make_shared<vector<DescribeAppAttributesResponseBodyAppsAppAttribute>>(expect1);
      }
    }
  }


  virtual ~DescribeAppAttributesResponseBodyApps() = default;
};
class DescribeAppAttributesResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeAppAttributesResponseBodyApps> apps{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeAppAttributesResponseBody() {}

  explicit DescribeAppAttributesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apps) {
      res["Apps"] = apps ? boost::any(apps->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Apps") != m.end() && !m["Apps"].empty()) {
      if (typeid(map<string, boost::any>) == m["Apps"].type()) {
        DescribeAppAttributesResponseBodyApps model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Apps"]));
        apps = make_shared<DescribeAppAttributesResponseBodyApps>(model1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeAppAttributesResponseBody() = default;
};
class DescribeAppAttributesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeAppAttributesResponseBody> body{};

  DescribeAppAttributesResponse() {}

  explicit DescribeAppAttributesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeAppAttributesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeAppAttributesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeAppAttributesResponse() = default;
};
class DescribeAppSecuritiesRequest : public Darabonba::Model {
public:
  shared_ptr<long> appId{};
  shared_ptr<string> securityToken{};

  DescribeAppSecuritiesRequest() {}

  explicit DescribeAppSecuritiesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<long>(boost::any_cast<long>(m["AppId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~DescribeAppSecuritiesRequest() = default;
};
class DescribeAppSecuritiesResponseBodyAppSecuritysAppSecurity : public Darabonba::Model {
public:
  shared_ptr<string> appCode{};
  shared_ptr<string> appKey{};
  shared_ptr<string> appSecret{};
  shared_ptr<string> createdTime{};
  shared_ptr<string> modifiedTime{};

  DescribeAppSecuritiesResponseBodyAppSecuritysAppSecurity() {}

  explicit DescribeAppSecuritiesResponseBodyAppSecuritysAppSecurity(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appCode) {
      res["AppCode"] = boost::any(*appCode);
    }
    if (appKey) {
      res["AppKey"] = boost::any(*appKey);
    }
    if (appSecret) {
      res["AppSecret"] = boost::any(*appSecret);
    }
    if (createdTime) {
      res["CreatedTime"] = boost::any(*createdTime);
    }
    if (modifiedTime) {
      res["ModifiedTime"] = boost::any(*modifiedTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppCode") != m.end() && !m["AppCode"].empty()) {
      appCode = make_shared<string>(boost::any_cast<string>(m["AppCode"]));
    }
    if (m.find("AppKey") != m.end() && !m["AppKey"].empty()) {
      appKey = make_shared<string>(boost::any_cast<string>(m["AppKey"]));
    }
    if (m.find("AppSecret") != m.end() && !m["AppSecret"].empty()) {
      appSecret = make_shared<string>(boost::any_cast<string>(m["AppSecret"]));
    }
    if (m.find("CreatedTime") != m.end() && !m["CreatedTime"].empty()) {
      createdTime = make_shared<string>(boost::any_cast<string>(m["CreatedTime"]));
    }
    if (m.find("ModifiedTime") != m.end() && !m["ModifiedTime"].empty()) {
      modifiedTime = make_shared<string>(boost::any_cast<string>(m["ModifiedTime"]));
    }
  }


  virtual ~DescribeAppSecuritiesResponseBodyAppSecuritysAppSecurity() = default;
};
class DescribeAppSecuritiesResponseBodyAppSecuritys : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeAppSecuritiesResponseBodyAppSecuritysAppSecurity>> appSecurity{};

  DescribeAppSecuritiesResponseBodyAppSecuritys() {}

  explicit DescribeAppSecuritiesResponseBodyAppSecuritys(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appSecurity) {
      vector<boost::any> temp1;
      for(auto item1:*appSecurity){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AppSecurity"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppSecurity") != m.end() && !m["AppSecurity"].empty()) {
      if (typeid(vector<boost::any>) == m["AppSecurity"].type()) {
        vector<DescribeAppSecuritiesResponseBodyAppSecuritysAppSecurity> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AppSecurity"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeAppSecuritiesResponseBodyAppSecuritysAppSecurity model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        appSecurity = make_shared<vector<DescribeAppSecuritiesResponseBodyAppSecuritysAppSecurity>>(expect1);
      }
    }
  }


  virtual ~DescribeAppSecuritiesResponseBodyAppSecuritys() = default;
};
class DescribeAppSecuritiesResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeAppSecuritiesResponseBodyAppSecuritys> appSecuritys{};
  shared_ptr<string> requestId{};

  DescribeAppSecuritiesResponseBody() {}

  explicit DescribeAppSecuritiesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appSecuritys) {
      res["AppSecuritys"] = appSecuritys ? boost::any(appSecuritys->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppSecuritys") != m.end() && !m["AppSecuritys"].empty()) {
      if (typeid(map<string, boost::any>) == m["AppSecuritys"].type()) {
        DescribeAppSecuritiesResponseBodyAppSecuritys model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AppSecuritys"]));
        appSecuritys = make_shared<DescribeAppSecuritiesResponseBodyAppSecuritys>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeAppSecuritiesResponseBody() = default;
};
class DescribeAppSecuritiesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeAppSecuritiesResponseBody> body{};

  DescribeAppSecuritiesResponse() {}

  explicit DescribeAppSecuritiesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeAppSecuritiesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeAppSecuritiesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeAppSecuritiesResponse() = default;
};
class DescribeAppSecurityRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  DescribeAppSecurityRequestTag() {}

  explicit DescribeAppSecurityRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeAppSecurityRequestTag() = default;
};
class DescribeAppSecurityRequest : public Darabonba::Model {
public:
  shared_ptr<long> appId{};
  shared_ptr<string> securityToken{};
  shared_ptr<vector<DescribeAppSecurityRequestTag>> tag{};

  DescribeAppSecurityRequest() {}

  explicit DescribeAppSecurityRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<long>(boost::any_cast<long>(m["AppId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<DescribeAppSecurityRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeAppSecurityRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<DescribeAppSecurityRequestTag>>(expect1);
      }
    }
  }


  virtual ~DescribeAppSecurityRequest() = default;
};
class DescribeAppSecurityResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> appCode{};
  shared_ptr<string> appKey{};
  shared_ptr<string> appSecret{};
  shared_ptr<string> createdTime{};
  shared_ptr<string> modifiedTime{};
  shared_ptr<string> requestId{};

  DescribeAppSecurityResponseBody() {}

  explicit DescribeAppSecurityResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appCode) {
      res["AppCode"] = boost::any(*appCode);
    }
    if (appKey) {
      res["AppKey"] = boost::any(*appKey);
    }
    if (appSecret) {
      res["AppSecret"] = boost::any(*appSecret);
    }
    if (createdTime) {
      res["CreatedTime"] = boost::any(*createdTime);
    }
    if (modifiedTime) {
      res["ModifiedTime"] = boost::any(*modifiedTime);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppCode") != m.end() && !m["AppCode"].empty()) {
      appCode = make_shared<string>(boost::any_cast<string>(m["AppCode"]));
    }
    if (m.find("AppKey") != m.end() && !m["AppKey"].empty()) {
      appKey = make_shared<string>(boost::any_cast<string>(m["AppKey"]));
    }
    if (m.find("AppSecret") != m.end() && !m["AppSecret"].empty()) {
      appSecret = make_shared<string>(boost::any_cast<string>(m["AppSecret"]));
    }
    if (m.find("CreatedTime") != m.end() && !m["CreatedTime"].empty()) {
      createdTime = make_shared<string>(boost::any_cast<string>(m["CreatedTime"]));
    }
    if (m.find("ModifiedTime") != m.end() && !m["ModifiedTime"].empty()) {
      modifiedTime = make_shared<string>(boost::any_cast<string>(m["ModifiedTime"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeAppSecurityResponseBody() = default;
};
class DescribeAppSecurityResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeAppSecurityResponseBody> body{};

  DescribeAppSecurityResponse() {}

  explicit DescribeAppSecurityResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeAppSecurityResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeAppSecurityResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeAppSecurityResponse() = default;
};
class DescribeAppsRequest : public Darabonba::Model {
public:
  shared_ptr<long> appId{};
  shared_ptr<long> appOwner{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> securityToken{};

  DescribeAppsRequest() {}

  explicit DescribeAppsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (appOwner) {
      res["AppOwner"] = boost::any(*appOwner);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<long>(boost::any_cast<long>(m["AppId"]));
    }
    if (m.find("AppOwner") != m.end() && !m["AppOwner"].empty()) {
      appOwner = make_shared<long>(boost::any_cast<long>(m["AppOwner"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~DescribeAppsRequest() = default;
};
class DescribeAppsResponseBodyAppsAppItem : public Darabonba::Model {
public:
  shared_ptr<long> appId{};
  shared_ptr<string> appName{};
  shared_ptr<string> description{};

  DescribeAppsResponseBodyAppsAppItem() {}

  explicit DescribeAppsResponseBodyAppsAppItem(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<long>(boost::any_cast<long>(m["AppId"]));
    }
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
  }


  virtual ~DescribeAppsResponseBodyAppsAppItem() = default;
};
class DescribeAppsResponseBodyApps : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeAppsResponseBodyAppsAppItem>> appItem{};

  DescribeAppsResponseBodyApps() {}

  explicit DescribeAppsResponseBodyApps(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appItem) {
      vector<boost::any> temp1;
      for(auto item1:*appItem){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AppItem"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppItem") != m.end() && !m["AppItem"].empty()) {
      if (typeid(vector<boost::any>) == m["AppItem"].type()) {
        vector<DescribeAppsResponseBodyAppsAppItem> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AppItem"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeAppsResponseBodyAppsAppItem model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        appItem = make_shared<vector<DescribeAppsResponseBodyAppsAppItem>>(expect1);
      }
    }
  }


  virtual ~DescribeAppsResponseBodyApps() = default;
};
class DescribeAppsResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeAppsResponseBodyApps> apps{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeAppsResponseBody() {}

  explicit DescribeAppsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apps) {
      res["Apps"] = apps ? boost::any(apps->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Apps") != m.end() && !m["Apps"].empty()) {
      if (typeid(map<string, boost::any>) == m["Apps"].type()) {
        DescribeAppsResponseBodyApps model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Apps"]));
        apps = make_shared<DescribeAppsResponseBodyApps>(model1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeAppsResponseBody() = default;
};
class DescribeAppsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeAppsResponseBody> body{};

  DescribeAppsResponse() {}

  explicit DescribeAppsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeAppsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeAppsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeAppsResponse() = default;
};
class DescribeAppsByApiProductRequest : public Darabonba::Model {
public:
  shared_ptr<string> apiProductId{};
  shared_ptr<string> appName{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> securityToken{};

  DescribeAppsByApiProductRequest() {}

  explicit DescribeAppsByApiProductRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiProductId) {
      res["ApiProductId"] = boost::any(*apiProductId);
    }
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiProductId") != m.end() && !m["ApiProductId"].empty()) {
      apiProductId = make_shared<string>(boost::any_cast<string>(m["ApiProductId"]));
    }
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~DescribeAppsByApiProductRequest() = default;
};
class DescribeAppsByApiProductResponseBodyAuthorizedAppsAuthorizedApp : public Darabonba::Model {
public:
  shared_ptr<long> appId{};
  shared_ptr<string> appName{};
  shared_ptr<string> authValidTime{};
  shared_ptr<string> authorizedTime{};
  shared_ptr<string> description{};
  shared_ptr<string> extend{};

  DescribeAppsByApiProductResponseBodyAuthorizedAppsAuthorizedApp() {}

  explicit DescribeAppsByApiProductResponseBodyAuthorizedAppsAuthorizedApp(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (authValidTime) {
      res["AuthValidTime"] = boost::any(*authValidTime);
    }
    if (authorizedTime) {
      res["AuthorizedTime"] = boost::any(*authorizedTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (extend) {
      res["Extend"] = boost::any(*extend);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<long>(boost::any_cast<long>(m["AppId"]));
    }
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("AuthValidTime") != m.end() && !m["AuthValidTime"].empty()) {
      authValidTime = make_shared<string>(boost::any_cast<string>(m["AuthValidTime"]));
    }
    if (m.find("AuthorizedTime") != m.end() && !m["AuthorizedTime"].empty()) {
      authorizedTime = make_shared<string>(boost::any_cast<string>(m["AuthorizedTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Extend") != m.end() && !m["Extend"].empty()) {
      extend = make_shared<string>(boost::any_cast<string>(m["Extend"]));
    }
  }


  virtual ~DescribeAppsByApiProductResponseBodyAuthorizedAppsAuthorizedApp() = default;
};
class DescribeAppsByApiProductResponseBodyAuthorizedApps : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeAppsByApiProductResponseBodyAuthorizedAppsAuthorizedApp>> authorizedApp{};

  DescribeAppsByApiProductResponseBodyAuthorizedApps() {}

  explicit DescribeAppsByApiProductResponseBodyAuthorizedApps(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (authorizedApp) {
      vector<boost::any> temp1;
      for(auto item1:*authorizedApp){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AuthorizedApp"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AuthorizedApp") != m.end() && !m["AuthorizedApp"].empty()) {
      if (typeid(vector<boost::any>) == m["AuthorizedApp"].type()) {
        vector<DescribeAppsByApiProductResponseBodyAuthorizedAppsAuthorizedApp> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AuthorizedApp"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeAppsByApiProductResponseBodyAuthorizedAppsAuthorizedApp model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        authorizedApp = make_shared<vector<DescribeAppsByApiProductResponseBodyAuthorizedAppsAuthorizedApp>>(expect1);
      }
    }
  }


  virtual ~DescribeAppsByApiProductResponseBodyAuthorizedApps() = default;
};
class DescribeAppsByApiProductResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeAppsByApiProductResponseBodyAuthorizedApps> authorizedApps{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeAppsByApiProductResponseBody() {}

  explicit DescribeAppsByApiProductResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (authorizedApps) {
      res["AuthorizedApps"] = authorizedApps ? boost::any(authorizedApps->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AuthorizedApps") != m.end() && !m["AuthorizedApps"].empty()) {
      if (typeid(map<string, boost::any>) == m["AuthorizedApps"].type()) {
        DescribeAppsByApiProductResponseBodyAuthorizedApps model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AuthorizedApps"]));
        authorizedApps = make_shared<DescribeAppsByApiProductResponseBodyAuthorizedApps>(model1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeAppsByApiProductResponseBody() = default;
};
class DescribeAppsByApiProductResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeAppsByApiProductResponseBody> body{};

  DescribeAppsByApiProductResponse() {}

  explicit DescribeAppsByApiProductResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeAppsByApiProductResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeAppsByApiProductResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeAppsByApiProductResponse() = default;
};
class DescribeAuthorizedApisRequest : public Darabonba::Model {
public:
  shared_ptr<long> appId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> securityToken{};

  DescribeAuthorizedApisRequest() {}

  explicit DescribeAuthorizedApisRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<long>(boost::any_cast<long>(m["AppId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~DescribeAuthorizedApisRequest() = default;
};
class DescribeAuthorizedApisResponseBodyAuthorizedApisAuthorizedApi : public Darabonba::Model {
public:
  shared_ptr<string> apiId{};
  shared_ptr<string> apiName{};
  shared_ptr<string> authVaildTime{};
  shared_ptr<string> authorizationSource{};
  shared_ptr<string> authorizedTime{};
  shared_ptr<string> description{};
  shared_ptr<string> groupId{};
  shared_ptr<string> groupName{};
  shared_ptr<string> operator_{};
  shared_ptr<string> regionId{};
  shared_ptr<string> stageName{};

  DescribeAuthorizedApisResponseBodyAuthorizedApisAuthorizedApi() {}

  explicit DescribeAuthorizedApisResponseBodyAuthorizedApisAuthorizedApi(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiId) {
      res["ApiId"] = boost::any(*apiId);
    }
    if (apiName) {
      res["ApiName"] = boost::any(*apiName);
    }
    if (authVaildTime) {
      res["AuthVaildTime"] = boost::any(*authVaildTime);
    }
    if (authorizationSource) {
      res["AuthorizationSource"] = boost::any(*authorizationSource);
    }
    if (authorizedTime) {
      res["AuthorizedTime"] = boost::any(*authorizedTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (operator_) {
      res["Operator"] = boost::any(*operator_);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (stageName) {
      res["StageName"] = boost::any(*stageName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiId") != m.end() && !m["ApiId"].empty()) {
      apiId = make_shared<string>(boost::any_cast<string>(m["ApiId"]));
    }
    if (m.find("ApiName") != m.end() && !m["ApiName"].empty()) {
      apiName = make_shared<string>(boost::any_cast<string>(m["ApiName"]));
    }
    if (m.find("AuthVaildTime") != m.end() && !m["AuthVaildTime"].empty()) {
      authVaildTime = make_shared<string>(boost::any_cast<string>(m["AuthVaildTime"]));
    }
    if (m.find("AuthorizationSource") != m.end() && !m["AuthorizationSource"].empty()) {
      authorizationSource = make_shared<string>(boost::any_cast<string>(m["AuthorizationSource"]));
    }
    if (m.find("AuthorizedTime") != m.end() && !m["AuthorizedTime"].empty()) {
      authorizedTime = make_shared<string>(boost::any_cast<string>(m["AuthorizedTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("Operator") != m.end() && !m["Operator"].empty()) {
      operator_ = make_shared<string>(boost::any_cast<string>(m["Operator"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("StageName") != m.end() && !m["StageName"].empty()) {
      stageName = make_shared<string>(boost::any_cast<string>(m["StageName"]));
    }
  }


  virtual ~DescribeAuthorizedApisResponseBodyAuthorizedApisAuthorizedApi() = default;
};
class DescribeAuthorizedApisResponseBodyAuthorizedApis : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeAuthorizedApisResponseBodyAuthorizedApisAuthorizedApi>> authorizedApi{};

  DescribeAuthorizedApisResponseBodyAuthorizedApis() {}

  explicit DescribeAuthorizedApisResponseBodyAuthorizedApis(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (authorizedApi) {
      vector<boost::any> temp1;
      for(auto item1:*authorizedApi){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AuthorizedApi"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AuthorizedApi") != m.end() && !m["AuthorizedApi"].empty()) {
      if (typeid(vector<boost::any>) == m["AuthorizedApi"].type()) {
        vector<DescribeAuthorizedApisResponseBodyAuthorizedApisAuthorizedApi> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AuthorizedApi"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeAuthorizedApisResponseBodyAuthorizedApisAuthorizedApi model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        authorizedApi = make_shared<vector<DescribeAuthorizedApisResponseBodyAuthorizedApisAuthorizedApi>>(expect1);
      }
    }
  }


  virtual ~DescribeAuthorizedApisResponseBodyAuthorizedApis() = default;
};
class DescribeAuthorizedApisResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeAuthorizedApisResponseBodyAuthorizedApis> authorizedApis{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeAuthorizedApisResponseBody() {}

  explicit DescribeAuthorizedApisResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (authorizedApis) {
      res["AuthorizedApis"] = authorizedApis ? boost::any(authorizedApis->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AuthorizedApis") != m.end() && !m["AuthorizedApis"].empty()) {
      if (typeid(map<string, boost::any>) == m["AuthorizedApis"].type()) {
        DescribeAuthorizedApisResponseBodyAuthorizedApis model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AuthorizedApis"]));
        authorizedApis = make_shared<DescribeAuthorizedApisResponseBodyAuthorizedApis>(model1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeAuthorizedApisResponseBody() = default;
};
class DescribeAuthorizedApisResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeAuthorizedApisResponseBody> body{};

  DescribeAuthorizedApisResponse() {}

  explicit DescribeAuthorizedApisResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeAuthorizedApisResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeAuthorizedApisResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeAuthorizedApisResponse() = default;
};
class DescribeAuthorizedAppsRequest : public Darabonba::Model {
public:
  shared_ptr<string> apiId{};
  shared_ptr<long> appId{};
  shared_ptr<string> appName{};
  shared_ptr<long> appOwnerId{};
  shared_ptr<string> groupId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> stageName{};

  DescribeAuthorizedAppsRequest() {}

  explicit DescribeAuthorizedAppsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiId) {
      res["ApiId"] = boost::any(*apiId);
    }
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (appOwnerId) {
      res["AppOwnerId"] = boost::any(*appOwnerId);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (stageName) {
      res["StageName"] = boost::any(*stageName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiId") != m.end() && !m["ApiId"].empty()) {
      apiId = make_shared<string>(boost::any_cast<string>(m["ApiId"]));
    }
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<long>(boost::any_cast<long>(m["AppId"]));
    }
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("AppOwnerId") != m.end() && !m["AppOwnerId"].empty()) {
      appOwnerId = make_shared<long>(boost::any_cast<long>(m["AppOwnerId"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("StageName") != m.end() && !m["StageName"].empty()) {
      stageName = make_shared<string>(boost::any_cast<string>(m["StageName"]));
    }
  }


  virtual ~DescribeAuthorizedAppsRequest() = default;
};
class DescribeAuthorizedAppsResponseBodyAuthorizedAppsAuthorizedApp : public Darabonba::Model {
public:
  shared_ptr<string> appDescription{};
  shared_ptr<long> appId{};
  shared_ptr<string> appName{};
  shared_ptr<string> authVaildTime{};
  shared_ptr<string> authorizationSource{};
  shared_ptr<string> authorizedTime{};
  shared_ptr<string> description{};
  shared_ptr<string> operator_{};
  shared_ptr<string> stageAlias{};
  shared_ptr<string> stageName{};

  DescribeAuthorizedAppsResponseBodyAuthorizedAppsAuthorizedApp() {}

  explicit DescribeAuthorizedAppsResponseBodyAuthorizedAppsAuthorizedApp(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appDescription) {
      res["AppDescription"] = boost::any(*appDescription);
    }
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (authVaildTime) {
      res["AuthVaildTime"] = boost::any(*authVaildTime);
    }
    if (authorizationSource) {
      res["AuthorizationSource"] = boost::any(*authorizationSource);
    }
    if (authorizedTime) {
      res["AuthorizedTime"] = boost::any(*authorizedTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (operator_) {
      res["Operator"] = boost::any(*operator_);
    }
    if (stageAlias) {
      res["StageAlias"] = boost::any(*stageAlias);
    }
    if (stageName) {
      res["StageName"] = boost::any(*stageName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppDescription") != m.end() && !m["AppDescription"].empty()) {
      appDescription = make_shared<string>(boost::any_cast<string>(m["AppDescription"]));
    }
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<long>(boost::any_cast<long>(m["AppId"]));
    }
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("AuthVaildTime") != m.end() && !m["AuthVaildTime"].empty()) {
      authVaildTime = make_shared<string>(boost::any_cast<string>(m["AuthVaildTime"]));
    }
    if (m.find("AuthorizationSource") != m.end() && !m["AuthorizationSource"].empty()) {
      authorizationSource = make_shared<string>(boost::any_cast<string>(m["AuthorizationSource"]));
    }
    if (m.find("AuthorizedTime") != m.end() && !m["AuthorizedTime"].empty()) {
      authorizedTime = make_shared<string>(boost::any_cast<string>(m["AuthorizedTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Operator") != m.end() && !m["Operator"].empty()) {
      operator_ = make_shared<string>(boost::any_cast<string>(m["Operator"]));
    }
    if (m.find("StageAlias") != m.end() && !m["StageAlias"].empty()) {
      stageAlias = make_shared<string>(boost::any_cast<string>(m["StageAlias"]));
    }
    if (m.find("StageName") != m.end() && !m["StageName"].empty()) {
      stageName = make_shared<string>(boost::any_cast<string>(m["StageName"]));
    }
  }


  virtual ~DescribeAuthorizedAppsResponseBodyAuthorizedAppsAuthorizedApp() = default;
};
class DescribeAuthorizedAppsResponseBodyAuthorizedApps : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeAuthorizedAppsResponseBodyAuthorizedAppsAuthorizedApp>> authorizedApp{};

  DescribeAuthorizedAppsResponseBodyAuthorizedApps() {}

  explicit DescribeAuthorizedAppsResponseBodyAuthorizedApps(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (authorizedApp) {
      vector<boost::any> temp1;
      for(auto item1:*authorizedApp){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AuthorizedApp"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AuthorizedApp") != m.end() && !m["AuthorizedApp"].empty()) {
      if (typeid(vector<boost::any>) == m["AuthorizedApp"].type()) {
        vector<DescribeAuthorizedAppsResponseBodyAuthorizedAppsAuthorizedApp> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AuthorizedApp"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeAuthorizedAppsResponseBodyAuthorizedAppsAuthorizedApp model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        authorizedApp = make_shared<vector<DescribeAuthorizedAppsResponseBodyAuthorizedAppsAuthorizedApp>>(expect1);
      }
    }
  }


  virtual ~DescribeAuthorizedAppsResponseBodyAuthorizedApps() = default;
};
class DescribeAuthorizedAppsResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeAuthorizedAppsResponseBodyAuthorizedApps> authorizedApps{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeAuthorizedAppsResponseBody() {}

  explicit DescribeAuthorizedAppsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (authorizedApps) {
      res["AuthorizedApps"] = authorizedApps ? boost::any(authorizedApps->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AuthorizedApps") != m.end() && !m["AuthorizedApps"].empty()) {
      if (typeid(map<string, boost::any>) == m["AuthorizedApps"].type()) {
        DescribeAuthorizedAppsResponseBodyAuthorizedApps model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AuthorizedApps"]));
        authorizedApps = make_shared<DescribeAuthorizedAppsResponseBodyAuthorizedApps>(model1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeAuthorizedAppsResponseBody() = default;
};
class DescribeAuthorizedAppsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeAuthorizedAppsResponseBody> body{};

  DescribeAuthorizedAppsResponse() {}

  explicit DescribeAuthorizedAppsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeAuthorizedAppsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeAuthorizedAppsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeAuthorizedAppsResponse() = default;
};
class DescribeBackendInfoRequest : public Darabonba::Model {
public:
  shared_ptr<string> backendId{};
  shared_ptr<string> securityToken{};

  DescribeBackendInfoRequest() {}

  explicit DescribeBackendInfoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (backendId) {
      res["BackendId"] = boost::any(*backendId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BackendId") != m.end() && !m["BackendId"].empty()) {
      backendId = make_shared<string>(boost::any_cast<string>(m["BackendId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~DescribeBackendInfoRequest() = default;
};
class DescribeBackendInfoResponseBodyBackendInfoBackendModelsBackendConfigDiscoveryConfigNacosConfig : public Darabonba::Model {
public:
  shared_ptr<string> accessKey{};
  shared_ptr<string> authType{};
  shared_ptr<string> clusters{};
  shared_ptr<string> groupName{};
  shared_ptr<string> namespace_{};
  shared_ptr<string> password{};
  shared_ptr<string> secretKey{};
  shared_ptr<string> serverAddress{};
  shared_ptr<string> serviceName{};
  shared_ptr<string> userName{};

  DescribeBackendInfoResponseBodyBackendInfoBackendModelsBackendConfigDiscoveryConfigNacosConfig() {}

  explicit DescribeBackendInfoResponseBodyBackendInfoBackendModelsBackendConfigDiscoveryConfigNacosConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessKey) {
      res["AccessKey"] = boost::any(*accessKey);
    }
    if (authType) {
      res["AuthType"] = boost::any(*authType);
    }
    if (clusters) {
      res["Clusters"] = boost::any(*clusters);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    if (password) {
      res["Password"] = boost::any(*password);
    }
    if (secretKey) {
      res["SecretKey"] = boost::any(*secretKey);
    }
    if (serverAddress) {
      res["ServerAddress"] = boost::any(*serverAddress);
    }
    if (serviceName) {
      res["ServiceName"] = boost::any(*serviceName);
    }
    if (userName) {
      res["UserName"] = boost::any(*userName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccessKey") != m.end() && !m["AccessKey"].empty()) {
      accessKey = make_shared<string>(boost::any_cast<string>(m["AccessKey"]));
    }
    if (m.find("AuthType") != m.end() && !m["AuthType"].empty()) {
      authType = make_shared<string>(boost::any_cast<string>(m["AuthType"]));
    }
    if (m.find("Clusters") != m.end() && !m["Clusters"].empty()) {
      clusters = make_shared<string>(boost::any_cast<string>(m["Clusters"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
    if (m.find("Password") != m.end() && !m["Password"].empty()) {
      password = make_shared<string>(boost::any_cast<string>(m["Password"]));
    }
    if (m.find("SecretKey") != m.end() && !m["SecretKey"].empty()) {
      secretKey = make_shared<string>(boost::any_cast<string>(m["SecretKey"]));
    }
    if (m.find("ServerAddress") != m.end() && !m["ServerAddress"].empty()) {
      serverAddress = make_shared<string>(boost::any_cast<string>(m["ServerAddress"]));
    }
    if (m.find("ServiceName") != m.end() && !m["ServiceName"].empty()) {
      serviceName = make_shared<string>(boost::any_cast<string>(m["ServiceName"]));
    }
    if (m.find("UserName") != m.end() && !m["UserName"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["UserName"]));
    }
  }


  virtual ~DescribeBackendInfoResponseBodyBackendInfoBackendModelsBackendConfigDiscoveryConfigNacosConfig() = default;
};
class DescribeBackendInfoResponseBodyBackendInfoBackendModelsBackendConfigDiscoveryConfigZookeeperConfig : public Darabonba::Model {
public:
  shared_ptr<string> connectString{};
  shared_ptr<string> namespace_{};
  shared_ptr<string> serviceName{};

  DescribeBackendInfoResponseBodyBackendInfoBackendModelsBackendConfigDiscoveryConfigZookeeperConfig() {}

  explicit DescribeBackendInfoResponseBodyBackendInfoBackendModelsBackendConfigDiscoveryConfigZookeeperConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (connectString) {
      res["ConnectString"] = boost::any(*connectString);
    }
    if (namespace_) {
      res["Namespace"] = boost::any(*namespace_);
    }
    if (serviceName) {
      res["ServiceName"] = boost::any(*serviceName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConnectString") != m.end() && !m["ConnectString"].empty()) {
      connectString = make_shared<string>(boost::any_cast<string>(m["ConnectString"]));
    }
    if (m.find("Namespace") != m.end() && !m["Namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["Namespace"]));
    }
    if (m.find("ServiceName") != m.end() && !m["ServiceName"].empty()) {
      serviceName = make_shared<string>(boost::any_cast<string>(m["ServiceName"]));
    }
  }


  virtual ~DescribeBackendInfoResponseBodyBackendInfoBackendModelsBackendConfigDiscoveryConfigZookeeperConfig() = default;
};
class DescribeBackendInfoResponseBodyBackendInfoBackendModelsBackendConfigDiscoveryConfig : public Darabonba::Model {
public:
  shared_ptr<DescribeBackendInfoResponseBodyBackendInfoBackendModelsBackendConfigDiscoveryConfigNacosConfig> nacosConfig{};
  shared_ptr<string> rcType{};
  shared_ptr<DescribeBackendInfoResponseBodyBackendInfoBackendModelsBackendConfigDiscoveryConfigZookeeperConfig> zookeeperConfig{};

  DescribeBackendInfoResponseBodyBackendInfoBackendModelsBackendConfigDiscoveryConfig() {}

  explicit DescribeBackendInfoResponseBodyBackendInfoBackendModelsBackendConfigDiscoveryConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nacosConfig) {
      res["NacosConfig"] = nacosConfig ? boost::any(nacosConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (rcType) {
      res["RcType"] = boost::any(*rcType);
    }
    if (zookeeperConfig) {
      res["ZookeeperConfig"] = zookeeperConfig ? boost::any(zookeeperConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NacosConfig") != m.end() && !m["NacosConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["NacosConfig"].type()) {
        DescribeBackendInfoResponseBodyBackendInfoBackendModelsBackendConfigDiscoveryConfigNacosConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NacosConfig"]));
        nacosConfig = make_shared<DescribeBackendInfoResponseBodyBackendInfoBackendModelsBackendConfigDiscoveryConfigNacosConfig>(model1);
      }
    }
    if (m.find("RcType") != m.end() && !m["RcType"].empty()) {
      rcType = make_shared<string>(boost::any_cast<string>(m["RcType"]));
    }
    if (m.find("ZookeeperConfig") != m.end() && !m["ZookeeperConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["ZookeeperConfig"].type()) {
        DescribeBackendInfoResponseBodyBackendInfoBackendModelsBackendConfigDiscoveryConfigZookeeperConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ZookeeperConfig"]));
        zookeeperConfig = make_shared<DescribeBackendInfoResponseBodyBackendInfoBackendModelsBackendConfigDiscoveryConfigZookeeperConfig>(model1);
      }
    }
  }


  virtual ~DescribeBackendInfoResponseBodyBackendInfoBackendModelsBackendConfigDiscoveryConfig() = default;
};
class DescribeBackendInfoResponseBodyBackendInfoBackendModelsBackendConfigEdasConfig : public Darabonba::Model {
public:
  shared_ptr<string> edasAppId{};
  shared_ptr<string> microserviceNamespace{};
  shared_ptr<string> microserviceNamespaceId{};
  shared_ptr<string> microserviceNamespaceName{};
  shared_ptr<string> mseInstanceId{};
  shared_ptr<string> registryType{};
  shared_ptr<string> serviceName{};

  DescribeBackendInfoResponseBodyBackendInfoBackendModelsBackendConfigEdasConfig() {}

  explicit DescribeBackendInfoResponseBodyBackendInfoBackendModelsBackendConfigEdasConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (edasAppId) {
      res["EdasAppId"] = boost::any(*edasAppId);
    }
    if (microserviceNamespace) {
      res["MicroserviceNamespace"] = boost::any(*microserviceNamespace);
    }
    if (microserviceNamespaceId) {
      res["MicroserviceNamespaceId"] = boost::any(*microserviceNamespaceId);
    }
    if (microserviceNamespaceName) {
      res["MicroserviceNamespaceName"] = boost::any(*microserviceNamespaceName);
    }
    if (mseInstanceId) {
      res["MseInstanceId"] = boost::any(*mseInstanceId);
    }
    if (registryType) {
      res["RegistryType"] = boost::any(*registryType);
    }
    if (serviceName) {
      res["ServiceName"] = boost::any(*serviceName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EdasAppId") != m.end() && !m["EdasAppId"].empty()) {
      edasAppId = make_shared<string>(boost::any_cast<string>(m["EdasAppId"]));
    }
    if (m.find("MicroserviceNamespace") != m.end() && !m["MicroserviceNamespace"].empty()) {
      microserviceNamespace = make_shared<string>(boost::any_cast<string>(m["MicroserviceNamespace"]));
    }
    if (m.find("MicroserviceNamespaceId") != m.end() && !m["MicroserviceNamespaceId"].empty()) {
      microserviceNamespaceId = make_shared<string>(boost::any_cast<string>(m["MicroserviceNamespaceId"]));
    }
    if (m.find("MicroserviceNamespaceName") != m.end() && !m["MicroserviceNamespaceName"].empty()) {
      microserviceNamespaceName = make_shared<string>(boost::any_cast<string>(m["MicroserviceNamespaceName"]));
    }
    if (m.find("MseInstanceId") != m.end() && !m["MseInstanceId"].empty()) {
      mseInstanceId = make_shared<string>(boost::any_cast<string>(m["MseInstanceId"]));
    }
    if (m.find("RegistryType") != m.end() && !m["RegistryType"].empty()) {
      registryType = make_shared<string>(boost::any_cast<string>(m["RegistryType"]));
    }
    if (m.find("ServiceName") != m.end() && !m["ServiceName"].empty()) {
      serviceName = make_shared<string>(boost::any_cast<string>(m["ServiceName"]));
    }
  }


  virtual ~DescribeBackendInfoResponseBodyBackendInfoBackendModelsBackendConfigEdasConfig() = default;
};
class DescribeBackendInfoResponseBodyBackendInfoBackendModelsBackendConfigEventBridgeConfig : public Darabonba::Model {
public:
  shared_ptr<string> eventBridgeRegionId{};
  shared_ptr<string> eventBus{};
  shared_ptr<string> eventSource{};
  shared_ptr<string> roleArn{};

  DescribeBackendInfoResponseBodyBackendInfoBackendModelsBackendConfigEventBridgeConfig() {}

  explicit DescribeBackendInfoResponseBodyBackendInfoBackendModelsBackendConfigEventBridgeConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (eventBridgeRegionId) {
      res["EventBridgeRegionId"] = boost::any(*eventBridgeRegionId);
    }
    if (eventBus) {
      res["EventBus"] = boost::any(*eventBus);
    }
    if (eventSource) {
      res["EventSource"] = boost::any(*eventSource);
    }
    if (roleArn) {
      res["RoleArn"] = boost::any(*roleArn);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EventBridgeRegionId") != m.end() && !m["EventBridgeRegionId"].empty()) {
      eventBridgeRegionId = make_shared<string>(boost::any_cast<string>(m["EventBridgeRegionId"]));
    }
    if (m.find("EventBus") != m.end() && !m["EventBus"].empty()) {
      eventBus = make_shared<string>(boost::any_cast<string>(m["EventBus"]));
    }
    if (m.find("EventSource") != m.end() && !m["EventSource"].empty()) {
      eventSource = make_shared<string>(boost::any_cast<string>(m["EventSource"]));
    }
    if (m.find("RoleArn") != m.end() && !m["RoleArn"].empty()) {
      roleArn = make_shared<string>(boost::any_cast<string>(m["RoleArn"]));
    }
  }


  virtual ~DescribeBackendInfoResponseBodyBackendInfoBackendModelsBackendConfigEventBridgeConfig() = default;
};
class DescribeBackendInfoResponseBodyBackendInfoBackendModelsBackendConfigFunctionComputeConfig : public Darabonba::Model {
public:
  shared_ptr<string> fcBaseUrl{};
  shared_ptr<string> fcRegionId{};
  shared_ptr<string> fcType{};
  shared_ptr<string> functionName{};
  shared_ptr<bool> onlyBusinessPath{};
  shared_ptr<string> qualifier{};
  shared_ptr<string> roleArn{};
  shared_ptr<string> serviceName{};

  DescribeBackendInfoResponseBodyBackendInfoBackendModelsBackendConfigFunctionComputeConfig() {}

  explicit DescribeBackendInfoResponseBodyBackendInfoBackendModelsBackendConfigFunctionComputeConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fcBaseUrl) {
      res["FcBaseUrl"] = boost::any(*fcBaseUrl);
    }
    if (fcRegionId) {
      res["FcRegionId"] = boost::any(*fcRegionId);
    }
    if (fcType) {
      res["FcType"] = boost::any(*fcType);
    }
    if (functionName) {
      res["FunctionName"] = boost::any(*functionName);
    }
    if (onlyBusinessPath) {
      res["OnlyBusinessPath"] = boost::any(*onlyBusinessPath);
    }
    if (qualifier) {
      res["Qualifier"] = boost::any(*qualifier);
    }
    if (roleArn) {
      res["RoleArn"] = boost::any(*roleArn);
    }
    if (serviceName) {
      res["ServiceName"] = boost::any(*serviceName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FcBaseUrl") != m.end() && !m["FcBaseUrl"].empty()) {
      fcBaseUrl = make_shared<string>(boost::any_cast<string>(m["FcBaseUrl"]));
    }
    if (m.find("FcRegionId") != m.end() && !m["FcRegionId"].empty()) {
      fcRegionId = make_shared<string>(boost::any_cast<string>(m["FcRegionId"]));
    }
    if (m.find("FcType") != m.end() && !m["FcType"].empty()) {
      fcType = make_shared<string>(boost::any_cast<string>(m["FcType"]));
    }
    if (m.find("FunctionName") != m.end() && !m["FunctionName"].empty()) {
      functionName = make_shared<string>(boost::any_cast<string>(m["FunctionName"]));
    }
    if (m.find("OnlyBusinessPath") != m.end() && !m["OnlyBusinessPath"].empty()) {
      onlyBusinessPath = make_shared<bool>(boost::any_cast<bool>(m["OnlyBusinessPath"]));
    }
    if (m.find("Qualifier") != m.end() && !m["Qualifier"].empty()) {
      qualifier = make_shared<string>(boost::any_cast<string>(m["Qualifier"]));
    }
    if (m.find("RoleArn") != m.end() && !m["RoleArn"].empty()) {
      roleArn = make_shared<string>(boost::any_cast<string>(m["RoleArn"]));
    }
    if (m.find("ServiceName") != m.end() && !m["ServiceName"].empty()) {
      serviceName = make_shared<string>(boost::any_cast<string>(m["ServiceName"]));
    }
  }


  virtual ~DescribeBackendInfoResponseBodyBackendInfoBackendModelsBackendConfigFunctionComputeConfig() = default;
};
class DescribeBackendInfoResponseBodyBackendInfoBackendModelsBackendConfigMockConfigMockHeaders : public Darabonba::Model {
public:
  shared_ptr<string> headerName{};
  shared_ptr<string> headerValue{};

  DescribeBackendInfoResponseBodyBackendInfoBackendModelsBackendConfigMockConfigMockHeaders() {}

  explicit DescribeBackendInfoResponseBodyBackendInfoBackendModelsBackendConfigMockConfigMockHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headerName) {
      res["HeaderName"] = boost::any(*headerName);
    }
    if (headerValue) {
      res["HeaderValue"] = boost::any(*headerValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HeaderName") != m.end() && !m["HeaderName"].empty()) {
      headerName = make_shared<string>(boost::any_cast<string>(m["HeaderName"]));
    }
    if (m.find("HeaderValue") != m.end() && !m["HeaderValue"].empty()) {
      headerValue = make_shared<string>(boost::any_cast<string>(m["HeaderValue"]));
    }
  }


  virtual ~DescribeBackendInfoResponseBodyBackendInfoBackendModelsBackendConfigMockConfigMockHeaders() = default;
};
class DescribeBackendInfoResponseBodyBackendInfoBackendModelsBackendConfigMockConfig : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeBackendInfoResponseBodyBackendInfoBackendModelsBackendConfigMockConfigMockHeaders>> mockHeaders{};
  shared_ptr<string> mockResult{};
  shared_ptr<string> mockStatusCode{};

  DescribeBackendInfoResponseBodyBackendInfoBackendModelsBackendConfigMockConfig() {}

  explicit DescribeBackendInfoResponseBodyBackendInfoBackendModelsBackendConfigMockConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mockHeaders) {
      vector<boost::any> temp1;
      for(auto item1:*mockHeaders){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["MockHeaders"] = boost::any(temp1);
    }
    if (mockResult) {
      res["MockResult"] = boost::any(*mockResult);
    }
    if (mockStatusCode) {
      res["MockStatusCode"] = boost::any(*mockStatusCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MockHeaders") != m.end() && !m["MockHeaders"].empty()) {
      if (typeid(vector<boost::any>) == m["MockHeaders"].type()) {
        vector<DescribeBackendInfoResponseBodyBackendInfoBackendModelsBackendConfigMockConfigMockHeaders> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["MockHeaders"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeBackendInfoResponseBodyBackendInfoBackendModelsBackendConfigMockConfigMockHeaders model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        mockHeaders = make_shared<vector<DescribeBackendInfoResponseBodyBackendInfoBackendModelsBackendConfigMockConfigMockHeaders>>(expect1);
      }
    }
    if (m.find("MockResult") != m.end() && !m["MockResult"].empty()) {
      mockResult = make_shared<string>(boost::any_cast<string>(m["MockResult"]));
    }
    if (m.find("MockStatusCode") != m.end() && !m["MockStatusCode"].empty()) {
      mockStatusCode = make_shared<string>(boost::any_cast<string>(m["MockStatusCode"]));
    }
  }


  virtual ~DescribeBackendInfoResponseBodyBackendInfoBackendModelsBackendConfigMockConfig() = default;
};
class DescribeBackendInfoResponseBodyBackendInfoBackendModelsBackendConfigOssConfig : public Darabonba::Model {
public:
  shared_ptr<string> bucketName{};
  shared_ptr<string> ossRegionId{};

  DescribeBackendInfoResponseBodyBackendInfoBackendModelsBackendConfigOssConfig() {}

  explicit DescribeBackendInfoResponseBodyBackendInfoBackendModelsBackendConfigOssConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bucketName) {
      res["BucketName"] = boost::any(*bucketName);
    }
    if (ossRegionId) {
      res["OssRegionId"] = boost::any(*ossRegionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BucketName") != m.end() && !m["BucketName"].empty()) {
      bucketName = make_shared<string>(boost::any_cast<string>(m["BucketName"]));
    }
    if (m.find("OssRegionId") != m.end() && !m["OssRegionId"].empty()) {
      ossRegionId = make_shared<string>(boost::any_cast<string>(m["OssRegionId"]));
    }
  }


  virtual ~DescribeBackendInfoResponseBodyBackendInfoBackendModelsBackendConfigOssConfig() = default;
};
class DescribeBackendInfoResponseBodyBackendInfoBackendModelsBackendConfigVpcConfig : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> name{};
  shared_ptr<long> port{};
  shared_ptr<string> vpcAccessId{};
  shared_ptr<string> vpcId{};
  shared_ptr<string> vpcScheme{};
  shared_ptr<string> vpcTargetHostName{};

  DescribeBackendInfoResponseBodyBackendInfoBackendModelsBackendConfigVpcConfig() {}

  explicit DescribeBackendInfoResponseBodyBackendInfoBackendModelsBackendConfigVpcConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (vpcAccessId) {
      res["VpcAccessId"] = boost::any(*vpcAccessId);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    if (vpcScheme) {
      res["VpcScheme"] = boost::any(*vpcScheme);
    }
    if (vpcTargetHostName) {
      res["VpcTargetHostName"] = boost::any(*vpcTargetHostName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<long>(boost::any_cast<long>(m["Port"]));
    }
    if (m.find("VpcAccessId") != m.end() && !m["VpcAccessId"].empty()) {
      vpcAccessId = make_shared<string>(boost::any_cast<string>(m["VpcAccessId"]));
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
    if (m.find("VpcScheme") != m.end() && !m["VpcScheme"].empty()) {
      vpcScheme = make_shared<string>(boost::any_cast<string>(m["VpcScheme"]));
    }
    if (m.find("VpcTargetHostName") != m.end() && !m["VpcTargetHostName"].empty()) {
      vpcTargetHostName = make_shared<string>(boost::any_cast<string>(m["VpcTargetHostName"]));
    }
  }


  virtual ~DescribeBackendInfoResponseBodyBackendInfoBackendModelsBackendConfigVpcConfig() = default;
};
class DescribeBackendInfoResponseBodyBackendInfoBackendModelsBackendConfig : public Darabonba::Model {
public:
  shared_ptr<DescribeBackendInfoResponseBodyBackendInfoBackendModelsBackendConfigDiscoveryConfig> discoveryConfig{};
  shared_ptr<DescribeBackendInfoResponseBodyBackendInfoBackendModelsBackendConfigEdasConfig> edasConfig{};
  shared_ptr<DescribeBackendInfoResponseBodyBackendInfoBackendModelsBackendConfigEventBridgeConfig> eventBridgeConfig{};
  shared_ptr<DescribeBackendInfoResponseBodyBackendInfoBackendModelsBackendConfigFunctionComputeConfig> functionComputeConfig{};
  shared_ptr<string> httpTargetHostName{};
  shared_ptr<DescribeBackendInfoResponseBodyBackendInfoBackendModelsBackendConfigMockConfig> mockConfig{};
  shared_ptr<DescribeBackendInfoResponseBodyBackendInfoBackendModelsBackendConfigOssConfig> ossConfig{};
  shared_ptr<string> serviceAddress{};
  shared_ptr<long> serviceTimeout{};
  shared_ptr<string> type{};
  shared_ptr<DescribeBackendInfoResponseBodyBackendInfoBackendModelsBackendConfigVpcConfig> vpcConfig{};

  DescribeBackendInfoResponseBodyBackendInfoBackendModelsBackendConfig() {}

  explicit DescribeBackendInfoResponseBodyBackendInfoBackendModelsBackendConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (discoveryConfig) {
      res["DiscoveryConfig"] = discoveryConfig ? boost::any(discoveryConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (edasConfig) {
      res["EdasConfig"] = edasConfig ? boost::any(edasConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (eventBridgeConfig) {
      res["EventBridgeConfig"] = eventBridgeConfig ? boost::any(eventBridgeConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (functionComputeConfig) {
      res["FunctionComputeConfig"] = functionComputeConfig ? boost::any(functionComputeConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpTargetHostName) {
      res["HttpTargetHostName"] = boost::any(*httpTargetHostName);
    }
    if (mockConfig) {
      res["MockConfig"] = mockConfig ? boost::any(mockConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (ossConfig) {
      res["OssConfig"] = ossConfig ? boost::any(ossConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (serviceAddress) {
      res["ServiceAddress"] = boost::any(*serviceAddress);
    }
    if (serviceTimeout) {
      res["ServiceTimeout"] = boost::any(*serviceTimeout);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (vpcConfig) {
      res["VpcConfig"] = vpcConfig ? boost::any(vpcConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DiscoveryConfig") != m.end() && !m["DiscoveryConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["DiscoveryConfig"].type()) {
        DescribeBackendInfoResponseBodyBackendInfoBackendModelsBackendConfigDiscoveryConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DiscoveryConfig"]));
        discoveryConfig = make_shared<DescribeBackendInfoResponseBodyBackendInfoBackendModelsBackendConfigDiscoveryConfig>(model1);
      }
    }
    if (m.find("EdasConfig") != m.end() && !m["EdasConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["EdasConfig"].type()) {
        DescribeBackendInfoResponseBodyBackendInfoBackendModelsBackendConfigEdasConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["EdasConfig"]));
        edasConfig = make_shared<DescribeBackendInfoResponseBodyBackendInfoBackendModelsBackendConfigEdasConfig>(model1);
      }
    }
    if (m.find("EventBridgeConfig") != m.end() && !m["EventBridgeConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["EventBridgeConfig"].type()) {
        DescribeBackendInfoResponseBodyBackendInfoBackendModelsBackendConfigEventBridgeConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["EventBridgeConfig"]));
        eventBridgeConfig = make_shared<DescribeBackendInfoResponseBodyBackendInfoBackendModelsBackendConfigEventBridgeConfig>(model1);
      }
    }
    if (m.find("FunctionComputeConfig") != m.end() && !m["FunctionComputeConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["FunctionComputeConfig"].type()) {
        DescribeBackendInfoResponseBodyBackendInfoBackendModelsBackendConfigFunctionComputeConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FunctionComputeConfig"]));
        functionComputeConfig = make_shared<DescribeBackendInfoResponseBodyBackendInfoBackendModelsBackendConfigFunctionComputeConfig>(model1);
      }
    }
    if (m.find("HttpTargetHostName") != m.end() && !m["HttpTargetHostName"].empty()) {
      httpTargetHostName = make_shared<string>(boost::any_cast<string>(m["HttpTargetHostName"]));
    }
    if (m.find("MockConfig") != m.end() && !m["MockConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["MockConfig"].type()) {
        DescribeBackendInfoResponseBodyBackendInfoBackendModelsBackendConfigMockConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MockConfig"]));
        mockConfig = make_shared<DescribeBackendInfoResponseBodyBackendInfoBackendModelsBackendConfigMockConfig>(model1);
      }
    }
    if (m.find("OssConfig") != m.end() && !m["OssConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["OssConfig"].type()) {
        DescribeBackendInfoResponseBodyBackendInfoBackendModelsBackendConfigOssConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OssConfig"]));
        ossConfig = make_shared<DescribeBackendInfoResponseBodyBackendInfoBackendModelsBackendConfigOssConfig>(model1);
      }
    }
    if (m.find("ServiceAddress") != m.end() && !m["ServiceAddress"].empty()) {
      serviceAddress = make_shared<string>(boost::any_cast<string>(m["ServiceAddress"]));
    }
    if (m.find("ServiceTimeout") != m.end() && !m["ServiceTimeout"].empty()) {
      serviceTimeout = make_shared<long>(boost::any_cast<long>(m["ServiceTimeout"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("VpcConfig") != m.end() && !m["VpcConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["VpcConfig"].type()) {
        DescribeBackendInfoResponseBodyBackendInfoBackendModelsBackendConfigVpcConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["VpcConfig"]));
        vpcConfig = make_shared<DescribeBackendInfoResponseBodyBackendInfoBackendModelsBackendConfigVpcConfig>(model1);
      }
    }
  }


  virtual ~DescribeBackendInfoResponseBodyBackendInfoBackendModelsBackendConfig() = default;
};
class DescribeBackendInfoResponseBodyBackendInfoBackendModels : public Darabonba::Model {
public:
  shared_ptr<DescribeBackendInfoResponseBodyBackendInfoBackendModelsBackendConfig> backendConfig{};
  shared_ptr<string> backendModelId{};
  shared_ptr<string> description{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> gmtModified{};
  shared_ptr<string> stageModeId{};
  shared_ptr<string> stageName{};

  DescribeBackendInfoResponseBodyBackendInfoBackendModels() {}

  explicit DescribeBackendInfoResponseBodyBackendInfoBackendModels(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (backendConfig) {
      res["BackendConfig"] = backendConfig ? boost::any(backendConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (backendModelId) {
      res["BackendModelId"] = boost::any(*backendModelId);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (stageModeId) {
      res["StageModeId"] = boost::any(*stageModeId);
    }
    if (stageName) {
      res["StageName"] = boost::any(*stageName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BackendConfig") != m.end() && !m["BackendConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["BackendConfig"].type()) {
        DescribeBackendInfoResponseBodyBackendInfoBackendModelsBackendConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["BackendConfig"]));
        backendConfig = make_shared<DescribeBackendInfoResponseBodyBackendInfoBackendModelsBackendConfig>(model1);
      }
    }
    if (m.find("BackendModelId") != m.end() && !m["BackendModelId"].empty()) {
      backendModelId = make_shared<string>(boost::any_cast<string>(m["BackendModelId"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["GmtCreate"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<string>(boost::any_cast<string>(m["GmtModified"]));
    }
    if (m.find("StageModeId") != m.end() && !m["StageModeId"].empty()) {
      stageModeId = make_shared<string>(boost::any_cast<string>(m["StageModeId"]));
    }
    if (m.find("StageName") != m.end() && !m["StageName"].empty()) {
      stageName = make_shared<string>(boost::any_cast<string>(m["StageName"]));
    }
  }


  virtual ~DescribeBackendInfoResponseBodyBackendInfoBackendModels() = default;
};
class DescribeBackendInfoResponseBodyBackendInfo : public Darabonba::Model {
public:
  shared_ptr<string> backendId{};
  shared_ptr<vector<DescribeBackendInfoResponseBodyBackendInfoBackendModels>> backendModels{};
  shared_ptr<string> backendName{};
  shared_ptr<string> backendType{};
  shared_ptr<string> createdTime{};
  shared_ptr<string> description{};
  shared_ptr<string> modifiedTime{};

  DescribeBackendInfoResponseBodyBackendInfo() {}

  explicit DescribeBackendInfoResponseBodyBackendInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (backendId) {
      res["BackendId"] = boost::any(*backendId);
    }
    if (backendModels) {
      vector<boost::any> temp1;
      for(auto item1:*backendModels){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["BackendModels"] = boost::any(temp1);
    }
    if (backendName) {
      res["BackendName"] = boost::any(*backendName);
    }
    if (backendType) {
      res["BackendType"] = boost::any(*backendType);
    }
    if (createdTime) {
      res["CreatedTime"] = boost::any(*createdTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (modifiedTime) {
      res["ModifiedTime"] = boost::any(*modifiedTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BackendId") != m.end() && !m["BackendId"].empty()) {
      backendId = make_shared<string>(boost::any_cast<string>(m["BackendId"]));
    }
    if (m.find("BackendModels") != m.end() && !m["BackendModels"].empty()) {
      if (typeid(vector<boost::any>) == m["BackendModels"].type()) {
        vector<DescribeBackendInfoResponseBodyBackendInfoBackendModels> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["BackendModels"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeBackendInfoResponseBodyBackendInfoBackendModels model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        backendModels = make_shared<vector<DescribeBackendInfoResponseBodyBackendInfoBackendModels>>(expect1);
      }
    }
    if (m.find("BackendName") != m.end() && !m["BackendName"].empty()) {
      backendName = make_shared<string>(boost::any_cast<string>(m["BackendName"]));
    }
    if (m.find("BackendType") != m.end() && !m["BackendType"].empty()) {
      backendType = make_shared<string>(boost::any_cast<string>(m["BackendType"]));
    }
    if (m.find("CreatedTime") != m.end() && !m["CreatedTime"].empty()) {
      createdTime = make_shared<string>(boost::any_cast<string>(m["CreatedTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("ModifiedTime") != m.end() && !m["ModifiedTime"].empty()) {
      modifiedTime = make_shared<string>(boost::any_cast<string>(m["ModifiedTime"]));
    }
  }


  virtual ~DescribeBackendInfoResponseBodyBackendInfo() = default;
};
class DescribeBackendInfoResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeBackendInfoResponseBodyBackendInfo> backendInfo{};
  shared_ptr<string> requestId{};

  DescribeBackendInfoResponseBody() {}

  explicit DescribeBackendInfoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (backendInfo) {
      res["BackendInfo"] = backendInfo ? boost::any(backendInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BackendInfo") != m.end() && !m["BackendInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["BackendInfo"].type()) {
        DescribeBackendInfoResponseBodyBackendInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["BackendInfo"]));
        backendInfo = make_shared<DescribeBackendInfoResponseBodyBackendInfo>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeBackendInfoResponseBody() = default;
};
class DescribeBackendInfoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeBackendInfoResponseBody> body{};

  DescribeBackendInfoResponse() {}

  explicit DescribeBackendInfoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeBackendInfoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeBackendInfoResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeBackendInfoResponse() = default;
};
class DescribeBackendListRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  DescribeBackendListRequestTag() {}

  explicit DescribeBackendListRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeBackendListRequestTag() = default;
};
class DescribeBackendListRequest : public Darabonba::Model {
public:
  shared_ptr<string> backendName{};
  shared_ptr<string> backendType{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> securityToken{};
  shared_ptr<vector<DescribeBackendListRequestTag>> tag{};

  DescribeBackendListRequest() {}

  explicit DescribeBackendListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (backendName) {
      res["BackendName"] = boost::any(*backendName);
    }
    if (backendType) {
      res["BackendType"] = boost::any(*backendType);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BackendName") != m.end() && !m["BackendName"].empty()) {
      backendName = make_shared<string>(boost::any_cast<string>(m["BackendName"]));
    }
    if (m.find("BackendType") != m.end() && !m["BackendType"].empty()) {
      backendType = make_shared<string>(boost::any_cast<string>(m["BackendType"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<DescribeBackendListRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeBackendListRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<DescribeBackendListRequestTag>>(expect1);
      }
    }
  }


  virtual ~DescribeBackendListRequest() = default;
};
class DescribeBackendListResponseBodyBackendInfoListTags : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  DescribeBackendListResponseBodyBackendInfoListTags() {}

  explicit DescribeBackendListResponseBodyBackendInfoListTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeBackendListResponseBodyBackendInfoListTags() = default;
};
class DescribeBackendListResponseBodyBackendInfoList : public Darabonba::Model {
public:
  shared_ptr<string> backendId{};
  shared_ptr<string> backendName{};
  shared_ptr<string> backendType{};
  shared_ptr<string> createdTime{};
  shared_ptr<string> description{};
  shared_ptr<string> modifiedTime{};
  shared_ptr<vector<DescribeBackendListResponseBodyBackendInfoListTags>> tags{};

  DescribeBackendListResponseBodyBackendInfoList() {}

  explicit DescribeBackendListResponseBodyBackendInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (backendId) {
      res["BackendId"] = boost::any(*backendId);
    }
    if (backendName) {
      res["BackendName"] = boost::any(*backendName);
    }
    if (backendType) {
      res["BackendType"] = boost::any(*backendType);
    }
    if (createdTime) {
      res["CreatedTime"] = boost::any(*createdTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (modifiedTime) {
      res["ModifiedTime"] = boost::any(*modifiedTime);
    }
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tags"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BackendId") != m.end() && !m["BackendId"].empty()) {
      backendId = make_shared<string>(boost::any_cast<string>(m["BackendId"]));
    }
    if (m.find("BackendName") != m.end() && !m["BackendName"].empty()) {
      backendName = make_shared<string>(boost::any_cast<string>(m["BackendName"]));
    }
    if (m.find("BackendType") != m.end() && !m["BackendType"].empty()) {
      backendType = make_shared<string>(boost::any_cast<string>(m["BackendType"]));
    }
    if (m.find("CreatedTime") != m.end() && !m["CreatedTime"].empty()) {
      createdTime = make_shared<string>(boost::any_cast<string>(m["CreatedTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("ModifiedTime") != m.end() && !m["ModifiedTime"].empty()) {
      modifiedTime = make_shared<string>(boost::any_cast<string>(m["ModifiedTime"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(vector<boost::any>) == m["Tags"].type()) {
        vector<DescribeBackendListResponseBodyBackendInfoListTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeBackendListResponseBodyBackendInfoListTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<DescribeBackendListResponseBodyBackendInfoListTags>>(expect1);
      }
    }
  }


  virtual ~DescribeBackendListResponseBodyBackendInfoList() = default;
};
class DescribeBackendListResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeBackendListResponseBodyBackendInfoList>> backendInfoList{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeBackendListResponseBody() {}

  explicit DescribeBackendListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (backendInfoList) {
      vector<boost::any> temp1;
      for(auto item1:*backendInfoList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["BackendInfoList"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BackendInfoList") != m.end() && !m["BackendInfoList"].empty()) {
      if (typeid(vector<boost::any>) == m["BackendInfoList"].type()) {
        vector<DescribeBackendListResponseBodyBackendInfoList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["BackendInfoList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeBackendListResponseBodyBackendInfoList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        backendInfoList = make_shared<vector<DescribeBackendListResponseBodyBackendInfoList>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeBackendListResponseBody() = default;
};
class DescribeBackendListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeBackendListResponseBody> body{};

  DescribeBackendListResponse() {}

  explicit DescribeBackendListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeBackendListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeBackendListResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeBackendListResponse() = default;
};
class DescribeDatasetInfoRequest : public Darabonba::Model {
public:
  shared_ptr<string> datasetId{};
  shared_ptr<string> securityToken{};

  DescribeDatasetInfoRequest() {}

  explicit DescribeDatasetInfoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (datasetId) {
      res["DatasetId"] = boost::any(*datasetId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DatasetId") != m.end() && !m["DatasetId"].empty()) {
      datasetId = make_shared<string>(boost::any_cast<string>(m["DatasetId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~DescribeDatasetInfoRequest() = default;
};
class DescribeDatasetInfoResponseBodyDatasetInfo : public Darabonba::Model {
public:
  shared_ptr<string> createdTime{};
  shared_ptr<string> datasetId{};
  shared_ptr<string> datasetName{};
  shared_ptr<string> datasetType{};
  shared_ptr<string> modifiedTime{};

  DescribeDatasetInfoResponseBodyDatasetInfo() {}

  explicit DescribeDatasetInfoResponseBodyDatasetInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createdTime) {
      res["CreatedTime"] = boost::any(*createdTime);
    }
    if (datasetId) {
      res["DatasetId"] = boost::any(*datasetId);
    }
    if (datasetName) {
      res["DatasetName"] = boost::any(*datasetName);
    }
    if (datasetType) {
      res["DatasetType"] = boost::any(*datasetType);
    }
    if (modifiedTime) {
      res["ModifiedTime"] = boost::any(*modifiedTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreatedTime") != m.end() && !m["CreatedTime"].empty()) {
      createdTime = make_shared<string>(boost::any_cast<string>(m["CreatedTime"]));
    }
    if (m.find("DatasetId") != m.end() && !m["DatasetId"].empty()) {
      datasetId = make_shared<string>(boost::any_cast<string>(m["DatasetId"]));
    }
    if (m.find("DatasetName") != m.end() && !m["DatasetName"].empty()) {
      datasetName = make_shared<string>(boost::any_cast<string>(m["DatasetName"]));
    }
    if (m.find("DatasetType") != m.end() && !m["DatasetType"].empty()) {
      datasetType = make_shared<string>(boost::any_cast<string>(m["DatasetType"]));
    }
    if (m.find("ModifiedTime") != m.end() && !m["ModifiedTime"].empty()) {
      modifiedTime = make_shared<string>(boost::any_cast<string>(m["ModifiedTime"]));
    }
  }


  virtual ~DescribeDatasetInfoResponseBodyDatasetInfo() = default;
};
class DescribeDatasetInfoResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeDatasetInfoResponseBodyDatasetInfo> datasetInfo{};
  shared_ptr<string> requestId{};

  DescribeDatasetInfoResponseBody() {}

  explicit DescribeDatasetInfoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (datasetInfo) {
      res["DatasetInfo"] = datasetInfo ? boost::any(datasetInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DatasetInfo") != m.end() && !m["DatasetInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["DatasetInfo"].type()) {
        DescribeDatasetInfoResponseBodyDatasetInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DatasetInfo"]));
        datasetInfo = make_shared<DescribeDatasetInfoResponseBodyDatasetInfo>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeDatasetInfoResponseBody() = default;
};
class DescribeDatasetInfoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDatasetInfoResponseBody> body{};

  DescribeDatasetInfoResponse() {}

  explicit DescribeDatasetInfoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDatasetInfoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDatasetInfoResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDatasetInfoResponse() = default;
};
class DescribeDatasetItemInfoRequest : public Darabonba::Model {
public:
  shared_ptr<string> datasetId{};
  shared_ptr<string> datasetItemId{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> value{};

  DescribeDatasetItemInfoRequest() {}

  explicit DescribeDatasetItemInfoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (datasetId) {
      res["DatasetId"] = boost::any(*datasetId);
    }
    if (datasetItemId) {
      res["DatasetItemId"] = boost::any(*datasetItemId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DatasetId") != m.end() && !m["DatasetId"].empty()) {
      datasetId = make_shared<string>(boost::any_cast<string>(m["DatasetId"]));
    }
    if (m.find("DatasetItemId") != m.end() && !m["DatasetItemId"].empty()) {
      datasetItemId = make_shared<string>(boost::any_cast<string>(m["DatasetItemId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeDatasetItemInfoRequest() = default;
};
class DescribeDatasetItemInfoResponseBodyDatasetItemInfo : public Darabonba::Model {
public:
  shared_ptr<string> createdTime{};
  shared_ptr<string> datasetId{};
  shared_ptr<string> datasetItemId{};
  shared_ptr<string> description{};
  shared_ptr<string> expiredTime{};
  shared_ptr<string> modifiedTime{};
  shared_ptr<string> value{};

  DescribeDatasetItemInfoResponseBodyDatasetItemInfo() {}

  explicit DescribeDatasetItemInfoResponseBodyDatasetItemInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createdTime) {
      res["CreatedTime"] = boost::any(*createdTime);
    }
    if (datasetId) {
      res["DatasetId"] = boost::any(*datasetId);
    }
    if (datasetItemId) {
      res["DatasetItemId"] = boost::any(*datasetItemId);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (expiredTime) {
      res["ExpiredTime"] = boost::any(*expiredTime);
    }
    if (modifiedTime) {
      res["ModifiedTime"] = boost::any(*modifiedTime);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreatedTime") != m.end() && !m["CreatedTime"].empty()) {
      createdTime = make_shared<string>(boost::any_cast<string>(m["CreatedTime"]));
    }
    if (m.find("DatasetId") != m.end() && !m["DatasetId"].empty()) {
      datasetId = make_shared<string>(boost::any_cast<string>(m["DatasetId"]));
    }
    if (m.find("DatasetItemId") != m.end() && !m["DatasetItemId"].empty()) {
      datasetItemId = make_shared<string>(boost::any_cast<string>(m["DatasetItemId"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("ExpiredTime") != m.end() && !m["ExpiredTime"].empty()) {
      expiredTime = make_shared<string>(boost::any_cast<string>(m["ExpiredTime"]));
    }
    if (m.find("ModifiedTime") != m.end() && !m["ModifiedTime"].empty()) {
      modifiedTime = make_shared<string>(boost::any_cast<string>(m["ModifiedTime"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeDatasetItemInfoResponseBodyDatasetItemInfo() = default;
};
class DescribeDatasetItemInfoResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeDatasetItemInfoResponseBodyDatasetItemInfo> datasetItemInfo{};
  shared_ptr<string> requestId{};

  DescribeDatasetItemInfoResponseBody() {}

  explicit DescribeDatasetItemInfoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (datasetItemInfo) {
      res["DatasetItemInfo"] = datasetItemInfo ? boost::any(datasetItemInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DatasetItemInfo") != m.end() && !m["DatasetItemInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["DatasetItemInfo"].type()) {
        DescribeDatasetItemInfoResponseBodyDatasetItemInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DatasetItemInfo"]));
        datasetItemInfo = make_shared<DescribeDatasetItemInfoResponseBodyDatasetItemInfo>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeDatasetItemInfoResponseBody() = default;
};
class DescribeDatasetItemInfoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDatasetItemInfoResponseBody> body{};

  DescribeDatasetItemInfoResponse() {}

  explicit DescribeDatasetItemInfoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDatasetItemInfoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDatasetItemInfoResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDatasetItemInfoResponse() = default;
};
class DescribeDatasetItemListRequest : public Darabonba::Model {
public:
  shared_ptr<string> datasetId{};
  shared_ptr<string> datasetItemIds{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> securityToken{};

  DescribeDatasetItemListRequest() {}

  explicit DescribeDatasetItemListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (datasetId) {
      res["DatasetId"] = boost::any(*datasetId);
    }
    if (datasetItemIds) {
      res["DatasetItemIds"] = boost::any(*datasetItemIds);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DatasetId") != m.end() && !m["DatasetId"].empty()) {
      datasetId = make_shared<string>(boost::any_cast<string>(m["DatasetId"]));
    }
    if (m.find("DatasetItemIds") != m.end() && !m["DatasetItemIds"].empty()) {
      datasetItemIds = make_shared<string>(boost::any_cast<string>(m["DatasetItemIds"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~DescribeDatasetItemListRequest() = default;
};
class DescribeDatasetItemListResponseBodyDatasetItemInfoList : public Darabonba::Model {
public:
  shared_ptr<string> createdTime{};
  shared_ptr<string> datasetId{};
  shared_ptr<string> datasetItemId{};
  shared_ptr<string> description{};
  shared_ptr<string> expiredTime{};
  shared_ptr<string> modifiedTime{};
  shared_ptr<string> value{};

  DescribeDatasetItemListResponseBodyDatasetItemInfoList() {}

  explicit DescribeDatasetItemListResponseBodyDatasetItemInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createdTime) {
      res["CreatedTime"] = boost::any(*createdTime);
    }
    if (datasetId) {
      res["DatasetId"] = boost::any(*datasetId);
    }
    if (datasetItemId) {
      res["DatasetItemId"] = boost::any(*datasetItemId);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (expiredTime) {
      res["ExpiredTime"] = boost::any(*expiredTime);
    }
    if (modifiedTime) {
      res["ModifiedTime"] = boost::any(*modifiedTime);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreatedTime") != m.end() && !m["CreatedTime"].empty()) {
      createdTime = make_shared<string>(boost::any_cast<string>(m["CreatedTime"]));
    }
    if (m.find("DatasetId") != m.end() && !m["DatasetId"].empty()) {
      datasetId = make_shared<string>(boost::any_cast<string>(m["DatasetId"]));
    }
    if (m.find("DatasetItemId") != m.end() && !m["DatasetItemId"].empty()) {
      datasetItemId = make_shared<string>(boost::any_cast<string>(m["DatasetItemId"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("ExpiredTime") != m.end() && !m["ExpiredTime"].empty()) {
      expiredTime = make_shared<string>(boost::any_cast<string>(m["ExpiredTime"]));
    }
    if (m.find("ModifiedTime") != m.end() && !m["ModifiedTime"].empty()) {
      modifiedTime = make_shared<string>(boost::any_cast<string>(m["ModifiedTime"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeDatasetItemListResponseBodyDatasetItemInfoList() = default;
};
class DescribeDatasetItemListResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDatasetItemListResponseBodyDatasetItemInfoList>> datasetItemInfoList{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeDatasetItemListResponseBody() {}

  explicit DescribeDatasetItemListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (datasetItemInfoList) {
      vector<boost::any> temp1;
      for(auto item1:*datasetItemInfoList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DatasetItemInfoList"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DatasetItemInfoList") != m.end() && !m["DatasetItemInfoList"].empty()) {
      if (typeid(vector<boost::any>) == m["DatasetItemInfoList"].type()) {
        vector<DescribeDatasetItemListResponseBodyDatasetItemInfoList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DatasetItemInfoList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDatasetItemListResponseBodyDatasetItemInfoList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        datasetItemInfoList = make_shared<vector<DescribeDatasetItemListResponseBodyDatasetItemInfoList>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeDatasetItemListResponseBody() = default;
};
class DescribeDatasetItemListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDatasetItemListResponseBody> body{};

  DescribeDatasetItemListResponse() {}

  explicit DescribeDatasetItemListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDatasetItemListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDatasetItemListResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDatasetItemListResponse() = default;
};
class DescribeDatasetListRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  DescribeDatasetListRequestTag() {}

  explicit DescribeDatasetListRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeDatasetListRequestTag() = default;
};
class DescribeDatasetListRequest : public Darabonba::Model {
public:
  shared_ptr<string> datasetIds{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> securityToken{};
  shared_ptr<vector<DescribeDatasetListRequestTag>> tag{};

  DescribeDatasetListRequest() {}

  explicit DescribeDatasetListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (datasetIds) {
      res["DatasetIds"] = boost::any(*datasetIds);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DatasetIds") != m.end() && !m["DatasetIds"].empty()) {
      datasetIds = make_shared<string>(boost::any_cast<string>(m["DatasetIds"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<DescribeDatasetListRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDatasetListRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<DescribeDatasetListRequestTag>>(expect1);
      }
    }
  }


  virtual ~DescribeDatasetListRequest() = default;
};
class DescribeDatasetListResponseBodyDatasetInfoListTags : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  DescribeDatasetListResponseBodyDatasetInfoListTags() {}

  explicit DescribeDatasetListResponseBodyDatasetInfoListTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeDatasetListResponseBodyDatasetInfoListTags() = default;
};
class DescribeDatasetListResponseBodyDatasetInfoList : public Darabonba::Model {
public:
  shared_ptr<string> createdTime{};
  shared_ptr<string> datasetId{};
  shared_ptr<string> datasetName{};
  shared_ptr<string> datasetType{};
  shared_ptr<string> modifiedTime{};
  shared_ptr<vector<DescribeDatasetListResponseBodyDatasetInfoListTags>> tags{};

  DescribeDatasetListResponseBodyDatasetInfoList() {}

  explicit DescribeDatasetListResponseBodyDatasetInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createdTime) {
      res["CreatedTime"] = boost::any(*createdTime);
    }
    if (datasetId) {
      res["DatasetId"] = boost::any(*datasetId);
    }
    if (datasetName) {
      res["DatasetName"] = boost::any(*datasetName);
    }
    if (datasetType) {
      res["DatasetType"] = boost::any(*datasetType);
    }
    if (modifiedTime) {
      res["ModifiedTime"] = boost::any(*modifiedTime);
    }
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tags"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreatedTime") != m.end() && !m["CreatedTime"].empty()) {
      createdTime = make_shared<string>(boost::any_cast<string>(m["CreatedTime"]));
    }
    if (m.find("DatasetId") != m.end() && !m["DatasetId"].empty()) {
      datasetId = make_shared<string>(boost::any_cast<string>(m["DatasetId"]));
    }
    if (m.find("DatasetName") != m.end() && !m["DatasetName"].empty()) {
      datasetName = make_shared<string>(boost::any_cast<string>(m["DatasetName"]));
    }
    if (m.find("DatasetType") != m.end() && !m["DatasetType"].empty()) {
      datasetType = make_shared<string>(boost::any_cast<string>(m["DatasetType"]));
    }
    if (m.find("ModifiedTime") != m.end() && !m["ModifiedTime"].empty()) {
      modifiedTime = make_shared<string>(boost::any_cast<string>(m["ModifiedTime"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(vector<boost::any>) == m["Tags"].type()) {
        vector<DescribeDatasetListResponseBodyDatasetInfoListTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDatasetListResponseBodyDatasetInfoListTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<DescribeDatasetListResponseBodyDatasetInfoListTags>>(expect1);
      }
    }
  }


  virtual ~DescribeDatasetListResponseBodyDatasetInfoList() = default;
};
class DescribeDatasetListResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDatasetListResponseBodyDatasetInfoList>> datasetInfoList{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeDatasetListResponseBody() {}

  explicit DescribeDatasetListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (datasetInfoList) {
      vector<boost::any> temp1;
      for(auto item1:*datasetInfoList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DatasetInfoList"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DatasetInfoList") != m.end() && !m["DatasetInfoList"].empty()) {
      if (typeid(vector<boost::any>) == m["DatasetInfoList"].type()) {
        vector<DescribeDatasetListResponseBodyDatasetInfoList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DatasetInfoList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDatasetListResponseBodyDatasetInfoList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        datasetInfoList = make_shared<vector<DescribeDatasetListResponseBodyDatasetInfoList>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeDatasetListResponseBody() = default;
};
class DescribeDatasetListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDatasetListResponseBody> body{};

  DescribeDatasetListResponse() {}

  explicit DescribeDatasetListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDatasetListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDatasetListResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDatasetListResponse() = default;
};
class DescribeDeployApiTaskRequest : public Darabonba::Model {
public:
  shared_ptr<string> operationUid{};
  shared_ptr<string> securityToken{};

  DescribeDeployApiTaskRequest() {}

  explicit DescribeDeployApiTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (operationUid) {
      res["OperationUid"] = boost::any(*operationUid);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OperationUid") != m.end() && !m["OperationUid"].empty()) {
      operationUid = make_shared<string>(boost::any_cast<string>(m["OperationUid"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~DescribeDeployApiTaskRequest() = default;
};
class DescribeDeployApiTaskResponseBodyDeployedResultsDeployedResult : public Darabonba::Model {
public:
  shared_ptr<string> apiUid{};
  shared_ptr<string> deployedStatus{};
  shared_ptr<string> errorMsg{};
  shared_ptr<string> groupId{};
  shared_ptr<string> stageName{};

  DescribeDeployApiTaskResponseBodyDeployedResultsDeployedResult() {}

  explicit DescribeDeployApiTaskResponseBodyDeployedResultsDeployedResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiUid) {
      res["ApiUid"] = boost::any(*apiUid);
    }
    if (deployedStatus) {
      res["DeployedStatus"] = boost::any(*deployedStatus);
    }
    if (errorMsg) {
      res["ErrorMsg"] = boost::any(*errorMsg);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (stageName) {
      res["StageName"] = boost::any(*stageName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiUid") != m.end() && !m["ApiUid"].empty()) {
      apiUid = make_shared<string>(boost::any_cast<string>(m["ApiUid"]));
    }
    if (m.find("DeployedStatus") != m.end() && !m["DeployedStatus"].empty()) {
      deployedStatus = make_shared<string>(boost::any_cast<string>(m["DeployedStatus"]));
    }
    if (m.find("ErrorMsg") != m.end() && !m["ErrorMsg"].empty()) {
      errorMsg = make_shared<string>(boost::any_cast<string>(m["ErrorMsg"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("StageName") != m.end() && !m["StageName"].empty()) {
      stageName = make_shared<string>(boost::any_cast<string>(m["StageName"]));
    }
  }


  virtual ~DescribeDeployApiTaskResponseBodyDeployedResultsDeployedResult() = default;
};
class DescribeDeployApiTaskResponseBodyDeployedResults : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDeployApiTaskResponseBodyDeployedResultsDeployedResult>> deployedResult{};

  DescribeDeployApiTaskResponseBodyDeployedResults() {}

  explicit DescribeDeployApiTaskResponseBodyDeployedResults(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deployedResult) {
      vector<boost::any> temp1;
      for(auto item1:*deployedResult){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DeployedResult"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeployedResult") != m.end() && !m["DeployedResult"].empty()) {
      if (typeid(vector<boost::any>) == m["DeployedResult"].type()) {
        vector<DescribeDeployApiTaskResponseBodyDeployedResultsDeployedResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DeployedResult"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDeployApiTaskResponseBodyDeployedResultsDeployedResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        deployedResult = make_shared<vector<DescribeDeployApiTaskResponseBodyDeployedResultsDeployedResult>>(expect1);
      }
    }
  }


  virtual ~DescribeDeployApiTaskResponseBodyDeployedResults() = default;
};
class DescribeDeployApiTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeDeployApiTaskResponseBodyDeployedResults> deployedResults{};
  shared_ptr<string> requestId{};

  DescribeDeployApiTaskResponseBody() {}

  explicit DescribeDeployApiTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deployedResults) {
      res["DeployedResults"] = deployedResults ? boost::any(deployedResults->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeployedResults") != m.end() && !m["DeployedResults"].empty()) {
      if (typeid(map<string, boost::any>) == m["DeployedResults"].type()) {
        DescribeDeployApiTaskResponseBodyDeployedResults model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DeployedResults"]));
        deployedResults = make_shared<DescribeDeployApiTaskResponseBodyDeployedResults>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeDeployApiTaskResponseBody() = default;
};
class DescribeDeployApiTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDeployApiTaskResponseBody> body{};

  DescribeDeployApiTaskResponse() {}

  explicit DescribeDeployApiTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDeployApiTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDeployApiTaskResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDeployApiTaskResponse() = default;
};
class DescribeDeployedApiRequest : public Darabonba::Model {
public:
  shared_ptr<string> apiId{};
  shared_ptr<string> groupId{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> stageName{};

  DescribeDeployedApiRequest() {}

  explicit DescribeDeployedApiRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiId) {
      res["ApiId"] = boost::any(*apiId);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (stageName) {
      res["StageName"] = boost::any(*stageName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiId") != m.end() && !m["ApiId"].empty()) {
      apiId = make_shared<string>(boost::any_cast<string>(m["ApiId"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("StageName") != m.end() && !m["StageName"].empty()) {
      stageName = make_shared<string>(boost::any_cast<string>(m["StageName"]));
    }
  }


  virtual ~DescribeDeployedApiRequest() = default;
};
class DescribeDeployedApiResponseBodyConstantParametersConstantParameter : public Darabonba::Model {
public:
  shared_ptr<string> constantValue{};
  shared_ptr<string> description{};
  shared_ptr<string> location{};
  shared_ptr<string> serviceParameterName{};

  DescribeDeployedApiResponseBodyConstantParametersConstantParameter() {}

  explicit DescribeDeployedApiResponseBodyConstantParametersConstantParameter(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (constantValue) {
      res["ConstantValue"] = boost::any(*constantValue);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (serviceParameterName) {
      res["ServiceParameterName"] = boost::any(*serviceParameterName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConstantValue") != m.end() && !m["ConstantValue"].empty()) {
      constantValue = make_shared<string>(boost::any_cast<string>(m["ConstantValue"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("ServiceParameterName") != m.end() && !m["ServiceParameterName"].empty()) {
      serviceParameterName = make_shared<string>(boost::any_cast<string>(m["ServiceParameterName"]));
    }
  }


  virtual ~DescribeDeployedApiResponseBodyConstantParametersConstantParameter() = default;
};
class DescribeDeployedApiResponseBodyConstantParameters : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDeployedApiResponseBodyConstantParametersConstantParameter>> constantParameter{};

  DescribeDeployedApiResponseBodyConstantParameters() {}

  explicit DescribeDeployedApiResponseBodyConstantParameters(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (constantParameter) {
      vector<boost::any> temp1;
      for(auto item1:*constantParameter){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ConstantParameter"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConstantParameter") != m.end() && !m["ConstantParameter"].empty()) {
      if (typeid(vector<boost::any>) == m["ConstantParameter"].type()) {
        vector<DescribeDeployedApiResponseBodyConstantParametersConstantParameter> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ConstantParameter"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDeployedApiResponseBodyConstantParametersConstantParameter model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        constantParameter = make_shared<vector<DescribeDeployedApiResponseBodyConstantParametersConstantParameter>>(expect1);
      }
    }
  }


  virtual ~DescribeDeployedApiResponseBodyConstantParameters() = default;
};
class DescribeDeployedApiResponseBodyCustomSystemParametersCustomSystemParameter : public Darabonba::Model {
public:
  shared_ptr<string> demoValue{};
  shared_ptr<string> description{};
  shared_ptr<string> location{};
  shared_ptr<string> parameterName{};
  shared_ptr<string> serviceParameterName{};

  DescribeDeployedApiResponseBodyCustomSystemParametersCustomSystemParameter() {}

  explicit DescribeDeployedApiResponseBodyCustomSystemParametersCustomSystemParameter(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (demoValue) {
      res["DemoValue"] = boost::any(*demoValue);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (parameterName) {
      res["ParameterName"] = boost::any(*parameterName);
    }
    if (serviceParameterName) {
      res["ServiceParameterName"] = boost::any(*serviceParameterName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DemoValue") != m.end() && !m["DemoValue"].empty()) {
      demoValue = make_shared<string>(boost::any_cast<string>(m["DemoValue"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("ParameterName") != m.end() && !m["ParameterName"].empty()) {
      parameterName = make_shared<string>(boost::any_cast<string>(m["ParameterName"]));
    }
    if (m.find("ServiceParameterName") != m.end() && !m["ServiceParameterName"].empty()) {
      serviceParameterName = make_shared<string>(boost::any_cast<string>(m["ServiceParameterName"]));
    }
  }


  virtual ~DescribeDeployedApiResponseBodyCustomSystemParametersCustomSystemParameter() = default;
};
class DescribeDeployedApiResponseBodyCustomSystemParameters : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDeployedApiResponseBodyCustomSystemParametersCustomSystemParameter>> customSystemParameter{};

  DescribeDeployedApiResponseBodyCustomSystemParameters() {}

  explicit DescribeDeployedApiResponseBodyCustomSystemParameters(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (customSystemParameter) {
      vector<boost::any> temp1;
      for(auto item1:*customSystemParameter){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CustomSystemParameter"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CustomSystemParameter") != m.end() && !m["CustomSystemParameter"].empty()) {
      if (typeid(vector<boost::any>) == m["CustomSystemParameter"].type()) {
        vector<DescribeDeployedApiResponseBodyCustomSystemParametersCustomSystemParameter> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CustomSystemParameter"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDeployedApiResponseBodyCustomSystemParametersCustomSystemParameter model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        customSystemParameter = make_shared<vector<DescribeDeployedApiResponseBodyCustomSystemParametersCustomSystemParameter>>(expect1);
      }
    }
  }


  virtual ~DescribeDeployedApiResponseBodyCustomSystemParameters() = default;
};
class DescribeDeployedApiResponseBodyErrorCodeSamplesErrorCodeSample : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> description{};
  shared_ptr<string> message{};

  DescribeDeployedApiResponseBodyErrorCodeSamplesErrorCodeSample() {}

  explicit DescribeDeployedApiResponseBodyErrorCodeSamplesErrorCodeSample(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
  }


  virtual ~DescribeDeployedApiResponseBodyErrorCodeSamplesErrorCodeSample() = default;
};
class DescribeDeployedApiResponseBodyErrorCodeSamples : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDeployedApiResponseBodyErrorCodeSamplesErrorCodeSample>> errorCodeSample{};

  DescribeDeployedApiResponseBodyErrorCodeSamples() {}

  explicit DescribeDeployedApiResponseBodyErrorCodeSamples(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCodeSample) {
      vector<boost::any> temp1;
      for(auto item1:*errorCodeSample){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ErrorCodeSample"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCodeSample") != m.end() && !m["ErrorCodeSample"].empty()) {
      if (typeid(vector<boost::any>) == m["ErrorCodeSample"].type()) {
        vector<DescribeDeployedApiResponseBodyErrorCodeSamplesErrorCodeSample> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ErrorCodeSample"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDeployedApiResponseBodyErrorCodeSamplesErrorCodeSample model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        errorCodeSample = make_shared<vector<DescribeDeployedApiResponseBodyErrorCodeSamplesErrorCodeSample>>(expect1);
      }
    }
  }


  virtual ~DescribeDeployedApiResponseBodyErrorCodeSamples() = default;
};
class DescribeDeployedApiResponseBodyOpenIdConnectConfig : public Darabonba::Model {
public:
  shared_ptr<string> idTokenParamName{};
  shared_ptr<string> openIdApiType{};
  shared_ptr<string> publicKey{};
  shared_ptr<string> publicKeyId{};

  DescribeDeployedApiResponseBodyOpenIdConnectConfig() {}

  explicit DescribeDeployedApiResponseBodyOpenIdConnectConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (idTokenParamName) {
      res["IdTokenParamName"] = boost::any(*idTokenParamName);
    }
    if (openIdApiType) {
      res["OpenIdApiType"] = boost::any(*openIdApiType);
    }
    if (publicKey) {
      res["PublicKey"] = boost::any(*publicKey);
    }
    if (publicKeyId) {
      res["PublicKeyId"] = boost::any(*publicKeyId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IdTokenParamName") != m.end() && !m["IdTokenParamName"].empty()) {
      idTokenParamName = make_shared<string>(boost::any_cast<string>(m["IdTokenParamName"]));
    }
    if (m.find("OpenIdApiType") != m.end() && !m["OpenIdApiType"].empty()) {
      openIdApiType = make_shared<string>(boost::any_cast<string>(m["OpenIdApiType"]));
    }
    if (m.find("PublicKey") != m.end() && !m["PublicKey"].empty()) {
      publicKey = make_shared<string>(boost::any_cast<string>(m["PublicKey"]));
    }
    if (m.find("PublicKeyId") != m.end() && !m["PublicKeyId"].empty()) {
      publicKeyId = make_shared<string>(boost::any_cast<string>(m["PublicKeyId"]));
    }
  }


  virtual ~DescribeDeployedApiResponseBodyOpenIdConnectConfig() = default;
};
class DescribeDeployedApiResponseBodyRequestConfig : public Darabonba::Model {
public:
  shared_ptr<string> bodyFormat{};
  shared_ptr<string> bodyModel{};
  shared_ptr<string> postBodyDescription{};
  shared_ptr<string> requestHttpMethod{};
  shared_ptr<string> requestMode{};
  shared_ptr<string> requestPath{};
  shared_ptr<string> requestProtocol{};

  DescribeDeployedApiResponseBodyRequestConfig() {}

  explicit DescribeDeployedApiResponseBodyRequestConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bodyFormat) {
      res["BodyFormat"] = boost::any(*bodyFormat);
    }
    if (bodyModel) {
      res["BodyModel"] = boost::any(*bodyModel);
    }
    if (postBodyDescription) {
      res["PostBodyDescription"] = boost::any(*postBodyDescription);
    }
    if (requestHttpMethod) {
      res["RequestHttpMethod"] = boost::any(*requestHttpMethod);
    }
    if (requestMode) {
      res["RequestMode"] = boost::any(*requestMode);
    }
    if (requestPath) {
      res["RequestPath"] = boost::any(*requestPath);
    }
    if (requestProtocol) {
      res["RequestProtocol"] = boost::any(*requestProtocol);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BodyFormat") != m.end() && !m["BodyFormat"].empty()) {
      bodyFormat = make_shared<string>(boost::any_cast<string>(m["BodyFormat"]));
    }
    if (m.find("BodyModel") != m.end() && !m["BodyModel"].empty()) {
      bodyModel = make_shared<string>(boost::any_cast<string>(m["BodyModel"]));
    }
    if (m.find("PostBodyDescription") != m.end() && !m["PostBodyDescription"].empty()) {
      postBodyDescription = make_shared<string>(boost::any_cast<string>(m["PostBodyDescription"]));
    }
    if (m.find("RequestHttpMethod") != m.end() && !m["RequestHttpMethod"].empty()) {
      requestHttpMethod = make_shared<string>(boost::any_cast<string>(m["RequestHttpMethod"]));
    }
    if (m.find("RequestMode") != m.end() && !m["RequestMode"].empty()) {
      requestMode = make_shared<string>(boost::any_cast<string>(m["RequestMode"]));
    }
    if (m.find("RequestPath") != m.end() && !m["RequestPath"].empty()) {
      requestPath = make_shared<string>(boost::any_cast<string>(m["RequestPath"]));
    }
    if (m.find("RequestProtocol") != m.end() && !m["RequestProtocol"].empty()) {
      requestProtocol = make_shared<string>(boost::any_cast<string>(m["RequestProtocol"]));
    }
  }


  virtual ~DescribeDeployedApiResponseBodyRequestConfig() = default;
};
class DescribeDeployedApiResponseBodyRequestParametersRequestParameter : public Darabonba::Model {
public:
  shared_ptr<string> apiParameterName{};
  shared_ptr<string> arrayItemsType{};
  shared_ptr<string> defaultValue{};
  shared_ptr<string> demoValue{};
  shared_ptr<string> description{};
  shared_ptr<long> docOrder{};
  shared_ptr<string> docShow{};
  shared_ptr<string> enumValue{};
  shared_ptr<string> jsonScheme{};
  shared_ptr<string> location{};
  shared_ptr<long> maxLength{};
  shared_ptr<long> maxValue{};
  shared_ptr<long> minLength{};
  shared_ptr<long> minValue{};
  shared_ptr<string> parameterType{};
  shared_ptr<string> regularExpression{};
  shared_ptr<string> required{};

  DescribeDeployedApiResponseBodyRequestParametersRequestParameter() {}

  explicit DescribeDeployedApiResponseBodyRequestParametersRequestParameter(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiParameterName) {
      res["ApiParameterName"] = boost::any(*apiParameterName);
    }
    if (arrayItemsType) {
      res["ArrayItemsType"] = boost::any(*arrayItemsType);
    }
    if (defaultValue) {
      res["DefaultValue"] = boost::any(*defaultValue);
    }
    if (demoValue) {
      res["DemoValue"] = boost::any(*demoValue);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (docOrder) {
      res["DocOrder"] = boost::any(*docOrder);
    }
    if (docShow) {
      res["DocShow"] = boost::any(*docShow);
    }
    if (enumValue) {
      res["EnumValue"] = boost::any(*enumValue);
    }
    if (jsonScheme) {
      res["JsonScheme"] = boost::any(*jsonScheme);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (maxLength) {
      res["MaxLength"] = boost::any(*maxLength);
    }
    if (maxValue) {
      res["MaxValue"] = boost::any(*maxValue);
    }
    if (minLength) {
      res["MinLength"] = boost::any(*minLength);
    }
    if (minValue) {
      res["MinValue"] = boost::any(*minValue);
    }
    if (parameterType) {
      res["ParameterType"] = boost::any(*parameterType);
    }
    if (regularExpression) {
      res["RegularExpression"] = boost::any(*regularExpression);
    }
    if (required) {
      res["Required"] = boost::any(*required);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiParameterName") != m.end() && !m["ApiParameterName"].empty()) {
      apiParameterName = make_shared<string>(boost::any_cast<string>(m["ApiParameterName"]));
    }
    if (m.find("ArrayItemsType") != m.end() && !m["ArrayItemsType"].empty()) {
      arrayItemsType = make_shared<string>(boost::any_cast<string>(m["ArrayItemsType"]));
    }
    if (m.find("DefaultValue") != m.end() && !m["DefaultValue"].empty()) {
      defaultValue = make_shared<string>(boost::any_cast<string>(m["DefaultValue"]));
    }
    if (m.find("DemoValue") != m.end() && !m["DemoValue"].empty()) {
      demoValue = make_shared<string>(boost::any_cast<string>(m["DemoValue"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DocOrder") != m.end() && !m["DocOrder"].empty()) {
      docOrder = make_shared<long>(boost::any_cast<long>(m["DocOrder"]));
    }
    if (m.find("DocShow") != m.end() && !m["DocShow"].empty()) {
      docShow = make_shared<string>(boost::any_cast<string>(m["DocShow"]));
    }
    if (m.find("EnumValue") != m.end() && !m["EnumValue"].empty()) {
      enumValue = make_shared<string>(boost::any_cast<string>(m["EnumValue"]));
    }
    if (m.find("JsonScheme") != m.end() && !m["JsonScheme"].empty()) {
      jsonScheme = make_shared<string>(boost::any_cast<string>(m["JsonScheme"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("MaxLength") != m.end() && !m["MaxLength"].empty()) {
      maxLength = make_shared<long>(boost::any_cast<long>(m["MaxLength"]));
    }
    if (m.find("MaxValue") != m.end() && !m["MaxValue"].empty()) {
      maxValue = make_shared<long>(boost::any_cast<long>(m["MaxValue"]));
    }
    if (m.find("MinLength") != m.end() && !m["MinLength"].empty()) {
      minLength = make_shared<long>(boost::any_cast<long>(m["MinLength"]));
    }
    if (m.find("MinValue") != m.end() && !m["MinValue"].empty()) {
      minValue = make_shared<long>(boost::any_cast<long>(m["MinValue"]));
    }
    if (m.find("ParameterType") != m.end() && !m["ParameterType"].empty()) {
      parameterType = make_shared<string>(boost::any_cast<string>(m["ParameterType"]));
    }
    if (m.find("RegularExpression") != m.end() && !m["RegularExpression"].empty()) {
      regularExpression = make_shared<string>(boost::any_cast<string>(m["RegularExpression"]));
    }
    if (m.find("Required") != m.end() && !m["Required"].empty()) {
      required = make_shared<string>(boost::any_cast<string>(m["Required"]));
    }
  }


  virtual ~DescribeDeployedApiResponseBodyRequestParametersRequestParameter() = default;
};
class DescribeDeployedApiResponseBodyRequestParameters : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDeployedApiResponseBodyRequestParametersRequestParameter>> requestParameter{};

  DescribeDeployedApiResponseBodyRequestParameters() {}

  explicit DescribeDeployedApiResponseBodyRequestParameters(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestParameter) {
      vector<boost::any> temp1;
      for(auto item1:*requestParameter){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RequestParameter"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestParameter") != m.end() && !m["RequestParameter"].empty()) {
      if (typeid(vector<boost::any>) == m["RequestParameter"].type()) {
        vector<DescribeDeployedApiResponseBodyRequestParametersRequestParameter> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RequestParameter"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDeployedApiResponseBodyRequestParametersRequestParameter model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        requestParameter = make_shared<vector<DescribeDeployedApiResponseBodyRequestParametersRequestParameter>>(expect1);
      }
    }
  }


  virtual ~DescribeDeployedApiResponseBodyRequestParameters() = default;
};
class DescribeDeployedApiResponseBodyResultDescriptionsResultDescription : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<bool> hasChild{};
  shared_ptr<string> id{};
  shared_ptr<string> key{};
  shared_ptr<bool> mandatory{};
  shared_ptr<string> name{};
  shared_ptr<string> pid{};
  shared_ptr<string> type{};

  DescribeDeployedApiResponseBodyResultDescriptionsResultDescription() {}

  explicit DescribeDeployedApiResponseBodyResultDescriptionsResultDescription(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (hasChild) {
      res["HasChild"] = boost::any(*hasChild);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (mandatory) {
      res["Mandatory"] = boost::any(*mandatory);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (pid) {
      res["Pid"] = boost::any(*pid);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("HasChild") != m.end() && !m["HasChild"].empty()) {
      hasChild = make_shared<bool>(boost::any_cast<bool>(m["HasChild"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Mandatory") != m.end() && !m["Mandatory"].empty()) {
      mandatory = make_shared<bool>(boost::any_cast<bool>(m["Mandatory"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Pid") != m.end() && !m["Pid"].empty()) {
      pid = make_shared<string>(boost::any_cast<string>(m["Pid"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DescribeDeployedApiResponseBodyResultDescriptionsResultDescription() = default;
};
class DescribeDeployedApiResponseBodyResultDescriptions : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDeployedApiResponseBodyResultDescriptionsResultDescription>> resultDescription{};

  DescribeDeployedApiResponseBodyResultDescriptions() {}

  explicit DescribeDeployedApiResponseBodyResultDescriptions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resultDescription) {
      vector<boost::any> temp1;
      for(auto item1:*resultDescription){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ResultDescription"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResultDescription") != m.end() && !m["ResultDescription"].empty()) {
      if (typeid(vector<boost::any>) == m["ResultDescription"].type()) {
        vector<DescribeDeployedApiResponseBodyResultDescriptionsResultDescription> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ResultDescription"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDeployedApiResponseBodyResultDescriptionsResultDescription model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        resultDescription = make_shared<vector<DescribeDeployedApiResponseBodyResultDescriptionsResultDescription>>(expect1);
      }
    }
  }


  virtual ~DescribeDeployedApiResponseBodyResultDescriptions() = default;
};
class DescribeDeployedApiResponseBodyServiceConfigFunctionComputeConfig : public Darabonba::Model {
public:
  shared_ptr<string> contentTypeCatagory{};
  shared_ptr<string> contentTypeValue{};
  shared_ptr<string> fcBaseUrl{};
  shared_ptr<string> fcType{};
  shared_ptr<string> functionName{};
  shared_ptr<string> method{};
  shared_ptr<bool> onlyBusinessPath{};
  shared_ptr<string> path{};
  shared_ptr<string> qualifier{};
  shared_ptr<string> regionId{};
  shared_ptr<string> roleArn{};
  shared_ptr<string> serviceName{};

  DescribeDeployedApiResponseBodyServiceConfigFunctionComputeConfig() {}

  explicit DescribeDeployedApiResponseBodyServiceConfigFunctionComputeConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contentTypeCatagory) {
      res["ContentTypeCatagory"] = boost::any(*contentTypeCatagory);
    }
    if (contentTypeValue) {
      res["ContentTypeValue"] = boost::any(*contentTypeValue);
    }
    if (fcBaseUrl) {
      res["FcBaseUrl"] = boost::any(*fcBaseUrl);
    }
    if (fcType) {
      res["FcType"] = boost::any(*fcType);
    }
    if (functionName) {
      res["FunctionName"] = boost::any(*functionName);
    }
    if (method) {
      res["Method"] = boost::any(*method);
    }
    if (onlyBusinessPath) {
      res["OnlyBusinessPath"] = boost::any(*onlyBusinessPath);
    }
    if (path) {
      res["Path"] = boost::any(*path);
    }
    if (qualifier) {
      res["Qualifier"] = boost::any(*qualifier);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (roleArn) {
      res["RoleArn"] = boost::any(*roleArn);
    }
    if (serviceName) {
      res["ServiceName"] = boost::any(*serviceName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ContentTypeCatagory") != m.end() && !m["ContentTypeCatagory"].empty()) {
      contentTypeCatagory = make_shared<string>(boost::any_cast<string>(m["ContentTypeCatagory"]));
    }
    if (m.find("ContentTypeValue") != m.end() && !m["ContentTypeValue"].empty()) {
      contentTypeValue = make_shared<string>(boost::any_cast<string>(m["ContentTypeValue"]));
    }
    if (m.find("FcBaseUrl") != m.end() && !m["FcBaseUrl"].empty()) {
      fcBaseUrl = make_shared<string>(boost::any_cast<string>(m["FcBaseUrl"]));
    }
    if (m.find("FcType") != m.end() && !m["FcType"].empty()) {
      fcType = make_shared<string>(boost::any_cast<string>(m["FcType"]));
    }
    if (m.find("FunctionName") != m.end() && !m["FunctionName"].empty()) {
      functionName = make_shared<string>(boost::any_cast<string>(m["FunctionName"]));
    }
    if (m.find("Method") != m.end() && !m["Method"].empty()) {
      method = make_shared<string>(boost::any_cast<string>(m["Method"]));
    }
    if (m.find("OnlyBusinessPath") != m.end() && !m["OnlyBusinessPath"].empty()) {
      onlyBusinessPath = make_shared<bool>(boost::any_cast<bool>(m["OnlyBusinessPath"]));
    }
    if (m.find("Path") != m.end() && !m["Path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["Path"]));
    }
    if (m.find("Qualifier") != m.end() && !m["Qualifier"].empty()) {
      qualifier = make_shared<string>(boost::any_cast<string>(m["Qualifier"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("RoleArn") != m.end() && !m["RoleArn"].empty()) {
      roleArn = make_shared<string>(boost::any_cast<string>(m["RoleArn"]));
    }
    if (m.find("ServiceName") != m.end() && !m["ServiceName"].empty()) {
      serviceName = make_shared<string>(boost::any_cast<string>(m["ServiceName"]));
    }
  }


  virtual ~DescribeDeployedApiResponseBodyServiceConfigFunctionComputeConfig() = default;
};
class DescribeDeployedApiResponseBodyServiceConfigMockHeadersMockHeader : public Darabonba::Model {
public:
  shared_ptr<string> headerName{};
  shared_ptr<string> headerValue{};

  DescribeDeployedApiResponseBodyServiceConfigMockHeadersMockHeader() {}

  explicit DescribeDeployedApiResponseBodyServiceConfigMockHeadersMockHeader(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headerName) {
      res["HeaderName"] = boost::any(*headerName);
    }
    if (headerValue) {
      res["HeaderValue"] = boost::any(*headerValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HeaderName") != m.end() && !m["HeaderName"].empty()) {
      headerName = make_shared<string>(boost::any_cast<string>(m["HeaderName"]));
    }
    if (m.find("HeaderValue") != m.end() && !m["HeaderValue"].empty()) {
      headerValue = make_shared<string>(boost::any_cast<string>(m["HeaderValue"]));
    }
  }


  virtual ~DescribeDeployedApiResponseBodyServiceConfigMockHeadersMockHeader() = default;
};
class DescribeDeployedApiResponseBodyServiceConfigMockHeaders : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDeployedApiResponseBodyServiceConfigMockHeadersMockHeader>> mockHeader{};

  DescribeDeployedApiResponseBodyServiceConfigMockHeaders() {}

  explicit DescribeDeployedApiResponseBodyServiceConfigMockHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mockHeader) {
      vector<boost::any> temp1;
      for(auto item1:*mockHeader){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["MockHeader"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MockHeader") != m.end() && !m["MockHeader"].empty()) {
      if (typeid(vector<boost::any>) == m["MockHeader"].type()) {
        vector<DescribeDeployedApiResponseBodyServiceConfigMockHeadersMockHeader> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["MockHeader"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDeployedApiResponseBodyServiceConfigMockHeadersMockHeader model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        mockHeader = make_shared<vector<DescribeDeployedApiResponseBodyServiceConfigMockHeadersMockHeader>>(expect1);
      }
    }
  }


  virtual ~DescribeDeployedApiResponseBodyServiceConfigMockHeaders() = default;
};
class DescribeDeployedApiResponseBodyServiceConfigVpcConfig : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> name{};
  shared_ptr<long> port{};
  shared_ptr<string> vpcId{};

  DescribeDeployedApiResponseBodyServiceConfigVpcConfig() {}

  explicit DescribeDeployedApiResponseBodyServiceConfigVpcConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<long>(boost::any_cast<long>(m["Port"]));
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
  }


  virtual ~DescribeDeployedApiResponseBodyServiceConfigVpcConfig() = default;
};
class DescribeDeployedApiResponseBodyServiceConfig : public Darabonba::Model {
public:
  shared_ptr<DescribeDeployedApiResponseBodyServiceConfigFunctionComputeConfig> functionComputeConfig{};
  shared_ptr<string> mock{};
  shared_ptr<DescribeDeployedApiResponseBodyServiceConfigMockHeaders> mockHeaders{};
  shared_ptr<string> mockResult{};
  shared_ptr<long> mockStatusCode{};
  shared_ptr<string> serviceAddress{};
  shared_ptr<string> serviceHttpMethod{};
  shared_ptr<string> servicePath{};
  shared_ptr<string> serviceProtocol{};
  shared_ptr<long> serviceTimeout{};
  shared_ptr<string> serviceVpcEnable{};
  shared_ptr<DescribeDeployedApiResponseBodyServiceConfigVpcConfig> vpcConfig{};
  shared_ptr<string> vpcId{};

  DescribeDeployedApiResponseBodyServiceConfig() {}

  explicit DescribeDeployedApiResponseBodyServiceConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (functionComputeConfig) {
      res["FunctionComputeConfig"] = functionComputeConfig ? boost::any(functionComputeConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (mock) {
      res["Mock"] = boost::any(*mock);
    }
    if (mockHeaders) {
      res["MockHeaders"] = mockHeaders ? boost::any(mockHeaders->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (mockResult) {
      res["MockResult"] = boost::any(*mockResult);
    }
    if (mockStatusCode) {
      res["MockStatusCode"] = boost::any(*mockStatusCode);
    }
    if (serviceAddress) {
      res["ServiceAddress"] = boost::any(*serviceAddress);
    }
    if (serviceHttpMethod) {
      res["ServiceHttpMethod"] = boost::any(*serviceHttpMethod);
    }
    if (servicePath) {
      res["ServicePath"] = boost::any(*servicePath);
    }
    if (serviceProtocol) {
      res["ServiceProtocol"] = boost::any(*serviceProtocol);
    }
    if (serviceTimeout) {
      res["ServiceTimeout"] = boost::any(*serviceTimeout);
    }
    if (serviceVpcEnable) {
      res["ServiceVpcEnable"] = boost::any(*serviceVpcEnable);
    }
    if (vpcConfig) {
      res["VpcConfig"] = vpcConfig ? boost::any(vpcConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FunctionComputeConfig") != m.end() && !m["FunctionComputeConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["FunctionComputeConfig"].type()) {
        DescribeDeployedApiResponseBodyServiceConfigFunctionComputeConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FunctionComputeConfig"]));
        functionComputeConfig = make_shared<DescribeDeployedApiResponseBodyServiceConfigFunctionComputeConfig>(model1);
      }
    }
    if (m.find("Mock") != m.end() && !m["Mock"].empty()) {
      mock = make_shared<string>(boost::any_cast<string>(m["Mock"]));
    }
    if (m.find("MockHeaders") != m.end() && !m["MockHeaders"].empty()) {
      if (typeid(map<string, boost::any>) == m["MockHeaders"].type()) {
        DescribeDeployedApiResponseBodyServiceConfigMockHeaders model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MockHeaders"]));
        mockHeaders = make_shared<DescribeDeployedApiResponseBodyServiceConfigMockHeaders>(model1);
      }
    }
    if (m.find("MockResult") != m.end() && !m["MockResult"].empty()) {
      mockResult = make_shared<string>(boost::any_cast<string>(m["MockResult"]));
    }
    if (m.find("MockStatusCode") != m.end() && !m["MockStatusCode"].empty()) {
      mockStatusCode = make_shared<long>(boost::any_cast<long>(m["MockStatusCode"]));
    }
    if (m.find("ServiceAddress") != m.end() && !m["ServiceAddress"].empty()) {
      serviceAddress = make_shared<string>(boost::any_cast<string>(m["ServiceAddress"]));
    }
    if (m.find("ServiceHttpMethod") != m.end() && !m["ServiceHttpMethod"].empty()) {
      serviceHttpMethod = make_shared<string>(boost::any_cast<string>(m["ServiceHttpMethod"]));
    }
    if (m.find("ServicePath") != m.end() && !m["ServicePath"].empty()) {
      servicePath = make_shared<string>(boost::any_cast<string>(m["ServicePath"]));
    }
    if (m.find("ServiceProtocol") != m.end() && !m["ServiceProtocol"].empty()) {
      serviceProtocol = make_shared<string>(boost::any_cast<string>(m["ServiceProtocol"]));
    }
    if (m.find("ServiceTimeout") != m.end() && !m["ServiceTimeout"].empty()) {
      serviceTimeout = make_shared<long>(boost::any_cast<long>(m["ServiceTimeout"]));
    }
    if (m.find("ServiceVpcEnable") != m.end() && !m["ServiceVpcEnable"].empty()) {
      serviceVpcEnable = make_shared<string>(boost::any_cast<string>(m["ServiceVpcEnable"]));
    }
    if (m.find("VpcConfig") != m.end() && !m["VpcConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["VpcConfig"].type()) {
        DescribeDeployedApiResponseBodyServiceConfigVpcConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["VpcConfig"]));
        vpcConfig = make_shared<DescribeDeployedApiResponseBodyServiceConfigVpcConfig>(model1);
      }
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
  }


  virtual ~DescribeDeployedApiResponseBodyServiceConfig() = default;
};
class DescribeDeployedApiResponseBodyServiceParametersServiceParameter : public Darabonba::Model {
public:
  shared_ptr<string> location{};
  shared_ptr<string> parameterType{};
  shared_ptr<string> serviceParameterName{};

  DescribeDeployedApiResponseBodyServiceParametersServiceParameter() {}

  explicit DescribeDeployedApiResponseBodyServiceParametersServiceParameter(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (parameterType) {
      res["ParameterType"] = boost::any(*parameterType);
    }
    if (serviceParameterName) {
      res["ServiceParameterName"] = boost::any(*serviceParameterName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("ParameterType") != m.end() && !m["ParameterType"].empty()) {
      parameterType = make_shared<string>(boost::any_cast<string>(m["ParameterType"]));
    }
    if (m.find("ServiceParameterName") != m.end() && !m["ServiceParameterName"].empty()) {
      serviceParameterName = make_shared<string>(boost::any_cast<string>(m["ServiceParameterName"]));
    }
  }


  virtual ~DescribeDeployedApiResponseBodyServiceParametersServiceParameter() = default;
};
class DescribeDeployedApiResponseBodyServiceParameters : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDeployedApiResponseBodyServiceParametersServiceParameter>> serviceParameter{};

  DescribeDeployedApiResponseBodyServiceParameters() {}

  explicit DescribeDeployedApiResponseBodyServiceParameters(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (serviceParameter) {
      vector<boost::any> temp1;
      for(auto item1:*serviceParameter){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ServiceParameter"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ServiceParameter") != m.end() && !m["ServiceParameter"].empty()) {
      if (typeid(vector<boost::any>) == m["ServiceParameter"].type()) {
        vector<DescribeDeployedApiResponseBodyServiceParametersServiceParameter> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ServiceParameter"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDeployedApiResponseBodyServiceParametersServiceParameter model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        serviceParameter = make_shared<vector<DescribeDeployedApiResponseBodyServiceParametersServiceParameter>>(expect1);
      }
    }
  }


  virtual ~DescribeDeployedApiResponseBodyServiceParameters() = default;
};
class DescribeDeployedApiResponseBodyServiceParametersMapServiceParameterMap : public Darabonba::Model {
public:
  shared_ptr<string> requestParameterName{};
  shared_ptr<string> serviceParameterName{};

  DescribeDeployedApiResponseBodyServiceParametersMapServiceParameterMap() {}

  explicit DescribeDeployedApiResponseBodyServiceParametersMapServiceParameterMap(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestParameterName) {
      res["RequestParameterName"] = boost::any(*requestParameterName);
    }
    if (serviceParameterName) {
      res["ServiceParameterName"] = boost::any(*serviceParameterName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestParameterName") != m.end() && !m["RequestParameterName"].empty()) {
      requestParameterName = make_shared<string>(boost::any_cast<string>(m["RequestParameterName"]));
    }
    if (m.find("ServiceParameterName") != m.end() && !m["ServiceParameterName"].empty()) {
      serviceParameterName = make_shared<string>(boost::any_cast<string>(m["ServiceParameterName"]));
    }
  }


  virtual ~DescribeDeployedApiResponseBodyServiceParametersMapServiceParameterMap() = default;
};
class DescribeDeployedApiResponseBodyServiceParametersMap : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDeployedApiResponseBodyServiceParametersMapServiceParameterMap>> serviceParameterMap{};

  DescribeDeployedApiResponseBodyServiceParametersMap() {}

  explicit DescribeDeployedApiResponseBodyServiceParametersMap(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (serviceParameterMap) {
      vector<boost::any> temp1;
      for(auto item1:*serviceParameterMap){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ServiceParameterMap"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ServiceParameterMap") != m.end() && !m["ServiceParameterMap"].empty()) {
      if (typeid(vector<boost::any>) == m["ServiceParameterMap"].type()) {
        vector<DescribeDeployedApiResponseBodyServiceParametersMapServiceParameterMap> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ServiceParameterMap"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDeployedApiResponseBodyServiceParametersMapServiceParameterMap model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        serviceParameterMap = make_shared<vector<DescribeDeployedApiResponseBodyServiceParametersMapServiceParameterMap>>(expect1);
      }
    }
  }


  virtual ~DescribeDeployedApiResponseBodyServiceParametersMap() = default;
};
class DescribeDeployedApiResponseBodySystemParametersSystemParameter : public Darabonba::Model {
public:
  shared_ptr<string> demoValue{};
  shared_ptr<string> description{};
  shared_ptr<string> location{};
  shared_ptr<string> parameterName{};
  shared_ptr<string> serviceParameterName{};

  DescribeDeployedApiResponseBodySystemParametersSystemParameter() {}

  explicit DescribeDeployedApiResponseBodySystemParametersSystemParameter(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (demoValue) {
      res["DemoValue"] = boost::any(*demoValue);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (parameterName) {
      res["ParameterName"] = boost::any(*parameterName);
    }
    if (serviceParameterName) {
      res["ServiceParameterName"] = boost::any(*serviceParameterName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DemoValue") != m.end() && !m["DemoValue"].empty()) {
      demoValue = make_shared<string>(boost::any_cast<string>(m["DemoValue"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("ParameterName") != m.end() && !m["ParameterName"].empty()) {
      parameterName = make_shared<string>(boost::any_cast<string>(m["ParameterName"]));
    }
    if (m.find("ServiceParameterName") != m.end() && !m["ServiceParameterName"].empty()) {
      serviceParameterName = make_shared<string>(boost::any_cast<string>(m["ServiceParameterName"]));
    }
  }


  virtual ~DescribeDeployedApiResponseBodySystemParametersSystemParameter() = default;
};
class DescribeDeployedApiResponseBodySystemParameters : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDeployedApiResponseBodySystemParametersSystemParameter>> systemParameter{};

  DescribeDeployedApiResponseBodySystemParameters() {}

  explicit DescribeDeployedApiResponseBodySystemParameters(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (systemParameter) {
      vector<boost::any> temp1;
      for(auto item1:*systemParameter){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SystemParameter"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SystemParameter") != m.end() && !m["SystemParameter"].empty()) {
      if (typeid(vector<boost::any>) == m["SystemParameter"].type()) {
        vector<DescribeDeployedApiResponseBodySystemParametersSystemParameter> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SystemParameter"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDeployedApiResponseBodySystemParametersSystemParameter model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        systemParameter = make_shared<vector<DescribeDeployedApiResponseBodySystemParametersSystemParameter>>(expect1);
      }
    }
  }


  virtual ~DescribeDeployedApiResponseBodySystemParameters() = default;
};
class DescribeDeployedApiResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> allowSignatureMethod{};
  shared_ptr<string> apiId{};
  shared_ptr<string> apiName{};
  shared_ptr<string> authType{};
  shared_ptr<DescribeDeployedApiResponseBodyConstantParameters> constantParameters{};
  shared_ptr<DescribeDeployedApiResponseBodyCustomSystemParameters> customSystemParameters{};
  shared_ptr<string> deployedTime{};
  shared_ptr<string> description{};
  shared_ptr<bool> disableInternet{};
  shared_ptr<DescribeDeployedApiResponseBodyErrorCodeSamples> errorCodeSamples{};
  shared_ptr<string> failResultSample{};
  shared_ptr<bool> forceNonceCheck{};
  shared_ptr<string> groupId{};
  shared_ptr<string> groupName{};
  shared_ptr<DescribeDeployedApiResponseBodyOpenIdConnectConfig> openIdConnectConfig{};
  shared_ptr<string> regionId{};
  shared_ptr<DescribeDeployedApiResponseBodyRequestConfig> requestConfig{};
  shared_ptr<string> requestId{};
  shared_ptr<DescribeDeployedApiResponseBodyRequestParameters> requestParameters{};
  shared_ptr<string> resultBodyModel{};
  shared_ptr<DescribeDeployedApiResponseBodyResultDescriptions> resultDescriptions{};
  shared_ptr<string> resultSample{};
  shared_ptr<string> resultType{};
  shared_ptr<DescribeDeployedApiResponseBodyServiceConfig> serviceConfig{};
  shared_ptr<DescribeDeployedApiResponseBodyServiceParameters> serviceParameters{};
  shared_ptr<DescribeDeployedApiResponseBodyServiceParametersMap> serviceParametersMap{};
  shared_ptr<string> stageName{};
  shared_ptr<DescribeDeployedApiResponseBodySystemParameters> systemParameters{};
  shared_ptr<string> visibility{};

  DescribeDeployedApiResponseBody() {}

  explicit DescribeDeployedApiResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (allowSignatureMethod) {
      res["AllowSignatureMethod"] = boost::any(*allowSignatureMethod);
    }
    if (apiId) {
      res["ApiId"] = boost::any(*apiId);
    }
    if (apiName) {
      res["ApiName"] = boost::any(*apiName);
    }
    if (authType) {
      res["AuthType"] = boost::any(*authType);
    }
    if (constantParameters) {
      res["ConstantParameters"] = constantParameters ? boost::any(constantParameters->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (customSystemParameters) {
      res["CustomSystemParameters"] = customSystemParameters ? boost::any(customSystemParameters->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (deployedTime) {
      res["DeployedTime"] = boost::any(*deployedTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (disableInternet) {
      res["DisableInternet"] = boost::any(*disableInternet);
    }
    if (errorCodeSamples) {
      res["ErrorCodeSamples"] = errorCodeSamples ? boost::any(errorCodeSamples->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (failResultSample) {
      res["FailResultSample"] = boost::any(*failResultSample);
    }
    if (forceNonceCheck) {
      res["ForceNonceCheck"] = boost::any(*forceNonceCheck);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (openIdConnectConfig) {
      res["OpenIdConnectConfig"] = openIdConnectConfig ? boost::any(openIdConnectConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (requestConfig) {
      res["RequestConfig"] = requestConfig ? boost::any(requestConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (requestParameters) {
      res["RequestParameters"] = requestParameters ? boost::any(requestParameters->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (resultBodyModel) {
      res["ResultBodyModel"] = boost::any(*resultBodyModel);
    }
    if (resultDescriptions) {
      res["ResultDescriptions"] = resultDescriptions ? boost::any(resultDescriptions->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (resultSample) {
      res["ResultSample"] = boost::any(*resultSample);
    }
    if (resultType) {
      res["ResultType"] = boost::any(*resultType);
    }
    if (serviceConfig) {
      res["ServiceConfig"] = serviceConfig ? boost::any(serviceConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (serviceParameters) {
      res["ServiceParameters"] = serviceParameters ? boost::any(serviceParameters->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (serviceParametersMap) {
      res["ServiceParametersMap"] = serviceParametersMap ? boost::any(serviceParametersMap->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (stageName) {
      res["StageName"] = boost::any(*stageName);
    }
    if (systemParameters) {
      res["SystemParameters"] = systemParameters ? boost::any(systemParameters->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (visibility) {
      res["Visibility"] = boost::any(*visibility);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AllowSignatureMethod") != m.end() && !m["AllowSignatureMethod"].empty()) {
      allowSignatureMethod = make_shared<string>(boost::any_cast<string>(m["AllowSignatureMethod"]));
    }
    if (m.find("ApiId") != m.end() && !m["ApiId"].empty()) {
      apiId = make_shared<string>(boost::any_cast<string>(m["ApiId"]));
    }
    if (m.find("ApiName") != m.end() && !m["ApiName"].empty()) {
      apiName = make_shared<string>(boost::any_cast<string>(m["ApiName"]));
    }
    if (m.find("AuthType") != m.end() && !m["AuthType"].empty()) {
      authType = make_shared<string>(boost::any_cast<string>(m["AuthType"]));
    }
    if (m.find("ConstantParameters") != m.end() && !m["ConstantParameters"].empty()) {
      if (typeid(map<string, boost::any>) == m["ConstantParameters"].type()) {
        DescribeDeployedApiResponseBodyConstantParameters model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ConstantParameters"]));
        constantParameters = make_shared<DescribeDeployedApiResponseBodyConstantParameters>(model1);
      }
    }
    if (m.find("CustomSystemParameters") != m.end() && !m["CustomSystemParameters"].empty()) {
      if (typeid(map<string, boost::any>) == m["CustomSystemParameters"].type()) {
        DescribeDeployedApiResponseBodyCustomSystemParameters model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CustomSystemParameters"]));
        customSystemParameters = make_shared<DescribeDeployedApiResponseBodyCustomSystemParameters>(model1);
      }
    }
    if (m.find("DeployedTime") != m.end() && !m["DeployedTime"].empty()) {
      deployedTime = make_shared<string>(boost::any_cast<string>(m["DeployedTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DisableInternet") != m.end() && !m["DisableInternet"].empty()) {
      disableInternet = make_shared<bool>(boost::any_cast<bool>(m["DisableInternet"]));
    }
    if (m.find("ErrorCodeSamples") != m.end() && !m["ErrorCodeSamples"].empty()) {
      if (typeid(map<string, boost::any>) == m["ErrorCodeSamples"].type()) {
        DescribeDeployedApiResponseBodyErrorCodeSamples model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ErrorCodeSamples"]));
        errorCodeSamples = make_shared<DescribeDeployedApiResponseBodyErrorCodeSamples>(model1);
      }
    }
    if (m.find("FailResultSample") != m.end() && !m["FailResultSample"].empty()) {
      failResultSample = make_shared<string>(boost::any_cast<string>(m["FailResultSample"]));
    }
    if (m.find("ForceNonceCheck") != m.end() && !m["ForceNonceCheck"].empty()) {
      forceNonceCheck = make_shared<bool>(boost::any_cast<bool>(m["ForceNonceCheck"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("OpenIdConnectConfig") != m.end() && !m["OpenIdConnectConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["OpenIdConnectConfig"].type()) {
        DescribeDeployedApiResponseBodyOpenIdConnectConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OpenIdConnectConfig"]));
        openIdConnectConfig = make_shared<DescribeDeployedApiResponseBodyOpenIdConnectConfig>(model1);
      }
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("RequestConfig") != m.end() && !m["RequestConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["RequestConfig"].type()) {
        DescribeDeployedApiResponseBodyRequestConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RequestConfig"]));
        requestConfig = make_shared<DescribeDeployedApiResponseBodyRequestConfig>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("RequestParameters") != m.end() && !m["RequestParameters"].empty()) {
      if (typeid(map<string, boost::any>) == m["RequestParameters"].type()) {
        DescribeDeployedApiResponseBodyRequestParameters model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RequestParameters"]));
        requestParameters = make_shared<DescribeDeployedApiResponseBodyRequestParameters>(model1);
      }
    }
    if (m.find("ResultBodyModel") != m.end() && !m["ResultBodyModel"].empty()) {
      resultBodyModel = make_shared<string>(boost::any_cast<string>(m["ResultBodyModel"]));
    }
    if (m.find("ResultDescriptions") != m.end() && !m["ResultDescriptions"].empty()) {
      if (typeid(map<string, boost::any>) == m["ResultDescriptions"].type()) {
        DescribeDeployedApiResponseBodyResultDescriptions model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ResultDescriptions"]));
        resultDescriptions = make_shared<DescribeDeployedApiResponseBodyResultDescriptions>(model1);
      }
    }
    if (m.find("ResultSample") != m.end() && !m["ResultSample"].empty()) {
      resultSample = make_shared<string>(boost::any_cast<string>(m["ResultSample"]));
    }
    if (m.find("ResultType") != m.end() && !m["ResultType"].empty()) {
      resultType = make_shared<string>(boost::any_cast<string>(m["ResultType"]));
    }
    if (m.find("ServiceConfig") != m.end() && !m["ServiceConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["ServiceConfig"].type()) {
        DescribeDeployedApiResponseBodyServiceConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ServiceConfig"]));
        serviceConfig = make_shared<DescribeDeployedApiResponseBodyServiceConfig>(model1);
      }
    }
    if (m.find("ServiceParameters") != m.end() && !m["ServiceParameters"].empty()) {
      if (typeid(map<string, boost::any>) == m["ServiceParameters"].type()) {
        DescribeDeployedApiResponseBodyServiceParameters model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ServiceParameters"]));
        serviceParameters = make_shared<DescribeDeployedApiResponseBodyServiceParameters>(model1);
      }
    }
    if (m.find("ServiceParametersMap") != m.end() && !m["ServiceParametersMap"].empty()) {
      if (typeid(map<string, boost::any>) == m["ServiceParametersMap"].type()) {
        DescribeDeployedApiResponseBodyServiceParametersMap model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ServiceParametersMap"]));
        serviceParametersMap = make_shared<DescribeDeployedApiResponseBodyServiceParametersMap>(model1);
      }
    }
    if (m.find("StageName") != m.end() && !m["StageName"].empty()) {
      stageName = make_shared<string>(boost::any_cast<string>(m["StageName"]));
    }
    if (m.find("SystemParameters") != m.end() && !m["SystemParameters"].empty()) {
      if (typeid(map<string, boost::any>) == m["SystemParameters"].type()) {
        DescribeDeployedApiResponseBodySystemParameters model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SystemParameters"]));
        systemParameters = make_shared<DescribeDeployedApiResponseBodySystemParameters>(model1);
      }
    }
    if (m.find("Visibility") != m.end() && !m["Visibility"].empty()) {
      visibility = make_shared<string>(boost::any_cast<string>(m["Visibility"]));
    }
  }


  virtual ~DescribeDeployedApiResponseBody() = default;
};
class DescribeDeployedApiResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDeployedApiResponseBody> body{};

  DescribeDeployedApiResponse() {}

  explicit DescribeDeployedApiResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDeployedApiResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDeployedApiResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDeployedApiResponse() = default;
};
class DescribeDeployedApisRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  DescribeDeployedApisRequestTag() {}

  explicit DescribeDeployedApisRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeDeployedApisRequestTag() = default;
};
class DescribeDeployedApisRequest : public Darabonba::Model {
public:
  shared_ptr<string> apiId{};
  shared_ptr<string> apiMethod{};
  shared_ptr<string> apiName{};
  shared_ptr<string> apiPath{};
  shared_ptr<bool> enableTagAuth{};
  shared_ptr<string> groupId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> stageName{};
  shared_ptr<vector<DescribeDeployedApisRequestTag>> tag{};

  DescribeDeployedApisRequest() {}

  explicit DescribeDeployedApisRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiId) {
      res["ApiId"] = boost::any(*apiId);
    }
    if (apiMethod) {
      res["ApiMethod"] = boost::any(*apiMethod);
    }
    if (apiName) {
      res["ApiName"] = boost::any(*apiName);
    }
    if (apiPath) {
      res["ApiPath"] = boost::any(*apiPath);
    }
    if (enableTagAuth) {
      res["EnableTagAuth"] = boost::any(*enableTagAuth);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (stageName) {
      res["StageName"] = boost::any(*stageName);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiId") != m.end() && !m["ApiId"].empty()) {
      apiId = make_shared<string>(boost::any_cast<string>(m["ApiId"]));
    }
    if (m.find("ApiMethod") != m.end() && !m["ApiMethod"].empty()) {
      apiMethod = make_shared<string>(boost::any_cast<string>(m["ApiMethod"]));
    }
    if (m.find("ApiName") != m.end() && !m["ApiName"].empty()) {
      apiName = make_shared<string>(boost::any_cast<string>(m["ApiName"]));
    }
    if (m.find("ApiPath") != m.end() && !m["ApiPath"].empty()) {
      apiPath = make_shared<string>(boost::any_cast<string>(m["ApiPath"]));
    }
    if (m.find("EnableTagAuth") != m.end() && !m["EnableTagAuth"].empty()) {
      enableTagAuth = make_shared<bool>(boost::any_cast<bool>(m["EnableTagAuth"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("StageName") != m.end() && !m["StageName"].empty()) {
      stageName = make_shared<string>(boost::any_cast<string>(m["StageName"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<DescribeDeployedApisRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDeployedApisRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<DescribeDeployedApisRequestTag>>(expect1);
      }
    }
  }


  virtual ~DescribeDeployedApisRequest() = default;
};
class DescribeDeployedApisResponseBodyDeployedApisDeployedApiItem : public Darabonba::Model {
public:
  shared_ptr<string> apiId{};
  shared_ptr<string> apiMethod{};
  shared_ptr<string> apiName{};
  shared_ptr<string> apiPath{};
  shared_ptr<string> deployedTime{};
  shared_ptr<string> description{};
  shared_ptr<string> groupId{};
  shared_ptr<string> groupName{};
  shared_ptr<string> regionId{};
  shared_ptr<string> stageName{};
  shared_ptr<string> visibility{};

  DescribeDeployedApisResponseBodyDeployedApisDeployedApiItem() {}

  explicit DescribeDeployedApisResponseBodyDeployedApisDeployedApiItem(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiId) {
      res["ApiId"] = boost::any(*apiId);
    }
    if (apiMethod) {
      res["ApiMethod"] = boost::any(*apiMethod);
    }
    if (apiName) {
      res["ApiName"] = boost::any(*apiName);
    }
    if (apiPath) {
      res["ApiPath"] = boost::any(*apiPath);
    }
    if (deployedTime) {
      res["DeployedTime"] = boost::any(*deployedTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (stageName) {
      res["StageName"] = boost::any(*stageName);
    }
    if (visibility) {
      res["Visibility"] = boost::any(*visibility);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiId") != m.end() && !m["ApiId"].empty()) {
      apiId = make_shared<string>(boost::any_cast<string>(m["ApiId"]));
    }
    if (m.find("ApiMethod") != m.end() && !m["ApiMethod"].empty()) {
      apiMethod = make_shared<string>(boost::any_cast<string>(m["ApiMethod"]));
    }
    if (m.find("ApiName") != m.end() && !m["ApiName"].empty()) {
      apiName = make_shared<string>(boost::any_cast<string>(m["ApiName"]));
    }
    if (m.find("ApiPath") != m.end() && !m["ApiPath"].empty()) {
      apiPath = make_shared<string>(boost::any_cast<string>(m["ApiPath"]));
    }
    if (m.find("DeployedTime") != m.end() && !m["DeployedTime"].empty()) {
      deployedTime = make_shared<string>(boost::any_cast<string>(m["DeployedTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("StageName") != m.end() && !m["StageName"].empty()) {
      stageName = make_shared<string>(boost::any_cast<string>(m["StageName"]));
    }
    if (m.find("Visibility") != m.end() && !m["Visibility"].empty()) {
      visibility = make_shared<string>(boost::any_cast<string>(m["Visibility"]));
    }
  }


  virtual ~DescribeDeployedApisResponseBodyDeployedApisDeployedApiItem() = default;
};
class DescribeDeployedApisResponseBodyDeployedApis : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDeployedApisResponseBodyDeployedApisDeployedApiItem>> deployedApiItem{};

  DescribeDeployedApisResponseBodyDeployedApis() {}

  explicit DescribeDeployedApisResponseBodyDeployedApis(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deployedApiItem) {
      vector<boost::any> temp1;
      for(auto item1:*deployedApiItem){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DeployedApiItem"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeployedApiItem") != m.end() && !m["DeployedApiItem"].empty()) {
      if (typeid(vector<boost::any>) == m["DeployedApiItem"].type()) {
        vector<DescribeDeployedApisResponseBodyDeployedApisDeployedApiItem> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DeployedApiItem"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDeployedApisResponseBodyDeployedApisDeployedApiItem model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        deployedApiItem = make_shared<vector<DescribeDeployedApisResponseBodyDeployedApisDeployedApiItem>>(expect1);
      }
    }
  }


  virtual ~DescribeDeployedApisResponseBodyDeployedApis() = default;
};
class DescribeDeployedApisResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeDeployedApisResponseBodyDeployedApis> deployedApis{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeDeployedApisResponseBody() {}

  explicit DescribeDeployedApisResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deployedApis) {
      res["DeployedApis"] = deployedApis ? boost::any(deployedApis->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeployedApis") != m.end() && !m["DeployedApis"].empty()) {
      if (typeid(map<string, boost::any>) == m["DeployedApis"].type()) {
        DescribeDeployedApisResponseBodyDeployedApis model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DeployedApis"]));
        deployedApis = make_shared<DescribeDeployedApisResponseBodyDeployedApis>(model1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeDeployedApisResponseBody() = default;
};
class DescribeDeployedApisResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDeployedApisResponseBody> body{};

  DescribeDeployedApisResponse() {}

  explicit DescribeDeployedApisResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDeployedApisResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDeployedApisResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDeployedApisResponse() = default;
};
class DescribeDomainRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> groupId{};
  shared_ptr<string> securityToken{};

  DescribeDomainRequest() {}

  explicit DescribeDomainRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~DescribeDomainRequest() = default;
};
class DescribeDomainResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> certificateBody{};
  shared_ptr<string> certificateId{};
  shared_ptr<string> certificateName{};
  shared_ptr<string> certificatePrivateKey{};
  shared_ptr<long> certificateValidEnd{};
  shared_ptr<long> certificateValidStart{};
  shared_ptr<string> domainBindingStatus{};
  shared_ptr<string> domainCNAMEStatus{};
  shared_ptr<string> domainLegalStatus{};
  shared_ptr<string> domainName{};
  shared_ptr<string> domainRemark{};
  shared_ptr<string> domainWebSocketStatus{};
  shared_ptr<string> groupId{};
  shared_ptr<string> requestId{};
  shared_ptr<string> subDomain{};

  DescribeDomainResponseBody() {}

  explicit DescribeDomainResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (certificateBody) {
      res["CertificateBody"] = boost::any(*certificateBody);
    }
    if (certificateId) {
      res["CertificateId"] = boost::any(*certificateId);
    }
    if (certificateName) {
      res["CertificateName"] = boost::any(*certificateName);
    }
    if (certificatePrivateKey) {
      res["CertificatePrivateKey"] = boost::any(*certificatePrivateKey);
    }
    if (certificateValidEnd) {
      res["CertificateValidEnd"] = boost::any(*certificateValidEnd);
    }
    if (certificateValidStart) {
      res["CertificateValidStart"] = boost::any(*certificateValidStart);
    }
    if (domainBindingStatus) {
      res["DomainBindingStatus"] = boost::any(*domainBindingStatus);
    }
    if (domainCNAMEStatus) {
      res["DomainCNAMEStatus"] = boost::any(*domainCNAMEStatus);
    }
    if (domainLegalStatus) {
      res["DomainLegalStatus"] = boost::any(*domainLegalStatus);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (domainRemark) {
      res["DomainRemark"] = boost::any(*domainRemark);
    }
    if (domainWebSocketStatus) {
      res["DomainWebSocketStatus"] = boost::any(*domainWebSocketStatus);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (subDomain) {
      res["SubDomain"] = boost::any(*subDomain);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CertificateBody") != m.end() && !m["CertificateBody"].empty()) {
      certificateBody = make_shared<string>(boost::any_cast<string>(m["CertificateBody"]));
    }
    if (m.find("CertificateId") != m.end() && !m["CertificateId"].empty()) {
      certificateId = make_shared<string>(boost::any_cast<string>(m["CertificateId"]));
    }
    if (m.find("CertificateName") != m.end() && !m["CertificateName"].empty()) {
      certificateName = make_shared<string>(boost::any_cast<string>(m["CertificateName"]));
    }
    if (m.find("CertificatePrivateKey") != m.end() && !m["CertificatePrivateKey"].empty()) {
      certificatePrivateKey = make_shared<string>(boost::any_cast<string>(m["CertificatePrivateKey"]));
    }
    if (m.find("CertificateValidEnd") != m.end() && !m["CertificateValidEnd"].empty()) {
      certificateValidEnd = make_shared<long>(boost::any_cast<long>(m["CertificateValidEnd"]));
    }
    if (m.find("CertificateValidStart") != m.end() && !m["CertificateValidStart"].empty()) {
      certificateValidStart = make_shared<long>(boost::any_cast<long>(m["CertificateValidStart"]));
    }
    if (m.find("DomainBindingStatus") != m.end() && !m["DomainBindingStatus"].empty()) {
      domainBindingStatus = make_shared<string>(boost::any_cast<string>(m["DomainBindingStatus"]));
    }
    if (m.find("DomainCNAMEStatus") != m.end() && !m["DomainCNAMEStatus"].empty()) {
      domainCNAMEStatus = make_shared<string>(boost::any_cast<string>(m["DomainCNAMEStatus"]));
    }
    if (m.find("DomainLegalStatus") != m.end() && !m["DomainLegalStatus"].empty()) {
      domainLegalStatus = make_shared<string>(boost::any_cast<string>(m["DomainLegalStatus"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("DomainRemark") != m.end() && !m["DomainRemark"].empty()) {
      domainRemark = make_shared<string>(boost::any_cast<string>(m["DomainRemark"]));
    }
    if (m.find("DomainWebSocketStatus") != m.end() && !m["DomainWebSocketStatus"].empty()) {
      domainWebSocketStatus = make_shared<string>(boost::any_cast<string>(m["DomainWebSocketStatus"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SubDomain") != m.end() && !m["SubDomain"].empty()) {
      subDomain = make_shared<string>(boost::any_cast<string>(m["SubDomain"]));
    }
  }


  virtual ~DescribeDomainResponseBody() = default;
};
class DescribeDomainResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDomainResponseBody> body{};

  DescribeDomainResponse() {}

  explicit DescribeDomainResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDomainResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDomainResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDomainResponse() = default;
};
class DescribeGroupLatencyRequest : public Darabonba::Model {
public:
  shared_ptr<string> endTime{};
  shared_ptr<string> groupId{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> stageName{};
  shared_ptr<string> startTime{};

  DescribeGroupLatencyRequest() {}

  explicit DescribeGroupLatencyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (stageName) {
      res["StageName"] = boost::any(*stageName);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("StageName") != m.end() && !m["StageName"].empty()) {
      stageName = make_shared<string>(boost::any_cast<string>(m["StageName"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeGroupLatencyRequest() = default;
};
class DescribeGroupLatencyResponseBodyLatencyPacketMonitorItem : public Darabonba::Model {
public:
  shared_ptr<string> item{};
  shared_ptr<string> itemTime{};
  shared_ptr<string> itemValue{};

  DescribeGroupLatencyResponseBodyLatencyPacketMonitorItem() {}

  explicit DescribeGroupLatencyResponseBodyLatencyPacketMonitorItem(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (item) {
      res["Item"] = boost::any(*item);
    }
    if (itemTime) {
      res["ItemTime"] = boost::any(*itemTime);
    }
    if (itemValue) {
      res["ItemValue"] = boost::any(*itemValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Item") != m.end() && !m["Item"].empty()) {
      item = make_shared<string>(boost::any_cast<string>(m["Item"]));
    }
    if (m.find("ItemTime") != m.end() && !m["ItemTime"].empty()) {
      itemTime = make_shared<string>(boost::any_cast<string>(m["ItemTime"]));
    }
    if (m.find("ItemValue") != m.end() && !m["ItemValue"].empty()) {
      itemValue = make_shared<string>(boost::any_cast<string>(m["ItemValue"]));
    }
  }


  virtual ~DescribeGroupLatencyResponseBodyLatencyPacketMonitorItem() = default;
};
class DescribeGroupLatencyResponseBodyLatencyPacket : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeGroupLatencyResponseBodyLatencyPacketMonitorItem>> monitorItem{};

  DescribeGroupLatencyResponseBodyLatencyPacket() {}

  explicit DescribeGroupLatencyResponseBodyLatencyPacket(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (monitorItem) {
      vector<boost::any> temp1;
      for(auto item1:*monitorItem){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["MonitorItem"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MonitorItem") != m.end() && !m["MonitorItem"].empty()) {
      if (typeid(vector<boost::any>) == m["MonitorItem"].type()) {
        vector<DescribeGroupLatencyResponseBodyLatencyPacketMonitorItem> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["MonitorItem"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeGroupLatencyResponseBodyLatencyPacketMonitorItem model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        monitorItem = make_shared<vector<DescribeGroupLatencyResponseBodyLatencyPacketMonitorItem>>(expect1);
      }
    }
  }


  virtual ~DescribeGroupLatencyResponseBodyLatencyPacket() = default;
};
class DescribeGroupLatencyResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeGroupLatencyResponseBodyLatencyPacket> latencyPacket{};
  shared_ptr<string> requestId{};

  DescribeGroupLatencyResponseBody() {}

  explicit DescribeGroupLatencyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (latencyPacket) {
      res["LatencyPacket"] = latencyPacket ? boost::any(latencyPacket->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LatencyPacket") != m.end() && !m["LatencyPacket"].empty()) {
      if (typeid(map<string, boost::any>) == m["LatencyPacket"].type()) {
        DescribeGroupLatencyResponseBodyLatencyPacket model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LatencyPacket"]));
        latencyPacket = make_shared<DescribeGroupLatencyResponseBodyLatencyPacket>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeGroupLatencyResponseBody() = default;
};
class DescribeGroupLatencyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeGroupLatencyResponseBody> body{};

  DescribeGroupLatencyResponse() {}

  explicit DescribeGroupLatencyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeGroupLatencyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeGroupLatencyResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeGroupLatencyResponse() = default;
};
class DescribeGroupQpsRequest : public Darabonba::Model {
public:
  shared_ptr<string> endTime{};
  shared_ptr<string> groupId{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> stageName{};
  shared_ptr<string> startTime{};

  DescribeGroupQpsRequest() {}

  explicit DescribeGroupQpsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (stageName) {
      res["StageName"] = boost::any(*stageName);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("StageName") != m.end() && !m["StageName"].empty()) {
      stageName = make_shared<string>(boost::any_cast<string>(m["StageName"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeGroupQpsRequest() = default;
};
class DescribeGroupQpsResponseBodyGroupQpsMonitorItem : public Darabonba::Model {
public:
  shared_ptr<string> itemTime{};
  shared_ptr<string> itemValue{};

  DescribeGroupQpsResponseBodyGroupQpsMonitorItem() {}

  explicit DescribeGroupQpsResponseBodyGroupQpsMonitorItem(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (itemTime) {
      res["ItemTime"] = boost::any(*itemTime);
    }
    if (itemValue) {
      res["ItemValue"] = boost::any(*itemValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ItemTime") != m.end() && !m["ItemTime"].empty()) {
      itemTime = make_shared<string>(boost::any_cast<string>(m["ItemTime"]));
    }
    if (m.find("ItemValue") != m.end() && !m["ItemValue"].empty()) {
      itemValue = make_shared<string>(boost::any_cast<string>(m["ItemValue"]));
    }
  }


  virtual ~DescribeGroupQpsResponseBodyGroupQpsMonitorItem() = default;
};
class DescribeGroupQpsResponseBodyGroupQps : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeGroupQpsResponseBodyGroupQpsMonitorItem>> monitorItem{};

  DescribeGroupQpsResponseBodyGroupQps() {}

  explicit DescribeGroupQpsResponseBodyGroupQps(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (monitorItem) {
      vector<boost::any> temp1;
      for(auto item1:*monitorItem){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["MonitorItem"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MonitorItem") != m.end() && !m["MonitorItem"].empty()) {
      if (typeid(vector<boost::any>) == m["MonitorItem"].type()) {
        vector<DescribeGroupQpsResponseBodyGroupQpsMonitorItem> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["MonitorItem"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeGroupQpsResponseBodyGroupQpsMonitorItem model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        monitorItem = make_shared<vector<DescribeGroupQpsResponseBodyGroupQpsMonitorItem>>(expect1);
      }
    }
  }


  virtual ~DescribeGroupQpsResponseBodyGroupQps() = default;
};
class DescribeGroupQpsResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeGroupQpsResponseBodyGroupQps> groupQps{};
  shared_ptr<string> requestId{};

  DescribeGroupQpsResponseBody() {}

  explicit DescribeGroupQpsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupQps) {
      res["GroupQps"] = groupQps ? boost::any(groupQps->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupQps") != m.end() && !m["GroupQps"].empty()) {
      if (typeid(map<string, boost::any>) == m["GroupQps"].type()) {
        DescribeGroupQpsResponseBodyGroupQps model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["GroupQps"]));
        groupQps = make_shared<DescribeGroupQpsResponseBodyGroupQps>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeGroupQpsResponseBody() = default;
};
class DescribeGroupQpsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeGroupQpsResponseBody> body{};

  DescribeGroupQpsResponse() {}

  explicit DescribeGroupQpsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeGroupQpsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeGroupQpsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeGroupQpsResponse() = default;
};
class DescribeGroupTrafficRequest : public Darabonba::Model {
public:
  shared_ptr<string> endTime{};
  shared_ptr<string> groupId{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> stageName{};
  shared_ptr<string> startTime{};

  DescribeGroupTrafficRequest() {}

  explicit DescribeGroupTrafficRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (stageName) {
      res["StageName"] = boost::any(*stageName);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("StageName") != m.end() && !m["StageName"].empty()) {
      stageName = make_shared<string>(boost::any_cast<string>(m["StageName"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeGroupTrafficRequest() = default;
};
class DescribeGroupTrafficResponseBodyTrafficPerSecondMonitorItem : public Darabonba::Model {
public:
  shared_ptr<string> item{};
  shared_ptr<string> itemTime{};
  shared_ptr<string> itemValue{};

  DescribeGroupTrafficResponseBodyTrafficPerSecondMonitorItem() {}

  explicit DescribeGroupTrafficResponseBodyTrafficPerSecondMonitorItem(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (item) {
      res["Item"] = boost::any(*item);
    }
    if (itemTime) {
      res["ItemTime"] = boost::any(*itemTime);
    }
    if (itemValue) {
      res["ItemValue"] = boost::any(*itemValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Item") != m.end() && !m["Item"].empty()) {
      item = make_shared<string>(boost::any_cast<string>(m["Item"]));
    }
    if (m.find("ItemTime") != m.end() && !m["ItemTime"].empty()) {
      itemTime = make_shared<string>(boost::any_cast<string>(m["ItemTime"]));
    }
    if (m.find("ItemValue") != m.end() && !m["ItemValue"].empty()) {
      itemValue = make_shared<string>(boost::any_cast<string>(m["ItemValue"]));
    }
  }


  virtual ~DescribeGroupTrafficResponseBodyTrafficPerSecondMonitorItem() = default;
};
class DescribeGroupTrafficResponseBodyTrafficPerSecond : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeGroupTrafficResponseBodyTrafficPerSecondMonitorItem>> monitorItem{};

  DescribeGroupTrafficResponseBodyTrafficPerSecond() {}

  explicit DescribeGroupTrafficResponseBodyTrafficPerSecond(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (monitorItem) {
      vector<boost::any> temp1;
      for(auto item1:*monitorItem){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["MonitorItem"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MonitorItem") != m.end() && !m["MonitorItem"].empty()) {
      if (typeid(vector<boost::any>) == m["MonitorItem"].type()) {
        vector<DescribeGroupTrafficResponseBodyTrafficPerSecondMonitorItem> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["MonitorItem"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeGroupTrafficResponseBodyTrafficPerSecondMonitorItem model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        monitorItem = make_shared<vector<DescribeGroupTrafficResponseBodyTrafficPerSecondMonitorItem>>(expect1);
      }
    }
  }


  virtual ~DescribeGroupTrafficResponseBodyTrafficPerSecond() = default;
};
class DescribeGroupTrafficResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeGroupTrafficResponseBodyTrafficPerSecond> trafficPerSecond{};

  DescribeGroupTrafficResponseBody() {}

  explicit DescribeGroupTrafficResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (trafficPerSecond) {
      res["TrafficPerSecond"] = trafficPerSecond ? boost::any(trafficPerSecond->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TrafficPerSecond") != m.end() && !m["TrafficPerSecond"].empty()) {
      if (typeid(map<string, boost::any>) == m["TrafficPerSecond"].type()) {
        DescribeGroupTrafficResponseBodyTrafficPerSecond model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TrafficPerSecond"]));
        trafficPerSecond = make_shared<DescribeGroupTrafficResponseBodyTrafficPerSecond>(model1);
      }
    }
  }


  virtual ~DescribeGroupTrafficResponseBody() = default;
};
class DescribeGroupTrafficResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeGroupTrafficResponseBody> body{};

  DescribeGroupTrafficResponse() {}

  explicit DescribeGroupTrafficResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeGroupTrafficResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeGroupTrafficResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeGroupTrafficResponse() = default;
};
class DescribeHistoryApisRequest : public Darabonba::Model {
public:
  shared_ptr<string> apiId{};
  shared_ptr<string> apiName{};
  shared_ptr<string> groupId{};
  shared_ptr<string> pageNumber{};
  shared_ptr<string> pageSize{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> stageName{};

  DescribeHistoryApisRequest() {}

  explicit DescribeHistoryApisRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiId) {
      res["ApiId"] = boost::any(*apiId);
    }
    if (apiName) {
      res["ApiName"] = boost::any(*apiName);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (stageName) {
      res["StageName"] = boost::any(*stageName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiId") != m.end() && !m["ApiId"].empty()) {
      apiId = make_shared<string>(boost::any_cast<string>(m["ApiId"]));
    }
    if (m.find("ApiName") != m.end() && !m["ApiName"].empty()) {
      apiName = make_shared<string>(boost::any_cast<string>(m["ApiName"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<string>(boost::any_cast<string>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<string>(boost::any_cast<string>(m["PageSize"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("StageName") != m.end() && !m["StageName"].empty()) {
      stageName = make_shared<string>(boost::any_cast<string>(m["StageName"]));
    }
  }


  virtual ~DescribeHistoryApisRequest() = default;
};
class DescribeHistoryApisResponseBodyApiHisItemsApiHisItem : public Darabonba::Model {
public:
  shared_ptr<string> apiId{};
  shared_ptr<string> apiName{};
  shared_ptr<string> deployedTime{};
  shared_ptr<string> description{};
  shared_ptr<string> groupId{};
  shared_ptr<string> groupName{};
  shared_ptr<string> historyVersion{};
  shared_ptr<string> regionId{};
  shared_ptr<string> stageAlias{};
  shared_ptr<string> stageName{};
  shared_ptr<string> status{};

  DescribeHistoryApisResponseBodyApiHisItemsApiHisItem() {}

  explicit DescribeHistoryApisResponseBodyApiHisItemsApiHisItem(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiId) {
      res["ApiId"] = boost::any(*apiId);
    }
    if (apiName) {
      res["ApiName"] = boost::any(*apiName);
    }
    if (deployedTime) {
      res["DeployedTime"] = boost::any(*deployedTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (historyVersion) {
      res["HistoryVersion"] = boost::any(*historyVersion);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (stageAlias) {
      res["StageAlias"] = boost::any(*stageAlias);
    }
    if (stageName) {
      res["StageName"] = boost::any(*stageName);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiId") != m.end() && !m["ApiId"].empty()) {
      apiId = make_shared<string>(boost::any_cast<string>(m["ApiId"]));
    }
    if (m.find("ApiName") != m.end() && !m["ApiName"].empty()) {
      apiName = make_shared<string>(boost::any_cast<string>(m["ApiName"]));
    }
    if (m.find("DeployedTime") != m.end() && !m["DeployedTime"].empty()) {
      deployedTime = make_shared<string>(boost::any_cast<string>(m["DeployedTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("HistoryVersion") != m.end() && !m["HistoryVersion"].empty()) {
      historyVersion = make_shared<string>(boost::any_cast<string>(m["HistoryVersion"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("StageAlias") != m.end() && !m["StageAlias"].empty()) {
      stageAlias = make_shared<string>(boost::any_cast<string>(m["StageAlias"]));
    }
    if (m.find("StageName") != m.end() && !m["StageName"].empty()) {
      stageName = make_shared<string>(boost::any_cast<string>(m["StageName"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeHistoryApisResponseBodyApiHisItemsApiHisItem() = default;
};
class DescribeHistoryApisResponseBodyApiHisItems : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeHistoryApisResponseBodyApiHisItemsApiHisItem>> apiHisItem{};

  DescribeHistoryApisResponseBodyApiHisItems() {}

  explicit DescribeHistoryApisResponseBodyApiHisItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiHisItem) {
      vector<boost::any> temp1;
      for(auto item1:*apiHisItem){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ApiHisItem"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiHisItem") != m.end() && !m["ApiHisItem"].empty()) {
      if (typeid(vector<boost::any>) == m["ApiHisItem"].type()) {
        vector<DescribeHistoryApisResponseBodyApiHisItemsApiHisItem> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ApiHisItem"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeHistoryApisResponseBodyApiHisItemsApiHisItem model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        apiHisItem = make_shared<vector<DescribeHistoryApisResponseBodyApiHisItemsApiHisItem>>(expect1);
      }
    }
  }


  virtual ~DescribeHistoryApisResponseBodyApiHisItems() = default;
};
class DescribeHistoryApisResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeHistoryApisResponseBodyApiHisItems> apiHisItems{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeHistoryApisResponseBody() {}

  explicit DescribeHistoryApisResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiHisItems) {
      res["ApiHisItems"] = apiHisItems ? boost::any(apiHisItems->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiHisItems") != m.end() && !m["ApiHisItems"].empty()) {
      if (typeid(map<string, boost::any>) == m["ApiHisItems"].type()) {
        DescribeHistoryApisResponseBodyApiHisItems model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ApiHisItems"]));
        apiHisItems = make_shared<DescribeHistoryApisResponseBodyApiHisItems>(model1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeHistoryApisResponseBody() = default;
};
class DescribeHistoryApisResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeHistoryApisResponseBody> body{};

  DescribeHistoryApisResponse() {}

  explicit DescribeHistoryApisResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeHistoryApisResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeHistoryApisResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeHistoryApisResponse() = default;
};
class DescribeImportOASTaskRequest : public Darabonba::Model {
public:
  shared_ptr<string> operationId{};
  shared_ptr<string> securityToken{};

  DescribeImportOASTaskRequest() {}

  explicit DescribeImportOASTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (operationId) {
      res["OperationId"] = boost::any(*operationId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OperationId") != m.end() && !m["OperationId"].empty()) {
      operationId = make_shared<string>(boost::any_cast<string>(m["OperationId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~DescribeImportOASTaskRequest() = default;
};
class DescribeImportOASTaskResponseBodyApiResultsApiResult : public Darabonba::Model {
public:
  shared_ptr<string> apiId{};
  shared_ptr<string> apiName{};
  shared_ptr<string> description{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> groupId{};
  shared_ptr<string> method{};
  shared_ptr<string> path{};
  shared_ptr<string> updateStatus{};

  DescribeImportOASTaskResponseBodyApiResultsApiResult() {}

  explicit DescribeImportOASTaskResponseBodyApiResultsApiResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiId) {
      res["ApiId"] = boost::any(*apiId);
    }
    if (apiName) {
      res["ApiName"] = boost::any(*apiName);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (method) {
      res["Method"] = boost::any(*method);
    }
    if (path) {
      res["Path"] = boost::any(*path);
    }
    if (updateStatus) {
      res["UpdateStatus"] = boost::any(*updateStatus);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiId") != m.end() && !m["ApiId"].empty()) {
      apiId = make_shared<string>(boost::any_cast<string>(m["ApiId"]));
    }
    if (m.find("ApiName") != m.end() && !m["ApiName"].empty()) {
      apiName = make_shared<string>(boost::any_cast<string>(m["ApiName"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("Method") != m.end() && !m["Method"].empty()) {
      method = make_shared<string>(boost::any_cast<string>(m["Method"]));
    }
    if (m.find("Path") != m.end() && !m["Path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["Path"]));
    }
    if (m.find("UpdateStatus") != m.end() && !m["UpdateStatus"].empty()) {
      updateStatus = make_shared<string>(boost::any_cast<string>(m["UpdateStatus"]));
    }
  }


  virtual ~DescribeImportOASTaskResponseBodyApiResultsApiResult() = default;
};
class DescribeImportOASTaskResponseBodyApiResults : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeImportOASTaskResponseBodyApiResultsApiResult>> apiResult{};

  DescribeImportOASTaskResponseBodyApiResults() {}

  explicit DescribeImportOASTaskResponseBodyApiResults(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiResult) {
      vector<boost::any> temp1;
      for(auto item1:*apiResult){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ApiResult"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiResult") != m.end() && !m["ApiResult"].empty()) {
      if (typeid(vector<boost::any>) == m["ApiResult"].type()) {
        vector<DescribeImportOASTaskResponseBodyApiResultsApiResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ApiResult"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeImportOASTaskResponseBodyApiResultsApiResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        apiResult = make_shared<vector<DescribeImportOASTaskResponseBodyApiResultsApiResult>>(expect1);
      }
    }
  }


  virtual ~DescribeImportOASTaskResponseBodyApiResults() = default;
};
class DescribeImportOASTaskResponseBodyModelResultsModelResult : public Darabonba::Model {
public:
  shared_ptr<string> errorMessage{};
  shared_ptr<string> groupId{};
  shared_ptr<string> modelId{};
  shared_ptr<string> modelName{};
  shared_ptr<string> updateStatus{};

  DescribeImportOASTaskResponseBodyModelResultsModelResult() {}

  explicit DescribeImportOASTaskResponseBodyModelResultsModelResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (modelId) {
      res["ModelId"] = boost::any(*modelId);
    }
    if (modelName) {
      res["ModelName"] = boost::any(*modelName);
    }
    if (updateStatus) {
      res["UpdateStatus"] = boost::any(*updateStatus);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("ModelId") != m.end() && !m["ModelId"].empty()) {
      modelId = make_shared<string>(boost::any_cast<string>(m["ModelId"]));
    }
    if (m.find("ModelName") != m.end() && !m["ModelName"].empty()) {
      modelName = make_shared<string>(boost::any_cast<string>(m["ModelName"]));
    }
    if (m.find("UpdateStatus") != m.end() && !m["UpdateStatus"].empty()) {
      updateStatus = make_shared<string>(boost::any_cast<string>(m["UpdateStatus"]));
    }
  }


  virtual ~DescribeImportOASTaskResponseBodyModelResultsModelResult() = default;
};
class DescribeImportOASTaskResponseBodyModelResults : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeImportOASTaskResponseBodyModelResultsModelResult>> modelResult{};

  DescribeImportOASTaskResponseBodyModelResults() {}

  explicit DescribeImportOASTaskResponseBodyModelResults(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (modelResult) {
      vector<boost::any> temp1;
      for(auto item1:*modelResult){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ModelResult"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ModelResult") != m.end() && !m["ModelResult"].empty()) {
      if (typeid(vector<boost::any>) == m["ModelResult"].type()) {
        vector<DescribeImportOASTaskResponseBodyModelResultsModelResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ModelResult"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeImportOASTaskResponseBodyModelResultsModelResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        modelResult = make_shared<vector<DescribeImportOASTaskResponseBodyModelResultsModelResult>>(expect1);
      }
    }
  }


  virtual ~DescribeImportOASTaskResponseBodyModelResults() = default;
};
class DescribeImportOASTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeImportOASTaskResponseBodyApiResults> apiResults{};
  shared_ptr<DescribeImportOASTaskResponseBodyModelResults> modelResults{};
  shared_ptr<string> requestId{};
  shared_ptr<string> taskStatus{};

  DescribeImportOASTaskResponseBody() {}

  explicit DescribeImportOASTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiResults) {
      res["ApiResults"] = apiResults ? boost::any(apiResults->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (modelResults) {
      res["ModelResults"] = modelResults ? boost::any(modelResults->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (taskStatus) {
      res["TaskStatus"] = boost::any(*taskStatus);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiResults") != m.end() && !m["ApiResults"].empty()) {
      if (typeid(map<string, boost::any>) == m["ApiResults"].type()) {
        DescribeImportOASTaskResponseBodyApiResults model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ApiResults"]));
        apiResults = make_shared<DescribeImportOASTaskResponseBodyApiResults>(model1);
      }
    }
    if (m.find("ModelResults") != m.end() && !m["ModelResults"].empty()) {
      if (typeid(map<string, boost::any>) == m["ModelResults"].type()) {
        DescribeImportOASTaskResponseBodyModelResults model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ModelResults"]));
        modelResults = make_shared<DescribeImportOASTaskResponseBodyModelResults>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TaskStatus") != m.end() && !m["TaskStatus"].empty()) {
      taskStatus = make_shared<string>(boost::any_cast<string>(m["TaskStatus"]));
    }
  }


  virtual ~DescribeImportOASTaskResponseBody() = default;
};
class DescribeImportOASTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeImportOASTaskResponseBody> body{};

  DescribeImportOASTaskResponse() {}

  explicit DescribeImportOASTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeImportOASTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeImportOASTaskResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeImportOASTaskResponse() = default;
};
class DescribeInstanceDropConnectionsRequest : public Darabonba::Model {
public:
  shared_ptr<string> endTime{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> sbcName{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> startTime{};

  DescribeInstanceDropConnectionsRequest() {}

  explicit DescribeInstanceDropConnectionsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (sbcName) {
      res["SbcName"] = boost::any(*sbcName);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("SbcName") != m.end() && !m["SbcName"].empty()) {
      sbcName = make_shared<string>(boost::any_cast<string>(m["SbcName"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeInstanceDropConnectionsRequest() = default;
};
class DescribeInstanceDropConnectionsResponseBodyInstanceDropConnectionsMonitorItem : public Darabonba::Model {
public:
  shared_ptr<string> itemTime{};
  shared_ptr<string> itemValue{};

  DescribeInstanceDropConnectionsResponseBodyInstanceDropConnectionsMonitorItem() {}

  explicit DescribeInstanceDropConnectionsResponseBodyInstanceDropConnectionsMonitorItem(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (itemTime) {
      res["ItemTime"] = boost::any(*itemTime);
    }
    if (itemValue) {
      res["ItemValue"] = boost::any(*itemValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ItemTime") != m.end() && !m["ItemTime"].empty()) {
      itemTime = make_shared<string>(boost::any_cast<string>(m["ItemTime"]));
    }
    if (m.find("ItemValue") != m.end() && !m["ItemValue"].empty()) {
      itemValue = make_shared<string>(boost::any_cast<string>(m["ItemValue"]));
    }
  }


  virtual ~DescribeInstanceDropConnectionsResponseBodyInstanceDropConnectionsMonitorItem() = default;
};
class DescribeInstanceDropConnectionsResponseBodyInstanceDropConnections : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeInstanceDropConnectionsResponseBodyInstanceDropConnectionsMonitorItem>> monitorItem{};

  DescribeInstanceDropConnectionsResponseBodyInstanceDropConnections() {}

  explicit DescribeInstanceDropConnectionsResponseBodyInstanceDropConnections(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (monitorItem) {
      vector<boost::any> temp1;
      for(auto item1:*monitorItem){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["MonitorItem"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MonitorItem") != m.end() && !m["MonitorItem"].empty()) {
      if (typeid(vector<boost::any>) == m["MonitorItem"].type()) {
        vector<DescribeInstanceDropConnectionsResponseBodyInstanceDropConnectionsMonitorItem> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["MonitorItem"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeInstanceDropConnectionsResponseBodyInstanceDropConnectionsMonitorItem model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        monitorItem = make_shared<vector<DescribeInstanceDropConnectionsResponseBodyInstanceDropConnectionsMonitorItem>>(expect1);
      }
    }
  }


  virtual ~DescribeInstanceDropConnectionsResponseBodyInstanceDropConnections() = default;
};
class DescribeInstanceDropConnectionsResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeInstanceDropConnectionsResponseBodyInstanceDropConnections> instanceDropConnections{};
  shared_ptr<string> requestId{};

  DescribeInstanceDropConnectionsResponseBody() {}

  explicit DescribeInstanceDropConnectionsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceDropConnections) {
      res["InstanceDropConnections"] = instanceDropConnections ? boost::any(instanceDropConnections->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceDropConnections") != m.end() && !m["InstanceDropConnections"].empty()) {
      if (typeid(map<string, boost::any>) == m["InstanceDropConnections"].type()) {
        DescribeInstanceDropConnectionsResponseBodyInstanceDropConnections model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InstanceDropConnections"]));
        instanceDropConnections = make_shared<DescribeInstanceDropConnectionsResponseBodyInstanceDropConnections>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeInstanceDropConnectionsResponseBody() = default;
};
class DescribeInstanceDropConnectionsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeInstanceDropConnectionsResponseBody> body{};

  DescribeInstanceDropConnectionsResponse() {}

  explicit DescribeInstanceDropConnectionsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeInstanceDropConnectionsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeInstanceDropConnectionsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeInstanceDropConnectionsResponse() = default;
};
class DescribeInstanceDropPacketRequest : public Darabonba::Model {
public:
  shared_ptr<string> endTime{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> sbcName{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> startTime{};

  DescribeInstanceDropPacketRequest() {}

  explicit DescribeInstanceDropPacketRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (sbcName) {
      res["SbcName"] = boost::any(*sbcName);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("SbcName") != m.end() && !m["SbcName"].empty()) {
      sbcName = make_shared<string>(boost::any_cast<string>(m["SbcName"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeInstanceDropPacketRequest() = default;
};
class DescribeInstanceDropPacketResponseBodyInstanceDropPacketMonitorItem : public Darabonba::Model {
public:
  shared_ptr<string> item{};
  shared_ptr<string> itemTime{};
  shared_ptr<string> itemValue{};

  DescribeInstanceDropPacketResponseBodyInstanceDropPacketMonitorItem() {}

  explicit DescribeInstanceDropPacketResponseBodyInstanceDropPacketMonitorItem(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (item) {
      res["Item"] = boost::any(*item);
    }
    if (itemTime) {
      res["ItemTime"] = boost::any(*itemTime);
    }
    if (itemValue) {
      res["ItemValue"] = boost::any(*itemValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Item") != m.end() && !m["Item"].empty()) {
      item = make_shared<string>(boost::any_cast<string>(m["Item"]));
    }
    if (m.find("ItemTime") != m.end() && !m["ItemTime"].empty()) {
      itemTime = make_shared<string>(boost::any_cast<string>(m["ItemTime"]));
    }
    if (m.find("ItemValue") != m.end() && !m["ItemValue"].empty()) {
      itemValue = make_shared<string>(boost::any_cast<string>(m["ItemValue"]));
    }
  }


  virtual ~DescribeInstanceDropPacketResponseBodyInstanceDropPacketMonitorItem() = default;
};
class DescribeInstanceDropPacketResponseBodyInstanceDropPacket : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeInstanceDropPacketResponseBodyInstanceDropPacketMonitorItem>> monitorItem{};

  DescribeInstanceDropPacketResponseBodyInstanceDropPacket() {}

  explicit DescribeInstanceDropPacketResponseBodyInstanceDropPacket(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (monitorItem) {
      vector<boost::any> temp1;
      for(auto item1:*monitorItem){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["MonitorItem"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MonitorItem") != m.end() && !m["MonitorItem"].empty()) {
      if (typeid(vector<boost::any>) == m["MonitorItem"].type()) {
        vector<DescribeInstanceDropPacketResponseBodyInstanceDropPacketMonitorItem> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["MonitorItem"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeInstanceDropPacketResponseBodyInstanceDropPacketMonitorItem model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        monitorItem = make_shared<vector<DescribeInstanceDropPacketResponseBodyInstanceDropPacketMonitorItem>>(expect1);
      }
    }
  }


  virtual ~DescribeInstanceDropPacketResponseBodyInstanceDropPacket() = default;
};
class DescribeInstanceDropPacketResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeInstanceDropPacketResponseBodyInstanceDropPacket> instanceDropPacket{};
  shared_ptr<string> requestId{};

  DescribeInstanceDropPacketResponseBody() {}

  explicit DescribeInstanceDropPacketResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceDropPacket) {
      res["InstanceDropPacket"] = instanceDropPacket ? boost::any(instanceDropPacket->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceDropPacket") != m.end() && !m["InstanceDropPacket"].empty()) {
      if (typeid(map<string, boost::any>) == m["InstanceDropPacket"].type()) {
        DescribeInstanceDropPacketResponseBodyInstanceDropPacket model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InstanceDropPacket"]));
        instanceDropPacket = make_shared<DescribeInstanceDropPacketResponseBodyInstanceDropPacket>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeInstanceDropPacketResponseBody() = default;
};
class DescribeInstanceDropPacketResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeInstanceDropPacketResponseBody> body{};

  DescribeInstanceDropPacketResponse() {}

  explicit DescribeInstanceDropPacketResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeInstanceDropPacketResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeInstanceDropPacketResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeInstanceDropPacketResponse() = default;
};
class DescribeInstanceHttpCodeRequest : public Darabonba::Model {
public:
  shared_ptr<string> endTime{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> stageName{};
  shared_ptr<string> startTime{};

  DescribeInstanceHttpCodeRequest() {}

  explicit DescribeInstanceHttpCodeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (stageName) {
      res["StageName"] = boost::any(*stageName);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("StageName") != m.end() && !m["StageName"].empty()) {
      stageName = make_shared<string>(boost::any_cast<string>(m["StageName"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeInstanceHttpCodeRequest() = default;
};
class DescribeInstanceHttpCodeResponseBodyInstanceHttpCodeMonitorItem : public Darabonba::Model {
public:
  shared_ptr<string> itemTime{};
  shared_ptr<string> itemValue{};

  DescribeInstanceHttpCodeResponseBodyInstanceHttpCodeMonitorItem() {}

  explicit DescribeInstanceHttpCodeResponseBodyInstanceHttpCodeMonitorItem(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (itemTime) {
      res["ItemTime"] = boost::any(*itemTime);
    }
    if (itemValue) {
      res["ItemValue"] = boost::any(*itemValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ItemTime") != m.end() && !m["ItemTime"].empty()) {
      itemTime = make_shared<string>(boost::any_cast<string>(m["ItemTime"]));
    }
    if (m.find("ItemValue") != m.end() && !m["ItemValue"].empty()) {
      itemValue = make_shared<string>(boost::any_cast<string>(m["ItemValue"]));
    }
  }


  virtual ~DescribeInstanceHttpCodeResponseBodyInstanceHttpCodeMonitorItem() = default;
};
class DescribeInstanceHttpCodeResponseBodyInstanceHttpCode : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeInstanceHttpCodeResponseBodyInstanceHttpCodeMonitorItem>> monitorItem{};

  DescribeInstanceHttpCodeResponseBodyInstanceHttpCode() {}

  explicit DescribeInstanceHttpCodeResponseBodyInstanceHttpCode(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (monitorItem) {
      vector<boost::any> temp1;
      for(auto item1:*monitorItem){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["MonitorItem"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MonitorItem") != m.end() && !m["MonitorItem"].empty()) {
      if (typeid(vector<boost::any>) == m["MonitorItem"].type()) {
        vector<DescribeInstanceHttpCodeResponseBodyInstanceHttpCodeMonitorItem> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["MonitorItem"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeInstanceHttpCodeResponseBodyInstanceHttpCodeMonitorItem model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        monitorItem = make_shared<vector<DescribeInstanceHttpCodeResponseBodyInstanceHttpCodeMonitorItem>>(expect1);
      }
    }
  }


  virtual ~DescribeInstanceHttpCodeResponseBodyInstanceHttpCode() = default;
};
class DescribeInstanceHttpCodeResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeInstanceHttpCodeResponseBodyInstanceHttpCode> instanceHttpCode{};
  shared_ptr<string> requestId{};

  DescribeInstanceHttpCodeResponseBody() {}

  explicit DescribeInstanceHttpCodeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceHttpCode) {
      res["InstanceHttpCode"] = instanceHttpCode ? boost::any(instanceHttpCode->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceHttpCode") != m.end() && !m["InstanceHttpCode"].empty()) {
      if (typeid(map<string, boost::any>) == m["InstanceHttpCode"].type()) {
        DescribeInstanceHttpCodeResponseBodyInstanceHttpCode model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InstanceHttpCode"]));
        instanceHttpCode = make_shared<DescribeInstanceHttpCodeResponseBodyInstanceHttpCode>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeInstanceHttpCodeResponseBody() = default;
};
class DescribeInstanceHttpCodeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeInstanceHttpCodeResponseBody> body{};

  DescribeInstanceHttpCodeResponse() {}

  explicit DescribeInstanceHttpCodeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeInstanceHttpCodeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeInstanceHttpCodeResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeInstanceHttpCodeResponse() = default;
};
class DescribeInstanceLatencyRequest : public Darabonba::Model {
public:
  shared_ptr<string> endTime{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> stageName{};
  shared_ptr<string> startTime{};

  DescribeInstanceLatencyRequest() {}

  explicit DescribeInstanceLatencyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (stageName) {
      res["StageName"] = boost::any(*stageName);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("StageName") != m.end() && !m["StageName"].empty()) {
      stageName = make_shared<string>(boost::any_cast<string>(m["StageName"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeInstanceLatencyRequest() = default;
};
class DescribeInstanceLatencyResponseBodyInstanceLatencyMonitorItem : public Darabonba::Model {
public:
  shared_ptr<string> item{};
  shared_ptr<string> itemTime{};
  shared_ptr<string> itemValue{};

  DescribeInstanceLatencyResponseBodyInstanceLatencyMonitorItem() {}

  explicit DescribeInstanceLatencyResponseBodyInstanceLatencyMonitorItem(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (item) {
      res["Item"] = boost::any(*item);
    }
    if (itemTime) {
      res["ItemTime"] = boost::any(*itemTime);
    }
    if (itemValue) {
      res["ItemValue"] = boost::any(*itemValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Item") != m.end() && !m["Item"].empty()) {
      item = make_shared<string>(boost::any_cast<string>(m["Item"]));
    }
    if (m.find("ItemTime") != m.end() && !m["ItemTime"].empty()) {
      itemTime = make_shared<string>(boost::any_cast<string>(m["ItemTime"]));
    }
    if (m.find("ItemValue") != m.end() && !m["ItemValue"].empty()) {
      itemValue = make_shared<string>(boost::any_cast<string>(m["ItemValue"]));
    }
  }


  virtual ~DescribeInstanceLatencyResponseBodyInstanceLatencyMonitorItem() = default;
};
class DescribeInstanceLatencyResponseBodyInstanceLatency : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeInstanceLatencyResponseBodyInstanceLatencyMonitorItem>> monitorItem{};

  DescribeInstanceLatencyResponseBodyInstanceLatency() {}

  explicit DescribeInstanceLatencyResponseBodyInstanceLatency(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (monitorItem) {
      vector<boost::any> temp1;
      for(auto item1:*monitorItem){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["MonitorItem"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MonitorItem") != m.end() && !m["MonitorItem"].empty()) {
      if (typeid(vector<boost::any>) == m["MonitorItem"].type()) {
        vector<DescribeInstanceLatencyResponseBodyInstanceLatencyMonitorItem> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["MonitorItem"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeInstanceLatencyResponseBodyInstanceLatencyMonitorItem model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        monitorItem = make_shared<vector<DescribeInstanceLatencyResponseBodyInstanceLatencyMonitorItem>>(expect1);
      }
    }
  }


  virtual ~DescribeInstanceLatencyResponseBodyInstanceLatency() = default;
};
class DescribeInstanceLatencyResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeInstanceLatencyResponseBodyInstanceLatency> instanceLatency{};
  shared_ptr<string> requestId{};

  DescribeInstanceLatencyResponseBody() {}

  explicit DescribeInstanceLatencyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceLatency) {
      res["InstanceLatency"] = instanceLatency ? boost::any(instanceLatency->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceLatency") != m.end() && !m["InstanceLatency"].empty()) {
      if (typeid(map<string, boost::any>) == m["InstanceLatency"].type()) {
        DescribeInstanceLatencyResponseBodyInstanceLatency model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InstanceLatency"]));
        instanceLatency = make_shared<DescribeInstanceLatencyResponseBodyInstanceLatency>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeInstanceLatencyResponseBody() = default;
};
class DescribeInstanceLatencyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeInstanceLatencyResponseBody> body{};

  DescribeInstanceLatencyResponse() {}

  explicit DescribeInstanceLatencyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeInstanceLatencyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeInstanceLatencyResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeInstanceLatencyResponse() = default;
};
class DescribeInstanceNewConnectionsRequest : public Darabonba::Model {
public:
  shared_ptr<string> endTime{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> sbcName{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> startTime{};

  DescribeInstanceNewConnectionsRequest() {}

  explicit DescribeInstanceNewConnectionsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (sbcName) {
      res["SbcName"] = boost::any(*sbcName);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("SbcName") != m.end() && !m["SbcName"].empty()) {
      sbcName = make_shared<string>(boost::any_cast<string>(m["SbcName"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeInstanceNewConnectionsRequest() = default;
};
class DescribeInstanceNewConnectionsResponseBodyInstanceNewConnectionsMonitorItem : public Darabonba::Model {
public:
  shared_ptr<string> itemTime{};
  shared_ptr<string> itemValue{};

  DescribeInstanceNewConnectionsResponseBodyInstanceNewConnectionsMonitorItem() {}

  explicit DescribeInstanceNewConnectionsResponseBodyInstanceNewConnectionsMonitorItem(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (itemTime) {
      res["ItemTime"] = boost::any(*itemTime);
    }
    if (itemValue) {
      res["ItemValue"] = boost::any(*itemValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ItemTime") != m.end() && !m["ItemTime"].empty()) {
      itemTime = make_shared<string>(boost::any_cast<string>(m["ItemTime"]));
    }
    if (m.find("ItemValue") != m.end() && !m["ItemValue"].empty()) {
      itemValue = make_shared<string>(boost::any_cast<string>(m["ItemValue"]));
    }
  }


  virtual ~DescribeInstanceNewConnectionsResponseBodyInstanceNewConnectionsMonitorItem() = default;
};
class DescribeInstanceNewConnectionsResponseBodyInstanceNewConnections : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeInstanceNewConnectionsResponseBodyInstanceNewConnectionsMonitorItem>> monitorItem{};

  DescribeInstanceNewConnectionsResponseBodyInstanceNewConnections() {}

  explicit DescribeInstanceNewConnectionsResponseBodyInstanceNewConnections(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (monitorItem) {
      vector<boost::any> temp1;
      for(auto item1:*monitorItem){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["MonitorItem"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MonitorItem") != m.end() && !m["MonitorItem"].empty()) {
      if (typeid(vector<boost::any>) == m["MonitorItem"].type()) {
        vector<DescribeInstanceNewConnectionsResponseBodyInstanceNewConnectionsMonitorItem> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["MonitorItem"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeInstanceNewConnectionsResponseBodyInstanceNewConnectionsMonitorItem model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        monitorItem = make_shared<vector<DescribeInstanceNewConnectionsResponseBodyInstanceNewConnectionsMonitorItem>>(expect1);
      }
    }
  }


  virtual ~DescribeInstanceNewConnectionsResponseBodyInstanceNewConnections() = default;
};
class DescribeInstanceNewConnectionsResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeInstanceNewConnectionsResponseBodyInstanceNewConnections> instanceNewConnections{};
  shared_ptr<string> requestId{};

  DescribeInstanceNewConnectionsResponseBody() {}

  explicit DescribeInstanceNewConnectionsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceNewConnections) {
      res["InstanceNewConnections"] = instanceNewConnections ? boost::any(instanceNewConnections->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceNewConnections") != m.end() && !m["InstanceNewConnections"].empty()) {
      if (typeid(map<string, boost::any>) == m["InstanceNewConnections"].type()) {
        DescribeInstanceNewConnectionsResponseBodyInstanceNewConnections model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InstanceNewConnections"]));
        instanceNewConnections = make_shared<DescribeInstanceNewConnectionsResponseBodyInstanceNewConnections>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeInstanceNewConnectionsResponseBody() = default;
};
class DescribeInstanceNewConnectionsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeInstanceNewConnectionsResponseBody> body{};

  DescribeInstanceNewConnectionsResponse() {}

  explicit DescribeInstanceNewConnectionsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeInstanceNewConnectionsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeInstanceNewConnectionsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeInstanceNewConnectionsResponse() = default;
};
class DescribeInstancePacketsRequest : public Darabonba::Model {
public:
  shared_ptr<string> endTime{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> sbcName{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> startTime{};

  DescribeInstancePacketsRequest() {}

  explicit DescribeInstancePacketsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (sbcName) {
      res["SbcName"] = boost::any(*sbcName);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("SbcName") != m.end() && !m["SbcName"].empty()) {
      sbcName = make_shared<string>(boost::any_cast<string>(m["SbcName"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeInstancePacketsRequest() = default;
};
class DescribeInstancePacketsResponseBodyInstancePacketsMonitorItem : public Darabonba::Model {
public:
  shared_ptr<string> item{};
  shared_ptr<string> itemTime{};
  shared_ptr<string> itemValue{};

  DescribeInstancePacketsResponseBodyInstancePacketsMonitorItem() {}

  explicit DescribeInstancePacketsResponseBodyInstancePacketsMonitorItem(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (item) {
      res["Item"] = boost::any(*item);
    }
    if (itemTime) {
      res["ItemTime"] = boost::any(*itemTime);
    }
    if (itemValue) {
      res["ItemValue"] = boost::any(*itemValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Item") != m.end() && !m["Item"].empty()) {
      item = make_shared<string>(boost::any_cast<string>(m["Item"]));
    }
    if (m.find("ItemTime") != m.end() && !m["ItemTime"].empty()) {
      itemTime = make_shared<string>(boost::any_cast<string>(m["ItemTime"]));
    }
    if (m.find("ItemValue") != m.end() && !m["ItemValue"].empty()) {
      itemValue = make_shared<string>(boost::any_cast<string>(m["ItemValue"]));
    }
  }


  virtual ~DescribeInstancePacketsResponseBodyInstancePacketsMonitorItem() = default;
};
class DescribeInstancePacketsResponseBodyInstancePackets : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeInstancePacketsResponseBodyInstancePacketsMonitorItem>> monitorItem{};

  DescribeInstancePacketsResponseBodyInstancePackets() {}

  explicit DescribeInstancePacketsResponseBodyInstancePackets(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (monitorItem) {
      vector<boost::any> temp1;
      for(auto item1:*monitorItem){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["MonitorItem"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MonitorItem") != m.end() && !m["MonitorItem"].empty()) {
      if (typeid(vector<boost::any>) == m["MonitorItem"].type()) {
        vector<DescribeInstancePacketsResponseBodyInstancePacketsMonitorItem> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["MonitorItem"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeInstancePacketsResponseBodyInstancePacketsMonitorItem model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        monitorItem = make_shared<vector<DescribeInstancePacketsResponseBodyInstancePacketsMonitorItem>>(expect1);
      }
    }
  }


  virtual ~DescribeInstancePacketsResponseBodyInstancePackets() = default;
};
class DescribeInstancePacketsResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeInstancePacketsResponseBodyInstancePackets> instancePackets{};
  shared_ptr<string> requestId{};

  DescribeInstancePacketsResponseBody() {}

  explicit DescribeInstancePacketsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instancePackets) {
      res["InstancePackets"] = instancePackets ? boost::any(instancePackets->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstancePackets") != m.end() && !m["InstancePackets"].empty()) {
      if (typeid(map<string, boost::any>) == m["InstancePackets"].type()) {
        DescribeInstancePacketsResponseBodyInstancePackets model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InstancePackets"]));
        instancePackets = make_shared<DescribeInstancePacketsResponseBodyInstancePackets>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeInstancePacketsResponseBody() = default;
};
class DescribeInstancePacketsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeInstancePacketsResponseBody> body{};

  DescribeInstancePacketsResponse() {}

  explicit DescribeInstancePacketsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeInstancePacketsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeInstancePacketsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeInstancePacketsResponse() = default;
};
class DescribeInstanceQpsRequest : public Darabonba::Model {
public:
  shared_ptr<string> endTime{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> stageName{};
  shared_ptr<string> startTime{};

  DescribeInstanceQpsRequest() {}

  explicit DescribeInstanceQpsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (stageName) {
      res["StageName"] = boost::any(*stageName);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("StageName") != m.end() && !m["StageName"].empty()) {
      stageName = make_shared<string>(boost::any_cast<string>(m["StageName"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeInstanceQpsRequest() = default;
};
class DescribeInstanceQpsResponseBodyInstanceQpsMonitorItem : public Darabonba::Model {
public:
  shared_ptr<string> itemTime{};
  shared_ptr<string> itemValue{};

  DescribeInstanceQpsResponseBodyInstanceQpsMonitorItem() {}

  explicit DescribeInstanceQpsResponseBodyInstanceQpsMonitorItem(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (itemTime) {
      res["ItemTime"] = boost::any(*itemTime);
    }
    if (itemValue) {
      res["ItemValue"] = boost::any(*itemValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ItemTime") != m.end() && !m["ItemTime"].empty()) {
      itemTime = make_shared<string>(boost::any_cast<string>(m["ItemTime"]));
    }
    if (m.find("ItemValue") != m.end() && !m["ItemValue"].empty()) {
      itemValue = make_shared<string>(boost::any_cast<string>(m["ItemValue"]));
    }
  }


  virtual ~DescribeInstanceQpsResponseBodyInstanceQpsMonitorItem() = default;
};
class DescribeInstanceQpsResponseBodyInstanceQps : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeInstanceQpsResponseBodyInstanceQpsMonitorItem>> monitorItem{};

  DescribeInstanceQpsResponseBodyInstanceQps() {}

  explicit DescribeInstanceQpsResponseBodyInstanceQps(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (monitorItem) {
      vector<boost::any> temp1;
      for(auto item1:*monitorItem){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["MonitorItem"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MonitorItem") != m.end() && !m["MonitorItem"].empty()) {
      if (typeid(vector<boost::any>) == m["MonitorItem"].type()) {
        vector<DescribeInstanceQpsResponseBodyInstanceQpsMonitorItem> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["MonitorItem"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeInstanceQpsResponseBodyInstanceQpsMonitorItem model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        monitorItem = make_shared<vector<DescribeInstanceQpsResponseBodyInstanceQpsMonitorItem>>(expect1);
      }
    }
  }


  virtual ~DescribeInstanceQpsResponseBodyInstanceQps() = default;
};
class DescribeInstanceQpsResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeInstanceQpsResponseBodyInstanceQps> instanceQps{};
  shared_ptr<string> requestId{};

  DescribeInstanceQpsResponseBody() {}

  explicit DescribeInstanceQpsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceQps) {
      res["InstanceQps"] = instanceQps ? boost::any(instanceQps->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceQps") != m.end() && !m["InstanceQps"].empty()) {
      if (typeid(map<string, boost::any>) == m["InstanceQps"].type()) {
        DescribeInstanceQpsResponseBodyInstanceQps model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InstanceQps"]));
        instanceQps = make_shared<DescribeInstanceQpsResponseBodyInstanceQps>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeInstanceQpsResponseBody() = default;
};
class DescribeInstanceQpsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeInstanceQpsResponseBody> body{};

  DescribeInstanceQpsResponse() {}

  explicit DescribeInstanceQpsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeInstanceQpsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeInstanceQpsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeInstanceQpsResponse() = default;
};
class DescribeInstanceSlbConnectRequest : public Darabonba::Model {
public:
  shared_ptr<string> endTime{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> sbcName{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> startTime{};

  DescribeInstanceSlbConnectRequest() {}

  explicit DescribeInstanceSlbConnectRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (sbcName) {
      res["SbcName"] = boost::any(*sbcName);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("SbcName") != m.end() && !m["SbcName"].empty()) {
      sbcName = make_shared<string>(boost::any_cast<string>(m["SbcName"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeInstanceSlbConnectRequest() = default;
};
class DescribeInstanceSlbConnectResponseBodyInstanceSlbConnectMonitorItem : public Darabonba::Model {
public:
  shared_ptr<string> item{};
  shared_ptr<string> itemTime{};
  shared_ptr<string> itemValue{};

  DescribeInstanceSlbConnectResponseBodyInstanceSlbConnectMonitorItem() {}

  explicit DescribeInstanceSlbConnectResponseBodyInstanceSlbConnectMonitorItem(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (item) {
      res["Item"] = boost::any(*item);
    }
    if (itemTime) {
      res["ItemTime"] = boost::any(*itemTime);
    }
    if (itemValue) {
      res["ItemValue"] = boost::any(*itemValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Item") != m.end() && !m["Item"].empty()) {
      item = make_shared<string>(boost::any_cast<string>(m["Item"]));
    }
    if (m.find("ItemTime") != m.end() && !m["ItemTime"].empty()) {
      itemTime = make_shared<string>(boost::any_cast<string>(m["ItemTime"]));
    }
    if (m.find("ItemValue") != m.end() && !m["ItemValue"].empty()) {
      itemValue = make_shared<string>(boost::any_cast<string>(m["ItemValue"]));
    }
  }


  virtual ~DescribeInstanceSlbConnectResponseBodyInstanceSlbConnectMonitorItem() = default;
};
class DescribeInstanceSlbConnectResponseBodyInstanceSlbConnect : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeInstanceSlbConnectResponseBodyInstanceSlbConnectMonitorItem>> monitorItem{};

  DescribeInstanceSlbConnectResponseBodyInstanceSlbConnect() {}

  explicit DescribeInstanceSlbConnectResponseBodyInstanceSlbConnect(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (monitorItem) {
      vector<boost::any> temp1;
      for(auto item1:*monitorItem){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["MonitorItem"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MonitorItem") != m.end() && !m["MonitorItem"].empty()) {
      if (typeid(vector<boost::any>) == m["MonitorItem"].type()) {
        vector<DescribeInstanceSlbConnectResponseBodyInstanceSlbConnectMonitorItem> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["MonitorItem"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeInstanceSlbConnectResponseBodyInstanceSlbConnectMonitorItem model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        monitorItem = make_shared<vector<DescribeInstanceSlbConnectResponseBodyInstanceSlbConnectMonitorItem>>(expect1);
      }
    }
  }


  virtual ~DescribeInstanceSlbConnectResponseBodyInstanceSlbConnect() = default;
};
class DescribeInstanceSlbConnectResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeInstanceSlbConnectResponseBodyInstanceSlbConnect> instanceSlbConnect{};
  shared_ptr<string> requestId{};

  DescribeInstanceSlbConnectResponseBody() {}

  explicit DescribeInstanceSlbConnectResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceSlbConnect) {
      res["InstanceSlbConnect"] = instanceSlbConnect ? boost::any(instanceSlbConnect->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceSlbConnect") != m.end() && !m["InstanceSlbConnect"].empty()) {
      if (typeid(map<string, boost::any>) == m["InstanceSlbConnect"].type()) {
        DescribeInstanceSlbConnectResponseBodyInstanceSlbConnect model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InstanceSlbConnect"]));
        instanceSlbConnect = make_shared<DescribeInstanceSlbConnectResponseBodyInstanceSlbConnect>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeInstanceSlbConnectResponseBody() = default;
};
class DescribeInstanceSlbConnectResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeInstanceSlbConnectResponseBody> body{};

  DescribeInstanceSlbConnectResponse() {}

  explicit DescribeInstanceSlbConnectResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeInstanceSlbConnectResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeInstanceSlbConnectResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeInstanceSlbConnectResponse() = default;
};
class DescribeInstanceTrafficRequest : public Darabonba::Model {
public:
  shared_ptr<string> endTime{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> stageName{};
  shared_ptr<string> startTime{};

  DescribeInstanceTrafficRequest() {}

  explicit DescribeInstanceTrafficRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (stageName) {
      res["StageName"] = boost::any(*stageName);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("StageName") != m.end() && !m["StageName"].empty()) {
      stageName = make_shared<string>(boost::any_cast<string>(m["StageName"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeInstanceTrafficRequest() = default;
};
class DescribeInstanceTrafficResponseBodyInstanceTrafficMonitorItem : public Darabonba::Model {
public:
  shared_ptr<string> item{};
  shared_ptr<string> itemTime{};
  shared_ptr<string> itemValue{};

  DescribeInstanceTrafficResponseBodyInstanceTrafficMonitorItem() {}

  explicit DescribeInstanceTrafficResponseBodyInstanceTrafficMonitorItem(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (item) {
      res["Item"] = boost::any(*item);
    }
    if (itemTime) {
      res["ItemTime"] = boost::any(*itemTime);
    }
    if (itemValue) {
      res["ItemValue"] = boost::any(*itemValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Item") != m.end() && !m["Item"].empty()) {
      item = make_shared<string>(boost::any_cast<string>(m["Item"]));
    }
    if (m.find("ItemTime") != m.end() && !m["ItemTime"].empty()) {
      itemTime = make_shared<string>(boost::any_cast<string>(m["ItemTime"]));
    }
    if (m.find("ItemValue") != m.end() && !m["ItemValue"].empty()) {
      itemValue = make_shared<string>(boost::any_cast<string>(m["ItemValue"]));
    }
  }


  virtual ~DescribeInstanceTrafficResponseBodyInstanceTrafficMonitorItem() = default;
};
class DescribeInstanceTrafficResponseBodyInstanceTraffic : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeInstanceTrafficResponseBodyInstanceTrafficMonitorItem>> monitorItem{};

  DescribeInstanceTrafficResponseBodyInstanceTraffic() {}

  explicit DescribeInstanceTrafficResponseBodyInstanceTraffic(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (monitorItem) {
      vector<boost::any> temp1;
      for(auto item1:*monitorItem){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["MonitorItem"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MonitorItem") != m.end() && !m["MonitorItem"].empty()) {
      if (typeid(vector<boost::any>) == m["MonitorItem"].type()) {
        vector<DescribeInstanceTrafficResponseBodyInstanceTrafficMonitorItem> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["MonitorItem"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeInstanceTrafficResponseBodyInstanceTrafficMonitorItem model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        monitorItem = make_shared<vector<DescribeInstanceTrafficResponseBodyInstanceTrafficMonitorItem>>(expect1);
      }
    }
  }


  virtual ~DescribeInstanceTrafficResponseBodyInstanceTraffic() = default;
};
class DescribeInstanceTrafficResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeInstanceTrafficResponseBodyInstanceTraffic> instanceTraffic{};
  shared_ptr<string> requestId{};

  DescribeInstanceTrafficResponseBody() {}

  explicit DescribeInstanceTrafficResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceTraffic) {
      res["InstanceTraffic"] = instanceTraffic ? boost::any(instanceTraffic->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceTraffic") != m.end() && !m["InstanceTraffic"].empty()) {
      if (typeid(map<string, boost::any>) == m["InstanceTraffic"].type()) {
        DescribeInstanceTrafficResponseBodyInstanceTraffic model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InstanceTraffic"]));
        instanceTraffic = make_shared<DescribeInstanceTrafficResponseBodyInstanceTraffic>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeInstanceTrafficResponseBody() = default;
};
class DescribeInstanceTrafficResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeInstanceTrafficResponseBody> body{};

  DescribeInstanceTrafficResponse() {}

  explicit DescribeInstanceTrafficResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeInstanceTrafficResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeInstanceTrafficResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeInstanceTrafficResponse() = default;
};
class DescribeInstancesRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  DescribeInstancesRequestTag() {}

  explicit DescribeInstancesRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeInstancesRequestTag() = default;
};
class DescribeInstancesRequest : public Darabonba::Model {
public:
  shared_ptr<bool> enableTagAuthorization{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> language{};
  shared_ptr<string> securityToken{};
  shared_ptr<vector<DescribeInstancesRequestTag>> tag{};

  DescribeInstancesRequest() {}

  explicit DescribeInstancesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (enableTagAuthorization) {
      res["EnableTagAuthorization"] = boost::any(*enableTagAuthorization);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (language) {
      res["Language"] = boost::any(*language);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EnableTagAuthorization") != m.end() && !m["EnableTagAuthorization"].empty()) {
      enableTagAuthorization = make_shared<bool>(boost::any_cast<bool>(m["EnableTagAuthorization"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Language") != m.end() && !m["Language"].empty()) {
      language = make_shared<string>(boost::any_cast<string>(m["Language"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<DescribeInstancesRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeInstancesRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<DescribeInstancesRequestTag>>(expect1);
      }
    }
  }


  virtual ~DescribeInstancesRequest() = default;
};
class DescribeInstancesResponseBodyInstancesInstanceAttributeInstanceSpecAttributesSpecAttribute : public Darabonba::Model {
public:
  shared_ptr<string> localName{};
  shared_ptr<string> value{};

  DescribeInstancesResponseBodyInstancesInstanceAttributeInstanceSpecAttributesSpecAttribute() {}

  explicit DescribeInstancesResponseBodyInstancesInstanceAttributeInstanceSpecAttributesSpecAttribute(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (localName) {
      res["LocalName"] = boost::any(*localName);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LocalName") != m.end() && !m["LocalName"].empty()) {
      localName = make_shared<string>(boost::any_cast<string>(m["LocalName"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeInstancesResponseBodyInstancesInstanceAttributeInstanceSpecAttributesSpecAttribute() = default;
};
class DescribeInstancesResponseBodyInstancesInstanceAttributeInstanceSpecAttributes : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeInstancesResponseBodyInstancesInstanceAttributeInstanceSpecAttributesSpecAttribute>> specAttribute{};

  DescribeInstancesResponseBodyInstancesInstanceAttributeInstanceSpecAttributes() {}

  explicit DescribeInstancesResponseBodyInstancesInstanceAttributeInstanceSpecAttributes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (specAttribute) {
      vector<boost::any> temp1;
      for(auto item1:*specAttribute){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SpecAttribute"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SpecAttribute") != m.end() && !m["SpecAttribute"].empty()) {
      if (typeid(vector<boost::any>) == m["SpecAttribute"].type()) {
        vector<DescribeInstancesResponseBodyInstancesInstanceAttributeInstanceSpecAttributesSpecAttribute> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SpecAttribute"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeInstancesResponseBodyInstancesInstanceAttributeInstanceSpecAttributesSpecAttribute model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        specAttribute = make_shared<vector<DescribeInstancesResponseBodyInstancesInstanceAttributeInstanceSpecAttributesSpecAttribute>>(expect1);
      }
    }
  }


  virtual ~DescribeInstancesResponseBodyInstancesInstanceAttributeInstanceSpecAttributes() = default;
};
class DescribeInstancesResponseBodyInstancesInstanceAttributeNetworkInterfaceAttributesNetworkInterfaceAttribute : public Darabonba::Model {
public:
  shared_ptr<string> cidrBlock{};
  shared_ptr<string> securityGroupId{};
  shared_ptr<string> vswitchId{};
  shared_ptr<string> zoneId{};

  DescribeInstancesResponseBodyInstancesInstanceAttributeNetworkInterfaceAttributesNetworkInterfaceAttribute() {}

  explicit DescribeInstancesResponseBodyInstancesInstanceAttributeNetworkInterfaceAttributesNetworkInterfaceAttribute(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cidrBlock) {
      res["CidrBlock"] = boost::any(*cidrBlock);
    }
    if (securityGroupId) {
      res["SecurityGroupId"] = boost::any(*securityGroupId);
    }
    if (vswitchId) {
      res["VswitchId"] = boost::any(*vswitchId);
    }
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CidrBlock") != m.end() && !m["CidrBlock"].empty()) {
      cidrBlock = make_shared<string>(boost::any_cast<string>(m["CidrBlock"]));
    }
    if (m.find("SecurityGroupId") != m.end() && !m["SecurityGroupId"].empty()) {
      securityGroupId = make_shared<string>(boost::any_cast<string>(m["SecurityGroupId"]));
    }
    if (m.find("VswitchId") != m.end() && !m["VswitchId"].empty()) {
      vswitchId = make_shared<string>(boost::any_cast<string>(m["VswitchId"]));
    }
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["ZoneId"]));
    }
  }


  virtual ~DescribeInstancesResponseBodyInstancesInstanceAttributeNetworkInterfaceAttributesNetworkInterfaceAttribute() = default;
};
class DescribeInstancesResponseBodyInstancesInstanceAttributeNetworkInterfaceAttributes : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeInstancesResponseBodyInstancesInstanceAttributeNetworkInterfaceAttributesNetworkInterfaceAttribute>> networkInterfaceAttribute{};

  DescribeInstancesResponseBodyInstancesInstanceAttributeNetworkInterfaceAttributes() {}

  explicit DescribeInstancesResponseBodyInstancesInstanceAttributeNetworkInterfaceAttributes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (networkInterfaceAttribute) {
      vector<boost::any> temp1;
      for(auto item1:*networkInterfaceAttribute){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["NetworkInterfaceAttribute"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NetworkInterfaceAttribute") != m.end() && !m["NetworkInterfaceAttribute"].empty()) {
      if (typeid(vector<boost::any>) == m["NetworkInterfaceAttribute"].type()) {
        vector<DescribeInstancesResponseBodyInstancesInstanceAttributeNetworkInterfaceAttributesNetworkInterfaceAttribute> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["NetworkInterfaceAttribute"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeInstancesResponseBodyInstancesInstanceAttributeNetworkInterfaceAttributesNetworkInterfaceAttribute model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        networkInterfaceAttribute = make_shared<vector<DescribeInstancesResponseBodyInstancesInstanceAttributeNetworkInterfaceAttributesNetworkInterfaceAttribute>>(expect1);
      }
    }
  }


  virtual ~DescribeInstancesResponseBodyInstancesInstanceAttributeNetworkInterfaceAttributes() = default;
};
class DescribeInstancesResponseBodyInstancesInstanceAttributePrivateDnsList : public Darabonba::Model {
public:
  shared_ptr<vector<string>> privateDns{};

  DescribeInstancesResponseBodyInstancesInstanceAttributePrivateDnsList() {}

  explicit DescribeInstancesResponseBodyInstancesInstanceAttributePrivateDnsList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (privateDns) {
      res["PrivateDns"] = boost::any(*privateDns);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PrivateDns") != m.end() && !m["PrivateDns"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["PrivateDns"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["PrivateDns"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      privateDns = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeInstancesResponseBodyInstancesInstanceAttributePrivateDnsList() = default;
};
class DescribeInstancesResponseBodyInstancesInstanceAttributeTagsTagInfo : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  DescribeInstancesResponseBodyInstancesInstanceAttributeTagsTagInfo() {}

  explicit DescribeInstancesResponseBodyInstancesInstanceAttributeTagsTagInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeInstancesResponseBodyInstancesInstanceAttributeTagsTagInfo() = default;
};
class DescribeInstancesResponseBodyInstancesInstanceAttributeTags : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeInstancesResponseBodyInstancesInstanceAttributeTagsTagInfo>> tagInfo{};

  DescribeInstancesResponseBodyInstancesInstanceAttributeTags() {}

  explicit DescribeInstancesResponseBodyInstancesInstanceAttributeTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tagInfo) {
      vector<boost::any> temp1;
      for(auto item1:*tagInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TagInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TagInfo") != m.end() && !m["TagInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["TagInfo"].type()) {
        vector<DescribeInstancesResponseBodyInstancesInstanceAttributeTagsTagInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TagInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeInstancesResponseBodyInstancesInstanceAttributeTagsTagInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tagInfo = make_shared<vector<DescribeInstancesResponseBodyInstancesInstanceAttributeTagsTagInfo>>(expect1);
      }
    }
  }


  virtual ~DescribeInstancesResponseBodyInstancesInstanceAttributeTags() = default;
};
class DescribeInstancesResponseBodyInstancesInstanceAttribute : public Darabonba::Model {
public:
  shared_ptr<string> aclId{};
  shared_ptr<string> aclName{};
  shared_ptr<string> aclStatus{};
  shared_ptr<string> aclType{};
  shared_ptr<string> classicEgressAddress{};
  shared_ptr<string> connectCidrBlocks{};
  shared_ptr<string> connectVpcId{};
  shared_ptr<string> createdTime{};
  shared_ptr<string> dedicatedInstanceType{};
  shared_ptr<bool> egressIpv6Enable{};
  shared_ptr<string> expiredTime{};
  shared_ptr<string> httpsPolicies{};
  shared_ptr<string> IPV6AclId{};
  shared_ptr<string> IPV6AclName{};
  shared_ptr<string> IPV6AclStatus{};
  shared_ptr<string> IPV6AclType{};
  shared_ptr<string> instanceChargeType{};
  shared_ptr<string> instanceCidrBlock{};
  shared_ptr<string> instanceClusterId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> instanceName{};
  shared_ptr<long> instanceRpsLimit{};
  shared_ptr<string> instanceSpec{};
  shared_ptr<DescribeInstancesResponseBodyInstancesInstanceAttributeInstanceSpecAttributes> instanceSpecAttributes{};
  shared_ptr<string> instanceType{};
  shared_ptr<string> internetEgressAddress{};
  shared_ptr<string> intranetSegments{};
  shared_ptr<string> maintainEndTime{};
  shared_ptr<string> maintainStartTime{};
  shared_ptr<DescribeInstancesResponseBodyInstancesInstanceAttributeNetworkInterfaceAttributes> networkInterfaceAttributes{};
  shared_ptr<DescribeInstancesResponseBodyInstancesInstanceAttributePrivateDnsList> privateDnsList{};
  shared_ptr<string> regionId{};
  shared_ptr<string> status{};
  shared_ptr<bool> supportIpv6{};
  shared_ptr<DescribeInstancesResponseBodyInstancesInstanceAttributeTags> tags{};
  shared_ptr<string> userVpcId{};
  shared_ptr<string> userVswitchId{};
  shared_ptr<string> vpcEgressAddress{};
  shared_ptr<bool> vpcIntranetEnable{};
  shared_ptr<long> vpcOwnerId{};
  shared_ptr<bool> vpcSlbIntranetEnable{};
  shared_ptr<string> zoneId{};
  shared_ptr<string> zoneLocalName{};

  DescribeInstancesResponseBodyInstancesInstanceAttribute() {}

  explicit DescribeInstancesResponseBodyInstancesInstanceAttribute(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aclId) {
      res["AclId"] = boost::any(*aclId);
    }
    if (aclName) {
      res["AclName"] = boost::any(*aclName);
    }
    if (aclStatus) {
      res["AclStatus"] = boost::any(*aclStatus);
    }
    if (aclType) {
      res["AclType"] = boost::any(*aclType);
    }
    if (classicEgressAddress) {
      res["ClassicEgressAddress"] = boost::any(*classicEgressAddress);
    }
    if (connectCidrBlocks) {
      res["ConnectCidrBlocks"] = boost::any(*connectCidrBlocks);
    }
    if (connectVpcId) {
      res["ConnectVpcId"] = boost::any(*connectVpcId);
    }
    if (createdTime) {
      res["CreatedTime"] = boost::any(*createdTime);
    }
    if (dedicatedInstanceType) {
      res["DedicatedInstanceType"] = boost::any(*dedicatedInstanceType);
    }
    if (egressIpv6Enable) {
      res["EgressIpv6Enable"] = boost::any(*egressIpv6Enable);
    }
    if (expiredTime) {
      res["ExpiredTime"] = boost::any(*expiredTime);
    }
    if (httpsPolicies) {
      res["HttpsPolicies"] = boost::any(*httpsPolicies);
    }
    if (IPV6AclId) {
      res["IPV6AclId"] = boost::any(*IPV6AclId);
    }
    if (IPV6AclName) {
      res["IPV6AclName"] = boost::any(*IPV6AclName);
    }
    if (IPV6AclStatus) {
      res["IPV6AclStatus"] = boost::any(*IPV6AclStatus);
    }
    if (IPV6AclType) {
      res["IPV6AclType"] = boost::any(*IPV6AclType);
    }
    if (instanceChargeType) {
      res["InstanceChargeType"] = boost::any(*instanceChargeType);
    }
    if (instanceCidrBlock) {
      res["InstanceCidrBlock"] = boost::any(*instanceCidrBlock);
    }
    if (instanceClusterId) {
      res["InstanceClusterId"] = boost::any(*instanceClusterId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (instanceName) {
      res["InstanceName"] = boost::any(*instanceName);
    }
    if (instanceRpsLimit) {
      res["InstanceRpsLimit"] = boost::any(*instanceRpsLimit);
    }
    if (instanceSpec) {
      res["InstanceSpec"] = boost::any(*instanceSpec);
    }
    if (instanceSpecAttributes) {
      res["InstanceSpecAttributes"] = instanceSpecAttributes ? boost::any(instanceSpecAttributes->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (internetEgressAddress) {
      res["InternetEgressAddress"] = boost::any(*internetEgressAddress);
    }
    if (intranetSegments) {
      res["IntranetSegments"] = boost::any(*intranetSegments);
    }
    if (maintainEndTime) {
      res["MaintainEndTime"] = boost::any(*maintainEndTime);
    }
    if (maintainStartTime) {
      res["MaintainStartTime"] = boost::any(*maintainStartTime);
    }
    if (networkInterfaceAttributes) {
      res["NetworkInterfaceAttributes"] = networkInterfaceAttributes ? boost::any(networkInterfaceAttributes->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (privateDnsList) {
      res["PrivateDnsList"] = privateDnsList ? boost::any(privateDnsList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (supportIpv6) {
      res["SupportIpv6"] = boost::any(*supportIpv6);
    }
    if (tags) {
      res["Tags"] = tags ? boost::any(tags->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (userVpcId) {
      res["UserVpcId"] = boost::any(*userVpcId);
    }
    if (userVswitchId) {
      res["UserVswitchId"] = boost::any(*userVswitchId);
    }
    if (vpcEgressAddress) {
      res["VpcEgressAddress"] = boost::any(*vpcEgressAddress);
    }
    if (vpcIntranetEnable) {
      res["VpcIntranetEnable"] = boost::any(*vpcIntranetEnable);
    }
    if (vpcOwnerId) {
      res["VpcOwnerId"] = boost::any(*vpcOwnerId);
    }
    if (vpcSlbIntranetEnable) {
      res["VpcSlbIntranetEnable"] = boost::any(*vpcSlbIntranetEnable);
    }
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    if (zoneLocalName) {
      res["ZoneLocalName"] = boost::any(*zoneLocalName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AclId") != m.end() && !m["AclId"].empty()) {
      aclId = make_shared<string>(boost::any_cast<string>(m["AclId"]));
    }
    if (m.find("AclName") != m.end() && !m["AclName"].empty()) {
      aclName = make_shared<string>(boost::any_cast<string>(m["AclName"]));
    }
    if (m.find("AclStatus") != m.end() && !m["AclStatus"].empty()) {
      aclStatus = make_shared<string>(boost::any_cast<string>(m["AclStatus"]));
    }
    if (m.find("AclType") != m.end() && !m["AclType"].empty()) {
      aclType = make_shared<string>(boost::any_cast<string>(m["AclType"]));
    }
    if (m.find("ClassicEgressAddress") != m.end() && !m["ClassicEgressAddress"].empty()) {
      classicEgressAddress = make_shared<string>(boost::any_cast<string>(m["ClassicEgressAddress"]));
    }
    if (m.find("ConnectCidrBlocks") != m.end() && !m["ConnectCidrBlocks"].empty()) {
      connectCidrBlocks = make_shared<string>(boost::any_cast<string>(m["ConnectCidrBlocks"]));
    }
    if (m.find("ConnectVpcId") != m.end() && !m["ConnectVpcId"].empty()) {
      connectVpcId = make_shared<string>(boost::any_cast<string>(m["ConnectVpcId"]));
    }
    if (m.find("CreatedTime") != m.end() && !m["CreatedTime"].empty()) {
      createdTime = make_shared<string>(boost::any_cast<string>(m["CreatedTime"]));
    }
    if (m.find("DedicatedInstanceType") != m.end() && !m["DedicatedInstanceType"].empty()) {
      dedicatedInstanceType = make_shared<string>(boost::any_cast<string>(m["DedicatedInstanceType"]));
    }
    if (m.find("EgressIpv6Enable") != m.end() && !m["EgressIpv6Enable"].empty()) {
      egressIpv6Enable = make_shared<bool>(boost::any_cast<bool>(m["EgressIpv6Enable"]));
    }
    if (m.find("ExpiredTime") != m.end() && !m["ExpiredTime"].empty()) {
      expiredTime = make_shared<string>(boost::any_cast<string>(m["ExpiredTime"]));
    }
    if (m.find("HttpsPolicies") != m.end() && !m["HttpsPolicies"].empty()) {
      httpsPolicies = make_shared<string>(boost::any_cast<string>(m["HttpsPolicies"]));
    }
    if (m.find("IPV6AclId") != m.end() && !m["IPV6AclId"].empty()) {
      IPV6AclId = make_shared<string>(boost::any_cast<string>(m["IPV6AclId"]));
    }
    if (m.find("IPV6AclName") != m.end() && !m["IPV6AclName"].empty()) {
      IPV6AclName = make_shared<string>(boost::any_cast<string>(m["IPV6AclName"]));
    }
    if (m.find("IPV6AclStatus") != m.end() && !m["IPV6AclStatus"].empty()) {
      IPV6AclStatus = make_shared<string>(boost::any_cast<string>(m["IPV6AclStatus"]));
    }
    if (m.find("IPV6AclType") != m.end() && !m["IPV6AclType"].empty()) {
      IPV6AclType = make_shared<string>(boost::any_cast<string>(m["IPV6AclType"]));
    }
    if (m.find("InstanceChargeType") != m.end() && !m["InstanceChargeType"].empty()) {
      instanceChargeType = make_shared<string>(boost::any_cast<string>(m["InstanceChargeType"]));
    }
    if (m.find("InstanceCidrBlock") != m.end() && !m["InstanceCidrBlock"].empty()) {
      instanceCidrBlock = make_shared<string>(boost::any_cast<string>(m["InstanceCidrBlock"]));
    }
    if (m.find("InstanceClusterId") != m.end() && !m["InstanceClusterId"].empty()) {
      instanceClusterId = make_shared<string>(boost::any_cast<string>(m["InstanceClusterId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("InstanceName") != m.end() && !m["InstanceName"].empty()) {
      instanceName = make_shared<string>(boost::any_cast<string>(m["InstanceName"]));
    }
    if (m.find("InstanceRpsLimit") != m.end() && !m["InstanceRpsLimit"].empty()) {
      instanceRpsLimit = make_shared<long>(boost::any_cast<long>(m["InstanceRpsLimit"]));
    }
    if (m.find("InstanceSpec") != m.end() && !m["InstanceSpec"].empty()) {
      instanceSpec = make_shared<string>(boost::any_cast<string>(m["InstanceSpec"]));
    }
    if (m.find("InstanceSpecAttributes") != m.end() && !m["InstanceSpecAttributes"].empty()) {
      if (typeid(map<string, boost::any>) == m["InstanceSpecAttributes"].type()) {
        DescribeInstancesResponseBodyInstancesInstanceAttributeInstanceSpecAttributes model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InstanceSpecAttributes"]));
        instanceSpecAttributes = make_shared<DescribeInstancesResponseBodyInstancesInstanceAttributeInstanceSpecAttributes>(model1);
      }
    }
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("InternetEgressAddress") != m.end() && !m["InternetEgressAddress"].empty()) {
      internetEgressAddress = make_shared<string>(boost::any_cast<string>(m["InternetEgressAddress"]));
    }
    if (m.find("IntranetSegments") != m.end() && !m["IntranetSegments"].empty()) {
      intranetSegments = make_shared<string>(boost::any_cast<string>(m["IntranetSegments"]));
    }
    if (m.find("MaintainEndTime") != m.end() && !m["MaintainEndTime"].empty()) {
      maintainEndTime = make_shared<string>(boost::any_cast<string>(m["MaintainEndTime"]));
    }
    if (m.find("MaintainStartTime") != m.end() && !m["MaintainStartTime"].empty()) {
      maintainStartTime = make_shared<string>(boost::any_cast<string>(m["MaintainStartTime"]));
    }
    if (m.find("NetworkInterfaceAttributes") != m.end() && !m["NetworkInterfaceAttributes"].empty()) {
      if (typeid(map<string, boost::any>) == m["NetworkInterfaceAttributes"].type()) {
        DescribeInstancesResponseBodyInstancesInstanceAttributeNetworkInterfaceAttributes model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["NetworkInterfaceAttributes"]));
        networkInterfaceAttributes = make_shared<DescribeInstancesResponseBodyInstancesInstanceAttributeNetworkInterfaceAttributes>(model1);
      }
    }
    if (m.find("PrivateDnsList") != m.end() && !m["PrivateDnsList"].empty()) {
      if (typeid(map<string, boost::any>) == m["PrivateDnsList"].type()) {
        DescribeInstancesResponseBodyInstancesInstanceAttributePrivateDnsList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PrivateDnsList"]));
        privateDnsList = make_shared<DescribeInstancesResponseBodyInstancesInstanceAttributePrivateDnsList>(model1);
      }
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("SupportIpv6") != m.end() && !m["SupportIpv6"].empty()) {
      supportIpv6 = make_shared<bool>(boost::any_cast<bool>(m["SupportIpv6"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(map<string, boost::any>) == m["Tags"].type()) {
        DescribeInstancesResponseBodyInstancesInstanceAttributeTags model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Tags"]));
        tags = make_shared<DescribeInstancesResponseBodyInstancesInstanceAttributeTags>(model1);
      }
    }
    if (m.find("UserVpcId") != m.end() && !m["UserVpcId"].empty()) {
      userVpcId = make_shared<string>(boost::any_cast<string>(m["UserVpcId"]));
    }
    if (m.find("UserVswitchId") != m.end() && !m["UserVswitchId"].empty()) {
      userVswitchId = make_shared<string>(boost::any_cast<string>(m["UserVswitchId"]));
    }
    if (m.find("VpcEgressAddress") != m.end() && !m["VpcEgressAddress"].empty()) {
      vpcEgressAddress = make_shared<string>(boost::any_cast<string>(m["VpcEgressAddress"]));
    }
    if (m.find("VpcIntranetEnable") != m.end() && !m["VpcIntranetEnable"].empty()) {
      vpcIntranetEnable = make_shared<bool>(boost::any_cast<bool>(m["VpcIntranetEnable"]));
    }
    if (m.find("VpcOwnerId") != m.end() && !m["VpcOwnerId"].empty()) {
      vpcOwnerId = make_shared<long>(boost::any_cast<long>(m["VpcOwnerId"]));
    }
    if (m.find("VpcSlbIntranetEnable") != m.end() && !m["VpcSlbIntranetEnable"].empty()) {
      vpcSlbIntranetEnable = make_shared<bool>(boost::any_cast<bool>(m["VpcSlbIntranetEnable"]));
    }
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["ZoneId"]));
    }
    if (m.find("ZoneLocalName") != m.end() && !m["ZoneLocalName"].empty()) {
      zoneLocalName = make_shared<string>(boost::any_cast<string>(m["ZoneLocalName"]));
    }
  }


  virtual ~DescribeInstancesResponseBodyInstancesInstanceAttribute() = default;
};
class DescribeInstancesResponseBodyInstances : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeInstancesResponseBodyInstancesInstanceAttribute>> instanceAttribute{};

  DescribeInstancesResponseBodyInstances() {}

  explicit DescribeInstancesResponseBodyInstances(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceAttribute) {
      vector<boost::any> temp1;
      for(auto item1:*instanceAttribute){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["InstanceAttribute"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceAttribute") != m.end() && !m["InstanceAttribute"].empty()) {
      if (typeid(vector<boost::any>) == m["InstanceAttribute"].type()) {
        vector<DescribeInstancesResponseBodyInstancesInstanceAttribute> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["InstanceAttribute"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeInstancesResponseBodyInstancesInstanceAttribute model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        instanceAttribute = make_shared<vector<DescribeInstancesResponseBodyInstancesInstanceAttribute>>(expect1);
      }
    }
  }


  virtual ~DescribeInstancesResponseBodyInstances() = default;
};
class DescribeInstancesResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeInstancesResponseBodyInstances> instances{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeInstancesResponseBody() {}

  explicit DescribeInstancesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instances) {
      res["Instances"] = instances ? boost::any(instances->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Instances") != m.end() && !m["Instances"].empty()) {
      if (typeid(map<string, boost::any>) == m["Instances"].type()) {
        DescribeInstancesResponseBodyInstances model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Instances"]));
        instances = make_shared<DescribeInstancesResponseBodyInstances>(model1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeInstancesResponseBody() = default;
};
class DescribeInstancesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeInstancesResponseBody> body{};

  DescribeInstancesResponse() {}

  explicit DescribeInstancesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeInstancesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeInstancesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeInstancesResponse() = default;
};
class DescribeIpControlPolicyItemsRequest : public Darabonba::Model {
public:
  shared_ptr<string> ipControlId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> policyItemId{};
  shared_ptr<string> securityToken{};

  DescribeIpControlPolicyItemsRequest() {}

  explicit DescribeIpControlPolicyItemsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ipControlId) {
      res["IpControlId"] = boost::any(*ipControlId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (policyItemId) {
      res["PolicyItemId"] = boost::any(*policyItemId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IpControlId") != m.end() && !m["IpControlId"].empty()) {
      ipControlId = make_shared<string>(boost::any_cast<string>(m["IpControlId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("PolicyItemId") != m.end() && !m["PolicyItemId"].empty()) {
      policyItemId = make_shared<string>(boost::any_cast<string>(m["PolicyItemId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~DescribeIpControlPolicyItemsRequest() = default;
};
class DescribeIpControlPolicyItemsResponseBodyIpControlPolicyItemsIpControlPolicyItem : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> cidrIp{};
  shared_ptr<string> createTime{};
  shared_ptr<string> modifiedTime{};
  shared_ptr<string> policyItemId{};

  DescribeIpControlPolicyItemsResponseBodyIpControlPolicyItemsIpControlPolicyItem() {}

  explicit DescribeIpControlPolicyItemsResponseBodyIpControlPolicyItemsIpControlPolicyItem(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (cidrIp) {
      res["CidrIp"] = boost::any(*cidrIp);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (modifiedTime) {
      res["ModifiedTime"] = boost::any(*modifiedTime);
    }
    if (policyItemId) {
      res["PolicyItemId"] = boost::any(*policyItemId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("CidrIp") != m.end() && !m["CidrIp"].empty()) {
      cidrIp = make_shared<string>(boost::any_cast<string>(m["CidrIp"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("ModifiedTime") != m.end() && !m["ModifiedTime"].empty()) {
      modifiedTime = make_shared<string>(boost::any_cast<string>(m["ModifiedTime"]));
    }
    if (m.find("PolicyItemId") != m.end() && !m["PolicyItemId"].empty()) {
      policyItemId = make_shared<string>(boost::any_cast<string>(m["PolicyItemId"]));
    }
  }


  virtual ~DescribeIpControlPolicyItemsResponseBodyIpControlPolicyItemsIpControlPolicyItem() = default;
};
class DescribeIpControlPolicyItemsResponseBodyIpControlPolicyItems : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeIpControlPolicyItemsResponseBodyIpControlPolicyItemsIpControlPolicyItem>> ipControlPolicyItem{};

  DescribeIpControlPolicyItemsResponseBodyIpControlPolicyItems() {}

  explicit DescribeIpControlPolicyItemsResponseBodyIpControlPolicyItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ipControlPolicyItem) {
      vector<boost::any> temp1;
      for(auto item1:*ipControlPolicyItem){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["IpControlPolicyItem"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IpControlPolicyItem") != m.end() && !m["IpControlPolicyItem"].empty()) {
      if (typeid(vector<boost::any>) == m["IpControlPolicyItem"].type()) {
        vector<DescribeIpControlPolicyItemsResponseBodyIpControlPolicyItemsIpControlPolicyItem> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["IpControlPolicyItem"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeIpControlPolicyItemsResponseBodyIpControlPolicyItemsIpControlPolicyItem model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ipControlPolicyItem = make_shared<vector<DescribeIpControlPolicyItemsResponseBodyIpControlPolicyItemsIpControlPolicyItem>>(expect1);
      }
    }
  }


  virtual ~DescribeIpControlPolicyItemsResponseBodyIpControlPolicyItems() = default;
};
class DescribeIpControlPolicyItemsResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeIpControlPolicyItemsResponseBodyIpControlPolicyItems> ipControlPolicyItems{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeIpControlPolicyItemsResponseBody() {}

  explicit DescribeIpControlPolicyItemsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ipControlPolicyItems) {
      res["IpControlPolicyItems"] = ipControlPolicyItems ? boost::any(ipControlPolicyItems->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IpControlPolicyItems") != m.end() && !m["IpControlPolicyItems"].empty()) {
      if (typeid(map<string, boost::any>) == m["IpControlPolicyItems"].type()) {
        DescribeIpControlPolicyItemsResponseBodyIpControlPolicyItems model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["IpControlPolicyItems"]));
        ipControlPolicyItems = make_shared<DescribeIpControlPolicyItemsResponseBodyIpControlPolicyItems>(model1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeIpControlPolicyItemsResponseBody() = default;
};
class DescribeIpControlPolicyItemsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeIpControlPolicyItemsResponseBody> body{};

  DescribeIpControlPolicyItemsResponse() {}

  explicit DescribeIpControlPolicyItemsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeIpControlPolicyItemsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeIpControlPolicyItemsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeIpControlPolicyItemsResponse() = default;
};
class DescribeIpControlsRequest : public Darabonba::Model {
public:
  shared_ptr<string> ipControlId{};
  shared_ptr<string> ipControlName{};
  shared_ptr<string> ipControlType{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> securityToken{};

  DescribeIpControlsRequest() {}

  explicit DescribeIpControlsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ipControlId) {
      res["IpControlId"] = boost::any(*ipControlId);
    }
    if (ipControlName) {
      res["IpControlName"] = boost::any(*ipControlName);
    }
    if (ipControlType) {
      res["IpControlType"] = boost::any(*ipControlType);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IpControlId") != m.end() && !m["IpControlId"].empty()) {
      ipControlId = make_shared<string>(boost::any_cast<string>(m["IpControlId"]));
    }
    if (m.find("IpControlName") != m.end() && !m["IpControlName"].empty()) {
      ipControlName = make_shared<string>(boost::any_cast<string>(m["IpControlName"]));
    }
    if (m.find("IpControlType") != m.end() && !m["IpControlType"].empty()) {
      ipControlType = make_shared<string>(boost::any_cast<string>(m["IpControlType"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~DescribeIpControlsRequest() = default;
};
class DescribeIpControlsResponseBodyIpControlInfosIpControlInfo : public Darabonba::Model {
public:
  shared_ptr<string> createTime{};
  shared_ptr<string> description{};
  shared_ptr<string> ipControlId{};
  shared_ptr<string> ipControlName{};
  shared_ptr<string> ipControlType{};
  shared_ptr<string> modifiedTime{};
  shared_ptr<string> regionId{};

  DescribeIpControlsResponseBodyIpControlInfosIpControlInfo() {}

  explicit DescribeIpControlsResponseBodyIpControlInfosIpControlInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (ipControlId) {
      res["IpControlId"] = boost::any(*ipControlId);
    }
    if (ipControlName) {
      res["IpControlName"] = boost::any(*ipControlName);
    }
    if (ipControlType) {
      res["IpControlType"] = boost::any(*ipControlType);
    }
    if (modifiedTime) {
      res["ModifiedTime"] = boost::any(*modifiedTime);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("IpControlId") != m.end() && !m["IpControlId"].empty()) {
      ipControlId = make_shared<string>(boost::any_cast<string>(m["IpControlId"]));
    }
    if (m.find("IpControlName") != m.end() && !m["IpControlName"].empty()) {
      ipControlName = make_shared<string>(boost::any_cast<string>(m["IpControlName"]));
    }
    if (m.find("IpControlType") != m.end() && !m["IpControlType"].empty()) {
      ipControlType = make_shared<string>(boost::any_cast<string>(m["IpControlType"]));
    }
    if (m.find("ModifiedTime") != m.end() && !m["ModifiedTime"].empty()) {
      modifiedTime = make_shared<string>(boost::any_cast<string>(m["ModifiedTime"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DescribeIpControlsResponseBodyIpControlInfosIpControlInfo() = default;
};
class DescribeIpControlsResponseBodyIpControlInfos : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeIpControlsResponseBodyIpControlInfosIpControlInfo>> ipControlInfo{};

  DescribeIpControlsResponseBodyIpControlInfos() {}

  explicit DescribeIpControlsResponseBodyIpControlInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ipControlInfo) {
      vector<boost::any> temp1;
      for(auto item1:*ipControlInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["IpControlInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IpControlInfo") != m.end() && !m["IpControlInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["IpControlInfo"].type()) {
        vector<DescribeIpControlsResponseBodyIpControlInfosIpControlInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["IpControlInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeIpControlsResponseBodyIpControlInfosIpControlInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ipControlInfo = make_shared<vector<DescribeIpControlsResponseBodyIpControlInfosIpControlInfo>>(expect1);
      }
    }
  }


  virtual ~DescribeIpControlsResponseBodyIpControlInfos() = default;
};
class DescribeIpControlsResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeIpControlsResponseBodyIpControlInfos> ipControlInfos{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeIpControlsResponseBody() {}

  explicit DescribeIpControlsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ipControlInfos) {
      res["IpControlInfos"] = ipControlInfos ? boost::any(ipControlInfos->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IpControlInfos") != m.end() && !m["IpControlInfos"].empty()) {
      if (typeid(map<string, boost::any>) == m["IpControlInfos"].type()) {
        DescribeIpControlsResponseBodyIpControlInfos model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["IpControlInfos"]));
        ipControlInfos = make_shared<DescribeIpControlsResponseBodyIpControlInfos>(model1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeIpControlsResponseBody() = default;
};
class DescribeIpControlsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeIpControlsResponseBody> body{};

  DescribeIpControlsResponse() {}

  explicit DescribeIpControlsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeIpControlsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeIpControlsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeIpControlsResponse() = default;
};
class DescribeLogConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> logType{};
  shared_ptr<string> securityToken{};

  DescribeLogConfigRequest() {}

  explicit DescribeLogConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (logType) {
      res["LogType"] = boost::any(*logType);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LogType") != m.end() && !m["LogType"].empty()) {
      logType = make_shared<string>(boost::any_cast<string>(m["LogType"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~DescribeLogConfigRequest() = default;
};
class DescribeLogConfigResponseBodyLogInfosLogInfo : public Darabonba::Model {
public:
  shared_ptr<string> logType{};
  shared_ptr<string> regionId{};
  shared_ptr<string> slsLogStore{};
  shared_ptr<string> slsProject{};

  DescribeLogConfigResponseBodyLogInfosLogInfo() {}

  explicit DescribeLogConfigResponseBodyLogInfosLogInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (logType) {
      res["LogType"] = boost::any(*logType);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (slsLogStore) {
      res["SlsLogStore"] = boost::any(*slsLogStore);
    }
    if (slsProject) {
      res["SlsProject"] = boost::any(*slsProject);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LogType") != m.end() && !m["LogType"].empty()) {
      logType = make_shared<string>(boost::any_cast<string>(m["LogType"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SlsLogStore") != m.end() && !m["SlsLogStore"].empty()) {
      slsLogStore = make_shared<string>(boost::any_cast<string>(m["SlsLogStore"]));
    }
    if (m.find("SlsProject") != m.end() && !m["SlsProject"].empty()) {
      slsProject = make_shared<string>(boost::any_cast<string>(m["SlsProject"]));
    }
  }


  virtual ~DescribeLogConfigResponseBodyLogInfosLogInfo() = default;
};
class DescribeLogConfigResponseBodyLogInfos : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeLogConfigResponseBodyLogInfosLogInfo>> logInfo{};

  DescribeLogConfigResponseBodyLogInfos() {}

  explicit DescribeLogConfigResponseBodyLogInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (logInfo) {
      vector<boost::any> temp1;
      for(auto item1:*logInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["LogInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LogInfo") != m.end() && !m["LogInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["LogInfo"].type()) {
        vector<DescribeLogConfigResponseBodyLogInfosLogInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["LogInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeLogConfigResponseBodyLogInfosLogInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        logInfo = make_shared<vector<DescribeLogConfigResponseBodyLogInfosLogInfo>>(expect1);
      }
    }
  }


  virtual ~DescribeLogConfigResponseBodyLogInfos() = default;
};
class DescribeLogConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeLogConfigResponseBodyLogInfos> logInfos{};
  shared_ptr<string> requestId{};

  DescribeLogConfigResponseBody() {}

  explicit DescribeLogConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (logInfos) {
      res["LogInfos"] = logInfos ? boost::any(logInfos->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LogInfos") != m.end() && !m["LogInfos"].empty()) {
      if (typeid(map<string, boost::any>) == m["LogInfos"].type()) {
        DescribeLogConfigResponseBodyLogInfos model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LogInfos"]));
        logInfos = make_shared<DescribeLogConfigResponseBodyLogInfos>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeLogConfigResponseBody() = default;
};
class DescribeLogConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeLogConfigResponseBody> body{};

  DescribeLogConfigResponse() {}

  explicit DescribeLogConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeLogConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeLogConfigResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeLogConfigResponse() = default;
};
class DescribeMarketRemainsQuotaRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> securityToken{};

  DescribeMarketRemainsQuotaRequest() {}

  explicit DescribeMarketRemainsQuotaRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~DescribeMarketRemainsQuotaRequest() = default;
};
class DescribeMarketRemainsQuotaResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> remainsQuota{};
  shared_ptr<string> requestId{};

  DescribeMarketRemainsQuotaResponseBody() {}

  explicit DescribeMarketRemainsQuotaResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (remainsQuota) {
      res["RemainsQuota"] = boost::any(*remainsQuota);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RemainsQuota") != m.end() && !m["RemainsQuota"].empty()) {
      remainsQuota = make_shared<long>(boost::any_cast<long>(m["RemainsQuota"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeMarketRemainsQuotaResponseBody() = default;
};
class DescribeMarketRemainsQuotaResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeMarketRemainsQuotaResponseBody> body{};

  DescribeMarketRemainsQuotaResponse() {}

  explicit DescribeMarketRemainsQuotaResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeMarketRemainsQuotaResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeMarketRemainsQuotaResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeMarketRemainsQuotaResponse() = default;
};
class DescribeModelsRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  DescribeModelsRequestTag() {}

  explicit DescribeModelsRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeModelsRequestTag() = default;
};
class DescribeModelsRequest : public Darabonba::Model {
public:
  shared_ptr<string> groupId{};
  shared_ptr<string> modelId{};
  shared_ptr<string> modelName{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<vector<DescribeModelsRequestTag>> tag{};

  DescribeModelsRequest() {}

  explicit DescribeModelsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (modelId) {
      res["ModelId"] = boost::any(*modelId);
    }
    if (modelName) {
      res["ModelName"] = boost::any(*modelName);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("ModelId") != m.end() && !m["ModelId"].empty()) {
      modelId = make_shared<string>(boost::any_cast<string>(m["ModelId"]));
    }
    if (m.find("ModelName") != m.end() && !m["ModelName"].empty()) {
      modelName = make_shared<string>(boost::any_cast<string>(m["ModelName"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<DescribeModelsRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeModelsRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<DescribeModelsRequestTag>>(expect1);
      }
    }
  }


  virtual ~DescribeModelsRequest() = default;
};
class DescribeModelsResponseBodyModelDetailsModelDetailTagsTagInfo : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  DescribeModelsResponseBodyModelDetailsModelDetailTagsTagInfo() {}

  explicit DescribeModelsResponseBodyModelDetailsModelDetailTagsTagInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeModelsResponseBodyModelDetailsModelDetailTagsTagInfo() = default;
};
class DescribeModelsResponseBodyModelDetailsModelDetailTags : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeModelsResponseBodyModelDetailsModelDetailTagsTagInfo>> tagInfo{};

  DescribeModelsResponseBodyModelDetailsModelDetailTags() {}

  explicit DescribeModelsResponseBodyModelDetailsModelDetailTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tagInfo) {
      vector<boost::any> temp1;
      for(auto item1:*tagInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TagInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TagInfo") != m.end() && !m["TagInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["TagInfo"].type()) {
        vector<DescribeModelsResponseBodyModelDetailsModelDetailTagsTagInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TagInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeModelsResponseBodyModelDetailsModelDetailTagsTagInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tagInfo = make_shared<vector<DescribeModelsResponseBodyModelDetailsModelDetailTagsTagInfo>>(expect1);
      }
    }
  }


  virtual ~DescribeModelsResponseBodyModelDetailsModelDetailTags() = default;
};
class DescribeModelsResponseBodyModelDetailsModelDetail : public Darabonba::Model {
public:
  shared_ptr<string> createdTime{};
  shared_ptr<string> description{};
  shared_ptr<string> groupId{};
  shared_ptr<string> modelId{};
  shared_ptr<string> modelName{};
  shared_ptr<string> modelRef{};
  shared_ptr<string> modifiedTime{};
  shared_ptr<string> schema{};
  shared_ptr<DescribeModelsResponseBodyModelDetailsModelDetailTags> tags{};

  DescribeModelsResponseBodyModelDetailsModelDetail() {}

  explicit DescribeModelsResponseBodyModelDetailsModelDetail(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createdTime) {
      res["CreatedTime"] = boost::any(*createdTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (modelId) {
      res["ModelId"] = boost::any(*modelId);
    }
    if (modelName) {
      res["ModelName"] = boost::any(*modelName);
    }
    if (modelRef) {
      res["ModelRef"] = boost::any(*modelRef);
    }
    if (modifiedTime) {
      res["ModifiedTime"] = boost::any(*modifiedTime);
    }
    if (schema) {
      res["Schema"] = boost::any(*schema);
    }
    if (tags) {
      res["Tags"] = tags ? boost::any(tags->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreatedTime") != m.end() && !m["CreatedTime"].empty()) {
      createdTime = make_shared<string>(boost::any_cast<string>(m["CreatedTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("ModelId") != m.end() && !m["ModelId"].empty()) {
      modelId = make_shared<string>(boost::any_cast<string>(m["ModelId"]));
    }
    if (m.find("ModelName") != m.end() && !m["ModelName"].empty()) {
      modelName = make_shared<string>(boost::any_cast<string>(m["ModelName"]));
    }
    if (m.find("ModelRef") != m.end() && !m["ModelRef"].empty()) {
      modelRef = make_shared<string>(boost::any_cast<string>(m["ModelRef"]));
    }
    if (m.find("ModifiedTime") != m.end() && !m["ModifiedTime"].empty()) {
      modifiedTime = make_shared<string>(boost::any_cast<string>(m["ModifiedTime"]));
    }
    if (m.find("Schema") != m.end() && !m["Schema"].empty()) {
      schema = make_shared<string>(boost::any_cast<string>(m["Schema"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(map<string, boost::any>) == m["Tags"].type()) {
        DescribeModelsResponseBodyModelDetailsModelDetailTags model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Tags"]));
        tags = make_shared<DescribeModelsResponseBodyModelDetailsModelDetailTags>(model1);
      }
    }
  }


  virtual ~DescribeModelsResponseBodyModelDetailsModelDetail() = default;
};
class DescribeModelsResponseBodyModelDetails : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeModelsResponseBodyModelDetailsModelDetail>> modelDetail{};

  DescribeModelsResponseBodyModelDetails() {}

  explicit DescribeModelsResponseBodyModelDetails(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (modelDetail) {
      vector<boost::any> temp1;
      for(auto item1:*modelDetail){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ModelDetail"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ModelDetail") != m.end() && !m["ModelDetail"].empty()) {
      if (typeid(vector<boost::any>) == m["ModelDetail"].type()) {
        vector<DescribeModelsResponseBodyModelDetailsModelDetail> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ModelDetail"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeModelsResponseBodyModelDetailsModelDetail model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        modelDetail = make_shared<vector<DescribeModelsResponseBodyModelDetailsModelDetail>>(expect1);
      }
    }
  }


  virtual ~DescribeModelsResponseBodyModelDetails() = default;
};
class DescribeModelsResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeModelsResponseBodyModelDetails> modelDetails{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeModelsResponseBody() {}

  explicit DescribeModelsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (modelDetails) {
      res["ModelDetails"] = modelDetails ? boost::any(modelDetails->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ModelDetails") != m.end() && !m["ModelDetails"].empty()) {
      if (typeid(map<string, boost::any>) == m["ModelDetails"].type()) {
        DescribeModelsResponseBodyModelDetails model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ModelDetails"]));
        modelDetails = make_shared<DescribeModelsResponseBodyModelDetails>(model1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeModelsResponseBody() = default;
};
class DescribeModelsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeModelsResponseBody> body{};

  DescribeModelsResponse() {}

  explicit DescribeModelsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeModelsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeModelsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeModelsResponse() = default;
};
class DescribePluginApisRequest : public Darabonba::Model {
public:
  shared_ptr<string> apiId{};
  shared_ptr<string> apiName{};
  shared_ptr<string> description{};
  shared_ptr<string> groupId{};
  shared_ptr<string> method{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> path{};
  shared_ptr<string> pluginId{};
  shared_ptr<string> securityToken{};

  DescribePluginApisRequest() {}

  explicit DescribePluginApisRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiId) {
      res["ApiId"] = boost::any(*apiId);
    }
    if (apiName) {
      res["ApiName"] = boost::any(*apiName);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (method) {
      res["Method"] = boost::any(*method);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (path) {
      res["Path"] = boost::any(*path);
    }
    if (pluginId) {
      res["PluginId"] = boost::any(*pluginId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiId") != m.end() && !m["ApiId"].empty()) {
      apiId = make_shared<string>(boost::any_cast<string>(m["ApiId"]));
    }
    if (m.find("ApiName") != m.end() && !m["ApiName"].empty()) {
      apiName = make_shared<string>(boost::any_cast<string>(m["ApiName"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("Method") != m.end() && !m["Method"].empty()) {
      method = make_shared<string>(boost::any_cast<string>(m["Method"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Path") != m.end() && !m["Path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["Path"]));
    }
    if (m.find("PluginId") != m.end() && !m["PluginId"].empty()) {
      pluginId = make_shared<string>(boost::any_cast<string>(m["PluginId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~DescribePluginApisRequest() = default;
};
class DescribePluginApisResponseBodyApiSummarysApiPluginSummary : public Darabonba::Model {
public:
  shared_ptr<string> apiId{};
  shared_ptr<string> apiName{};
  shared_ptr<string> description{};
  shared_ptr<string> groupId{};
  shared_ptr<string> groupName{};
  shared_ptr<string> method{};
  shared_ptr<string> path{};
  shared_ptr<string> regionId{};
  shared_ptr<string> stageAlias{};
  shared_ptr<string> stageName{};

  DescribePluginApisResponseBodyApiSummarysApiPluginSummary() {}

  explicit DescribePluginApisResponseBodyApiSummarysApiPluginSummary(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiId) {
      res["ApiId"] = boost::any(*apiId);
    }
    if (apiName) {
      res["ApiName"] = boost::any(*apiName);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (method) {
      res["Method"] = boost::any(*method);
    }
    if (path) {
      res["Path"] = boost::any(*path);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (stageAlias) {
      res["StageAlias"] = boost::any(*stageAlias);
    }
    if (stageName) {
      res["StageName"] = boost::any(*stageName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiId") != m.end() && !m["ApiId"].empty()) {
      apiId = make_shared<string>(boost::any_cast<string>(m["ApiId"]));
    }
    if (m.find("ApiName") != m.end() && !m["ApiName"].empty()) {
      apiName = make_shared<string>(boost::any_cast<string>(m["ApiName"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("Method") != m.end() && !m["Method"].empty()) {
      method = make_shared<string>(boost::any_cast<string>(m["Method"]));
    }
    if (m.find("Path") != m.end() && !m["Path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["Path"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("StageAlias") != m.end() && !m["StageAlias"].empty()) {
      stageAlias = make_shared<string>(boost::any_cast<string>(m["StageAlias"]));
    }
    if (m.find("StageName") != m.end() && !m["StageName"].empty()) {
      stageName = make_shared<string>(boost::any_cast<string>(m["StageName"]));
    }
  }


  virtual ~DescribePluginApisResponseBodyApiSummarysApiPluginSummary() = default;
};
class DescribePluginApisResponseBodyApiSummarys : public Darabonba::Model {
public:
  shared_ptr<vector<DescribePluginApisResponseBodyApiSummarysApiPluginSummary>> apiPluginSummary{};

  DescribePluginApisResponseBodyApiSummarys() {}

  explicit DescribePluginApisResponseBodyApiSummarys(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiPluginSummary) {
      vector<boost::any> temp1;
      for(auto item1:*apiPluginSummary){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ApiPluginSummary"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiPluginSummary") != m.end() && !m["ApiPluginSummary"].empty()) {
      if (typeid(vector<boost::any>) == m["ApiPluginSummary"].type()) {
        vector<DescribePluginApisResponseBodyApiSummarysApiPluginSummary> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ApiPluginSummary"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribePluginApisResponseBodyApiSummarysApiPluginSummary model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        apiPluginSummary = make_shared<vector<DescribePluginApisResponseBodyApiSummarysApiPluginSummary>>(expect1);
      }
    }
  }


  virtual ~DescribePluginApisResponseBodyApiSummarys() = default;
};
class DescribePluginApisResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribePluginApisResponseBodyApiSummarys> apiSummarys{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribePluginApisResponseBody() {}

  explicit DescribePluginApisResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiSummarys) {
      res["ApiSummarys"] = apiSummarys ? boost::any(apiSummarys->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiSummarys") != m.end() && !m["ApiSummarys"].empty()) {
      if (typeid(map<string, boost::any>) == m["ApiSummarys"].type()) {
        DescribePluginApisResponseBodyApiSummarys model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ApiSummarys"]));
        apiSummarys = make_shared<DescribePluginApisResponseBodyApiSummarys>(model1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribePluginApisResponseBody() = default;
};
class DescribePluginApisResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribePluginApisResponseBody> body{};

  DescribePluginApisResponse() {}

  explicit DescribePluginApisResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribePluginApisResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribePluginApisResponseBody>(model1);
      }
    }
  }


  virtual ~DescribePluginApisResponse() = default;
};
class DescribePluginSchemasRequest : public Darabonba::Model {
public:
  shared_ptr<string> language{};
  shared_ptr<string> securityToken{};

  DescribePluginSchemasRequest() {}

  explicit DescribePluginSchemasRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (language) {
      res["Language"] = boost::any(*language);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Language") != m.end() && !m["Language"].empty()) {
      language = make_shared<string>(boost::any_cast<string>(m["Language"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~DescribePluginSchemasRequest() = default;
};
class DescribePluginSchemasResponseBodyPluginSchemasPluginSchema : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> documentId{};
  shared_ptr<string> name{};
  shared_ptr<bool> supportClassic{};
  shared_ptr<string> title{};

  DescribePluginSchemasResponseBodyPluginSchemasPluginSchema() {}

  explicit DescribePluginSchemasResponseBodyPluginSchemasPluginSchema(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (documentId) {
      res["DocumentId"] = boost::any(*documentId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (supportClassic) {
      res["SupportClassic"] = boost::any(*supportClassic);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DocumentId") != m.end() && !m["DocumentId"].empty()) {
      documentId = make_shared<string>(boost::any_cast<string>(m["DocumentId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("SupportClassic") != m.end() && !m["SupportClassic"].empty()) {
      supportClassic = make_shared<bool>(boost::any_cast<bool>(m["SupportClassic"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
  }


  virtual ~DescribePluginSchemasResponseBodyPluginSchemasPluginSchema() = default;
};
class DescribePluginSchemasResponseBodyPluginSchemas : public Darabonba::Model {
public:
  shared_ptr<vector<DescribePluginSchemasResponseBodyPluginSchemasPluginSchema>> pluginSchema{};

  DescribePluginSchemasResponseBodyPluginSchemas() {}

  explicit DescribePluginSchemasResponseBodyPluginSchemas(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pluginSchema) {
      vector<boost::any> temp1;
      for(auto item1:*pluginSchema){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PluginSchema"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PluginSchema") != m.end() && !m["PluginSchema"].empty()) {
      if (typeid(vector<boost::any>) == m["PluginSchema"].type()) {
        vector<DescribePluginSchemasResponseBodyPluginSchemasPluginSchema> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PluginSchema"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribePluginSchemasResponseBodyPluginSchemasPluginSchema model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        pluginSchema = make_shared<vector<DescribePluginSchemasResponseBodyPluginSchemasPluginSchema>>(expect1);
      }
    }
  }


  virtual ~DescribePluginSchemasResponseBodyPluginSchemas() = default;
};
class DescribePluginSchemasResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribePluginSchemasResponseBodyPluginSchemas> pluginSchemas{};
  shared_ptr<string> requestId{};

  DescribePluginSchemasResponseBody() {}

  explicit DescribePluginSchemasResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pluginSchemas) {
      res["PluginSchemas"] = pluginSchemas ? boost::any(pluginSchemas->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PluginSchemas") != m.end() && !m["PluginSchemas"].empty()) {
      if (typeid(map<string, boost::any>) == m["PluginSchemas"].type()) {
        DescribePluginSchemasResponseBodyPluginSchemas model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PluginSchemas"]));
        pluginSchemas = make_shared<DescribePluginSchemasResponseBodyPluginSchemas>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribePluginSchemasResponseBody() = default;
};
class DescribePluginSchemasResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribePluginSchemasResponseBody> body{};

  DescribePluginSchemasResponse() {}

  explicit DescribePluginSchemasResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribePluginSchemasResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribePluginSchemasResponseBody>(model1);
      }
    }
  }


  virtual ~DescribePluginSchemasResponse() = default;
};
class DescribePluginTemplatesRequest : public Darabonba::Model {
public:
  shared_ptr<string> language{};
  shared_ptr<string> pluginName{};
  shared_ptr<string> securityToken{};

  DescribePluginTemplatesRequest() {}

  explicit DescribePluginTemplatesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (language) {
      res["Language"] = boost::any(*language);
    }
    if (pluginName) {
      res["PluginName"] = boost::any(*pluginName);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Language") != m.end() && !m["Language"].empty()) {
      language = make_shared<string>(boost::any_cast<string>(m["Language"]));
    }
    if (m.find("PluginName") != m.end() && !m["PluginName"].empty()) {
      pluginName = make_shared<string>(boost::any_cast<string>(m["PluginName"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~DescribePluginTemplatesRequest() = default;
};
class DescribePluginTemplatesResponseBodyTemplatesTemplate : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> documentAnchor{};
  shared_ptr<string> documentId{};
  shared_ptr<string> sample{};
  shared_ptr<string> title{};

  DescribePluginTemplatesResponseBodyTemplatesTemplate() {}

  explicit DescribePluginTemplatesResponseBodyTemplatesTemplate(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (documentAnchor) {
      res["DocumentAnchor"] = boost::any(*documentAnchor);
    }
    if (documentId) {
      res["DocumentId"] = boost::any(*documentId);
    }
    if (sample) {
      res["Sample"] = boost::any(*sample);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DocumentAnchor") != m.end() && !m["DocumentAnchor"].empty()) {
      documentAnchor = make_shared<string>(boost::any_cast<string>(m["DocumentAnchor"]));
    }
    if (m.find("DocumentId") != m.end() && !m["DocumentId"].empty()) {
      documentId = make_shared<string>(boost::any_cast<string>(m["DocumentId"]));
    }
    if (m.find("Sample") != m.end() && !m["Sample"].empty()) {
      sample = make_shared<string>(boost::any_cast<string>(m["Sample"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
  }


  virtual ~DescribePluginTemplatesResponseBodyTemplatesTemplate() = default;
};
class DescribePluginTemplatesResponseBodyTemplates : public Darabonba::Model {
public:
  shared_ptr<vector<DescribePluginTemplatesResponseBodyTemplatesTemplate>> template_{};

  DescribePluginTemplatesResponseBodyTemplates() {}

  explicit DescribePluginTemplatesResponseBodyTemplates(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (template_) {
      vector<boost::any> temp1;
      for(auto item1:*template_){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Template"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Template") != m.end() && !m["Template"].empty()) {
      if (typeid(vector<boost::any>) == m["Template"].type()) {
        vector<DescribePluginTemplatesResponseBodyTemplatesTemplate> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Template"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribePluginTemplatesResponseBodyTemplatesTemplate model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        template_ = make_shared<vector<DescribePluginTemplatesResponseBodyTemplatesTemplate>>(expect1);
      }
    }
  }


  virtual ~DescribePluginTemplatesResponseBodyTemplates() = default;
};
class DescribePluginTemplatesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribePluginTemplatesResponseBodyTemplates> templates{};

  DescribePluginTemplatesResponseBody() {}

  explicit DescribePluginTemplatesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (templates) {
      res["Templates"] = templates ? boost::any(templates->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Templates") != m.end() && !m["Templates"].empty()) {
      if (typeid(map<string, boost::any>) == m["Templates"].type()) {
        DescribePluginTemplatesResponseBodyTemplates model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Templates"]));
        templates = make_shared<DescribePluginTemplatesResponseBodyTemplates>(model1);
      }
    }
  }


  virtual ~DescribePluginTemplatesResponseBody() = default;
};
class DescribePluginTemplatesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribePluginTemplatesResponseBody> body{};

  DescribePluginTemplatesResponse() {}

  explicit DescribePluginTemplatesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribePluginTemplatesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribePluginTemplatesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribePluginTemplatesResponse() = default;
};
class DescribePluginsRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  DescribePluginsRequestTag() {}

  explicit DescribePluginsRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribePluginsRequestTag() = default;
};
class DescribePluginsRequest : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> pluginId{};
  shared_ptr<string> pluginName{};
  shared_ptr<string> pluginType{};
  shared_ptr<string> securityToken{};
  shared_ptr<vector<DescribePluginsRequestTag>> tag{};

  DescribePluginsRequest() {}

  explicit DescribePluginsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (pluginId) {
      res["PluginId"] = boost::any(*pluginId);
    }
    if (pluginName) {
      res["PluginName"] = boost::any(*pluginName);
    }
    if (pluginType) {
      res["PluginType"] = boost::any(*pluginType);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("PluginId") != m.end() && !m["PluginId"].empty()) {
      pluginId = make_shared<string>(boost::any_cast<string>(m["PluginId"]));
    }
    if (m.find("PluginName") != m.end() && !m["PluginName"].empty()) {
      pluginName = make_shared<string>(boost::any_cast<string>(m["PluginName"]));
    }
    if (m.find("PluginType") != m.end() && !m["PluginType"].empty()) {
      pluginType = make_shared<string>(boost::any_cast<string>(m["PluginType"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<DescribePluginsRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribePluginsRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<DescribePluginsRequestTag>>(expect1);
      }
    }
  }


  virtual ~DescribePluginsRequest() = default;
};
class DescribePluginsResponseBodyPluginsPluginAttributeTagsTagInfo : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  DescribePluginsResponseBodyPluginsPluginAttributeTagsTagInfo() {}

  explicit DescribePluginsResponseBodyPluginsPluginAttributeTagsTagInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribePluginsResponseBodyPluginsPluginAttributeTagsTagInfo() = default;
};
class DescribePluginsResponseBodyPluginsPluginAttributeTags : public Darabonba::Model {
public:
  shared_ptr<vector<DescribePluginsResponseBodyPluginsPluginAttributeTagsTagInfo>> tagInfo{};

  DescribePluginsResponseBodyPluginsPluginAttributeTags() {}

  explicit DescribePluginsResponseBodyPluginsPluginAttributeTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tagInfo) {
      vector<boost::any> temp1;
      for(auto item1:*tagInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TagInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TagInfo") != m.end() && !m["TagInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["TagInfo"].type()) {
        vector<DescribePluginsResponseBodyPluginsPluginAttributeTagsTagInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TagInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribePluginsResponseBodyPluginsPluginAttributeTagsTagInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tagInfo = make_shared<vector<DescribePluginsResponseBodyPluginsPluginAttributeTagsTagInfo>>(expect1);
      }
    }
  }


  virtual ~DescribePluginsResponseBodyPluginsPluginAttributeTags() = default;
};
class DescribePluginsResponseBodyPluginsPluginAttribute : public Darabonba::Model {
public:
  shared_ptr<string> createdTime{};
  shared_ptr<string> description{};
  shared_ptr<string> modifiedTime{};
  shared_ptr<string> pluginData{};
  shared_ptr<string> pluginId{};
  shared_ptr<string> pluginName{};
  shared_ptr<string> pluginType{};
  shared_ptr<string> regionId{};
  shared_ptr<DescribePluginsResponseBodyPluginsPluginAttributeTags> tags{};

  DescribePluginsResponseBodyPluginsPluginAttribute() {}

  explicit DescribePluginsResponseBodyPluginsPluginAttribute(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createdTime) {
      res["CreatedTime"] = boost::any(*createdTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (modifiedTime) {
      res["ModifiedTime"] = boost::any(*modifiedTime);
    }
    if (pluginData) {
      res["PluginData"] = boost::any(*pluginData);
    }
    if (pluginId) {
      res["PluginId"] = boost::any(*pluginId);
    }
    if (pluginName) {
      res["PluginName"] = boost::any(*pluginName);
    }
    if (pluginType) {
      res["PluginType"] = boost::any(*pluginType);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (tags) {
      res["Tags"] = tags ? boost::any(tags->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreatedTime") != m.end() && !m["CreatedTime"].empty()) {
      createdTime = make_shared<string>(boost::any_cast<string>(m["CreatedTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("ModifiedTime") != m.end() && !m["ModifiedTime"].empty()) {
      modifiedTime = make_shared<string>(boost::any_cast<string>(m["ModifiedTime"]));
    }
    if (m.find("PluginData") != m.end() && !m["PluginData"].empty()) {
      pluginData = make_shared<string>(boost::any_cast<string>(m["PluginData"]));
    }
    if (m.find("PluginId") != m.end() && !m["PluginId"].empty()) {
      pluginId = make_shared<string>(boost::any_cast<string>(m["PluginId"]));
    }
    if (m.find("PluginName") != m.end() && !m["PluginName"].empty()) {
      pluginName = make_shared<string>(boost::any_cast<string>(m["PluginName"]));
    }
    if (m.find("PluginType") != m.end() && !m["PluginType"].empty()) {
      pluginType = make_shared<string>(boost::any_cast<string>(m["PluginType"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(map<string, boost::any>) == m["Tags"].type()) {
        DescribePluginsResponseBodyPluginsPluginAttributeTags model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Tags"]));
        tags = make_shared<DescribePluginsResponseBodyPluginsPluginAttributeTags>(model1);
      }
    }
  }


  virtual ~DescribePluginsResponseBodyPluginsPluginAttribute() = default;
};
class DescribePluginsResponseBodyPlugins : public Darabonba::Model {
public:
  shared_ptr<vector<DescribePluginsResponseBodyPluginsPluginAttribute>> pluginAttribute{};

  DescribePluginsResponseBodyPlugins() {}

  explicit DescribePluginsResponseBodyPlugins(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pluginAttribute) {
      vector<boost::any> temp1;
      for(auto item1:*pluginAttribute){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PluginAttribute"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PluginAttribute") != m.end() && !m["PluginAttribute"].empty()) {
      if (typeid(vector<boost::any>) == m["PluginAttribute"].type()) {
        vector<DescribePluginsResponseBodyPluginsPluginAttribute> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PluginAttribute"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribePluginsResponseBodyPluginsPluginAttribute model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        pluginAttribute = make_shared<vector<DescribePluginsResponseBodyPluginsPluginAttribute>>(expect1);
      }
    }
  }


  virtual ~DescribePluginsResponseBodyPlugins() = default;
};
class DescribePluginsResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<DescribePluginsResponseBodyPlugins> plugins{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribePluginsResponseBody() {}

  explicit DescribePluginsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (plugins) {
      res["Plugins"] = plugins ? boost::any(plugins->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Plugins") != m.end() && !m["Plugins"].empty()) {
      if (typeid(map<string, boost::any>) == m["Plugins"].type()) {
        DescribePluginsResponseBodyPlugins model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Plugins"]));
        plugins = make_shared<DescribePluginsResponseBodyPlugins>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribePluginsResponseBody() = default;
};
class DescribePluginsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribePluginsResponseBody> body{};

  DescribePluginsResponse() {}

  explicit DescribePluginsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribePluginsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribePluginsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribePluginsResponse() = default;
};
class DescribePluginsByApiRequest : public Darabonba::Model {
public:
  shared_ptr<string> apiId{};
  shared_ptr<string> groupId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> stageName{};

  DescribePluginsByApiRequest() {}

  explicit DescribePluginsByApiRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiId) {
      res["ApiId"] = boost::any(*apiId);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (stageName) {
      res["StageName"] = boost::any(*stageName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiId") != m.end() && !m["ApiId"].empty()) {
      apiId = make_shared<string>(boost::any_cast<string>(m["ApiId"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("StageName") != m.end() && !m["StageName"].empty()) {
      stageName = make_shared<string>(boost::any_cast<string>(m["StageName"]));
    }
  }


  virtual ~DescribePluginsByApiRequest() = default;
};
class DescribePluginsByApiResponseBodyPluginsPluginAttribute : public Darabonba::Model {
public:
  shared_ptr<string> createdTime{};
  shared_ptr<string> description{};
  shared_ptr<string> modifiedTime{};
  shared_ptr<string> pluginData{};
  shared_ptr<string> pluginId{};
  shared_ptr<string> pluginName{};
  shared_ptr<string> pluginType{};
  shared_ptr<string> regionId{};

  DescribePluginsByApiResponseBodyPluginsPluginAttribute() {}

  explicit DescribePluginsByApiResponseBodyPluginsPluginAttribute(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createdTime) {
      res["CreatedTime"] = boost::any(*createdTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (modifiedTime) {
      res["ModifiedTime"] = boost::any(*modifiedTime);
    }
    if (pluginData) {
      res["PluginData"] = boost::any(*pluginData);
    }
    if (pluginId) {
      res["PluginId"] = boost::any(*pluginId);
    }
    if (pluginName) {
      res["PluginName"] = boost::any(*pluginName);
    }
    if (pluginType) {
      res["PluginType"] = boost::any(*pluginType);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreatedTime") != m.end() && !m["CreatedTime"].empty()) {
      createdTime = make_shared<string>(boost::any_cast<string>(m["CreatedTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("ModifiedTime") != m.end() && !m["ModifiedTime"].empty()) {
      modifiedTime = make_shared<string>(boost::any_cast<string>(m["ModifiedTime"]));
    }
    if (m.find("PluginData") != m.end() && !m["PluginData"].empty()) {
      pluginData = make_shared<string>(boost::any_cast<string>(m["PluginData"]));
    }
    if (m.find("PluginId") != m.end() && !m["PluginId"].empty()) {
      pluginId = make_shared<string>(boost::any_cast<string>(m["PluginId"]));
    }
    if (m.find("PluginName") != m.end() && !m["PluginName"].empty()) {
      pluginName = make_shared<string>(boost::any_cast<string>(m["PluginName"]));
    }
    if (m.find("PluginType") != m.end() && !m["PluginType"].empty()) {
      pluginType = make_shared<string>(boost::any_cast<string>(m["PluginType"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DescribePluginsByApiResponseBodyPluginsPluginAttribute() = default;
};
class DescribePluginsByApiResponseBodyPlugins : public Darabonba::Model {
public:
  shared_ptr<vector<DescribePluginsByApiResponseBodyPluginsPluginAttribute>> pluginAttribute{};

  DescribePluginsByApiResponseBodyPlugins() {}

  explicit DescribePluginsByApiResponseBodyPlugins(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pluginAttribute) {
      vector<boost::any> temp1;
      for(auto item1:*pluginAttribute){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PluginAttribute"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PluginAttribute") != m.end() && !m["PluginAttribute"].empty()) {
      if (typeid(vector<boost::any>) == m["PluginAttribute"].type()) {
        vector<DescribePluginsByApiResponseBodyPluginsPluginAttribute> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PluginAttribute"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribePluginsByApiResponseBodyPluginsPluginAttribute model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        pluginAttribute = make_shared<vector<DescribePluginsByApiResponseBodyPluginsPluginAttribute>>(expect1);
      }
    }
  }


  virtual ~DescribePluginsByApiResponseBodyPlugins() = default;
};
class DescribePluginsByApiResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<DescribePluginsByApiResponseBodyPlugins> plugins{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribePluginsByApiResponseBody() {}

  explicit DescribePluginsByApiResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (plugins) {
      res["Plugins"] = plugins ? boost::any(plugins->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Plugins") != m.end() && !m["Plugins"].empty()) {
      if (typeid(map<string, boost::any>) == m["Plugins"].type()) {
        DescribePluginsByApiResponseBodyPlugins model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Plugins"]));
        plugins = make_shared<DescribePluginsByApiResponseBodyPlugins>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribePluginsByApiResponseBody() = default;
};
class DescribePluginsByApiResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribePluginsByApiResponseBody> body{};

  DescribePluginsByApiResponse() {}

  explicit DescribePluginsByApiResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribePluginsByApiResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribePluginsByApiResponseBody>(model1);
      }
    }
  }


  virtual ~DescribePluginsByApiResponse() = default;
};
class DescribePurchasedApiGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> groupId{};
  shared_ptr<string> securityToken{};

  DescribePurchasedApiGroupRequest() {}

  explicit DescribePurchasedApiGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~DescribePurchasedApiGroupRequest() = default;
};
class DescribePurchasedApiGroupResponseBodyDomainsDomainItem : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};

  DescribePurchasedApiGroupResponseBodyDomainsDomainItem() {}

  explicit DescribePurchasedApiGroupResponseBodyDomainsDomainItem(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
  }


  virtual ~DescribePurchasedApiGroupResponseBodyDomainsDomainItem() = default;
};
class DescribePurchasedApiGroupResponseBodyDomains : public Darabonba::Model {
public:
  shared_ptr<vector<DescribePurchasedApiGroupResponseBodyDomainsDomainItem>> domainItem{};

  DescribePurchasedApiGroupResponseBodyDomains() {}

  explicit DescribePurchasedApiGroupResponseBodyDomains(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainItem) {
      vector<boost::any> temp1;
      for(auto item1:*domainItem){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DomainItem"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainItem") != m.end() && !m["DomainItem"].empty()) {
      if (typeid(vector<boost::any>) == m["DomainItem"].type()) {
        vector<DescribePurchasedApiGroupResponseBodyDomainsDomainItem> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DomainItem"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribePurchasedApiGroupResponseBodyDomainsDomainItem model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        domainItem = make_shared<vector<DescribePurchasedApiGroupResponseBodyDomainsDomainItem>>(expect1);
      }
    }
  }


  virtual ~DescribePurchasedApiGroupResponseBodyDomains() = default;
};
class DescribePurchasedApiGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<DescribePurchasedApiGroupResponseBodyDomains> domains{};
  shared_ptr<string> groupId{};
  shared_ptr<string> groupName{};
  shared_ptr<string> purchasedTime{};
  shared_ptr<string> regionId{};
  shared_ptr<string> requestId{};
  shared_ptr<string> status{};

  DescribePurchasedApiGroupResponseBody() {}

  explicit DescribePurchasedApiGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (domains) {
      res["Domains"] = domains ? boost::any(domains->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (purchasedTime) {
      res["PurchasedTime"] = boost::any(*purchasedTime);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Domains") != m.end() && !m["Domains"].empty()) {
      if (typeid(map<string, boost::any>) == m["Domains"].type()) {
        DescribePurchasedApiGroupResponseBodyDomains model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Domains"]));
        domains = make_shared<DescribePurchasedApiGroupResponseBodyDomains>(model1);
      }
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("PurchasedTime") != m.end() && !m["PurchasedTime"].empty()) {
      purchasedTime = make_shared<string>(boost::any_cast<string>(m["PurchasedTime"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribePurchasedApiGroupResponseBody() = default;
};
class DescribePurchasedApiGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribePurchasedApiGroupResponseBody> body{};

  DescribePurchasedApiGroupResponse() {}

  explicit DescribePurchasedApiGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribePurchasedApiGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribePurchasedApiGroupResponseBody>(model1);
      }
    }
  }


  virtual ~DescribePurchasedApiGroupResponse() = default;
};
class DescribePurchasedApiGroupsRequest : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> securityToken{};

  DescribePurchasedApiGroupsRequest() {}

  explicit DescribePurchasedApiGroupsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~DescribePurchasedApiGroupsRequest() = default;
};
class DescribePurchasedApiGroupsResponseBodyPurchasedApiGroupAttributesPurchasedApiGroupAttribute : public Darabonba::Model {
public:
  shared_ptr<string> billingType{};
  shared_ptr<string> description{};
  shared_ptr<string> expireTime{};
  shared_ptr<string> groupId{};
  shared_ptr<string> groupName{};
  shared_ptr<long> invokeTimesMax{};
  shared_ptr<long> invokeTimesNow{};
  shared_ptr<string> purchasedTime{};
  shared_ptr<string> regionId{};
  shared_ptr<string> status{};

  DescribePurchasedApiGroupsResponseBodyPurchasedApiGroupAttributesPurchasedApiGroupAttribute() {}

  explicit DescribePurchasedApiGroupsResponseBodyPurchasedApiGroupAttributesPurchasedApiGroupAttribute(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (billingType) {
      res["BillingType"] = boost::any(*billingType);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (expireTime) {
      res["ExpireTime"] = boost::any(*expireTime);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (invokeTimesMax) {
      res["InvokeTimesMax"] = boost::any(*invokeTimesMax);
    }
    if (invokeTimesNow) {
      res["InvokeTimesNow"] = boost::any(*invokeTimesNow);
    }
    if (purchasedTime) {
      res["PurchasedTime"] = boost::any(*purchasedTime);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BillingType") != m.end() && !m["BillingType"].empty()) {
      billingType = make_shared<string>(boost::any_cast<string>(m["BillingType"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("ExpireTime") != m.end() && !m["ExpireTime"].empty()) {
      expireTime = make_shared<string>(boost::any_cast<string>(m["ExpireTime"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("InvokeTimesMax") != m.end() && !m["InvokeTimesMax"].empty()) {
      invokeTimesMax = make_shared<long>(boost::any_cast<long>(m["InvokeTimesMax"]));
    }
    if (m.find("InvokeTimesNow") != m.end() && !m["InvokeTimesNow"].empty()) {
      invokeTimesNow = make_shared<long>(boost::any_cast<long>(m["InvokeTimesNow"]));
    }
    if (m.find("PurchasedTime") != m.end() && !m["PurchasedTime"].empty()) {
      purchasedTime = make_shared<string>(boost::any_cast<string>(m["PurchasedTime"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribePurchasedApiGroupsResponseBodyPurchasedApiGroupAttributesPurchasedApiGroupAttribute() = default;
};
class DescribePurchasedApiGroupsResponseBodyPurchasedApiGroupAttributes : public Darabonba::Model {
public:
  shared_ptr<vector<DescribePurchasedApiGroupsResponseBodyPurchasedApiGroupAttributesPurchasedApiGroupAttribute>> purchasedApiGroupAttribute{};

  DescribePurchasedApiGroupsResponseBodyPurchasedApiGroupAttributes() {}

  explicit DescribePurchasedApiGroupsResponseBodyPurchasedApiGroupAttributes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (purchasedApiGroupAttribute) {
      vector<boost::any> temp1;
      for(auto item1:*purchasedApiGroupAttribute){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PurchasedApiGroupAttribute"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PurchasedApiGroupAttribute") != m.end() && !m["PurchasedApiGroupAttribute"].empty()) {
      if (typeid(vector<boost::any>) == m["PurchasedApiGroupAttribute"].type()) {
        vector<DescribePurchasedApiGroupsResponseBodyPurchasedApiGroupAttributesPurchasedApiGroupAttribute> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PurchasedApiGroupAttribute"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribePurchasedApiGroupsResponseBodyPurchasedApiGroupAttributesPurchasedApiGroupAttribute model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        purchasedApiGroupAttribute = make_shared<vector<DescribePurchasedApiGroupsResponseBodyPurchasedApiGroupAttributesPurchasedApiGroupAttribute>>(expect1);
      }
    }
  }


  virtual ~DescribePurchasedApiGroupsResponseBodyPurchasedApiGroupAttributes() = default;
};
class DescribePurchasedApiGroupsResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<DescribePurchasedApiGroupsResponseBodyPurchasedApiGroupAttributes> purchasedApiGroupAttributes{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribePurchasedApiGroupsResponseBody() {}

  explicit DescribePurchasedApiGroupsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (purchasedApiGroupAttributes) {
      res["PurchasedApiGroupAttributes"] = purchasedApiGroupAttributes ? boost::any(purchasedApiGroupAttributes->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("PurchasedApiGroupAttributes") != m.end() && !m["PurchasedApiGroupAttributes"].empty()) {
      if (typeid(map<string, boost::any>) == m["PurchasedApiGroupAttributes"].type()) {
        DescribePurchasedApiGroupsResponseBodyPurchasedApiGroupAttributes model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PurchasedApiGroupAttributes"]));
        purchasedApiGroupAttributes = make_shared<DescribePurchasedApiGroupsResponseBodyPurchasedApiGroupAttributes>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribePurchasedApiGroupsResponseBody() = default;
};
class DescribePurchasedApiGroupsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribePurchasedApiGroupsResponseBody> body{};

  DescribePurchasedApiGroupsResponse() {}

  explicit DescribePurchasedApiGroupsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribePurchasedApiGroupsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribePurchasedApiGroupsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribePurchasedApiGroupsResponse() = default;
};
class DescribePurchasedApisRequest : public Darabonba::Model {
public:
  shared_ptr<string> apiId{};
  shared_ptr<string> apiName{};
  shared_ptr<string> groupId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> stageName{};
  shared_ptr<string> visibility{};

  DescribePurchasedApisRequest() {}

  explicit DescribePurchasedApisRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiId) {
      res["ApiId"] = boost::any(*apiId);
    }
    if (apiName) {
      res["ApiName"] = boost::any(*apiName);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (stageName) {
      res["StageName"] = boost::any(*stageName);
    }
    if (visibility) {
      res["Visibility"] = boost::any(*visibility);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiId") != m.end() && !m["ApiId"].empty()) {
      apiId = make_shared<string>(boost::any_cast<string>(m["ApiId"]));
    }
    if (m.find("ApiName") != m.end() && !m["ApiName"].empty()) {
      apiName = make_shared<string>(boost::any_cast<string>(m["ApiName"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("StageName") != m.end() && !m["StageName"].empty()) {
      stageName = make_shared<string>(boost::any_cast<string>(m["StageName"]));
    }
    if (m.find("Visibility") != m.end() && !m["Visibility"].empty()) {
      visibility = make_shared<string>(boost::any_cast<string>(m["Visibility"]));
    }
  }


  virtual ~DescribePurchasedApisRequest() = default;
};
class DescribePurchasedApisResponseBodyPurchasedApisPurchasedApi : public Darabonba::Model {
public:
  shared_ptr<string> apiId{};
  shared_ptr<string> apiName{};
  shared_ptr<string> deployedTime{};
  shared_ptr<string> description{};
  shared_ptr<string> groupId{};
  shared_ptr<string> groupName{};
  shared_ptr<string> modifiedTime{};
  shared_ptr<string> purchasedTime{};
  shared_ptr<string> regionId{};
  shared_ptr<string> stageName{};
  shared_ptr<string> visibility{};

  DescribePurchasedApisResponseBodyPurchasedApisPurchasedApi() {}

  explicit DescribePurchasedApisResponseBodyPurchasedApisPurchasedApi(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiId) {
      res["ApiId"] = boost::any(*apiId);
    }
    if (apiName) {
      res["ApiName"] = boost::any(*apiName);
    }
    if (deployedTime) {
      res["DeployedTime"] = boost::any(*deployedTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (modifiedTime) {
      res["ModifiedTime"] = boost::any(*modifiedTime);
    }
    if (purchasedTime) {
      res["PurchasedTime"] = boost::any(*purchasedTime);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (stageName) {
      res["StageName"] = boost::any(*stageName);
    }
    if (visibility) {
      res["Visibility"] = boost::any(*visibility);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiId") != m.end() && !m["ApiId"].empty()) {
      apiId = make_shared<string>(boost::any_cast<string>(m["ApiId"]));
    }
    if (m.find("ApiName") != m.end() && !m["ApiName"].empty()) {
      apiName = make_shared<string>(boost::any_cast<string>(m["ApiName"]));
    }
    if (m.find("DeployedTime") != m.end() && !m["DeployedTime"].empty()) {
      deployedTime = make_shared<string>(boost::any_cast<string>(m["DeployedTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("ModifiedTime") != m.end() && !m["ModifiedTime"].empty()) {
      modifiedTime = make_shared<string>(boost::any_cast<string>(m["ModifiedTime"]));
    }
    if (m.find("PurchasedTime") != m.end() && !m["PurchasedTime"].empty()) {
      purchasedTime = make_shared<string>(boost::any_cast<string>(m["PurchasedTime"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("StageName") != m.end() && !m["StageName"].empty()) {
      stageName = make_shared<string>(boost::any_cast<string>(m["StageName"]));
    }
    if (m.find("Visibility") != m.end() && !m["Visibility"].empty()) {
      visibility = make_shared<string>(boost::any_cast<string>(m["Visibility"]));
    }
  }


  virtual ~DescribePurchasedApisResponseBodyPurchasedApisPurchasedApi() = default;
};
class DescribePurchasedApisResponseBodyPurchasedApis : public Darabonba::Model {
public:
  shared_ptr<vector<DescribePurchasedApisResponseBodyPurchasedApisPurchasedApi>> purchasedApi{};

  DescribePurchasedApisResponseBodyPurchasedApis() {}

  explicit DescribePurchasedApisResponseBodyPurchasedApis(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (purchasedApi) {
      vector<boost::any> temp1;
      for(auto item1:*purchasedApi){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PurchasedApi"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PurchasedApi") != m.end() && !m["PurchasedApi"].empty()) {
      if (typeid(vector<boost::any>) == m["PurchasedApi"].type()) {
        vector<DescribePurchasedApisResponseBodyPurchasedApisPurchasedApi> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PurchasedApi"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribePurchasedApisResponseBodyPurchasedApisPurchasedApi model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        purchasedApi = make_shared<vector<DescribePurchasedApisResponseBodyPurchasedApisPurchasedApi>>(expect1);
      }
    }
  }


  virtual ~DescribePurchasedApisResponseBodyPurchasedApis() = default;
};
class DescribePurchasedApisResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<DescribePurchasedApisResponseBodyPurchasedApis> purchasedApis{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribePurchasedApisResponseBody() {}

  explicit DescribePurchasedApisResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (purchasedApis) {
      res["PurchasedApis"] = purchasedApis ? boost::any(purchasedApis->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("PurchasedApis") != m.end() && !m["PurchasedApis"].empty()) {
      if (typeid(map<string, boost::any>) == m["PurchasedApis"].type()) {
        DescribePurchasedApisResponseBodyPurchasedApis model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PurchasedApis"]));
        purchasedApis = make_shared<DescribePurchasedApisResponseBodyPurchasedApis>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribePurchasedApisResponseBody() = default;
};
class DescribePurchasedApisResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribePurchasedApisResponseBody> body{};

  DescribePurchasedApisResponse() {}

  explicit DescribePurchasedApisResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribePurchasedApisResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribePurchasedApisResponseBody>(model1);
      }
    }
  }


  virtual ~DescribePurchasedApisResponse() = default;
};
class DescribeRegionsRequest : public Darabonba::Model {
public:
  shared_ptr<string> language{};
  shared_ptr<string> securityToken{};

  DescribeRegionsRequest() {}

  explicit DescribeRegionsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (language) {
      res["Language"] = boost::any(*language);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Language") != m.end() && !m["Language"].empty()) {
      language = make_shared<string>(boost::any_cast<string>(m["Language"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~DescribeRegionsRequest() = default;
};
class DescribeRegionsResponseBodyRegionsRegion : public Darabonba::Model {
public:
  shared_ptr<string> localName{};
  shared_ptr<string> regionEndpoint{};
  shared_ptr<string> regionId{};

  DescribeRegionsResponseBodyRegionsRegion() {}

  explicit DescribeRegionsResponseBodyRegionsRegion(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (localName) {
      res["LocalName"] = boost::any(*localName);
    }
    if (regionEndpoint) {
      res["RegionEndpoint"] = boost::any(*regionEndpoint);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LocalName") != m.end() && !m["LocalName"].empty()) {
      localName = make_shared<string>(boost::any_cast<string>(m["LocalName"]));
    }
    if (m.find("RegionEndpoint") != m.end() && !m["RegionEndpoint"].empty()) {
      regionEndpoint = make_shared<string>(boost::any_cast<string>(m["RegionEndpoint"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DescribeRegionsResponseBodyRegionsRegion() = default;
};
class DescribeRegionsResponseBodyRegions : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeRegionsResponseBodyRegionsRegion>> region{};

  DescribeRegionsResponseBodyRegions() {}

  explicit DescribeRegionsResponseBodyRegions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (region) {
      vector<boost::any> temp1;
      for(auto item1:*region){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Region"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      if (typeid(vector<boost::any>) == m["Region"].type()) {
        vector<DescribeRegionsResponseBodyRegionsRegion> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Region"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeRegionsResponseBodyRegionsRegion model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        region = make_shared<vector<DescribeRegionsResponseBodyRegionsRegion>>(expect1);
      }
    }
  }


  virtual ~DescribeRegionsResponseBodyRegions() = default;
};
class DescribeRegionsResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeRegionsResponseBodyRegions> regions{};
  shared_ptr<string> requestId{};

  DescribeRegionsResponseBody() {}

  explicit DescribeRegionsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (regions) {
      res["Regions"] = regions ? boost::any(regions->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Regions") != m.end() && !m["Regions"].empty()) {
      if (typeid(map<string, boost::any>) == m["Regions"].type()) {
        DescribeRegionsResponseBodyRegions model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Regions"]));
        regions = make_shared<DescribeRegionsResponseBodyRegions>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeRegionsResponseBody() = default;
};
class DescribeRegionsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeRegionsResponseBody> body{};

  DescribeRegionsResponse() {}

  explicit DescribeRegionsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeRegionsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeRegionsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeRegionsResponse() = default;
};
class DescribeSignaturesRequest : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> signatureId{};
  shared_ptr<string> signatureName{};

  DescribeSignaturesRequest() {}

  explicit DescribeSignaturesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (signatureId) {
      res["SignatureId"] = boost::any(*signatureId);
    }
    if (signatureName) {
      res["SignatureName"] = boost::any(*signatureName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("SignatureId") != m.end() && !m["SignatureId"].empty()) {
      signatureId = make_shared<string>(boost::any_cast<string>(m["SignatureId"]));
    }
    if (m.find("SignatureName") != m.end() && !m["SignatureName"].empty()) {
      signatureName = make_shared<string>(boost::any_cast<string>(m["SignatureName"]));
    }
  }


  virtual ~DescribeSignaturesRequest() = default;
};
class DescribeSignaturesResponseBodySignatureInfosSignatureInfo : public Darabonba::Model {
public:
  shared_ptr<string> createdTime{};
  shared_ptr<string> modifiedTime{};
  shared_ptr<string> regionId{};
  shared_ptr<string> signatureId{};
  shared_ptr<string> signatureKey{};
  shared_ptr<string> signatureName{};
  shared_ptr<string> signatureSecret{};

  DescribeSignaturesResponseBodySignatureInfosSignatureInfo() {}

  explicit DescribeSignaturesResponseBodySignatureInfosSignatureInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createdTime) {
      res["CreatedTime"] = boost::any(*createdTime);
    }
    if (modifiedTime) {
      res["ModifiedTime"] = boost::any(*modifiedTime);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (signatureId) {
      res["SignatureId"] = boost::any(*signatureId);
    }
    if (signatureKey) {
      res["SignatureKey"] = boost::any(*signatureKey);
    }
    if (signatureName) {
      res["SignatureName"] = boost::any(*signatureName);
    }
    if (signatureSecret) {
      res["SignatureSecret"] = boost::any(*signatureSecret);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreatedTime") != m.end() && !m["CreatedTime"].empty()) {
      createdTime = make_shared<string>(boost::any_cast<string>(m["CreatedTime"]));
    }
    if (m.find("ModifiedTime") != m.end() && !m["ModifiedTime"].empty()) {
      modifiedTime = make_shared<string>(boost::any_cast<string>(m["ModifiedTime"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SignatureId") != m.end() && !m["SignatureId"].empty()) {
      signatureId = make_shared<string>(boost::any_cast<string>(m["SignatureId"]));
    }
    if (m.find("SignatureKey") != m.end() && !m["SignatureKey"].empty()) {
      signatureKey = make_shared<string>(boost::any_cast<string>(m["SignatureKey"]));
    }
    if (m.find("SignatureName") != m.end() && !m["SignatureName"].empty()) {
      signatureName = make_shared<string>(boost::any_cast<string>(m["SignatureName"]));
    }
    if (m.find("SignatureSecret") != m.end() && !m["SignatureSecret"].empty()) {
      signatureSecret = make_shared<string>(boost::any_cast<string>(m["SignatureSecret"]));
    }
  }


  virtual ~DescribeSignaturesResponseBodySignatureInfosSignatureInfo() = default;
};
class DescribeSignaturesResponseBodySignatureInfos : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeSignaturesResponseBodySignatureInfosSignatureInfo>> signatureInfo{};

  DescribeSignaturesResponseBodySignatureInfos() {}

  explicit DescribeSignaturesResponseBodySignatureInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (signatureInfo) {
      vector<boost::any> temp1;
      for(auto item1:*signatureInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SignatureInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SignatureInfo") != m.end() && !m["SignatureInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["SignatureInfo"].type()) {
        vector<DescribeSignaturesResponseBodySignatureInfosSignatureInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SignatureInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeSignaturesResponseBodySignatureInfosSignatureInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        signatureInfo = make_shared<vector<DescribeSignaturesResponseBodySignatureInfosSignatureInfo>>(expect1);
      }
    }
  }


  virtual ~DescribeSignaturesResponseBodySignatureInfos() = default;
};
class DescribeSignaturesResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<DescribeSignaturesResponseBodySignatureInfos> signatureInfos{};
  shared_ptr<long> totalCount{};

  DescribeSignaturesResponseBody() {}

  explicit DescribeSignaturesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (signatureInfos) {
      res["SignatureInfos"] = signatureInfos ? boost::any(signatureInfos->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SignatureInfos") != m.end() && !m["SignatureInfos"].empty()) {
      if (typeid(map<string, boost::any>) == m["SignatureInfos"].type()) {
        DescribeSignaturesResponseBodySignatureInfos model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SignatureInfos"]));
        signatureInfos = make_shared<DescribeSignaturesResponseBodySignatureInfos>(model1);
      }
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeSignaturesResponseBody() = default;
};
class DescribeSignaturesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeSignaturesResponseBody> body{};

  DescribeSignaturesResponse() {}

  explicit DescribeSignaturesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeSignaturesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeSignaturesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeSignaturesResponse() = default;
};
class DescribeSignaturesByApiRequest : public Darabonba::Model {
public:
  shared_ptr<string> apiId{};
  shared_ptr<string> groupId{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> stageName{};

  DescribeSignaturesByApiRequest() {}

  explicit DescribeSignaturesByApiRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiId) {
      res["ApiId"] = boost::any(*apiId);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (stageName) {
      res["StageName"] = boost::any(*stageName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiId") != m.end() && !m["ApiId"].empty()) {
      apiId = make_shared<string>(boost::any_cast<string>(m["ApiId"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("StageName") != m.end() && !m["StageName"].empty()) {
      stageName = make_shared<string>(boost::any_cast<string>(m["StageName"]));
    }
  }


  virtual ~DescribeSignaturesByApiRequest() = default;
};
class DescribeSignaturesByApiResponseBodySignaturesSignatureItem : public Darabonba::Model {
public:
  shared_ptr<string> boundTime{};
  shared_ptr<string> signatureId{};
  shared_ptr<string> signatureName{};

  DescribeSignaturesByApiResponseBodySignaturesSignatureItem() {}

  explicit DescribeSignaturesByApiResponseBodySignaturesSignatureItem(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (boundTime) {
      res["BoundTime"] = boost::any(*boundTime);
    }
    if (signatureId) {
      res["SignatureId"] = boost::any(*signatureId);
    }
    if (signatureName) {
      res["SignatureName"] = boost::any(*signatureName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BoundTime") != m.end() && !m["BoundTime"].empty()) {
      boundTime = make_shared<string>(boost::any_cast<string>(m["BoundTime"]));
    }
    if (m.find("SignatureId") != m.end() && !m["SignatureId"].empty()) {
      signatureId = make_shared<string>(boost::any_cast<string>(m["SignatureId"]));
    }
    if (m.find("SignatureName") != m.end() && !m["SignatureName"].empty()) {
      signatureName = make_shared<string>(boost::any_cast<string>(m["SignatureName"]));
    }
  }


  virtual ~DescribeSignaturesByApiResponseBodySignaturesSignatureItem() = default;
};
class DescribeSignaturesByApiResponseBodySignatures : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeSignaturesByApiResponseBodySignaturesSignatureItem>> signatureItem{};

  DescribeSignaturesByApiResponseBodySignatures() {}

  explicit DescribeSignaturesByApiResponseBodySignatures(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (signatureItem) {
      vector<boost::any> temp1;
      for(auto item1:*signatureItem){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SignatureItem"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SignatureItem") != m.end() && !m["SignatureItem"].empty()) {
      if (typeid(vector<boost::any>) == m["SignatureItem"].type()) {
        vector<DescribeSignaturesByApiResponseBodySignaturesSignatureItem> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SignatureItem"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeSignaturesByApiResponseBodySignaturesSignatureItem model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        signatureItem = make_shared<vector<DescribeSignaturesByApiResponseBodySignaturesSignatureItem>>(expect1);
      }
    }
  }


  virtual ~DescribeSignaturesByApiResponseBodySignatures() = default;
};
class DescribeSignaturesByApiResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeSignaturesByApiResponseBodySignatures> signatures{};

  DescribeSignaturesByApiResponseBody() {}

  explicit DescribeSignaturesByApiResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (signatures) {
      res["Signatures"] = signatures ? boost::any(signatures->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Signatures") != m.end() && !m["Signatures"].empty()) {
      if (typeid(map<string, boost::any>) == m["Signatures"].type()) {
        DescribeSignaturesByApiResponseBodySignatures model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Signatures"]));
        signatures = make_shared<DescribeSignaturesByApiResponseBodySignatures>(model1);
      }
    }
  }


  virtual ~DescribeSignaturesByApiResponseBody() = default;
};
class DescribeSignaturesByApiResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeSignaturesByApiResponseBody> body{};

  DescribeSignaturesByApiResponse() {}

  explicit DescribeSignaturesByApiResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeSignaturesByApiResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeSignaturesByApiResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeSignaturesByApiResponse() = default;
};
class DescribeSummaryDataRequest : public Darabonba::Model {
public:
  shared_ptr<string> securityToken{};

  DescribeSummaryDataRequest() {}

  explicit DescribeSummaryDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~DescribeSummaryDataRequest() = default;
};
class DescribeSummaryDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> expireInstanceNum{};
  shared_ptr<string> region{};
  shared_ptr<string> requestId{};
  shared_ptr<long> usageApiNum{};
  shared_ptr<long> usageGroupNum{};
  shared_ptr<long> usageInstanceNum{};

  DescribeSummaryDataResponseBody() {}

  explicit DescribeSummaryDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (expireInstanceNum) {
      res["ExpireInstanceNum"] = boost::any(*expireInstanceNum);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (usageApiNum) {
      res["UsageApiNum"] = boost::any(*usageApiNum);
    }
    if (usageGroupNum) {
      res["UsageGroupNum"] = boost::any(*usageGroupNum);
    }
    if (usageInstanceNum) {
      res["UsageInstanceNum"] = boost::any(*usageInstanceNum);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ExpireInstanceNum") != m.end() && !m["ExpireInstanceNum"].empty()) {
      expireInstanceNum = make_shared<long>(boost::any_cast<long>(m["ExpireInstanceNum"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("UsageApiNum") != m.end() && !m["UsageApiNum"].empty()) {
      usageApiNum = make_shared<long>(boost::any_cast<long>(m["UsageApiNum"]));
    }
    if (m.find("UsageGroupNum") != m.end() && !m["UsageGroupNum"].empty()) {
      usageGroupNum = make_shared<long>(boost::any_cast<long>(m["UsageGroupNum"]));
    }
    if (m.find("UsageInstanceNum") != m.end() && !m["UsageInstanceNum"].empty()) {
      usageInstanceNum = make_shared<long>(boost::any_cast<long>(m["UsageInstanceNum"]));
    }
  }


  virtual ~DescribeSummaryDataResponseBody() = default;
};
class DescribeSummaryDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeSummaryDataResponseBody> body{};

  DescribeSummaryDataResponse() {}

  explicit DescribeSummaryDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeSummaryDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeSummaryDataResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeSummaryDataResponse() = default;
};
class DescribeSystemParametersRequest : public Darabonba::Model {
public:
  shared_ptr<string> securityToken{};

  DescribeSystemParametersRequest() {}

  explicit DescribeSystemParametersRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~DescribeSystemParametersRequest() = default;
};
class DescribeSystemParametersResponseBodySystemParamsSystemParamItem : public Darabonba::Model {
public:
  shared_ptr<string> demoValue{};
  shared_ptr<string> description{};
  shared_ptr<string> paramName{};
  shared_ptr<string> paramType{};

  DescribeSystemParametersResponseBodySystemParamsSystemParamItem() {}

  explicit DescribeSystemParametersResponseBodySystemParamsSystemParamItem(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (demoValue) {
      res["DemoValue"] = boost::any(*demoValue);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (paramName) {
      res["ParamName"] = boost::any(*paramName);
    }
    if (paramType) {
      res["ParamType"] = boost::any(*paramType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DemoValue") != m.end() && !m["DemoValue"].empty()) {
      demoValue = make_shared<string>(boost::any_cast<string>(m["DemoValue"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("ParamName") != m.end() && !m["ParamName"].empty()) {
      paramName = make_shared<string>(boost::any_cast<string>(m["ParamName"]));
    }
    if (m.find("ParamType") != m.end() && !m["ParamType"].empty()) {
      paramType = make_shared<string>(boost::any_cast<string>(m["ParamType"]));
    }
  }


  virtual ~DescribeSystemParametersResponseBodySystemParamsSystemParamItem() = default;
};
class DescribeSystemParametersResponseBodySystemParams : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeSystemParametersResponseBodySystemParamsSystemParamItem>> systemParamItem{};

  DescribeSystemParametersResponseBodySystemParams() {}

  explicit DescribeSystemParametersResponseBodySystemParams(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (systemParamItem) {
      vector<boost::any> temp1;
      for(auto item1:*systemParamItem){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SystemParamItem"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SystemParamItem") != m.end() && !m["SystemParamItem"].empty()) {
      if (typeid(vector<boost::any>) == m["SystemParamItem"].type()) {
        vector<DescribeSystemParametersResponseBodySystemParamsSystemParamItem> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SystemParamItem"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeSystemParametersResponseBodySystemParamsSystemParamItem model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        systemParamItem = make_shared<vector<DescribeSystemParametersResponseBodySystemParamsSystemParamItem>>(expect1);
      }
    }
  }


  virtual ~DescribeSystemParametersResponseBodySystemParams() = default;
};
class DescribeSystemParametersResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeSystemParametersResponseBodySystemParams> systemParams{};

  DescribeSystemParametersResponseBody() {}

  explicit DescribeSystemParametersResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (systemParams) {
      res["SystemParams"] = systemParams ? boost::any(systemParams->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SystemParams") != m.end() && !m["SystemParams"].empty()) {
      if (typeid(map<string, boost::any>) == m["SystemParams"].type()) {
        DescribeSystemParametersResponseBodySystemParams model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SystemParams"]));
        systemParams = make_shared<DescribeSystemParametersResponseBodySystemParams>(model1);
      }
    }
  }


  virtual ~DescribeSystemParametersResponseBody() = default;
};
class DescribeSystemParametersResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeSystemParametersResponseBody> body{};

  DescribeSystemParametersResponse() {}

  explicit DescribeSystemParametersResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeSystemParametersResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeSystemParametersResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeSystemParametersResponse() = default;
};
class DescribeTrafficControlsRequest : public Darabonba::Model {
public:
  shared_ptr<string> apiId{};
  shared_ptr<string> groupId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> stageName{};
  shared_ptr<string> trafficControlId{};
  shared_ptr<string> trafficControlName{};

  DescribeTrafficControlsRequest() {}

  explicit DescribeTrafficControlsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiId) {
      res["ApiId"] = boost::any(*apiId);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (stageName) {
      res["StageName"] = boost::any(*stageName);
    }
    if (trafficControlId) {
      res["TrafficControlId"] = boost::any(*trafficControlId);
    }
    if (trafficControlName) {
      res["TrafficControlName"] = boost::any(*trafficControlName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiId") != m.end() && !m["ApiId"].empty()) {
      apiId = make_shared<string>(boost::any_cast<string>(m["ApiId"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("StageName") != m.end() && !m["StageName"].empty()) {
      stageName = make_shared<string>(boost::any_cast<string>(m["StageName"]));
    }
    if (m.find("TrafficControlId") != m.end() && !m["TrafficControlId"].empty()) {
      trafficControlId = make_shared<string>(boost::any_cast<string>(m["TrafficControlId"]));
    }
    if (m.find("TrafficControlName") != m.end() && !m["TrafficControlName"].empty()) {
      trafficControlName = make_shared<string>(boost::any_cast<string>(m["TrafficControlName"]));
    }
  }


  virtual ~DescribeTrafficControlsRequest() = default;
};
class DescribeTrafficControlsResponseBodyTrafficControlsTrafficControlSpecialPoliciesSpecialPolicySpecialsSpecial : public Darabonba::Model {
public:
  shared_ptr<string> specialKey{};
  shared_ptr<long> trafficValue{};

  DescribeTrafficControlsResponseBodyTrafficControlsTrafficControlSpecialPoliciesSpecialPolicySpecialsSpecial() {}

  explicit DescribeTrafficControlsResponseBodyTrafficControlsTrafficControlSpecialPoliciesSpecialPolicySpecialsSpecial(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (specialKey) {
      res["SpecialKey"] = boost::any(*specialKey);
    }
    if (trafficValue) {
      res["TrafficValue"] = boost::any(*trafficValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SpecialKey") != m.end() && !m["SpecialKey"].empty()) {
      specialKey = make_shared<string>(boost::any_cast<string>(m["SpecialKey"]));
    }
    if (m.find("TrafficValue") != m.end() && !m["TrafficValue"].empty()) {
      trafficValue = make_shared<long>(boost::any_cast<long>(m["TrafficValue"]));
    }
  }


  virtual ~DescribeTrafficControlsResponseBodyTrafficControlsTrafficControlSpecialPoliciesSpecialPolicySpecialsSpecial() = default;
};
class DescribeTrafficControlsResponseBodyTrafficControlsTrafficControlSpecialPoliciesSpecialPolicySpecials : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeTrafficControlsResponseBodyTrafficControlsTrafficControlSpecialPoliciesSpecialPolicySpecialsSpecial>> special{};

  DescribeTrafficControlsResponseBodyTrafficControlsTrafficControlSpecialPoliciesSpecialPolicySpecials() {}

  explicit DescribeTrafficControlsResponseBodyTrafficControlsTrafficControlSpecialPoliciesSpecialPolicySpecials(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (special) {
      vector<boost::any> temp1;
      for(auto item1:*special){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Special"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Special") != m.end() && !m["Special"].empty()) {
      if (typeid(vector<boost::any>) == m["Special"].type()) {
        vector<DescribeTrafficControlsResponseBodyTrafficControlsTrafficControlSpecialPoliciesSpecialPolicySpecialsSpecial> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Special"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeTrafficControlsResponseBodyTrafficControlsTrafficControlSpecialPoliciesSpecialPolicySpecialsSpecial model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        special = make_shared<vector<DescribeTrafficControlsResponseBodyTrafficControlsTrafficControlSpecialPoliciesSpecialPolicySpecialsSpecial>>(expect1);
      }
    }
  }


  virtual ~DescribeTrafficControlsResponseBodyTrafficControlsTrafficControlSpecialPoliciesSpecialPolicySpecials() = default;
};
class DescribeTrafficControlsResponseBodyTrafficControlsTrafficControlSpecialPoliciesSpecialPolicy : public Darabonba::Model {
public:
  shared_ptr<string> specialType{};
  shared_ptr<DescribeTrafficControlsResponseBodyTrafficControlsTrafficControlSpecialPoliciesSpecialPolicySpecials> specials{};

  DescribeTrafficControlsResponseBodyTrafficControlsTrafficControlSpecialPoliciesSpecialPolicy() {}

  explicit DescribeTrafficControlsResponseBodyTrafficControlsTrafficControlSpecialPoliciesSpecialPolicy(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (specialType) {
      res["SpecialType"] = boost::any(*specialType);
    }
    if (specials) {
      res["Specials"] = specials ? boost::any(specials->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SpecialType") != m.end() && !m["SpecialType"].empty()) {
      specialType = make_shared<string>(boost::any_cast<string>(m["SpecialType"]));
    }
    if (m.find("Specials") != m.end() && !m["Specials"].empty()) {
      if (typeid(map<string, boost::any>) == m["Specials"].type()) {
        DescribeTrafficControlsResponseBodyTrafficControlsTrafficControlSpecialPoliciesSpecialPolicySpecials model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Specials"]));
        specials = make_shared<DescribeTrafficControlsResponseBodyTrafficControlsTrafficControlSpecialPoliciesSpecialPolicySpecials>(model1);
      }
    }
  }


  virtual ~DescribeTrafficControlsResponseBodyTrafficControlsTrafficControlSpecialPoliciesSpecialPolicy() = default;
};
class DescribeTrafficControlsResponseBodyTrafficControlsTrafficControlSpecialPolicies : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeTrafficControlsResponseBodyTrafficControlsTrafficControlSpecialPoliciesSpecialPolicy>> specialPolicy{};

  DescribeTrafficControlsResponseBodyTrafficControlsTrafficControlSpecialPolicies() {}

  explicit DescribeTrafficControlsResponseBodyTrafficControlsTrafficControlSpecialPolicies(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (specialPolicy) {
      vector<boost::any> temp1;
      for(auto item1:*specialPolicy){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SpecialPolicy"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SpecialPolicy") != m.end() && !m["SpecialPolicy"].empty()) {
      if (typeid(vector<boost::any>) == m["SpecialPolicy"].type()) {
        vector<DescribeTrafficControlsResponseBodyTrafficControlsTrafficControlSpecialPoliciesSpecialPolicy> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SpecialPolicy"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeTrafficControlsResponseBodyTrafficControlsTrafficControlSpecialPoliciesSpecialPolicy model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        specialPolicy = make_shared<vector<DescribeTrafficControlsResponseBodyTrafficControlsTrafficControlSpecialPoliciesSpecialPolicy>>(expect1);
      }
    }
  }


  virtual ~DescribeTrafficControlsResponseBodyTrafficControlsTrafficControlSpecialPolicies() = default;
};
class DescribeTrafficControlsResponseBodyTrafficControlsTrafficControl : public Darabonba::Model {
public:
  shared_ptr<long> apiDefault{};
  shared_ptr<long> appDefault{};
  shared_ptr<string> createdTime{};
  shared_ptr<string> description{};
  shared_ptr<string> modifiedTime{};
  shared_ptr<DescribeTrafficControlsResponseBodyTrafficControlsTrafficControlSpecialPolicies> specialPolicies{};
  shared_ptr<string> trafficControlId{};
  shared_ptr<string> trafficControlName{};
  shared_ptr<string> trafficControlUnit{};
  shared_ptr<long> userDefault{};

  DescribeTrafficControlsResponseBodyTrafficControlsTrafficControl() {}

  explicit DescribeTrafficControlsResponseBodyTrafficControlsTrafficControl(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiDefault) {
      res["ApiDefault"] = boost::any(*apiDefault);
    }
    if (appDefault) {
      res["AppDefault"] = boost::any(*appDefault);
    }
    if (createdTime) {
      res["CreatedTime"] = boost::any(*createdTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (modifiedTime) {
      res["ModifiedTime"] = boost::any(*modifiedTime);
    }
    if (specialPolicies) {
      res["SpecialPolicies"] = specialPolicies ? boost::any(specialPolicies->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (trafficControlId) {
      res["TrafficControlId"] = boost::any(*trafficControlId);
    }
    if (trafficControlName) {
      res["TrafficControlName"] = boost::any(*trafficControlName);
    }
    if (trafficControlUnit) {
      res["TrafficControlUnit"] = boost::any(*trafficControlUnit);
    }
    if (userDefault) {
      res["UserDefault"] = boost::any(*userDefault);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiDefault") != m.end() && !m["ApiDefault"].empty()) {
      apiDefault = make_shared<long>(boost::any_cast<long>(m["ApiDefault"]));
    }
    if (m.find("AppDefault") != m.end() && !m["AppDefault"].empty()) {
      appDefault = make_shared<long>(boost::any_cast<long>(m["AppDefault"]));
    }
    if (m.find("CreatedTime") != m.end() && !m["CreatedTime"].empty()) {
      createdTime = make_shared<string>(boost::any_cast<string>(m["CreatedTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("ModifiedTime") != m.end() && !m["ModifiedTime"].empty()) {
      modifiedTime = make_shared<string>(boost::any_cast<string>(m["ModifiedTime"]));
    }
    if (m.find("SpecialPolicies") != m.end() && !m["SpecialPolicies"].empty()) {
      if (typeid(map<string, boost::any>) == m["SpecialPolicies"].type()) {
        DescribeTrafficControlsResponseBodyTrafficControlsTrafficControlSpecialPolicies model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SpecialPolicies"]));
        specialPolicies = make_shared<DescribeTrafficControlsResponseBodyTrafficControlsTrafficControlSpecialPolicies>(model1);
      }
    }
    if (m.find("TrafficControlId") != m.end() && !m["TrafficControlId"].empty()) {
      trafficControlId = make_shared<string>(boost::any_cast<string>(m["TrafficControlId"]));
    }
    if (m.find("TrafficControlName") != m.end() && !m["TrafficControlName"].empty()) {
      trafficControlName = make_shared<string>(boost::any_cast<string>(m["TrafficControlName"]));
    }
    if (m.find("TrafficControlUnit") != m.end() && !m["TrafficControlUnit"].empty()) {
      trafficControlUnit = make_shared<string>(boost::any_cast<string>(m["TrafficControlUnit"]));
    }
    if (m.find("UserDefault") != m.end() && !m["UserDefault"].empty()) {
      userDefault = make_shared<long>(boost::any_cast<long>(m["UserDefault"]));
    }
  }


  virtual ~DescribeTrafficControlsResponseBodyTrafficControlsTrafficControl() = default;
};
class DescribeTrafficControlsResponseBodyTrafficControls : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeTrafficControlsResponseBodyTrafficControlsTrafficControl>> trafficControl{};

  DescribeTrafficControlsResponseBodyTrafficControls() {}

  explicit DescribeTrafficControlsResponseBodyTrafficControls(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (trafficControl) {
      vector<boost::any> temp1;
      for(auto item1:*trafficControl){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TrafficControl"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TrafficControl") != m.end() && !m["TrafficControl"].empty()) {
      if (typeid(vector<boost::any>) == m["TrafficControl"].type()) {
        vector<DescribeTrafficControlsResponseBodyTrafficControlsTrafficControl> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TrafficControl"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeTrafficControlsResponseBodyTrafficControlsTrafficControl model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        trafficControl = make_shared<vector<DescribeTrafficControlsResponseBodyTrafficControlsTrafficControl>>(expect1);
      }
    }
  }


  virtual ~DescribeTrafficControlsResponseBodyTrafficControls() = default;
};
class DescribeTrafficControlsResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};
  shared_ptr<DescribeTrafficControlsResponseBodyTrafficControls> trafficControls{};

  DescribeTrafficControlsResponseBody() {}

  explicit DescribeTrafficControlsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (trafficControls) {
      res["TrafficControls"] = trafficControls ? boost::any(trafficControls->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("TrafficControls") != m.end() && !m["TrafficControls"].empty()) {
      if (typeid(map<string, boost::any>) == m["TrafficControls"].type()) {
        DescribeTrafficControlsResponseBodyTrafficControls model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TrafficControls"]));
        trafficControls = make_shared<DescribeTrafficControlsResponseBodyTrafficControls>(model1);
      }
    }
  }


  virtual ~DescribeTrafficControlsResponseBody() = default;
};
class DescribeTrafficControlsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeTrafficControlsResponseBody> body{};

  DescribeTrafficControlsResponse() {}

  explicit DescribeTrafficControlsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeTrafficControlsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeTrafficControlsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeTrafficControlsResponse() = default;
};
class DescribeTrafficControlsByApiRequest : public Darabonba::Model {
public:
  shared_ptr<string> apiId{};
  shared_ptr<string> groupId{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> stageName{};

  DescribeTrafficControlsByApiRequest() {}

  explicit DescribeTrafficControlsByApiRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiId) {
      res["ApiId"] = boost::any(*apiId);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (stageName) {
      res["StageName"] = boost::any(*stageName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiId") != m.end() && !m["ApiId"].empty()) {
      apiId = make_shared<string>(boost::any_cast<string>(m["ApiId"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("StageName") != m.end() && !m["StageName"].empty()) {
      stageName = make_shared<string>(boost::any_cast<string>(m["StageName"]));
    }
  }


  virtual ~DescribeTrafficControlsByApiRequest() = default;
};
class DescribeTrafficControlsByApiResponseBodyTrafficControlItemsTrafficControlItem : public Darabonba::Model {
public:
  shared_ptr<string> boundTime{};
  shared_ptr<string> trafficControlItemId{};
  shared_ptr<string> trafficControlItemName{};

  DescribeTrafficControlsByApiResponseBodyTrafficControlItemsTrafficControlItem() {}

  explicit DescribeTrafficControlsByApiResponseBodyTrafficControlItemsTrafficControlItem(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (boundTime) {
      res["BoundTime"] = boost::any(*boundTime);
    }
    if (trafficControlItemId) {
      res["TrafficControlItemId"] = boost::any(*trafficControlItemId);
    }
    if (trafficControlItemName) {
      res["TrafficControlItemName"] = boost::any(*trafficControlItemName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BoundTime") != m.end() && !m["BoundTime"].empty()) {
      boundTime = make_shared<string>(boost::any_cast<string>(m["BoundTime"]));
    }
    if (m.find("TrafficControlItemId") != m.end() && !m["TrafficControlItemId"].empty()) {
      trafficControlItemId = make_shared<string>(boost::any_cast<string>(m["TrafficControlItemId"]));
    }
    if (m.find("TrafficControlItemName") != m.end() && !m["TrafficControlItemName"].empty()) {
      trafficControlItemName = make_shared<string>(boost::any_cast<string>(m["TrafficControlItemName"]));
    }
  }


  virtual ~DescribeTrafficControlsByApiResponseBodyTrafficControlItemsTrafficControlItem() = default;
};
class DescribeTrafficControlsByApiResponseBodyTrafficControlItems : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeTrafficControlsByApiResponseBodyTrafficControlItemsTrafficControlItem>> trafficControlItem{};

  DescribeTrafficControlsByApiResponseBodyTrafficControlItems() {}

  explicit DescribeTrafficControlsByApiResponseBodyTrafficControlItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (trafficControlItem) {
      vector<boost::any> temp1;
      for(auto item1:*trafficControlItem){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TrafficControlItem"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TrafficControlItem") != m.end() && !m["TrafficControlItem"].empty()) {
      if (typeid(vector<boost::any>) == m["TrafficControlItem"].type()) {
        vector<DescribeTrafficControlsByApiResponseBodyTrafficControlItemsTrafficControlItem> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TrafficControlItem"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeTrafficControlsByApiResponseBodyTrafficControlItemsTrafficControlItem model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        trafficControlItem = make_shared<vector<DescribeTrafficControlsByApiResponseBodyTrafficControlItemsTrafficControlItem>>(expect1);
      }
    }
  }


  virtual ~DescribeTrafficControlsByApiResponseBodyTrafficControlItems() = default;
};
class DescribeTrafficControlsByApiResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeTrafficControlsByApiResponseBodyTrafficControlItems> trafficControlItems{};

  DescribeTrafficControlsByApiResponseBody() {}

  explicit DescribeTrafficControlsByApiResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (trafficControlItems) {
      res["TrafficControlItems"] = trafficControlItems ? boost::any(trafficControlItems->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TrafficControlItems") != m.end() && !m["TrafficControlItems"].empty()) {
      if (typeid(map<string, boost::any>) == m["TrafficControlItems"].type()) {
        DescribeTrafficControlsByApiResponseBodyTrafficControlItems model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TrafficControlItems"]));
        trafficControlItems = make_shared<DescribeTrafficControlsByApiResponseBodyTrafficControlItems>(model1);
      }
    }
  }


  virtual ~DescribeTrafficControlsByApiResponseBody() = default;
};
class DescribeTrafficControlsByApiResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeTrafficControlsByApiResponseBody> body{};

  DescribeTrafficControlsByApiResponse() {}

  explicit DescribeTrafficControlsByApiResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeTrafficControlsByApiResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeTrafficControlsByApiResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeTrafficControlsByApiResponse() = default;
};
class DescribeUpdateBackendTaskRequest : public Darabonba::Model {
public:
  shared_ptr<string> operationUid{};
  shared_ptr<string> securityToken{};

  DescribeUpdateBackendTaskRequest() {}

  explicit DescribeUpdateBackendTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (operationUid) {
      res["OperationUid"] = boost::any(*operationUid);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OperationUid") != m.end() && !m["OperationUid"].empty()) {
      operationUid = make_shared<string>(boost::any_cast<string>(m["OperationUid"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~DescribeUpdateBackendTaskRequest() = default;
};
class DescribeUpdateBackendTaskResponseBodyApiUpdateBackendResultsApiUpdateBackendResult : public Darabonba::Model {
public:
  shared_ptr<string> apiName{};
  shared_ptr<string> apiUid{};
  shared_ptr<string> backendId{};
  shared_ptr<string> errorMsg{};
  shared_ptr<string> groupId{};
  shared_ptr<string> groupName{};
  shared_ptr<string> stageId{};
  shared_ptr<string> stageName{};
  shared_ptr<string> updateStatus{};

  DescribeUpdateBackendTaskResponseBodyApiUpdateBackendResultsApiUpdateBackendResult() {}

  explicit DescribeUpdateBackendTaskResponseBodyApiUpdateBackendResultsApiUpdateBackendResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiName) {
      res["ApiName"] = boost::any(*apiName);
    }
    if (apiUid) {
      res["ApiUid"] = boost::any(*apiUid);
    }
    if (backendId) {
      res["BackendId"] = boost::any(*backendId);
    }
    if (errorMsg) {
      res["ErrorMsg"] = boost::any(*errorMsg);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (stageId) {
      res["StageId"] = boost::any(*stageId);
    }
    if (stageName) {
      res["StageName"] = boost::any(*stageName);
    }
    if (updateStatus) {
      res["UpdateStatus"] = boost::any(*updateStatus);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiName") != m.end() && !m["ApiName"].empty()) {
      apiName = make_shared<string>(boost::any_cast<string>(m["ApiName"]));
    }
    if (m.find("ApiUid") != m.end() && !m["ApiUid"].empty()) {
      apiUid = make_shared<string>(boost::any_cast<string>(m["ApiUid"]));
    }
    if (m.find("BackendId") != m.end() && !m["BackendId"].empty()) {
      backendId = make_shared<string>(boost::any_cast<string>(m["BackendId"]));
    }
    if (m.find("ErrorMsg") != m.end() && !m["ErrorMsg"].empty()) {
      errorMsg = make_shared<string>(boost::any_cast<string>(m["ErrorMsg"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("StageId") != m.end() && !m["StageId"].empty()) {
      stageId = make_shared<string>(boost::any_cast<string>(m["StageId"]));
    }
    if (m.find("StageName") != m.end() && !m["StageName"].empty()) {
      stageName = make_shared<string>(boost::any_cast<string>(m["StageName"]));
    }
    if (m.find("UpdateStatus") != m.end() && !m["UpdateStatus"].empty()) {
      updateStatus = make_shared<string>(boost::any_cast<string>(m["UpdateStatus"]));
    }
  }


  virtual ~DescribeUpdateBackendTaskResponseBodyApiUpdateBackendResultsApiUpdateBackendResult() = default;
};
class DescribeUpdateBackendTaskResponseBodyApiUpdateBackendResults : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeUpdateBackendTaskResponseBodyApiUpdateBackendResultsApiUpdateBackendResult>> apiUpdateBackendResult{};

  DescribeUpdateBackendTaskResponseBodyApiUpdateBackendResults() {}

  explicit DescribeUpdateBackendTaskResponseBodyApiUpdateBackendResults(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiUpdateBackendResult) {
      vector<boost::any> temp1;
      for(auto item1:*apiUpdateBackendResult){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ApiUpdateBackendResult"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiUpdateBackendResult") != m.end() && !m["ApiUpdateBackendResult"].empty()) {
      if (typeid(vector<boost::any>) == m["ApiUpdateBackendResult"].type()) {
        vector<DescribeUpdateBackendTaskResponseBodyApiUpdateBackendResultsApiUpdateBackendResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ApiUpdateBackendResult"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeUpdateBackendTaskResponseBodyApiUpdateBackendResultsApiUpdateBackendResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        apiUpdateBackendResult = make_shared<vector<DescribeUpdateBackendTaskResponseBodyApiUpdateBackendResultsApiUpdateBackendResult>>(expect1);
      }
    }
  }


  virtual ~DescribeUpdateBackendTaskResponseBodyApiUpdateBackendResults() = default;
};
class DescribeUpdateBackendTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeUpdateBackendTaskResponseBodyApiUpdateBackendResults> apiUpdateBackendResults{};
  shared_ptr<string> requestId{};

  DescribeUpdateBackendTaskResponseBody() {}

  explicit DescribeUpdateBackendTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiUpdateBackendResults) {
      res["ApiUpdateBackendResults"] = apiUpdateBackendResults ? boost::any(apiUpdateBackendResults->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiUpdateBackendResults") != m.end() && !m["ApiUpdateBackendResults"].empty()) {
      if (typeid(map<string, boost::any>) == m["ApiUpdateBackendResults"].type()) {
        DescribeUpdateBackendTaskResponseBodyApiUpdateBackendResults model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ApiUpdateBackendResults"]));
        apiUpdateBackendResults = make_shared<DescribeUpdateBackendTaskResponseBodyApiUpdateBackendResults>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeUpdateBackendTaskResponseBody() = default;
};
class DescribeUpdateBackendTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeUpdateBackendTaskResponseBody> body{};

  DescribeUpdateBackendTaskResponse() {}

  explicit DescribeUpdateBackendTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeUpdateBackendTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeUpdateBackendTaskResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeUpdateBackendTaskResponse() = default;
};
class DescribeUpdateVpcInfoTaskRequest : public Darabonba::Model {
public:
  shared_ptr<string> operationUid{};
  shared_ptr<string> securityToken{};

  DescribeUpdateVpcInfoTaskRequest() {}

  explicit DescribeUpdateVpcInfoTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (operationUid) {
      res["OperationUid"] = boost::any(*operationUid);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OperationUid") != m.end() && !m["OperationUid"].empty()) {
      operationUid = make_shared<string>(boost::any_cast<string>(m["OperationUid"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~DescribeUpdateVpcInfoTaskRequest() = default;
};
class DescribeUpdateVpcInfoTaskResponseBodyApiUpdateVpcInfoResultsApiUpdateVpcInfoResult : public Darabonba::Model {
public:
  shared_ptr<string> apiName{};
  shared_ptr<string> apiUid{};
  shared_ptr<string> errorMsg{};
  shared_ptr<string> groupId{};
  shared_ptr<string> groupName{};
  shared_ptr<string> stageId{};
  shared_ptr<string> stageName{};
  shared_ptr<string> updateStatus{};

  DescribeUpdateVpcInfoTaskResponseBodyApiUpdateVpcInfoResultsApiUpdateVpcInfoResult() {}

  explicit DescribeUpdateVpcInfoTaskResponseBodyApiUpdateVpcInfoResultsApiUpdateVpcInfoResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiName) {
      res["ApiName"] = boost::any(*apiName);
    }
    if (apiUid) {
      res["ApiUid"] = boost::any(*apiUid);
    }
    if (errorMsg) {
      res["ErrorMsg"] = boost::any(*errorMsg);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (stageId) {
      res["StageId"] = boost::any(*stageId);
    }
    if (stageName) {
      res["StageName"] = boost::any(*stageName);
    }
    if (updateStatus) {
      res["UpdateStatus"] = boost::any(*updateStatus);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiName") != m.end() && !m["ApiName"].empty()) {
      apiName = make_shared<string>(boost::any_cast<string>(m["ApiName"]));
    }
    if (m.find("ApiUid") != m.end() && !m["ApiUid"].empty()) {
      apiUid = make_shared<string>(boost::any_cast<string>(m["ApiUid"]));
    }
    if (m.find("ErrorMsg") != m.end() && !m["ErrorMsg"].empty()) {
      errorMsg = make_shared<string>(boost::any_cast<string>(m["ErrorMsg"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("StageId") != m.end() && !m["StageId"].empty()) {
      stageId = make_shared<string>(boost::any_cast<string>(m["StageId"]));
    }
    if (m.find("StageName") != m.end() && !m["StageName"].empty()) {
      stageName = make_shared<string>(boost::any_cast<string>(m["StageName"]));
    }
    if (m.find("UpdateStatus") != m.end() && !m["UpdateStatus"].empty()) {
      updateStatus = make_shared<string>(boost::any_cast<string>(m["UpdateStatus"]));
    }
  }


  virtual ~DescribeUpdateVpcInfoTaskResponseBodyApiUpdateVpcInfoResultsApiUpdateVpcInfoResult() = default;
};
class DescribeUpdateVpcInfoTaskResponseBodyApiUpdateVpcInfoResults : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeUpdateVpcInfoTaskResponseBodyApiUpdateVpcInfoResultsApiUpdateVpcInfoResult>> apiUpdateVpcInfoResult{};

  DescribeUpdateVpcInfoTaskResponseBodyApiUpdateVpcInfoResults() {}

  explicit DescribeUpdateVpcInfoTaskResponseBodyApiUpdateVpcInfoResults(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiUpdateVpcInfoResult) {
      vector<boost::any> temp1;
      for(auto item1:*apiUpdateVpcInfoResult){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ApiUpdateVpcInfoResult"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiUpdateVpcInfoResult") != m.end() && !m["ApiUpdateVpcInfoResult"].empty()) {
      if (typeid(vector<boost::any>) == m["ApiUpdateVpcInfoResult"].type()) {
        vector<DescribeUpdateVpcInfoTaskResponseBodyApiUpdateVpcInfoResultsApiUpdateVpcInfoResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ApiUpdateVpcInfoResult"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeUpdateVpcInfoTaskResponseBodyApiUpdateVpcInfoResultsApiUpdateVpcInfoResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        apiUpdateVpcInfoResult = make_shared<vector<DescribeUpdateVpcInfoTaskResponseBodyApiUpdateVpcInfoResultsApiUpdateVpcInfoResult>>(expect1);
      }
    }
  }


  virtual ~DescribeUpdateVpcInfoTaskResponseBodyApiUpdateVpcInfoResults() = default;
};
class DescribeUpdateVpcInfoTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeUpdateVpcInfoTaskResponseBodyApiUpdateVpcInfoResults> apiUpdateVpcInfoResults{};
  shared_ptr<string> requestId{};

  DescribeUpdateVpcInfoTaskResponseBody() {}

  explicit DescribeUpdateVpcInfoTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiUpdateVpcInfoResults) {
      res["ApiUpdateVpcInfoResults"] = apiUpdateVpcInfoResults ? boost::any(apiUpdateVpcInfoResults->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiUpdateVpcInfoResults") != m.end() && !m["ApiUpdateVpcInfoResults"].empty()) {
      if (typeid(map<string, boost::any>) == m["ApiUpdateVpcInfoResults"].type()) {
        DescribeUpdateVpcInfoTaskResponseBodyApiUpdateVpcInfoResults model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ApiUpdateVpcInfoResults"]));
        apiUpdateVpcInfoResults = make_shared<DescribeUpdateVpcInfoTaskResponseBodyApiUpdateVpcInfoResults>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeUpdateVpcInfoTaskResponseBody() = default;
};
class DescribeUpdateVpcInfoTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeUpdateVpcInfoTaskResponseBody> body{};

  DescribeUpdateVpcInfoTaskResponse() {}

  explicit DescribeUpdateVpcInfoTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeUpdateVpcInfoTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeUpdateVpcInfoTaskResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeUpdateVpcInfoTaskResponse() = default;
};
class DescribeVpcAccessesRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  DescribeVpcAccessesRequestTag() {}

  explicit DescribeVpcAccessesRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeVpcAccessesRequestTag() = default;
};
class DescribeVpcAccessesRequest : public Darabonba::Model {
public:
  shared_ptr<bool> accurateQuery{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> name{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> port{};
  shared_ptr<string> securityToken{};
  shared_ptr<vector<DescribeVpcAccessesRequestTag>> tag{};
  shared_ptr<string> vpcAccessId{};
  shared_ptr<string> vpcId{};

  DescribeVpcAccessesRequest() {}

  explicit DescribeVpcAccessesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accurateQuery) {
      res["AccurateQuery"] = boost::any(*accurateQuery);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    if (vpcAccessId) {
      res["VpcAccessId"] = boost::any(*vpcAccessId);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccurateQuery") != m.end() && !m["AccurateQuery"].empty()) {
      accurateQuery = make_shared<bool>(boost::any_cast<bool>(m["AccurateQuery"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<string>(boost::any_cast<string>(m["Port"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<DescribeVpcAccessesRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeVpcAccessesRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<DescribeVpcAccessesRequestTag>>(expect1);
      }
    }
    if (m.find("VpcAccessId") != m.end() && !m["VpcAccessId"].empty()) {
      vpcAccessId = make_shared<string>(boost::any_cast<string>(m["VpcAccessId"]));
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
  }


  virtual ~DescribeVpcAccessesRequest() = default;
};
class DescribeVpcAccessesResponseBodyVpcAccessAttributesVpcAccessAttributeTagsTagInfo : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  DescribeVpcAccessesResponseBodyVpcAccessAttributesVpcAccessAttributeTagsTagInfo() {}

  explicit DescribeVpcAccessesResponseBodyVpcAccessAttributesVpcAccessAttributeTagsTagInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeVpcAccessesResponseBodyVpcAccessAttributesVpcAccessAttributeTagsTagInfo() = default;
};
class DescribeVpcAccessesResponseBodyVpcAccessAttributesVpcAccessAttributeTags : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeVpcAccessesResponseBodyVpcAccessAttributesVpcAccessAttributeTagsTagInfo>> tagInfo{};

  DescribeVpcAccessesResponseBodyVpcAccessAttributesVpcAccessAttributeTags() {}

  explicit DescribeVpcAccessesResponseBodyVpcAccessAttributesVpcAccessAttributeTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tagInfo) {
      vector<boost::any> temp1;
      for(auto item1:*tagInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TagInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TagInfo") != m.end() && !m["TagInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["TagInfo"].type()) {
        vector<DescribeVpcAccessesResponseBodyVpcAccessAttributesVpcAccessAttributeTagsTagInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TagInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeVpcAccessesResponseBodyVpcAccessAttributesVpcAccessAttributeTagsTagInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tagInfo = make_shared<vector<DescribeVpcAccessesResponseBodyVpcAccessAttributesVpcAccessAttributeTagsTagInfo>>(expect1);
      }
    }
  }


  virtual ~DescribeVpcAccessesResponseBodyVpcAccessAttributesVpcAccessAttributeTags() = default;
};
class DescribeVpcAccessesResponseBodyVpcAccessAttributesVpcAccessAttribute : public Darabonba::Model {
public:
  shared_ptr<string> createdTime{};
  shared_ptr<string> description{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> name{};
  shared_ptr<long> port{};
  shared_ptr<string> regionId{};
  shared_ptr<DescribeVpcAccessesResponseBodyVpcAccessAttributesVpcAccessAttributeTags> tags{};
  shared_ptr<string> vpcAccessId{};
  shared_ptr<string> vpcId{};
  shared_ptr<string> vpcTargetHostName{};

  DescribeVpcAccessesResponseBodyVpcAccessAttributesVpcAccessAttribute() {}

  explicit DescribeVpcAccessesResponseBodyVpcAccessAttributesVpcAccessAttribute(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createdTime) {
      res["CreatedTime"] = boost::any(*createdTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (tags) {
      res["Tags"] = tags ? boost::any(tags->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (vpcAccessId) {
      res["VpcAccessId"] = boost::any(*vpcAccessId);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    if (vpcTargetHostName) {
      res["VpcTargetHostName"] = boost::any(*vpcTargetHostName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreatedTime") != m.end() && !m["CreatedTime"].empty()) {
      createdTime = make_shared<string>(boost::any_cast<string>(m["CreatedTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<long>(boost::any_cast<long>(m["Port"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(map<string, boost::any>) == m["Tags"].type()) {
        DescribeVpcAccessesResponseBodyVpcAccessAttributesVpcAccessAttributeTags model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Tags"]));
        tags = make_shared<DescribeVpcAccessesResponseBodyVpcAccessAttributesVpcAccessAttributeTags>(model1);
      }
    }
    if (m.find("VpcAccessId") != m.end() && !m["VpcAccessId"].empty()) {
      vpcAccessId = make_shared<string>(boost::any_cast<string>(m["VpcAccessId"]));
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
    if (m.find("VpcTargetHostName") != m.end() && !m["VpcTargetHostName"].empty()) {
      vpcTargetHostName = make_shared<string>(boost::any_cast<string>(m["VpcTargetHostName"]));
    }
  }


  virtual ~DescribeVpcAccessesResponseBodyVpcAccessAttributesVpcAccessAttribute() = default;
};
class DescribeVpcAccessesResponseBodyVpcAccessAttributes : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeVpcAccessesResponseBodyVpcAccessAttributesVpcAccessAttribute>> vpcAccessAttribute{};

  DescribeVpcAccessesResponseBodyVpcAccessAttributes() {}

  explicit DescribeVpcAccessesResponseBodyVpcAccessAttributes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (vpcAccessAttribute) {
      vector<boost::any> temp1;
      for(auto item1:*vpcAccessAttribute){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["VpcAccessAttribute"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("VpcAccessAttribute") != m.end() && !m["VpcAccessAttribute"].empty()) {
      if (typeid(vector<boost::any>) == m["VpcAccessAttribute"].type()) {
        vector<DescribeVpcAccessesResponseBodyVpcAccessAttributesVpcAccessAttribute> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["VpcAccessAttribute"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeVpcAccessesResponseBodyVpcAccessAttributesVpcAccessAttribute model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        vpcAccessAttribute = make_shared<vector<DescribeVpcAccessesResponseBodyVpcAccessAttributesVpcAccessAttribute>>(expect1);
      }
    }
  }


  virtual ~DescribeVpcAccessesResponseBodyVpcAccessAttributes() = default;
};
class DescribeVpcAccessesResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};
  shared_ptr<DescribeVpcAccessesResponseBodyVpcAccessAttributes> vpcAccessAttributes{};

  DescribeVpcAccessesResponseBody() {}

  explicit DescribeVpcAccessesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (vpcAccessAttributes) {
      res["VpcAccessAttributes"] = vpcAccessAttributes ? boost::any(vpcAccessAttributes->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("VpcAccessAttributes") != m.end() && !m["VpcAccessAttributes"].empty()) {
      if (typeid(map<string, boost::any>) == m["VpcAccessAttributes"].type()) {
        DescribeVpcAccessesResponseBodyVpcAccessAttributes model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["VpcAccessAttributes"]));
        vpcAccessAttributes = make_shared<DescribeVpcAccessesResponseBodyVpcAccessAttributes>(model1);
      }
    }
  }


  virtual ~DescribeVpcAccessesResponseBody() = default;
};
class DescribeVpcAccessesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeVpcAccessesResponseBody> body{};

  DescribeVpcAccessesResponse() {}

  explicit DescribeVpcAccessesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeVpcAccessesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeVpcAccessesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeVpcAccessesResponse() = default;
};
class DescribeZonesRequest : public Darabonba::Model {
public:
  shared_ptr<string> language{};
  shared_ptr<string> securityToken{};

  DescribeZonesRequest() {}

  explicit DescribeZonesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (language) {
      res["Language"] = boost::any(*language);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Language") != m.end() && !m["Language"].empty()) {
      language = make_shared<string>(boost::any_cast<string>(m["Language"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~DescribeZonesRequest() = default;
};
class DescribeZonesResponseBodyZonesZone : public Darabonba::Model {
public:
  shared_ptr<string> localName{};
  shared_ptr<string> zoneId{};

  DescribeZonesResponseBodyZonesZone() {}

  explicit DescribeZonesResponseBodyZonesZone(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (localName) {
      res["LocalName"] = boost::any(*localName);
    }
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LocalName") != m.end() && !m["LocalName"].empty()) {
      localName = make_shared<string>(boost::any_cast<string>(m["LocalName"]));
    }
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["ZoneId"]));
    }
  }


  virtual ~DescribeZonesResponseBodyZonesZone() = default;
};
class DescribeZonesResponseBodyZones : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeZonesResponseBodyZonesZone>> zone{};

  DescribeZonesResponseBodyZones() {}

  explicit DescribeZonesResponseBodyZones(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (zone) {
      vector<boost::any> temp1;
      for(auto item1:*zone){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Zone"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Zone") != m.end() && !m["Zone"].empty()) {
      if (typeid(vector<boost::any>) == m["Zone"].type()) {
        vector<DescribeZonesResponseBodyZonesZone> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Zone"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeZonesResponseBodyZonesZone model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        zone = make_shared<vector<DescribeZonesResponseBodyZonesZone>>(expect1);
      }
    }
  }


  virtual ~DescribeZonesResponseBodyZones() = default;
};
class DescribeZonesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeZonesResponseBodyZones> zones{};

  DescribeZonesResponseBody() {}

  explicit DescribeZonesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (zones) {
      res["Zones"] = zones ? boost::any(zones->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Zones") != m.end() && !m["Zones"].empty()) {
      if (typeid(map<string, boost::any>) == m["Zones"].type()) {
        DescribeZonesResponseBodyZones model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Zones"]));
        zones = make_shared<DescribeZonesResponseBodyZones>(model1);
      }
    }
  }


  virtual ~DescribeZonesResponseBody() = default;
};
class DescribeZonesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeZonesResponseBody> body{};

  DescribeZonesResponse() {}

  explicit DescribeZonesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeZonesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeZonesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeZonesResponse() = default;
};
class DetachApiProductRequestApis : public Darabonba::Model {
public:
  shared_ptr<string> apiId{};
  shared_ptr<string> stageName{};

  DetachApiProductRequestApis() {}

  explicit DetachApiProductRequestApis(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiId) {
      res["ApiId"] = boost::any(*apiId);
    }
    if (stageName) {
      res["StageName"] = boost::any(*stageName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiId") != m.end() && !m["ApiId"].empty()) {
      apiId = make_shared<string>(boost::any_cast<string>(m["ApiId"]));
    }
    if (m.find("StageName") != m.end() && !m["StageName"].empty()) {
      stageName = make_shared<string>(boost::any_cast<string>(m["StageName"]));
    }
  }


  virtual ~DetachApiProductRequestApis() = default;
};
class DetachApiProductRequest : public Darabonba::Model {
public:
  shared_ptr<string> apiProductId{};
  shared_ptr<vector<DetachApiProductRequestApis>> apis{};
  shared_ptr<string> securityToken{};

  DetachApiProductRequest() {}

  explicit DetachApiProductRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiProductId) {
      res["ApiProductId"] = boost::any(*apiProductId);
    }
    if (apis) {
      vector<boost::any> temp1;
      for(auto item1:*apis){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Apis"] = boost::any(temp1);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiProductId") != m.end() && !m["ApiProductId"].empty()) {
      apiProductId = make_shared<string>(boost::any_cast<string>(m["ApiProductId"]));
    }
    if (m.find("Apis") != m.end() && !m["Apis"].empty()) {
      if (typeid(vector<boost::any>) == m["Apis"].type()) {
        vector<DetachApiProductRequestApis> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Apis"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DetachApiProductRequestApis model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        apis = make_shared<vector<DetachApiProductRequestApis>>(expect1);
      }
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~DetachApiProductRequest() = default;
};
class DetachApiProductResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DetachApiProductResponseBody() {}

  explicit DetachApiProductResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DetachApiProductResponseBody() = default;
};
class DetachApiProductResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DetachApiProductResponseBody> body{};

  DetachApiProductResponse() {}

  explicit DetachApiProductResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DetachApiProductResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DetachApiProductResponseBody>(model1);
      }
    }
  }


  virtual ~DetachApiProductResponse() = default;
};
class DetachPluginRequest : public Darabonba::Model {
public:
  shared_ptr<string> apiId{};
  shared_ptr<string> groupId{};
  shared_ptr<string> pluginId{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> stageName{};

  DetachPluginRequest() {}

  explicit DetachPluginRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiId) {
      res["ApiId"] = boost::any(*apiId);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (pluginId) {
      res["PluginId"] = boost::any(*pluginId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (stageName) {
      res["StageName"] = boost::any(*stageName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiId") != m.end() && !m["ApiId"].empty()) {
      apiId = make_shared<string>(boost::any_cast<string>(m["ApiId"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("PluginId") != m.end() && !m["PluginId"].empty()) {
      pluginId = make_shared<string>(boost::any_cast<string>(m["PluginId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("StageName") != m.end() && !m["StageName"].empty()) {
      stageName = make_shared<string>(boost::any_cast<string>(m["StageName"]));
    }
  }


  virtual ~DetachPluginRequest() = default;
};
class DetachPluginResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DetachPluginResponseBody() {}

  explicit DetachPluginResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DetachPluginResponseBody() = default;
};
class DetachPluginResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DetachPluginResponseBody> body{};

  DetachPluginResponse() {}

  explicit DetachPluginResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DetachPluginResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DetachPluginResponseBody>(model1);
      }
    }
  }


  virtual ~DetachPluginResponse() = default;
};
class DisableInstanceAccessControlRequest : public Darabonba::Model {
public:
  shared_ptr<string> aclId{};
  shared_ptr<string> addressIPVersion{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> securityToken{};

  DisableInstanceAccessControlRequest() {}

  explicit DisableInstanceAccessControlRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aclId) {
      res["AclId"] = boost::any(*aclId);
    }
    if (addressIPVersion) {
      res["AddressIPVersion"] = boost::any(*addressIPVersion);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AclId") != m.end() && !m["AclId"].empty()) {
      aclId = make_shared<string>(boost::any_cast<string>(m["AclId"]));
    }
    if (m.find("AddressIPVersion") != m.end() && !m["AddressIPVersion"].empty()) {
      addressIPVersion = make_shared<string>(boost::any_cast<string>(m["AddressIPVersion"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~DisableInstanceAccessControlRequest() = default;
};
class DisableInstanceAccessControlResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DisableInstanceAccessControlResponseBody() {}

  explicit DisableInstanceAccessControlResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DisableInstanceAccessControlResponseBody() = default;
};
class DisableInstanceAccessControlResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DisableInstanceAccessControlResponseBody> body{};

  DisableInstanceAccessControlResponse() {}

  explicit DisableInstanceAccessControlResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DisableInstanceAccessControlResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DisableInstanceAccessControlResponseBody>(model1);
      }
    }
  }


  virtual ~DisableInstanceAccessControlResponse() = default;
};
class DryRunSwaggerRequest : public Darabonba::Model {
public:
  shared_ptr<string> data{};
  shared_ptr<string> dataFormat{};
  shared_ptr<map<string, boost::any>> globalCondition{};
  shared_ptr<string> groupId{};
  shared_ptr<bool> overwrite{};
  shared_ptr<string> securityToken{};

  DryRunSwaggerRequest() {}

  explicit DryRunSwaggerRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (dataFormat) {
      res["DataFormat"] = boost::any(*dataFormat);
    }
    if (globalCondition) {
      res["GlobalCondition"] = boost::any(*globalCondition);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (overwrite) {
      res["Overwrite"] = boost::any(*overwrite);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("DataFormat") != m.end() && !m["DataFormat"].empty()) {
      dataFormat = make_shared<string>(boost::any_cast<string>(m["DataFormat"]));
    }
    if (m.find("GlobalCondition") != m.end() && !m["GlobalCondition"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["GlobalCondition"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      globalCondition = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("Overwrite") != m.end() && !m["Overwrite"].empty()) {
      overwrite = make_shared<bool>(boost::any_cast<bool>(m["Overwrite"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~DryRunSwaggerRequest() = default;
};
class DryRunSwaggerShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> data{};
  shared_ptr<string> dataFormat{};
  shared_ptr<string> globalConditionShrink{};
  shared_ptr<string> groupId{};
  shared_ptr<bool> overwrite{};
  shared_ptr<string> securityToken{};

  DryRunSwaggerShrinkRequest() {}

  explicit DryRunSwaggerShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (dataFormat) {
      res["DataFormat"] = boost::any(*dataFormat);
    }
    if (globalConditionShrink) {
      res["GlobalCondition"] = boost::any(*globalConditionShrink);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (overwrite) {
      res["Overwrite"] = boost::any(*overwrite);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("DataFormat") != m.end() && !m["DataFormat"].empty()) {
      dataFormat = make_shared<string>(boost::any_cast<string>(m["DataFormat"]));
    }
    if (m.find("GlobalCondition") != m.end() && !m["GlobalCondition"].empty()) {
      globalConditionShrink = make_shared<string>(boost::any_cast<string>(m["GlobalCondition"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("Overwrite") != m.end() && !m["Overwrite"].empty()) {
      overwrite = make_shared<bool>(boost::any_cast<bool>(m["Overwrite"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~DryRunSwaggerShrinkRequest() = default;
};
class DryRunSwaggerResponseBodyFailedApiImportSwaggerFailed : public Darabonba::Model {
public:
  shared_ptr<string> errorMsg{};
  shared_ptr<string> httpMethod{};
  shared_ptr<string> path{};

  DryRunSwaggerResponseBodyFailedApiImportSwaggerFailed() {}

  explicit DryRunSwaggerResponseBodyFailedApiImportSwaggerFailed(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorMsg) {
      res["ErrorMsg"] = boost::any(*errorMsg);
    }
    if (httpMethod) {
      res["HttpMethod"] = boost::any(*httpMethod);
    }
    if (path) {
      res["Path"] = boost::any(*path);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorMsg") != m.end() && !m["ErrorMsg"].empty()) {
      errorMsg = make_shared<string>(boost::any_cast<string>(m["ErrorMsg"]));
    }
    if (m.find("HttpMethod") != m.end() && !m["HttpMethod"].empty()) {
      httpMethod = make_shared<string>(boost::any_cast<string>(m["HttpMethod"]));
    }
    if (m.find("Path") != m.end() && !m["Path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["Path"]));
    }
  }


  virtual ~DryRunSwaggerResponseBodyFailedApiImportSwaggerFailed() = default;
};
class DryRunSwaggerResponseBodyFailed : public Darabonba::Model {
public:
  shared_ptr<vector<DryRunSwaggerResponseBodyFailedApiImportSwaggerFailed>> apiImportSwaggerFailed{};

  DryRunSwaggerResponseBodyFailed() {}

  explicit DryRunSwaggerResponseBodyFailed(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiImportSwaggerFailed) {
      vector<boost::any> temp1;
      for(auto item1:*apiImportSwaggerFailed){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ApiImportSwaggerFailed"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiImportSwaggerFailed") != m.end() && !m["ApiImportSwaggerFailed"].empty()) {
      if (typeid(vector<boost::any>) == m["ApiImportSwaggerFailed"].type()) {
        vector<DryRunSwaggerResponseBodyFailedApiImportSwaggerFailed> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ApiImportSwaggerFailed"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DryRunSwaggerResponseBodyFailedApiImportSwaggerFailed model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        apiImportSwaggerFailed = make_shared<vector<DryRunSwaggerResponseBodyFailedApiImportSwaggerFailed>>(expect1);
      }
    }
  }


  virtual ~DryRunSwaggerResponseBodyFailed() = default;
};
class DryRunSwaggerResponseBodyModelFailedApiImportModelFailed : public Darabonba::Model {
public:
  shared_ptr<string> errorMsg{};
  shared_ptr<string> groupId{};
  shared_ptr<string> modelName{};

  DryRunSwaggerResponseBodyModelFailedApiImportModelFailed() {}

  explicit DryRunSwaggerResponseBodyModelFailedApiImportModelFailed(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorMsg) {
      res["ErrorMsg"] = boost::any(*errorMsg);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (modelName) {
      res["ModelName"] = boost::any(*modelName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorMsg") != m.end() && !m["ErrorMsg"].empty()) {
      errorMsg = make_shared<string>(boost::any_cast<string>(m["ErrorMsg"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("ModelName") != m.end() && !m["ModelName"].empty()) {
      modelName = make_shared<string>(boost::any_cast<string>(m["ModelName"]));
    }
  }


  virtual ~DryRunSwaggerResponseBodyModelFailedApiImportModelFailed() = default;
};
class DryRunSwaggerResponseBodyModelFailed : public Darabonba::Model {
public:
  shared_ptr<vector<DryRunSwaggerResponseBodyModelFailedApiImportModelFailed>> apiImportModelFailed{};

  DryRunSwaggerResponseBodyModelFailed() {}

  explicit DryRunSwaggerResponseBodyModelFailed(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiImportModelFailed) {
      vector<boost::any> temp1;
      for(auto item1:*apiImportModelFailed){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ApiImportModelFailed"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiImportModelFailed") != m.end() && !m["ApiImportModelFailed"].empty()) {
      if (typeid(vector<boost::any>) == m["ApiImportModelFailed"].type()) {
        vector<DryRunSwaggerResponseBodyModelFailedApiImportModelFailed> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ApiImportModelFailed"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DryRunSwaggerResponseBodyModelFailedApiImportModelFailed model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        apiImportModelFailed = make_shared<vector<DryRunSwaggerResponseBodyModelFailedApiImportModelFailed>>(expect1);
      }
    }
  }


  virtual ~DryRunSwaggerResponseBodyModelFailed() = default;
};
class DryRunSwaggerResponseBodyModelSuccessApiImportModelSuccess : public Darabonba::Model {
public:
  shared_ptr<string> groupId{};
  shared_ptr<string> modelName{};
  shared_ptr<string> modelOperation{};
  shared_ptr<string> modelUid{};

  DryRunSwaggerResponseBodyModelSuccessApiImportModelSuccess() {}

  explicit DryRunSwaggerResponseBodyModelSuccessApiImportModelSuccess(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (modelName) {
      res["ModelName"] = boost::any(*modelName);
    }
    if (modelOperation) {
      res["ModelOperation"] = boost::any(*modelOperation);
    }
    if (modelUid) {
      res["ModelUid"] = boost::any(*modelUid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("ModelName") != m.end() && !m["ModelName"].empty()) {
      modelName = make_shared<string>(boost::any_cast<string>(m["ModelName"]));
    }
    if (m.find("ModelOperation") != m.end() && !m["ModelOperation"].empty()) {
      modelOperation = make_shared<string>(boost::any_cast<string>(m["ModelOperation"]));
    }
    if (m.find("ModelUid") != m.end() && !m["ModelUid"].empty()) {
      modelUid = make_shared<string>(boost::any_cast<string>(m["ModelUid"]));
    }
  }


  virtual ~DryRunSwaggerResponseBodyModelSuccessApiImportModelSuccess() = default;
};
class DryRunSwaggerResponseBodyModelSuccess : public Darabonba::Model {
public:
  shared_ptr<vector<DryRunSwaggerResponseBodyModelSuccessApiImportModelSuccess>> apiImportModelSuccess{};

  DryRunSwaggerResponseBodyModelSuccess() {}

  explicit DryRunSwaggerResponseBodyModelSuccess(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiImportModelSuccess) {
      vector<boost::any> temp1;
      for(auto item1:*apiImportModelSuccess){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ApiImportModelSuccess"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiImportModelSuccess") != m.end() && !m["ApiImportModelSuccess"].empty()) {
      if (typeid(vector<boost::any>) == m["ApiImportModelSuccess"].type()) {
        vector<DryRunSwaggerResponseBodyModelSuccessApiImportModelSuccess> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ApiImportModelSuccess"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DryRunSwaggerResponseBodyModelSuccessApiImportModelSuccess model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        apiImportModelSuccess = make_shared<vector<DryRunSwaggerResponseBodyModelSuccessApiImportModelSuccess>>(expect1);
      }
    }
  }


  virtual ~DryRunSwaggerResponseBodyModelSuccess() = default;
};
class DryRunSwaggerResponseBodySuccessApiDryRunSwaggerSuccess : public Darabonba::Model {
public:
  shared_ptr<string> apiOperation{};
  shared_ptr<string> apiSwagger{};
  shared_ptr<string> apiUid{};
  shared_ptr<string> httpMethod{};
  shared_ptr<string> path{};

  DryRunSwaggerResponseBodySuccessApiDryRunSwaggerSuccess() {}

  explicit DryRunSwaggerResponseBodySuccessApiDryRunSwaggerSuccess(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiOperation) {
      res["ApiOperation"] = boost::any(*apiOperation);
    }
    if (apiSwagger) {
      res["ApiSwagger"] = boost::any(*apiSwagger);
    }
    if (apiUid) {
      res["ApiUid"] = boost::any(*apiUid);
    }
    if (httpMethod) {
      res["HttpMethod"] = boost::any(*httpMethod);
    }
    if (path) {
      res["Path"] = boost::any(*path);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiOperation") != m.end() && !m["ApiOperation"].empty()) {
      apiOperation = make_shared<string>(boost::any_cast<string>(m["ApiOperation"]));
    }
    if (m.find("ApiSwagger") != m.end() && !m["ApiSwagger"].empty()) {
      apiSwagger = make_shared<string>(boost::any_cast<string>(m["ApiSwagger"]));
    }
    if (m.find("ApiUid") != m.end() && !m["ApiUid"].empty()) {
      apiUid = make_shared<string>(boost::any_cast<string>(m["ApiUid"]));
    }
    if (m.find("HttpMethod") != m.end() && !m["HttpMethod"].empty()) {
      httpMethod = make_shared<string>(boost::any_cast<string>(m["HttpMethod"]));
    }
    if (m.find("Path") != m.end() && !m["Path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["Path"]));
    }
  }


  virtual ~DryRunSwaggerResponseBodySuccessApiDryRunSwaggerSuccess() = default;
};
class DryRunSwaggerResponseBodySuccess : public Darabonba::Model {
public:
  shared_ptr<vector<DryRunSwaggerResponseBodySuccessApiDryRunSwaggerSuccess>> apiDryRunSwaggerSuccess{};

  DryRunSwaggerResponseBodySuccess() {}

  explicit DryRunSwaggerResponseBodySuccess(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiDryRunSwaggerSuccess) {
      vector<boost::any> temp1;
      for(auto item1:*apiDryRunSwaggerSuccess){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ApiDryRunSwaggerSuccess"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiDryRunSwaggerSuccess") != m.end() && !m["ApiDryRunSwaggerSuccess"].empty()) {
      if (typeid(vector<boost::any>) == m["ApiDryRunSwaggerSuccess"].type()) {
        vector<DryRunSwaggerResponseBodySuccessApiDryRunSwaggerSuccess> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ApiDryRunSwaggerSuccess"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DryRunSwaggerResponseBodySuccessApiDryRunSwaggerSuccess model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        apiDryRunSwaggerSuccess = make_shared<vector<DryRunSwaggerResponseBodySuccessApiDryRunSwaggerSuccess>>(expect1);
      }
    }
  }


  virtual ~DryRunSwaggerResponseBodySuccess() = default;
};
class DryRunSwaggerResponseBody : public Darabonba::Model {
public:
  shared_ptr<DryRunSwaggerResponseBodyFailed> failed{};
  shared_ptr<string> globalCondition{};
  shared_ptr<DryRunSwaggerResponseBodyModelFailed> modelFailed{};
  shared_ptr<DryRunSwaggerResponseBodyModelSuccess> modelSuccess{};
  shared_ptr<string> requestId{};
  shared_ptr<DryRunSwaggerResponseBodySuccess> success{};

  DryRunSwaggerResponseBody() {}

  explicit DryRunSwaggerResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (failed) {
      res["Failed"] = failed ? boost::any(failed->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (globalCondition) {
      res["GlobalCondition"] = boost::any(*globalCondition);
    }
    if (modelFailed) {
      res["ModelFailed"] = modelFailed ? boost::any(modelFailed->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (modelSuccess) {
      res["ModelSuccess"] = modelSuccess ? boost::any(modelSuccess->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = success ? boost::any(success->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Failed") != m.end() && !m["Failed"].empty()) {
      if (typeid(map<string, boost::any>) == m["Failed"].type()) {
        DryRunSwaggerResponseBodyFailed model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Failed"]));
        failed = make_shared<DryRunSwaggerResponseBodyFailed>(model1);
      }
    }
    if (m.find("GlobalCondition") != m.end() && !m["GlobalCondition"].empty()) {
      globalCondition = make_shared<string>(boost::any_cast<string>(m["GlobalCondition"]));
    }
    if (m.find("ModelFailed") != m.end() && !m["ModelFailed"].empty()) {
      if (typeid(map<string, boost::any>) == m["ModelFailed"].type()) {
        DryRunSwaggerResponseBodyModelFailed model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ModelFailed"]));
        modelFailed = make_shared<DryRunSwaggerResponseBodyModelFailed>(model1);
      }
    }
    if (m.find("ModelSuccess") != m.end() && !m["ModelSuccess"].empty()) {
      if (typeid(map<string, boost::any>) == m["ModelSuccess"].type()) {
        DryRunSwaggerResponseBodyModelSuccess model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ModelSuccess"]));
        modelSuccess = make_shared<DryRunSwaggerResponseBodyModelSuccess>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      if (typeid(map<string, boost::any>) == m["Success"].type()) {
        DryRunSwaggerResponseBodySuccess model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Success"]));
        success = make_shared<DryRunSwaggerResponseBodySuccess>(model1);
      }
    }
  }


  virtual ~DryRunSwaggerResponseBody() = default;
};
class DryRunSwaggerResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DryRunSwaggerResponseBody> body{};

  DryRunSwaggerResponse() {}

  explicit DryRunSwaggerResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DryRunSwaggerResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DryRunSwaggerResponseBody>(model1);
      }
    }
  }


  virtual ~DryRunSwaggerResponse() = default;
};
class EnableInstanceAccessControlRequest : public Darabonba::Model {
public:
  shared_ptr<string> aclId{};
  shared_ptr<string> aclType{};
  shared_ptr<string> addressIPVersion{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> securityToken{};

  EnableInstanceAccessControlRequest() {}

  explicit EnableInstanceAccessControlRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aclId) {
      res["AclId"] = boost::any(*aclId);
    }
    if (aclType) {
      res["AclType"] = boost::any(*aclType);
    }
    if (addressIPVersion) {
      res["AddressIPVersion"] = boost::any(*addressIPVersion);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AclId") != m.end() && !m["AclId"].empty()) {
      aclId = make_shared<string>(boost::any_cast<string>(m["AclId"]));
    }
    if (m.find("AclType") != m.end() && !m["AclType"].empty()) {
      aclType = make_shared<string>(boost::any_cast<string>(m["AclType"]));
    }
    if (m.find("AddressIPVersion") != m.end() && !m["AddressIPVersion"].empty()) {
      addressIPVersion = make_shared<string>(boost::any_cast<string>(m["AddressIPVersion"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~EnableInstanceAccessControlRequest() = default;
};
class EnableInstanceAccessControlResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  EnableInstanceAccessControlResponseBody() {}

  explicit EnableInstanceAccessControlResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~EnableInstanceAccessControlResponseBody() = default;
};
class EnableInstanceAccessControlResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<EnableInstanceAccessControlResponseBody> body{};

  EnableInstanceAccessControlResponse() {}

  explicit EnableInstanceAccessControlResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        EnableInstanceAccessControlResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<EnableInstanceAccessControlResponseBody>(model1);
      }
    }
  }


  virtual ~EnableInstanceAccessControlResponse() = default;
};
class ImportOASRequest : public Darabonba::Model {
public:
  shared_ptr<string> authType{};
  shared_ptr<string> backendName{};
  shared_ptr<string> data{};
  shared_ptr<string> groupId{};
  shared_ptr<bool> ignoreWarning{};
  shared_ptr<string> OASVersion{};
  shared_ptr<bool> overwrite{};
  shared_ptr<string> requestMode{};
  shared_ptr<string> securityToken{};
  shared_ptr<bool> skipDryRun{};

  ImportOASRequest() {}

  explicit ImportOASRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (authType) {
      res["AuthType"] = boost::any(*authType);
    }
    if (backendName) {
      res["BackendName"] = boost::any(*backendName);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (ignoreWarning) {
      res["IgnoreWarning"] = boost::any(*ignoreWarning);
    }
    if (OASVersion) {
      res["OASVersion"] = boost::any(*OASVersion);
    }
    if (overwrite) {
      res["Overwrite"] = boost::any(*overwrite);
    }
    if (requestMode) {
      res["RequestMode"] = boost::any(*requestMode);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (skipDryRun) {
      res["SkipDryRun"] = boost::any(*skipDryRun);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AuthType") != m.end() && !m["AuthType"].empty()) {
      authType = make_shared<string>(boost::any_cast<string>(m["AuthType"]));
    }
    if (m.find("BackendName") != m.end() && !m["BackendName"].empty()) {
      backendName = make_shared<string>(boost::any_cast<string>(m["BackendName"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("IgnoreWarning") != m.end() && !m["IgnoreWarning"].empty()) {
      ignoreWarning = make_shared<bool>(boost::any_cast<bool>(m["IgnoreWarning"]));
    }
    if (m.find("OASVersion") != m.end() && !m["OASVersion"].empty()) {
      OASVersion = make_shared<string>(boost::any_cast<string>(m["OASVersion"]));
    }
    if (m.find("Overwrite") != m.end() && !m["Overwrite"].empty()) {
      overwrite = make_shared<bool>(boost::any_cast<bool>(m["Overwrite"]));
    }
    if (m.find("RequestMode") != m.end() && !m["RequestMode"].empty()) {
      requestMode = make_shared<string>(boost::any_cast<string>(m["RequestMode"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("SkipDryRun") != m.end() && !m["SkipDryRun"].empty()) {
      skipDryRun = make_shared<bool>(boost::any_cast<bool>(m["SkipDryRun"]));
    }
  }


  virtual ~ImportOASRequest() = default;
};
class ImportOASResponseBodyErrorMessages : public Darabonba::Model {
public:
  shared_ptr<vector<string>> errorMessage{};

  ImportOASResponseBodyErrorMessages() {}

  explicit ImportOASResponseBodyErrorMessages(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ErrorMessage"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ErrorMessage"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      errorMessage = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ImportOASResponseBodyErrorMessages() = default;
};
class ImportOASResponseBodyFailedApisFailedApi : public Darabonba::Model {
public:
  shared_ptr<string> errorMsg{};
  shared_ptr<string> httpMethod{};
  shared_ptr<string> path{};

  ImportOASResponseBodyFailedApisFailedApi() {}

  explicit ImportOASResponseBodyFailedApisFailedApi(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorMsg) {
      res["ErrorMsg"] = boost::any(*errorMsg);
    }
    if (httpMethod) {
      res["HttpMethod"] = boost::any(*httpMethod);
    }
    if (path) {
      res["Path"] = boost::any(*path);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorMsg") != m.end() && !m["ErrorMsg"].empty()) {
      errorMsg = make_shared<string>(boost::any_cast<string>(m["ErrorMsg"]));
    }
    if (m.find("HttpMethod") != m.end() && !m["HttpMethod"].empty()) {
      httpMethod = make_shared<string>(boost::any_cast<string>(m["HttpMethod"]));
    }
    if (m.find("Path") != m.end() && !m["Path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["Path"]));
    }
  }


  virtual ~ImportOASResponseBodyFailedApisFailedApi() = default;
};
class ImportOASResponseBodyFailedApis : public Darabonba::Model {
public:
  shared_ptr<vector<ImportOASResponseBodyFailedApisFailedApi>> failedApi{};

  ImportOASResponseBodyFailedApis() {}

  explicit ImportOASResponseBodyFailedApis(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (failedApi) {
      vector<boost::any> temp1;
      for(auto item1:*failedApi){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["FailedApi"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FailedApi") != m.end() && !m["FailedApi"].empty()) {
      if (typeid(vector<boost::any>) == m["FailedApi"].type()) {
        vector<ImportOASResponseBodyFailedApisFailedApi> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["FailedApi"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ImportOASResponseBodyFailedApisFailedApi model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        failedApi = make_shared<vector<ImportOASResponseBodyFailedApisFailedApi>>(expect1);
      }
    }
  }


  virtual ~ImportOASResponseBodyFailedApis() = default;
};
class ImportOASResponseBodyFailedModelsFailedModel : public Darabonba::Model {
public:
  shared_ptr<string> errorMsg{};
  shared_ptr<string> groupId{};
  shared_ptr<string> modelName{};

  ImportOASResponseBodyFailedModelsFailedModel() {}

  explicit ImportOASResponseBodyFailedModelsFailedModel(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorMsg) {
      res["ErrorMsg"] = boost::any(*errorMsg);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (modelName) {
      res["ModelName"] = boost::any(*modelName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorMsg") != m.end() && !m["ErrorMsg"].empty()) {
      errorMsg = make_shared<string>(boost::any_cast<string>(m["ErrorMsg"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("ModelName") != m.end() && !m["ModelName"].empty()) {
      modelName = make_shared<string>(boost::any_cast<string>(m["ModelName"]));
    }
  }


  virtual ~ImportOASResponseBodyFailedModelsFailedModel() = default;
};
class ImportOASResponseBodyFailedModels : public Darabonba::Model {
public:
  shared_ptr<vector<ImportOASResponseBodyFailedModelsFailedModel>> failedModel{};

  ImportOASResponseBodyFailedModels() {}

  explicit ImportOASResponseBodyFailedModels(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (failedModel) {
      vector<boost::any> temp1;
      for(auto item1:*failedModel){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["FailedModel"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FailedModel") != m.end() && !m["FailedModel"].empty()) {
      if (typeid(vector<boost::any>) == m["FailedModel"].type()) {
        vector<ImportOASResponseBodyFailedModelsFailedModel> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["FailedModel"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ImportOASResponseBodyFailedModelsFailedModel model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        failedModel = make_shared<vector<ImportOASResponseBodyFailedModelsFailedModel>>(expect1);
      }
    }
  }


  virtual ~ImportOASResponseBodyFailedModels() = default;
};
class ImportOASResponseBodySuccessApisSuccessApi : public Darabonba::Model {
public:
  shared_ptr<string> apiId{};
  shared_ptr<string> apiOperation{};
  shared_ptr<string> httpMethod{};
  shared_ptr<string> path{};

  ImportOASResponseBodySuccessApisSuccessApi() {}

  explicit ImportOASResponseBodySuccessApisSuccessApi(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiId) {
      res["ApiId"] = boost::any(*apiId);
    }
    if (apiOperation) {
      res["ApiOperation"] = boost::any(*apiOperation);
    }
    if (httpMethod) {
      res["HttpMethod"] = boost::any(*httpMethod);
    }
    if (path) {
      res["Path"] = boost::any(*path);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiId") != m.end() && !m["ApiId"].empty()) {
      apiId = make_shared<string>(boost::any_cast<string>(m["ApiId"]));
    }
    if (m.find("ApiOperation") != m.end() && !m["ApiOperation"].empty()) {
      apiOperation = make_shared<string>(boost::any_cast<string>(m["ApiOperation"]));
    }
    if (m.find("HttpMethod") != m.end() && !m["HttpMethod"].empty()) {
      httpMethod = make_shared<string>(boost::any_cast<string>(m["HttpMethod"]));
    }
    if (m.find("Path") != m.end() && !m["Path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["Path"]));
    }
  }


  virtual ~ImportOASResponseBodySuccessApisSuccessApi() = default;
};
class ImportOASResponseBodySuccessApis : public Darabonba::Model {
public:
  shared_ptr<vector<ImportOASResponseBodySuccessApisSuccessApi>> successApi{};

  ImportOASResponseBodySuccessApis() {}

  explicit ImportOASResponseBodySuccessApis(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (successApi) {
      vector<boost::any> temp1;
      for(auto item1:*successApi){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SuccessApi"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SuccessApi") != m.end() && !m["SuccessApi"].empty()) {
      if (typeid(vector<boost::any>) == m["SuccessApi"].type()) {
        vector<ImportOASResponseBodySuccessApisSuccessApi> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SuccessApi"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ImportOASResponseBodySuccessApisSuccessApi model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        successApi = make_shared<vector<ImportOASResponseBodySuccessApisSuccessApi>>(expect1);
      }
    }
  }


  virtual ~ImportOASResponseBodySuccessApis() = default;
};
class ImportOASResponseBodySuccessModelsSuccessModel : public Darabonba::Model {
public:
  shared_ptr<string> groupId{};
  shared_ptr<string> modelName{};
  shared_ptr<string> modelOperation{};
  shared_ptr<string> modelUid{};

  ImportOASResponseBodySuccessModelsSuccessModel() {}

  explicit ImportOASResponseBodySuccessModelsSuccessModel(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (modelName) {
      res["ModelName"] = boost::any(*modelName);
    }
    if (modelOperation) {
      res["ModelOperation"] = boost::any(*modelOperation);
    }
    if (modelUid) {
      res["ModelUid"] = boost::any(*modelUid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("ModelName") != m.end() && !m["ModelName"].empty()) {
      modelName = make_shared<string>(boost::any_cast<string>(m["ModelName"]));
    }
    if (m.find("ModelOperation") != m.end() && !m["ModelOperation"].empty()) {
      modelOperation = make_shared<string>(boost::any_cast<string>(m["ModelOperation"]));
    }
    if (m.find("ModelUid") != m.end() && !m["ModelUid"].empty()) {
      modelUid = make_shared<string>(boost::any_cast<string>(m["ModelUid"]));
    }
  }


  virtual ~ImportOASResponseBodySuccessModelsSuccessModel() = default;
};
class ImportOASResponseBodySuccessModels : public Darabonba::Model {
public:
  shared_ptr<vector<ImportOASResponseBodySuccessModelsSuccessModel>> successModel{};

  ImportOASResponseBodySuccessModels() {}

  explicit ImportOASResponseBodySuccessModels(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (successModel) {
      vector<boost::any> temp1;
      for(auto item1:*successModel){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SuccessModel"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SuccessModel") != m.end() && !m["SuccessModel"].empty()) {
      if (typeid(vector<boost::any>) == m["SuccessModel"].type()) {
        vector<ImportOASResponseBodySuccessModelsSuccessModel> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SuccessModel"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ImportOASResponseBodySuccessModelsSuccessModel model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        successModel = make_shared<vector<ImportOASResponseBodySuccessModelsSuccessModel>>(expect1);
      }
    }
  }


  virtual ~ImportOASResponseBodySuccessModels() = default;
};
class ImportOASResponseBodyWarningMessages : public Darabonba::Model {
public:
  shared_ptr<vector<string>> warningMessage{};

  ImportOASResponseBodyWarningMessages() {}

  explicit ImportOASResponseBodyWarningMessages(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (warningMessage) {
      res["WarningMessage"] = boost::any(*warningMessage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("WarningMessage") != m.end() && !m["WarningMessage"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["WarningMessage"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["WarningMessage"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      warningMessage = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ImportOASResponseBodyWarningMessages() = default;
};
class ImportOASResponseBody : public Darabonba::Model {
public:
  shared_ptr<ImportOASResponseBodyErrorMessages> errorMessages{};
  shared_ptr<ImportOASResponseBodyFailedApis> failedApis{};
  shared_ptr<ImportOASResponseBodyFailedModels> failedModels{};
  shared_ptr<string> operationId{};
  shared_ptr<string> requestId{};
  shared_ptr<ImportOASResponseBodySuccessApis> successApis{};
  shared_ptr<ImportOASResponseBodySuccessModels> successModels{};
  shared_ptr<ImportOASResponseBodyWarningMessages> warningMessages{};

  ImportOASResponseBody() {}

  explicit ImportOASResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorMessages) {
      res["ErrorMessages"] = errorMessages ? boost::any(errorMessages->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (failedApis) {
      res["FailedApis"] = failedApis ? boost::any(failedApis->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (failedModels) {
      res["FailedModels"] = failedModels ? boost::any(failedModels->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (operationId) {
      res["OperationId"] = boost::any(*operationId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (successApis) {
      res["SuccessApis"] = successApis ? boost::any(successApis->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (successModels) {
      res["SuccessModels"] = successModels ? boost::any(successModels->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (warningMessages) {
      res["WarningMessages"] = warningMessages ? boost::any(warningMessages->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorMessages") != m.end() && !m["ErrorMessages"].empty()) {
      if (typeid(map<string, boost::any>) == m["ErrorMessages"].type()) {
        ImportOASResponseBodyErrorMessages model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ErrorMessages"]));
        errorMessages = make_shared<ImportOASResponseBodyErrorMessages>(model1);
      }
    }
    if (m.find("FailedApis") != m.end() && !m["FailedApis"].empty()) {
      if (typeid(map<string, boost::any>) == m["FailedApis"].type()) {
        ImportOASResponseBodyFailedApis model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FailedApis"]));
        failedApis = make_shared<ImportOASResponseBodyFailedApis>(model1);
      }
    }
    if (m.find("FailedModels") != m.end() && !m["FailedModels"].empty()) {
      if (typeid(map<string, boost::any>) == m["FailedModels"].type()) {
        ImportOASResponseBodyFailedModels model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FailedModels"]));
        failedModels = make_shared<ImportOASResponseBodyFailedModels>(model1);
      }
    }
    if (m.find("OperationId") != m.end() && !m["OperationId"].empty()) {
      operationId = make_shared<string>(boost::any_cast<string>(m["OperationId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SuccessApis") != m.end() && !m["SuccessApis"].empty()) {
      if (typeid(map<string, boost::any>) == m["SuccessApis"].type()) {
        ImportOASResponseBodySuccessApis model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SuccessApis"]));
        successApis = make_shared<ImportOASResponseBodySuccessApis>(model1);
      }
    }
    if (m.find("SuccessModels") != m.end() && !m["SuccessModels"].empty()) {
      if (typeid(map<string, boost::any>) == m["SuccessModels"].type()) {
        ImportOASResponseBodySuccessModels model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SuccessModels"]));
        successModels = make_shared<ImportOASResponseBodySuccessModels>(model1);
      }
    }
    if (m.find("WarningMessages") != m.end() && !m["WarningMessages"].empty()) {
      if (typeid(map<string, boost::any>) == m["WarningMessages"].type()) {
        ImportOASResponseBodyWarningMessages model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["WarningMessages"]));
        warningMessages = make_shared<ImportOASResponseBodyWarningMessages>(model1);
      }
    }
  }


  virtual ~ImportOASResponseBody() = default;
};
class ImportOASResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ImportOASResponseBody> body{};

  ImportOASResponse() {}

  explicit ImportOASResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ImportOASResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ImportOASResponseBody>(model1);
      }
    }
  }


  virtual ~ImportOASResponse() = default;
};
class ImportSwaggerRequest : public Darabonba::Model {
public:
  shared_ptr<string> data{};
  shared_ptr<string> dataFormat{};
  shared_ptr<bool> dryRun{};
  shared_ptr<map<string, boost::any>> globalCondition{};
  shared_ptr<string> groupId{};
  shared_ptr<bool> overwrite{};
  shared_ptr<string> securityToken{};

  ImportSwaggerRequest() {}

  explicit ImportSwaggerRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (dataFormat) {
      res["DataFormat"] = boost::any(*dataFormat);
    }
    if (dryRun) {
      res["DryRun"] = boost::any(*dryRun);
    }
    if (globalCondition) {
      res["GlobalCondition"] = boost::any(*globalCondition);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (overwrite) {
      res["Overwrite"] = boost::any(*overwrite);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("DataFormat") != m.end() && !m["DataFormat"].empty()) {
      dataFormat = make_shared<string>(boost::any_cast<string>(m["DataFormat"]));
    }
    if (m.find("DryRun") != m.end() && !m["DryRun"].empty()) {
      dryRun = make_shared<bool>(boost::any_cast<bool>(m["DryRun"]));
    }
    if (m.find("GlobalCondition") != m.end() && !m["GlobalCondition"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["GlobalCondition"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      globalCondition = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("Overwrite") != m.end() && !m["Overwrite"].empty()) {
      overwrite = make_shared<bool>(boost::any_cast<bool>(m["Overwrite"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~ImportSwaggerRequest() = default;
};
class ImportSwaggerShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> data{};
  shared_ptr<string> dataFormat{};
  shared_ptr<bool> dryRun{};
  shared_ptr<string> globalConditionShrink{};
  shared_ptr<string> groupId{};
  shared_ptr<bool> overwrite{};
  shared_ptr<string> securityToken{};

  ImportSwaggerShrinkRequest() {}

  explicit ImportSwaggerShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (dataFormat) {
      res["DataFormat"] = boost::any(*dataFormat);
    }
    if (dryRun) {
      res["DryRun"] = boost::any(*dryRun);
    }
    if (globalConditionShrink) {
      res["GlobalCondition"] = boost::any(*globalConditionShrink);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (overwrite) {
      res["Overwrite"] = boost::any(*overwrite);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("DataFormat") != m.end() && !m["DataFormat"].empty()) {
      dataFormat = make_shared<string>(boost::any_cast<string>(m["DataFormat"]));
    }
    if (m.find("DryRun") != m.end() && !m["DryRun"].empty()) {
      dryRun = make_shared<bool>(boost::any_cast<bool>(m["DryRun"]));
    }
    if (m.find("GlobalCondition") != m.end() && !m["GlobalCondition"].empty()) {
      globalConditionShrink = make_shared<string>(boost::any_cast<string>(m["GlobalCondition"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("Overwrite") != m.end() && !m["Overwrite"].empty()) {
      overwrite = make_shared<bool>(boost::any_cast<bool>(m["Overwrite"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~ImportSwaggerShrinkRequest() = default;
};
class ImportSwaggerResponseBodyFailedApiImportSwaggerFailed : public Darabonba::Model {
public:
  shared_ptr<string> errorMsg{};
  shared_ptr<string> httpMethod{};
  shared_ptr<string> path{};

  ImportSwaggerResponseBodyFailedApiImportSwaggerFailed() {}

  explicit ImportSwaggerResponseBodyFailedApiImportSwaggerFailed(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorMsg) {
      res["ErrorMsg"] = boost::any(*errorMsg);
    }
    if (httpMethod) {
      res["HttpMethod"] = boost::any(*httpMethod);
    }
    if (path) {
      res["Path"] = boost::any(*path);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorMsg") != m.end() && !m["ErrorMsg"].empty()) {
      errorMsg = make_shared<string>(boost::any_cast<string>(m["ErrorMsg"]));
    }
    if (m.find("HttpMethod") != m.end() && !m["HttpMethod"].empty()) {
      httpMethod = make_shared<string>(boost::any_cast<string>(m["HttpMethod"]));
    }
    if (m.find("Path") != m.end() && !m["Path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["Path"]));
    }
  }


  virtual ~ImportSwaggerResponseBodyFailedApiImportSwaggerFailed() = default;
};
class ImportSwaggerResponseBodyFailed : public Darabonba::Model {
public:
  shared_ptr<vector<ImportSwaggerResponseBodyFailedApiImportSwaggerFailed>> apiImportSwaggerFailed{};

  ImportSwaggerResponseBodyFailed() {}

  explicit ImportSwaggerResponseBodyFailed(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiImportSwaggerFailed) {
      vector<boost::any> temp1;
      for(auto item1:*apiImportSwaggerFailed){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ApiImportSwaggerFailed"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiImportSwaggerFailed") != m.end() && !m["ApiImportSwaggerFailed"].empty()) {
      if (typeid(vector<boost::any>) == m["ApiImportSwaggerFailed"].type()) {
        vector<ImportSwaggerResponseBodyFailedApiImportSwaggerFailed> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ApiImportSwaggerFailed"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ImportSwaggerResponseBodyFailedApiImportSwaggerFailed model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        apiImportSwaggerFailed = make_shared<vector<ImportSwaggerResponseBodyFailedApiImportSwaggerFailed>>(expect1);
      }
    }
  }


  virtual ~ImportSwaggerResponseBodyFailed() = default;
};
class ImportSwaggerResponseBodyModelFailedApiImportModelFailed : public Darabonba::Model {
public:
  shared_ptr<string> errorMsg{};
  shared_ptr<string> groupId{};
  shared_ptr<string> modelName{};

  ImportSwaggerResponseBodyModelFailedApiImportModelFailed() {}

  explicit ImportSwaggerResponseBodyModelFailedApiImportModelFailed(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorMsg) {
      res["ErrorMsg"] = boost::any(*errorMsg);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (modelName) {
      res["ModelName"] = boost::any(*modelName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorMsg") != m.end() && !m["ErrorMsg"].empty()) {
      errorMsg = make_shared<string>(boost::any_cast<string>(m["ErrorMsg"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("ModelName") != m.end() && !m["ModelName"].empty()) {
      modelName = make_shared<string>(boost::any_cast<string>(m["ModelName"]));
    }
  }


  virtual ~ImportSwaggerResponseBodyModelFailedApiImportModelFailed() = default;
};
class ImportSwaggerResponseBodyModelFailed : public Darabonba::Model {
public:
  shared_ptr<vector<ImportSwaggerResponseBodyModelFailedApiImportModelFailed>> apiImportModelFailed{};

  ImportSwaggerResponseBodyModelFailed() {}

  explicit ImportSwaggerResponseBodyModelFailed(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiImportModelFailed) {
      vector<boost::any> temp1;
      for(auto item1:*apiImportModelFailed){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ApiImportModelFailed"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiImportModelFailed") != m.end() && !m["ApiImportModelFailed"].empty()) {
      if (typeid(vector<boost::any>) == m["ApiImportModelFailed"].type()) {
        vector<ImportSwaggerResponseBodyModelFailedApiImportModelFailed> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ApiImportModelFailed"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ImportSwaggerResponseBodyModelFailedApiImportModelFailed model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        apiImportModelFailed = make_shared<vector<ImportSwaggerResponseBodyModelFailedApiImportModelFailed>>(expect1);
      }
    }
  }


  virtual ~ImportSwaggerResponseBodyModelFailed() = default;
};
class ImportSwaggerResponseBodyModelSuccessApiImportModelSuccess : public Darabonba::Model {
public:
  shared_ptr<string> groupId{};
  shared_ptr<string> modelName{};
  shared_ptr<string> modelOperation{};
  shared_ptr<string> modelUid{};

  ImportSwaggerResponseBodyModelSuccessApiImportModelSuccess() {}

  explicit ImportSwaggerResponseBodyModelSuccessApiImportModelSuccess(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (modelName) {
      res["ModelName"] = boost::any(*modelName);
    }
    if (modelOperation) {
      res["ModelOperation"] = boost::any(*modelOperation);
    }
    if (modelUid) {
      res["ModelUid"] = boost::any(*modelUid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("ModelName") != m.end() && !m["ModelName"].empty()) {
      modelName = make_shared<string>(boost::any_cast<string>(m["ModelName"]));
    }
    if (m.find("ModelOperation") != m.end() && !m["ModelOperation"].empty()) {
      modelOperation = make_shared<string>(boost::any_cast<string>(m["ModelOperation"]));
    }
    if (m.find("ModelUid") != m.end() && !m["ModelUid"].empty()) {
      modelUid = make_shared<string>(boost::any_cast<string>(m["ModelUid"]));
    }
  }


  virtual ~ImportSwaggerResponseBodyModelSuccessApiImportModelSuccess() = default;
};
class ImportSwaggerResponseBodyModelSuccess : public Darabonba::Model {
public:
  shared_ptr<vector<ImportSwaggerResponseBodyModelSuccessApiImportModelSuccess>> apiImportModelSuccess{};

  ImportSwaggerResponseBodyModelSuccess() {}

  explicit ImportSwaggerResponseBodyModelSuccess(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiImportModelSuccess) {
      vector<boost::any> temp1;
      for(auto item1:*apiImportModelSuccess){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ApiImportModelSuccess"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiImportModelSuccess") != m.end() && !m["ApiImportModelSuccess"].empty()) {
      if (typeid(vector<boost::any>) == m["ApiImportModelSuccess"].type()) {
        vector<ImportSwaggerResponseBodyModelSuccessApiImportModelSuccess> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ApiImportModelSuccess"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ImportSwaggerResponseBodyModelSuccessApiImportModelSuccess model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        apiImportModelSuccess = make_shared<vector<ImportSwaggerResponseBodyModelSuccessApiImportModelSuccess>>(expect1);
      }
    }
  }


  virtual ~ImportSwaggerResponseBodyModelSuccess() = default;
};
class ImportSwaggerResponseBodySuccessApiImportSwaggerSuccess : public Darabonba::Model {
public:
  shared_ptr<string> apiOperation{};
  shared_ptr<string> apiUid{};
  shared_ptr<string> httpMethod{};
  shared_ptr<string> path{};

  ImportSwaggerResponseBodySuccessApiImportSwaggerSuccess() {}

  explicit ImportSwaggerResponseBodySuccessApiImportSwaggerSuccess(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiOperation) {
      res["ApiOperation"] = boost::any(*apiOperation);
    }
    if (apiUid) {
      res["ApiUid"] = boost::any(*apiUid);
    }
    if (httpMethod) {
      res["HttpMethod"] = boost::any(*httpMethod);
    }
    if (path) {
      res["Path"] = boost::any(*path);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiOperation") != m.end() && !m["ApiOperation"].empty()) {
      apiOperation = make_shared<string>(boost::any_cast<string>(m["ApiOperation"]));
    }
    if (m.find("ApiUid") != m.end() && !m["ApiUid"].empty()) {
      apiUid = make_shared<string>(boost::any_cast<string>(m["ApiUid"]));
    }
    if (m.find("HttpMethod") != m.end() && !m["HttpMethod"].empty()) {
      httpMethod = make_shared<string>(boost::any_cast<string>(m["HttpMethod"]));
    }
    if (m.find("Path") != m.end() && !m["Path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["Path"]));
    }
  }


  virtual ~ImportSwaggerResponseBodySuccessApiImportSwaggerSuccess() = default;
};
class ImportSwaggerResponseBodySuccess : public Darabonba::Model {
public:
  shared_ptr<vector<ImportSwaggerResponseBodySuccessApiImportSwaggerSuccess>> apiImportSwaggerSuccess{};

  ImportSwaggerResponseBodySuccess() {}

  explicit ImportSwaggerResponseBodySuccess(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiImportSwaggerSuccess) {
      vector<boost::any> temp1;
      for(auto item1:*apiImportSwaggerSuccess){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ApiImportSwaggerSuccess"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiImportSwaggerSuccess") != m.end() && !m["ApiImportSwaggerSuccess"].empty()) {
      if (typeid(vector<boost::any>) == m["ApiImportSwaggerSuccess"].type()) {
        vector<ImportSwaggerResponseBodySuccessApiImportSwaggerSuccess> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ApiImportSwaggerSuccess"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ImportSwaggerResponseBodySuccessApiImportSwaggerSuccess model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        apiImportSwaggerSuccess = make_shared<vector<ImportSwaggerResponseBodySuccessApiImportSwaggerSuccess>>(expect1);
      }
    }
  }


  virtual ~ImportSwaggerResponseBodySuccess() = default;
};
class ImportSwaggerResponseBody : public Darabonba::Model {
public:
  shared_ptr<ImportSwaggerResponseBodyFailed> failed{};
  shared_ptr<ImportSwaggerResponseBodyModelFailed> modelFailed{};
  shared_ptr<ImportSwaggerResponseBodyModelSuccess> modelSuccess{};
  shared_ptr<string> requestId{};
  shared_ptr<ImportSwaggerResponseBodySuccess> success{};

  ImportSwaggerResponseBody() {}

  explicit ImportSwaggerResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (failed) {
      res["Failed"] = failed ? boost::any(failed->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (modelFailed) {
      res["ModelFailed"] = modelFailed ? boost::any(modelFailed->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (modelSuccess) {
      res["ModelSuccess"] = modelSuccess ? boost::any(modelSuccess->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = success ? boost::any(success->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Failed") != m.end() && !m["Failed"].empty()) {
      if (typeid(map<string, boost::any>) == m["Failed"].type()) {
        ImportSwaggerResponseBodyFailed model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Failed"]));
        failed = make_shared<ImportSwaggerResponseBodyFailed>(model1);
      }
    }
    if (m.find("ModelFailed") != m.end() && !m["ModelFailed"].empty()) {
      if (typeid(map<string, boost::any>) == m["ModelFailed"].type()) {
        ImportSwaggerResponseBodyModelFailed model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ModelFailed"]));
        modelFailed = make_shared<ImportSwaggerResponseBodyModelFailed>(model1);
      }
    }
    if (m.find("ModelSuccess") != m.end() && !m["ModelSuccess"].empty()) {
      if (typeid(map<string, boost::any>) == m["ModelSuccess"].type()) {
        ImportSwaggerResponseBodyModelSuccess model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ModelSuccess"]));
        modelSuccess = make_shared<ImportSwaggerResponseBodyModelSuccess>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      if (typeid(map<string, boost::any>) == m["Success"].type()) {
        ImportSwaggerResponseBodySuccess model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Success"]));
        success = make_shared<ImportSwaggerResponseBodySuccess>(model1);
      }
    }
  }


  virtual ~ImportSwaggerResponseBody() = default;
};
class ImportSwaggerResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ImportSwaggerResponseBody> body{};

  ImportSwaggerResponse() {}

  explicit ImportSwaggerResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ImportSwaggerResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ImportSwaggerResponseBody>(model1);
      }
    }
  }


  virtual ~ImportSwaggerResponse() = default;
};
class ListTagResourcesRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  ListTagResourcesRequestTag() {}

  explicit ListTagResourcesRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~ListTagResourcesRequestTag() = default;
};
class ListTagResourcesRequest : public Darabonba::Model {
public:
  shared_ptr<string> nextToken{};
  shared_ptr<vector<string>> resourceId{};
  shared_ptr<string> resourceType{};
  shared_ptr<vector<ListTagResourcesRequestTag>> tag{};

  ListTagResourcesRequest() {}

  explicit ListTagResourcesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ResourceId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ResourceId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      resourceId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<ListTagResourcesRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListTagResourcesRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<ListTagResourcesRequestTag>>(expect1);
      }
    }
  }


  virtual ~ListTagResourcesRequest() = default;
};
class ListTagResourcesResponseBodyTagResourcesTagResource : public Darabonba::Model {
public:
  shared_ptr<string> resourceId{};
  shared_ptr<string> resourceType{};
  shared_ptr<string> tagKey{};
  shared_ptr<string> tagValue{};

  ListTagResourcesResponseBodyTagResourcesTagResource() {}

  explicit ListTagResourcesResponseBodyTagResourcesTagResource(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (tagKey) {
      res["TagKey"] = boost::any(*tagKey);
    }
    if (tagValue) {
      res["TagValue"] = boost::any(*tagValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      resourceId = make_shared<string>(boost::any_cast<string>(m["ResourceId"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("TagKey") != m.end() && !m["TagKey"].empty()) {
      tagKey = make_shared<string>(boost::any_cast<string>(m["TagKey"]));
    }
    if (m.find("TagValue") != m.end() && !m["TagValue"].empty()) {
      tagValue = make_shared<string>(boost::any_cast<string>(m["TagValue"]));
    }
  }


  virtual ~ListTagResourcesResponseBodyTagResourcesTagResource() = default;
};
class ListTagResourcesResponseBodyTagResources : public Darabonba::Model {
public:
  shared_ptr<vector<ListTagResourcesResponseBodyTagResourcesTagResource>> tagResource{};

  ListTagResourcesResponseBodyTagResources() {}

  explicit ListTagResourcesResponseBodyTagResources(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tagResource) {
      vector<boost::any> temp1;
      for(auto item1:*tagResource){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TagResource"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TagResource") != m.end() && !m["TagResource"].empty()) {
      if (typeid(vector<boost::any>) == m["TagResource"].type()) {
        vector<ListTagResourcesResponseBodyTagResourcesTagResource> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TagResource"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListTagResourcesResponseBodyTagResourcesTagResource model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tagResource = make_shared<vector<ListTagResourcesResponseBodyTagResourcesTagResource>>(expect1);
      }
    }
  }


  virtual ~ListTagResourcesResponseBodyTagResources() = default;
};
class ListTagResourcesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> nextToken{};
  shared_ptr<string> requestId{};
  shared_ptr<ListTagResourcesResponseBodyTagResources> tagResources{};

  ListTagResourcesResponseBody() {}

  explicit ListTagResourcesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (tagResources) {
      res["TagResources"] = tagResources ? boost::any(tagResources->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TagResources") != m.end() && !m["TagResources"].empty()) {
      if (typeid(map<string, boost::any>) == m["TagResources"].type()) {
        ListTagResourcesResponseBodyTagResources model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TagResources"]));
        tagResources = make_shared<ListTagResourcesResponseBodyTagResources>(model1);
      }
    }
  }


  virtual ~ListTagResourcesResponseBody() = default;
};
class ListTagResourcesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListTagResourcesResponseBody> body{};

  ListTagResourcesResponse() {}

  explicit ListTagResourcesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListTagResourcesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListTagResourcesResponseBody>(model1);
      }
    }
  }


  virtual ~ListTagResourcesResponse() = default;
};
class ModifyApiRequest : public Darabonba::Model {
public:
  shared_ptr<string> allowSignatureMethod{};
  shared_ptr<string> apiId{};
  shared_ptr<string> apiName{};
  shared_ptr<string> appCodeAuthType{};
  shared_ptr<string> authType{};
  shared_ptr<bool> backendEnable{};
  shared_ptr<string> backendId{};
  shared_ptr<string> constantParameters{};
  shared_ptr<string> description{};
  shared_ptr<bool> disableInternet{};
  shared_ptr<string> errorCodeSamples{};
  shared_ptr<string> failResultSample{};
  shared_ptr<bool> forceNonceCheck{};
  shared_ptr<string> groupId{};
  shared_ptr<string> openIdConnectConfig{};
  shared_ptr<string> requestConfig{};
  shared_ptr<string> requestParameters{};
  shared_ptr<string> resultBodyModel{};
  shared_ptr<string> resultDescriptions{};
  shared_ptr<string> resultSample{};
  shared_ptr<string> resultType{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> serviceConfig{};
  shared_ptr<string> serviceParameters{};
  shared_ptr<string> serviceParametersMap{};
  shared_ptr<string> systemParameters{};
  shared_ptr<string> visibility{};
  shared_ptr<string> webSocketApiType{};

  ModifyApiRequest() {}

  explicit ModifyApiRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (allowSignatureMethod) {
      res["AllowSignatureMethod"] = boost::any(*allowSignatureMethod);
    }
    if (apiId) {
      res["ApiId"] = boost::any(*apiId);
    }
    if (apiName) {
      res["ApiName"] = boost::any(*apiName);
    }
    if (appCodeAuthType) {
      res["AppCodeAuthType"] = boost::any(*appCodeAuthType);
    }
    if (authType) {
      res["AuthType"] = boost::any(*authType);
    }
    if (backendEnable) {
      res["BackendEnable"] = boost::any(*backendEnable);
    }
    if (backendId) {
      res["BackendId"] = boost::any(*backendId);
    }
    if (constantParameters) {
      res["ConstantParameters"] = boost::any(*constantParameters);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (disableInternet) {
      res["DisableInternet"] = boost::any(*disableInternet);
    }
    if (errorCodeSamples) {
      res["ErrorCodeSamples"] = boost::any(*errorCodeSamples);
    }
    if (failResultSample) {
      res["FailResultSample"] = boost::any(*failResultSample);
    }
    if (forceNonceCheck) {
      res["ForceNonceCheck"] = boost::any(*forceNonceCheck);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (openIdConnectConfig) {
      res["OpenIdConnectConfig"] = boost::any(*openIdConnectConfig);
    }
    if (requestConfig) {
      res["RequestConfig"] = boost::any(*requestConfig);
    }
    if (requestParameters) {
      res["RequestParameters"] = boost::any(*requestParameters);
    }
    if (resultBodyModel) {
      res["ResultBodyModel"] = boost::any(*resultBodyModel);
    }
    if (resultDescriptions) {
      res["ResultDescriptions"] = boost::any(*resultDescriptions);
    }
    if (resultSample) {
      res["ResultSample"] = boost::any(*resultSample);
    }
    if (resultType) {
      res["ResultType"] = boost::any(*resultType);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (serviceConfig) {
      res["ServiceConfig"] = boost::any(*serviceConfig);
    }
    if (serviceParameters) {
      res["ServiceParameters"] = boost::any(*serviceParameters);
    }
    if (serviceParametersMap) {
      res["ServiceParametersMap"] = boost::any(*serviceParametersMap);
    }
    if (systemParameters) {
      res["SystemParameters"] = boost::any(*systemParameters);
    }
    if (visibility) {
      res["Visibility"] = boost::any(*visibility);
    }
    if (webSocketApiType) {
      res["WebSocketApiType"] = boost::any(*webSocketApiType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AllowSignatureMethod") != m.end() && !m["AllowSignatureMethod"].empty()) {
      allowSignatureMethod = make_shared<string>(boost::any_cast<string>(m["AllowSignatureMethod"]));
    }
    if (m.find("ApiId") != m.end() && !m["ApiId"].empty()) {
      apiId = make_shared<string>(boost::any_cast<string>(m["ApiId"]));
    }
    if (m.find("ApiName") != m.end() && !m["ApiName"].empty()) {
      apiName = make_shared<string>(boost::any_cast<string>(m["ApiName"]));
    }
    if (m.find("AppCodeAuthType") != m.end() && !m["AppCodeAuthType"].empty()) {
      appCodeAuthType = make_shared<string>(boost::any_cast<string>(m["AppCodeAuthType"]));
    }
    if (m.find("AuthType") != m.end() && !m["AuthType"].empty()) {
      authType = make_shared<string>(boost::any_cast<string>(m["AuthType"]));
    }
    if (m.find("BackendEnable") != m.end() && !m["BackendEnable"].empty()) {
      backendEnable = make_shared<bool>(boost::any_cast<bool>(m["BackendEnable"]));
    }
    if (m.find("BackendId") != m.end() && !m["BackendId"].empty()) {
      backendId = make_shared<string>(boost::any_cast<string>(m["BackendId"]));
    }
    if (m.find("ConstantParameters") != m.end() && !m["ConstantParameters"].empty()) {
      constantParameters = make_shared<string>(boost::any_cast<string>(m["ConstantParameters"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DisableInternet") != m.end() && !m["DisableInternet"].empty()) {
      disableInternet = make_shared<bool>(boost::any_cast<bool>(m["DisableInternet"]));
    }
    if (m.find("ErrorCodeSamples") != m.end() && !m["ErrorCodeSamples"].empty()) {
      errorCodeSamples = make_shared<string>(boost::any_cast<string>(m["ErrorCodeSamples"]));
    }
    if (m.find("FailResultSample") != m.end() && !m["FailResultSample"].empty()) {
      failResultSample = make_shared<string>(boost::any_cast<string>(m["FailResultSample"]));
    }
    if (m.find("ForceNonceCheck") != m.end() && !m["ForceNonceCheck"].empty()) {
      forceNonceCheck = make_shared<bool>(boost::any_cast<bool>(m["ForceNonceCheck"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("OpenIdConnectConfig") != m.end() && !m["OpenIdConnectConfig"].empty()) {
      openIdConnectConfig = make_shared<string>(boost::any_cast<string>(m["OpenIdConnectConfig"]));
    }
    if (m.find("RequestConfig") != m.end() && !m["RequestConfig"].empty()) {
      requestConfig = make_shared<string>(boost::any_cast<string>(m["RequestConfig"]));
    }
    if (m.find("RequestParameters") != m.end() && !m["RequestParameters"].empty()) {
      requestParameters = make_shared<string>(boost::any_cast<string>(m["RequestParameters"]));
    }
    if (m.find("ResultBodyModel") != m.end() && !m["ResultBodyModel"].empty()) {
      resultBodyModel = make_shared<string>(boost::any_cast<string>(m["ResultBodyModel"]));
    }
    if (m.find("ResultDescriptions") != m.end() && !m["ResultDescriptions"].empty()) {
      resultDescriptions = make_shared<string>(boost::any_cast<string>(m["ResultDescriptions"]));
    }
    if (m.find("ResultSample") != m.end() && !m["ResultSample"].empty()) {
      resultSample = make_shared<string>(boost::any_cast<string>(m["ResultSample"]));
    }
    if (m.find("ResultType") != m.end() && !m["ResultType"].empty()) {
      resultType = make_shared<string>(boost::any_cast<string>(m["ResultType"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("ServiceConfig") != m.end() && !m["ServiceConfig"].empty()) {
      serviceConfig = make_shared<string>(boost::any_cast<string>(m["ServiceConfig"]));
    }
    if (m.find("ServiceParameters") != m.end() && !m["ServiceParameters"].empty()) {
      serviceParameters = make_shared<string>(boost::any_cast<string>(m["ServiceParameters"]));
    }
    if (m.find("ServiceParametersMap") != m.end() && !m["ServiceParametersMap"].empty()) {
      serviceParametersMap = make_shared<string>(boost::any_cast<string>(m["ServiceParametersMap"]));
    }
    if (m.find("SystemParameters") != m.end() && !m["SystemParameters"].empty()) {
      systemParameters = make_shared<string>(boost::any_cast<string>(m["SystemParameters"]));
    }
    if (m.find("Visibility") != m.end() && !m["Visibility"].empty()) {
      visibility = make_shared<string>(boost::any_cast<string>(m["Visibility"]));
    }
    if (m.find("WebSocketApiType") != m.end() && !m["WebSocketApiType"].empty()) {
      webSocketApiType = make_shared<string>(boost::any_cast<string>(m["WebSocketApiType"]));
    }
  }


  virtual ~ModifyApiRequest() = default;
};
class ModifyApiResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyApiResponseBody() {}

  explicit ModifyApiResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyApiResponseBody() = default;
};
class ModifyApiResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyApiResponseBody> body{};

  ModifyApiResponse() {}

  explicit ModifyApiResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyApiResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyApiResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyApiResponse() = default;
};
class ModifyApiConfigurationRequest : public Darabonba::Model {
public:
  shared_ptr<string> allowSignatureMethod{};
  shared_ptr<string> apiId{};
  shared_ptr<string> apiName{};
  shared_ptr<string> appCodeAuthType{};
  shared_ptr<string> authType{};
  shared_ptr<string> backendName{};
  shared_ptr<string> bodyFormat{};
  shared_ptr<string> bodyModel{};
  shared_ptr<string> contentTypeCategory{};
  shared_ptr<string> contentTypeValue{};
  shared_ptr<string> description{};
  shared_ptr<bool> disableInternet{};
  shared_ptr<string> errorCodeSamples{};
  shared_ptr<string> failResultSample{};
  shared_ptr<bool> forceNonceCheck{};
  shared_ptr<string> functionComputeConfig{};
  shared_ptr<string> httpConfig{};
  shared_ptr<string> mockConfig{};
  shared_ptr<string> modelName{};
  shared_ptr<string> ossConfig{};
  shared_ptr<string> postBodyDescription{};
  shared_ptr<string> requestHttpMethod{};
  shared_ptr<string> requestMode{};
  shared_ptr<string> requestParameters{};
  shared_ptr<string> requestPath{};
  shared_ptr<string> requestProtocol{};
  shared_ptr<string> resultSample{};
  shared_ptr<string> resultType{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> serviceParameters{};
  shared_ptr<string> serviceParametersMap{};
  shared_ptr<string> serviceProtocol{};
  shared_ptr<long> serviceTimeout{};
  shared_ptr<bool> useBackendService{};
  shared_ptr<string> visibility{};
  shared_ptr<string> vpcConfig{};

  ModifyApiConfigurationRequest() {}

  explicit ModifyApiConfigurationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (allowSignatureMethod) {
      res["AllowSignatureMethod"] = boost::any(*allowSignatureMethod);
    }
    if (apiId) {
      res["ApiId"] = boost::any(*apiId);
    }
    if (apiName) {
      res["ApiName"] = boost::any(*apiName);
    }
    if (appCodeAuthType) {
      res["AppCodeAuthType"] = boost::any(*appCodeAuthType);
    }
    if (authType) {
      res["AuthType"] = boost::any(*authType);
    }
    if (backendName) {
      res["BackendName"] = boost::any(*backendName);
    }
    if (bodyFormat) {
      res["BodyFormat"] = boost::any(*bodyFormat);
    }
    if (bodyModel) {
      res["BodyModel"] = boost::any(*bodyModel);
    }
    if (contentTypeCategory) {
      res["ContentTypeCategory"] = boost::any(*contentTypeCategory);
    }
    if (contentTypeValue) {
      res["ContentTypeValue"] = boost::any(*contentTypeValue);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (disableInternet) {
      res["DisableInternet"] = boost::any(*disableInternet);
    }
    if (errorCodeSamples) {
      res["ErrorCodeSamples"] = boost::any(*errorCodeSamples);
    }
    if (failResultSample) {
      res["FailResultSample"] = boost::any(*failResultSample);
    }
    if (forceNonceCheck) {
      res["ForceNonceCheck"] = boost::any(*forceNonceCheck);
    }
    if (functionComputeConfig) {
      res["FunctionComputeConfig"] = boost::any(*functionComputeConfig);
    }
    if (httpConfig) {
      res["HttpConfig"] = boost::any(*httpConfig);
    }
    if (mockConfig) {
      res["MockConfig"] = boost::any(*mockConfig);
    }
    if (modelName) {
      res["ModelName"] = boost::any(*modelName);
    }
    if (ossConfig) {
      res["OssConfig"] = boost::any(*ossConfig);
    }
    if (postBodyDescription) {
      res["PostBodyDescription"] = boost::any(*postBodyDescription);
    }
    if (requestHttpMethod) {
      res["RequestHttpMethod"] = boost::any(*requestHttpMethod);
    }
    if (requestMode) {
      res["RequestMode"] = boost::any(*requestMode);
    }
    if (requestParameters) {
      res["RequestParameters"] = boost::any(*requestParameters);
    }
    if (requestPath) {
      res["RequestPath"] = boost::any(*requestPath);
    }
    if (requestProtocol) {
      res["RequestProtocol"] = boost::any(*requestProtocol);
    }
    if (resultSample) {
      res["ResultSample"] = boost::any(*resultSample);
    }
    if (resultType) {
      res["ResultType"] = boost::any(*resultType);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (serviceParameters) {
      res["ServiceParameters"] = boost::any(*serviceParameters);
    }
    if (serviceParametersMap) {
      res["ServiceParametersMap"] = boost::any(*serviceParametersMap);
    }
    if (serviceProtocol) {
      res["ServiceProtocol"] = boost::any(*serviceProtocol);
    }
    if (serviceTimeout) {
      res["ServiceTimeout"] = boost::any(*serviceTimeout);
    }
    if (useBackendService) {
      res["UseBackendService"] = boost::any(*useBackendService);
    }
    if (visibility) {
      res["Visibility"] = boost::any(*visibility);
    }
    if (vpcConfig) {
      res["VpcConfig"] = boost::any(*vpcConfig);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AllowSignatureMethod") != m.end() && !m["AllowSignatureMethod"].empty()) {
      allowSignatureMethod = make_shared<string>(boost::any_cast<string>(m["AllowSignatureMethod"]));
    }
    if (m.find("ApiId") != m.end() && !m["ApiId"].empty()) {
      apiId = make_shared<string>(boost::any_cast<string>(m["ApiId"]));
    }
    if (m.find("ApiName") != m.end() && !m["ApiName"].empty()) {
      apiName = make_shared<string>(boost::any_cast<string>(m["ApiName"]));
    }
    if (m.find("AppCodeAuthType") != m.end() && !m["AppCodeAuthType"].empty()) {
      appCodeAuthType = make_shared<string>(boost::any_cast<string>(m["AppCodeAuthType"]));
    }
    if (m.find("AuthType") != m.end() && !m["AuthType"].empty()) {
      authType = make_shared<string>(boost::any_cast<string>(m["AuthType"]));
    }
    if (m.find("BackendName") != m.end() && !m["BackendName"].empty()) {
      backendName = make_shared<string>(boost::any_cast<string>(m["BackendName"]));
    }
    if (m.find("BodyFormat") != m.end() && !m["BodyFormat"].empty()) {
      bodyFormat = make_shared<string>(boost::any_cast<string>(m["BodyFormat"]));
    }
    if (m.find("BodyModel") != m.end() && !m["BodyModel"].empty()) {
      bodyModel = make_shared<string>(boost::any_cast<string>(m["BodyModel"]));
    }
    if (m.find("ContentTypeCategory") != m.end() && !m["ContentTypeCategory"].empty()) {
      contentTypeCategory = make_shared<string>(boost::any_cast<string>(m["ContentTypeCategory"]));
    }
    if (m.find("ContentTypeValue") != m.end() && !m["ContentTypeValue"].empty()) {
      contentTypeValue = make_shared<string>(boost::any_cast<string>(m["ContentTypeValue"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DisableInternet") != m.end() && !m["DisableInternet"].empty()) {
      disableInternet = make_shared<bool>(boost::any_cast<bool>(m["DisableInternet"]));
    }
    if (m.find("ErrorCodeSamples") != m.end() && !m["ErrorCodeSamples"].empty()) {
      errorCodeSamples = make_shared<string>(boost::any_cast<string>(m["ErrorCodeSamples"]));
    }
    if (m.find("FailResultSample") != m.end() && !m["FailResultSample"].empty()) {
      failResultSample = make_shared<string>(boost::any_cast<string>(m["FailResultSample"]));
    }
    if (m.find("ForceNonceCheck") != m.end() && !m["ForceNonceCheck"].empty()) {
      forceNonceCheck = make_shared<bool>(boost::any_cast<bool>(m["ForceNonceCheck"]));
    }
    if (m.find("FunctionComputeConfig") != m.end() && !m["FunctionComputeConfig"].empty()) {
      functionComputeConfig = make_shared<string>(boost::any_cast<string>(m["FunctionComputeConfig"]));
    }
    if (m.find("HttpConfig") != m.end() && !m["HttpConfig"].empty()) {
      httpConfig = make_shared<string>(boost::any_cast<string>(m["HttpConfig"]));
    }
    if (m.find("MockConfig") != m.end() && !m["MockConfig"].empty()) {
      mockConfig = make_shared<string>(boost::any_cast<string>(m["MockConfig"]));
    }
    if (m.find("ModelName") != m.end() && !m["ModelName"].empty()) {
      modelName = make_shared<string>(boost::any_cast<string>(m["ModelName"]));
    }
    if (m.find("OssConfig") != m.end() && !m["OssConfig"].empty()) {
      ossConfig = make_shared<string>(boost::any_cast<string>(m["OssConfig"]));
    }
    if (m.find("PostBodyDescription") != m.end() && !m["PostBodyDescription"].empty()) {
      postBodyDescription = make_shared<string>(boost::any_cast<string>(m["PostBodyDescription"]));
    }
    if (m.find("RequestHttpMethod") != m.end() && !m["RequestHttpMethod"].empty()) {
      requestHttpMethod = make_shared<string>(boost::any_cast<string>(m["RequestHttpMethod"]));
    }
    if (m.find("RequestMode") != m.end() && !m["RequestMode"].empty()) {
      requestMode = make_shared<string>(boost::any_cast<string>(m["RequestMode"]));
    }
    if (m.find("RequestParameters") != m.end() && !m["RequestParameters"].empty()) {
      requestParameters = make_shared<string>(boost::any_cast<string>(m["RequestParameters"]));
    }
    if (m.find("RequestPath") != m.end() && !m["RequestPath"].empty()) {
      requestPath = make_shared<string>(boost::any_cast<string>(m["RequestPath"]));
    }
    if (m.find("RequestProtocol") != m.end() && !m["RequestProtocol"].empty()) {
      requestProtocol = make_shared<string>(boost::any_cast<string>(m["RequestProtocol"]));
    }
    if (m.find("ResultSample") != m.end() && !m["ResultSample"].empty()) {
      resultSample = make_shared<string>(boost::any_cast<string>(m["ResultSample"]));
    }
    if (m.find("ResultType") != m.end() && !m["ResultType"].empty()) {
      resultType = make_shared<string>(boost::any_cast<string>(m["ResultType"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("ServiceParameters") != m.end() && !m["ServiceParameters"].empty()) {
      serviceParameters = make_shared<string>(boost::any_cast<string>(m["ServiceParameters"]));
    }
    if (m.find("ServiceParametersMap") != m.end() && !m["ServiceParametersMap"].empty()) {
      serviceParametersMap = make_shared<string>(boost::any_cast<string>(m["ServiceParametersMap"]));
    }
    if (m.find("ServiceProtocol") != m.end() && !m["ServiceProtocol"].empty()) {
      serviceProtocol = make_shared<string>(boost::any_cast<string>(m["ServiceProtocol"]));
    }
    if (m.find("ServiceTimeout") != m.end() && !m["ServiceTimeout"].empty()) {
      serviceTimeout = make_shared<long>(boost::any_cast<long>(m["ServiceTimeout"]));
    }
    if (m.find("UseBackendService") != m.end() && !m["UseBackendService"].empty()) {
      useBackendService = make_shared<bool>(boost::any_cast<bool>(m["UseBackendService"]));
    }
    if (m.find("Visibility") != m.end() && !m["Visibility"].empty()) {
      visibility = make_shared<string>(boost::any_cast<string>(m["Visibility"]));
    }
    if (m.find("VpcConfig") != m.end() && !m["VpcConfig"].empty()) {
      vpcConfig = make_shared<string>(boost::any_cast<string>(m["VpcConfig"]));
    }
  }


  virtual ~ModifyApiConfigurationRequest() = default;
};
class ModifyApiConfigurationResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyApiConfigurationResponseBody() {}

  explicit ModifyApiConfigurationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyApiConfigurationResponseBody() = default;
};
class ModifyApiConfigurationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyApiConfigurationResponseBody> body{};

  ModifyApiConfigurationResponse() {}

  explicit ModifyApiConfigurationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyApiConfigurationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyApiConfigurationResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyApiConfigurationResponse() = default;
};
class ModifyApiGroupRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  ModifyApiGroupRequestTag() {}

  explicit ModifyApiGroupRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~ModifyApiGroupRequestTag() = default;
};
class ModifyApiGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> basePath{};
  shared_ptr<string> compatibleFlags{};
  shared_ptr<string> customTraceConfig{};
  shared_ptr<string> customerConfigs{};
  shared_ptr<string> defaultDomain{};
  shared_ptr<string> description{};
  shared_ptr<string> groupId{};
  shared_ptr<string> groupName{};
  shared_ptr<string> passthroughHeaders{};
  shared_ptr<string> rpcPattern{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> supportSSE{};
  shared_ptr<vector<ModifyApiGroupRequestTag>> tag{};
  shared_ptr<string> userLogConfig{};

  ModifyApiGroupRequest() {}

  explicit ModifyApiGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (basePath) {
      res["BasePath"] = boost::any(*basePath);
    }
    if (compatibleFlags) {
      res["CompatibleFlags"] = boost::any(*compatibleFlags);
    }
    if (customTraceConfig) {
      res["CustomTraceConfig"] = boost::any(*customTraceConfig);
    }
    if (customerConfigs) {
      res["CustomerConfigs"] = boost::any(*customerConfigs);
    }
    if (defaultDomain) {
      res["DefaultDomain"] = boost::any(*defaultDomain);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (passthroughHeaders) {
      res["PassthroughHeaders"] = boost::any(*passthroughHeaders);
    }
    if (rpcPattern) {
      res["RpcPattern"] = boost::any(*rpcPattern);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (supportSSE) {
      res["SupportSSE"] = boost::any(*supportSSE);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    if (userLogConfig) {
      res["UserLogConfig"] = boost::any(*userLogConfig);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BasePath") != m.end() && !m["BasePath"].empty()) {
      basePath = make_shared<string>(boost::any_cast<string>(m["BasePath"]));
    }
    if (m.find("CompatibleFlags") != m.end() && !m["CompatibleFlags"].empty()) {
      compatibleFlags = make_shared<string>(boost::any_cast<string>(m["CompatibleFlags"]));
    }
    if (m.find("CustomTraceConfig") != m.end() && !m["CustomTraceConfig"].empty()) {
      customTraceConfig = make_shared<string>(boost::any_cast<string>(m["CustomTraceConfig"]));
    }
    if (m.find("CustomerConfigs") != m.end() && !m["CustomerConfigs"].empty()) {
      customerConfigs = make_shared<string>(boost::any_cast<string>(m["CustomerConfigs"]));
    }
    if (m.find("DefaultDomain") != m.end() && !m["DefaultDomain"].empty()) {
      defaultDomain = make_shared<string>(boost::any_cast<string>(m["DefaultDomain"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("PassthroughHeaders") != m.end() && !m["PassthroughHeaders"].empty()) {
      passthroughHeaders = make_shared<string>(boost::any_cast<string>(m["PassthroughHeaders"]));
    }
    if (m.find("RpcPattern") != m.end() && !m["RpcPattern"].empty()) {
      rpcPattern = make_shared<string>(boost::any_cast<string>(m["RpcPattern"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("SupportSSE") != m.end() && !m["SupportSSE"].empty()) {
      supportSSE = make_shared<string>(boost::any_cast<string>(m["SupportSSE"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<ModifyApiGroupRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ModifyApiGroupRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<ModifyApiGroupRequestTag>>(expect1);
      }
    }
    if (m.find("UserLogConfig") != m.end() && !m["UserLogConfig"].empty()) {
      userLogConfig = make_shared<string>(boost::any_cast<string>(m["UserLogConfig"]));
    }
  }


  virtual ~ModifyApiGroupRequest() = default;
};
class ModifyApiGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> basePath{};
  shared_ptr<string> description{};
  shared_ptr<string> groupId{};
  shared_ptr<string> groupName{};
  shared_ptr<string> requestId{};
  shared_ptr<string> subDomain{};

  ModifyApiGroupResponseBody() {}

  explicit ModifyApiGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (basePath) {
      res["BasePath"] = boost::any(*basePath);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (subDomain) {
      res["SubDomain"] = boost::any(*subDomain);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BasePath") != m.end() && !m["BasePath"].empty()) {
      basePath = make_shared<string>(boost::any_cast<string>(m["BasePath"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SubDomain") != m.end() && !m["SubDomain"].empty()) {
      subDomain = make_shared<string>(boost::any_cast<string>(m["SubDomain"]));
    }
  }


  virtual ~ModifyApiGroupResponseBody() = default;
};
class ModifyApiGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyApiGroupResponseBody> body{};

  ModifyApiGroupResponse() {}

  explicit ModifyApiGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyApiGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyApiGroupResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyApiGroupResponse() = default;
};
class ModifyApiGroupInstanceRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  ModifyApiGroupInstanceRequestTag() {}

  explicit ModifyApiGroupInstanceRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~ModifyApiGroupInstanceRequestTag() = default;
};
class ModifyApiGroupInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<string> groupId{};
  shared_ptr<string> remark{};
  shared_ptr<string> securityToken{};
  shared_ptr<vector<ModifyApiGroupInstanceRequestTag>> tag{};
  shared_ptr<string> targetInstanceId{};

  ModifyApiGroupInstanceRequest() {}

  explicit ModifyApiGroupInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (remark) {
      res["Remark"] = boost::any(*remark);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    if (targetInstanceId) {
      res["TargetInstanceId"] = boost::any(*targetInstanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("Remark") != m.end() && !m["Remark"].empty()) {
      remark = make_shared<string>(boost::any_cast<string>(m["Remark"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<ModifyApiGroupInstanceRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ModifyApiGroupInstanceRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<ModifyApiGroupInstanceRequestTag>>(expect1);
      }
    }
    if (m.find("TargetInstanceId") != m.end() && !m["TargetInstanceId"].empty()) {
      targetInstanceId = make_shared<string>(boost::any_cast<string>(m["TargetInstanceId"]));
    }
  }


  virtual ~ModifyApiGroupInstanceRequest() = default;
};
class ModifyApiGroupInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyApiGroupInstanceResponseBody() {}

  explicit ModifyApiGroupInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyApiGroupInstanceResponseBody() = default;
};
class ModifyApiGroupInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyApiGroupInstanceResponseBody> body{};

  ModifyApiGroupInstanceResponse() {}

  explicit ModifyApiGroupInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyApiGroupInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyApiGroupInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyApiGroupInstanceResponse() = default;
};
class ModifyApiGroupNetworkPolicyRequest : public Darabonba::Model {
public:
  shared_ptr<string> groupId{};
  shared_ptr<string> httpsPolicy{};
  shared_ptr<bool> innerDomainEnable{};
  shared_ptr<bool> internetEnable{};
  shared_ptr<bool> internetIPV6Enable{};
  shared_ptr<string> securityToken{};
  shared_ptr<bool> vpcIntranetEnable{};
  shared_ptr<bool> vpcSlbIntranetEnable{};

  ModifyApiGroupNetworkPolicyRequest() {}

  explicit ModifyApiGroupNetworkPolicyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (httpsPolicy) {
      res["HttpsPolicy"] = boost::any(*httpsPolicy);
    }
    if (innerDomainEnable) {
      res["InnerDomainEnable"] = boost::any(*innerDomainEnable);
    }
    if (internetEnable) {
      res["InternetEnable"] = boost::any(*internetEnable);
    }
    if (internetIPV6Enable) {
      res["InternetIPV6Enable"] = boost::any(*internetIPV6Enable);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (vpcIntranetEnable) {
      res["VpcIntranetEnable"] = boost::any(*vpcIntranetEnable);
    }
    if (vpcSlbIntranetEnable) {
      res["VpcSlbIntranetEnable"] = boost::any(*vpcSlbIntranetEnable);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("HttpsPolicy") != m.end() && !m["HttpsPolicy"].empty()) {
      httpsPolicy = make_shared<string>(boost::any_cast<string>(m["HttpsPolicy"]));
    }
    if (m.find("InnerDomainEnable") != m.end() && !m["InnerDomainEnable"].empty()) {
      innerDomainEnable = make_shared<bool>(boost::any_cast<bool>(m["InnerDomainEnable"]));
    }
    if (m.find("InternetEnable") != m.end() && !m["InternetEnable"].empty()) {
      internetEnable = make_shared<bool>(boost::any_cast<bool>(m["InternetEnable"]));
    }
    if (m.find("InternetIPV6Enable") != m.end() && !m["InternetIPV6Enable"].empty()) {
      internetIPV6Enable = make_shared<bool>(boost::any_cast<bool>(m["InternetIPV6Enable"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("VpcIntranetEnable") != m.end() && !m["VpcIntranetEnable"].empty()) {
      vpcIntranetEnable = make_shared<bool>(boost::any_cast<bool>(m["VpcIntranetEnable"]));
    }
    if (m.find("VpcSlbIntranetEnable") != m.end() && !m["VpcSlbIntranetEnable"].empty()) {
      vpcSlbIntranetEnable = make_shared<bool>(boost::any_cast<bool>(m["VpcSlbIntranetEnable"]));
    }
  }


  virtual ~ModifyApiGroupNetworkPolicyRequest() = default;
};
class ModifyApiGroupNetworkPolicyResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyApiGroupNetworkPolicyResponseBody() {}

  explicit ModifyApiGroupNetworkPolicyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyApiGroupNetworkPolicyResponseBody() = default;
};
class ModifyApiGroupNetworkPolicyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyApiGroupNetworkPolicyResponseBody> body{};

  ModifyApiGroupNetworkPolicyResponse() {}

  explicit ModifyApiGroupNetworkPolicyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyApiGroupNetworkPolicyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyApiGroupNetworkPolicyResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyApiGroupNetworkPolicyResponse() = default;
};
class ModifyApiGroupVpcWhitelistRequest : public Darabonba::Model {
public:
  shared_ptr<string> groupId{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> vpcIds{};

  ModifyApiGroupVpcWhitelistRequest() {}

  explicit ModifyApiGroupVpcWhitelistRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (vpcIds) {
      res["VpcIds"] = boost::any(*vpcIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("VpcIds") != m.end() && !m["VpcIds"].empty()) {
      vpcIds = make_shared<string>(boost::any_cast<string>(m["VpcIds"]));
    }
  }


  virtual ~ModifyApiGroupVpcWhitelistRequest() = default;
};
class ModifyApiGroupVpcWhitelistResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyApiGroupVpcWhitelistResponseBody() {}

  explicit ModifyApiGroupVpcWhitelistResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyApiGroupVpcWhitelistResponseBody() = default;
};
class ModifyApiGroupVpcWhitelistResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyApiGroupVpcWhitelistResponseBody> body{};

  ModifyApiGroupVpcWhitelistResponse() {}

  explicit ModifyApiGroupVpcWhitelistResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyApiGroupVpcWhitelistResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyApiGroupVpcWhitelistResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyApiGroupVpcWhitelistResponse() = default;
};
class ModifyAppRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  ModifyAppRequestTag() {}

  explicit ModifyAppRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~ModifyAppRequestTag() = default;
};
class ModifyAppRequest : public Darabonba::Model {
public:
  shared_ptr<long> appId{};
  shared_ptr<string> appName{};
  shared_ptr<string> description{};
  shared_ptr<string> extend{};
  shared_ptr<string> securityToken{};
  shared_ptr<vector<ModifyAppRequestTag>> tag{};

  ModifyAppRequest() {}

  explicit ModifyAppRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (extend) {
      res["Extend"] = boost::any(*extend);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<long>(boost::any_cast<long>(m["AppId"]));
    }
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Extend") != m.end() && !m["Extend"].empty()) {
      extend = make_shared<string>(boost::any_cast<string>(m["Extend"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<ModifyAppRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ModifyAppRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<ModifyAppRequestTag>>(expect1);
      }
    }
  }


  virtual ~ModifyAppRequest() = default;
};
class ModifyAppResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyAppResponseBody() {}

  explicit ModifyAppResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyAppResponseBody() = default;
};
class ModifyAppResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyAppResponseBody> body{};

  ModifyAppResponse() {}

  explicit ModifyAppResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyAppResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyAppResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyAppResponse() = default;
};
class ModifyBackendRequest : public Darabonba::Model {
public:
  shared_ptr<string> backendId{};
  shared_ptr<string> backendName{};
  shared_ptr<string> backendType{};
  shared_ptr<string> description{};
  shared_ptr<string> securityToken{};

  ModifyBackendRequest() {}

  explicit ModifyBackendRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (backendId) {
      res["BackendId"] = boost::any(*backendId);
    }
    if (backendName) {
      res["BackendName"] = boost::any(*backendName);
    }
    if (backendType) {
      res["BackendType"] = boost::any(*backendType);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BackendId") != m.end() && !m["BackendId"].empty()) {
      backendId = make_shared<string>(boost::any_cast<string>(m["BackendId"]));
    }
    if (m.find("BackendName") != m.end() && !m["BackendName"].empty()) {
      backendName = make_shared<string>(boost::any_cast<string>(m["BackendName"]));
    }
    if (m.find("BackendType") != m.end() && !m["BackendType"].empty()) {
      backendType = make_shared<string>(boost::any_cast<string>(m["BackendType"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~ModifyBackendRequest() = default;
};
class ModifyBackendResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyBackendResponseBody() {}

  explicit ModifyBackendResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyBackendResponseBody() = default;
};
class ModifyBackendResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyBackendResponseBody> body{};

  ModifyBackendResponse() {}

  explicit ModifyBackendResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyBackendResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyBackendResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyBackendResponse() = default;
};
class ModifyBackendModelRequest : public Darabonba::Model {
public:
  shared_ptr<string> backendId{};
  shared_ptr<string> backendModelData{};
  shared_ptr<string> backendModelId{};
  shared_ptr<string> backendType{};
  shared_ptr<string> description{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> stageName{};

  ModifyBackendModelRequest() {}

  explicit ModifyBackendModelRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (backendId) {
      res["BackendId"] = boost::any(*backendId);
    }
    if (backendModelData) {
      res["BackendModelData"] = boost::any(*backendModelData);
    }
    if (backendModelId) {
      res["BackendModelId"] = boost::any(*backendModelId);
    }
    if (backendType) {
      res["BackendType"] = boost::any(*backendType);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (stageName) {
      res["StageName"] = boost::any(*stageName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BackendId") != m.end() && !m["BackendId"].empty()) {
      backendId = make_shared<string>(boost::any_cast<string>(m["BackendId"]));
    }
    if (m.find("BackendModelData") != m.end() && !m["BackendModelData"].empty()) {
      backendModelData = make_shared<string>(boost::any_cast<string>(m["BackendModelData"]));
    }
    if (m.find("BackendModelId") != m.end() && !m["BackendModelId"].empty()) {
      backendModelId = make_shared<string>(boost::any_cast<string>(m["BackendModelId"]));
    }
    if (m.find("BackendType") != m.end() && !m["BackendType"].empty()) {
      backendType = make_shared<string>(boost::any_cast<string>(m["BackendType"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("StageName") != m.end() && !m["StageName"].empty()) {
      stageName = make_shared<string>(boost::any_cast<string>(m["StageName"]));
    }
  }


  virtual ~ModifyBackendModelRequest() = default;
};
class ModifyBackendModelResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> operationId{};
  shared_ptr<string> requestId{};

  ModifyBackendModelResponseBody() {}

  explicit ModifyBackendModelResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (operationId) {
      res["OperationId"] = boost::any(*operationId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OperationId") != m.end() && !m["OperationId"].empty()) {
      operationId = make_shared<string>(boost::any_cast<string>(m["OperationId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyBackendModelResponseBody() = default;
};
class ModifyBackendModelResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyBackendModelResponseBody> body{};

  ModifyBackendModelResponse() {}

  explicit ModifyBackendModelResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyBackendModelResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyBackendModelResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyBackendModelResponse() = default;
};
class ModifyDatasetRequest : public Darabonba::Model {
public:
  shared_ptr<string> datasetId{};
  shared_ptr<string> datasetName{};
  shared_ptr<string> securityToken{};

  ModifyDatasetRequest() {}

  explicit ModifyDatasetRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (datasetId) {
      res["DatasetId"] = boost::any(*datasetId);
    }
    if (datasetName) {
      res["DatasetName"] = boost::any(*datasetName);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DatasetId") != m.end() && !m["DatasetId"].empty()) {
      datasetId = make_shared<string>(boost::any_cast<string>(m["DatasetId"]));
    }
    if (m.find("DatasetName") != m.end() && !m["DatasetName"].empty()) {
      datasetName = make_shared<string>(boost::any_cast<string>(m["DatasetName"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~ModifyDatasetRequest() = default;
};
class ModifyDatasetResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyDatasetResponseBody() {}

  explicit ModifyDatasetResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyDatasetResponseBody() = default;
};
class ModifyDatasetResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyDatasetResponseBody> body{};

  ModifyDatasetResponse() {}

  explicit ModifyDatasetResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyDatasetResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyDatasetResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyDatasetResponse() = default;
};
class ModifyDatasetItemRequest : public Darabonba::Model {
public:
  shared_ptr<string> datasetId{};
  shared_ptr<string> datasetItemId{};
  shared_ptr<string> description{};
  shared_ptr<string> expiredTime{};
  shared_ptr<string> securityToken{};

  ModifyDatasetItemRequest() {}

  explicit ModifyDatasetItemRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (datasetId) {
      res["DatasetId"] = boost::any(*datasetId);
    }
    if (datasetItemId) {
      res["DatasetItemId"] = boost::any(*datasetItemId);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (expiredTime) {
      res["ExpiredTime"] = boost::any(*expiredTime);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DatasetId") != m.end() && !m["DatasetId"].empty()) {
      datasetId = make_shared<string>(boost::any_cast<string>(m["DatasetId"]));
    }
    if (m.find("DatasetItemId") != m.end() && !m["DatasetItemId"].empty()) {
      datasetItemId = make_shared<string>(boost::any_cast<string>(m["DatasetItemId"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("ExpiredTime") != m.end() && !m["ExpiredTime"].empty()) {
      expiredTime = make_shared<string>(boost::any_cast<string>(m["ExpiredTime"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~ModifyDatasetItemRequest() = default;
};
class ModifyDatasetItemResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyDatasetItemResponseBody() {}

  explicit ModifyDatasetItemResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyDatasetItemResponseBody() = default;
};
class ModifyDatasetItemResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyDatasetItemResponseBody> body{};

  ModifyDatasetItemResponse() {}

  explicit ModifyDatasetItemResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyDatasetItemResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyDatasetItemResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyDatasetItemResponse() = default;
};
class ModifyInstanceAttributeRequestToConnectVpcIpBlock : public Darabonba::Model {
public:
  shared_ptr<string> cidrBlock{};
  shared_ptr<bool> customized{};
  shared_ptr<string> vswitchId{};
  shared_ptr<string> zoneId{};

  ModifyInstanceAttributeRequestToConnectVpcIpBlock() {}

  explicit ModifyInstanceAttributeRequestToConnectVpcIpBlock(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cidrBlock) {
      res["CidrBlock"] = boost::any(*cidrBlock);
    }
    if (customized) {
      res["Customized"] = boost::any(*customized);
    }
    if (vswitchId) {
      res["VswitchId"] = boost::any(*vswitchId);
    }
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CidrBlock") != m.end() && !m["CidrBlock"].empty()) {
      cidrBlock = make_shared<string>(boost::any_cast<string>(m["CidrBlock"]));
    }
    if (m.find("Customized") != m.end() && !m["Customized"].empty()) {
      customized = make_shared<bool>(boost::any_cast<bool>(m["Customized"]));
    }
    if (m.find("VswitchId") != m.end() && !m["VswitchId"].empty()) {
      vswitchId = make_shared<string>(boost::any_cast<string>(m["VswitchId"]));
    }
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["ZoneId"]));
    }
  }


  virtual ~ModifyInstanceAttributeRequestToConnectVpcIpBlock() = default;
};
class ModifyInstanceAttributeRequest : public Darabonba::Model {
public:
  shared_ptr<string> deleteVpcIpBlock{};
  shared_ptr<string> egressIpv6Enable{};
  shared_ptr<string> httpsPolicy{};
  shared_ptr<string> IPV6Enabled{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> instanceName{};
  shared_ptr<string> intranetSegments{};
  shared_ptr<string> maintainEndTime{};
  shared_ptr<string> maintainStartTime{};
  shared_ptr<ModifyInstanceAttributeRequestToConnectVpcIpBlock> toConnectVpcIpBlock{};
  shared_ptr<string> token{};
  shared_ptr<string> vpcSlbIntranetEnable{};

  ModifyInstanceAttributeRequest() {}

  explicit ModifyInstanceAttributeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deleteVpcIpBlock) {
      res["DeleteVpcIpBlock"] = boost::any(*deleteVpcIpBlock);
    }
    if (egressIpv6Enable) {
      res["EgressIpv6Enable"] = boost::any(*egressIpv6Enable);
    }
    if (httpsPolicy) {
      res["HttpsPolicy"] = boost::any(*httpsPolicy);
    }
    if (IPV6Enabled) {
      res["IPV6Enabled"] = boost::any(*IPV6Enabled);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (instanceName) {
      res["InstanceName"] = boost::any(*instanceName);
    }
    if (intranetSegments) {
      res["IntranetSegments"] = boost::any(*intranetSegments);
    }
    if (maintainEndTime) {
      res["MaintainEndTime"] = boost::any(*maintainEndTime);
    }
    if (maintainStartTime) {
      res["MaintainStartTime"] = boost::any(*maintainStartTime);
    }
    if (toConnectVpcIpBlock) {
      res["ToConnectVpcIpBlock"] = toConnectVpcIpBlock ? boost::any(toConnectVpcIpBlock->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (token) {
      res["Token"] = boost::any(*token);
    }
    if (vpcSlbIntranetEnable) {
      res["VpcSlbIntranetEnable"] = boost::any(*vpcSlbIntranetEnable);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeleteVpcIpBlock") != m.end() && !m["DeleteVpcIpBlock"].empty()) {
      deleteVpcIpBlock = make_shared<string>(boost::any_cast<string>(m["DeleteVpcIpBlock"]));
    }
    if (m.find("EgressIpv6Enable") != m.end() && !m["EgressIpv6Enable"].empty()) {
      egressIpv6Enable = make_shared<string>(boost::any_cast<string>(m["EgressIpv6Enable"]));
    }
    if (m.find("HttpsPolicy") != m.end() && !m["HttpsPolicy"].empty()) {
      httpsPolicy = make_shared<string>(boost::any_cast<string>(m["HttpsPolicy"]));
    }
    if (m.find("IPV6Enabled") != m.end() && !m["IPV6Enabled"].empty()) {
      IPV6Enabled = make_shared<string>(boost::any_cast<string>(m["IPV6Enabled"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("InstanceName") != m.end() && !m["InstanceName"].empty()) {
      instanceName = make_shared<string>(boost::any_cast<string>(m["InstanceName"]));
    }
    if (m.find("IntranetSegments") != m.end() && !m["IntranetSegments"].empty()) {
      intranetSegments = make_shared<string>(boost::any_cast<string>(m["IntranetSegments"]));
    }
    if (m.find("MaintainEndTime") != m.end() && !m["MaintainEndTime"].empty()) {
      maintainEndTime = make_shared<string>(boost::any_cast<string>(m["MaintainEndTime"]));
    }
    if (m.find("MaintainStartTime") != m.end() && !m["MaintainStartTime"].empty()) {
      maintainStartTime = make_shared<string>(boost::any_cast<string>(m["MaintainStartTime"]));
    }
    if (m.find("ToConnectVpcIpBlock") != m.end() && !m["ToConnectVpcIpBlock"].empty()) {
      if (typeid(map<string, boost::any>) == m["ToConnectVpcIpBlock"].type()) {
        ModifyInstanceAttributeRequestToConnectVpcIpBlock model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ToConnectVpcIpBlock"]));
        toConnectVpcIpBlock = make_shared<ModifyInstanceAttributeRequestToConnectVpcIpBlock>(model1);
      }
    }
    if (m.find("Token") != m.end() && !m["Token"].empty()) {
      token = make_shared<string>(boost::any_cast<string>(m["Token"]));
    }
    if (m.find("VpcSlbIntranetEnable") != m.end() && !m["VpcSlbIntranetEnable"].empty()) {
      vpcSlbIntranetEnable = make_shared<string>(boost::any_cast<string>(m["VpcSlbIntranetEnable"]));
    }
  }


  virtual ~ModifyInstanceAttributeRequest() = default;
};
class ModifyInstanceAttributeShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> deleteVpcIpBlock{};
  shared_ptr<string> egressIpv6Enable{};
  shared_ptr<string> httpsPolicy{};
  shared_ptr<string> IPV6Enabled{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> instanceName{};
  shared_ptr<string> intranetSegments{};
  shared_ptr<string> maintainEndTime{};
  shared_ptr<string> maintainStartTime{};
  shared_ptr<string> toConnectVpcIpBlockShrink{};
  shared_ptr<string> token{};
  shared_ptr<string> vpcSlbIntranetEnable{};

  ModifyInstanceAttributeShrinkRequest() {}

  explicit ModifyInstanceAttributeShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deleteVpcIpBlock) {
      res["DeleteVpcIpBlock"] = boost::any(*deleteVpcIpBlock);
    }
    if (egressIpv6Enable) {
      res["EgressIpv6Enable"] = boost::any(*egressIpv6Enable);
    }
    if (httpsPolicy) {
      res["HttpsPolicy"] = boost::any(*httpsPolicy);
    }
    if (IPV6Enabled) {
      res["IPV6Enabled"] = boost::any(*IPV6Enabled);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (instanceName) {
      res["InstanceName"] = boost::any(*instanceName);
    }
    if (intranetSegments) {
      res["IntranetSegments"] = boost::any(*intranetSegments);
    }
    if (maintainEndTime) {
      res["MaintainEndTime"] = boost::any(*maintainEndTime);
    }
    if (maintainStartTime) {
      res["MaintainStartTime"] = boost::any(*maintainStartTime);
    }
    if (toConnectVpcIpBlockShrink) {
      res["ToConnectVpcIpBlock"] = boost::any(*toConnectVpcIpBlockShrink);
    }
    if (token) {
      res["Token"] = boost::any(*token);
    }
    if (vpcSlbIntranetEnable) {
      res["VpcSlbIntranetEnable"] = boost::any(*vpcSlbIntranetEnable);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeleteVpcIpBlock") != m.end() && !m["DeleteVpcIpBlock"].empty()) {
      deleteVpcIpBlock = make_shared<string>(boost::any_cast<string>(m["DeleteVpcIpBlock"]));
    }
    if (m.find("EgressIpv6Enable") != m.end() && !m["EgressIpv6Enable"].empty()) {
      egressIpv6Enable = make_shared<string>(boost::any_cast<string>(m["EgressIpv6Enable"]));
    }
    if (m.find("HttpsPolicy") != m.end() && !m["HttpsPolicy"].empty()) {
      httpsPolicy = make_shared<string>(boost::any_cast<string>(m["HttpsPolicy"]));
    }
    if (m.find("IPV6Enabled") != m.end() && !m["IPV6Enabled"].empty()) {
      IPV6Enabled = make_shared<string>(boost::any_cast<string>(m["IPV6Enabled"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("InstanceName") != m.end() && !m["InstanceName"].empty()) {
      instanceName = make_shared<string>(boost::any_cast<string>(m["InstanceName"]));
    }
    if (m.find("IntranetSegments") != m.end() && !m["IntranetSegments"].empty()) {
      intranetSegments = make_shared<string>(boost::any_cast<string>(m["IntranetSegments"]));
    }
    if (m.find("MaintainEndTime") != m.end() && !m["MaintainEndTime"].empty()) {
      maintainEndTime = make_shared<string>(boost::any_cast<string>(m["MaintainEndTime"]));
    }
    if (m.find("MaintainStartTime") != m.end() && !m["MaintainStartTime"].empty()) {
      maintainStartTime = make_shared<string>(boost::any_cast<string>(m["MaintainStartTime"]));
    }
    if (m.find("ToConnectVpcIpBlock") != m.end() && !m["ToConnectVpcIpBlock"].empty()) {
      toConnectVpcIpBlockShrink = make_shared<string>(boost::any_cast<string>(m["ToConnectVpcIpBlock"]));
    }
    if (m.find("Token") != m.end() && !m["Token"].empty()) {
      token = make_shared<string>(boost::any_cast<string>(m["Token"]));
    }
    if (m.find("VpcSlbIntranetEnable") != m.end() && !m["VpcSlbIntranetEnable"].empty()) {
      vpcSlbIntranetEnable = make_shared<string>(boost::any_cast<string>(m["VpcSlbIntranetEnable"]));
    }
  }


  virtual ~ModifyInstanceAttributeShrinkRequest() = default;
};
class ModifyInstanceAttributeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyInstanceAttributeResponseBody() {}

  explicit ModifyInstanceAttributeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyInstanceAttributeResponseBody() = default;
};
class ModifyInstanceAttributeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyInstanceAttributeResponseBody> body{};

  ModifyInstanceAttributeResponse() {}

  explicit ModifyInstanceAttributeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyInstanceAttributeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyInstanceAttributeResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyInstanceAttributeResponse() = default;
};
class ModifyInstanceSpecRequest : public Darabonba::Model {
public:
  shared_ptr<bool> autoPay{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> instanceSpec{};
  shared_ptr<string> modifyAction{};
  shared_ptr<bool> skipWaitSwitch{};
  shared_ptr<string> token{};

  ModifyInstanceSpecRequest() {}

  explicit ModifyInstanceSpecRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (autoPay) {
      res["AutoPay"] = boost::any(*autoPay);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (instanceSpec) {
      res["InstanceSpec"] = boost::any(*instanceSpec);
    }
    if (modifyAction) {
      res["ModifyAction"] = boost::any(*modifyAction);
    }
    if (skipWaitSwitch) {
      res["SkipWaitSwitch"] = boost::any(*skipWaitSwitch);
    }
    if (token) {
      res["Token"] = boost::any(*token);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AutoPay") != m.end() && !m["AutoPay"].empty()) {
      autoPay = make_shared<bool>(boost::any_cast<bool>(m["AutoPay"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("InstanceSpec") != m.end() && !m["InstanceSpec"].empty()) {
      instanceSpec = make_shared<string>(boost::any_cast<string>(m["InstanceSpec"]));
    }
    if (m.find("ModifyAction") != m.end() && !m["ModifyAction"].empty()) {
      modifyAction = make_shared<string>(boost::any_cast<string>(m["ModifyAction"]));
    }
    if (m.find("SkipWaitSwitch") != m.end() && !m["SkipWaitSwitch"].empty()) {
      skipWaitSwitch = make_shared<bool>(boost::any_cast<bool>(m["SkipWaitSwitch"]));
    }
    if (m.find("Token") != m.end() && !m["Token"].empty()) {
      token = make_shared<string>(boost::any_cast<string>(m["Token"]));
    }
  }


  virtual ~ModifyInstanceSpecRequest() = default;
};
class ModifyInstanceSpecResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyInstanceSpecResponseBody() {}

  explicit ModifyInstanceSpecResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyInstanceSpecResponseBody() = default;
};
class ModifyInstanceSpecResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyInstanceSpecResponseBody> body{};

  ModifyInstanceSpecResponse() {}

  explicit ModifyInstanceSpecResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyInstanceSpecResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyInstanceSpecResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyInstanceSpecResponse() = default;
};
class ModifyIntranetDomainPolicyRequest : public Darabonba::Model {
public:
  shared_ptr<string> groupId{};
  shared_ptr<string> securityToken{};
  shared_ptr<bool> vpcIntranetEnable{};

  ModifyIntranetDomainPolicyRequest() {}

  explicit ModifyIntranetDomainPolicyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (vpcIntranetEnable) {
      res["VpcIntranetEnable"] = boost::any(*vpcIntranetEnable);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("VpcIntranetEnable") != m.end() && !m["VpcIntranetEnable"].empty()) {
      vpcIntranetEnable = make_shared<bool>(boost::any_cast<bool>(m["VpcIntranetEnable"]));
    }
  }


  virtual ~ModifyIntranetDomainPolicyRequest() = default;
};
class ModifyIntranetDomainPolicyResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyIntranetDomainPolicyResponseBody() {}

  explicit ModifyIntranetDomainPolicyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyIntranetDomainPolicyResponseBody() = default;
};
class ModifyIntranetDomainPolicyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyIntranetDomainPolicyResponseBody> body{};

  ModifyIntranetDomainPolicyResponse() {}

  explicit ModifyIntranetDomainPolicyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyIntranetDomainPolicyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyIntranetDomainPolicyResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyIntranetDomainPolicyResponse() = default;
};
class ModifyIpControlRequest : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> ipControlId{};
  shared_ptr<string> ipControlName{};
  shared_ptr<string> securityToken{};

  ModifyIpControlRequest() {}

  explicit ModifyIpControlRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (ipControlId) {
      res["IpControlId"] = boost::any(*ipControlId);
    }
    if (ipControlName) {
      res["IpControlName"] = boost::any(*ipControlName);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("IpControlId") != m.end() && !m["IpControlId"].empty()) {
      ipControlId = make_shared<string>(boost::any_cast<string>(m["IpControlId"]));
    }
    if (m.find("IpControlName") != m.end() && !m["IpControlName"].empty()) {
      ipControlName = make_shared<string>(boost::any_cast<string>(m["IpControlName"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~ModifyIpControlRequest() = default;
};
class ModifyIpControlResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyIpControlResponseBody() {}

  explicit ModifyIpControlResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyIpControlResponseBody() = default;
};
class ModifyIpControlResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyIpControlResponseBody> body{};

  ModifyIpControlResponse() {}

  explicit ModifyIpControlResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyIpControlResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyIpControlResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyIpControlResponse() = default;
};
class ModifyIpControlPolicyItemRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> cidrIp{};
  shared_ptr<string> ipControlId{};
  shared_ptr<string> policyItemId{};
  shared_ptr<string> securityToken{};

  ModifyIpControlPolicyItemRequest() {}

  explicit ModifyIpControlPolicyItemRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (cidrIp) {
      res["CidrIp"] = boost::any(*cidrIp);
    }
    if (ipControlId) {
      res["IpControlId"] = boost::any(*ipControlId);
    }
    if (policyItemId) {
      res["PolicyItemId"] = boost::any(*policyItemId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("CidrIp") != m.end() && !m["CidrIp"].empty()) {
      cidrIp = make_shared<string>(boost::any_cast<string>(m["CidrIp"]));
    }
    if (m.find("IpControlId") != m.end() && !m["IpControlId"].empty()) {
      ipControlId = make_shared<string>(boost::any_cast<string>(m["IpControlId"]));
    }
    if (m.find("PolicyItemId") != m.end() && !m["PolicyItemId"].empty()) {
      policyItemId = make_shared<string>(boost::any_cast<string>(m["PolicyItemId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~ModifyIpControlPolicyItemRequest() = default;
};
class ModifyIpControlPolicyItemResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyIpControlPolicyItemResponseBody() {}

  explicit ModifyIpControlPolicyItemResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyIpControlPolicyItemResponseBody() = default;
};
class ModifyIpControlPolicyItemResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyIpControlPolicyItemResponseBody> body{};

  ModifyIpControlPolicyItemResponse() {}

  explicit ModifyIpControlPolicyItemResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyIpControlPolicyItemResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyIpControlPolicyItemResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyIpControlPolicyItemResponse() = default;
};
class ModifyLogConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> logType{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> slsLogStore{};
  shared_ptr<string> slsProject{};

  ModifyLogConfigRequest() {}

  explicit ModifyLogConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (logType) {
      res["LogType"] = boost::any(*logType);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (slsLogStore) {
      res["SlsLogStore"] = boost::any(*slsLogStore);
    }
    if (slsProject) {
      res["SlsProject"] = boost::any(*slsProject);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LogType") != m.end() && !m["LogType"].empty()) {
      logType = make_shared<string>(boost::any_cast<string>(m["LogType"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("SlsLogStore") != m.end() && !m["SlsLogStore"].empty()) {
      slsLogStore = make_shared<string>(boost::any_cast<string>(m["SlsLogStore"]));
    }
    if (m.find("SlsProject") != m.end() && !m["SlsProject"].empty()) {
      slsProject = make_shared<string>(boost::any_cast<string>(m["SlsProject"]));
    }
  }


  virtual ~ModifyLogConfigRequest() = default;
};
class ModifyLogConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyLogConfigResponseBody() {}

  explicit ModifyLogConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyLogConfigResponseBody() = default;
};
class ModifyLogConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyLogConfigResponseBody> body{};

  ModifyLogConfigResponse() {}

  explicit ModifyLogConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyLogConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyLogConfigResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyLogConfigResponse() = default;
};
class ModifyModelRequest : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> groupId{};
  shared_ptr<string> modelName{};
  shared_ptr<string> newModelName{};
  shared_ptr<string> schema{};

  ModifyModelRequest() {}

  explicit ModifyModelRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (modelName) {
      res["ModelName"] = boost::any(*modelName);
    }
    if (newModelName) {
      res["NewModelName"] = boost::any(*newModelName);
    }
    if (schema) {
      res["Schema"] = boost::any(*schema);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("ModelName") != m.end() && !m["ModelName"].empty()) {
      modelName = make_shared<string>(boost::any_cast<string>(m["ModelName"]));
    }
    if (m.find("NewModelName") != m.end() && !m["NewModelName"].empty()) {
      newModelName = make_shared<string>(boost::any_cast<string>(m["NewModelName"]));
    }
    if (m.find("Schema") != m.end() && !m["Schema"].empty()) {
      schema = make_shared<string>(boost::any_cast<string>(m["Schema"]));
    }
  }


  virtual ~ModifyModelRequest() = default;
};
class ModifyModelResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyModelResponseBody() {}

  explicit ModifyModelResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyModelResponseBody() = default;
};
class ModifyModelResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyModelResponseBody> body{};

  ModifyModelResponse() {}

  explicit ModifyModelResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyModelResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyModelResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyModelResponse() = default;
};
class ModifyPluginRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  ModifyPluginRequestTag() {}

  explicit ModifyPluginRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~ModifyPluginRequestTag() = default;
};
class ModifyPluginRequest : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> pluginData{};
  shared_ptr<string> pluginId{};
  shared_ptr<string> pluginName{};
  shared_ptr<string> securityToken{};
  shared_ptr<vector<ModifyPluginRequestTag>> tag{};

  ModifyPluginRequest() {}

  explicit ModifyPluginRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (pluginData) {
      res["PluginData"] = boost::any(*pluginData);
    }
    if (pluginId) {
      res["PluginId"] = boost::any(*pluginId);
    }
    if (pluginName) {
      res["PluginName"] = boost::any(*pluginName);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("PluginData") != m.end() && !m["PluginData"].empty()) {
      pluginData = make_shared<string>(boost::any_cast<string>(m["PluginData"]));
    }
    if (m.find("PluginId") != m.end() && !m["PluginId"].empty()) {
      pluginId = make_shared<string>(boost::any_cast<string>(m["PluginId"]));
    }
    if (m.find("PluginName") != m.end() && !m["PluginName"].empty()) {
      pluginName = make_shared<string>(boost::any_cast<string>(m["PluginName"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<ModifyPluginRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ModifyPluginRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<ModifyPluginRequestTag>>(expect1);
      }
    }
  }


  virtual ~ModifyPluginRequest() = default;
};
class ModifyPluginResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyPluginResponseBody() {}

  explicit ModifyPluginResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyPluginResponseBody() = default;
};
class ModifyPluginResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyPluginResponseBody> body{};

  ModifyPluginResponse() {}

  explicit ModifyPluginResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyPluginResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyPluginResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyPluginResponse() = default;
};
class ModifySignatureRequest : public Darabonba::Model {
public:
  shared_ptr<string> securityToken{};
  shared_ptr<string> signatureId{};
  shared_ptr<string> signatureKey{};
  shared_ptr<string> signatureName{};
  shared_ptr<string> signatureSecret{};

  ModifySignatureRequest() {}

  explicit ModifySignatureRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (signatureId) {
      res["SignatureId"] = boost::any(*signatureId);
    }
    if (signatureKey) {
      res["SignatureKey"] = boost::any(*signatureKey);
    }
    if (signatureName) {
      res["SignatureName"] = boost::any(*signatureName);
    }
    if (signatureSecret) {
      res["SignatureSecret"] = boost::any(*signatureSecret);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("SignatureId") != m.end() && !m["SignatureId"].empty()) {
      signatureId = make_shared<string>(boost::any_cast<string>(m["SignatureId"]));
    }
    if (m.find("SignatureKey") != m.end() && !m["SignatureKey"].empty()) {
      signatureKey = make_shared<string>(boost::any_cast<string>(m["SignatureKey"]));
    }
    if (m.find("SignatureName") != m.end() && !m["SignatureName"].empty()) {
      signatureName = make_shared<string>(boost::any_cast<string>(m["SignatureName"]));
    }
    if (m.find("SignatureSecret") != m.end() && !m["SignatureSecret"].empty()) {
      signatureSecret = make_shared<string>(boost::any_cast<string>(m["SignatureSecret"]));
    }
  }


  virtual ~ModifySignatureRequest() = default;
};
class ModifySignatureResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> signatureId{};
  shared_ptr<string> signatureName{};

  ModifySignatureResponseBody() {}

  explicit ModifySignatureResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (signatureId) {
      res["SignatureId"] = boost::any(*signatureId);
    }
    if (signatureName) {
      res["SignatureName"] = boost::any(*signatureName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SignatureId") != m.end() && !m["SignatureId"].empty()) {
      signatureId = make_shared<string>(boost::any_cast<string>(m["SignatureId"]));
    }
    if (m.find("SignatureName") != m.end() && !m["SignatureName"].empty()) {
      signatureName = make_shared<string>(boost::any_cast<string>(m["SignatureName"]));
    }
  }


  virtual ~ModifySignatureResponseBody() = default;
};
class ModifySignatureResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifySignatureResponseBody> body{};

  ModifySignatureResponse() {}

  explicit ModifySignatureResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifySignatureResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifySignatureResponseBody>(model1);
      }
    }
  }


  virtual ~ModifySignatureResponse() = default;
};
class ModifyTrafficControlRequest : public Darabonba::Model {
public:
  shared_ptr<long> apiDefault{};
  shared_ptr<long> appDefault{};
  shared_ptr<string> description{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> trafficControlId{};
  shared_ptr<string> trafficControlName{};
  shared_ptr<string> trafficControlUnit{};
  shared_ptr<long> userDefault{};

  ModifyTrafficControlRequest() {}

  explicit ModifyTrafficControlRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiDefault) {
      res["ApiDefault"] = boost::any(*apiDefault);
    }
    if (appDefault) {
      res["AppDefault"] = boost::any(*appDefault);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (trafficControlId) {
      res["TrafficControlId"] = boost::any(*trafficControlId);
    }
    if (trafficControlName) {
      res["TrafficControlName"] = boost::any(*trafficControlName);
    }
    if (trafficControlUnit) {
      res["TrafficControlUnit"] = boost::any(*trafficControlUnit);
    }
    if (userDefault) {
      res["UserDefault"] = boost::any(*userDefault);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiDefault") != m.end() && !m["ApiDefault"].empty()) {
      apiDefault = make_shared<long>(boost::any_cast<long>(m["ApiDefault"]));
    }
    if (m.find("AppDefault") != m.end() && !m["AppDefault"].empty()) {
      appDefault = make_shared<long>(boost::any_cast<long>(m["AppDefault"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("TrafficControlId") != m.end() && !m["TrafficControlId"].empty()) {
      trafficControlId = make_shared<string>(boost::any_cast<string>(m["TrafficControlId"]));
    }
    if (m.find("TrafficControlName") != m.end() && !m["TrafficControlName"].empty()) {
      trafficControlName = make_shared<string>(boost::any_cast<string>(m["TrafficControlName"]));
    }
    if (m.find("TrafficControlUnit") != m.end() && !m["TrafficControlUnit"].empty()) {
      trafficControlUnit = make_shared<string>(boost::any_cast<string>(m["TrafficControlUnit"]));
    }
    if (m.find("UserDefault") != m.end() && !m["UserDefault"].empty()) {
      userDefault = make_shared<long>(boost::any_cast<long>(m["UserDefault"]));
    }
  }


  virtual ~ModifyTrafficControlRequest() = default;
};
class ModifyTrafficControlResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyTrafficControlResponseBody() {}

  explicit ModifyTrafficControlResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyTrafficControlResponseBody() = default;
};
class ModifyTrafficControlResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyTrafficControlResponseBody> body{};

  ModifyTrafficControlResponse() {}

  explicit ModifyTrafficControlResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyTrafficControlResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyTrafficControlResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyTrafficControlResponse() = default;
};
class ModifyVpcAccessAndUpdateApisRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> name{};
  shared_ptr<bool> needBatchWork{};
  shared_ptr<long> port{};
  shared_ptr<bool> refresh{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> token{};
  shared_ptr<string> vpcId{};
  shared_ptr<string> vpcTargetHostName{};

  ModifyVpcAccessAndUpdateApisRequest() {}

  explicit ModifyVpcAccessAndUpdateApisRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (needBatchWork) {
      res["NeedBatchWork"] = boost::any(*needBatchWork);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (refresh) {
      res["Refresh"] = boost::any(*refresh);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (token) {
      res["Token"] = boost::any(*token);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    if (vpcTargetHostName) {
      res["VpcTargetHostName"] = boost::any(*vpcTargetHostName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("NeedBatchWork") != m.end() && !m["NeedBatchWork"].empty()) {
      needBatchWork = make_shared<bool>(boost::any_cast<bool>(m["NeedBatchWork"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<long>(boost::any_cast<long>(m["Port"]));
    }
    if (m.find("Refresh") != m.end() && !m["Refresh"].empty()) {
      refresh = make_shared<bool>(boost::any_cast<bool>(m["Refresh"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("Token") != m.end() && !m["Token"].empty()) {
      token = make_shared<string>(boost::any_cast<string>(m["Token"]));
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
    if (m.find("VpcTargetHostName") != m.end() && !m["VpcTargetHostName"].empty()) {
      vpcTargetHostName = make_shared<string>(boost::any_cast<string>(m["VpcTargetHostName"]));
    }
  }


  virtual ~ModifyVpcAccessAndUpdateApisRequest() = default;
};
class ModifyVpcAccessAndUpdateApisResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> operationId{};
  shared_ptr<string> requestId{};

  ModifyVpcAccessAndUpdateApisResponseBody() {}

  explicit ModifyVpcAccessAndUpdateApisResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (operationId) {
      res["OperationId"] = boost::any(*operationId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OperationId") != m.end() && !m["OperationId"].empty()) {
      operationId = make_shared<string>(boost::any_cast<string>(m["OperationId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyVpcAccessAndUpdateApisResponseBody() = default;
};
class ModifyVpcAccessAndUpdateApisResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyVpcAccessAndUpdateApisResponseBody> body{};

  ModifyVpcAccessAndUpdateApisResponse() {}

  explicit ModifyVpcAccessAndUpdateApisResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyVpcAccessAndUpdateApisResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyVpcAccessAndUpdateApisResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyVpcAccessAndUpdateApisResponse() = default;
};
class OpenApiGatewayServiceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> orderId{};
  shared_ptr<string> requestId{};

  OpenApiGatewayServiceResponseBody() {}

  explicit OpenApiGatewayServiceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (orderId) {
      res["OrderId"] = boost::any(*orderId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OrderId") != m.end() && !m["OrderId"].empty()) {
      orderId = make_shared<string>(boost::any_cast<string>(m["OrderId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~OpenApiGatewayServiceResponseBody() = default;
};
class OpenApiGatewayServiceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<OpenApiGatewayServiceResponseBody> body{};

  OpenApiGatewayServiceResponse() {}

  explicit OpenApiGatewayServiceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        OpenApiGatewayServiceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<OpenApiGatewayServiceResponseBody>(model1);
      }
    }
  }


  virtual ~OpenApiGatewayServiceResponse() = default;
};
class QueryRequestLogsRequest : public Darabonba::Model {
public:
  shared_ptr<string> requestLogId{};
  shared_ptr<string> securityToken{};

  QueryRequestLogsRequest() {}

  explicit QueryRequestLogsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestLogId) {
      res["RequestLogId"] = boost::any(*requestLogId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestLogId") != m.end() && !m["RequestLogId"].empty()) {
      requestLogId = make_shared<string>(boost::any_cast<string>(m["RequestLogId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~QueryRequestLogsRequest() = default;
};
class QueryRequestLogsResponseBodyRequestLogsRequestLog : public Darabonba::Model {
public:
  shared_ptr<string> apiId{};
  shared_ptr<string> apiName{};
  shared_ptr<string> appName{};
  shared_ptr<long> backendRequestEnd{};
  shared_ptr<long> backendRequestStart{};
  shared_ptr<long> backendResponseEnd{};
  shared_ptr<long> backendResponseStart{};
  shared_ptr<string> clientIp{};
  shared_ptr<string> clientNonce{};
  shared_ptr<string> consumerAppId{};
  shared_ptr<string> consumerAppKey{};
  shared_ptr<string> customTraceId{};
  shared_ptr<string> domain{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> exception{};
  shared_ptr<long> frontRequestEnd{};
  shared_ptr<long> frontRequestStart{};
  shared_ptr<long> frontResponseEnd{};
  shared_ptr<long> frontResponseStart{};
  shared_ptr<string> groupId{};
  shared_ptr<string> groupName{};
  shared_ptr<string> httpMethod{};
  shared_ptr<string> httpPath{};
  shared_ptr<string> initialRequestId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> jwtClaims{};
  shared_ptr<string> region{};
  shared_ptr<string> requestBody{};
  shared_ptr<string> requestHeaders{};
  shared_ptr<string> requestId{};
  shared_ptr<string> requestProtocol{};
  shared_ptr<string> requestQueryString{};
  shared_ptr<string> requestSize{};
  shared_ptr<string> requestTime{};
  shared_ptr<string> responseBody{};
  shared_ptr<string> responseHeaders{};
  shared_ptr<string> responseSize{};
  shared_ptr<string> serviceLatency{};
  shared_ptr<string> stageId{};
  shared_ptr<string> stageName{};
  shared_ptr<string> statusCode{};
  shared_ptr<string> totalLatency{};
  shared_ptr<string> plugin{};

  QueryRequestLogsResponseBodyRequestLogsRequestLog() {}

  explicit QueryRequestLogsResponseBodyRequestLogsRequestLog(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiId) {
      res["ApiId"] = boost::any(*apiId);
    }
    if (apiName) {
      res["ApiName"] = boost::any(*apiName);
    }
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (backendRequestEnd) {
      res["BackendRequestEnd"] = boost::any(*backendRequestEnd);
    }
    if (backendRequestStart) {
      res["BackendRequestStart"] = boost::any(*backendRequestStart);
    }
    if (backendResponseEnd) {
      res["BackendResponseEnd"] = boost::any(*backendResponseEnd);
    }
    if (backendResponseStart) {
      res["BackendResponseStart"] = boost::any(*backendResponseStart);
    }
    if (clientIp) {
      res["ClientIp"] = boost::any(*clientIp);
    }
    if (clientNonce) {
      res["ClientNonce"] = boost::any(*clientNonce);
    }
    if (consumerAppId) {
      res["ConsumerAppId"] = boost::any(*consumerAppId);
    }
    if (consumerAppKey) {
      res["ConsumerAppKey"] = boost::any(*consumerAppKey);
    }
    if (customTraceId) {
      res["CustomTraceId"] = boost::any(*customTraceId);
    }
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (exception) {
      res["Exception"] = boost::any(*exception);
    }
    if (frontRequestEnd) {
      res["FrontRequestEnd"] = boost::any(*frontRequestEnd);
    }
    if (frontRequestStart) {
      res["FrontRequestStart"] = boost::any(*frontRequestStart);
    }
    if (frontResponseEnd) {
      res["FrontResponseEnd"] = boost::any(*frontResponseEnd);
    }
    if (frontResponseStart) {
      res["FrontResponseStart"] = boost::any(*frontResponseStart);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (groupName) {
      res["GroupName"] = boost::any(*groupName);
    }
    if (httpMethod) {
      res["HttpMethod"] = boost::any(*httpMethod);
    }
    if (httpPath) {
      res["HttpPath"] = boost::any(*httpPath);
    }
    if (initialRequestId) {
      res["InitialRequestId"] = boost::any(*initialRequestId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (jwtClaims) {
      res["JwtClaims"] = boost::any(*jwtClaims);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (requestBody) {
      res["RequestBody"] = boost::any(*requestBody);
    }
    if (requestHeaders) {
      res["RequestHeaders"] = boost::any(*requestHeaders);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (requestProtocol) {
      res["RequestProtocol"] = boost::any(*requestProtocol);
    }
    if (requestQueryString) {
      res["RequestQueryString"] = boost::any(*requestQueryString);
    }
    if (requestSize) {
      res["RequestSize"] = boost::any(*requestSize);
    }
    if (requestTime) {
      res["RequestTime"] = boost::any(*requestTime);
    }
    if (responseBody) {
      res["ResponseBody"] = boost::any(*responseBody);
    }
    if (responseHeaders) {
      res["ResponseHeaders"] = boost::any(*responseHeaders);
    }
    if (responseSize) {
      res["ResponseSize"] = boost::any(*responseSize);
    }
    if (serviceLatency) {
      res["ServiceLatency"] = boost::any(*serviceLatency);
    }
    if (stageId) {
      res["StageId"] = boost::any(*stageId);
    }
    if (stageName) {
      res["StageName"] = boost::any(*stageName);
    }
    if (statusCode) {
      res["StatusCode"] = boost::any(*statusCode);
    }
    if (totalLatency) {
      res["TotalLatency"] = boost::any(*totalLatency);
    }
    if (plugin) {
      res["plugin"] = boost::any(*plugin);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiId") != m.end() && !m["ApiId"].empty()) {
      apiId = make_shared<string>(boost::any_cast<string>(m["ApiId"]));
    }
    if (m.find("ApiName") != m.end() && !m["ApiName"].empty()) {
      apiName = make_shared<string>(boost::any_cast<string>(m["ApiName"]));
    }
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("BackendRequestEnd") != m.end() && !m["BackendRequestEnd"].empty()) {
      backendRequestEnd = make_shared<long>(boost::any_cast<long>(m["BackendRequestEnd"]));
    }
    if (m.find("BackendRequestStart") != m.end() && !m["BackendRequestStart"].empty()) {
      backendRequestStart = make_shared<long>(boost::any_cast<long>(m["BackendRequestStart"]));
    }
    if (m.find("BackendResponseEnd") != m.end() && !m["BackendResponseEnd"].empty()) {
      backendResponseEnd = make_shared<long>(boost::any_cast<long>(m["BackendResponseEnd"]));
    }
    if (m.find("BackendResponseStart") != m.end() && !m["BackendResponseStart"].empty()) {
      backendResponseStart = make_shared<long>(boost::any_cast<long>(m["BackendResponseStart"]));
    }
    if (m.find("ClientIp") != m.end() && !m["ClientIp"].empty()) {
      clientIp = make_shared<string>(boost::any_cast<string>(m["ClientIp"]));
    }
    if (m.find("ClientNonce") != m.end() && !m["ClientNonce"].empty()) {
      clientNonce = make_shared<string>(boost::any_cast<string>(m["ClientNonce"]));
    }
    if (m.find("ConsumerAppId") != m.end() && !m["ConsumerAppId"].empty()) {
      consumerAppId = make_shared<string>(boost::any_cast<string>(m["ConsumerAppId"]));
    }
    if (m.find("ConsumerAppKey") != m.end() && !m["ConsumerAppKey"].empty()) {
      consumerAppKey = make_shared<string>(boost::any_cast<string>(m["ConsumerAppKey"]));
    }
    if (m.find("CustomTraceId") != m.end() && !m["CustomTraceId"].empty()) {
      customTraceId = make_shared<string>(boost::any_cast<string>(m["CustomTraceId"]));
    }
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Exception") != m.end() && !m["Exception"].empty()) {
      exception = make_shared<string>(boost::any_cast<string>(m["Exception"]));
    }
    if (m.find("FrontRequestEnd") != m.end() && !m["FrontRequestEnd"].empty()) {
      frontRequestEnd = make_shared<long>(boost::any_cast<long>(m["FrontRequestEnd"]));
    }
    if (m.find("FrontRequestStart") != m.end() && !m["FrontRequestStart"].empty()) {
      frontRequestStart = make_shared<long>(boost::any_cast<long>(m["FrontRequestStart"]));
    }
    if (m.find("FrontResponseEnd") != m.end() && !m["FrontResponseEnd"].empty()) {
      frontResponseEnd = make_shared<long>(boost::any_cast<long>(m["FrontResponseEnd"]));
    }
    if (m.find("FrontResponseStart") != m.end() && !m["FrontResponseStart"].empty()) {
      frontResponseStart = make_shared<long>(boost::any_cast<long>(m["FrontResponseStart"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("GroupName") != m.end() && !m["GroupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["GroupName"]));
    }
    if (m.find("HttpMethod") != m.end() && !m["HttpMethod"].empty()) {
      httpMethod = make_shared<string>(boost::any_cast<string>(m["HttpMethod"]));
    }
    if (m.find("HttpPath") != m.end() && !m["HttpPath"].empty()) {
      httpPath = make_shared<string>(boost::any_cast<string>(m["HttpPath"]));
    }
    if (m.find("InitialRequestId") != m.end() && !m["InitialRequestId"].empty()) {
      initialRequestId = make_shared<string>(boost::any_cast<string>(m["InitialRequestId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("JwtClaims") != m.end() && !m["JwtClaims"].empty()) {
      jwtClaims = make_shared<string>(boost::any_cast<string>(m["JwtClaims"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("RequestBody") != m.end() && !m["RequestBody"].empty()) {
      requestBody = make_shared<string>(boost::any_cast<string>(m["RequestBody"]));
    }
    if (m.find("RequestHeaders") != m.end() && !m["RequestHeaders"].empty()) {
      requestHeaders = make_shared<string>(boost::any_cast<string>(m["RequestHeaders"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("RequestProtocol") != m.end() && !m["RequestProtocol"].empty()) {
      requestProtocol = make_shared<string>(boost::any_cast<string>(m["RequestProtocol"]));
    }
    if (m.find("RequestQueryString") != m.end() && !m["RequestQueryString"].empty()) {
      requestQueryString = make_shared<string>(boost::any_cast<string>(m["RequestQueryString"]));
    }
    if (m.find("RequestSize") != m.end() && !m["RequestSize"].empty()) {
      requestSize = make_shared<string>(boost::any_cast<string>(m["RequestSize"]));
    }
    if (m.find("RequestTime") != m.end() && !m["RequestTime"].empty()) {
      requestTime = make_shared<string>(boost::any_cast<string>(m["RequestTime"]));
    }
    if (m.find("ResponseBody") != m.end() && !m["ResponseBody"].empty()) {
      responseBody = make_shared<string>(boost::any_cast<string>(m["ResponseBody"]));
    }
    if (m.find("ResponseHeaders") != m.end() && !m["ResponseHeaders"].empty()) {
      responseHeaders = make_shared<string>(boost::any_cast<string>(m["ResponseHeaders"]));
    }
    if (m.find("ResponseSize") != m.end() && !m["ResponseSize"].empty()) {
      responseSize = make_shared<string>(boost::any_cast<string>(m["ResponseSize"]));
    }
    if (m.find("ServiceLatency") != m.end() && !m["ServiceLatency"].empty()) {
      serviceLatency = make_shared<string>(boost::any_cast<string>(m["ServiceLatency"]));
    }
    if (m.find("StageId") != m.end() && !m["StageId"].empty()) {
      stageId = make_shared<string>(boost::any_cast<string>(m["StageId"]));
    }
    if (m.find("StageName") != m.end() && !m["StageName"].empty()) {
      stageName = make_shared<string>(boost::any_cast<string>(m["StageName"]));
    }
    if (m.find("StatusCode") != m.end() && !m["StatusCode"].empty()) {
      statusCode = make_shared<string>(boost::any_cast<string>(m["StatusCode"]));
    }
    if (m.find("TotalLatency") != m.end() && !m["TotalLatency"].empty()) {
      totalLatency = make_shared<string>(boost::any_cast<string>(m["TotalLatency"]));
    }
    if (m.find("plugin") != m.end() && !m["plugin"].empty()) {
      plugin = make_shared<string>(boost::any_cast<string>(m["plugin"]));
    }
  }


  virtual ~QueryRequestLogsResponseBodyRequestLogsRequestLog() = default;
};
class QueryRequestLogsResponseBodyRequestLogs : public Darabonba::Model {
public:
  shared_ptr<vector<QueryRequestLogsResponseBodyRequestLogsRequestLog>> requestLog{};

  QueryRequestLogsResponseBodyRequestLogs() {}

  explicit QueryRequestLogsResponseBodyRequestLogs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestLog) {
      vector<boost::any> temp1;
      for(auto item1:*requestLog){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RequestLog"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestLog") != m.end() && !m["RequestLog"].empty()) {
      if (typeid(vector<boost::any>) == m["RequestLog"].type()) {
        vector<QueryRequestLogsResponseBodyRequestLogsRequestLog> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RequestLog"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            QueryRequestLogsResponseBodyRequestLogsRequestLog model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        requestLog = make_shared<vector<QueryRequestLogsResponseBodyRequestLogsRequestLog>>(expect1);
      }
    }
  }


  virtual ~QueryRequestLogsResponseBodyRequestLogs() = default;
};
class QueryRequestLogsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<QueryRequestLogsResponseBodyRequestLogs> requestLogs{};

  QueryRequestLogsResponseBody() {}

  explicit QueryRequestLogsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (requestLogs) {
      res["RequestLogs"] = requestLogs ? boost::any(requestLogs->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("RequestLogs") != m.end() && !m["RequestLogs"].empty()) {
      if (typeid(map<string, boost::any>) == m["RequestLogs"].type()) {
        QueryRequestLogsResponseBodyRequestLogs model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RequestLogs"]));
        requestLogs = make_shared<QueryRequestLogsResponseBodyRequestLogs>(model1);
      }
    }
  }


  virtual ~QueryRequestLogsResponseBody() = default;
};
class QueryRequestLogsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryRequestLogsResponseBody> body{};

  QueryRequestLogsResponse() {}

  explicit QueryRequestLogsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryRequestLogsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryRequestLogsResponseBody>(model1);
      }
    }
  }


  virtual ~QueryRequestLogsResponse() = default;
};
class ReactivateDomainRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> groupId{};
  shared_ptr<string> securityToken{};

  ReactivateDomainRequest() {}

  explicit ReactivateDomainRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~ReactivateDomainRequest() = default;
};
class ReactivateDomainResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ReactivateDomainResponseBody() {}

  explicit ReactivateDomainResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ReactivateDomainResponseBody() = default;
};
class ReactivateDomainResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ReactivateDomainResponseBody> body{};

  ReactivateDomainResponse() {}

  explicit ReactivateDomainResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ReactivateDomainResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ReactivateDomainResponseBody>(model1);
      }
    }
  }


  virtual ~ReactivateDomainResponse() = default;
};
class RemoveAccessControlListEntryRequest : public Darabonba::Model {
public:
  shared_ptr<string> aclEntrys{};
  shared_ptr<string> aclId{};
  shared_ptr<string> securityToken{};

  RemoveAccessControlListEntryRequest() {}

  explicit RemoveAccessControlListEntryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aclEntrys) {
      res["AclEntrys"] = boost::any(*aclEntrys);
    }
    if (aclId) {
      res["AclId"] = boost::any(*aclId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AclEntrys") != m.end() && !m["AclEntrys"].empty()) {
      aclEntrys = make_shared<string>(boost::any_cast<string>(m["AclEntrys"]));
    }
    if (m.find("AclId") != m.end() && !m["AclId"].empty()) {
      aclId = make_shared<string>(boost::any_cast<string>(m["AclId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~RemoveAccessControlListEntryRequest() = default;
};
class RemoveAccessControlListEntryResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  RemoveAccessControlListEntryResponseBody() {}

  explicit RemoveAccessControlListEntryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RemoveAccessControlListEntryResponseBody() = default;
};
class RemoveAccessControlListEntryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RemoveAccessControlListEntryResponseBody> body{};

  RemoveAccessControlListEntryResponse() {}

  explicit RemoveAccessControlListEntryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RemoveAccessControlListEntryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RemoveAccessControlListEntryResponseBody>(model1);
      }
    }
  }


  virtual ~RemoveAccessControlListEntryResponse() = default;
};
class RemoveApiProductsAuthoritiesRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> apiProductIds{};
  shared_ptr<long> appId{};
  shared_ptr<string> securityToken{};

  RemoveApiProductsAuthoritiesRequest() {}

  explicit RemoveApiProductsAuthoritiesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiProductIds) {
      res["ApiProductIds"] = boost::any(*apiProductIds);
    }
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiProductIds") != m.end() && !m["ApiProductIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ApiProductIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ApiProductIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      apiProductIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<long>(boost::any_cast<long>(m["AppId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~RemoveApiProductsAuthoritiesRequest() = default;
};
class RemoveApiProductsAuthoritiesShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> apiProductIdsShrink{};
  shared_ptr<long> appId{};
  shared_ptr<string> securityToken{};

  RemoveApiProductsAuthoritiesShrinkRequest() {}

  explicit RemoveApiProductsAuthoritiesShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiProductIdsShrink) {
      res["ApiProductIds"] = boost::any(*apiProductIdsShrink);
    }
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiProductIds") != m.end() && !m["ApiProductIds"].empty()) {
      apiProductIdsShrink = make_shared<string>(boost::any_cast<string>(m["ApiProductIds"]));
    }
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<long>(boost::any_cast<long>(m["AppId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~RemoveApiProductsAuthoritiesShrinkRequest() = default;
};
class RemoveApiProductsAuthoritiesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  RemoveApiProductsAuthoritiesResponseBody() {}

  explicit RemoveApiProductsAuthoritiesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RemoveApiProductsAuthoritiesResponseBody() = default;
};
class RemoveApiProductsAuthoritiesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RemoveApiProductsAuthoritiesResponseBody> body{};

  RemoveApiProductsAuthoritiesResponse() {}

  explicit RemoveApiProductsAuthoritiesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RemoveApiProductsAuthoritiesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RemoveApiProductsAuthoritiesResponseBody>(model1);
      }
    }
  }


  virtual ~RemoveApiProductsAuthoritiesResponse() = default;
};
class RemoveApisAuthoritiesRequest : public Darabonba::Model {
public:
  shared_ptr<string> apiIds{};
  shared_ptr<long> appId{};
  shared_ptr<string> description{};
  shared_ptr<string> groupId{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> stageName{};

  RemoveApisAuthoritiesRequest() {}

  explicit RemoveApisAuthoritiesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiIds) {
      res["ApiIds"] = boost::any(*apiIds);
    }
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (stageName) {
      res["StageName"] = boost::any(*stageName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiIds") != m.end() && !m["ApiIds"].empty()) {
      apiIds = make_shared<string>(boost::any_cast<string>(m["ApiIds"]));
    }
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<long>(boost::any_cast<long>(m["AppId"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("StageName") != m.end() && !m["StageName"].empty()) {
      stageName = make_shared<string>(boost::any_cast<string>(m["StageName"]));
    }
  }


  virtual ~RemoveApisAuthoritiesRequest() = default;
};
class RemoveApisAuthoritiesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  RemoveApisAuthoritiesResponseBody() {}

  explicit RemoveApisAuthoritiesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RemoveApisAuthoritiesResponseBody() = default;
};
class RemoveApisAuthoritiesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RemoveApisAuthoritiesResponseBody> body{};

  RemoveApisAuthoritiesResponse() {}

  explicit RemoveApisAuthoritiesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RemoveApisAuthoritiesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RemoveApisAuthoritiesResponseBody>(model1);
      }
    }
  }


  virtual ~RemoveApisAuthoritiesResponse() = default;
};
class RemoveAppsAuthoritiesRequest : public Darabonba::Model {
public:
  shared_ptr<string> apiId{};
  shared_ptr<string> appIds{};
  shared_ptr<string> groupId{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> stageName{};

  RemoveAppsAuthoritiesRequest() {}

  explicit RemoveAppsAuthoritiesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiId) {
      res["ApiId"] = boost::any(*apiId);
    }
    if (appIds) {
      res["AppIds"] = boost::any(*appIds);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (stageName) {
      res["StageName"] = boost::any(*stageName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiId") != m.end() && !m["ApiId"].empty()) {
      apiId = make_shared<string>(boost::any_cast<string>(m["ApiId"]));
    }
    if (m.find("AppIds") != m.end() && !m["AppIds"].empty()) {
      appIds = make_shared<string>(boost::any_cast<string>(m["AppIds"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("StageName") != m.end() && !m["StageName"].empty()) {
      stageName = make_shared<string>(boost::any_cast<string>(m["StageName"]));
    }
  }


  virtual ~RemoveAppsAuthoritiesRequest() = default;
};
class RemoveAppsAuthoritiesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  RemoveAppsAuthoritiesResponseBody() {}

  explicit RemoveAppsAuthoritiesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RemoveAppsAuthoritiesResponseBody() = default;
};
class RemoveAppsAuthoritiesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RemoveAppsAuthoritiesResponseBody> body{};

  RemoveAppsAuthoritiesResponse() {}

  explicit RemoveAppsAuthoritiesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RemoveAppsAuthoritiesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RemoveAppsAuthoritiesResponseBody>(model1);
      }
    }
  }


  virtual ~RemoveAppsAuthoritiesResponse() = default;
};
class RemoveIpControlApisRequest : public Darabonba::Model {
public:
  shared_ptr<string> apiIds{};
  shared_ptr<string> groupId{};
  shared_ptr<string> ipControlId{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> stageName{};

  RemoveIpControlApisRequest() {}

  explicit RemoveIpControlApisRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiIds) {
      res["ApiIds"] = boost::any(*apiIds);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (ipControlId) {
      res["IpControlId"] = boost::any(*ipControlId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (stageName) {
      res["StageName"] = boost::any(*stageName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiIds") != m.end() && !m["ApiIds"].empty()) {
      apiIds = make_shared<string>(boost::any_cast<string>(m["ApiIds"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("IpControlId") != m.end() && !m["IpControlId"].empty()) {
      ipControlId = make_shared<string>(boost::any_cast<string>(m["IpControlId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("StageName") != m.end() && !m["StageName"].empty()) {
      stageName = make_shared<string>(boost::any_cast<string>(m["StageName"]));
    }
  }


  virtual ~RemoveIpControlApisRequest() = default;
};
class RemoveIpControlApisResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  RemoveIpControlApisResponseBody() {}

  explicit RemoveIpControlApisResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RemoveIpControlApisResponseBody() = default;
};
class RemoveIpControlApisResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RemoveIpControlApisResponseBody> body{};

  RemoveIpControlApisResponse() {}

  explicit RemoveIpControlApisResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RemoveIpControlApisResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RemoveIpControlApisResponseBody>(model1);
      }
    }
  }


  virtual ~RemoveIpControlApisResponse() = default;
};
class RemoveIpControlPolicyItemRequest : public Darabonba::Model {
public:
  shared_ptr<string> ipControlId{};
  shared_ptr<string> policyItemIds{};
  shared_ptr<string> securityToken{};

  RemoveIpControlPolicyItemRequest() {}

  explicit RemoveIpControlPolicyItemRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ipControlId) {
      res["IpControlId"] = boost::any(*ipControlId);
    }
    if (policyItemIds) {
      res["PolicyItemIds"] = boost::any(*policyItemIds);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IpControlId") != m.end() && !m["IpControlId"].empty()) {
      ipControlId = make_shared<string>(boost::any_cast<string>(m["IpControlId"]));
    }
    if (m.find("PolicyItemIds") != m.end() && !m["PolicyItemIds"].empty()) {
      policyItemIds = make_shared<string>(boost::any_cast<string>(m["PolicyItemIds"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~RemoveIpControlPolicyItemRequest() = default;
};
class RemoveIpControlPolicyItemResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  RemoveIpControlPolicyItemResponseBody() {}

  explicit RemoveIpControlPolicyItemResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RemoveIpControlPolicyItemResponseBody() = default;
};
class RemoveIpControlPolicyItemResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RemoveIpControlPolicyItemResponseBody> body{};

  RemoveIpControlPolicyItemResponse() {}

  explicit RemoveIpControlPolicyItemResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RemoveIpControlPolicyItemResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RemoveIpControlPolicyItemResponseBody>(model1);
      }
    }
  }


  virtual ~RemoveIpControlPolicyItemResponse() = default;
};
class RemoveSignatureApisRequest : public Darabonba::Model {
public:
  shared_ptr<string> apiIds{};
  shared_ptr<string> groupId{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> signatureId{};
  shared_ptr<string> stageName{};

  RemoveSignatureApisRequest() {}

  explicit RemoveSignatureApisRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiIds) {
      res["ApiIds"] = boost::any(*apiIds);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (signatureId) {
      res["SignatureId"] = boost::any(*signatureId);
    }
    if (stageName) {
      res["StageName"] = boost::any(*stageName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiIds") != m.end() && !m["ApiIds"].empty()) {
      apiIds = make_shared<string>(boost::any_cast<string>(m["ApiIds"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("SignatureId") != m.end() && !m["SignatureId"].empty()) {
      signatureId = make_shared<string>(boost::any_cast<string>(m["SignatureId"]));
    }
    if (m.find("StageName") != m.end() && !m["StageName"].empty()) {
      stageName = make_shared<string>(boost::any_cast<string>(m["StageName"]));
    }
  }


  virtual ~RemoveSignatureApisRequest() = default;
};
class RemoveSignatureApisResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  RemoveSignatureApisResponseBody() {}

  explicit RemoveSignatureApisResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RemoveSignatureApisResponseBody() = default;
};
class RemoveSignatureApisResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RemoveSignatureApisResponseBody> body{};

  RemoveSignatureApisResponse() {}

  explicit RemoveSignatureApisResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RemoveSignatureApisResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RemoveSignatureApisResponseBody>(model1);
      }
    }
  }


  virtual ~RemoveSignatureApisResponse() = default;
};
class RemoveTrafficControlApisRequest : public Darabonba::Model {
public:
  shared_ptr<string> apiIds{};
  shared_ptr<string> groupId{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> stageName{};
  shared_ptr<string> trafficControlId{};

  RemoveTrafficControlApisRequest() {}

  explicit RemoveTrafficControlApisRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiIds) {
      res["ApiIds"] = boost::any(*apiIds);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (stageName) {
      res["StageName"] = boost::any(*stageName);
    }
    if (trafficControlId) {
      res["TrafficControlId"] = boost::any(*trafficControlId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiIds") != m.end() && !m["ApiIds"].empty()) {
      apiIds = make_shared<string>(boost::any_cast<string>(m["ApiIds"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("StageName") != m.end() && !m["StageName"].empty()) {
      stageName = make_shared<string>(boost::any_cast<string>(m["StageName"]));
    }
    if (m.find("TrafficControlId") != m.end() && !m["TrafficControlId"].empty()) {
      trafficControlId = make_shared<string>(boost::any_cast<string>(m["TrafficControlId"]));
    }
  }


  virtual ~RemoveTrafficControlApisRequest() = default;
};
class RemoveTrafficControlApisResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  RemoveTrafficControlApisResponseBody() {}

  explicit RemoveTrafficControlApisResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RemoveTrafficControlApisResponseBody() = default;
};
class RemoveTrafficControlApisResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RemoveTrafficControlApisResponseBody> body{};

  RemoveTrafficControlApisResponse() {}

  explicit RemoveTrafficControlApisResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RemoveTrafficControlApisResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RemoveTrafficControlApisResponseBody>(model1);
      }
    }
  }


  virtual ~RemoveTrafficControlApisResponse() = default;
};
class RemoveVpcAccessRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<bool> needBatchWork{};
  shared_ptr<long> port{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> vpcId{};

  RemoveVpcAccessRequest() {}

  explicit RemoveVpcAccessRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (needBatchWork) {
      res["NeedBatchWork"] = boost::any(*needBatchWork);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("NeedBatchWork") != m.end() && !m["NeedBatchWork"].empty()) {
      needBatchWork = make_shared<bool>(boost::any_cast<bool>(m["NeedBatchWork"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<long>(boost::any_cast<long>(m["Port"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
  }


  virtual ~RemoveVpcAccessRequest() = default;
};
class RemoveVpcAccessResponseBodyApisApi : public Darabonba::Model {
public:
  shared_ptr<string> apiId{};
  shared_ptr<string> groupId{};
  shared_ptr<string> stageId{};

  RemoveVpcAccessResponseBodyApisApi() {}

  explicit RemoveVpcAccessResponseBodyApisApi(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiId) {
      res["ApiId"] = boost::any(*apiId);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (stageId) {
      res["StageId"] = boost::any(*stageId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiId") != m.end() && !m["ApiId"].empty()) {
      apiId = make_shared<string>(boost::any_cast<string>(m["ApiId"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("StageId") != m.end() && !m["StageId"].empty()) {
      stageId = make_shared<string>(boost::any_cast<string>(m["StageId"]));
    }
  }


  virtual ~RemoveVpcAccessResponseBodyApisApi() = default;
};
class RemoveVpcAccessResponseBodyApis : public Darabonba::Model {
public:
  shared_ptr<vector<RemoveVpcAccessResponseBodyApisApi>> api{};

  RemoveVpcAccessResponseBodyApis() {}

  explicit RemoveVpcAccessResponseBodyApis(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (api) {
      vector<boost::any> temp1;
      for(auto item1:*api){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Api"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Api") != m.end() && !m["Api"].empty()) {
      if (typeid(vector<boost::any>) == m["Api"].type()) {
        vector<RemoveVpcAccessResponseBodyApisApi> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Api"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            RemoveVpcAccessResponseBodyApisApi model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        api = make_shared<vector<RemoveVpcAccessResponseBodyApisApi>>(expect1);
      }
    }
  }


  virtual ~RemoveVpcAccessResponseBodyApis() = default;
};
class RemoveVpcAccessResponseBody : public Darabonba::Model {
public:
  shared_ptr<RemoveVpcAccessResponseBodyApis> apis{};
  shared_ptr<string> requestId{};

  RemoveVpcAccessResponseBody() {}

  explicit RemoveVpcAccessResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apis) {
      res["Apis"] = apis ? boost::any(apis->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Apis") != m.end() && !m["Apis"].empty()) {
      if (typeid(map<string, boost::any>) == m["Apis"].type()) {
        RemoveVpcAccessResponseBodyApis model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Apis"]));
        apis = make_shared<RemoveVpcAccessResponseBodyApis>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RemoveVpcAccessResponseBody() = default;
};
class RemoveVpcAccessResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RemoveVpcAccessResponseBody> body{};

  RemoveVpcAccessResponse() {}

  explicit RemoveVpcAccessResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RemoveVpcAccessResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RemoveVpcAccessResponseBody>(model1);
      }
    }
  }


  virtual ~RemoveVpcAccessResponse() = default;
};
class RemoveVpcAccessAndAbolishApisRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<bool> needBatchWork{};
  shared_ptr<long> port{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> vpcId{};

  RemoveVpcAccessAndAbolishApisRequest() {}

  explicit RemoveVpcAccessAndAbolishApisRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (needBatchWork) {
      res["NeedBatchWork"] = boost::any(*needBatchWork);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("NeedBatchWork") != m.end() && !m["NeedBatchWork"].empty()) {
      needBatchWork = make_shared<bool>(boost::any_cast<bool>(m["NeedBatchWork"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<long>(boost::any_cast<long>(m["Port"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
  }


  virtual ~RemoveVpcAccessAndAbolishApisRequest() = default;
};
class RemoveVpcAccessAndAbolishApisResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> operationId{};
  shared_ptr<string> requestId{};

  RemoveVpcAccessAndAbolishApisResponseBody() {}

  explicit RemoveVpcAccessAndAbolishApisResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (operationId) {
      res["OperationId"] = boost::any(*operationId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OperationId") != m.end() && !m["OperationId"].empty()) {
      operationId = make_shared<string>(boost::any_cast<string>(m["OperationId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RemoveVpcAccessAndAbolishApisResponseBody() = default;
};
class RemoveVpcAccessAndAbolishApisResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RemoveVpcAccessAndAbolishApisResponseBody> body{};

  RemoveVpcAccessAndAbolishApisResponse() {}

  explicit RemoveVpcAccessAndAbolishApisResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RemoveVpcAccessAndAbolishApisResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RemoveVpcAccessAndAbolishApisResponseBody>(model1);
      }
    }
  }


  virtual ~RemoveVpcAccessAndAbolishApisResponse() = default;
};
class ResetAppCodeRequest : public Darabonba::Model {
public:
  shared_ptr<string> appCode{};
  shared_ptr<string> newAppCode{};
  shared_ptr<string> securityToken{};

  ResetAppCodeRequest() {}

  explicit ResetAppCodeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appCode) {
      res["AppCode"] = boost::any(*appCode);
    }
    if (newAppCode) {
      res["NewAppCode"] = boost::any(*newAppCode);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppCode") != m.end() && !m["AppCode"].empty()) {
      appCode = make_shared<string>(boost::any_cast<string>(m["AppCode"]));
    }
    if (m.find("NewAppCode") != m.end() && !m["NewAppCode"].empty()) {
      newAppCode = make_shared<string>(boost::any_cast<string>(m["NewAppCode"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~ResetAppCodeRequest() = default;
};
class ResetAppCodeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ResetAppCodeResponseBody() {}

  explicit ResetAppCodeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ResetAppCodeResponseBody() = default;
};
class ResetAppCodeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ResetAppCodeResponseBody> body{};

  ResetAppCodeResponse() {}

  explicit ResetAppCodeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ResetAppCodeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ResetAppCodeResponseBody>(model1);
      }
    }
  }


  virtual ~ResetAppCodeResponse() = default;
};
class ResetAppSecretRequest : public Darabonba::Model {
public:
  shared_ptr<string> appKey{};
  shared_ptr<string> newAppKey{};
  shared_ptr<string> newAppSecret{};
  shared_ptr<string> securityToken{};

  ResetAppSecretRequest() {}

  explicit ResetAppSecretRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appKey) {
      res["AppKey"] = boost::any(*appKey);
    }
    if (newAppKey) {
      res["NewAppKey"] = boost::any(*newAppKey);
    }
    if (newAppSecret) {
      res["NewAppSecret"] = boost::any(*newAppSecret);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppKey") != m.end() && !m["AppKey"].empty()) {
      appKey = make_shared<string>(boost::any_cast<string>(m["AppKey"]));
    }
    if (m.find("NewAppKey") != m.end() && !m["NewAppKey"].empty()) {
      newAppKey = make_shared<string>(boost::any_cast<string>(m["NewAppKey"]));
    }
    if (m.find("NewAppSecret") != m.end() && !m["NewAppSecret"].empty()) {
      newAppSecret = make_shared<string>(boost::any_cast<string>(m["NewAppSecret"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~ResetAppSecretRequest() = default;
};
class ResetAppSecretResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ResetAppSecretResponseBody() {}

  explicit ResetAppSecretResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ResetAppSecretResponseBody() = default;
};
class ResetAppSecretResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ResetAppSecretResponseBody> body{};

  ResetAppSecretResponse() {}

  explicit ResetAppSecretResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ResetAppSecretResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ResetAppSecretResponseBody>(model1);
      }
    }
  }


  virtual ~ResetAppSecretResponse() = default;
};
class SdkGenerateByAppRequest : public Darabonba::Model {
public:
  shared_ptr<long> appId{};
  shared_ptr<string> language{};
  shared_ptr<string> securityToken{};

  SdkGenerateByAppRequest() {}

  explicit SdkGenerateByAppRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (language) {
      res["Language"] = boost::any(*language);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<long>(boost::any_cast<long>(m["AppId"]));
    }
    if (m.find("Language") != m.end() && !m["Language"].empty()) {
      language = make_shared<string>(boost::any_cast<string>(m["Language"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~SdkGenerateByAppRequest() = default;
};
class SdkGenerateByAppResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> downloadLink{};
  shared_ptr<string> requestId{};

  SdkGenerateByAppResponseBody() {}

  explicit SdkGenerateByAppResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (downloadLink) {
      res["DownloadLink"] = boost::any(*downloadLink);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DownloadLink") != m.end() && !m["DownloadLink"].empty()) {
      downloadLink = make_shared<string>(boost::any_cast<string>(m["DownloadLink"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SdkGenerateByAppResponseBody() = default;
};
class SdkGenerateByAppResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SdkGenerateByAppResponseBody> body{};

  SdkGenerateByAppResponse() {}

  explicit SdkGenerateByAppResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SdkGenerateByAppResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SdkGenerateByAppResponseBody>(model1);
      }
    }
  }


  virtual ~SdkGenerateByAppResponse() = default;
};
class SdkGenerateByAppForRegionRequest : public Darabonba::Model {
public:
  shared_ptr<long> appId{};
  shared_ptr<string> language{};
  shared_ptr<string> securityToken{};

  SdkGenerateByAppForRegionRequest() {}

  explicit SdkGenerateByAppForRegionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (language) {
      res["Language"] = boost::any(*language);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<long>(boost::any_cast<long>(m["AppId"]));
    }
    if (m.find("Language") != m.end() && !m["Language"].empty()) {
      language = make_shared<string>(boost::any_cast<string>(m["Language"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~SdkGenerateByAppForRegionRequest() = default;
};
class SdkGenerateByAppForRegionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> downloadLink{};
  shared_ptr<string> requestId{};

  SdkGenerateByAppForRegionResponseBody() {}

  explicit SdkGenerateByAppForRegionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (downloadLink) {
      res["DownloadLink"] = boost::any(*downloadLink);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DownloadLink") != m.end() && !m["DownloadLink"].empty()) {
      downloadLink = make_shared<string>(boost::any_cast<string>(m["DownloadLink"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SdkGenerateByAppForRegionResponseBody() = default;
};
class SdkGenerateByAppForRegionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SdkGenerateByAppForRegionResponseBody> body{};

  SdkGenerateByAppForRegionResponse() {}

  explicit SdkGenerateByAppForRegionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SdkGenerateByAppForRegionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SdkGenerateByAppForRegionResponseBody>(model1);
      }
    }
  }


  virtual ~SdkGenerateByAppForRegionResponse() = default;
};
class SdkGenerateByGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> groupId{};
  shared_ptr<string> language{};
  shared_ptr<string> securityToken{};

  SdkGenerateByGroupRequest() {}

  explicit SdkGenerateByGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (language) {
      res["Language"] = boost::any(*language);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("Language") != m.end() && !m["Language"].empty()) {
      language = make_shared<string>(boost::any_cast<string>(m["Language"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~SdkGenerateByGroupRequest() = default;
};
class SdkGenerateByGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> downloadLink{};
  shared_ptr<string> requestId{};

  SdkGenerateByGroupResponseBody() {}

  explicit SdkGenerateByGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (downloadLink) {
      res["DownloadLink"] = boost::any(*downloadLink);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DownloadLink") != m.end() && !m["DownloadLink"].empty()) {
      downloadLink = make_shared<string>(boost::any_cast<string>(m["DownloadLink"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SdkGenerateByGroupResponseBody() = default;
};
class SdkGenerateByGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SdkGenerateByGroupResponseBody> body{};

  SdkGenerateByGroupResponse() {}

  explicit SdkGenerateByGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SdkGenerateByGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SdkGenerateByGroupResponseBody>(model1);
      }
    }
  }


  virtual ~SdkGenerateByGroupResponse() = default;
};
class SetAccessControlListAttributeRequest : public Darabonba::Model {
public:
  shared_ptr<string> aclId{};
  shared_ptr<string> aclName{};
  shared_ptr<string> securityToken{};

  SetAccessControlListAttributeRequest() {}

  explicit SetAccessControlListAttributeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aclId) {
      res["AclId"] = boost::any(*aclId);
    }
    if (aclName) {
      res["AclName"] = boost::any(*aclName);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AclId") != m.end() && !m["AclId"].empty()) {
      aclId = make_shared<string>(boost::any_cast<string>(m["AclId"]));
    }
    if (m.find("AclName") != m.end() && !m["AclName"].empty()) {
      aclName = make_shared<string>(boost::any_cast<string>(m["AclName"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~SetAccessControlListAttributeRequest() = default;
};
class SetAccessControlListAttributeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  SetAccessControlListAttributeResponseBody() {}

  explicit SetAccessControlListAttributeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SetAccessControlListAttributeResponseBody() = default;
};
class SetAccessControlListAttributeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SetAccessControlListAttributeResponseBody> body{};

  SetAccessControlListAttributeResponse() {}

  explicit SetAccessControlListAttributeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SetAccessControlListAttributeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SetAccessControlListAttributeResponseBody>(model1);
      }
    }
  }


  virtual ~SetAccessControlListAttributeResponse() = default;
};
class SetApiProductsAuthoritiesRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> apiProductIds{};
  shared_ptr<long> appId{};
  shared_ptr<string> authValidTime{};
  shared_ptr<string> description{};
  shared_ptr<string> securityToken{};

  SetApiProductsAuthoritiesRequest() {}

  explicit SetApiProductsAuthoritiesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiProductIds) {
      res["ApiProductIds"] = boost::any(*apiProductIds);
    }
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (authValidTime) {
      res["AuthValidTime"] = boost::any(*authValidTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiProductIds") != m.end() && !m["ApiProductIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ApiProductIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ApiProductIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      apiProductIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<long>(boost::any_cast<long>(m["AppId"]));
    }
    if (m.find("AuthValidTime") != m.end() && !m["AuthValidTime"].empty()) {
      authValidTime = make_shared<string>(boost::any_cast<string>(m["AuthValidTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~SetApiProductsAuthoritiesRequest() = default;
};
class SetApiProductsAuthoritiesShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> apiProductIdsShrink{};
  shared_ptr<long> appId{};
  shared_ptr<string> authValidTime{};
  shared_ptr<string> description{};
  shared_ptr<string> securityToken{};

  SetApiProductsAuthoritiesShrinkRequest() {}

  explicit SetApiProductsAuthoritiesShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiProductIdsShrink) {
      res["ApiProductIds"] = boost::any(*apiProductIdsShrink);
    }
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (authValidTime) {
      res["AuthValidTime"] = boost::any(*authValidTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiProductIds") != m.end() && !m["ApiProductIds"].empty()) {
      apiProductIdsShrink = make_shared<string>(boost::any_cast<string>(m["ApiProductIds"]));
    }
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<long>(boost::any_cast<long>(m["AppId"]));
    }
    if (m.find("AuthValidTime") != m.end() && !m["AuthValidTime"].empty()) {
      authValidTime = make_shared<string>(boost::any_cast<string>(m["AuthValidTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~SetApiProductsAuthoritiesShrinkRequest() = default;
};
class SetApiProductsAuthoritiesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  SetApiProductsAuthoritiesResponseBody() {}

  explicit SetApiProductsAuthoritiesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SetApiProductsAuthoritiesResponseBody() = default;
};
class SetApiProductsAuthoritiesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SetApiProductsAuthoritiesResponseBody> body{};

  SetApiProductsAuthoritiesResponse() {}

  explicit SetApiProductsAuthoritiesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SetApiProductsAuthoritiesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SetApiProductsAuthoritiesResponseBody>(model1);
      }
    }
  }


  virtual ~SetApiProductsAuthoritiesResponse() = default;
};
class SetApisAuthoritiesRequest : public Darabonba::Model {
public:
  shared_ptr<string> apiIds{};
  shared_ptr<long> appId{};
  shared_ptr<string> authValidTime{};
  shared_ptr<string> description{};
  shared_ptr<string> groupId{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> stageName{};

  SetApisAuthoritiesRequest() {}

  explicit SetApisAuthoritiesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiIds) {
      res["ApiIds"] = boost::any(*apiIds);
    }
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (authValidTime) {
      res["AuthValidTime"] = boost::any(*authValidTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (stageName) {
      res["StageName"] = boost::any(*stageName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiIds") != m.end() && !m["ApiIds"].empty()) {
      apiIds = make_shared<string>(boost::any_cast<string>(m["ApiIds"]));
    }
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<long>(boost::any_cast<long>(m["AppId"]));
    }
    if (m.find("AuthValidTime") != m.end() && !m["AuthValidTime"].empty()) {
      authValidTime = make_shared<string>(boost::any_cast<string>(m["AuthValidTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("StageName") != m.end() && !m["StageName"].empty()) {
      stageName = make_shared<string>(boost::any_cast<string>(m["StageName"]));
    }
  }


  virtual ~SetApisAuthoritiesRequest() = default;
};
class SetApisAuthoritiesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  SetApisAuthoritiesResponseBody() {}

  explicit SetApisAuthoritiesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SetApisAuthoritiesResponseBody() = default;
};
class SetApisAuthoritiesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SetApisAuthoritiesResponseBody> body{};

  SetApisAuthoritiesResponse() {}

  explicit SetApisAuthoritiesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SetApisAuthoritiesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SetApisAuthoritiesResponseBody>(model1);
      }
    }
  }


  virtual ~SetApisAuthoritiesResponse() = default;
};
class SetAppsAuthToApiProductRequest : public Darabonba::Model {
public:
  shared_ptr<string> apiProductId{};
  shared_ptr<vector<long>> appIds{};
  shared_ptr<string> authValidTime{};
  shared_ptr<string> description{};
  shared_ptr<string> securityToken{};

  SetAppsAuthToApiProductRequest() {}

  explicit SetAppsAuthToApiProductRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiProductId) {
      res["ApiProductId"] = boost::any(*apiProductId);
    }
    if (appIds) {
      res["AppIds"] = boost::any(*appIds);
    }
    if (authValidTime) {
      res["AuthValidTime"] = boost::any(*authValidTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiProductId") != m.end() && !m["ApiProductId"].empty()) {
      apiProductId = make_shared<string>(boost::any_cast<string>(m["ApiProductId"]));
    }
    if (m.find("AppIds") != m.end() && !m["AppIds"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["AppIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["AppIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      appIds = make_shared<vector<long>>(toVec1);
    }
    if (m.find("AuthValidTime") != m.end() && !m["AuthValidTime"].empty()) {
      authValidTime = make_shared<string>(boost::any_cast<string>(m["AuthValidTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~SetAppsAuthToApiProductRequest() = default;
};
class SetAppsAuthToApiProductResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  SetAppsAuthToApiProductResponseBody() {}

  explicit SetAppsAuthToApiProductResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SetAppsAuthToApiProductResponseBody() = default;
};
class SetAppsAuthToApiProductResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SetAppsAuthToApiProductResponseBody> body{};

  SetAppsAuthToApiProductResponse() {}

  explicit SetAppsAuthToApiProductResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SetAppsAuthToApiProductResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SetAppsAuthToApiProductResponseBody>(model1);
      }
    }
  }


  virtual ~SetAppsAuthToApiProductResponse() = default;
};
class SetAppsAuthoritiesRequest : public Darabonba::Model {
public:
  shared_ptr<string> apiId{};
  shared_ptr<string> appIds{};
  shared_ptr<string> authValidTime{};
  shared_ptr<string> description{};
  shared_ptr<string> groupId{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> stageName{};

  SetAppsAuthoritiesRequest() {}

  explicit SetAppsAuthoritiesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiId) {
      res["ApiId"] = boost::any(*apiId);
    }
    if (appIds) {
      res["AppIds"] = boost::any(*appIds);
    }
    if (authValidTime) {
      res["AuthValidTime"] = boost::any(*authValidTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (stageName) {
      res["StageName"] = boost::any(*stageName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiId") != m.end() && !m["ApiId"].empty()) {
      apiId = make_shared<string>(boost::any_cast<string>(m["ApiId"]));
    }
    if (m.find("AppIds") != m.end() && !m["AppIds"].empty()) {
      appIds = make_shared<string>(boost::any_cast<string>(m["AppIds"]));
    }
    if (m.find("AuthValidTime") != m.end() && !m["AuthValidTime"].empty()) {
      authValidTime = make_shared<string>(boost::any_cast<string>(m["AuthValidTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("StageName") != m.end() && !m["StageName"].empty()) {
      stageName = make_shared<string>(boost::any_cast<string>(m["StageName"]));
    }
  }


  virtual ~SetAppsAuthoritiesRequest() = default;
};
class SetAppsAuthoritiesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  SetAppsAuthoritiesResponseBody() {}

  explicit SetAppsAuthoritiesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SetAppsAuthoritiesResponseBody() = default;
};
class SetAppsAuthoritiesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SetAppsAuthoritiesResponseBody> body{};

  SetAppsAuthoritiesResponse() {}

  explicit SetAppsAuthoritiesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SetAppsAuthoritiesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SetAppsAuthoritiesResponseBody>(model1);
      }
    }
  }


  virtual ~SetAppsAuthoritiesResponse() = default;
};
class SetDomainRequest : public Darabonba::Model {
public:
  shared_ptr<string> bindStageName{};
  shared_ptr<string> customDomainType{};
  shared_ptr<string> domainName{};
  shared_ptr<string> groupId{};
  shared_ptr<bool> isForce{};
  shared_ptr<bool> isHttpRedirectToHttps{};

  SetDomainRequest() {}

  explicit SetDomainRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bindStageName) {
      res["BindStageName"] = boost::any(*bindStageName);
    }
    if (customDomainType) {
      res["CustomDomainType"] = boost::any(*customDomainType);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (isForce) {
      res["IsForce"] = boost::any(*isForce);
    }
    if (isHttpRedirectToHttps) {
      res["IsHttpRedirectToHttps"] = boost::any(*isHttpRedirectToHttps);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BindStageName") != m.end() && !m["BindStageName"].empty()) {
      bindStageName = make_shared<string>(boost::any_cast<string>(m["BindStageName"]));
    }
    if (m.find("CustomDomainType") != m.end() && !m["CustomDomainType"].empty()) {
      customDomainType = make_shared<string>(boost::any_cast<string>(m["CustomDomainType"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("IsForce") != m.end() && !m["IsForce"].empty()) {
      isForce = make_shared<bool>(boost::any_cast<bool>(m["IsForce"]));
    }
    if (m.find("IsHttpRedirectToHttps") != m.end() && !m["IsHttpRedirectToHttps"].empty()) {
      isHttpRedirectToHttps = make_shared<bool>(boost::any_cast<bool>(m["IsHttpRedirectToHttps"]));
    }
  }


  virtual ~SetDomainRequest() = default;
};
class SetDomainResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> domainBindingStatus{};
  shared_ptr<string> domainLegalStatus{};
  shared_ptr<string> domainName{};
  shared_ptr<string> domainRemark{};
  shared_ptr<string> domainWebSocketStatus{};
  shared_ptr<string> groupId{};
  shared_ptr<string> requestId{};
  shared_ptr<string> subDomain{};

  SetDomainResponseBody() {}

  explicit SetDomainResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainBindingStatus) {
      res["DomainBindingStatus"] = boost::any(*domainBindingStatus);
    }
    if (domainLegalStatus) {
      res["DomainLegalStatus"] = boost::any(*domainLegalStatus);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (domainRemark) {
      res["DomainRemark"] = boost::any(*domainRemark);
    }
    if (domainWebSocketStatus) {
      res["DomainWebSocketStatus"] = boost::any(*domainWebSocketStatus);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (subDomain) {
      res["SubDomain"] = boost::any(*subDomain);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainBindingStatus") != m.end() && !m["DomainBindingStatus"].empty()) {
      domainBindingStatus = make_shared<string>(boost::any_cast<string>(m["DomainBindingStatus"]));
    }
    if (m.find("DomainLegalStatus") != m.end() && !m["DomainLegalStatus"].empty()) {
      domainLegalStatus = make_shared<string>(boost::any_cast<string>(m["DomainLegalStatus"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("DomainRemark") != m.end() && !m["DomainRemark"].empty()) {
      domainRemark = make_shared<string>(boost::any_cast<string>(m["DomainRemark"]));
    }
    if (m.find("DomainWebSocketStatus") != m.end() && !m["DomainWebSocketStatus"].empty()) {
      domainWebSocketStatus = make_shared<string>(boost::any_cast<string>(m["DomainWebSocketStatus"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SubDomain") != m.end() && !m["SubDomain"].empty()) {
      subDomain = make_shared<string>(boost::any_cast<string>(m["SubDomain"]));
    }
  }


  virtual ~SetDomainResponseBody() = default;
};
class SetDomainResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SetDomainResponseBody> body{};

  SetDomainResponse() {}

  explicit SetDomainResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SetDomainResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SetDomainResponseBody>(model1);
      }
    }
  }


  virtual ~SetDomainResponse() = default;
};
class SetDomainCertificateRequest : public Darabonba::Model {
public:
  shared_ptr<string> caCertificateBody{};
  shared_ptr<string> certificateBody{};
  shared_ptr<string> certificateName{};
  shared_ptr<string> certificatePrivateKey{};
  shared_ptr<string> domainName{};
  shared_ptr<string> groupId{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> sslVerifyDepth{};

  SetDomainCertificateRequest() {}

  explicit SetDomainCertificateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (caCertificateBody) {
      res["CaCertificateBody"] = boost::any(*caCertificateBody);
    }
    if (certificateBody) {
      res["CertificateBody"] = boost::any(*certificateBody);
    }
    if (certificateName) {
      res["CertificateName"] = boost::any(*certificateName);
    }
    if (certificatePrivateKey) {
      res["CertificatePrivateKey"] = boost::any(*certificatePrivateKey);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (sslVerifyDepth) {
      res["SslVerifyDepth"] = boost::any(*sslVerifyDepth);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CaCertificateBody") != m.end() && !m["CaCertificateBody"].empty()) {
      caCertificateBody = make_shared<string>(boost::any_cast<string>(m["CaCertificateBody"]));
    }
    if (m.find("CertificateBody") != m.end() && !m["CertificateBody"].empty()) {
      certificateBody = make_shared<string>(boost::any_cast<string>(m["CertificateBody"]));
    }
    if (m.find("CertificateName") != m.end() && !m["CertificateName"].empty()) {
      certificateName = make_shared<string>(boost::any_cast<string>(m["CertificateName"]));
    }
    if (m.find("CertificatePrivateKey") != m.end() && !m["CertificatePrivateKey"].empty()) {
      certificatePrivateKey = make_shared<string>(boost::any_cast<string>(m["CertificatePrivateKey"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("SslVerifyDepth") != m.end() && !m["SslVerifyDepth"].empty()) {
      sslVerifyDepth = make_shared<string>(boost::any_cast<string>(m["SslVerifyDepth"]));
    }
  }


  virtual ~SetDomainCertificateRequest() = default;
};
class SetDomainCertificateResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  SetDomainCertificateResponseBody() {}

  explicit SetDomainCertificateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SetDomainCertificateResponseBody() = default;
};
class SetDomainCertificateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SetDomainCertificateResponseBody> body{};

  SetDomainCertificateResponse() {}

  explicit SetDomainCertificateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SetDomainCertificateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SetDomainCertificateResponseBody>(model1);
      }
    }
  }


  virtual ~SetDomainCertificateResponse() = default;
};
class SetDomainWebSocketStatusRequest : public Darabonba::Model {
public:
  shared_ptr<string> actionValue{};
  shared_ptr<string> domainName{};
  shared_ptr<string> groupId{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> WSSEnable{};

  SetDomainWebSocketStatusRequest() {}

  explicit SetDomainWebSocketStatusRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (actionValue) {
      res["ActionValue"] = boost::any(*actionValue);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (WSSEnable) {
      res["WSSEnable"] = boost::any(*WSSEnable);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ActionValue") != m.end() && !m["ActionValue"].empty()) {
      actionValue = make_shared<string>(boost::any_cast<string>(m["ActionValue"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("WSSEnable") != m.end() && !m["WSSEnable"].empty()) {
      WSSEnable = make_shared<string>(boost::any_cast<string>(m["WSSEnable"]));
    }
  }


  virtual ~SetDomainWebSocketStatusRequest() = default;
};
class SetDomainWebSocketStatusResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  SetDomainWebSocketStatusResponseBody() {}

  explicit SetDomainWebSocketStatusResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SetDomainWebSocketStatusResponseBody() = default;
};
class SetDomainWebSocketStatusResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SetDomainWebSocketStatusResponseBody> body{};

  SetDomainWebSocketStatusResponse() {}

  explicit SetDomainWebSocketStatusResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SetDomainWebSocketStatusResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SetDomainWebSocketStatusResponseBody>(model1);
      }
    }
  }


  virtual ~SetDomainWebSocketStatusResponse() = default;
};
class SetGroupAuthAppCodeRequest : public Darabonba::Model {
public:
  shared_ptr<string> authAppCode{};
  shared_ptr<string> groupId{};
  shared_ptr<string> securityToken{};

  SetGroupAuthAppCodeRequest() {}

  explicit SetGroupAuthAppCodeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (authAppCode) {
      res["AuthAppCode"] = boost::any(*authAppCode);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AuthAppCode") != m.end() && !m["AuthAppCode"].empty()) {
      authAppCode = make_shared<string>(boost::any_cast<string>(m["AuthAppCode"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
  }


  virtual ~SetGroupAuthAppCodeRequest() = default;
};
class SetGroupAuthAppCodeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  SetGroupAuthAppCodeResponseBody() {}

  explicit SetGroupAuthAppCodeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SetGroupAuthAppCodeResponseBody() = default;
};
class SetGroupAuthAppCodeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SetGroupAuthAppCodeResponseBody> body{};

  SetGroupAuthAppCodeResponse() {}

  explicit SetGroupAuthAppCodeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SetGroupAuthAppCodeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SetGroupAuthAppCodeResponseBody>(model1);
      }
    }
  }


  virtual ~SetGroupAuthAppCodeResponse() = default;
};
class SetIpControlApisRequest : public Darabonba::Model {
public:
  shared_ptr<string> apiIds{};
  shared_ptr<string> groupId{};
  shared_ptr<string> ipControlId{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> stageName{};

  SetIpControlApisRequest() {}

  explicit SetIpControlApisRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiIds) {
      res["ApiIds"] = boost::any(*apiIds);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (ipControlId) {
      res["IpControlId"] = boost::any(*ipControlId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (stageName) {
      res["StageName"] = boost::any(*stageName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiIds") != m.end() && !m["ApiIds"].empty()) {
      apiIds = make_shared<string>(boost::any_cast<string>(m["ApiIds"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("IpControlId") != m.end() && !m["IpControlId"].empty()) {
      ipControlId = make_shared<string>(boost::any_cast<string>(m["IpControlId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("StageName") != m.end() && !m["StageName"].empty()) {
      stageName = make_shared<string>(boost::any_cast<string>(m["StageName"]));
    }
  }


  virtual ~SetIpControlApisRequest() = default;
};
class SetIpControlApisResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  SetIpControlApisResponseBody() {}

  explicit SetIpControlApisResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SetIpControlApisResponseBody() = default;
};
class SetIpControlApisResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SetIpControlApisResponseBody> body{};

  SetIpControlApisResponse() {}

  explicit SetIpControlApisResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SetIpControlApisResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SetIpControlApisResponseBody>(model1);
      }
    }
  }


  virtual ~SetIpControlApisResponse() = default;
};
class SetSignatureApisRequest : public Darabonba::Model {
public:
  shared_ptr<string> apiIds{};
  shared_ptr<string> groupId{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> signatureId{};
  shared_ptr<string> stageName{};

  SetSignatureApisRequest() {}

  explicit SetSignatureApisRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiIds) {
      res["ApiIds"] = boost::any(*apiIds);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (signatureId) {
      res["SignatureId"] = boost::any(*signatureId);
    }
    if (stageName) {
      res["StageName"] = boost::any(*stageName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiIds") != m.end() && !m["ApiIds"].empty()) {
      apiIds = make_shared<string>(boost::any_cast<string>(m["ApiIds"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("SignatureId") != m.end() && !m["SignatureId"].empty()) {
      signatureId = make_shared<string>(boost::any_cast<string>(m["SignatureId"]));
    }
    if (m.find("StageName") != m.end() && !m["StageName"].empty()) {
      stageName = make_shared<string>(boost::any_cast<string>(m["StageName"]));
    }
  }


  virtual ~SetSignatureApisRequest() = default;
};
class SetSignatureApisResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  SetSignatureApisResponseBody() {}

  explicit SetSignatureApisResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SetSignatureApisResponseBody() = default;
};
class SetSignatureApisResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SetSignatureApisResponseBody> body{};

  SetSignatureApisResponse() {}

  explicit SetSignatureApisResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SetSignatureApisResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SetSignatureApisResponseBody>(model1);
      }
    }
  }


  virtual ~SetSignatureApisResponse() = default;
};
class SetTrafficControlApisRequest : public Darabonba::Model {
public:
  shared_ptr<string> apiIds{};
  shared_ptr<string> groupId{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> stageName{};
  shared_ptr<string> trafficControlId{};

  SetTrafficControlApisRequest() {}

  explicit SetTrafficControlApisRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiIds) {
      res["ApiIds"] = boost::any(*apiIds);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (stageName) {
      res["StageName"] = boost::any(*stageName);
    }
    if (trafficControlId) {
      res["TrafficControlId"] = boost::any(*trafficControlId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiIds") != m.end() && !m["ApiIds"].empty()) {
      apiIds = make_shared<string>(boost::any_cast<string>(m["ApiIds"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("StageName") != m.end() && !m["StageName"].empty()) {
      stageName = make_shared<string>(boost::any_cast<string>(m["StageName"]));
    }
    if (m.find("TrafficControlId") != m.end() && !m["TrafficControlId"].empty()) {
      trafficControlId = make_shared<string>(boost::any_cast<string>(m["TrafficControlId"]));
    }
  }


  virtual ~SetTrafficControlApisRequest() = default;
};
class SetTrafficControlApisResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  SetTrafficControlApisResponseBody() {}

  explicit SetTrafficControlApisResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SetTrafficControlApisResponseBody() = default;
};
class SetTrafficControlApisResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SetTrafficControlApisResponseBody> body{};

  SetTrafficControlApisResponse() {}

  explicit SetTrafficControlApisResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SetTrafficControlApisResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SetTrafficControlApisResponseBody>(model1);
      }
    }
  }


  virtual ~SetTrafficControlApisResponse() = default;
};
class SetVpcAccessRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  SetVpcAccessRequestTag() {}

  explicit SetVpcAccessRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~SetVpcAccessRequestTag() = default;
};
class SetVpcAccessRequest : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> name{};
  shared_ptr<long> port{};
  shared_ptr<string> securityToken{};
  shared_ptr<vector<SetVpcAccessRequestTag>> tag{};
  shared_ptr<string> vpcId{};
  shared_ptr<string> vpcTargetHostName{};

  SetVpcAccessRequest() {}

  explicit SetVpcAccessRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    if (vpcTargetHostName) {
      res["VpcTargetHostName"] = boost::any(*vpcTargetHostName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<long>(boost::any_cast<long>(m["Port"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<SetVpcAccessRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SetVpcAccessRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<SetVpcAccessRequestTag>>(expect1);
      }
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
    if (m.find("VpcTargetHostName") != m.end() && !m["VpcTargetHostName"].empty()) {
      vpcTargetHostName = make_shared<string>(boost::any_cast<string>(m["VpcTargetHostName"]));
    }
  }


  virtual ~SetVpcAccessRequest() = default;
};
class SetVpcAccessResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> vpcAccessId{};

  SetVpcAccessResponseBody() {}

  explicit SetVpcAccessResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (vpcAccessId) {
      res["VpcAccessId"] = boost::any(*vpcAccessId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("VpcAccessId") != m.end() && !m["VpcAccessId"].empty()) {
      vpcAccessId = make_shared<string>(boost::any_cast<string>(m["VpcAccessId"]));
    }
  }


  virtual ~SetVpcAccessResponseBody() = default;
};
class SetVpcAccessResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SetVpcAccessResponseBody> body{};

  SetVpcAccessResponse() {}

  explicit SetVpcAccessResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SetVpcAccessResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SetVpcAccessResponseBody>(model1);
      }
    }
  }


  virtual ~SetVpcAccessResponse() = default;
};
class SetWildcardDomainPatternsRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainName{};
  shared_ptr<string> groupId{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> wildcardDomainPatterns{};

  SetWildcardDomainPatternsRequest() {}

  explicit SetWildcardDomainPatternsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (wildcardDomainPatterns) {
      res["WildcardDomainPatterns"] = boost::any(*wildcardDomainPatterns);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("WildcardDomainPatterns") != m.end() && !m["WildcardDomainPatterns"].empty()) {
      wildcardDomainPatterns = make_shared<string>(boost::any_cast<string>(m["WildcardDomainPatterns"]));
    }
  }


  virtual ~SetWildcardDomainPatternsRequest() = default;
};
class SetWildcardDomainPatternsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  SetWildcardDomainPatternsResponseBody() {}

  explicit SetWildcardDomainPatternsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SetWildcardDomainPatternsResponseBody() = default;
};
class SetWildcardDomainPatternsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SetWildcardDomainPatternsResponseBody> body{};

  SetWildcardDomainPatternsResponse() {}

  explicit SetWildcardDomainPatternsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SetWildcardDomainPatternsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SetWildcardDomainPatternsResponseBody>(model1);
      }
    }
  }


  virtual ~SetWildcardDomainPatternsResponse() = default;
};
class SwitchApiRequest : public Darabonba::Model {
public:
  shared_ptr<string> apiId{};
  shared_ptr<string> description{};
  shared_ptr<string> groupId{};
  shared_ptr<string> historyVersion{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> stageName{};

  SwitchApiRequest() {}

  explicit SwitchApiRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apiId) {
      res["ApiId"] = boost::any(*apiId);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (historyVersion) {
      res["HistoryVersion"] = boost::any(*historyVersion);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (stageName) {
      res["StageName"] = boost::any(*stageName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApiId") != m.end() && !m["ApiId"].empty()) {
      apiId = make_shared<string>(boost::any_cast<string>(m["ApiId"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("HistoryVersion") != m.end() && !m["HistoryVersion"].empty()) {
      historyVersion = make_shared<string>(boost::any_cast<string>(m["HistoryVersion"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("StageName") != m.end() && !m["StageName"].empty()) {
      stageName = make_shared<string>(boost::any_cast<string>(m["StageName"]));
    }
  }


  virtual ~SwitchApiRequest() = default;
};
class SwitchApiResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  SwitchApiResponseBody() {}

  explicit SwitchApiResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SwitchApiResponseBody() = default;
};
class SwitchApiResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SwitchApiResponseBody> body{};

  SwitchApiResponse() {}

  explicit SwitchApiResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SwitchApiResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SwitchApiResponseBody>(model1);
      }
    }
  }


  virtual ~SwitchApiResponse() = default;
};
class TagResourcesRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  TagResourcesRequestTag() {}

  explicit TagResourcesRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~TagResourcesRequestTag() = default;
};
class TagResourcesRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> resourceId{};
  shared_ptr<string> resourceType{};
  shared_ptr<string> securityToken{};
  shared_ptr<vector<TagResourcesRequestTag>> tag{};

  TagResourcesRequest() {}

  explicit TagResourcesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ResourceId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ResourceId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      resourceId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<TagResourcesRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            TagResourcesRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<TagResourcesRequestTag>>(expect1);
      }
    }
  }


  virtual ~TagResourcesRequest() = default;
};
class TagResourcesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  TagResourcesResponseBody() {}

  explicit TagResourcesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~TagResourcesResponseBody() = default;
};
class TagResourcesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<TagResourcesResponseBody> body{};

  TagResourcesResponse() {}

  explicit TagResourcesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        TagResourcesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<TagResourcesResponseBody>(model1);
      }
    }
  }


  virtual ~TagResourcesResponse() = default;
};
class UntagResourcesRequest : public Darabonba::Model {
public:
  shared_ptr<bool> all{};
  shared_ptr<vector<string>> resourceId{};
  shared_ptr<string> resourceType{};
  shared_ptr<string> securityToken{};
  shared_ptr<vector<string>> tagKey{};

  UntagResourcesRequest() {}

  explicit UntagResourcesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (all) {
      res["All"] = boost::any(*all);
    }
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (tagKey) {
      res["TagKey"] = boost::any(*tagKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("All") != m.end() && !m["All"].empty()) {
      all = make_shared<bool>(boost::any_cast<bool>(m["All"]));
    }
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ResourceId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ResourceId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      resourceId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("TagKey") != m.end() && !m["TagKey"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["TagKey"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["TagKey"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      tagKey = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~UntagResourcesRequest() = default;
};
class UntagResourcesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UntagResourcesResponseBody() {}

  explicit UntagResourcesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UntagResourcesResponseBody() = default;
};
class UntagResourcesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UntagResourcesResponseBody> body{};

  UntagResourcesResponse() {}

  explicit UntagResourcesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UntagResourcesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UntagResourcesResponseBody>(model1);
      }
    }
  }


  virtual ~UntagResourcesResponse() = default;
};
class ValidateVpcConnectivityRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> securityToken{};
  shared_ptr<string> vpcAccessId{};

  ValidateVpcConnectivityRequest() {}

  explicit ValidateVpcConnectivityRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (securityToken) {
      res["SecurityToken"] = boost::any(*securityToken);
    }
    if (vpcAccessId) {
      res["VpcAccessId"] = boost::any(*vpcAccessId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("SecurityToken") != m.end() && !m["SecurityToken"].empty()) {
      securityToken = make_shared<string>(boost::any_cast<string>(m["SecurityToken"]));
    }
    if (m.find("VpcAccessId") != m.end() && !m["VpcAccessId"].empty()) {
      vpcAccessId = make_shared<string>(boost::any_cast<string>(m["VpcAccessId"]));
    }
  }


  virtual ~ValidateVpcConnectivityRequest() = default;
};
class ValidateVpcConnectivityResponseBody : public Darabonba::Model {
public:
  shared_ptr<bool> connected{};
  shared_ptr<string> ipType{};
  shared_ptr<string> requestId{};

  ValidateVpcConnectivityResponseBody() {}

  explicit ValidateVpcConnectivityResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (connected) {
      res["Connected"] = boost::any(*connected);
    }
    if (ipType) {
      res["IpType"] = boost::any(*ipType);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Connected") != m.end() && !m["Connected"].empty()) {
      connected = make_shared<bool>(boost::any_cast<bool>(m["Connected"]));
    }
    if (m.find("IpType") != m.end() && !m["IpType"].empty()) {
      ipType = make_shared<string>(boost::any_cast<string>(m["IpType"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ValidateVpcConnectivityResponseBody() = default;
};
class ValidateVpcConnectivityResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ValidateVpcConnectivityResponseBody> body{};

  ValidateVpcConnectivityResponse() {}

  explicit ValidateVpcConnectivityResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ValidateVpcConnectivityResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ValidateVpcConnectivityResponseBody>(model1);
      }
    }
  }


  virtual ~ValidateVpcConnectivityResponse() = default;
};
class Client : Alibabacloud_OpenApi::Client {
public:
  explicit Client(const shared_ptr<Alibabacloud_OpenApi::Config>& config);
  string getEndpoint(shared_ptr<string> productId,
                     shared_ptr<string> regionId,
                     shared_ptr<string> endpointRule,
                     shared_ptr<string> network,
                     shared_ptr<string> suffix,
                     shared_ptr<map<string, string>> endpointMap,
                     shared_ptr<string> endpoint);
  AbolishApiResponse abolishApiWithOptions(shared_ptr<AbolishApiRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AbolishApiResponse abolishApi(shared_ptr<AbolishApiRequest> request);
  AddAccessControlListEntryResponse addAccessControlListEntryWithOptions(shared_ptr<AddAccessControlListEntryRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddAccessControlListEntryResponse addAccessControlListEntry(shared_ptr<AddAccessControlListEntryRequest> request);
  AddIpControlPolicyItemResponse addIpControlPolicyItemWithOptions(shared_ptr<AddIpControlPolicyItemRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddIpControlPolicyItemResponse addIpControlPolicyItem(shared_ptr<AddIpControlPolicyItemRequest> request);
  AddTrafficSpecialControlResponse addTrafficSpecialControlWithOptions(shared_ptr<AddTrafficSpecialControlRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddTrafficSpecialControlResponse addTrafficSpecialControl(shared_ptr<AddTrafficSpecialControlRequest> request);
  AttachApiProductResponse attachApiProductWithOptions(shared_ptr<AttachApiProductRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AttachApiProductResponse attachApiProduct(shared_ptr<AttachApiProductRequest> request);
  AttachPluginResponse attachPluginWithOptions(shared_ptr<AttachPluginRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AttachPluginResponse attachPlugin(shared_ptr<AttachPluginRequest> request);
  BatchAbolishApisResponse batchAbolishApisWithOptions(shared_ptr<BatchAbolishApisRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  BatchAbolishApisResponse batchAbolishApis(shared_ptr<BatchAbolishApisRequest> request);
  BatchDeployApisResponse batchDeployApisWithOptions(shared_ptr<BatchDeployApisRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  BatchDeployApisResponse batchDeployApis(shared_ptr<BatchDeployApisRequest> request);
  CreateAccessControlListResponse createAccessControlListWithOptions(shared_ptr<CreateAccessControlListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateAccessControlListResponse createAccessControlList(shared_ptr<CreateAccessControlListRequest> request);
  CreateApiResponse createApiWithOptions(shared_ptr<CreateApiRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateApiResponse createApi(shared_ptr<CreateApiRequest> request);
  CreateApiGroupResponse createApiGroupWithOptions(shared_ptr<CreateApiGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateApiGroupResponse createApiGroup(shared_ptr<CreateApiGroupRequest> request);
  CreateApiStageVariableResponse createApiStageVariableWithOptions(shared_ptr<CreateApiStageVariableRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateApiStageVariableResponse createApiStageVariable(shared_ptr<CreateApiStageVariableRequest> request);
  CreateAppResponse createAppWithOptions(shared_ptr<CreateAppRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateAppResponse createApp(shared_ptr<CreateAppRequest> request);
  CreateAppCodeResponse createAppCodeWithOptions(shared_ptr<CreateAppCodeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateAppCodeResponse createAppCode(shared_ptr<CreateAppCodeRequest> request);
  CreateAppKeyResponse createAppKeyWithOptions(shared_ptr<CreateAppKeyRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateAppKeyResponse createAppKey(shared_ptr<CreateAppKeyRequest> request);
  CreateBackendResponse createBackendWithOptions(shared_ptr<CreateBackendRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateBackendResponse createBackend(shared_ptr<CreateBackendRequest> request);
  CreateBackendModelResponse createBackendModelWithOptions(shared_ptr<CreateBackendModelRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateBackendModelResponse createBackendModel(shared_ptr<CreateBackendModelRequest> request);
  CreateDatasetResponse createDatasetWithOptions(shared_ptr<CreateDatasetRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateDatasetResponse createDataset(shared_ptr<CreateDatasetRequest> request);
  CreateDatasetItemResponse createDatasetItemWithOptions(shared_ptr<CreateDatasetItemRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateDatasetItemResponse createDatasetItem(shared_ptr<CreateDatasetItemRequest> request);
  CreateInstanceResponse createInstanceWithOptions(shared_ptr<CreateInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateInstanceResponse createInstance(shared_ptr<CreateInstanceRequest> request);
  CreateIntranetDomainResponse createIntranetDomainWithOptions(shared_ptr<CreateIntranetDomainRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateIntranetDomainResponse createIntranetDomain(shared_ptr<CreateIntranetDomainRequest> request);
  CreateIpControlResponse createIpControlWithOptions(shared_ptr<CreateIpControlRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateIpControlResponse createIpControl(shared_ptr<CreateIpControlRequest> request);
  CreateLogConfigResponse createLogConfigWithOptions(shared_ptr<CreateLogConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateLogConfigResponse createLogConfig(shared_ptr<CreateLogConfigRequest> request);
  CreateModelResponse createModelWithOptions(shared_ptr<CreateModelRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateModelResponse createModel(shared_ptr<CreateModelRequest> request);
  CreateMonitorGroupResponse createMonitorGroupWithOptions(shared_ptr<CreateMonitorGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateMonitorGroupResponse createMonitorGroup(shared_ptr<CreateMonitorGroupRequest> request);
  CreatePluginResponse createPluginWithOptions(shared_ptr<CreatePluginRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreatePluginResponse createPlugin(shared_ptr<CreatePluginRequest> request);
  CreateSignatureResponse createSignatureWithOptions(shared_ptr<CreateSignatureRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateSignatureResponse createSignature(shared_ptr<CreateSignatureRequest> request);
  CreateTrafficControlResponse createTrafficControlWithOptions(shared_ptr<CreateTrafficControlRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateTrafficControlResponse createTrafficControl(shared_ptr<CreateTrafficControlRequest> request);
  DeleteAccessControlListResponse deleteAccessControlListWithOptions(shared_ptr<DeleteAccessControlListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteAccessControlListResponse deleteAccessControlList(shared_ptr<DeleteAccessControlListRequest> request);
  DeleteAllTrafficSpecialControlResponse deleteAllTrafficSpecialControlWithOptions(shared_ptr<DeleteAllTrafficSpecialControlRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteAllTrafficSpecialControlResponse deleteAllTrafficSpecialControl(shared_ptr<DeleteAllTrafficSpecialControlRequest> request);
  DeleteApiResponse deleteApiWithOptions(shared_ptr<DeleteApiRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteApiResponse deleteApi(shared_ptr<DeleteApiRequest> request);
  DeleteApiGroupResponse deleteApiGroupWithOptions(shared_ptr<DeleteApiGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteApiGroupResponse deleteApiGroup(shared_ptr<DeleteApiGroupRequest> request);
  DeleteApiProductResponse deleteApiProductWithOptions(shared_ptr<DeleteApiProductRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteApiProductResponse deleteApiProduct(shared_ptr<DeleteApiProductRequest> request);
  DeleteApiStageVariableResponse deleteApiStageVariableWithOptions(shared_ptr<DeleteApiStageVariableRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteApiStageVariableResponse deleteApiStageVariable(shared_ptr<DeleteApiStageVariableRequest> request);
  DeleteAppResponse deleteAppWithOptions(shared_ptr<DeleteAppRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteAppResponse deleteApp(shared_ptr<DeleteAppRequest> request);
  DeleteAppCodeResponse deleteAppCodeWithOptions(shared_ptr<DeleteAppCodeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteAppCodeResponse deleteAppCode(shared_ptr<DeleteAppCodeRequest> request);
  DeleteAppKeyResponse deleteAppKeyWithOptions(shared_ptr<DeleteAppKeyRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteAppKeyResponse deleteAppKey(shared_ptr<DeleteAppKeyRequest> request);
  DeleteBackendResponse deleteBackendWithOptions(shared_ptr<DeleteBackendRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteBackendResponse deleteBackend(shared_ptr<DeleteBackendRequest> request);
  DeleteBackendModelResponse deleteBackendModelWithOptions(shared_ptr<DeleteBackendModelRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteBackendModelResponse deleteBackendModel(shared_ptr<DeleteBackendModelRequest> request);
  DeleteDatasetResponse deleteDatasetWithOptions(shared_ptr<DeleteDatasetRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteDatasetResponse deleteDataset(shared_ptr<DeleteDatasetRequest> request);
  DeleteDatasetItemResponse deleteDatasetItemWithOptions(shared_ptr<DeleteDatasetItemRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteDatasetItemResponse deleteDatasetItem(shared_ptr<DeleteDatasetItemRequest> request);
  DeleteDomainResponse deleteDomainWithOptions(shared_ptr<DeleteDomainRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteDomainResponse deleteDomain(shared_ptr<DeleteDomainRequest> request);
  DeleteDomainCertificateResponse deleteDomainCertificateWithOptions(shared_ptr<DeleteDomainCertificateRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteDomainCertificateResponse deleteDomainCertificate(shared_ptr<DeleteDomainCertificateRequest> request);
  DeleteInstanceResponse deleteInstanceWithOptions(shared_ptr<DeleteInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteInstanceResponse deleteInstance(shared_ptr<DeleteInstanceRequest> request);
  DeleteIpControlResponse deleteIpControlWithOptions(shared_ptr<DeleteIpControlRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteIpControlResponse deleteIpControl(shared_ptr<DeleteIpControlRequest> request);
  DeleteLogConfigResponse deleteLogConfigWithOptions(shared_ptr<DeleteLogConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteLogConfigResponse deleteLogConfig(shared_ptr<DeleteLogConfigRequest> request);
  DeleteModelResponse deleteModelWithOptions(shared_ptr<DeleteModelRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteModelResponse deleteModel(shared_ptr<DeleteModelRequest> request);
  DeleteMonitorGroupResponse deleteMonitorGroupWithOptions(shared_ptr<DeleteMonitorGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteMonitorGroupResponse deleteMonitorGroup(shared_ptr<DeleteMonitorGroupRequest> request);
  DeletePluginResponse deletePluginWithOptions(shared_ptr<DeletePluginRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeletePluginResponse deletePlugin(shared_ptr<DeletePluginRequest> request);
  DeleteSignatureResponse deleteSignatureWithOptions(shared_ptr<DeleteSignatureRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteSignatureResponse deleteSignature(shared_ptr<DeleteSignatureRequest> request);
  DeleteTrafficControlResponse deleteTrafficControlWithOptions(shared_ptr<DeleteTrafficControlRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteTrafficControlResponse deleteTrafficControl(shared_ptr<DeleteTrafficControlRequest> request);
  DeleteTrafficSpecialControlResponse deleteTrafficSpecialControlWithOptions(shared_ptr<DeleteTrafficSpecialControlRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteTrafficSpecialControlResponse deleteTrafficSpecialControl(shared_ptr<DeleteTrafficSpecialControlRequest> request);
  DeployApiResponse deployApiWithOptions(shared_ptr<DeployApiRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeployApiResponse deployApi(shared_ptr<DeployApiRequest> request);
  DescribeAbolishApiTaskResponse describeAbolishApiTaskWithOptions(shared_ptr<DescribeAbolishApiTaskRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeAbolishApiTaskResponse describeAbolishApiTask(shared_ptr<DescribeAbolishApiTaskRequest> request);
  DescribeAccessControlListAttributeResponse describeAccessControlListAttributeWithOptions(shared_ptr<DescribeAccessControlListAttributeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeAccessControlListAttributeResponse describeAccessControlListAttribute(shared_ptr<DescribeAccessControlListAttributeRequest> request);
  DescribeAccessControlListsResponse describeAccessControlListsWithOptions(shared_ptr<DescribeAccessControlListsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeAccessControlListsResponse describeAccessControlLists(shared_ptr<DescribeAccessControlListsRequest> request);
  DescribeApiResponse describeApiWithOptions(shared_ptr<DescribeApiRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeApiResponse describeApi(shared_ptr<DescribeApiRequest> request);
  DescribeApiDocResponse describeApiDocWithOptions(shared_ptr<DescribeApiDocRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeApiDocResponse describeApiDoc(shared_ptr<DescribeApiDocRequest> request);
  DescribeApiGroupResponse describeApiGroupWithOptions(shared_ptr<DescribeApiGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeApiGroupResponse describeApiGroup(shared_ptr<DescribeApiGroupRequest> request);
  DescribeApiGroupVpcWhitelistResponse describeApiGroupVpcWhitelistWithOptions(shared_ptr<DescribeApiGroupVpcWhitelistRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeApiGroupVpcWhitelistResponse describeApiGroupVpcWhitelist(shared_ptr<DescribeApiGroupVpcWhitelistRequest> request);
  DescribeApiGroupsResponse describeApiGroupsWithOptions(shared_ptr<DescribeApiGroupsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeApiGroupsResponse describeApiGroups(shared_ptr<DescribeApiGroupsRequest> request);
  DescribeApiHistoriesResponse describeApiHistoriesWithOptions(shared_ptr<DescribeApiHistoriesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeApiHistoriesResponse describeApiHistories(shared_ptr<DescribeApiHistoriesRequest> request);
  DescribeApiHistoryResponse describeApiHistoryWithOptions(shared_ptr<DescribeApiHistoryRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeApiHistoryResponse describeApiHistory(shared_ptr<DescribeApiHistoryRequest> request);
  DescribeApiIpControlsResponse describeApiIpControlsWithOptions(shared_ptr<DescribeApiIpControlsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeApiIpControlsResponse describeApiIpControls(shared_ptr<DescribeApiIpControlsRequest> request);
  DescribeApiLatencyDataResponse describeApiLatencyDataWithOptions(shared_ptr<DescribeApiLatencyDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeApiLatencyDataResponse describeApiLatencyData(shared_ptr<DescribeApiLatencyDataRequest> request);
  DescribeApiMarketAttributesResponse describeApiMarketAttributesWithOptions(shared_ptr<DescribeApiMarketAttributesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeApiMarketAttributesResponse describeApiMarketAttributes(shared_ptr<DescribeApiMarketAttributesRequest> request);
  DescribeApiProductApisResponse describeApiProductApisWithOptions(shared_ptr<DescribeApiProductApisRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeApiProductApisResponse describeApiProductApis(shared_ptr<DescribeApiProductApisRequest> request);
  DescribeApiProductsByAppResponse describeApiProductsByAppWithOptions(shared_ptr<DescribeApiProductsByAppRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeApiProductsByAppResponse describeApiProductsByApp(shared_ptr<DescribeApiProductsByAppRequest> request);
  DescribeApiQpsDataResponse describeApiQpsDataWithOptions(shared_ptr<DescribeApiQpsDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeApiQpsDataResponse describeApiQpsData(shared_ptr<DescribeApiQpsDataRequest> request);
  DescribeApiSignaturesResponse describeApiSignaturesWithOptions(shared_ptr<DescribeApiSignaturesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeApiSignaturesResponse describeApiSignatures(shared_ptr<DescribeApiSignaturesRequest> request);
  DescribeApiTrafficControlsResponse describeApiTrafficControlsWithOptions(shared_ptr<DescribeApiTrafficControlsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeApiTrafficControlsResponse describeApiTrafficControls(shared_ptr<DescribeApiTrafficControlsRequest> request);
  DescribeApiTrafficDataResponse describeApiTrafficDataWithOptions(shared_ptr<DescribeApiTrafficDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeApiTrafficDataResponse describeApiTrafficData(shared_ptr<DescribeApiTrafficDataRequest> request);
  DescribeApisResponse describeApisWithOptions(shared_ptr<DescribeApisRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeApisResponse describeApis(shared_ptr<DescribeApisRequest> request);
  DescribeApisByAppResponse describeApisByAppWithOptions(shared_ptr<DescribeApisByAppRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeApisByAppResponse describeApisByApp(shared_ptr<DescribeApisByAppRequest> request);
  DescribeApisByBackendResponse describeApisByBackendWithOptions(shared_ptr<DescribeApisByBackendRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeApisByBackendResponse describeApisByBackend(shared_ptr<DescribeApisByBackendRequest> request);
  DescribeApisByIpControlResponse describeApisByIpControlWithOptions(shared_ptr<DescribeApisByIpControlRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeApisByIpControlResponse describeApisByIpControl(shared_ptr<DescribeApisByIpControlRequest> request);
  DescribeApisBySignatureResponse describeApisBySignatureWithOptions(shared_ptr<DescribeApisBySignatureRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeApisBySignatureResponse describeApisBySignature(shared_ptr<DescribeApisBySignatureRequest> request);
  DescribeApisByTrafficControlResponse describeApisByTrafficControlWithOptions(shared_ptr<DescribeApisByTrafficControlRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeApisByTrafficControlResponse describeApisByTrafficControl(shared_ptr<DescribeApisByTrafficControlRequest> request);
  DescribeApisByVpcAccessResponse describeApisByVpcAccessWithOptions(shared_ptr<DescribeApisByVpcAccessRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeApisByVpcAccessResponse describeApisByVpcAccess(shared_ptr<DescribeApisByVpcAccessRequest> request);
  DescribeApisWithStageNameIntegratedByAppResponse describeApisWithStageNameIntegratedByAppWithOptions(shared_ptr<DescribeApisWithStageNameIntegratedByAppRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeApisWithStageNameIntegratedByAppResponse describeApisWithStageNameIntegratedByApp(shared_ptr<DescribeApisWithStageNameIntegratedByAppRequest> request);
  DescribeAppResponse describeAppWithOptions(shared_ptr<DescribeAppRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeAppResponse describeApp(shared_ptr<DescribeAppRequest> request);
  DescribeAppAttributesResponse describeAppAttributesWithOptions(shared_ptr<DescribeAppAttributesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeAppAttributesResponse describeAppAttributes(shared_ptr<DescribeAppAttributesRequest> request);
  DescribeAppSecuritiesResponse describeAppSecuritiesWithOptions(shared_ptr<DescribeAppSecuritiesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeAppSecuritiesResponse describeAppSecurities(shared_ptr<DescribeAppSecuritiesRequest> request);
  DescribeAppSecurityResponse describeAppSecurityWithOptions(shared_ptr<DescribeAppSecurityRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeAppSecurityResponse describeAppSecurity(shared_ptr<DescribeAppSecurityRequest> request);
  DescribeAppsResponse describeAppsWithOptions(shared_ptr<DescribeAppsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeAppsResponse describeApps(shared_ptr<DescribeAppsRequest> request);
  DescribeAppsByApiProductResponse describeAppsByApiProductWithOptions(shared_ptr<DescribeAppsByApiProductRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeAppsByApiProductResponse describeAppsByApiProduct(shared_ptr<DescribeAppsByApiProductRequest> request);
  DescribeAuthorizedApisResponse describeAuthorizedApisWithOptions(shared_ptr<DescribeAuthorizedApisRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeAuthorizedApisResponse describeAuthorizedApis(shared_ptr<DescribeAuthorizedApisRequest> request);
  DescribeAuthorizedAppsResponse describeAuthorizedAppsWithOptions(shared_ptr<DescribeAuthorizedAppsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeAuthorizedAppsResponse describeAuthorizedApps(shared_ptr<DescribeAuthorizedAppsRequest> request);
  DescribeBackendInfoResponse describeBackendInfoWithOptions(shared_ptr<DescribeBackendInfoRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeBackendInfoResponse describeBackendInfo(shared_ptr<DescribeBackendInfoRequest> request);
  DescribeBackendListResponse describeBackendListWithOptions(shared_ptr<DescribeBackendListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeBackendListResponse describeBackendList(shared_ptr<DescribeBackendListRequest> request);
  DescribeDatasetInfoResponse describeDatasetInfoWithOptions(shared_ptr<DescribeDatasetInfoRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDatasetInfoResponse describeDatasetInfo(shared_ptr<DescribeDatasetInfoRequest> request);
  DescribeDatasetItemInfoResponse describeDatasetItemInfoWithOptions(shared_ptr<DescribeDatasetItemInfoRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDatasetItemInfoResponse describeDatasetItemInfo(shared_ptr<DescribeDatasetItemInfoRequest> request);
  DescribeDatasetItemListResponse describeDatasetItemListWithOptions(shared_ptr<DescribeDatasetItemListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDatasetItemListResponse describeDatasetItemList(shared_ptr<DescribeDatasetItemListRequest> request);
  DescribeDatasetListResponse describeDatasetListWithOptions(shared_ptr<DescribeDatasetListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDatasetListResponse describeDatasetList(shared_ptr<DescribeDatasetListRequest> request);
  DescribeDeployApiTaskResponse describeDeployApiTaskWithOptions(shared_ptr<DescribeDeployApiTaskRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDeployApiTaskResponse describeDeployApiTask(shared_ptr<DescribeDeployApiTaskRequest> request);
  DescribeDeployedApiResponse describeDeployedApiWithOptions(shared_ptr<DescribeDeployedApiRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDeployedApiResponse describeDeployedApi(shared_ptr<DescribeDeployedApiRequest> request);
  DescribeDeployedApisResponse describeDeployedApisWithOptions(shared_ptr<DescribeDeployedApisRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDeployedApisResponse describeDeployedApis(shared_ptr<DescribeDeployedApisRequest> request);
  DescribeDomainResponse describeDomainWithOptions(shared_ptr<DescribeDomainRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDomainResponse describeDomain(shared_ptr<DescribeDomainRequest> request);
  DescribeGroupLatencyResponse describeGroupLatencyWithOptions(shared_ptr<DescribeGroupLatencyRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeGroupLatencyResponse describeGroupLatency(shared_ptr<DescribeGroupLatencyRequest> request);
  DescribeGroupQpsResponse describeGroupQpsWithOptions(shared_ptr<DescribeGroupQpsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeGroupQpsResponse describeGroupQps(shared_ptr<DescribeGroupQpsRequest> request);
  DescribeGroupTrafficResponse describeGroupTrafficWithOptions(shared_ptr<DescribeGroupTrafficRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeGroupTrafficResponse describeGroupTraffic(shared_ptr<DescribeGroupTrafficRequest> request);
  DescribeHistoryApisResponse describeHistoryApisWithOptions(shared_ptr<DescribeHistoryApisRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeHistoryApisResponse describeHistoryApis(shared_ptr<DescribeHistoryApisRequest> request);
  DescribeImportOASTaskResponse describeImportOASTaskWithOptions(shared_ptr<DescribeImportOASTaskRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeImportOASTaskResponse describeImportOASTask(shared_ptr<DescribeImportOASTaskRequest> request);
  DescribeInstanceDropConnectionsResponse describeInstanceDropConnectionsWithOptions(shared_ptr<DescribeInstanceDropConnectionsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeInstanceDropConnectionsResponse describeInstanceDropConnections(shared_ptr<DescribeInstanceDropConnectionsRequest> request);
  DescribeInstanceDropPacketResponse describeInstanceDropPacketWithOptions(shared_ptr<DescribeInstanceDropPacketRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeInstanceDropPacketResponse describeInstanceDropPacket(shared_ptr<DescribeInstanceDropPacketRequest> request);
  DescribeInstanceHttpCodeResponse describeInstanceHttpCodeWithOptions(shared_ptr<DescribeInstanceHttpCodeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeInstanceHttpCodeResponse describeInstanceHttpCode(shared_ptr<DescribeInstanceHttpCodeRequest> request);
  DescribeInstanceLatencyResponse describeInstanceLatencyWithOptions(shared_ptr<DescribeInstanceLatencyRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeInstanceLatencyResponse describeInstanceLatency(shared_ptr<DescribeInstanceLatencyRequest> request);
  DescribeInstanceNewConnectionsResponse describeInstanceNewConnectionsWithOptions(shared_ptr<DescribeInstanceNewConnectionsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeInstanceNewConnectionsResponse describeInstanceNewConnections(shared_ptr<DescribeInstanceNewConnectionsRequest> request);
  DescribeInstancePacketsResponse describeInstancePacketsWithOptions(shared_ptr<DescribeInstancePacketsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeInstancePacketsResponse describeInstancePackets(shared_ptr<DescribeInstancePacketsRequest> request);
  DescribeInstanceQpsResponse describeInstanceQpsWithOptions(shared_ptr<DescribeInstanceQpsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeInstanceQpsResponse describeInstanceQps(shared_ptr<DescribeInstanceQpsRequest> request);
  DescribeInstanceSlbConnectResponse describeInstanceSlbConnectWithOptions(shared_ptr<DescribeInstanceSlbConnectRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeInstanceSlbConnectResponse describeInstanceSlbConnect(shared_ptr<DescribeInstanceSlbConnectRequest> request);
  DescribeInstanceTrafficResponse describeInstanceTrafficWithOptions(shared_ptr<DescribeInstanceTrafficRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeInstanceTrafficResponse describeInstanceTraffic(shared_ptr<DescribeInstanceTrafficRequest> request);
  DescribeInstancesResponse describeInstancesWithOptions(shared_ptr<DescribeInstancesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeInstancesResponse describeInstances(shared_ptr<DescribeInstancesRequest> request);
  DescribeIpControlPolicyItemsResponse describeIpControlPolicyItemsWithOptions(shared_ptr<DescribeIpControlPolicyItemsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeIpControlPolicyItemsResponse describeIpControlPolicyItems(shared_ptr<DescribeIpControlPolicyItemsRequest> request);
  DescribeIpControlsResponse describeIpControlsWithOptions(shared_ptr<DescribeIpControlsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeIpControlsResponse describeIpControls(shared_ptr<DescribeIpControlsRequest> request);
  DescribeLogConfigResponse describeLogConfigWithOptions(shared_ptr<DescribeLogConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeLogConfigResponse describeLogConfig(shared_ptr<DescribeLogConfigRequest> request);
  DescribeMarketRemainsQuotaResponse describeMarketRemainsQuotaWithOptions(shared_ptr<DescribeMarketRemainsQuotaRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeMarketRemainsQuotaResponse describeMarketRemainsQuota(shared_ptr<DescribeMarketRemainsQuotaRequest> request);
  DescribeModelsResponse describeModelsWithOptions(shared_ptr<DescribeModelsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeModelsResponse describeModels(shared_ptr<DescribeModelsRequest> request);
  DescribePluginApisResponse describePluginApisWithOptions(shared_ptr<DescribePluginApisRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribePluginApisResponse describePluginApis(shared_ptr<DescribePluginApisRequest> request);
  DescribePluginSchemasResponse describePluginSchemasWithOptions(shared_ptr<DescribePluginSchemasRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribePluginSchemasResponse describePluginSchemas(shared_ptr<DescribePluginSchemasRequest> request);
  DescribePluginTemplatesResponse describePluginTemplatesWithOptions(shared_ptr<DescribePluginTemplatesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribePluginTemplatesResponse describePluginTemplates(shared_ptr<DescribePluginTemplatesRequest> request);
  DescribePluginsResponse describePluginsWithOptions(shared_ptr<DescribePluginsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribePluginsResponse describePlugins(shared_ptr<DescribePluginsRequest> request);
  DescribePluginsByApiResponse describePluginsByApiWithOptions(shared_ptr<DescribePluginsByApiRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribePluginsByApiResponse describePluginsByApi(shared_ptr<DescribePluginsByApiRequest> request);
  DescribePurchasedApiGroupResponse describePurchasedApiGroupWithOptions(shared_ptr<DescribePurchasedApiGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribePurchasedApiGroupResponse describePurchasedApiGroup(shared_ptr<DescribePurchasedApiGroupRequest> request);
  DescribePurchasedApiGroupsResponse describePurchasedApiGroupsWithOptions(shared_ptr<DescribePurchasedApiGroupsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribePurchasedApiGroupsResponse describePurchasedApiGroups(shared_ptr<DescribePurchasedApiGroupsRequest> request);
  DescribePurchasedApisResponse describePurchasedApisWithOptions(shared_ptr<DescribePurchasedApisRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribePurchasedApisResponse describePurchasedApis(shared_ptr<DescribePurchasedApisRequest> request);
  DescribeRegionsResponse describeRegionsWithOptions(shared_ptr<DescribeRegionsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeRegionsResponse describeRegions(shared_ptr<DescribeRegionsRequest> request);
  DescribeSignaturesResponse describeSignaturesWithOptions(shared_ptr<DescribeSignaturesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeSignaturesResponse describeSignatures(shared_ptr<DescribeSignaturesRequest> request);
  DescribeSignaturesByApiResponse describeSignaturesByApiWithOptions(shared_ptr<DescribeSignaturesByApiRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeSignaturesByApiResponse describeSignaturesByApi(shared_ptr<DescribeSignaturesByApiRequest> request);
  DescribeSummaryDataResponse describeSummaryDataWithOptions(shared_ptr<DescribeSummaryDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeSummaryDataResponse describeSummaryData(shared_ptr<DescribeSummaryDataRequest> request);
  DescribeSystemParametersResponse describeSystemParametersWithOptions(shared_ptr<DescribeSystemParametersRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeSystemParametersResponse describeSystemParameters(shared_ptr<DescribeSystemParametersRequest> request);
  DescribeTrafficControlsResponse describeTrafficControlsWithOptions(shared_ptr<DescribeTrafficControlsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeTrafficControlsResponse describeTrafficControls(shared_ptr<DescribeTrafficControlsRequest> request);
  DescribeTrafficControlsByApiResponse describeTrafficControlsByApiWithOptions(shared_ptr<DescribeTrafficControlsByApiRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeTrafficControlsByApiResponse describeTrafficControlsByApi(shared_ptr<DescribeTrafficControlsByApiRequest> request);
  DescribeUpdateBackendTaskResponse describeUpdateBackendTaskWithOptions(shared_ptr<DescribeUpdateBackendTaskRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeUpdateBackendTaskResponse describeUpdateBackendTask(shared_ptr<DescribeUpdateBackendTaskRequest> request);
  DescribeUpdateVpcInfoTaskResponse describeUpdateVpcInfoTaskWithOptions(shared_ptr<DescribeUpdateVpcInfoTaskRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeUpdateVpcInfoTaskResponse describeUpdateVpcInfoTask(shared_ptr<DescribeUpdateVpcInfoTaskRequest> request);
  DescribeVpcAccessesResponse describeVpcAccessesWithOptions(shared_ptr<DescribeVpcAccessesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeVpcAccessesResponse describeVpcAccesses(shared_ptr<DescribeVpcAccessesRequest> request);
  DescribeZonesResponse describeZonesWithOptions(shared_ptr<DescribeZonesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeZonesResponse describeZones(shared_ptr<DescribeZonesRequest> request);
  DetachApiProductResponse detachApiProductWithOptions(shared_ptr<DetachApiProductRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DetachApiProductResponse detachApiProduct(shared_ptr<DetachApiProductRequest> request);
  DetachPluginResponse detachPluginWithOptions(shared_ptr<DetachPluginRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DetachPluginResponse detachPlugin(shared_ptr<DetachPluginRequest> request);
  DisableInstanceAccessControlResponse disableInstanceAccessControlWithOptions(shared_ptr<DisableInstanceAccessControlRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DisableInstanceAccessControlResponse disableInstanceAccessControl(shared_ptr<DisableInstanceAccessControlRequest> request);
  DryRunSwaggerResponse dryRunSwaggerWithOptions(shared_ptr<DryRunSwaggerRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DryRunSwaggerResponse dryRunSwagger(shared_ptr<DryRunSwaggerRequest> request);
  EnableInstanceAccessControlResponse enableInstanceAccessControlWithOptions(shared_ptr<EnableInstanceAccessControlRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  EnableInstanceAccessControlResponse enableInstanceAccessControl(shared_ptr<EnableInstanceAccessControlRequest> request);
  ImportOASResponse importOASWithOptions(shared_ptr<ImportOASRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ImportOASResponse importOAS(shared_ptr<ImportOASRequest> request);
  ImportSwaggerResponse importSwaggerWithOptions(shared_ptr<ImportSwaggerRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ImportSwaggerResponse importSwagger(shared_ptr<ImportSwaggerRequest> request);
  ListTagResourcesResponse listTagResourcesWithOptions(shared_ptr<ListTagResourcesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListTagResourcesResponse listTagResources(shared_ptr<ListTagResourcesRequest> request);
  ModifyApiResponse modifyApiWithOptions(shared_ptr<ModifyApiRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyApiResponse modifyApi(shared_ptr<ModifyApiRequest> request);
  ModifyApiConfigurationResponse modifyApiConfigurationWithOptions(shared_ptr<ModifyApiConfigurationRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyApiConfigurationResponse modifyApiConfiguration(shared_ptr<ModifyApiConfigurationRequest> request);
  ModifyApiGroupResponse modifyApiGroupWithOptions(shared_ptr<ModifyApiGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyApiGroupResponse modifyApiGroup(shared_ptr<ModifyApiGroupRequest> request);
  ModifyApiGroupInstanceResponse modifyApiGroupInstanceWithOptions(shared_ptr<ModifyApiGroupInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyApiGroupInstanceResponse modifyApiGroupInstance(shared_ptr<ModifyApiGroupInstanceRequest> request);
  ModifyApiGroupNetworkPolicyResponse modifyApiGroupNetworkPolicyWithOptions(shared_ptr<ModifyApiGroupNetworkPolicyRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyApiGroupNetworkPolicyResponse modifyApiGroupNetworkPolicy(shared_ptr<ModifyApiGroupNetworkPolicyRequest> request);
  ModifyApiGroupVpcWhitelistResponse modifyApiGroupVpcWhitelistWithOptions(shared_ptr<ModifyApiGroupVpcWhitelistRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyApiGroupVpcWhitelistResponse modifyApiGroupVpcWhitelist(shared_ptr<ModifyApiGroupVpcWhitelistRequest> request);
  ModifyAppResponse modifyAppWithOptions(shared_ptr<ModifyAppRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyAppResponse modifyApp(shared_ptr<ModifyAppRequest> request);
  ModifyBackendResponse modifyBackendWithOptions(shared_ptr<ModifyBackendRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyBackendResponse modifyBackend(shared_ptr<ModifyBackendRequest> request);
  ModifyBackendModelResponse modifyBackendModelWithOptions(shared_ptr<ModifyBackendModelRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyBackendModelResponse modifyBackendModel(shared_ptr<ModifyBackendModelRequest> request);
  ModifyDatasetResponse modifyDatasetWithOptions(shared_ptr<ModifyDatasetRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyDatasetResponse modifyDataset(shared_ptr<ModifyDatasetRequest> request);
  ModifyDatasetItemResponse modifyDatasetItemWithOptions(shared_ptr<ModifyDatasetItemRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyDatasetItemResponse modifyDatasetItem(shared_ptr<ModifyDatasetItemRequest> request);
  ModifyInstanceAttributeResponse modifyInstanceAttributeWithOptions(shared_ptr<ModifyInstanceAttributeRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyInstanceAttributeResponse modifyInstanceAttribute(shared_ptr<ModifyInstanceAttributeRequest> request);
  ModifyInstanceSpecResponse modifyInstanceSpecWithOptions(shared_ptr<ModifyInstanceSpecRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyInstanceSpecResponse modifyInstanceSpec(shared_ptr<ModifyInstanceSpecRequest> request);
  ModifyIntranetDomainPolicyResponse modifyIntranetDomainPolicyWithOptions(shared_ptr<ModifyIntranetDomainPolicyRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyIntranetDomainPolicyResponse modifyIntranetDomainPolicy(shared_ptr<ModifyIntranetDomainPolicyRequest> request);
  ModifyIpControlResponse modifyIpControlWithOptions(shared_ptr<ModifyIpControlRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyIpControlResponse modifyIpControl(shared_ptr<ModifyIpControlRequest> request);
  ModifyIpControlPolicyItemResponse modifyIpControlPolicyItemWithOptions(shared_ptr<ModifyIpControlPolicyItemRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyIpControlPolicyItemResponse modifyIpControlPolicyItem(shared_ptr<ModifyIpControlPolicyItemRequest> request);
  ModifyLogConfigResponse modifyLogConfigWithOptions(shared_ptr<ModifyLogConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyLogConfigResponse modifyLogConfig(shared_ptr<ModifyLogConfigRequest> request);
  ModifyModelResponse modifyModelWithOptions(shared_ptr<ModifyModelRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyModelResponse modifyModel(shared_ptr<ModifyModelRequest> request);
  ModifyPluginResponse modifyPluginWithOptions(shared_ptr<ModifyPluginRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyPluginResponse modifyPlugin(shared_ptr<ModifyPluginRequest> request);
  ModifySignatureResponse modifySignatureWithOptions(shared_ptr<ModifySignatureRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifySignatureResponse modifySignature(shared_ptr<ModifySignatureRequest> request);
  ModifyTrafficControlResponse modifyTrafficControlWithOptions(shared_ptr<ModifyTrafficControlRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyTrafficControlResponse modifyTrafficControl(shared_ptr<ModifyTrafficControlRequest> request);
  ModifyVpcAccessAndUpdateApisResponse modifyVpcAccessAndUpdateApisWithOptions(shared_ptr<ModifyVpcAccessAndUpdateApisRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyVpcAccessAndUpdateApisResponse modifyVpcAccessAndUpdateApis(shared_ptr<ModifyVpcAccessAndUpdateApisRequest> request);
  OpenApiGatewayServiceResponse openApiGatewayServiceWithOptions(shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  OpenApiGatewayServiceResponse openApiGatewayService();
  QueryRequestLogsResponse queryRequestLogsWithOptions(shared_ptr<QueryRequestLogsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryRequestLogsResponse queryRequestLogs(shared_ptr<QueryRequestLogsRequest> request);
  ReactivateDomainResponse reactivateDomainWithOptions(shared_ptr<ReactivateDomainRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ReactivateDomainResponse reactivateDomain(shared_ptr<ReactivateDomainRequest> request);
  RemoveAccessControlListEntryResponse removeAccessControlListEntryWithOptions(shared_ptr<RemoveAccessControlListEntryRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RemoveAccessControlListEntryResponse removeAccessControlListEntry(shared_ptr<RemoveAccessControlListEntryRequest> request);
  RemoveApiProductsAuthoritiesResponse removeApiProductsAuthoritiesWithOptions(shared_ptr<RemoveApiProductsAuthoritiesRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RemoveApiProductsAuthoritiesResponse removeApiProductsAuthorities(shared_ptr<RemoveApiProductsAuthoritiesRequest> request);
  RemoveApisAuthoritiesResponse removeApisAuthoritiesWithOptions(shared_ptr<RemoveApisAuthoritiesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RemoveApisAuthoritiesResponse removeApisAuthorities(shared_ptr<RemoveApisAuthoritiesRequest> request);
  RemoveAppsAuthoritiesResponse removeAppsAuthoritiesWithOptions(shared_ptr<RemoveAppsAuthoritiesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RemoveAppsAuthoritiesResponse removeAppsAuthorities(shared_ptr<RemoveAppsAuthoritiesRequest> request);
  RemoveIpControlApisResponse removeIpControlApisWithOptions(shared_ptr<RemoveIpControlApisRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RemoveIpControlApisResponse removeIpControlApis(shared_ptr<RemoveIpControlApisRequest> request);
  RemoveIpControlPolicyItemResponse removeIpControlPolicyItemWithOptions(shared_ptr<RemoveIpControlPolicyItemRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RemoveIpControlPolicyItemResponse removeIpControlPolicyItem(shared_ptr<RemoveIpControlPolicyItemRequest> request);
  RemoveSignatureApisResponse removeSignatureApisWithOptions(shared_ptr<RemoveSignatureApisRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RemoveSignatureApisResponse removeSignatureApis(shared_ptr<RemoveSignatureApisRequest> request);
  RemoveTrafficControlApisResponse removeTrafficControlApisWithOptions(shared_ptr<RemoveTrafficControlApisRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RemoveTrafficControlApisResponse removeTrafficControlApis(shared_ptr<RemoveTrafficControlApisRequest> request);
  RemoveVpcAccessResponse removeVpcAccessWithOptions(shared_ptr<RemoveVpcAccessRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RemoveVpcAccessResponse removeVpcAccess(shared_ptr<RemoveVpcAccessRequest> request);
  RemoveVpcAccessAndAbolishApisResponse removeVpcAccessAndAbolishApisWithOptions(shared_ptr<RemoveVpcAccessAndAbolishApisRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RemoveVpcAccessAndAbolishApisResponse removeVpcAccessAndAbolishApis(shared_ptr<RemoveVpcAccessAndAbolishApisRequest> request);
  ResetAppCodeResponse resetAppCodeWithOptions(shared_ptr<ResetAppCodeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ResetAppCodeResponse resetAppCode(shared_ptr<ResetAppCodeRequest> request);
  ResetAppSecretResponse resetAppSecretWithOptions(shared_ptr<ResetAppSecretRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ResetAppSecretResponse resetAppSecret(shared_ptr<ResetAppSecretRequest> request);
  SdkGenerateByAppResponse sdkGenerateByAppWithOptions(shared_ptr<SdkGenerateByAppRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SdkGenerateByAppResponse sdkGenerateByApp(shared_ptr<SdkGenerateByAppRequest> request);
  SdkGenerateByAppForRegionResponse sdkGenerateByAppForRegionWithOptions(shared_ptr<SdkGenerateByAppForRegionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SdkGenerateByAppForRegionResponse sdkGenerateByAppForRegion(shared_ptr<SdkGenerateByAppForRegionRequest> request);
  SdkGenerateByGroupResponse sdkGenerateByGroupWithOptions(shared_ptr<SdkGenerateByGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SdkGenerateByGroupResponse sdkGenerateByGroup(shared_ptr<SdkGenerateByGroupRequest> request);
  SetAccessControlListAttributeResponse setAccessControlListAttributeWithOptions(shared_ptr<SetAccessControlListAttributeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SetAccessControlListAttributeResponse setAccessControlListAttribute(shared_ptr<SetAccessControlListAttributeRequest> request);
  SetApiProductsAuthoritiesResponse setApiProductsAuthoritiesWithOptions(shared_ptr<SetApiProductsAuthoritiesRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SetApiProductsAuthoritiesResponse setApiProductsAuthorities(shared_ptr<SetApiProductsAuthoritiesRequest> request);
  SetApisAuthoritiesResponse setApisAuthoritiesWithOptions(shared_ptr<SetApisAuthoritiesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SetApisAuthoritiesResponse setApisAuthorities(shared_ptr<SetApisAuthoritiesRequest> request);
  SetAppsAuthToApiProductResponse setAppsAuthToApiProductWithOptions(shared_ptr<SetAppsAuthToApiProductRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SetAppsAuthToApiProductResponse setAppsAuthToApiProduct(shared_ptr<SetAppsAuthToApiProductRequest> request);
  SetAppsAuthoritiesResponse setAppsAuthoritiesWithOptions(shared_ptr<SetAppsAuthoritiesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SetAppsAuthoritiesResponse setAppsAuthorities(shared_ptr<SetAppsAuthoritiesRequest> request);
  SetDomainResponse setDomainWithOptions(shared_ptr<SetDomainRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SetDomainResponse setDomain(shared_ptr<SetDomainRequest> request);
  SetDomainCertificateResponse setDomainCertificateWithOptions(shared_ptr<SetDomainCertificateRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SetDomainCertificateResponse setDomainCertificate(shared_ptr<SetDomainCertificateRequest> request);
  SetDomainWebSocketStatusResponse setDomainWebSocketStatusWithOptions(shared_ptr<SetDomainWebSocketStatusRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SetDomainWebSocketStatusResponse setDomainWebSocketStatus(shared_ptr<SetDomainWebSocketStatusRequest> request);
  SetGroupAuthAppCodeResponse setGroupAuthAppCodeWithOptions(shared_ptr<SetGroupAuthAppCodeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SetGroupAuthAppCodeResponse setGroupAuthAppCode(shared_ptr<SetGroupAuthAppCodeRequest> request);
  SetIpControlApisResponse setIpControlApisWithOptions(shared_ptr<SetIpControlApisRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SetIpControlApisResponse setIpControlApis(shared_ptr<SetIpControlApisRequest> request);
  SetSignatureApisResponse setSignatureApisWithOptions(shared_ptr<SetSignatureApisRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SetSignatureApisResponse setSignatureApis(shared_ptr<SetSignatureApisRequest> request);
  SetTrafficControlApisResponse setTrafficControlApisWithOptions(shared_ptr<SetTrafficControlApisRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SetTrafficControlApisResponse setTrafficControlApis(shared_ptr<SetTrafficControlApisRequest> request);
  SetVpcAccessResponse setVpcAccessWithOptions(shared_ptr<SetVpcAccessRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SetVpcAccessResponse setVpcAccess(shared_ptr<SetVpcAccessRequest> request);
  SetWildcardDomainPatternsResponse setWildcardDomainPatternsWithOptions(shared_ptr<SetWildcardDomainPatternsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SetWildcardDomainPatternsResponse setWildcardDomainPatterns(shared_ptr<SetWildcardDomainPatternsRequest> request);
  SwitchApiResponse switchApiWithOptions(shared_ptr<SwitchApiRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SwitchApiResponse switchApi(shared_ptr<SwitchApiRequest> request);
  TagResourcesResponse tagResourcesWithOptions(shared_ptr<TagResourcesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  TagResourcesResponse tagResources(shared_ptr<TagResourcesRequest> request);
  UntagResourcesResponse untagResourcesWithOptions(shared_ptr<UntagResourcesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UntagResourcesResponse untagResources(shared_ptr<UntagResourcesRequest> request);
  ValidateVpcConnectivityResponse validateVpcConnectivityWithOptions(shared_ptr<ValidateVpcConnectivityRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ValidateVpcConnectivityResponse validateVpcConnectivity(shared_ptr<ValidateVpcConnectivityRequest> request);

  virtual ~Client() = default;
};
} // namespace Alibabacloud_CloudAPI20160714

#endif
