// This file is auto-generated, don't edit it. Thanks.

#ifndef ALIBABACLOUD_OCEANBASEPRO20190901_H_
#define ALIBABACLOUD_OCEANBASEPRO20190901_H_

#include <alibabacloud/open_api.hpp>
#include <boost/any.hpp>
#include <darabonba/core.hpp>
#include <darabonba/util.hpp>
#include <iostream>
#include <map>
#include <vector>

using namespace std;

namespace Alibabacloud_OceanBasePro20190901 {
class DataExtraInfoSubCondsValue : public Darabonba::Model {
public:
  shared_ptr<string> tenantName{};
  shared_ptr<string> database{};
  shared_ptr<string> destDatabase{};
  shared_ptr<string> tableName{};
  shared_ptr<string> destName{};
  shared_ptr<string> whereClause{};
  shared_ptr<vector<string>> filterColumns{};
  shared_ptr<vector<string>> shardColumns{};
  shared_ptr<string> logicTableId{};
  shared_ptr<string> sourceEndpointId{};
  shared_ptr<string> sourceClientId{};

  DataExtraInfoSubCondsValue() {}

  explicit DataExtraInfoSubCondsValue(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantName) {
      res["TenantName"] = boost::any(*tenantName);
    }
    if (database) {
      res["Database"] = boost::any(*database);
    }
    if (destDatabase) {
      res["DestDatabase"] = boost::any(*destDatabase);
    }
    if (tableName) {
      res["TableName"] = boost::any(*tableName);
    }
    if (destName) {
      res["DestName"] = boost::any(*destName);
    }
    if (whereClause) {
      res["WhereClause"] = boost::any(*whereClause);
    }
    if (filterColumns) {
      res["FilterColumns"] = boost::any(*filterColumns);
    }
    if (shardColumns) {
      res["ShardColumns"] = boost::any(*shardColumns);
    }
    if (logicTableId) {
      res["LogicTableId"] = boost::any(*logicTableId);
    }
    if (sourceEndpointId) {
      res["SourceEndpointId"] = boost::any(*sourceEndpointId);
    }
    if (sourceClientId) {
      res["SourceClientId"] = boost::any(*sourceClientId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TenantName") != m.end() && !m["TenantName"].empty()) {
      tenantName = make_shared<string>(boost::any_cast<string>(m["TenantName"]));
    }
    if (m.find("Database") != m.end() && !m["Database"].empty()) {
      database = make_shared<string>(boost::any_cast<string>(m["Database"]));
    }
    if (m.find("DestDatabase") != m.end() && !m["DestDatabase"].empty()) {
      destDatabase = make_shared<string>(boost::any_cast<string>(m["DestDatabase"]));
    }
    if (m.find("TableName") != m.end() && !m["TableName"].empty()) {
      tableName = make_shared<string>(boost::any_cast<string>(m["TableName"]));
    }
    if (m.find("DestName") != m.end() && !m["DestName"].empty()) {
      destName = make_shared<string>(boost::any_cast<string>(m["DestName"]));
    }
    if (m.find("WhereClause") != m.end() && !m["WhereClause"].empty()) {
      whereClause = make_shared<string>(boost::any_cast<string>(m["WhereClause"]));
    }
    if (m.find("FilterColumns") != m.end() && !m["FilterColumns"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["FilterColumns"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["FilterColumns"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      filterColumns = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ShardColumns") != m.end() && !m["ShardColumns"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ShardColumns"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ShardColumns"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      shardColumns = make_shared<vector<string>>(toVec1);
    }
    if (m.find("LogicTableId") != m.end() && !m["LogicTableId"].empty()) {
      logicTableId = make_shared<string>(boost::any_cast<string>(m["LogicTableId"]));
    }
    if (m.find("SourceEndpointId") != m.end() && !m["SourceEndpointId"].empty()) {
      sourceEndpointId = make_shared<string>(boost::any_cast<string>(m["SourceEndpointId"]));
    }
    if (m.find("SourceClientId") != m.end() && !m["SourceClientId"].empty()) {
      sourceClientId = make_shared<string>(boost::any_cast<string>(m["SourceClientId"]));
    }
  }


  virtual ~DataExtraInfoSubCondsValue() = default;
};
class DataExtraInfoSubDbsValueTablesColumns : public Darabonba::Model {
public:
  shared_ptr<string> columnName{};
  shared_ptr<long> position{};
  shared_ptr<string> columnType{};
  shared_ptr<string> recordFieldType{};
  shared_ptr<string> rawColumnType{};
  shared_ptr<string> columnKey{};
  shared_ptr<bool> nullable{};
  shared_ptr<string> defaultValue{};
  shared_ptr<long> dataLength{};
  shared_ptr<long> dataPrecision{};
  shared_ptr<long> dataScale{};
  shared_ptr<string> encoding{};
  shared_ptr<string> columnComment{};
  shared_ptr<bool> isGenerateField{};

  DataExtraInfoSubDbsValueTablesColumns() {}

  explicit DataExtraInfoSubDbsValueTablesColumns(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (columnName) {
      res["ColumnName"] = boost::any(*columnName);
    }
    if (position) {
      res["Position"] = boost::any(*position);
    }
    if (columnType) {
      res["ColumnType"] = boost::any(*columnType);
    }
    if (recordFieldType) {
      res["RecordFieldType"] = boost::any(*recordFieldType);
    }
    if (rawColumnType) {
      res["RawColumnType"] = boost::any(*rawColumnType);
    }
    if (columnKey) {
      res["ColumnKey"] = boost::any(*columnKey);
    }
    if (nullable) {
      res["Nullable"] = boost::any(*nullable);
    }
    if (defaultValue) {
      res["DefaultValue"] = boost::any(*defaultValue);
    }
    if (dataLength) {
      res["DataLength"] = boost::any(*dataLength);
    }
    if (dataPrecision) {
      res["DataPrecision"] = boost::any(*dataPrecision);
    }
    if (dataScale) {
      res["DataScale"] = boost::any(*dataScale);
    }
    if (encoding) {
      res["Encoding"] = boost::any(*encoding);
    }
    if (columnComment) {
      res["ColumnComment"] = boost::any(*columnComment);
    }
    if (isGenerateField) {
      res["IsGenerateField"] = boost::any(*isGenerateField);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ColumnName") != m.end() && !m["ColumnName"].empty()) {
      columnName = make_shared<string>(boost::any_cast<string>(m["ColumnName"]));
    }
    if (m.find("Position") != m.end() && !m["Position"].empty()) {
      position = make_shared<long>(boost::any_cast<long>(m["Position"]));
    }
    if (m.find("ColumnType") != m.end() && !m["ColumnType"].empty()) {
      columnType = make_shared<string>(boost::any_cast<string>(m["ColumnType"]));
    }
    if (m.find("RecordFieldType") != m.end() && !m["RecordFieldType"].empty()) {
      recordFieldType = make_shared<string>(boost::any_cast<string>(m["RecordFieldType"]));
    }
    if (m.find("RawColumnType") != m.end() && !m["RawColumnType"].empty()) {
      rawColumnType = make_shared<string>(boost::any_cast<string>(m["RawColumnType"]));
    }
    if (m.find("ColumnKey") != m.end() && !m["ColumnKey"].empty()) {
      columnKey = make_shared<string>(boost::any_cast<string>(m["ColumnKey"]));
    }
    if (m.find("Nullable") != m.end() && !m["Nullable"].empty()) {
      nullable = make_shared<bool>(boost::any_cast<bool>(m["Nullable"]));
    }
    if (m.find("DefaultValue") != m.end() && !m["DefaultValue"].empty()) {
      defaultValue = make_shared<string>(boost::any_cast<string>(m["DefaultValue"]));
    }
    if (m.find("DataLength") != m.end() && !m["DataLength"].empty()) {
      dataLength = make_shared<long>(boost::any_cast<long>(m["DataLength"]));
    }
    if (m.find("DataPrecision") != m.end() && !m["DataPrecision"].empty()) {
      dataPrecision = make_shared<long>(boost::any_cast<long>(m["DataPrecision"]));
    }
    if (m.find("DataScale") != m.end() && !m["DataScale"].empty()) {
      dataScale = make_shared<long>(boost::any_cast<long>(m["DataScale"]));
    }
    if (m.find("Encoding") != m.end() && !m["Encoding"].empty()) {
      encoding = make_shared<string>(boost::any_cast<string>(m["Encoding"]));
    }
    if (m.find("ColumnComment") != m.end() && !m["ColumnComment"].empty()) {
      columnComment = make_shared<string>(boost::any_cast<string>(m["ColumnComment"]));
    }
    if (m.find("IsGenerateField") != m.end() && !m["IsGenerateField"].empty()) {
      isGenerateField = make_shared<bool>(boost::any_cast<bool>(m["IsGenerateField"]));
    }
  }


  virtual ~DataExtraInfoSubDbsValueTablesColumns() = default;
};
class DataExtraInfoSubDbsValueTables : public Darabonba::Model {
public:
  shared_ptr<string> tableId{};
  shared_ptr<string> database{};
  shared_ptr<string> tableName{};
  shared_ptr<string> mappingTableName{};
  shared_ptr<string> instance{};
  shared_ptr<vector<DataExtraInfoSubDbsValueTablesColumns>> columns{};

  DataExtraInfoSubDbsValueTables() {}

  explicit DataExtraInfoSubDbsValueTables(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tableId) {
      res["TableId"] = boost::any(*tableId);
    }
    if (database) {
      res["Database"] = boost::any(*database);
    }
    if (tableName) {
      res["TableName"] = boost::any(*tableName);
    }
    if (mappingTableName) {
      res["MappingTableName"] = boost::any(*mappingTableName);
    }
    if (instance) {
      res["Instance"] = boost::any(*instance);
    }
    if (columns) {
      vector<boost::any> temp1;
      for(auto item1:*columns){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Columns"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TableId") != m.end() && !m["TableId"].empty()) {
      tableId = make_shared<string>(boost::any_cast<string>(m["TableId"]));
    }
    if (m.find("Database") != m.end() && !m["Database"].empty()) {
      database = make_shared<string>(boost::any_cast<string>(m["Database"]));
    }
    if (m.find("TableName") != m.end() && !m["TableName"].empty()) {
      tableName = make_shared<string>(boost::any_cast<string>(m["TableName"]));
    }
    if (m.find("MappingTableName") != m.end() && !m["MappingTableName"].empty()) {
      mappingTableName = make_shared<string>(boost::any_cast<string>(m["MappingTableName"]));
    }
    if (m.find("Instance") != m.end() && !m["Instance"].empty()) {
      instance = make_shared<string>(boost::any_cast<string>(m["Instance"]));
    }
    if (m.find("Columns") != m.end() && !m["Columns"].empty()) {
      if (typeid(vector<boost::any>) == m["Columns"].type()) {
        vector<DataExtraInfoSubDbsValueTablesColumns> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Columns"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DataExtraInfoSubDbsValueTablesColumns model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        columns = make_shared<vector<DataExtraInfoSubDbsValueTablesColumns>>(expect1);
      }
    }
  }


  virtual ~DataExtraInfoSubDbsValueTables() = default;
};
class DataExtraInfoSubDbsValue : public Darabonba::Model {
public:
  shared_ptr<string> clusterName{};
  shared_ptr<string> tenantName{};
  shared_ptr<string> databaseId{};
  shared_ptr<string> databaseName{};
  shared_ptr<string> mappingDatabaseName{};
  shared_ptr<string> sourceClientId{};
  shared_ptr<vector<DataExtraInfoSubDbsValueTables>> tables{};

  DataExtraInfoSubDbsValue() {}

  explicit DataExtraInfoSubDbsValue(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterName) {
      res["ClusterName"] = boost::any(*clusterName);
    }
    if (tenantName) {
      res["TenantName"] = boost::any(*tenantName);
    }
    if (databaseId) {
      res["DatabaseId"] = boost::any(*databaseId);
    }
    if (databaseName) {
      res["DatabaseName"] = boost::any(*databaseName);
    }
    if (mappingDatabaseName) {
      res["MappingDatabaseName"] = boost::any(*mappingDatabaseName);
    }
    if (sourceClientId) {
      res["SourceClientId"] = boost::any(*sourceClientId);
    }
    if (tables) {
      vector<boost::any> temp1;
      for(auto item1:*tables){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tables"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterName") != m.end() && !m["ClusterName"].empty()) {
      clusterName = make_shared<string>(boost::any_cast<string>(m["ClusterName"]));
    }
    if (m.find("TenantName") != m.end() && !m["TenantName"].empty()) {
      tenantName = make_shared<string>(boost::any_cast<string>(m["TenantName"]));
    }
    if (m.find("DatabaseId") != m.end() && !m["DatabaseId"].empty()) {
      databaseId = make_shared<string>(boost::any_cast<string>(m["DatabaseId"]));
    }
    if (m.find("DatabaseName") != m.end() && !m["DatabaseName"].empty()) {
      databaseName = make_shared<string>(boost::any_cast<string>(m["DatabaseName"]));
    }
    if (m.find("MappingDatabaseName") != m.end() && !m["MappingDatabaseName"].empty()) {
      mappingDatabaseName = make_shared<string>(boost::any_cast<string>(m["MappingDatabaseName"]));
    }
    if (m.find("SourceClientId") != m.end() && !m["SourceClientId"].empty()) {
      sourceClientId = make_shared<string>(boost::any_cast<string>(m["SourceClientId"]));
    }
    if (m.find("Tables") != m.end() && !m["Tables"].empty()) {
      if (typeid(vector<boost::any>) == m["Tables"].type()) {
        vector<DataExtraInfoSubDbsValueTables> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tables"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DataExtraInfoSubDbsValueTables model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tables = make_shared<vector<DataExtraInfoSubDbsValueTables>>(expect1);
      }
    }
  }


  virtual ~DataExtraInfoSubDbsValue() = default;
};
class CancelProjectModifyRecordRequest : public Darabonba::Model {
public:
  shared_ptr<string> id{};

  CancelProjectModifyRecordRequest() {}

  explicit CancelProjectModifyRecordRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
  }


  virtual ~CancelProjectModifyRecordRequest() = default;
};
class CancelProjectModifyRecordResponseBodyErrorDetail : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<map<string, boost::any>> extraContext{};
  shared_ptr<string> level{};
  shared_ptr<string> message{};
  shared_ptr<map<string, string>> messageMcmsContext{};
  shared_ptr<string> messageMcmsKey{};
  shared_ptr<string> proposal{};
  shared_ptr<map<string, string>> proposalMcmsContext{};
  shared_ptr<string> proposalMcmsKey{};
  shared_ptr<string> reason{};
  shared_ptr<map<string, string>> reasonMcmsContext{};
  shared_ptr<string> reasonMcmsKey{};
  shared_ptr<boost::any> upstreamErrorDetail{};

  CancelProjectModifyRecordResponseBodyErrorDetail() {}

  explicit CancelProjectModifyRecordResponseBodyErrorDetail(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (extraContext) {
      res["ExtraContext"] = boost::any(*extraContext);
    }
    if (level) {
      res["Level"] = boost::any(*level);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (messageMcmsContext) {
      res["MessageMcmsContext"] = boost::any(*messageMcmsContext);
    }
    if (messageMcmsKey) {
      res["MessageMcmsKey"] = boost::any(*messageMcmsKey);
    }
    if (proposal) {
      res["Proposal"] = boost::any(*proposal);
    }
    if (proposalMcmsContext) {
      res["ProposalMcmsContext"] = boost::any(*proposalMcmsContext);
    }
    if (proposalMcmsKey) {
      res["ProposalMcmsKey"] = boost::any(*proposalMcmsKey);
    }
    if (reason) {
      res["Reason"] = boost::any(*reason);
    }
    if (reasonMcmsContext) {
      res["ReasonMcmsContext"] = boost::any(*reasonMcmsContext);
    }
    if (reasonMcmsKey) {
      res["ReasonMcmsKey"] = boost::any(*reasonMcmsKey);
    }
    if (upstreamErrorDetail) {
      res["UpstreamErrorDetail"] = boost::any(*upstreamErrorDetail);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ExtraContext") != m.end() && !m["ExtraContext"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["ExtraContext"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      extraContext = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<string>(boost::any_cast<string>(m["Level"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("MessageMcmsContext") != m.end() && !m["MessageMcmsContext"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["MessageMcmsContext"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      messageMcmsContext = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("MessageMcmsKey") != m.end() && !m["MessageMcmsKey"].empty()) {
      messageMcmsKey = make_shared<string>(boost::any_cast<string>(m["MessageMcmsKey"]));
    }
    if (m.find("Proposal") != m.end() && !m["Proposal"].empty()) {
      proposal = make_shared<string>(boost::any_cast<string>(m["Proposal"]));
    }
    if (m.find("ProposalMcmsContext") != m.end() && !m["ProposalMcmsContext"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["ProposalMcmsContext"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      proposalMcmsContext = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("ProposalMcmsKey") != m.end() && !m["ProposalMcmsKey"].empty()) {
      proposalMcmsKey = make_shared<string>(boost::any_cast<string>(m["ProposalMcmsKey"]));
    }
    if (m.find("Reason") != m.end() && !m["Reason"].empty()) {
      reason = make_shared<string>(boost::any_cast<string>(m["Reason"]));
    }
    if (m.find("ReasonMcmsContext") != m.end() && !m["ReasonMcmsContext"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["ReasonMcmsContext"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      reasonMcmsContext = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("ReasonMcmsKey") != m.end() && !m["ReasonMcmsKey"].empty()) {
      reasonMcmsKey = make_shared<string>(boost::any_cast<string>(m["ReasonMcmsKey"]));
    }
    if (m.find("UpstreamErrorDetail") != m.end() && !m["UpstreamErrorDetail"].empty()) {
      upstreamErrorDetail = make_shared<boost::any>(boost::any_cast<boost::any>(m["UpstreamErrorDetail"]));
    }
  }


  virtual ~CancelProjectModifyRecordResponseBodyErrorDetail() = default;
};
class CancelProjectModifyRecordResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> advice{};
  shared_ptr<string> code{};
  shared_ptr<string> cost{};
  shared_ptr<boost::any> data{};
  shared_ptr<CancelProjectModifyRecordResponseBodyErrorDetail> errorDetail{};
  shared_ptr<string> message{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<long> totalCount{};

  CancelProjectModifyRecordResponseBody() {}

  explicit CancelProjectModifyRecordResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (advice) {
      res["Advice"] = boost::any(*advice);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (cost) {
      res["Cost"] = boost::any(*cost);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (errorDetail) {
      res["ErrorDetail"] = errorDetail ? boost::any(errorDetail->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Advice") != m.end() && !m["Advice"].empty()) {
      advice = make_shared<string>(boost::any_cast<string>(m["Advice"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Cost") != m.end() && !m["Cost"].empty()) {
      cost = make_shared<string>(boost::any_cast<string>(m["Cost"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<boost::any>(boost::any_cast<boost::any>(m["Data"]));
    }
    if (m.find("ErrorDetail") != m.end() && !m["ErrorDetail"].empty()) {
      if (typeid(map<string, boost::any>) == m["ErrorDetail"].type()) {
        CancelProjectModifyRecordResponseBodyErrorDetail model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ErrorDetail"]));
        errorDetail = make_shared<CancelProjectModifyRecordResponseBodyErrorDetail>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~CancelProjectModifyRecordResponseBody() = default;
};
class CancelProjectModifyRecordResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CancelProjectModifyRecordResponseBody> body{};

  CancelProjectModifyRecordResponse() {}

  explicit CancelProjectModifyRecordResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CancelProjectModifyRecordResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CancelProjectModifyRecordResponseBody>(model1);
      }
    }
  }


  virtual ~CancelProjectModifyRecordResponse() = default;
};
class CreateBackupSetDownloadLinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> backupSetId{};
  shared_ptr<string> instanceId{};

  CreateBackupSetDownloadLinkRequest() {}

  explicit CreateBackupSetDownloadLinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (backupSetId) {
      res["BackupSetId"] = boost::any(*backupSetId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BackupSetId") != m.end() && !m["BackupSetId"].empty()) {
      backupSetId = make_shared<string>(boost::any_cast<string>(m["BackupSetId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~CreateBackupSetDownloadLinkRequest() = default;
};
class CreateBackupSetDownloadLinkResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> downloadTaskId{};
  shared_ptr<string> requestId{};

  CreateBackupSetDownloadLinkResponseBody() {}

  explicit CreateBackupSetDownloadLinkResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (downloadTaskId) {
      res["DownloadTaskId"] = boost::any(*downloadTaskId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DownloadTaskId") != m.end() && !m["DownloadTaskId"].empty()) {
      downloadTaskId = make_shared<long>(boost::any_cast<long>(m["DownloadTaskId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateBackupSetDownloadLinkResponseBody() = default;
};
class CreateBackupSetDownloadLinkResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateBackupSetDownloadLinkResponseBody> body{};

  CreateBackupSetDownloadLinkResponse() {}

  explicit CreateBackupSetDownloadLinkResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateBackupSetDownloadLinkResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateBackupSetDownloadLinkResponseBody>(model1);
      }
    }
  }


  virtual ~CreateBackupSetDownloadLinkResponse() = default;
};
class CreateDatabaseRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> collation{};
  shared_ptr<string> databaseName{};
  shared_ptr<string> description{};
  shared_ptr<string> encoding{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> tenantId{};

  CreateDatabaseRequest() {}

  explicit CreateDatabaseRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (collation) {
      res["Collation"] = boost::any(*collation);
    }
    if (databaseName) {
      res["DatabaseName"] = boost::any(*databaseName);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (encoding) {
      res["Encoding"] = boost::any(*encoding);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("Collation") != m.end() && !m["Collation"].empty()) {
      collation = make_shared<string>(boost::any_cast<string>(m["Collation"]));
    }
    if (m.find("DatabaseName") != m.end() && !m["DatabaseName"].empty()) {
      databaseName = make_shared<string>(boost::any_cast<string>(m["DatabaseName"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Encoding") != m.end() && !m["Encoding"].empty()) {
      encoding = make_shared<string>(boost::any_cast<string>(m["Encoding"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["TenantId"]));
    }
  }


  virtual ~CreateDatabaseRequest() = default;
};
class CreateDatabaseResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> databaseName{};
  shared_ptr<string> requestId{};

  CreateDatabaseResponseBody() {}

  explicit CreateDatabaseResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (databaseName) {
      res["DatabaseName"] = boost::any(*databaseName);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DatabaseName") != m.end() && !m["DatabaseName"].empty()) {
      databaseName = make_shared<string>(boost::any_cast<string>(m["DatabaseName"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateDatabaseResponseBody() = default;
};
class CreateDatabaseResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateDatabaseResponseBody> body{};

  CreateDatabaseResponse() {}

  explicit CreateDatabaseResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateDatabaseResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateDatabaseResponseBody>(model1);
      }
    }
  }


  virtual ~CreateDatabaseResponse() = default;
};
class CreateInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<bool> autoRenew{};
  shared_ptr<long> autoRenewPeriod{};
  shared_ptr<string> chargeType{};
  shared_ptr<long> diskSize{};
  shared_ptr<string> diskType{};
  shared_ptr<bool> dryRun{};
  shared_ptr<string> instanceClass{};
  shared_ptr<string> instanceName{};
  shared_ptr<string> isolationOptimization{};
  shared_ptr<string> obVersion{};
  shared_ptr<long> period{};
  shared_ptr<string> periodUnit{};
  shared_ptr<string> primaryInstance{};
  shared_ptr<string> primaryRegion{};
  shared_ptr<string> replicaMode{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> series{};
  shared_ptr<string> zones{};

  CreateInstanceRequest() {}

  explicit CreateInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (autoRenew) {
      res["AutoRenew"] = boost::any(*autoRenew);
    }
    if (autoRenewPeriod) {
      res["AutoRenewPeriod"] = boost::any(*autoRenewPeriod);
    }
    if (chargeType) {
      res["ChargeType"] = boost::any(*chargeType);
    }
    if (diskSize) {
      res["DiskSize"] = boost::any(*diskSize);
    }
    if (diskType) {
      res["DiskType"] = boost::any(*diskType);
    }
    if (dryRun) {
      res["DryRun"] = boost::any(*dryRun);
    }
    if (instanceClass) {
      res["InstanceClass"] = boost::any(*instanceClass);
    }
    if (instanceName) {
      res["InstanceName"] = boost::any(*instanceName);
    }
    if (isolationOptimization) {
      res["IsolationOptimization"] = boost::any(*isolationOptimization);
    }
    if (obVersion) {
      res["ObVersion"] = boost::any(*obVersion);
    }
    if (period) {
      res["Period"] = boost::any(*period);
    }
    if (periodUnit) {
      res["PeriodUnit"] = boost::any(*periodUnit);
    }
    if (primaryInstance) {
      res["PrimaryInstance"] = boost::any(*primaryInstance);
    }
    if (primaryRegion) {
      res["PrimaryRegion"] = boost::any(*primaryRegion);
    }
    if (replicaMode) {
      res["ReplicaMode"] = boost::any(*replicaMode);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (series) {
      res["Series"] = boost::any(*series);
    }
    if (zones) {
      res["Zones"] = boost::any(*zones);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AutoRenew") != m.end() && !m["AutoRenew"].empty()) {
      autoRenew = make_shared<bool>(boost::any_cast<bool>(m["AutoRenew"]));
    }
    if (m.find("AutoRenewPeriod") != m.end() && !m["AutoRenewPeriod"].empty()) {
      autoRenewPeriod = make_shared<long>(boost::any_cast<long>(m["AutoRenewPeriod"]));
    }
    if (m.find("ChargeType") != m.end() && !m["ChargeType"].empty()) {
      chargeType = make_shared<string>(boost::any_cast<string>(m["ChargeType"]));
    }
    if (m.find("DiskSize") != m.end() && !m["DiskSize"].empty()) {
      diskSize = make_shared<long>(boost::any_cast<long>(m["DiskSize"]));
    }
    if (m.find("DiskType") != m.end() && !m["DiskType"].empty()) {
      diskType = make_shared<string>(boost::any_cast<string>(m["DiskType"]));
    }
    if (m.find("DryRun") != m.end() && !m["DryRun"].empty()) {
      dryRun = make_shared<bool>(boost::any_cast<bool>(m["DryRun"]));
    }
    if (m.find("InstanceClass") != m.end() && !m["InstanceClass"].empty()) {
      instanceClass = make_shared<string>(boost::any_cast<string>(m["InstanceClass"]));
    }
    if (m.find("InstanceName") != m.end() && !m["InstanceName"].empty()) {
      instanceName = make_shared<string>(boost::any_cast<string>(m["InstanceName"]));
    }
    if (m.find("IsolationOptimization") != m.end() && !m["IsolationOptimization"].empty()) {
      isolationOptimization = make_shared<string>(boost::any_cast<string>(m["IsolationOptimization"]));
    }
    if (m.find("ObVersion") != m.end() && !m["ObVersion"].empty()) {
      obVersion = make_shared<string>(boost::any_cast<string>(m["ObVersion"]));
    }
    if (m.find("Period") != m.end() && !m["Period"].empty()) {
      period = make_shared<long>(boost::any_cast<long>(m["Period"]));
    }
    if (m.find("PeriodUnit") != m.end() && !m["PeriodUnit"].empty()) {
      periodUnit = make_shared<string>(boost::any_cast<string>(m["PeriodUnit"]));
    }
    if (m.find("PrimaryInstance") != m.end() && !m["PrimaryInstance"].empty()) {
      primaryInstance = make_shared<string>(boost::any_cast<string>(m["PrimaryInstance"]));
    }
    if (m.find("PrimaryRegion") != m.end() && !m["PrimaryRegion"].empty()) {
      primaryRegion = make_shared<string>(boost::any_cast<string>(m["PrimaryRegion"]));
    }
    if (m.find("ReplicaMode") != m.end() && !m["ReplicaMode"].empty()) {
      replicaMode = make_shared<string>(boost::any_cast<string>(m["ReplicaMode"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("Series") != m.end() && !m["Series"].empty()) {
      series = make_shared<string>(boost::any_cast<string>(m["Series"]));
    }
    if (m.find("Zones") != m.end() && !m["Zones"].empty()) {
      zones = make_shared<string>(boost::any_cast<string>(m["Zones"]));
    }
  }


  virtual ~CreateInstanceRequest() = default;
};
class CreateInstanceResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<bool> dryRunResult{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> orderId{};
  shared_ptr<string> resourceGroupId{};

  CreateInstanceResponseBodyData() {}

  explicit CreateInstanceResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dryRunResult) {
      res["DryRunResult"] = boost::any(*dryRunResult);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (orderId) {
      res["OrderId"] = boost::any(*orderId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DryRunResult") != m.end() && !m["DryRunResult"].empty()) {
      dryRunResult = make_shared<bool>(boost::any_cast<bool>(m["DryRunResult"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("OrderId") != m.end() && !m["OrderId"].empty()) {
      orderId = make_shared<string>(boost::any_cast<string>(m["OrderId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
  }


  virtual ~CreateInstanceResponseBodyData() = default;
};
class CreateInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<CreateInstanceResponseBodyData> data{};
  shared_ptr<string> requestId{};

  CreateInstanceResponseBody() {}

  explicit CreateInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        CreateInstanceResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<CreateInstanceResponseBodyData>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateInstanceResponseBody() = default;
};
class CreateInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateInstanceResponseBody> body{};

  CreateInstanceResponse() {}

  explicit CreateInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~CreateInstanceResponse() = default;
};
class CreateLabelRequest : public Darabonba::Model {
public:
  shared_ptr<string> name{};

  CreateLabelRequest() {}

  explicit CreateLabelRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~CreateLabelRequest() = default;
};
class CreateLabelResponseBodyErrorDetail : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<map<string, boost::any>> extraContext{};
  shared_ptr<string> level{};
  shared_ptr<string> message{};
  shared_ptr<map<string, string>> messageMcmsContext{};
  shared_ptr<string> messageMcmsKey{};
  shared_ptr<string> proposal{};
  shared_ptr<map<string, string>> proposalMcmsContext{};
  shared_ptr<string> proposalMcmsKey{};
  shared_ptr<string> reason{};
  shared_ptr<map<string, string>> reasonMcmsContext{};
  shared_ptr<string> reasonMcmsKey{};
  shared_ptr<boost::any> upstreamErrorDetail{};

  CreateLabelResponseBodyErrorDetail() {}

  explicit CreateLabelResponseBodyErrorDetail(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (extraContext) {
      res["ExtraContext"] = boost::any(*extraContext);
    }
    if (level) {
      res["Level"] = boost::any(*level);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (messageMcmsContext) {
      res["MessageMcmsContext"] = boost::any(*messageMcmsContext);
    }
    if (messageMcmsKey) {
      res["MessageMcmsKey"] = boost::any(*messageMcmsKey);
    }
    if (proposal) {
      res["Proposal"] = boost::any(*proposal);
    }
    if (proposalMcmsContext) {
      res["ProposalMcmsContext"] = boost::any(*proposalMcmsContext);
    }
    if (proposalMcmsKey) {
      res["ProposalMcmsKey"] = boost::any(*proposalMcmsKey);
    }
    if (reason) {
      res["Reason"] = boost::any(*reason);
    }
    if (reasonMcmsContext) {
      res["ReasonMcmsContext"] = boost::any(*reasonMcmsContext);
    }
    if (reasonMcmsKey) {
      res["ReasonMcmsKey"] = boost::any(*reasonMcmsKey);
    }
    if (upstreamErrorDetail) {
      res["UpstreamErrorDetail"] = boost::any(*upstreamErrorDetail);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ExtraContext") != m.end() && !m["ExtraContext"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["ExtraContext"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      extraContext = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<string>(boost::any_cast<string>(m["Level"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("MessageMcmsContext") != m.end() && !m["MessageMcmsContext"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["MessageMcmsContext"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      messageMcmsContext = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("MessageMcmsKey") != m.end() && !m["MessageMcmsKey"].empty()) {
      messageMcmsKey = make_shared<string>(boost::any_cast<string>(m["MessageMcmsKey"]));
    }
    if (m.find("Proposal") != m.end() && !m["Proposal"].empty()) {
      proposal = make_shared<string>(boost::any_cast<string>(m["Proposal"]));
    }
    if (m.find("ProposalMcmsContext") != m.end() && !m["ProposalMcmsContext"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["ProposalMcmsContext"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      proposalMcmsContext = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("ProposalMcmsKey") != m.end() && !m["ProposalMcmsKey"].empty()) {
      proposalMcmsKey = make_shared<string>(boost::any_cast<string>(m["ProposalMcmsKey"]));
    }
    if (m.find("Reason") != m.end() && !m["Reason"].empty()) {
      reason = make_shared<string>(boost::any_cast<string>(m["Reason"]));
    }
    if (m.find("ReasonMcmsContext") != m.end() && !m["ReasonMcmsContext"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["ReasonMcmsContext"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      reasonMcmsContext = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("ReasonMcmsKey") != m.end() && !m["ReasonMcmsKey"].empty()) {
      reasonMcmsKey = make_shared<string>(boost::any_cast<string>(m["ReasonMcmsKey"]));
    }
    if (m.find("UpstreamErrorDetail") != m.end() && !m["UpstreamErrorDetail"].empty()) {
      upstreamErrorDetail = make_shared<boost::any>(boost::any_cast<boost::any>(m["UpstreamErrorDetail"]));
    }
  }


  virtual ~CreateLabelResponseBodyErrorDetail() = default;
};
class CreateLabelResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> advice{};
  shared_ptr<string> code{};
  shared_ptr<string> cost{};
  shared_ptr<string> data{};
  shared_ptr<CreateLabelResponseBodyErrorDetail> errorDetail{};
  shared_ptr<string> message{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<long> totalCount{};

  CreateLabelResponseBody() {}

  explicit CreateLabelResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (advice) {
      res["Advice"] = boost::any(*advice);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (cost) {
      res["Cost"] = boost::any(*cost);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (errorDetail) {
      res["ErrorDetail"] = errorDetail ? boost::any(errorDetail->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Advice") != m.end() && !m["Advice"].empty()) {
      advice = make_shared<string>(boost::any_cast<string>(m["Advice"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Cost") != m.end() && !m["Cost"].empty()) {
      cost = make_shared<string>(boost::any_cast<string>(m["Cost"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("ErrorDetail") != m.end() && !m["ErrorDetail"].empty()) {
      if (typeid(map<string, boost::any>) == m["ErrorDetail"].type()) {
        CreateLabelResponseBodyErrorDetail model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ErrorDetail"]));
        errorDetail = make_shared<CreateLabelResponseBodyErrorDetail>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~CreateLabelResponseBody() = default;
};
class CreateLabelResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateLabelResponseBody> body{};

  CreateLabelResponse() {}

  explicit CreateLabelResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateLabelResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateLabelResponseBody>(model1);
      }
    }
  }


  virtual ~CreateLabelResponse() = default;
};
class CreateMySqlDataSourceRequest : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> dgInstanceId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> ip{};
  shared_ptr<string> name{};
  shared_ptr<string> password{};
  shared_ptr<long> port{};
  shared_ptr<string> schema{};
  shared_ptr<string> type{};
  shared_ptr<string> userName{};
  shared_ptr<string> vpcId{};

  CreateMySqlDataSourceRequest() {}

  explicit CreateMySqlDataSourceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (dgInstanceId) {
      res["DgInstanceId"] = boost::any(*dgInstanceId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (ip) {
      res["Ip"] = boost::any(*ip);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (password) {
      res["Password"] = boost::any(*password);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (schema) {
      res["Schema"] = boost::any(*schema);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (userName) {
      res["UserName"] = boost::any(*userName);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DgInstanceId") != m.end() && !m["DgInstanceId"].empty()) {
      dgInstanceId = make_shared<string>(boost::any_cast<string>(m["DgInstanceId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Ip") != m.end() && !m["Ip"].empty()) {
      ip = make_shared<string>(boost::any_cast<string>(m["Ip"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Password") != m.end() && !m["Password"].empty()) {
      password = make_shared<string>(boost::any_cast<string>(m["Password"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<long>(boost::any_cast<long>(m["Port"]));
    }
    if (m.find("Schema") != m.end() && !m["Schema"].empty()) {
      schema = make_shared<string>(boost::any_cast<string>(m["Schema"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("UserName") != m.end() && !m["UserName"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["UserName"]));
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
  }


  virtual ~CreateMySqlDataSourceRequest() = default;
};
class CreateMySqlDataSourceResponseBodyErrorDetail : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<map<string, boost::any>> extraContext{};
  shared_ptr<string> level{};
  shared_ptr<string> message{};
  shared_ptr<map<string, string>> messageMcmsContext{};
  shared_ptr<string> messageMcmsKey{};
  shared_ptr<string> proposal{};
  shared_ptr<map<string, string>> proposalMcmsContext{};
  shared_ptr<string> proposalMcmsKey{};
  shared_ptr<string> reason{};
  shared_ptr<map<string, string>> reasonMcmsContext{};
  shared_ptr<string> reasonMcmsKey{};
  shared_ptr<boost::any> upstreamErrorDetail{};

  CreateMySqlDataSourceResponseBodyErrorDetail() {}

  explicit CreateMySqlDataSourceResponseBodyErrorDetail(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (extraContext) {
      res["ExtraContext"] = boost::any(*extraContext);
    }
    if (level) {
      res["Level"] = boost::any(*level);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (messageMcmsContext) {
      res["MessageMcmsContext"] = boost::any(*messageMcmsContext);
    }
    if (messageMcmsKey) {
      res["MessageMcmsKey"] = boost::any(*messageMcmsKey);
    }
    if (proposal) {
      res["Proposal"] = boost::any(*proposal);
    }
    if (proposalMcmsContext) {
      res["ProposalMcmsContext"] = boost::any(*proposalMcmsContext);
    }
    if (proposalMcmsKey) {
      res["ProposalMcmsKey"] = boost::any(*proposalMcmsKey);
    }
    if (reason) {
      res["Reason"] = boost::any(*reason);
    }
    if (reasonMcmsContext) {
      res["ReasonMcmsContext"] = boost::any(*reasonMcmsContext);
    }
    if (reasonMcmsKey) {
      res["ReasonMcmsKey"] = boost::any(*reasonMcmsKey);
    }
    if (upstreamErrorDetail) {
      res["UpstreamErrorDetail"] = boost::any(*upstreamErrorDetail);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ExtraContext") != m.end() && !m["ExtraContext"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["ExtraContext"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      extraContext = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<string>(boost::any_cast<string>(m["Level"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("MessageMcmsContext") != m.end() && !m["MessageMcmsContext"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["MessageMcmsContext"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      messageMcmsContext = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("MessageMcmsKey") != m.end() && !m["MessageMcmsKey"].empty()) {
      messageMcmsKey = make_shared<string>(boost::any_cast<string>(m["MessageMcmsKey"]));
    }
    if (m.find("Proposal") != m.end() && !m["Proposal"].empty()) {
      proposal = make_shared<string>(boost::any_cast<string>(m["Proposal"]));
    }
    if (m.find("ProposalMcmsContext") != m.end() && !m["ProposalMcmsContext"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["ProposalMcmsContext"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      proposalMcmsContext = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("ProposalMcmsKey") != m.end() && !m["ProposalMcmsKey"].empty()) {
      proposalMcmsKey = make_shared<string>(boost::any_cast<string>(m["ProposalMcmsKey"]));
    }
    if (m.find("Reason") != m.end() && !m["Reason"].empty()) {
      reason = make_shared<string>(boost::any_cast<string>(m["Reason"]));
    }
    if (m.find("ReasonMcmsContext") != m.end() && !m["ReasonMcmsContext"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["ReasonMcmsContext"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      reasonMcmsContext = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("ReasonMcmsKey") != m.end() && !m["ReasonMcmsKey"].empty()) {
      reasonMcmsKey = make_shared<string>(boost::any_cast<string>(m["ReasonMcmsKey"]));
    }
    if (m.find("UpstreamErrorDetail") != m.end() && !m["UpstreamErrorDetail"].empty()) {
      upstreamErrorDetail = make_shared<boost::any>(boost::any_cast<boost::any>(m["UpstreamErrorDetail"]));
    }
  }


  virtual ~CreateMySqlDataSourceResponseBodyErrorDetail() = default;
};
class CreateMySqlDataSourceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> advice{};
  shared_ptr<string> code{};
  shared_ptr<string> cost{};
  shared_ptr<string> data{};
  shared_ptr<CreateMySqlDataSourceResponseBodyErrorDetail> errorDetail{};
  shared_ptr<string> message{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<long> totalCount{};

  CreateMySqlDataSourceResponseBody() {}

  explicit CreateMySqlDataSourceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (advice) {
      res["Advice"] = boost::any(*advice);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (cost) {
      res["Cost"] = boost::any(*cost);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (errorDetail) {
      res["ErrorDetail"] = errorDetail ? boost::any(errorDetail->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Advice") != m.end() && !m["Advice"].empty()) {
      advice = make_shared<string>(boost::any_cast<string>(m["Advice"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Cost") != m.end() && !m["Cost"].empty()) {
      cost = make_shared<string>(boost::any_cast<string>(m["Cost"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("ErrorDetail") != m.end() && !m["ErrorDetail"].empty()) {
      if (typeid(map<string, boost::any>) == m["ErrorDetail"].type()) {
        CreateMySqlDataSourceResponseBodyErrorDetail model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ErrorDetail"]));
        errorDetail = make_shared<CreateMySqlDataSourceResponseBodyErrorDetail>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~CreateMySqlDataSourceResponseBody() = default;
};
class CreateMySqlDataSourceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateMySqlDataSourceResponseBody> body{};

  CreateMySqlDataSourceResponse() {}

  explicit CreateMySqlDataSourceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateMySqlDataSourceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateMySqlDataSourceResponseBody>(model1);
      }
    }
  }


  virtual ~CreateMySqlDataSourceResponse() = default;
};
class CreateOceanBaseDataSourceRequest : public Darabonba::Model {
public:
  shared_ptr<string> cluster{};
  shared_ptr<string> configUrl{};
  shared_ptr<string> description{};
  shared_ptr<string> drcPassword{};
  shared_ptr<string> drcUserName{};
  shared_ptr<string> innerDrcPassword{};
  shared_ptr<string> ip{};
  shared_ptr<string> logProxyIp{};
  shared_ptr<string> logProxyPort{};
  shared_ptr<string> name{};
  shared_ptr<string> password{};
  shared_ptr<long> port{};
  shared_ptr<string> tenant{};
  shared_ptr<string> type{};
  shared_ptr<string> userName{};
  shared_ptr<string> vpcId{};

  CreateOceanBaseDataSourceRequest() {}

  explicit CreateOceanBaseDataSourceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cluster) {
      res["Cluster"] = boost::any(*cluster);
    }
    if (configUrl) {
      res["ConfigUrl"] = boost::any(*configUrl);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (drcPassword) {
      res["DrcPassword"] = boost::any(*drcPassword);
    }
    if (drcUserName) {
      res["DrcUserName"] = boost::any(*drcUserName);
    }
    if (innerDrcPassword) {
      res["InnerDrcPassword"] = boost::any(*innerDrcPassword);
    }
    if (ip) {
      res["Ip"] = boost::any(*ip);
    }
    if (logProxyIp) {
      res["LogProxyIp"] = boost::any(*logProxyIp);
    }
    if (logProxyPort) {
      res["LogProxyPort"] = boost::any(*logProxyPort);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (password) {
      res["Password"] = boost::any(*password);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (tenant) {
      res["Tenant"] = boost::any(*tenant);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (userName) {
      res["UserName"] = boost::any(*userName);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Cluster") != m.end() && !m["Cluster"].empty()) {
      cluster = make_shared<string>(boost::any_cast<string>(m["Cluster"]));
    }
    if (m.find("ConfigUrl") != m.end() && !m["ConfigUrl"].empty()) {
      configUrl = make_shared<string>(boost::any_cast<string>(m["ConfigUrl"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DrcPassword") != m.end() && !m["DrcPassword"].empty()) {
      drcPassword = make_shared<string>(boost::any_cast<string>(m["DrcPassword"]));
    }
    if (m.find("DrcUserName") != m.end() && !m["DrcUserName"].empty()) {
      drcUserName = make_shared<string>(boost::any_cast<string>(m["DrcUserName"]));
    }
    if (m.find("InnerDrcPassword") != m.end() && !m["InnerDrcPassword"].empty()) {
      innerDrcPassword = make_shared<string>(boost::any_cast<string>(m["InnerDrcPassword"]));
    }
    if (m.find("Ip") != m.end() && !m["Ip"].empty()) {
      ip = make_shared<string>(boost::any_cast<string>(m["Ip"]));
    }
    if (m.find("LogProxyIp") != m.end() && !m["LogProxyIp"].empty()) {
      logProxyIp = make_shared<string>(boost::any_cast<string>(m["LogProxyIp"]));
    }
    if (m.find("LogProxyPort") != m.end() && !m["LogProxyPort"].empty()) {
      logProxyPort = make_shared<string>(boost::any_cast<string>(m["LogProxyPort"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Password") != m.end() && !m["Password"].empty()) {
      password = make_shared<string>(boost::any_cast<string>(m["Password"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<long>(boost::any_cast<long>(m["Port"]));
    }
    if (m.find("Tenant") != m.end() && !m["Tenant"].empty()) {
      tenant = make_shared<string>(boost::any_cast<string>(m["Tenant"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("UserName") != m.end() && !m["UserName"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["UserName"]));
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
  }


  virtual ~CreateOceanBaseDataSourceRequest() = default;
};
class CreateOceanBaseDataSourceResponseBodyErrorDetail : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<map<string, boost::any>> extraContext{};
  shared_ptr<string> level{};
  shared_ptr<string> message{};
  shared_ptr<map<string, string>> messageMcmsContext{};
  shared_ptr<string> messageMcmsKey{};
  shared_ptr<string> proposal{};
  shared_ptr<map<string, string>> proposalMcmsContext{};
  shared_ptr<string> proposalMcmsKey{};
  shared_ptr<string> reason{};
  shared_ptr<map<string, string>> reasonMcmsContext{};
  shared_ptr<string> reasonMcmsKey{};
  shared_ptr<boost::any> upstreamErrorDetail{};

  CreateOceanBaseDataSourceResponseBodyErrorDetail() {}

  explicit CreateOceanBaseDataSourceResponseBodyErrorDetail(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (extraContext) {
      res["ExtraContext"] = boost::any(*extraContext);
    }
    if (level) {
      res["Level"] = boost::any(*level);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (messageMcmsContext) {
      res["MessageMcmsContext"] = boost::any(*messageMcmsContext);
    }
    if (messageMcmsKey) {
      res["MessageMcmsKey"] = boost::any(*messageMcmsKey);
    }
    if (proposal) {
      res["Proposal"] = boost::any(*proposal);
    }
    if (proposalMcmsContext) {
      res["ProposalMcmsContext"] = boost::any(*proposalMcmsContext);
    }
    if (proposalMcmsKey) {
      res["ProposalMcmsKey"] = boost::any(*proposalMcmsKey);
    }
    if (reason) {
      res["Reason"] = boost::any(*reason);
    }
    if (reasonMcmsContext) {
      res["ReasonMcmsContext"] = boost::any(*reasonMcmsContext);
    }
    if (reasonMcmsKey) {
      res["ReasonMcmsKey"] = boost::any(*reasonMcmsKey);
    }
    if (upstreamErrorDetail) {
      res["UpstreamErrorDetail"] = boost::any(*upstreamErrorDetail);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ExtraContext") != m.end() && !m["ExtraContext"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["ExtraContext"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      extraContext = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<string>(boost::any_cast<string>(m["Level"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("MessageMcmsContext") != m.end() && !m["MessageMcmsContext"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["MessageMcmsContext"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      messageMcmsContext = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("MessageMcmsKey") != m.end() && !m["MessageMcmsKey"].empty()) {
      messageMcmsKey = make_shared<string>(boost::any_cast<string>(m["MessageMcmsKey"]));
    }
    if (m.find("Proposal") != m.end() && !m["Proposal"].empty()) {
      proposal = make_shared<string>(boost::any_cast<string>(m["Proposal"]));
    }
    if (m.find("ProposalMcmsContext") != m.end() && !m["ProposalMcmsContext"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["ProposalMcmsContext"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      proposalMcmsContext = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("ProposalMcmsKey") != m.end() && !m["ProposalMcmsKey"].empty()) {
      proposalMcmsKey = make_shared<string>(boost::any_cast<string>(m["ProposalMcmsKey"]));
    }
    if (m.find("Reason") != m.end() && !m["Reason"].empty()) {
      reason = make_shared<string>(boost::any_cast<string>(m["Reason"]));
    }
    if (m.find("ReasonMcmsContext") != m.end() && !m["ReasonMcmsContext"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["ReasonMcmsContext"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      reasonMcmsContext = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("ReasonMcmsKey") != m.end() && !m["ReasonMcmsKey"].empty()) {
      reasonMcmsKey = make_shared<string>(boost::any_cast<string>(m["ReasonMcmsKey"]));
    }
    if (m.find("UpstreamErrorDetail") != m.end() && !m["UpstreamErrorDetail"].empty()) {
      upstreamErrorDetail = make_shared<boost::any>(boost::any_cast<boost::any>(m["UpstreamErrorDetail"]));
    }
  }


  virtual ~CreateOceanBaseDataSourceResponseBodyErrorDetail() = default;
};
class CreateOceanBaseDataSourceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> advice{};
  shared_ptr<string> code{};
  shared_ptr<string> cost{};
  shared_ptr<string> data{};
  shared_ptr<CreateOceanBaseDataSourceResponseBodyErrorDetail> errorDetail{};
  shared_ptr<string> message{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<long> totalCount{};

  CreateOceanBaseDataSourceResponseBody() {}

  explicit CreateOceanBaseDataSourceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (advice) {
      res["Advice"] = boost::any(*advice);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (cost) {
      res["Cost"] = boost::any(*cost);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (errorDetail) {
      res["ErrorDetail"] = errorDetail ? boost::any(errorDetail->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Advice") != m.end() && !m["Advice"].empty()) {
      advice = make_shared<string>(boost::any_cast<string>(m["Advice"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Cost") != m.end() && !m["Cost"].empty()) {
      cost = make_shared<string>(boost::any_cast<string>(m["Cost"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("ErrorDetail") != m.end() && !m["ErrorDetail"].empty()) {
      if (typeid(map<string, boost::any>) == m["ErrorDetail"].type()) {
        CreateOceanBaseDataSourceResponseBodyErrorDetail model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ErrorDetail"]));
        errorDetail = make_shared<CreateOceanBaseDataSourceResponseBodyErrorDetail>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~CreateOceanBaseDataSourceResponseBody() = default;
};
class CreateOceanBaseDataSourceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateOceanBaseDataSourceResponseBody> body{};

  CreateOceanBaseDataSourceResponse() {}

  explicit CreateOceanBaseDataSourceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateOceanBaseDataSourceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateOceanBaseDataSourceResponseBody>(model1);
      }
    }
  }


  virtual ~CreateOceanBaseDataSourceResponse() = default;
};
class CreateOmsMysqlDataSourceRequest : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> dgDatabaseId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> ip{};
  shared_ptr<string> name{};
  shared_ptr<string> password{};
  shared_ptr<string> port{};
  shared_ptr<string> schema{};
  shared_ptr<string> type{};
  shared_ptr<string> username{};
  shared_ptr<string> vpcId{};

  CreateOmsMysqlDataSourceRequest() {}

  explicit CreateOmsMysqlDataSourceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (dgDatabaseId) {
      res["DgDatabaseId"] = boost::any(*dgDatabaseId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (ip) {
      res["Ip"] = boost::any(*ip);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (password) {
      res["Password"] = boost::any(*password);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (schema) {
      res["Schema"] = boost::any(*schema);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (username) {
      res["Username"] = boost::any(*username);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DgDatabaseId") != m.end() && !m["DgDatabaseId"].empty()) {
      dgDatabaseId = make_shared<string>(boost::any_cast<string>(m["DgDatabaseId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Ip") != m.end() && !m["Ip"].empty()) {
      ip = make_shared<string>(boost::any_cast<string>(m["Ip"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Password") != m.end() && !m["Password"].empty()) {
      password = make_shared<string>(boost::any_cast<string>(m["Password"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<string>(boost::any_cast<string>(m["Port"]));
    }
    if (m.find("Schema") != m.end() && !m["Schema"].empty()) {
      schema = make_shared<string>(boost::any_cast<string>(m["Schema"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Username") != m.end() && !m["Username"].empty()) {
      username = make_shared<string>(boost::any_cast<string>(m["Username"]));
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
  }


  virtual ~CreateOmsMysqlDataSourceRequest() = default;
};
class CreateOmsMysqlDataSourceResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> endpointId{};

  CreateOmsMysqlDataSourceResponseBodyData() {}

  explicit CreateOmsMysqlDataSourceResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endpointId) {
      res["EndpointId"] = boost::any(*endpointId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndpointId") != m.end() && !m["EndpointId"].empty()) {
      endpointId = make_shared<string>(boost::any_cast<string>(m["EndpointId"]));
    }
  }


  virtual ~CreateOmsMysqlDataSourceResponseBodyData() = default;
};
class CreateOmsMysqlDataSourceResponseBody : public Darabonba::Model {
public:
  shared_ptr<CreateOmsMysqlDataSourceResponseBodyData> data{};
  shared_ptr<string> requestId{};

  CreateOmsMysqlDataSourceResponseBody() {}

  explicit CreateOmsMysqlDataSourceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        CreateOmsMysqlDataSourceResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<CreateOmsMysqlDataSourceResponseBodyData>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateOmsMysqlDataSourceResponseBody() = default;
};
class CreateOmsMysqlDataSourceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateOmsMysqlDataSourceResponseBody> body{};

  CreateOmsMysqlDataSourceResponse() {}

  explicit CreateOmsMysqlDataSourceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateOmsMysqlDataSourceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateOmsMysqlDataSourceResponseBody>(model1);
      }
    }
  }


  virtual ~CreateOmsMysqlDataSourceResponse() = default;
};
class CreateProjectRequestCommonTransferConfigCustomColumns : public Darabonba::Model {
public:
  shared_ptr<string> columnName{};
  shared_ptr<string> expression{};

  CreateProjectRequestCommonTransferConfigCustomColumns() {}

  explicit CreateProjectRequestCommonTransferConfigCustomColumns(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (columnName) {
      res["ColumnName"] = boost::any(*columnName);
    }
    if (expression) {
      res["Expression"] = boost::any(*expression);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ColumnName") != m.end() && !m["ColumnName"].empty()) {
      columnName = make_shared<string>(boost::any_cast<string>(m["ColumnName"]));
    }
    if (m.find("Expression") != m.end() && !m["Expression"].empty()) {
      expression = make_shared<string>(boost::any_cast<string>(m["Expression"]));
    }
  }


  virtual ~CreateProjectRequestCommonTransferConfigCustomColumns() = default;
};
class CreateProjectRequestCommonTransferConfig : public Darabonba::Model {
public:
  shared_ptr<bool> activeActive{};
  shared_ptr<vector<CreateProjectRequestCommonTransferConfigCustomColumns>> customColumns{};
  shared_ptr<string> dataWorksBusinessName{};
  shared_ptr<string> datahubTopicType{};
  shared_ptr<long> mqPartition{};
  shared_ptr<string> mqPartitionMode{};
  shared_ptr<string> mqSerializerType{};
  shared_ptr<bool> rocketMqEnableMsgTrace{};
  shared_ptr<string> rocketMqMsgTags{};
  shared_ptr<string> rocketMqProducerGroup{};
  shared_ptr<long> rocketMqSendMsgTimeout{};
  shared_ptr<bool> syncSchema{};
  shared_ptr<string> syncSchemaColumnName{};
  shared_ptr<string> tableCategory{};

  CreateProjectRequestCommonTransferConfig() {}

  explicit CreateProjectRequestCommonTransferConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (activeActive) {
      res["ActiveActive"] = boost::any(*activeActive);
    }
    if (customColumns) {
      vector<boost::any> temp1;
      for(auto item1:*customColumns){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CustomColumns"] = boost::any(temp1);
    }
    if (dataWorksBusinessName) {
      res["DataWorksBusinessName"] = boost::any(*dataWorksBusinessName);
    }
    if (datahubTopicType) {
      res["DatahubTopicType"] = boost::any(*datahubTopicType);
    }
    if (mqPartition) {
      res["MqPartition"] = boost::any(*mqPartition);
    }
    if (mqPartitionMode) {
      res["MqPartitionMode"] = boost::any(*mqPartitionMode);
    }
    if (mqSerializerType) {
      res["MqSerializerType"] = boost::any(*mqSerializerType);
    }
    if (rocketMqEnableMsgTrace) {
      res["RocketMqEnableMsgTrace"] = boost::any(*rocketMqEnableMsgTrace);
    }
    if (rocketMqMsgTags) {
      res["RocketMqMsgTags"] = boost::any(*rocketMqMsgTags);
    }
    if (rocketMqProducerGroup) {
      res["RocketMqProducerGroup"] = boost::any(*rocketMqProducerGroup);
    }
    if (rocketMqSendMsgTimeout) {
      res["RocketMqSendMsgTimeout"] = boost::any(*rocketMqSendMsgTimeout);
    }
    if (syncSchema) {
      res["SyncSchema"] = boost::any(*syncSchema);
    }
    if (syncSchemaColumnName) {
      res["SyncSchemaColumnName"] = boost::any(*syncSchemaColumnName);
    }
    if (tableCategory) {
      res["TableCategory"] = boost::any(*tableCategory);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ActiveActive") != m.end() && !m["ActiveActive"].empty()) {
      activeActive = make_shared<bool>(boost::any_cast<bool>(m["ActiveActive"]));
    }
    if (m.find("CustomColumns") != m.end() && !m["CustomColumns"].empty()) {
      if (typeid(vector<boost::any>) == m["CustomColumns"].type()) {
        vector<CreateProjectRequestCommonTransferConfigCustomColumns> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CustomColumns"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateProjectRequestCommonTransferConfigCustomColumns model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        customColumns = make_shared<vector<CreateProjectRequestCommonTransferConfigCustomColumns>>(expect1);
      }
    }
    if (m.find("DataWorksBusinessName") != m.end() && !m["DataWorksBusinessName"].empty()) {
      dataWorksBusinessName = make_shared<string>(boost::any_cast<string>(m["DataWorksBusinessName"]));
    }
    if (m.find("DatahubTopicType") != m.end() && !m["DatahubTopicType"].empty()) {
      datahubTopicType = make_shared<string>(boost::any_cast<string>(m["DatahubTopicType"]));
    }
    if (m.find("MqPartition") != m.end() && !m["MqPartition"].empty()) {
      mqPartition = make_shared<long>(boost::any_cast<long>(m["MqPartition"]));
    }
    if (m.find("MqPartitionMode") != m.end() && !m["MqPartitionMode"].empty()) {
      mqPartitionMode = make_shared<string>(boost::any_cast<string>(m["MqPartitionMode"]));
    }
    if (m.find("MqSerializerType") != m.end() && !m["MqSerializerType"].empty()) {
      mqSerializerType = make_shared<string>(boost::any_cast<string>(m["MqSerializerType"]));
    }
    if (m.find("RocketMqEnableMsgTrace") != m.end() && !m["RocketMqEnableMsgTrace"].empty()) {
      rocketMqEnableMsgTrace = make_shared<bool>(boost::any_cast<bool>(m["RocketMqEnableMsgTrace"]));
    }
    if (m.find("RocketMqMsgTags") != m.end() && !m["RocketMqMsgTags"].empty()) {
      rocketMqMsgTags = make_shared<string>(boost::any_cast<string>(m["RocketMqMsgTags"]));
    }
    if (m.find("RocketMqProducerGroup") != m.end() && !m["RocketMqProducerGroup"].empty()) {
      rocketMqProducerGroup = make_shared<string>(boost::any_cast<string>(m["RocketMqProducerGroup"]));
    }
    if (m.find("RocketMqSendMsgTimeout") != m.end() && !m["RocketMqSendMsgTimeout"].empty()) {
      rocketMqSendMsgTimeout = make_shared<long>(boost::any_cast<long>(m["RocketMqSendMsgTimeout"]));
    }
    if (m.find("SyncSchema") != m.end() && !m["SyncSchema"].empty()) {
      syncSchema = make_shared<bool>(boost::any_cast<bool>(m["SyncSchema"]));
    }
    if (m.find("SyncSchemaColumnName") != m.end() && !m["SyncSchemaColumnName"].empty()) {
      syncSchemaColumnName = make_shared<string>(boost::any_cast<string>(m["SyncSchemaColumnName"]));
    }
    if (m.find("TableCategory") != m.end() && !m["TableCategory"].empty()) {
      tableCategory = make_shared<string>(boost::any_cast<string>(m["TableCategory"]));
    }
  }


  virtual ~CreateProjectRequestCommonTransferConfig() = default;
};
class CreateProjectRequestFullTransferConfig : public Darabonba::Model {
public:
  shared_ptr<bool> allowDestTableNotEmpty{};
  shared_ptr<string> fullTransferSpeedMode{};
  shared_ptr<string> fullVerifySpeedMode{};
  shared_ptr<bool> nonePkUkTruncateDstTable{};
  shared_ptr<long> readWorkerNum{};
  shared_ptr<long> throttleIOPS{};
  shared_ptr<long> throttleRps{};
  shared_ptr<long> writeWorkerNum{};

  CreateProjectRequestFullTransferConfig() {}

  explicit CreateProjectRequestFullTransferConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (allowDestTableNotEmpty) {
      res["AllowDestTableNotEmpty"] = boost::any(*allowDestTableNotEmpty);
    }
    if (fullTransferSpeedMode) {
      res["FullTransferSpeedMode"] = boost::any(*fullTransferSpeedMode);
    }
    if (fullVerifySpeedMode) {
      res["FullVerifySpeedMode"] = boost::any(*fullVerifySpeedMode);
    }
    if (nonePkUkTruncateDstTable) {
      res["NonePkUkTruncateDstTable"] = boost::any(*nonePkUkTruncateDstTable);
    }
    if (readWorkerNum) {
      res["ReadWorkerNum"] = boost::any(*readWorkerNum);
    }
    if (throttleIOPS) {
      res["ThrottleIOPS"] = boost::any(*throttleIOPS);
    }
    if (throttleRps) {
      res["ThrottleRps"] = boost::any(*throttleRps);
    }
    if (writeWorkerNum) {
      res["WriteWorkerNum"] = boost::any(*writeWorkerNum);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AllowDestTableNotEmpty") != m.end() && !m["AllowDestTableNotEmpty"].empty()) {
      allowDestTableNotEmpty = make_shared<bool>(boost::any_cast<bool>(m["AllowDestTableNotEmpty"]));
    }
    if (m.find("FullTransferSpeedMode") != m.end() && !m["FullTransferSpeedMode"].empty()) {
      fullTransferSpeedMode = make_shared<string>(boost::any_cast<string>(m["FullTransferSpeedMode"]));
    }
    if (m.find("FullVerifySpeedMode") != m.end() && !m["FullVerifySpeedMode"].empty()) {
      fullVerifySpeedMode = make_shared<string>(boost::any_cast<string>(m["FullVerifySpeedMode"]));
    }
    if (m.find("NonePkUkTruncateDstTable") != m.end() && !m["NonePkUkTruncateDstTable"].empty()) {
      nonePkUkTruncateDstTable = make_shared<bool>(boost::any_cast<bool>(m["NonePkUkTruncateDstTable"]));
    }
    if (m.find("ReadWorkerNum") != m.end() && !m["ReadWorkerNum"].empty()) {
      readWorkerNum = make_shared<long>(boost::any_cast<long>(m["ReadWorkerNum"]));
    }
    if (m.find("ThrottleIOPS") != m.end() && !m["ThrottleIOPS"].empty()) {
      throttleIOPS = make_shared<long>(boost::any_cast<long>(m["ThrottleIOPS"]));
    }
    if (m.find("ThrottleRps") != m.end() && !m["ThrottleRps"].empty()) {
      throttleRps = make_shared<long>(boost::any_cast<long>(m["ThrottleRps"]));
    }
    if (m.find("WriteWorkerNum") != m.end() && !m["WriteWorkerNum"].empty()) {
      writeWorkerNum = make_shared<long>(boost::any_cast<long>(m["WriteWorkerNum"]));
    }
  }


  virtual ~CreateProjectRequestFullTransferConfig() = default;
};
class CreateProjectRequestIncrTransferConfig : public Darabonba::Model {
public:
  shared_ptr<bool> enableIncrSyncStatistics{};
  shared_ptr<bool> enableSequencingWithinTxn{};
  shared_ptr<long> incrSyncConcurrency{};
  shared_ptr<vector<string>> recordTypeWhiteList{};
  shared_ptr<string> startTimestamp{};
  shared_ptr<long> storeLogKeptHour{};
  shared_ptr<vector<string>> supportDDLTypes{};
  shared_ptr<long> throttleIOPS{};
  shared_ptr<long> throttleRps{};

  CreateProjectRequestIncrTransferConfig() {}

  explicit CreateProjectRequestIncrTransferConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (enableIncrSyncStatistics) {
      res["EnableIncrSyncStatistics"] = boost::any(*enableIncrSyncStatistics);
    }
    if (enableSequencingWithinTxn) {
      res["EnableSequencingWithinTxn"] = boost::any(*enableSequencingWithinTxn);
    }
    if (incrSyncConcurrency) {
      res["IncrSyncConcurrency"] = boost::any(*incrSyncConcurrency);
    }
    if (recordTypeWhiteList) {
      res["RecordTypeWhiteList"] = boost::any(*recordTypeWhiteList);
    }
    if (startTimestamp) {
      res["StartTimestamp"] = boost::any(*startTimestamp);
    }
    if (storeLogKeptHour) {
      res["StoreLogKeptHour"] = boost::any(*storeLogKeptHour);
    }
    if (supportDDLTypes) {
      res["SupportDDLTypes"] = boost::any(*supportDDLTypes);
    }
    if (throttleIOPS) {
      res["ThrottleIOPS"] = boost::any(*throttleIOPS);
    }
    if (throttleRps) {
      res["ThrottleRps"] = boost::any(*throttleRps);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EnableIncrSyncStatistics") != m.end() && !m["EnableIncrSyncStatistics"].empty()) {
      enableIncrSyncStatistics = make_shared<bool>(boost::any_cast<bool>(m["EnableIncrSyncStatistics"]));
    }
    if (m.find("EnableSequencingWithinTxn") != m.end() && !m["EnableSequencingWithinTxn"].empty()) {
      enableSequencingWithinTxn = make_shared<bool>(boost::any_cast<bool>(m["EnableSequencingWithinTxn"]));
    }
    if (m.find("IncrSyncConcurrency") != m.end() && !m["IncrSyncConcurrency"].empty()) {
      incrSyncConcurrency = make_shared<long>(boost::any_cast<long>(m["IncrSyncConcurrency"]));
    }
    if (m.find("RecordTypeWhiteList") != m.end() && !m["RecordTypeWhiteList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["RecordTypeWhiteList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["RecordTypeWhiteList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      recordTypeWhiteList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("StartTimestamp") != m.end() && !m["StartTimestamp"].empty()) {
      startTimestamp = make_shared<string>(boost::any_cast<string>(m["StartTimestamp"]));
    }
    if (m.find("StoreLogKeptHour") != m.end() && !m["StoreLogKeptHour"].empty()) {
      storeLogKeptHour = make_shared<long>(boost::any_cast<long>(m["StoreLogKeptHour"]));
    }
    if (m.find("SupportDDLTypes") != m.end() && !m["SupportDDLTypes"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SupportDDLTypes"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SupportDDLTypes"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      supportDDLTypes = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ThrottleIOPS") != m.end() && !m["ThrottleIOPS"].empty()) {
      throttleIOPS = make_shared<long>(boost::any_cast<long>(m["ThrottleIOPS"]));
    }
    if (m.find("ThrottleRps") != m.end() && !m["ThrottleRps"].empty()) {
      throttleRps = make_shared<long>(boost::any_cast<long>(m["ThrottleRps"]));
    }
  }


  virtual ~CreateProjectRequestIncrTransferConfig() = default;
};
class CreateProjectRequestReverseIncrTransferConfig : public Darabonba::Model {
public:
  shared_ptr<bool> enableIncrSyncStatistics{};
  shared_ptr<bool> enableSequencingWithinTxn{};
  shared_ptr<long> incrSyncConcurrency{};
  shared_ptr<vector<string>> recordTypeWhiteList{};
  shared_ptr<string> startTimestamp{};
  shared_ptr<long> storeLogKeptHour{};
  shared_ptr<vector<string>> supportDDLTypes{};
  shared_ptr<long> throttleIOPS{};
  shared_ptr<long> throttleRps{};

  CreateProjectRequestReverseIncrTransferConfig() {}

  explicit CreateProjectRequestReverseIncrTransferConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (enableIncrSyncStatistics) {
      res["EnableIncrSyncStatistics"] = boost::any(*enableIncrSyncStatistics);
    }
    if (enableSequencingWithinTxn) {
      res["EnableSequencingWithinTxn"] = boost::any(*enableSequencingWithinTxn);
    }
    if (incrSyncConcurrency) {
      res["IncrSyncConcurrency"] = boost::any(*incrSyncConcurrency);
    }
    if (recordTypeWhiteList) {
      res["RecordTypeWhiteList"] = boost::any(*recordTypeWhiteList);
    }
    if (startTimestamp) {
      res["StartTimestamp"] = boost::any(*startTimestamp);
    }
    if (storeLogKeptHour) {
      res["StoreLogKeptHour"] = boost::any(*storeLogKeptHour);
    }
    if (supportDDLTypes) {
      res["SupportDDLTypes"] = boost::any(*supportDDLTypes);
    }
    if (throttleIOPS) {
      res["ThrottleIOPS"] = boost::any(*throttleIOPS);
    }
    if (throttleRps) {
      res["ThrottleRps"] = boost::any(*throttleRps);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EnableIncrSyncStatistics") != m.end() && !m["EnableIncrSyncStatistics"].empty()) {
      enableIncrSyncStatistics = make_shared<bool>(boost::any_cast<bool>(m["EnableIncrSyncStatistics"]));
    }
    if (m.find("EnableSequencingWithinTxn") != m.end() && !m["EnableSequencingWithinTxn"].empty()) {
      enableSequencingWithinTxn = make_shared<bool>(boost::any_cast<bool>(m["EnableSequencingWithinTxn"]));
    }
    if (m.find("IncrSyncConcurrency") != m.end() && !m["IncrSyncConcurrency"].empty()) {
      incrSyncConcurrency = make_shared<long>(boost::any_cast<long>(m["IncrSyncConcurrency"]));
    }
    if (m.find("RecordTypeWhiteList") != m.end() && !m["RecordTypeWhiteList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["RecordTypeWhiteList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["RecordTypeWhiteList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      recordTypeWhiteList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("StartTimestamp") != m.end() && !m["StartTimestamp"].empty()) {
      startTimestamp = make_shared<string>(boost::any_cast<string>(m["StartTimestamp"]));
    }
    if (m.find("StoreLogKeptHour") != m.end() && !m["StoreLogKeptHour"].empty()) {
      storeLogKeptHour = make_shared<long>(boost::any_cast<long>(m["StoreLogKeptHour"]));
    }
    if (m.find("SupportDDLTypes") != m.end() && !m["SupportDDLTypes"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SupportDDLTypes"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SupportDDLTypes"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      supportDDLTypes = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ThrottleIOPS") != m.end() && !m["ThrottleIOPS"].empty()) {
      throttleIOPS = make_shared<long>(boost::any_cast<long>(m["ThrottleIOPS"]));
    }
    if (m.find("ThrottleRps") != m.end() && !m["ThrottleRps"].empty()) {
      throttleRps = make_shared<long>(boost::any_cast<long>(m["ThrottleRps"]));
    }
  }


  virtual ~CreateProjectRequestReverseIncrTransferConfig() = default;
};
class CreateProjectRequestStructTransferConfig : public Darabonba::Model {
public:
  shared_ptr<string> byteCharConvertStrategy{};
  shared_ptr<bool> deferIndexCreation{};

  CreateProjectRequestStructTransferConfig() {}

  explicit CreateProjectRequestStructTransferConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (byteCharConvertStrategy) {
      res["ByteCharConvertStrategy"] = boost::any(*byteCharConvertStrategy);
    }
    if (deferIndexCreation) {
      res["DeferIndexCreation"] = boost::any(*deferIndexCreation);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ByteCharConvertStrategy") != m.end() && !m["ByteCharConvertStrategy"].empty()) {
      byteCharConvertStrategy = make_shared<string>(boost::any_cast<string>(m["ByteCharConvertStrategy"]));
    }
    if (m.find("DeferIndexCreation") != m.end() && !m["DeferIndexCreation"].empty()) {
      deferIndexCreation = make_shared<bool>(boost::any_cast<bool>(m["DeferIndexCreation"]));
    }
  }


  virtual ~CreateProjectRequestStructTransferConfig() = default;
};
class CreateProjectRequestTransferMappingDatabasesSpecificTablesAdbTableSchema : public Darabonba::Model {
public:
  shared_ptr<vector<string>> distributedKeys{};
  shared_ptr<string> partitionLifeCycle{};
  shared_ptr<string> partitionStatement{};
  shared_ptr<vector<string>> primaryKeys{};

  CreateProjectRequestTransferMappingDatabasesSpecificTablesAdbTableSchema() {}

  explicit CreateProjectRequestTransferMappingDatabasesSpecificTablesAdbTableSchema(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (distributedKeys) {
      res["DistributedKeys"] = boost::any(*distributedKeys);
    }
    if (partitionLifeCycle) {
      res["PartitionLifeCycle"] = boost::any(*partitionLifeCycle);
    }
    if (partitionStatement) {
      res["PartitionStatement"] = boost::any(*partitionStatement);
    }
    if (primaryKeys) {
      res["PrimaryKeys"] = boost::any(*primaryKeys);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DistributedKeys") != m.end() && !m["DistributedKeys"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DistributedKeys"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DistributedKeys"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      distributedKeys = make_shared<vector<string>>(toVec1);
    }
    if (m.find("PartitionLifeCycle") != m.end() && !m["PartitionLifeCycle"].empty()) {
      partitionLifeCycle = make_shared<string>(boost::any_cast<string>(m["PartitionLifeCycle"]));
    }
    if (m.find("PartitionStatement") != m.end() && !m["PartitionStatement"].empty()) {
      partitionStatement = make_shared<string>(boost::any_cast<string>(m["PartitionStatement"]));
    }
    if (m.find("PrimaryKeys") != m.end() && !m["PrimaryKeys"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["PrimaryKeys"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["PrimaryKeys"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      primaryKeys = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~CreateProjectRequestTransferMappingDatabasesSpecificTablesAdbTableSchema() = default;
};
class CreateProjectRequestTransferMappingDatabasesSpecificTables : public Darabonba::Model {
public:
  shared_ptr<CreateProjectRequestTransferMappingDatabasesSpecificTablesAdbTableSchema> adbTableSchema{};
  shared_ptr<vector<string>> filterColumns{};
  shared_ptr<string> id{};
  shared_ptr<string> mappedName{};
  shared_ptr<string> name{};
  shared_ptr<vector<string>> shardColumns{};
  shared_ptr<string> whereClause{};

  CreateProjectRequestTransferMappingDatabasesSpecificTables() {}

  explicit CreateProjectRequestTransferMappingDatabasesSpecificTables(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (adbTableSchema) {
      res["AdbTableSchema"] = adbTableSchema ? boost::any(adbTableSchema->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (filterColumns) {
      res["FilterColumns"] = boost::any(*filterColumns);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (mappedName) {
      res["MappedName"] = boost::any(*mappedName);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (shardColumns) {
      res["ShardColumns"] = boost::any(*shardColumns);
    }
    if (whereClause) {
      res["WhereClause"] = boost::any(*whereClause);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AdbTableSchema") != m.end() && !m["AdbTableSchema"].empty()) {
      if (typeid(map<string, boost::any>) == m["AdbTableSchema"].type()) {
        CreateProjectRequestTransferMappingDatabasesSpecificTablesAdbTableSchema model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AdbTableSchema"]));
        adbTableSchema = make_shared<CreateProjectRequestTransferMappingDatabasesSpecificTablesAdbTableSchema>(model1);
      }
    }
    if (m.find("FilterColumns") != m.end() && !m["FilterColumns"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["FilterColumns"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["FilterColumns"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      filterColumns = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("MappedName") != m.end() && !m["MappedName"].empty()) {
      mappedName = make_shared<string>(boost::any_cast<string>(m["MappedName"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ShardColumns") != m.end() && !m["ShardColumns"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ShardColumns"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ShardColumns"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      shardColumns = make_shared<vector<string>>(toVec1);
    }
    if (m.find("WhereClause") != m.end() && !m["WhereClause"].empty()) {
      whereClause = make_shared<string>(boost::any_cast<string>(m["WhereClause"]));
    }
  }


  virtual ~CreateProjectRequestTransferMappingDatabasesSpecificTables() = default;
};
class CreateProjectRequestTransferMappingDatabasesSpecificViewsAdbTableSchema : public Darabonba::Model {
public:
  shared_ptr<vector<string>> distributedKeys{};
  shared_ptr<string> partitionLifeCycle{};
  shared_ptr<string> partitionStatement{};
  shared_ptr<vector<string>> primaryKeys{};

  CreateProjectRequestTransferMappingDatabasesSpecificViewsAdbTableSchema() {}

  explicit CreateProjectRequestTransferMappingDatabasesSpecificViewsAdbTableSchema(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (distributedKeys) {
      res["DistributedKeys"] = boost::any(*distributedKeys);
    }
    if (partitionLifeCycle) {
      res["PartitionLifeCycle"] = boost::any(*partitionLifeCycle);
    }
    if (partitionStatement) {
      res["PartitionStatement"] = boost::any(*partitionStatement);
    }
    if (primaryKeys) {
      res["PrimaryKeys"] = boost::any(*primaryKeys);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DistributedKeys") != m.end() && !m["DistributedKeys"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DistributedKeys"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DistributedKeys"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      distributedKeys = make_shared<vector<string>>(toVec1);
    }
    if (m.find("PartitionLifeCycle") != m.end() && !m["PartitionLifeCycle"].empty()) {
      partitionLifeCycle = make_shared<string>(boost::any_cast<string>(m["PartitionLifeCycle"]));
    }
    if (m.find("PartitionStatement") != m.end() && !m["PartitionStatement"].empty()) {
      partitionStatement = make_shared<string>(boost::any_cast<string>(m["PartitionStatement"]));
    }
    if (m.find("PrimaryKeys") != m.end() && !m["PrimaryKeys"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["PrimaryKeys"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["PrimaryKeys"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      primaryKeys = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~CreateProjectRequestTransferMappingDatabasesSpecificViewsAdbTableSchema() = default;
};
class CreateProjectRequestTransferMappingDatabasesSpecificViews : public Darabonba::Model {
public:
  shared_ptr<CreateProjectRequestTransferMappingDatabasesSpecificViewsAdbTableSchema> adbTableSchema{};
  shared_ptr<vector<string>> filterColumns{};
  shared_ptr<string> id{};
  shared_ptr<string> mappedName{};
  shared_ptr<string> name{};
  shared_ptr<vector<string>> shardColumns{};
  shared_ptr<string> whereClause{};

  CreateProjectRequestTransferMappingDatabasesSpecificViews() {}

  explicit CreateProjectRequestTransferMappingDatabasesSpecificViews(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (adbTableSchema) {
      res["AdbTableSchema"] = adbTableSchema ? boost::any(adbTableSchema->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (filterColumns) {
      res["FilterColumns"] = boost::any(*filterColumns);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (mappedName) {
      res["MappedName"] = boost::any(*mappedName);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (shardColumns) {
      res["ShardColumns"] = boost::any(*shardColumns);
    }
    if (whereClause) {
      res["WhereClause"] = boost::any(*whereClause);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AdbTableSchema") != m.end() && !m["AdbTableSchema"].empty()) {
      if (typeid(map<string, boost::any>) == m["AdbTableSchema"].type()) {
        CreateProjectRequestTransferMappingDatabasesSpecificViewsAdbTableSchema model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AdbTableSchema"]));
        adbTableSchema = make_shared<CreateProjectRequestTransferMappingDatabasesSpecificViewsAdbTableSchema>(model1);
      }
    }
    if (m.find("FilterColumns") != m.end() && !m["FilterColumns"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["FilterColumns"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["FilterColumns"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      filterColumns = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("MappedName") != m.end() && !m["MappedName"].empty()) {
      mappedName = make_shared<string>(boost::any_cast<string>(m["MappedName"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ShardColumns") != m.end() && !m["ShardColumns"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ShardColumns"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ShardColumns"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      shardColumns = make_shared<vector<string>>(toVec1);
    }
    if (m.find("WhereClause") != m.end() && !m["WhereClause"].empty()) {
      whereClause = make_shared<string>(boost::any_cast<string>(m["WhereClause"]));
    }
  }


  virtual ~CreateProjectRequestTransferMappingDatabasesSpecificViews() = default;
};
class CreateProjectRequestTransferMappingDatabasesTablesAdbTableSchema : public Darabonba::Model {
public:
  shared_ptr<vector<string>> distributedKeys{};
  shared_ptr<string> partitionLifeCycle{};
  shared_ptr<string> partitionStatement{};
  shared_ptr<vector<string>> primaryKeys{};

  CreateProjectRequestTransferMappingDatabasesTablesAdbTableSchema() {}

  explicit CreateProjectRequestTransferMappingDatabasesTablesAdbTableSchema(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (distributedKeys) {
      res["DistributedKeys"] = boost::any(*distributedKeys);
    }
    if (partitionLifeCycle) {
      res["PartitionLifeCycle"] = boost::any(*partitionLifeCycle);
    }
    if (partitionStatement) {
      res["PartitionStatement"] = boost::any(*partitionStatement);
    }
    if (primaryKeys) {
      res["PrimaryKeys"] = boost::any(*primaryKeys);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DistributedKeys") != m.end() && !m["DistributedKeys"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DistributedKeys"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DistributedKeys"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      distributedKeys = make_shared<vector<string>>(toVec1);
    }
    if (m.find("PartitionLifeCycle") != m.end() && !m["PartitionLifeCycle"].empty()) {
      partitionLifeCycle = make_shared<string>(boost::any_cast<string>(m["PartitionLifeCycle"]));
    }
    if (m.find("PartitionStatement") != m.end() && !m["PartitionStatement"].empty()) {
      partitionStatement = make_shared<string>(boost::any_cast<string>(m["PartitionStatement"]));
    }
    if (m.find("PrimaryKeys") != m.end() && !m["PrimaryKeys"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["PrimaryKeys"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["PrimaryKeys"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      primaryKeys = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~CreateProjectRequestTransferMappingDatabasesTablesAdbTableSchema() = default;
};
class CreateProjectRequestTransferMappingDatabasesTables : public Darabonba::Model {
public:
  shared_ptr<CreateProjectRequestTransferMappingDatabasesTablesAdbTableSchema> adbTableSchema{};
  shared_ptr<vector<string>> filterColumns{};
  shared_ptr<string> id{};
  shared_ptr<string> mappedName{};
  shared_ptr<string> name{};
  shared_ptr<vector<string>> shardColumns{};
  shared_ptr<string> whereClause{};

  CreateProjectRequestTransferMappingDatabasesTables() {}

  explicit CreateProjectRequestTransferMappingDatabasesTables(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (adbTableSchema) {
      res["AdbTableSchema"] = adbTableSchema ? boost::any(adbTableSchema->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (filterColumns) {
      res["FilterColumns"] = boost::any(*filterColumns);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (mappedName) {
      res["MappedName"] = boost::any(*mappedName);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (shardColumns) {
      res["ShardColumns"] = boost::any(*shardColumns);
    }
    if (whereClause) {
      res["WhereClause"] = boost::any(*whereClause);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AdbTableSchema") != m.end() && !m["AdbTableSchema"].empty()) {
      if (typeid(map<string, boost::any>) == m["AdbTableSchema"].type()) {
        CreateProjectRequestTransferMappingDatabasesTablesAdbTableSchema model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AdbTableSchema"]));
        adbTableSchema = make_shared<CreateProjectRequestTransferMappingDatabasesTablesAdbTableSchema>(model1);
      }
    }
    if (m.find("FilterColumns") != m.end() && !m["FilterColumns"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["FilterColumns"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["FilterColumns"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      filterColumns = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("MappedName") != m.end() && !m["MappedName"].empty()) {
      mappedName = make_shared<string>(boost::any_cast<string>(m["MappedName"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ShardColumns") != m.end() && !m["ShardColumns"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ShardColumns"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ShardColumns"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      shardColumns = make_shared<vector<string>>(toVec1);
    }
    if (m.find("WhereClause") != m.end() && !m["WhereClause"].empty()) {
      whereClause = make_shared<string>(boost::any_cast<string>(m["WhereClause"]));
    }
  }


  virtual ~CreateProjectRequestTransferMappingDatabasesTables() = default;
};
class CreateProjectRequestTransferMappingDatabasesViewsAdbTableSchema : public Darabonba::Model {
public:
  shared_ptr<vector<string>> distributedKeys{};
  shared_ptr<string> partitionLifeCycle{};
  shared_ptr<string> partitionStatement{};
  shared_ptr<vector<string>> primaryKeys{};

  CreateProjectRequestTransferMappingDatabasesViewsAdbTableSchema() {}

  explicit CreateProjectRequestTransferMappingDatabasesViewsAdbTableSchema(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (distributedKeys) {
      res["DistributedKeys"] = boost::any(*distributedKeys);
    }
    if (partitionLifeCycle) {
      res["PartitionLifeCycle"] = boost::any(*partitionLifeCycle);
    }
    if (partitionStatement) {
      res["PartitionStatement"] = boost::any(*partitionStatement);
    }
    if (primaryKeys) {
      res["PrimaryKeys"] = boost::any(*primaryKeys);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DistributedKeys") != m.end() && !m["DistributedKeys"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DistributedKeys"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DistributedKeys"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      distributedKeys = make_shared<vector<string>>(toVec1);
    }
    if (m.find("PartitionLifeCycle") != m.end() && !m["PartitionLifeCycle"].empty()) {
      partitionLifeCycle = make_shared<string>(boost::any_cast<string>(m["PartitionLifeCycle"]));
    }
    if (m.find("PartitionStatement") != m.end() && !m["PartitionStatement"].empty()) {
      partitionStatement = make_shared<string>(boost::any_cast<string>(m["PartitionStatement"]));
    }
    if (m.find("PrimaryKeys") != m.end() && !m["PrimaryKeys"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["PrimaryKeys"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["PrimaryKeys"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      primaryKeys = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~CreateProjectRequestTransferMappingDatabasesViewsAdbTableSchema() = default;
};
class CreateProjectRequestTransferMappingDatabasesViews : public Darabonba::Model {
public:
  shared_ptr<CreateProjectRequestTransferMappingDatabasesViewsAdbTableSchema> adbTableSchema{};
  shared_ptr<vector<string>> filterColumns{};
  shared_ptr<string> id{};
  shared_ptr<string> mappedName{};
  shared_ptr<string> name{};
  shared_ptr<vector<string>> shardColumns{};
  shared_ptr<string> whereClause{};

  CreateProjectRequestTransferMappingDatabasesViews() {}

  explicit CreateProjectRequestTransferMappingDatabasesViews(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (adbTableSchema) {
      res["AdbTableSchema"] = adbTableSchema ? boost::any(adbTableSchema->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (filterColumns) {
      res["FilterColumns"] = boost::any(*filterColumns);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (mappedName) {
      res["MappedName"] = boost::any(*mappedName);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (shardColumns) {
      res["ShardColumns"] = boost::any(*shardColumns);
    }
    if (whereClause) {
      res["WhereClause"] = boost::any(*whereClause);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AdbTableSchema") != m.end() && !m["AdbTableSchema"].empty()) {
      if (typeid(map<string, boost::any>) == m["AdbTableSchema"].type()) {
        CreateProjectRequestTransferMappingDatabasesViewsAdbTableSchema model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AdbTableSchema"]));
        adbTableSchema = make_shared<CreateProjectRequestTransferMappingDatabasesViewsAdbTableSchema>(model1);
      }
    }
    if (m.find("FilterColumns") != m.end() && !m["FilterColumns"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["FilterColumns"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["FilterColumns"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      filterColumns = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("MappedName") != m.end() && !m["MappedName"].empty()) {
      mappedName = make_shared<string>(boost::any_cast<string>(m["MappedName"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ShardColumns") != m.end() && !m["ShardColumns"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ShardColumns"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ShardColumns"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      shardColumns = make_shared<vector<string>>(toVec1);
    }
    if (m.find("WhereClause") != m.end() && !m["WhereClause"].empty()) {
      whereClause = make_shared<string>(boost::any_cast<string>(m["WhereClause"]));
    }
  }


  virtual ~CreateProjectRequestTransferMappingDatabasesViews() = default;
};
class CreateProjectRequestTransferMappingDatabases : public Darabonba::Model {
public:
  shared_ptr<string> clusterName{};
  shared_ptr<string> id{};
  shared_ptr<string> mappedName{};
  shared_ptr<string> name{};
  shared_ptr<vector<CreateProjectRequestTransferMappingDatabasesSpecificTables>> specificTables{};
  shared_ptr<vector<CreateProjectRequestTransferMappingDatabasesSpecificViews>> specificViews{};
  shared_ptr<vector<CreateProjectRequestTransferMappingDatabasesTables>> tables{};
  shared_ptr<string> tenantName{};
  shared_ptr<vector<CreateProjectRequestTransferMappingDatabasesViews>> views{};

  CreateProjectRequestTransferMappingDatabases() {}

  explicit CreateProjectRequestTransferMappingDatabases(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterName) {
      res["ClusterName"] = boost::any(*clusterName);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (mappedName) {
      res["MappedName"] = boost::any(*mappedName);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (specificTables) {
      vector<boost::any> temp1;
      for(auto item1:*specificTables){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SpecificTables"] = boost::any(temp1);
    }
    if (specificViews) {
      vector<boost::any> temp1;
      for(auto item1:*specificViews){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SpecificViews"] = boost::any(temp1);
    }
    if (tables) {
      vector<boost::any> temp1;
      for(auto item1:*tables){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tables"] = boost::any(temp1);
    }
    if (tenantName) {
      res["TenantName"] = boost::any(*tenantName);
    }
    if (views) {
      vector<boost::any> temp1;
      for(auto item1:*views){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Views"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterName") != m.end() && !m["ClusterName"].empty()) {
      clusterName = make_shared<string>(boost::any_cast<string>(m["ClusterName"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("MappedName") != m.end() && !m["MappedName"].empty()) {
      mappedName = make_shared<string>(boost::any_cast<string>(m["MappedName"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("SpecificTables") != m.end() && !m["SpecificTables"].empty()) {
      if (typeid(vector<boost::any>) == m["SpecificTables"].type()) {
        vector<CreateProjectRequestTransferMappingDatabasesSpecificTables> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SpecificTables"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateProjectRequestTransferMappingDatabasesSpecificTables model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        specificTables = make_shared<vector<CreateProjectRequestTransferMappingDatabasesSpecificTables>>(expect1);
      }
    }
    if (m.find("SpecificViews") != m.end() && !m["SpecificViews"].empty()) {
      if (typeid(vector<boost::any>) == m["SpecificViews"].type()) {
        vector<CreateProjectRequestTransferMappingDatabasesSpecificViews> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SpecificViews"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateProjectRequestTransferMappingDatabasesSpecificViews model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        specificViews = make_shared<vector<CreateProjectRequestTransferMappingDatabasesSpecificViews>>(expect1);
      }
    }
    if (m.find("Tables") != m.end() && !m["Tables"].empty()) {
      if (typeid(vector<boost::any>) == m["Tables"].type()) {
        vector<CreateProjectRequestTransferMappingDatabasesTables> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tables"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateProjectRequestTransferMappingDatabasesTables model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tables = make_shared<vector<CreateProjectRequestTransferMappingDatabasesTables>>(expect1);
      }
    }
    if (m.find("TenantName") != m.end() && !m["TenantName"].empty()) {
      tenantName = make_shared<string>(boost::any_cast<string>(m["TenantName"]));
    }
    if (m.find("Views") != m.end() && !m["Views"].empty()) {
      if (typeid(vector<boost::any>) == m["Views"].type()) {
        vector<CreateProjectRequestTransferMappingDatabasesViews> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Views"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateProjectRequestTransferMappingDatabasesViews model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        views = make_shared<vector<CreateProjectRequestTransferMappingDatabasesViews>>(expect1);
      }
    }
  }


  virtual ~CreateProjectRequestTransferMappingDatabases() = default;
};
class CreateProjectRequestTransferMappingDatabasesBlackSpecificTablesAdbTableSchema : public Darabonba::Model {
public:
  shared_ptr<vector<string>> distributedKeys{};
  shared_ptr<string> partitionLifeCycle{};
  shared_ptr<string> partitionStatement{};
  shared_ptr<vector<string>> primaryKeys{};

  CreateProjectRequestTransferMappingDatabasesBlackSpecificTablesAdbTableSchema() {}

  explicit CreateProjectRequestTransferMappingDatabasesBlackSpecificTablesAdbTableSchema(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (distributedKeys) {
      res["DistributedKeys"] = boost::any(*distributedKeys);
    }
    if (partitionLifeCycle) {
      res["PartitionLifeCycle"] = boost::any(*partitionLifeCycle);
    }
    if (partitionStatement) {
      res["PartitionStatement"] = boost::any(*partitionStatement);
    }
    if (primaryKeys) {
      res["PrimaryKeys"] = boost::any(*primaryKeys);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DistributedKeys") != m.end() && !m["DistributedKeys"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DistributedKeys"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DistributedKeys"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      distributedKeys = make_shared<vector<string>>(toVec1);
    }
    if (m.find("PartitionLifeCycle") != m.end() && !m["PartitionLifeCycle"].empty()) {
      partitionLifeCycle = make_shared<string>(boost::any_cast<string>(m["PartitionLifeCycle"]));
    }
    if (m.find("PartitionStatement") != m.end() && !m["PartitionStatement"].empty()) {
      partitionStatement = make_shared<string>(boost::any_cast<string>(m["PartitionStatement"]));
    }
    if (m.find("PrimaryKeys") != m.end() && !m["PrimaryKeys"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["PrimaryKeys"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["PrimaryKeys"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      primaryKeys = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~CreateProjectRequestTransferMappingDatabasesBlackSpecificTablesAdbTableSchema() = default;
};
class CreateProjectRequestTransferMappingDatabasesBlackSpecificTables : public Darabonba::Model {
public:
  shared_ptr<CreateProjectRequestTransferMappingDatabasesBlackSpecificTablesAdbTableSchema> adbTableSchema{};
  shared_ptr<vector<string>> filterColumns{};
  shared_ptr<string> id{};
  shared_ptr<string> mappedName{};
  shared_ptr<string> name{};
  shared_ptr<vector<string>> shardColumns{};
  shared_ptr<string> whereClause{};

  CreateProjectRequestTransferMappingDatabasesBlackSpecificTables() {}

  explicit CreateProjectRequestTransferMappingDatabasesBlackSpecificTables(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (adbTableSchema) {
      res["AdbTableSchema"] = adbTableSchema ? boost::any(adbTableSchema->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (filterColumns) {
      res["FilterColumns"] = boost::any(*filterColumns);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (mappedName) {
      res["MappedName"] = boost::any(*mappedName);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (shardColumns) {
      res["ShardColumns"] = boost::any(*shardColumns);
    }
    if (whereClause) {
      res["WhereClause"] = boost::any(*whereClause);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AdbTableSchema") != m.end() && !m["AdbTableSchema"].empty()) {
      if (typeid(map<string, boost::any>) == m["AdbTableSchema"].type()) {
        CreateProjectRequestTransferMappingDatabasesBlackSpecificTablesAdbTableSchema model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AdbTableSchema"]));
        adbTableSchema = make_shared<CreateProjectRequestTransferMappingDatabasesBlackSpecificTablesAdbTableSchema>(model1);
      }
    }
    if (m.find("FilterColumns") != m.end() && !m["FilterColumns"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["FilterColumns"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["FilterColumns"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      filterColumns = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("MappedName") != m.end() && !m["MappedName"].empty()) {
      mappedName = make_shared<string>(boost::any_cast<string>(m["MappedName"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ShardColumns") != m.end() && !m["ShardColumns"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ShardColumns"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ShardColumns"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      shardColumns = make_shared<vector<string>>(toVec1);
    }
    if (m.find("WhereClause") != m.end() && !m["WhereClause"].empty()) {
      whereClause = make_shared<string>(boost::any_cast<string>(m["WhereClause"]));
    }
  }


  virtual ~CreateProjectRequestTransferMappingDatabasesBlackSpecificTables() = default;
};
class CreateProjectRequestTransferMappingDatabasesBlackSpecificViewsAdbTableSchema : public Darabonba::Model {
public:
  shared_ptr<vector<string>> distributedKeys{};
  shared_ptr<string> partitionLifeCycle{};
  shared_ptr<string> partitionStatement{};
  shared_ptr<vector<string>> primaryKeys{};

  CreateProjectRequestTransferMappingDatabasesBlackSpecificViewsAdbTableSchema() {}

  explicit CreateProjectRequestTransferMappingDatabasesBlackSpecificViewsAdbTableSchema(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (distributedKeys) {
      res["DistributedKeys"] = boost::any(*distributedKeys);
    }
    if (partitionLifeCycle) {
      res["PartitionLifeCycle"] = boost::any(*partitionLifeCycle);
    }
    if (partitionStatement) {
      res["PartitionStatement"] = boost::any(*partitionStatement);
    }
    if (primaryKeys) {
      res["PrimaryKeys"] = boost::any(*primaryKeys);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DistributedKeys") != m.end() && !m["DistributedKeys"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DistributedKeys"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DistributedKeys"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      distributedKeys = make_shared<vector<string>>(toVec1);
    }
    if (m.find("PartitionLifeCycle") != m.end() && !m["PartitionLifeCycle"].empty()) {
      partitionLifeCycle = make_shared<string>(boost::any_cast<string>(m["PartitionLifeCycle"]));
    }
    if (m.find("PartitionStatement") != m.end() && !m["PartitionStatement"].empty()) {
      partitionStatement = make_shared<string>(boost::any_cast<string>(m["PartitionStatement"]));
    }
    if (m.find("PrimaryKeys") != m.end() && !m["PrimaryKeys"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["PrimaryKeys"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["PrimaryKeys"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      primaryKeys = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~CreateProjectRequestTransferMappingDatabasesBlackSpecificViewsAdbTableSchema() = default;
};
class CreateProjectRequestTransferMappingDatabasesBlackSpecificViews : public Darabonba::Model {
public:
  shared_ptr<CreateProjectRequestTransferMappingDatabasesBlackSpecificViewsAdbTableSchema> adbTableSchema{};
  shared_ptr<vector<string>> filterColumns{};
  shared_ptr<string> id{};
  shared_ptr<string> mappedName{};
  shared_ptr<string> name{};
  shared_ptr<vector<string>> shardColumns{};
  shared_ptr<string> whereClause{};

  CreateProjectRequestTransferMappingDatabasesBlackSpecificViews() {}

  explicit CreateProjectRequestTransferMappingDatabasesBlackSpecificViews(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (adbTableSchema) {
      res["AdbTableSchema"] = adbTableSchema ? boost::any(adbTableSchema->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (filterColumns) {
      res["FilterColumns"] = boost::any(*filterColumns);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (mappedName) {
      res["MappedName"] = boost::any(*mappedName);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (shardColumns) {
      res["ShardColumns"] = boost::any(*shardColumns);
    }
    if (whereClause) {
      res["WhereClause"] = boost::any(*whereClause);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AdbTableSchema") != m.end() && !m["AdbTableSchema"].empty()) {
      if (typeid(map<string, boost::any>) == m["AdbTableSchema"].type()) {
        CreateProjectRequestTransferMappingDatabasesBlackSpecificViewsAdbTableSchema model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AdbTableSchema"]));
        adbTableSchema = make_shared<CreateProjectRequestTransferMappingDatabasesBlackSpecificViewsAdbTableSchema>(model1);
      }
    }
    if (m.find("FilterColumns") != m.end() && !m["FilterColumns"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["FilterColumns"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["FilterColumns"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      filterColumns = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("MappedName") != m.end() && !m["MappedName"].empty()) {
      mappedName = make_shared<string>(boost::any_cast<string>(m["MappedName"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ShardColumns") != m.end() && !m["ShardColumns"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ShardColumns"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ShardColumns"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      shardColumns = make_shared<vector<string>>(toVec1);
    }
    if (m.find("WhereClause") != m.end() && !m["WhereClause"].empty()) {
      whereClause = make_shared<string>(boost::any_cast<string>(m["WhereClause"]));
    }
  }


  virtual ~CreateProjectRequestTransferMappingDatabasesBlackSpecificViews() = default;
};
class CreateProjectRequestTransferMappingDatabasesBlackTablesAdbTableSchema : public Darabonba::Model {
public:
  shared_ptr<vector<string>> distributedKeys{};
  shared_ptr<string> partitionLifeCycle{};
  shared_ptr<string> partitionStatement{};
  shared_ptr<vector<string>> primaryKeys{};

  CreateProjectRequestTransferMappingDatabasesBlackTablesAdbTableSchema() {}

  explicit CreateProjectRequestTransferMappingDatabasesBlackTablesAdbTableSchema(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (distributedKeys) {
      res["DistributedKeys"] = boost::any(*distributedKeys);
    }
    if (partitionLifeCycle) {
      res["PartitionLifeCycle"] = boost::any(*partitionLifeCycle);
    }
    if (partitionStatement) {
      res["PartitionStatement"] = boost::any(*partitionStatement);
    }
    if (primaryKeys) {
      res["PrimaryKeys"] = boost::any(*primaryKeys);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DistributedKeys") != m.end() && !m["DistributedKeys"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DistributedKeys"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DistributedKeys"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      distributedKeys = make_shared<vector<string>>(toVec1);
    }
    if (m.find("PartitionLifeCycle") != m.end() && !m["PartitionLifeCycle"].empty()) {
      partitionLifeCycle = make_shared<string>(boost::any_cast<string>(m["PartitionLifeCycle"]));
    }
    if (m.find("PartitionStatement") != m.end() && !m["PartitionStatement"].empty()) {
      partitionStatement = make_shared<string>(boost::any_cast<string>(m["PartitionStatement"]));
    }
    if (m.find("PrimaryKeys") != m.end() && !m["PrimaryKeys"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["PrimaryKeys"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["PrimaryKeys"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      primaryKeys = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~CreateProjectRequestTransferMappingDatabasesBlackTablesAdbTableSchema() = default;
};
class CreateProjectRequestTransferMappingDatabasesBlackTables : public Darabonba::Model {
public:
  shared_ptr<CreateProjectRequestTransferMappingDatabasesBlackTablesAdbTableSchema> adbTableSchema{};
  shared_ptr<vector<string>> filterColumns{};
  shared_ptr<string> id{};
  shared_ptr<string> mappedName{};
  shared_ptr<string> name{};
  shared_ptr<vector<string>> shardColumns{};
  shared_ptr<string> whereClause{};

  CreateProjectRequestTransferMappingDatabasesBlackTables() {}

  explicit CreateProjectRequestTransferMappingDatabasesBlackTables(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (adbTableSchema) {
      res["AdbTableSchema"] = adbTableSchema ? boost::any(adbTableSchema->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (filterColumns) {
      res["FilterColumns"] = boost::any(*filterColumns);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (mappedName) {
      res["MappedName"] = boost::any(*mappedName);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (shardColumns) {
      res["ShardColumns"] = boost::any(*shardColumns);
    }
    if (whereClause) {
      res["WhereClause"] = boost::any(*whereClause);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AdbTableSchema") != m.end() && !m["AdbTableSchema"].empty()) {
      if (typeid(map<string, boost::any>) == m["AdbTableSchema"].type()) {
        CreateProjectRequestTransferMappingDatabasesBlackTablesAdbTableSchema model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AdbTableSchema"]));
        adbTableSchema = make_shared<CreateProjectRequestTransferMappingDatabasesBlackTablesAdbTableSchema>(model1);
      }
    }
    if (m.find("FilterColumns") != m.end() && !m["FilterColumns"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["FilterColumns"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["FilterColumns"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      filterColumns = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("MappedName") != m.end() && !m["MappedName"].empty()) {
      mappedName = make_shared<string>(boost::any_cast<string>(m["MappedName"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ShardColumns") != m.end() && !m["ShardColumns"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ShardColumns"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ShardColumns"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      shardColumns = make_shared<vector<string>>(toVec1);
    }
    if (m.find("WhereClause") != m.end() && !m["WhereClause"].empty()) {
      whereClause = make_shared<string>(boost::any_cast<string>(m["WhereClause"]));
    }
  }


  virtual ~CreateProjectRequestTransferMappingDatabasesBlackTables() = default;
};
class CreateProjectRequestTransferMappingDatabasesBlackViewsAdbTableSchema : public Darabonba::Model {
public:
  shared_ptr<vector<string>> distributedKeys{};
  shared_ptr<string> partitionLifeCycle{};
  shared_ptr<string> partitionStatement{};
  shared_ptr<vector<string>> primaryKeys{};

  CreateProjectRequestTransferMappingDatabasesBlackViewsAdbTableSchema() {}

  explicit CreateProjectRequestTransferMappingDatabasesBlackViewsAdbTableSchema(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (distributedKeys) {
      res["DistributedKeys"] = boost::any(*distributedKeys);
    }
    if (partitionLifeCycle) {
      res["PartitionLifeCycle"] = boost::any(*partitionLifeCycle);
    }
    if (partitionStatement) {
      res["PartitionStatement"] = boost::any(*partitionStatement);
    }
    if (primaryKeys) {
      res["PrimaryKeys"] = boost::any(*primaryKeys);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DistributedKeys") != m.end() && !m["DistributedKeys"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DistributedKeys"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DistributedKeys"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      distributedKeys = make_shared<vector<string>>(toVec1);
    }
    if (m.find("PartitionLifeCycle") != m.end() && !m["PartitionLifeCycle"].empty()) {
      partitionLifeCycle = make_shared<string>(boost::any_cast<string>(m["PartitionLifeCycle"]));
    }
    if (m.find("PartitionStatement") != m.end() && !m["PartitionStatement"].empty()) {
      partitionStatement = make_shared<string>(boost::any_cast<string>(m["PartitionStatement"]));
    }
    if (m.find("PrimaryKeys") != m.end() && !m["PrimaryKeys"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["PrimaryKeys"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["PrimaryKeys"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      primaryKeys = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~CreateProjectRequestTransferMappingDatabasesBlackViewsAdbTableSchema() = default;
};
class CreateProjectRequestTransferMappingDatabasesBlackViews : public Darabonba::Model {
public:
  shared_ptr<CreateProjectRequestTransferMappingDatabasesBlackViewsAdbTableSchema> adbTableSchema{};
  shared_ptr<vector<string>> filterColumns{};
  shared_ptr<string> id{};
  shared_ptr<string> mappedName{};
  shared_ptr<string> name{};
  shared_ptr<vector<string>> shardColumns{};
  shared_ptr<string> whereClause{};

  CreateProjectRequestTransferMappingDatabasesBlackViews() {}

  explicit CreateProjectRequestTransferMappingDatabasesBlackViews(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (adbTableSchema) {
      res["AdbTableSchema"] = adbTableSchema ? boost::any(adbTableSchema->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (filterColumns) {
      res["FilterColumns"] = boost::any(*filterColumns);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (mappedName) {
      res["MappedName"] = boost::any(*mappedName);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (shardColumns) {
      res["ShardColumns"] = boost::any(*shardColumns);
    }
    if (whereClause) {
      res["WhereClause"] = boost::any(*whereClause);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AdbTableSchema") != m.end() && !m["AdbTableSchema"].empty()) {
      if (typeid(map<string, boost::any>) == m["AdbTableSchema"].type()) {
        CreateProjectRequestTransferMappingDatabasesBlackViewsAdbTableSchema model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AdbTableSchema"]));
        adbTableSchema = make_shared<CreateProjectRequestTransferMappingDatabasesBlackViewsAdbTableSchema>(model1);
      }
    }
    if (m.find("FilterColumns") != m.end() && !m["FilterColumns"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["FilterColumns"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["FilterColumns"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      filterColumns = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("MappedName") != m.end() && !m["MappedName"].empty()) {
      mappedName = make_shared<string>(boost::any_cast<string>(m["MappedName"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ShardColumns") != m.end() && !m["ShardColumns"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ShardColumns"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ShardColumns"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      shardColumns = make_shared<vector<string>>(toVec1);
    }
    if (m.find("WhereClause") != m.end() && !m["WhereClause"].empty()) {
      whereClause = make_shared<string>(boost::any_cast<string>(m["WhereClause"]));
    }
  }


  virtual ~CreateProjectRequestTransferMappingDatabasesBlackViews() = default;
};
class CreateProjectRequestTransferMappingDatabasesBlack : public Darabonba::Model {
public:
  shared_ptr<string> clusterName{};
  shared_ptr<string> id{};
  shared_ptr<string> mappedName{};
  shared_ptr<string> name{};
  shared_ptr<vector<CreateProjectRequestTransferMappingDatabasesBlackSpecificTables>> specificTables{};
  shared_ptr<vector<CreateProjectRequestTransferMappingDatabasesBlackSpecificViews>> specificViews{};
  shared_ptr<vector<CreateProjectRequestTransferMappingDatabasesBlackTables>> tables{};
  shared_ptr<string> tenantName{};
  shared_ptr<vector<CreateProjectRequestTransferMappingDatabasesBlackViews>> views{};

  CreateProjectRequestTransferMappingDatabasesBlack() {}

  explicit CreateProjectRequestTransferMappingDatabasesBlack(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterName) {
      res["ClusterName"] = boost::any(*clusterName);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (mappedName) {
      res["MappedName"] = boost::any(*mappedName);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (specificTables) {
      vector<boost::any> temp1;
      for(auto item1:*specificTables){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SpecificTables"] = boost::any(temp1);
    }
    if (specificViews) {
      vector<boost::any> temp1;
      for(auto item1:*specificViews){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SpecificViews"] = boost::any(temp1);
    }
    if (tables) {
      vector<boost::any> temp1;
      for(auto item1:*tables){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tables"] = boost::any(temp1);
    }
    if (tenantName) {
      res["TenantName"] = boost::any(*tenantName);
    }
    if (views) {
      vector<boost::any> temp1;
      for(auto item1:*views){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Views"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterName") != m.end() && !m["ClusterName"].empty()) {
      clusterName = make_shared<string>(boost::any_cast<string>(m["ClusterName"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("MappedName") != m.end() && !m["MappedName"].empty()) {
      mappedName = make_shared<string>(boost::any_cast<string>(m["MappedName"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("SpecificTables") != m.end() && !m["SpecificTables"].empty()) {
      if (typeid(vector<boost::any>) == m["SpecificTables"].type()) {
        vector<CreateProjectRequestTransferMappingDatabasesBlackSpecificTables> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SpecificTables"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateProjectRequestTransferMappingDatabasesBlackSpecificTables model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        specificTables = make_shared<vector<CreateProjectRequestTransferMappingDatabasesBlackSpecificTables>>(expect1);
      }
    }
    if (m.find("SpecificViews") != m.end() && !m["SpecificViews"].empty()) {
      if (typeid(vector<boost::any>) == m["SpecificViews"].type()) {
        vector<CreateProjectRequestTransferMappingDatabasesBlackSpecificViews> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SpecificViews"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateProjectRequestTransferMappingDatabasesBlackSpecificViews model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        specificViews = make_shared<vector<CreateProjectRequestTransferMappingDatabasesBlackSpecificViews>>(expect1);
      }
    }
    if (m.find("Tables") != m.end() && !m["Tables"].empty()) {
      if (typeid(vector<boost::any>) == m["Tables"].type()) {
        vector<CreateProjectRequestTransferMappingDatabasesBlackTables> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tables"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateProjectRequestTransferMappingDatabasesBlackTables model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tables = make_shared<vector<CreateProjectRequestTransferMappingDatabasesBlackTables>>(expect1);
      }
    }
    if (m.find("TenantName") != m.end() && !m["TenantName"].empty()) {
      tenantName = make_shared<string>(boost::any_cast<string>(m["TenantName"]));
    }
    if (m.find("Views") != m.end() && !m["Views"].empty()) {
      if (typeid(vector<boost::any>) == m["Views"].type()) {
        vector<CreateProjectRequestTransferMappingDatabasesBlackViews> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Views"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateProjectRequestTransferMappingDatabasesBlackViews model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        views = make_shared<vector<CreateProjectRequestTransferMappingDatabasesBlackViews>>(expect1);
      }
    }
  }


  virtual ~CreateProjectRequestTransferMappingDatabasesBlack() = default;
};
class CreateProjectRequestTransferMapping : public Darabonba::Model {
public:
  shared_ptr<vector<CreateProjectRequestTransferMappingDatabases>> databases{};
  shared_ptr<vector<CreateProjectRequestTransferMappingDatabasesBlack>> databasesBlack{};
  shared_ptr<string> mode{};
  shared_ptr<vector<string>> tableAndViewBlackList{};
  shared_ptr<vector<string>> tableAndViewWhiteList{};

  CreateProjectRequestTransferMapping() {}

  explicit CreateProjectRequestTransferMapping(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (databases) {
      vector<boost::any> temp1;
      for(auto item1:*databases){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Databases"] = boost::any(temp1);
    }
    if (databasesBlack) {
      vector<boost::any> temp1;
      for(auto item1:*databasesBlack){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DatabasesBlack"] = boost::any(temp1);
    }
    if (mode) {
      res["Mode"] = boost::any(*mode);
    }
    if (tableAndViewBlackList) {
      res["TableAndViewBlackList"] = boost::any(*tableAndViewBlackList);
    }
    if (tableAndViewWhiteList) {
      res["TableAndViewWhiteList"] = boost::any(*tableAndViewWhiteList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Databases") != m.end() && !m["Databases"].empty()) {
      if (typeid(vector<boost::any>) == m["Databases"].type()) {
        vector<CreateProjectRequestTransferMappingDatabases> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Databases"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateProjectRequestTransferMappingDatabases model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        databases = make_shared<vector<CreateProjectRequestTransferMappingDatabases>>(expect1);
      }
    }
    if (m.find("DatabasesBlack") != m.end() && !m["DatabasesBlack"].empty()) {
      if (typeid(vector<boost::any>) == m["DatabasesBlack"].type()) {
        vector<CreateProjectRequestTransferMappingDatabasesBlack> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DatabasesBlack"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateProjectRequestTransferMappingDatabasesBlack model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        databasesBlack = make_shared<vector<CreateProjectRequestTransferMappingDatabasesBlack>>(expect1);
      }
    }
    if (m.find("Mode") != m.end() && !m["Mode"].empty()) {
      mode = make_shared<string>(boost::any_cast<string>(m["Mode"]));
    }
    if (m.find("TableAndViewBlackList") != m.end() && !m["TableAndViewBlackList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["TableAndViewBlackList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["TableAndViewBlackList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      tableAndViewBlackList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("TableAndViewWhiteList") != m.end() && !m["TableAndViewWhiteList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["TableAndViewWhiteList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["TableAndViewWhiteList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      tableAndViewWhiteList = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~CreateProjectRequestTransferMapping() = default;
};
class CreateProjectRequest : public Darabonba::Model {
public:
  shared_ptr<CreateProjectRequestCommonTransferConfig> commonTransferConfig{};
  shared_ptr<bool> enableFullTransfer{};
  shared_ptr<bool> enableFullVerify{};
  shared_ptr<bool> enableIncrTransfer{};
  shared_ptr<bool> enableReverseIncrTransfer{};
  shared_ptr<bool> enableStructTransfer{};
  shared_ptr<CreateProjectRequestFullTransferConfig> fullTransferConfig{};
  shared_ptr<string> id{};
  shared_ptr<CreateProjectRequestIncrTransferConfig> incrTransferConfig{};
  shared_ptr<vector<string>> labelIds{};
  shared_ptr<string> name{};
  shared_ptr<string> ossKey{};
  shared_ptr<CreateProjectRequestReverseIncrTransferConfig> reverseIncrTransferConfig{};
  shared_ptr<string> sinkEndpointId{};
  shared_ptr<string> sourceEndpointId{};
  shared_ptr<CreateProjectRequestStructTransferConfig> structTransferConfig{};
  shared_ptr<CreateProjectRequestTransferMapping> transferMapping{};
  shared_ptr<string> type{};
  shared_ptr<bool> useOss{};
  shared_ptr<string> workerGradeId{};

  CreateProjectRequest() {}

  explicit CreateProjectRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonTransferConfig) {
      res["CommonTransferConfig"] = commonTransferConfig ? boost::any(commonTransferConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (enableFullTransfer) {
      res["EnableFullTransfer"] = boost::any(*enableFullTransfer);
    }
    if (enableFullVerify) {
      res["EnableFullVerify"] = boost::any(*enableFullVerify);
    }
    if (enableIncrTransfer) {
      res["EnableIncrTransfer"] = boost::any(*enableIncrTransfer);
    }
    if (enableReverseIncrTransfer) {
      res["EnableReverseIncrTransfer"] = boost::any(*enableReverseIncrTransfer);
    }
    if (enableStructTransfer) {
      res["EnableStructTransfer"] = boost::any(*enableStructTransfer);
    }
    if (fullTransferConfig) {
      res["FullTransferConfig"] = fullTransferConfig ? boost::any(fullTransferConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (incrTransferConfig) {
      res["IncrTransferConfig"] = incrTransferConfig ? boost::any(incrTransferConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (labelIds) {
      res["LabelIds"] = boost::any(*labelIds);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (ossKey) {
      res["OssKey"] = boost::any(*ossKey);
    }
    if (reverseIncrTransferConfig) {
      res["ReverseIncrTransferConfig"] = reverseIncrTransferConfig ? boost::any(reverseIncrTransferConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (sinkEndpointId) {
      res["SinkEndpointId"] = boost::any(*sinkEndpointId);
    }
    if (sourceEndpointId) {
      res["SourceEndpointId"] = boost::any(*sourceEndpointId);
    }
    if (structTransferConfig) {
      res["StructTransferConfig"] = structTransferConfig ? boost::any(structTransferConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (transferMapping) {
      res["TransferMapping"] = transferMapping ? boost::any(transferMapping->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (useOss) {
      res["UseOss"] = boost::any(*useOss);
    }
    if (workerGradeId) {
      res["WorkerGradeId"] = boost::any(*workerGradeId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CommonTransferConfig") != m.end() && !m["CommonTransferConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["CommonTransferConfig"].type()) {
        CreateProjectRequestCommonTransferConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CommonTransferConfig"]));
        commonTransferConfig = make_shared<CreateProjectRequestCommonTransferConfig>(model1);
      }
    }
    if (m.find("EnableFullTransfer") != m.end() && !m["EnableFullTransfer"].empty()) {
      enableFullTransfer = make_shared<bool>(boost::any_cast<bool>(m["EnableFullTransfer"]));
    }
    if (m.find("EnableFullVerify") != m.end() && !m["EnableFullVerify"].empty()) {
      enableFullVerify = make_shared<bool>(boost::any_cast<bool>(m["EnableFullVerify"]));
    }
    if (m.find("EnableIncrTransfer") != m.end() && !m["EnableIncrTransfer"].empty()) {
      enableIncrTransfer = make_shared<bool>(boost::any_cast<bool>(m["EnableIncrTransfer"]));
    }
    if (m.find("EnableReverseIncrTransfer") != m.end() && !m["EnableReverseIncrTransfer"].empty()) {
      enableReverseIncrTransfer = make_shared<bool>(boost::any_cast<bool>(m["EnableReverseIncrTransfer"]));
    }
    if (m.find("EnableStructTransfer") != m.end() && !m["EnableStructTransfer"].empty()) {
      enableStructTransfer = make_shared<bool>(boost::any_cast<bool>(m["EnableStructTransfer"]));
    }
    if (m.find("FullTransferConfig") != m.end() && !m["FullTransferConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["FullTransferConfig"].type()) {
        CreateProjectRequestFullTransferConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FullTransferConfig"]));
        fullTransferConfig = make_shared<CreateProjectRequestFullTransferConfig>(model1);
      }
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("IncrTransferConfig") != m.end() && !m["IncrTransferConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["IncrTransferConfig"].type()) {
        CreateProjectRequestIncrTransferConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["IncrTransferConfig"]));
        incrTransferConfig = make_shared<CreateProjectRequestIncrTransferConfig>(model1);
      }
    }
    if (m.find("LabelIds") != m.end() && !m["LabelIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["LabelIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["LabelIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      labelIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("OssKey") != m.end() && !m["OssKey"].empty()) {
      ossKey = make_shared<string>(boost::any_cast<string>(m["OssKey"]));
    }
    if (m.find("ReverseIncrTransferConfig") != m.end() && !m["ReverseIncrTransferConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["ReverseIncrTransferConfig"].type()) {
        CreateProjectRequestReverseIncrTransferConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ReverseIncrTransferConfig"]));
        reverseIncrTransferConfig = make_shared<CreateProjectRequestReverseIncrTransferConfig>(model1);
      }
    }
    if (m.find("SinkEndpointId") != m.end() && !m["SinkEndpointId"].empty()) {
      sinkEndpointId = make_shared<string>(boost::any_cast<string>(m["SinkEndpointId"]));
    }
    if (m.find("SourceEndpointId") != m.end() && !m["SourceEndpointId"].empty()) {
      sourceEndpointId = make_shared<string>(boost::any_cast<string>(m["SourceEndpointId"]));
    }
    if (m.find("StructTransferConfig") != m.end() && !m["StructTransferConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["StructTransferConfig"].type()) {
        CreateProjectRequestStructTransferConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["StructTransferConfig"]));
        structTransferConfig = make_shared<CreateProjectRequestStructTransferConfig>(model1);
      }
    }
    if (m.find("TransferMapping") != m.end() && !m["TransferMapping"].empty()) {
      if (typeid(map<string, boost::any>) == m["TransferMapping"].type()) {
        CreateProjectRequestTransferMapping model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TransferMapping"]));
        transferMapping = make_shared<CreateProjectRequestTransferMapping>(model1);
      }
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("UseOss") != m.end() && !m["UseOss"].empty()) {
      useOss = make_shared<bool>(boost::any_cast<bool>(m["UseOss"]));
    }
    if (m.find("WorkerGradeId") != m.end() && !m["WorkerGradeId"].empty()) {
      workerGradeId = make_shared<string>(boost::any_cast<string>(m["WorkerGradeId"]));
    }
  }


  virtual ~CreateProjectRequest() = default;
};
class CreateProjectShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> commonTransferConfigShrink{};
  shared_ptr<bool> enableFullTransfer{};
  shared_ptr<bool> enableFullVerify{};
  shared_ptr<bool> enableIncrTransfer{};
  shared_ptr<bool> enableReverseIncrTransfer{};
  shared_ptr<bool> enableStructTransfer{};
  shared_ptr<string> fullTransferConfigShrink{};
  shared_ptr<string> id{};
  shared_ptr<string> incrTransferConfigShrink{};
  shared_ptr<string> labelIdsShrink{};
  shared_ptr<string> name{};
  shared_ptr<string> ossKey{};
  shared_ptr<string> reverseIncrTransferConfigShrink{};
  shared_ptr<string> sinkEndpointId{};
  shared_ptr<string> sourceEndpointId{};
  shared_ptr<string> structTransferConfigShrink{};
  shared_ptr<string> transferMappingShrink{};
  shared_ptr<string> type{};
  shared_ptr<bool> useOss{};
  shared_ptr<string> workerGradeId{};

  CreateProjectShrinkRequest() {}

  explicit CreateProjectShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commonTransferConfigShrink) {
      res["CommonTransferConfig"] = boost::any(*commonTransferConfigShrink);
    }
    if (enableFullTransfer) {
      res["EnableFullTransfer"] = boost::any(*enableFullTransfer);
    }
    if (enableFullVerify) {
      res["EnableFullVerify"] = boost::any(*enableFullVerify);
    }
    if (enableIncrTransfer) {
      res["EnableIncrTransfer"] = boost::any(*enableIncrTransfer);
    }
    if (enableReverseIncrTransfer) {
      res["EnableReverseIncrTransfer"] = boost::any(*enableReverseIncrTransfer);
    }
    if (enableStructTransfer) {
      res["EnableStructTransfer"] = boost::any(*enableStructTransfer);
    }
    if (fullTransferConfigShrink) {
      res["FullTransferConfig"] = boost::any(*fullTransferConfigShrink);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (incrTransferConfigShrink) {
      res["IncrTransferConfig"] = boost::any(*incrTransferConfigShrink);
    }
    if (labelIdsShrink) {
      res["LabelIds"] = boost::any(*labelIdsShrink);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (ossKey) {
      res["OssKey"] = boost::any(*ossKey);
    }
    if (reverseIncrTransferConfigShrink) {
      res["ReverseIncrTransferConfig"] = boost::any(*reverseIncrTransferConfigShrink);
    }
    if (sinkEndpointId) {
      res["SinkEndpointId"] = boost::any(*sinkEndpointId);
    }
    if (sourceEndpointId) {
      res["SourceEndpointId"] = boost::any(*sourceEndpointId);
    }
    if (structTransferConfigShrink) {
      res["StructTransferConfig"] = boost::any(*structTransferConfigShrink);
    }
    if (transferMappingShrink) {
      res["TransferMapping"] = boost::any(*transferMappingShrink);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (useOss) {
      res["UseOss"] = boost::any(*useOss);
    }
    if (workerGradeId) {
      res["WorkerGradeId"] = boost::any(*workerGradeId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CommonTransferConfig") != m.end() && !m["CommonTransferConfig"].empty()) {
      commonTransferConfigShrink = make_shared<string>(boost::any_cast<string>(m["CommonTransferConfig"]));
    }
    if (m.find("EnableFullTransfer") != m.end() && !m["EnableFullTransfer"].empty()) {
      enableFullTransfer = make_shared<bool>(boost::any_cast<bool>(m["EnableFullTransfer"]));
    }
    if (m.find("EnableFullVerify") != m.end() && !m["EnableFullVerify"].empty()) {
      enableFullVerify = make_shared<bool>(boost::any_cast<bool>(m["EnableFullVerify"]));
    }
    if (m.find("EnableIncrTransfer") != m.end() && !m["EnableIncrTransfer"].empty()) {
      enableIncrTransfer = make_shared<bool>(boost::any_cast<bool>(m["EnableIncrTransfer"]));
    }
    if (m.find("EnableReverseIncrTransfer") != m.end() && !m["EnableReverseIncrTransfer"].empty()) {
      enableReverseIncrTransfer = make_shared<bool>(boost::any_cast<bool>(m["EnableReverseIncrTransfer"]));
    }
    if (m.find("EnableStructTransfer") != m.end() && !m["EnableStructTransfer"].empty()) {
      enableStructTransfer = make_shared<bool>(boost::any_cast<bool>(m["EnableStructTransfer"]));
    }
    if (m.find("FullTransferConfig") != m.end() && !m["FullTransferConfig"].empty()) {
      fullTransferConfigShrink = make_shared<string>(boost::any_cast<string>(m["FullTransferConfig"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("IncrTransferConfig") != m.end() && !m["IncrTransferConfig"].empty()) {
      incrTransferConfigShrink = make_shared<string>(boost::any_cast<string>(m["IncrTransferConfig"]));
    }
    if (m.find("LabelIds") != m.end() && !m["LabelIds"].empty()) {
      labelIdsShrink = make_shared<string>(boost::any_cast<string>(m["LabelIds"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("OssKey") != m.end() && !m["OssKey"].empty()) {
      ossKey = make_shared<string>(boost::any_cast<string>(m["OssKey"]));
    }
    if (m.find("ReverseIncrTransferConfig") != m.end() && !m["ReverseIncrTransferConfig"].empty()) {
      reverseIncrTransferConfigShrink = make_shared<string>(boost::any_cast<string>(m["ReverseIncrTransferConfig"]));
    }
    if (m.find("SinkEndpointId") != m.end() && !m["SinkEndpointId"].empty()) {
      sinkEndpointId = make_shared<string>(boost::any_cast<string>(m["SinkEndpointId"]));
    }
    if (m.find("SourceEndpointId") != m.end() && !m["SourceEndpointId"].empty()) {
      sourceEndpointId = make_shared<string>(boost::any_cast<string>(m["SourceEndpointId"]));
    }
    if (m.find("StructTransferConfig") != m.end() && !m["StructTransferConfig"].empty()) {
      structTransferConfigShrink = make_shared<string>(boost::any_cast<string>(m["StructTransferConfig"]));
    }
    if (m.find("TransferMapping") != m.end() && !m["TransferMapping"].empty()) {
      transferMappingShrink = make_shared<string>(boost::any_cast<string>(m["TransferMapping"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("UseOss") != m.end() && !m["UseOss"].empty()) {
      useOss = make_shared<bool>(boost::any_cast<bool>(m["UseOss"]));
    }
    if (m.find("WorkerGradeId") != m.end() && !m["WorkerGradeId"].empty()) {
      workerGradeId = make_shared<string>(boost::any_cast<string>(m["WorkerGradeId"]));
    }
  }


  virtual ~CreateProjectShrinkRequest() = default;
};
class CreateProjectResponseBodyErrorDetail : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<map<string, boost::any>> extraContext{};
  shared_ptr<string> level{};
  shared_ptr<string> message{};
  shared_ptr<map<string, string>> messageMcmsContext{};
  shared_ptr<string> messageMcmsKey{};
  shared_ptr<string> proposal{};
  shared_ptr<map<string, string>> proposalMcmsContext{};
  shared_ptr<string> proposalMcmsKey{};
  shared_ptr<string> reason{};
  shared_ptr<map<string, string>> reasonMcmsContext{};
  shared_ptr<string> reasonMcmsKey{};
  shared_ptr<boost::any> upstreamErrorDetail{};

  CreateProjectResponseBodyErrorDetail() {}

  explicit CreateProjectResponseBodyErrorDetail(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (extraContext) {
      res["ExtraContext"] = boost::any(*extraContext);
    }
    if (level) {
      res["Level"] = boost::any(*level);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (messageMcmsContext) {
      res["MessageMcmsContext"] = boost::any(*messageMcmsContext);
    }
    if (messageMcmsKey) {
      res["MessageMcmsKey"] = boost::any(*messageMcmsKey);
    }
    if (proposal) {
      res["Proposal"] = boost::any(*proposal);
    }
    if (proposalMcmsContext) {
      res["ProposalMcmsContext"] = boost::any(*proposalMcmsContext);
    }
    if (proposalMcmsKey) {
      res["ProposalMcmsKey"] = boost::any(*proposalMcmsKey);
    }
    if (reason) {
      res["Reason"] = boost::any(*reason);
    }
    if (reasonMcmsContext) {
      res["ReasonMcmsContext"] = boost::any(*reasonMcmsContext);
    }
    if (reasonMcmsKey) {
      res["ReasonMcmsKey"] = boost::any(*reasonMcmsKey);
    }
    if (upstreamErrorDetail) {
      res["UpstreamErrorDetail"] = boost::any(*upstreamErrorDetail);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ExtraContext") != m.end() && !m["ExtraContext"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["ExtraContext"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      extraContext = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<string>(boost::any_cast<string>(m["Level"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("MessageMcmsContext") != m.end() && !m["MessageMcmsContext"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["MessageMcmsContext"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      messageMcmsContext = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("MessageMcmsKey") != m.end() && !m["MessageMcmsKey"].empty()) {
      messageMcmsKey = make_shared<string>(boost::any_cast<string>(m["MessageMcmsKey"]));
    }
    if (m.find("Proposal") != m.end() && !m["Proposal"].empty()) {
      proposal = make_shared<string>(boost::any_cast<string>(m["Proposal"]));
    }
    if (m.find("ProposalMcmsContext") != m.end() && !m["ProposalMcmsContext"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["ProposalMcmsContext"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      proposalMcmsContext = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("ProposalMcmsKey") != m.end() && !m["ProposalMcmsKey"].empty()) {
      proposalMcmsKey = make_shared<string>(boost::any_cast<string>(m["ProposalMcmsKey"]));
    }
    if (m.find("Reason") != m.end() && !m["Reason"].empty()) {
      reason = make_shared<string>(boost::any_cast<string>(m["Reason"]));
    }
    if (m.find("ReasonMcmsContext") != m.end() && !m["ReasonMcmsContext"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["ReasonMcmsContext"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      reasonMcmsContext = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("ReasonMcmsKey") != m.end() && !m["ReasonMcmsKey"].empty()) {
      reasonMcmsKey = make_shared<string>(boost::any_cast<string>(m["ReasonMcmsKey"]));
    }
    if (m.find("UpstreamErrorDetail") != m.end() && !m["UpstreamErrorDetail"].empty()) {
      upstreamErrorDetail = make_shared<boost::any>(boost::any_cast<boost::any>(m["UpstreamErrorDetail"]));
    }
  }


  virtual ~CreateProjectResponseBodyErrorDetail() = default;
};
class CreateProjectResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> advice{};
  shared_ptr<string> code{};
  shared_ptr<string> cost{};
  shared_ptr<string> data{};
  shared_ptr<CreateProjectResponseBodyErrorDetail> errorDetail{};
  shared_ptr<string> message{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<long> totalCount{};

  CreateProjectResponseBody() {}

  explicit CreateProjectResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (advice) {
      res["Advice"] = boost::any(*advice);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (cost) {
      res["Cost"] = boost::any(*cost);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (errorDetail) {
      res["ErrorDetail"] = errorDetail ? boost::any(errorDetail->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Advice") != m.end() && !m["Advice"].empty()) {
      advice = make_shared<string>(boost::any_cast<string>(m["Advice"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Cost") != m.end() && !m["Cost"].empty()) {
      cost = make_shared<string>(boost::any_cast<string>(m["Cost"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("ErrorDetail") != m.end() && !m["ErrorDetail"].empty()) {
      if (typeid(map<string, boost::any>) == m["ErrorDetail"].type()) {
        CreateProjectResponseBodyErrorDetail model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ErrorDetail"]));
        errorDetail = make_shared<CreateProjectResponseBodyErrorDetail>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~CreateProjectResponseBody() = default;
};
class CreateProjectResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateProjectResponseBody> body{};

  CreateProjectResponse() {}

  explicit CreateProjectResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateProjectResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateProjectResponseBody>(model1);
      }
    }
  }


  virtual ~CreateProjectResponse() = default;
};
class CreateProjectModifyRecordsRequestDatabasesSpecificTablesAdbTableSchema : public Darabonba::Model {
public:
  shared_ptr<vector<string>> distributedKeys{};
  shared_ptr<string> partitionLifeCycle{};
  shared_ptr<string> partitionStatement{};
  shared_ptr<vector<string>> primaryKeys{};

  CreateProjectModifyRecordsRequestDatabasesSpecificTablesAdbTableSchema() {}

  explicit CreateProjectModifyRecordsRequestDatabasesSpecificTablesAdbTableSchema(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (distributedKeys) {
      res["DistributedKeys"] = boost::any(*distributedKeys);
    }
    if (partitionLifeCycle) {
      res["PartitionLifeCycle"] = boost::any(*partitionLifeCycle);
    }
    if (partitionStatement) {
      res["PartitionStatement"] = boost::any(*partitionStatement);
    }
    if (primaryKeys) {
      res["PrimaryKeys"] = boost::any(*primaryKeys);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DistributedKeys") != m.end() && !m["DistributedKeys"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DistributedKeys"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DistributedKeys"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      distributedKeys = make_shared<vector<string>>(toVec1);
    }
    if (m.find("PartitionLifeCycle") != m.end() && !m["PartitionLifeCycle"].empty()) {
      partitionLifeCycle = make_shared<string>(boost::any_cast<string>(m["PartitionLifeCycle"]));
    }
    if (m.find("PartitionStatement") != m.end() && !m["PartitionStatement"].empty()) {
      partitionStatement = make_shared<string>(boost::any_cast<string>(m["PartitionStatement"]));
    }
    if (m.find("PrimaryKeys") != m.end() && !m["PrimaryKeys"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["PrimaryKeys"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["PrimaryKeys"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      primaryKeys = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~CreateProjectModifyRecordsRequestDatabasesSpecificTablesAdbTableSchema() = default;
};
class CreateProjectModifyRecordsRequestDatabasesSpecificTables : public Darabonba::Model {
public:
  shared_ptr<CreateProjectModifyRecordsRequestDatabasesSpecificTablesAdbTableSchema> adbTableSchema{};
  shared_ptr<vector<string>> filterColumns{};
  shared_ptr<string> id{};
  shared_ptr<string> mappedName{};
  shared_ptr<string> name{};
  shared_ptr<vector<string>> shardColumns{};
  shared_ptr<string> whereClause{};

  CreateProjectModifyRecordsRequestDatabasesSpecificTables() {}

  explicit CreateProjectModifyRecordsRequestDatabasesSpecificTables(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (adbTableSchema) {
      res["AdbTableSchema"] = adbTableSchema ? boost::any(adbTableSchema->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (filterColumns) {
      res["FilterColumns"] = boost::any(*filterColumns);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (mappedName) {
      res["MappedName"] = boost::any(*mappedName);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (shardColumns) {
      res["ShardColumns"] = boost::any(*shardColumns);
    }
    if (whereClause) {
      res["WhereClause"] = boost::any(*whereClause);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AdbTableSchema") != m.end() && !m["AdbTableSchema"].empty()) {
      if (typeid(map<string, boost::any>) == m["AdbTableSchema"].type()) {
        CreateProjectModifyRecordsRequestDatabasesSpecificTablesAdbTableSchema model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AdbTableSchema"]));
        adbTableSchema = make_shared<CreateProjectModifyRecordsRequestDatabasesSpecificTablesAdbTableSchema>(model1);
      }
    }
    if (m.find("FilterColumns") != m.end() && !m["FilterColumns"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["FilterColumns"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["FilterColumns"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      filterColumns = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("MappedName") != m.end() && !m["MappedName"].empty()) {
      mappedName = make_shared<string>(boost::any_cast<string>(m["MappedName"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ShardColumns") != m.end() && !m["ShardColumns"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ShardColumns"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ShardColumns"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      shardColumns = make_shared<vector<string>>(toVec1);
    }
    if (m.find("WhereClause") != m.end() && !m["WhereClause"].empty()) {
      whereClause = make_shared<string>(boost::any_cast<string>(m["WhereClause"]));
    }
  }


  virtual ~CreateProjectModifyRecordsRequestDatabasesSpecificTables() = default;
};
class CreateProjectModifyRecordsRequestDatabasesSpecificViewsAdbTableSchema : public Darabonba::Model {
public:
  shared_ptr<vector<string>> distributedKeys{};
  shared_ptr<string> partitionLifeCycle{};
  shared_ptr<string> partitionStatement{};
  shared_ptr<vector<string>> primaryKeys{};

  CreateProjectModifyRecordsRequestDatabasesSpecificViewsAdbTableSchema() {}

  explicit CreateProjectModifyRecordsRequestDatabasesSpecificViewsAdbTableSchema(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (distributedKeys) {
      res["DistributedKeys"] = boost::any(*distributedKeys);
    }
    if (partitionLifeCycle) {
      res["PartitionLifeCycle"] = boost::any(*partitionLifeCycle);
    }
    if (partitionStatement) {
      res["PartitionStatement"] = boost::any(*partitionStatement);
    }
    if (primaryKeys) {
      res["PrimaryKeys"] = boost::any(*primaryKeys);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DistributedKeys") != m.end() && !m["DistributedKeys"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DistributedKeys"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DistributedKeys"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      distributedKeys = make_shared<vector<string>>(toVec1);
    }
    if (m.find("PartitionLifeCycle") != m.end() && !m["PartitionLifeCycle"].empty()) {
      partitionLifeCycle = make_shared<string>(boost::any_cast<string>(m["PartitionLifeCycle"]));
    }
    if (m.find("PartitionStatement") != m.end() && !m["PartitionStatement"].empty()) {
      partitionStatement = make_shared<string>(boost::any_cast<string>(m["PartitionStatement"]));
    }
    if (m.find("PrimaryKeys") != m.end() && !m["PrimaryKeys"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["PrimaryKeys"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["PrimaryKeys"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      primaryKeys = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~CreateProjectModifyRecordsRequestDatabasesSpecificViewsAdbTableSchema() = default;
};
class CreateProjectModifyRecordsRequestDatabasesSpecificViews : public Darabonba::Model {
public:
  shared_ptr<CreateProjectModifyRecordsRequestDatabasesSpecificViewsAdbTableSchema> adbTableSchema{};
  shared_ptr<vector<string>> filterColumns{};
  shared_ptr<string> id{};
  shared_ptr<string> mappedName{};
  shared_ptr<string> name{};
  shared_ptr<vector<string>> shardColumns{};
  shared_ptr<string> whereClause{};

  CreateProjectModifyRecordsRequestDatabasesSpecificViews() {}

  explicit CreateProjectModifyRecordsRequestDatabasesSpecificViews(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (adbTableSchema) {
      res["AdbTableSchema"] = adbTableSchema ? boost::any(adbTableSchema->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (filterColumns) {
      res["FilterColumns"] = boost::any(*filterColumns);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (mappedName) {
      res["MappedName"] = boost::any(*mappedName);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (shardColumns) {
      res["ShardColumns"] = boost::any(*shardColumns);
    }
    if (whereClause) {
      res["WhereClause"] = boost::any(*whereClause);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AdbTableSchema") != m.end() && !m["AdbTableSchema"].empty()) {
      if (typeid(map<string, boost::any>) == m["AdbTableSchema"].type()) {
        CreateProjectModifyRecordsRequestDatabasesSpecificViewsAdbTableSchema model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AdbTableSchema"]));
        adbTableSchema = make_shared<CreateProjectModifyRecordsRequestDatabasesSpecificViewsAdbTableSchema>(model1);
      }
    }
    if (m.find("FilterColumns") != m.end() && !m["FilterColumns"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["FilterColumns"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["FilterColumns"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      filterColumns = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("MappedName") != m.end() && !m["MappedName"].empty()) {
      mappedName = make_shared<string>(boost::any_cast<string>(m["MappedName"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ShardColumns") != m.end() && !m["ShardColumns"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ShardColumns"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ShardColumns"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      shardColumns = make_shared<vector<string>>(toVec1);
    }
    if (m.find("WhereClause") != m.end() && !m["WhereClause"].empty()) {
      whereClause = make_shared<string>(boost::any_cast<string>(m["WhereClause"]));
    }
  }


  virtual ~CreateProjectModifyRecordsRequestDatabasesSpecificViews() = default;
};
class CreateProjectModifyRecordsRequestDatabasesTablesAdbTableSchema : public Darabonba::Model {
public:
  shared_ptr<vector<string>> distributedKeys{};
  shared_ptr<string> partitionLifeCycle{};
  shared_ptr<string> partitionStatement{};
  shared_ptr<vector<string>> primaryKeys{};

  CreateProjectModifyRecordsRequestDatabasesTablesAdbTableSchema() {}

  explicit CreateProjectModifyRecordsRequestDatabasesTablesAdbTableSchema(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (distributedKeys) {
      res["DistributedKeys"] = boost::any(*distributedKeys);
    }
    if (partitionLifeCycle) {
      res["PartitionLifeCycle"] = boost::any(*partitionLifeCycle);
    }
    if (partitionStatement) {
      res["PartitionStatement"] = boost::any(*partitionStatement);
    }
    if (primaryKeys) {
      res["PrimaryKeys"] = boost::any(*primaryKeys);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DistributedKeys") != m.end() && !m["DistributedKeys"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DistributedKeys"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DistributedKeys"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      distributedKeys = make_shared<vector<string>>(toVec1);
    }
    if (m.find("PartitionLifeCycle") != m.end() && !m["PartitionLifeCycle"].empty()) {
      partitionLifeCycle = make_shared<string>(boost::any_cast<string>(m["PartitionLifeCycle"]));
    }
    if (m.find("PartitionStatement") != m.end() && !m["PartitionStatement"].empty()) {
      partitionStatement = make_shared<string>(boost::any_cast<string>(m["PartitionStatement"]));
    }
    if (m.find("PrimaryKeys") != m.end() && !m["PrimaryKeys"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["PrimaryKeys"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["PrimaryKeys"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      primaryKeys = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~CreateProjectModifyRecordsRequestDatabasesTablesAdbTableSchema() = default;
};
class CreateProjectModifyRecordsRequestDatabasesTables : public Darabonba::Model {
public:
  shared_ptr<CreateProjectModifyRecordsRequestDatabasesTablesAdbTableSchema> adbTableSchema{};
  shared_ptr<vector<string>> filterColumns{};
  shared_ptr<string> id{};
  shared_ptr<string> mappedName{};
  shared_ptr<string> name{};
  shared_ptr<vector<string>> shardColumns{};
  shared_ptr<string> whereClause{};

  CreateProjectModifyRecordsRequestDatabasesTables() {}

  explicit CreateProjectModifyRecordsRequestDatabasesTables(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (adbTableSchema) {
      res["AdbTableSchema"] = adbTableSchema ? boost::any(adbTableSchema->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (filterColumns) {
      res["FilterColumns"] = boost::any(*filterColumns);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (mappedName) {
      res["MappedName"] = boost::any(*mappedName);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (shardColumns) {
      res["ShardColumns"] = boost::any(*shardColumns);
    }
    if (whereClause) {
      res["WhereClause"] = boost::any(*whereClause);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AdbTableSchema") != m.end() && !m["AdbTableSchema"].empty()) {
      if (typeid(map<string, boost::any>) == m["AdbTableSchema"].type()) {
        CreateProjectModifyRecordsRequestDatabasesTablesAdbTableSchema model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AdbTableSchema"]));
        adbTableSchema = make_shared<CreateProjectModifyRecordsRequestDatabasesTablesAdbTableSchema>(model1);
      }
    }
    if (m.find("FilterColumns") != m.end() && !m["FilterColumns"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["FilterColumns"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["FilterColumns"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      filterColumns = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("MappedName") != m.end() && !m["MappedName"].empty()) {
      mappedName = make_shared<string>(boost::any_cast<string>(m["MappedName"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ShardColumns") != m.end() && !m["ShardColumns"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ShardColumns"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ShardColumns"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      shardColumns = make_shared<vector<string>>(toVec1);
    }
    if (m.find("WhereClause") != m.end() && !m["WhereClause"].empty()) {
      whereClause = make_shared<string>(boost::any_cast<string>(m["WhereClause"]));
    }
  }


  virtual ~CreateProjectModifyRecordsRequestDatabasesTables() = default;
};
class CreateProjectModifyRecordsRequestDatabasesViewsAdbTableSchema : public Darabonba::Model {
public:
  shared_ptr<vector<string>> distributedKeys{};
  shared_ptr<string> partitionLifeCycle{};
  shared_ptr<string> partitionStatement{};
  shared_ptr<vector<string>> primaryKeys{};

  CreateProjectModifyRecordsRequestDatabasesViewsAdbTableSchema() {}

  explicit CreateProjectModifyRecordsRequestDatabasesViewsAdbTableSchema(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (distributedKeys) {
      res["DistributedKeys"] = boost::any(*distributedKeys);
    }
    if (partitionLifeCycle) {
      res["PartitionLifeCycle"] = boost::any(*partitionLifeCycle);
    }
    if (partitionStatement) {
      res["PartitionStatement"] = boost::any(*partitionStatement);
    }
    if (primaryKeys) {
      res["PrimaryKeys"] = boost::any(*primaryKeys);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DistributedKeys") != m.end() && !m["DistributedKeys"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DistributedKeys"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DistributedKeys"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      distributedKeys = make_shared<vector<string>>(toVec1);
    }
    if (m.find("PartitionLifeCycle") != m.end() && !m["PartitionLifeCycle"].empty()) {
      partitionLifeCycle = make_shared<string>(boost::any_cast<string>(m["PartitionLifeCycle"]));
    }
    if (m.find("PartitionStatement") != m.end() && !m["PartitionStatement"].empty()) {
      partitionStatement = make_shared<string>(boost::any_cast<string>(m["PartitionStatement"]));
    }
    if (m.find("PrimaryKeys") != m.end() && !m["PrimaryKeys"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["PrimaryKeys"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["PrimaryKeys"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      primaryKeys = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~CreateProjectModifyRecordsRequestDatabasesViewsAdbTableSchema() = default;
};
class CreateProjectModifyRecordsRequestDatabasesViews : public Darabonba::Model {
public:
  shared_ptr<CreateProjectModifyRecordsRequestDatabasesViewsAdbTableSchema> adbTableSchema{};
  shared_ptr<vector<string>> filterColumns{};
  shared_ptr<string> id{};
  shared_ptr<string> mappedName{};
  shared_ptr<string> name{};
  shared_ptr<vector<string>> shardColumns{};
  shared_ptr<string> whereClause{};

  CreateProjectModifyRecordsRequestDatabasesViews() {}

  explicit CreateProjectModifyRecordsRequestDatabasesViews(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (adbTableSchema) {
      res["AdbTableSchema"] = adbTableSchema ? boost::any(adbTableSchema->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (filterColumns) {
      res["FilterColumns"] = boost::any(*filterColumns);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (mappedName) {
      res["MappedName"] = boost::any(*mappedName);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (shardColumns) {
      res["ShardColumns"] = boost::any(*shardColumns);
    }
    if (whereClause) {
      res["WhereClause"] = boost::any(*whereClause);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AdbTableSchema") != m.end() && !m["AdbTableSchema"].empty()) {
      if (typeid(map<string, boost::any>) == m["AdbTableSchema"].type()) {
        CreateProjectModifyRecordsRequestDatabasesViewsAdbTableSchema model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AdbTableSchema"]));
        adbTableSchema = make_shared<CreateProjectModifyRecordsRequestDatabasesViewsAdbTableSchema>(model1);
      }
    }
    if (m.find("FilterColumns") != m.end() && !m["FilterColumns"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["FilterColumns"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["FilterColumns"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      filterColumns = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("MappedName") != m.end() && !m["MappedName"].empty()) {
      mappedName = make_shared<string>(boost::any_cast<string>(m["MappedName"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ShardColumns") != m.end() && !m["ShardColumns"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ShardColumns"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ShardColumns"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      shardColumns = make_shared<vector<string>>(toVec1);
    }
    if (m.find("WhereClause") != m.end() && !m["WhereClause"].empty()) {
      whereClause = make_shared<string>(boost::any_cast<string>(m["WhereClause"]));
    }
  }


  virtual ~CreateProjectModifyRecordsRequestDatabasesViews() = default;
};
class CreateProjectModifyRecordsRequestDatabases : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<string> mappedName{};
  shared_ptr<string> name{};
  shared_ptr<vector<CreateProjectModifyRecordsRequestDatabasesSpecificTables>> specificTables{};
  shared_ptr<vector<CreateProjectModifyRecordsRequestDatabasesSpecificViews>> specificViews{};
  shared_ptr<vector<CreateProjectModifyRecordsRequestDatabasesTables>> tables{};
  shared_ptr<vector<CreateProjectModifyRecordsRequestDatabasesViews>> views{};

  CreateProjectModifyRecordsRequestDatabases() {}

  explicit CreateProjectModifyRecordsRequestDatabases(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (mappedName) {
      res["MappedName"] = boost::any(*mappedName);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (specificTables) {
      vector<boost::any> temp1;
      for(auto item1:*specificTables){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SpecificTables"] = boost::any(temp1);
    }
    if (specificViews) {
      vector<boost::any> temp1;
      for(auto item1:*specificViews){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SpecificViews"] = boost::any(temp1);
    }
    if (tables) {
      vector<boost::any> temp1;
      for(auto item1:*tables){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tables"] = boost::any(temp1);
    }
    if (views) {
      vector<boost::any> temp1;
      for(auto item1:*views){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Views"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("MappedName") != m.end() && !m["MappedName"].empty()) {
      mappedName = make_shared<string>(boost::any_cast<string>(m["MappedName"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("SpecificTables") != m.end() && !m["SpecificTables"].empty()) {
      if (typeid(vector<boost::any>) == m["SpecificTables"].type()) {
        vector<CreateProjectModifyRecordsRequestDatabasesSpecificTables> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SpecificTables"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateProjectModifyRecordsRequestDatabasesSpecificTables model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        specificTables = make_shared<vector<CreateProjectModifyRecordsRequestDatabasesSpecificTables>>(expect1);
      }
    }
    if (m.find("SpecificViews") != m.end() && !m["SpecificViews"].empty()) {
      if (typeid(vector<boost::any>) == m["SpecificViews"].type()) {
        vector<CreateProjectModifyRecordsRequestDatabasesSpecificViews> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SpecificViews"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateProjectModifyRecordsRequestDatabasesSpecificViews model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        specificViews = make_shared<vector<CreateProjectModifyRecordsRequestDatabasesSpecificViews>>(expect1);
      }
    }
    if (m.find("Tables") != m.end() && !m["Tables"].empty()) {
      if (typeid(vector<boost::any>) == m["Tables"].type()) {
        vector<CreateProjectModifyRecordsRequestDatabasesTables> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tables"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateProjectModifyRecordsRequestDatabasesTables model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tables = make_shared<vector<CreateProjectModifyRecordsRequestDatabasesTables>>(expect1);
      }
    }
    if (m.find("Views") != m.end() && !m["Views"].empty()) {
      if (typeid(vector<boost::any>) == m["Views"].type()) {
        vector<CreateProjectModifyRecordsRequestDatabasesViews> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Views"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateProjectModifyRecordsRequestDatabasesViews model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        views = make_shared<vector<CreateProjectModifyRecordsRequestDatabasesViews>>(expect1);
      }
    }
  }


  virtual ~CreateProjectModifyRecordsRequestDatabases() = default;
};
class CreateProjectModifyRecordsRequest : public Darabonba::Model {
public:
  shared_ptr<vector<CreateProjectModifyRecordsRequestDatabases>> databases{};
  shared_ptr<string> id{};

  CreateProjectModifyRecordsRequest() {}

  explicit CreateProjectModifyRecordsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (databases) {
      vector<boost::any> temp1;
      for(auto item1:*databases){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Databases"] = boost::any(temp1);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Databases") != m.end() && !m["Databases"].empty()) {
      if (typeid(vector<boost::any>) == m["Databases"].type()) {
        vector<CreateProjectModifyRecordsRequestDatabases> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Databases"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateProjectModifyRecordsRequestDatabases model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        databases = make_shared<vector<CreateProjectModifyRecordsRequestDatabases>>(expect1);
      }
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
  }


  virtual ~CreateProjectModifyRecordsRequest() = default;
};
class CreateProjectModifyRecordsShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> databasesShrink{};
  shared_ptr<string> id{};

  CreateProjectModifyRecordsShrinkRequest() {}

  explicit CreateProjectModifyRecordsShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (databasesShrink) {
      res["Databases"] = boost::any(*databasesShrink);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Databases") != m.end() && !m["Databases"].empty()) {
      databasesShrink = make_shared<string>(boost::any_cast<string>(m["Databases"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
  }


  virtual ~CreateProjectModifyRecordsShrinkRequest() = default;
};
class CreateProjectModifyRecordsResponseBodyErrorDetail : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<map<string, boost::any>> extraContext{};
  shared_ptr<string> level{};
  shared_ptr<string> message{};
  shared_ptr<map<string, string>> messageMcmsContext{};
  shared_ptr<string> messageMcmsKey{};
  shared_ptr<string> proposal{};
  shared_ptr<map<string, string>> proposalMcmsContext{};
  shared_ptr<string> proposalMcmsKey{};
  shared_ptr<string> reason{};
  shared_ptr<map<string, string>> reasonMcmsContext{};
  shared_ptr<string> reasonMcmsKey{};
  shared_ptr<boost::any> upstreamErrorDetail{};

  CreateProjectModifyRecordsResponseBodyErrorDetail() {}

  explicit CreateProjectModifyRecordsResponseBodyErrorDetail(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (extraContext) {
      res["ExtraContext"] = boost::any(*extraContext);
    }
    if (level) {
      res["Level"] = boost::any(*level);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (messageMcmsContext) {
      res["MessageMcmsContext"] = boost::any(*messageMcmsContext);
    }
    if (messageMcmsKey) {
      res["MessageMcmsKey"] = boost::any(*messageMcmsKey);
    }
    if (proposal) {
      res["Proposal"] = boost::any(*proposal);
    }
    if (proposalMcmsContext) {
      res["ProposalMcmsContext"] = boost::any(*proposalMcmsContext);
    }
    if (proposalMcmsKey) {
      res["ProposalMcmsKey"] = boost::any(*proposalMcmsKey);
    }
    if (reason) {
      res["Reason"] = boost::any(*reason);
    }
    if (reasonMcmsContext) {
      res["ReasonMcmsContext"] = boost::any(*reasonMcmsContext);
    }
    if (reasonMcmsKey) {
      res["ReasonMcmsKey"] = boost::any(*reasonMcmsKey);
    }
    if (upstreamErrorDetail) {
      res["UpstreamErrorDetail"] = boost::any(*upstreamErrorDetail);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ExtraContext") != m.end() && !m["ExtraContext"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["ExtraContext"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      extraContext = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<string>(boost::any_cast<string>(m["Level"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("MessageMcmsContext") != m.end() && !m["MessageMcmsContext"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["MessageMcmsContext"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      messageMcmsContext = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("MessageMcmsKey") != m.end() && !m["MessageMcmsKey"].empty()) {
      messageMcmsKey = make_shared<string>(boost::any_cast<string>(m["MessageMcmsKey"]));
    }
    if (m.find("Proposal") != m.end() && !m["Proposal"].empty()) {
      proposal = make_shared<string>(boost::any_cast<string>(m["Proposal"]));
    }
    if (m.find("ProposalMcmsContext") != m.end() && !m["ProposalMcmsContext"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["ProposalMcmsContext"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      proposalMcmsContext = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("ProposalMcmsKey") != m.end() && !m["ProposalMcmsKey"].empty()) {
      proposalMcmsKey = make_shared<string>(boost::any_cast<string>(m["ProposalMcmsKey"]));
    }
    if (m.find("Reason") != m.end() && !m["Reason"].empty()) {
      reason = make_shared<string>(boost::any_cast<string>(m["Reason"]));
    }
    if (m.find("ReasonMcmsContext") != m.end() && !m["ReasonMcmsContext"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["ReasonMcmsContext"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      reasonMcmsContext = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("ReasonMcmsKey") != m.end() && !m["ReasonMcmsKey"].empty()) {
      reasonMcmsKey = make_shared<string>(boost::any_cast<string>(m["ReasonMcmsKey"]));
    }
    if (m.find("UpstreamErrorDetail") != m.end() && !m["UpstreamErrorDetail"].empty()) {
      upstreamErrorDetail = make_shared<boost::any>(boost::any_cast<boost::any>(m["UpstreamErrorDetail"]));
    }
  }


  virtual ~CreateProjectModifyRecordsResponseBodyErrorDetail() = default;
};
class CreateProjectModifyRecordsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> advice{};
  shared_ptr<string> code{};
  shared_ptr<string> cost{};
  shared_ptr<long> data{};
  shared_ptr<CreateProjectModifyRecordsResponseBodyErrorDetail> errorDetail{};
  shared_ptr<string> message{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<long> totalCount{};

  CreateProjectModifyRecordsResponseBody() {}

  explicit CreateProjectModifyRecordsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (advice) {
      res["Advice"] = boost::any(*advice);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (cost) {
      res["Cost"] = boost::any(*cost);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (errorDetail) {
      res["ErrorDetail"] = errorDetail ? boost::any(errorDetail->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Advice") != m.end() && !m["Advice"].empty()) {
      advice = make_shared<string>(boost::any_cast<string>(m["Advice"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Cost") != m.end() && !m["Cost"].empty()) {
      cost = make_shared<string>(boost::any_cast<string>(m["Cost"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<long>(boost::any_cast<long>(m["Data"]));
    }
    if (m.find("ErrorDetail") != m.end() && !m["ErrorDetail"].empty()) {
      if (typeid(map<string, boost::any>) == m["ErrorDetail"].type()) {
        CreateProjectModifyRecordsResponseBodyErrorDetail model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ErrorDetail"]));
        errorDetail = make_shared<CreateProjectModifyRecordsResponseBodyErrorDetail>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~CreateProjectModifyRecordsResponseBody() = default;
};
class CreateProjectModifyRecordsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateProjectModifyRecordsResponseBody> body{};

  CreateProjectModifyRecordsResponse() {}

  explicit CreateProjectModifyRecordsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateProjectModifyRecordsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateProjectModifyRecordsResponseBody>(model1);
      }
    }
  }


  virtual ~CreateProjectModifyRecordsResponse() = default;
};
class CreateRdsPostgreSQLDataSourceRequest : public Darabonba::Model {
public:
  shared_ptr<string> databaseName{};
  shared_ptr<string> description{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> name{};
  shared_ptr<string> password{};
  shared_ptr<string> userName{};

  CreateRdsPostgreSQLDataSourceRequest() {}

  explicit CreateRdsPostgreSQLDataSourceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (databaseName) {
      res["DatabaseName"] = boost::any(*databaseName);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (password) {
      res["Password"] = boost::any(*password);
    }
    if (userName) {
      res["UserName"] = boost::any(*userName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DatabaseName") != m.end() && !m["DatabaseName"].empty()) {
      databaseName = make_shared<string>(boost::any_cast<string>(m["DatabaseName"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Password") != m.end() && !m["Password"].empty()) {
      password = make_shared<string>(boost::any_cast<string>(m["Password"]));
    }
    if (m.find("UserName") != m.end() && !m["UserName"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["UserName"]));
    }
  }


  virtual ~CreateRdsPostgreSQLDataSourceRequest() = default;
};
class CreateRdsPostgreSQLDataSourceResponseBodyErrorDetail : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<map<string, boost::any>> extraContext{};
  shared_ptr<string> level{};
  shared_ptr<string> message{};
  shared_ptr<map<string, string>> messageMcmsContext{};
  shared_ptr<string> messageMcmsKey{};
  shared_ptr<string> proposal{};
  shared_ptr<map<string, string>> proposalMcmsContext{};
  shared_ptr<string> proposalMcmsKey{};
  shared_ptr<string> reason{};
  shared_ptr<map<string, string>> reasonMcmsContext{};
  shared_ptr<string> reasonMcmsKey{};
  shared_ptr<boost::any> upstreamErrorDetail{};

  CreateRdsPostgreSQLDataSourceResponseBodyErrorDetail() {}

  explicit CreateRdsPostgreSQLDataSourceResponseBodyErrorDetail(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (extraContext) {
      res["ExtraContext"] = boost::any(*extraContext);
    }
    if (level) {
      res["Level"] = boost::any(*level);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (messageMcmsContext) {
      res["MessageMcmsContext"] = boost::any(*messageMcmsContext);
    }
    if (messageMcmsKey) {
      res["MessageMcmsKey"] = boost::any(*messageMcmsKey);
    }
    if (proposal) {
      res["Proposal"] = boost::any(*proposal);
    }
    if (proposalMcmsContext) {
      res["ProposalMcmsContext"] = boost::any(*proposalMcmsContext);
    }
    if (proposalMcmsKey) {
      res["ProposalMcmsKey"] = boost::any(*proposalMcmsKey);
    }
    if (reason) {
      res["Reason"] = boost::any(*reason);
    }
    if (reasonMcmsContext) {
      res["ReasonMcmsContext"] = boost::any(*reasonMcmsContext);
    }
    if (reasonMcmsKey) {
      res["ReasonMcmsKey"] = boost::any(*reasonMcmsKey);
    }
    if (upstreamErrorDetail) {
      res["UpstreamErrorDetail"] = boost::any(*upstreamErrorDetail);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ExtraContext") != m.end() && !m["ExtraContext"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["ExtraContext"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      extraContext = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<string>(boost::any_cast<string>(m["Level"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("MessageMcmsContext") != m.end() && !m["MessageMcmsContext"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["MessageMcmsContext"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      messageMcmsContext = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("MessageMcmsKey") != m.end() && !m["MessageMcmsKey"].empty()) {
      messageMcmsKey = make_shared<string>(boost::any_cast<string>(m["MessageMcmsKey"]));
    }
    if (m.find("Proposal") != m.end() && !m["Proposal"].empty()) {
      proposal = make_shared<string>(boost::any_cast<string>(m["Proposal"]));
    }
    if (m.find("ProposalMcmsContext") != m.end() && !m["ProposalMcmsContext"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["ProposalMcmsContext"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      proposalMcmsContext = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("ProposalMcmsKey") != m.end() && !m["ProposalMcmsKey"].empty()) {
      proposalMcmsKey = make_shared<string>(boost::any_cast<string>(m["ProposalMcmsKey"]));
    }
    if (m.find("Reason") != m.end() && !m["Reason"].empty()) {
      reason = make_shared<string>(boost::any_cast<string>(m["Reason"]));
    }
    if (m.find("ReasonMcmsContext") != m.end() && !m["ReasonMcmsContext"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["ReasonMcmsContext"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      reasonMcmsContext = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("ReasonMcmsKey") != m.end() && !m["ReasonMcmsKey"].empty()) {
      reasonMcmsKey = make_shared<string>(boost::any_cast<string>(m["ReasonMcmsKey"]));
    }
    if (m.find("UpstreamErrorDetail") != m.end() && !m["UpstreamErrorDetail"].empty()) {
      upstreamErrorDetail = make_shared<boost::any>(boost::any_cast<boost::any>(m["UpstreamErrorDetail"]));
    }
  }


  virtual ~CreateRdsPostgreSQLDataSourceResponseBodyErrorDetail() = default;
};
class CreateRdsPostgreSQLDataSourceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> advice{};
  shared_ptr<string> code{};
  shared_ptr<string> cost{};
  shared_ptr<string> data{};
  shared_ptr<CreateRdsPostgreSQLDataSourceResponseBodyErrorDetail> errorDetail{};
  shared_ptr<string> message{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<long> totalCount{};

  CreateRdsPostgreSQLDataSourceResponseBody() {}

  explicit CreateRdsPostgreSQLDataSourceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (advice) {
      res["Advice"] = boost::any(*advice);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (cost) {
      res["Cost"] = boost::any(*cost);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (errorDetail) {
      res["ErrorDetail"] = errorDetail ? boost::any(errorDetail->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Advice") != m.end() && !m["Advice"].empty()) {
      advice = make_shared<string>(boost::any_cast<string>(m["Advice"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Cost") != m.end() && !m["Cost"].empty()) {
      cost = make_shared<string>(boost::any_cast<string>(m["Cost"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("ErrorDetail") != m.end() && !m["ErrorDetail"].empty()) {
      if (typeid(map<string, boost::any>) == m["ErrorDetail"].type()) {
        CreateRdsPostgreSQLDataSourceResponseBodyErrorDetail model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ErrorDetail"]));
        errorDetail = make_shared<CreateRdsPostgreSQLDataSourceResponseBodyErrorDetail>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~CreateRdsPostgreSQLDataSourceResponseBody() = default;
};
class CreateRdsPostgreSQLDataSourceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateRdsPostgreSQLDataSourceResponseBody> body{};

  CreateRdsPostgreSQLDataSourceResponse() {}

  explicit CreateRdsPostgreSQLDataSourceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateRdsPostgreSQLDataSourceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateRdsPostgreSQLDataSourceResponseBody>(model1);
      }
    }
  }


  virtual ~CreateRdsPostgreSQLDataSourceResponse() = default;
};
class CreateSecurityIpGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> securityIpGroupName{};
  shared_ptr<string> securityIps{};

  CreateSecurityIpGroupRequest() {}

  explicit CreateSecurityIpGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (securityIpGroupName) {
      res["SecurityIpGroupName"] = boost::any(*securityIpGroupName);
    }
    if (securityIps) {
      res["SecurityIps"] = boost::any(*securityIps);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("SecurityIpGroupName") != m.end() && !m["SecurityIpGroupName"].empty()) {
      securityIpGroupName = make_shared<string>(boost::any_cast<string>(m["SecurityIpGroupName"]));
    }
    if (m.find("SecurityIps") != m.end() && !m["SecurityIps"].empty()) {
      securityIps = make_shared<string>(boost::any_cast<string>(m["SecurityIps"]));
    }
  }


  virtual ~CreateSecurityIpGroupRequest() = default;
};
class CreateSecurityIpGroupResponseBodySecurityIpGroup : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> securityIpGroupName{};
  shared_ptr<string> securityIps{};

  CreateSecurityIpGroupResponseBodySecurityIpGroup() {}

  explicit CreateSecurityIpGroupResponseBodySecurityIpGroup(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (securityIpGroupName) {
      res["SecurityIpGroupName"] = boost::any(*securityIpGroupName);
    }
    if (securityIps) {
      res["SecurityIps"] = boost::any(*securityIps);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("SecurityIpGroupName") != m.end() && !m["SecurityIpGroupName"].empty()) {
      securityIpGroupName = make_shared<string>(boost::any_cast<string>(m["SecurityIpGroupName"]));
    }
    if (m.find("SecurityIps") != m.end() && !m["SecurityIps"].empty()) {
      securityIps = make_shared<string>(boost::any_cast<string>(m["SecurityIps"]));
    }
  }


  virtual ~CreateSecurityIpGroupResponseBodySecurityIpGroup() = default;
};
class CreateSecurityIpGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<CreateSecurityIpGroupResponseBodySecurityIpGroup> securityIpGroup{};

  CreateSecurityIpGroupResponseBody() {}

  explicit CreateSecurityIpGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (securityIpGroup) {
      res["SecurityIpGroup"] = securityIpGroup ? boost::any(securityIpGroup->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SecurityIpGroup") != m.end() && !m["SecurityIpGroup"].empty()) {
      if (typeid(map<string, boost::any>) == m["SecurityIpGroup"].type()) {
        CreateSecurityIpGroupResponseBodySecurityIpGroup model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SecurityIpGroup"]));
        securityIpGroup = make_shared<CreateSecurityIpGroupResponseBodySecurityIpGroup>(model1);
      }
    }
  }


  virtual ~CreateSecurityIpGroupResponseBody() = default;
};
class CreateSecurityIpGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateSecurityIpGroupResponseBody> body{};

  CreateSecurityIpGroupResponse() {}

  explicit CreateSecurityIpGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateSecurityIpGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateSecurityIpGroupResponseBody>(model1);
      }
    }
  }


  virtual ~CreateSecurityIpGroupResponse() = default;
};
class CreateTenantRequest : public Darabonba::Model {
public:
  shared_ptr<string> charset{};
  shared_ptr<long> cpu{};
  shared_ptr<string> description{};
  shared_ptr<string> instanceId{};
  shared_ptr<long> logDisk{};
  shared_ptr<long> memory{};
  shared_ptr<string> primaryZone{};
  shared_ptr<string> readOnlyZoneList{};
  shared_ptr<string> tenantMode{};
  shared_ptr<string> tenantName{};
  shared_ptr<string> timeZone{};
  shared_ptr<long> unitNum{};
  shared_ptr<string> userVSwitchId{};
  shared_ptr<string> userVpcId{};

  CreateTenantRequest() {}

  explicit CreateTenantRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (charset) {
      res["Charset"] = boost::any(*charset);
    }
    if (cpu) {
      res["Cpu"] = boost::any(*cpu);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (logDisk) {
      res["LogDisk"] = boost::any(*logDisk);
    }
    if (memory) {
      res["Memory"] = boost::any(*memory);
    }
    if (primaryZone) {
      res["PrimaryZone"] = boost::any(*primaryZone);
    }
    if (readOnlyZoneList) {
      res["ReadOnlyZoneList"] = boost::any(*readOnlyZoneList);
    }
    if (tenantMode) {
      res["TenantMode"] = boost::any(*tenantMode);
    }
    if (tenantName) {
      res["TenantName"] = boost::any(*tenantName);
    }
    if (timeZone) {
      res["TimeZone"] = boost::any(*timeZone);
    }
    if (unitNum) {
      res["UnitNum"] = boost::any(*unitNum);
    }
    if (userVSwitchId) {
      res["UserVSwitchId"] = boost::any(*userVSwitchId);
    }
    if (userVpcId) {
      res["UserVpcId"] = boost::any(*userVpcId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Charset") != m.end() && !m["Charset"].empty()) {
      charset = make_shared<string>(boost::any_cast<string>(m["Charset"]));
    }
    if (m.find("Cpu") != m.end() && !m["Cpu"].empty()) {
      cpu = make_shared<long>(boost::any_cast<long>(m["Cpu"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("LogDisk") != m.end() && !m["LogDisk"].empty()) {
      logDisk = make_shared<long>(boost::any_cast<long>(m["LogDisk"]));
    }
    if (m.find("Memory") != m.end() && !m["Memory"].empty()) {
      memory = make_shared<long>(boost::any_cast<long>(m["Memory"]));
    }
    if (m.find("PrimaryZone") != m.end() && !m["PrimaryZone"].empty()) {
      primaryZone = make_shared<string>(boost::any_cast<string>(m["PrimaryZone"]));
    }
    if (m.find("ReadOnlyZoneList") != m.end() && !m["ReadOnlyZoneList"].empty()) {
      readOnlyZoneList = make_shared<string>(boost::any_cast<string>(m["ReadOnlyZoneList"]));
    }
    if (m.find("TenantMode") != m.end() && !m["TenantMode"].empty()) {
      tenantMode = make_shared<string>(boost::any_cast<string>(m["TenantMode"]));
    }
    if (m.find("TenantName") != m.end() && !m["TenantName"].empty()) {
      tenantName = make_shared<string>(boost::any_cast<string>(m["TenantName"]));
    }
    if (m.find("TimeZone") != m.end() && !m["TimeZone"].empty()) {
      timeZone = make_shared<string>(boost::any_cast<string>(m["TimeZone"]));
    }
    if (m.find("UnitNum") != m.end() && !m["UnitNum"].empty()) {
      unitNum = make_shared<long>(boost::any_cast<long>(m["UnitNum"]));
    }
    if (m.find("UserVSwitchId") != m.end() && !m["UserVSwitchId"].empty()) {
      userVSwitchId = make_shared<string>(boost::any_cast<string>(m["UserVSwitchId"]));
    }
    if (m.find("UserVpcId") != m.end() && !m["UserVpcId"].empty()) {
      userVpcId = make_shared<string>(boost::any_cast<string>(m["UserVpcId"]));
    }
  }


  virtual ~CreateTenantRequest() = default;
};
class CreateTenantResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> tenantId{};

  CreateTenantResponseBody() {}

  explicit CreateTenantResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["TenantId"]));
    }
  }


  virtual ~CreateTenantResponseBody() = default;
};
class CreateTenantResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateTenantResponseBody> body{};

  CreateTenantResponse() {}

  explicit CreateTenantResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateTenantResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateTenantResponseBody>(model1);
      }
    }
  }


  virtual ~CreateTenantResponse() = default;
};
class CreateTenantReadOnlyConnectionRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> tenantId{};
  shared_ptr<string> vSwitchId{};
  shared_ptr<string> vpcId{};
  shared_ptr<string> zoneId{};

  CreateTenantReadOnlyConnectionRequest() {}

  explicit CreateTenantReadOnlyConnectionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    if (vSwitchId) {
      res["VSwitchId"] = boost::any(*vSwitchId);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["TenantId"]));
    }
    if (m.find("VSwitchId") != m.end() && !m["VSwitchId"].empty()) {
      vSwitchId = make_shared<string>(boost::any_cast<string>(m["VSwitchId"]));
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["ZoneId"]));
    }
  }


  virtual ~CreateTenantReadOnlyConnectionRequest() = default;
};
class CreateTenantReadOnlyConnectionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  CreateTenantReadOnlyConnectionResponseBody() {}

  explicit CreateTenantReadOnlyConnectionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateTenantReadOnlyConnectionResponseBody() = default;
};
class CreateTenantReadOnlyConnectionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateTenantReadOnlyConnectionResponseBody> body{};

  CreateTenantReadOnlyConnectionResponse() {}

  explicit CreateTenantReadOnlyConnectionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateTenantReadOnlyConnectionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateTenantReadOnlyConnectionResponseBody>(model1);
      }
    }
  }


  virtual ~CreateTenantReadOnlyConnectionResponse() = default;
};
class CreateTenantSecurityIpGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> securityIpGroupName{};
  shared_ptr<string> securityIps{};
  shared_ptr<string> tenantId{};

  CreateTenantSecurityIpGroupRequest() {}

  explicit CreateTenantSecurityIpGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (securityIpGroupName) {
      res["SecurityIpGroupName"] = boost::any(*securityIpGroupName);
    }
    if (securityIps) {
      res["SecurityIps"] = boost::any(*securityIps);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("SecurityIpGroupName") != m.end() && !m["SecurityIpGroupName"].empty()) {
      securityIpGroupName = make_shared<string>(boost::any_cast<string>(m["SecurityIpGroupName"]));
    }
    if (m.find("SecurityIps") != m.end() && !m["SecurityIps"].empty()) {
      securityIps = make_shared<string>(boost::any_cast<string>(m["SecurityIps"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["TenantId"]));
    }
  }


  virtual ~CreateTenantSecurityIpGroupRequest() = default;
};
class CreateTenantSecurityIpGroupResponseBodySecurityIpGroup : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> securityIpGroupName{};
  shared_ptr<string> securityIps{};
  shared_ptr<string> tenantId{};

  CreateTenantSecurityIpGroupResponseBodySecurityIpGroup() {}

  explicit CreateTenantSecurityIpGroupResponseBodySecurityIpGroup(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (securityIpGroupName) {
      res["SecurityIpGroupName"] = boost::any(*securityIpGroupName);
    }
    if (securityIps) {
      res["SecurityIps"] = boost::any(*securityIps);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("SecurityIpGroupName") != m.end() && !m["SecurityIpGroupName"].empty()) {
      securityIpGroupName = make_shared<string>(boost::any_cast<string>(m["SecurityIpGroupName"]));
    }
    if (m.find("SecurityIps") != m.end() && !m["SecurityIps"].empty()) {
      securityIps = make_shared<string>(boost::any_cast<string>(m["SecurityIps"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["TenantId"]));
    }
  }


  virtual ~CreateTenantSecurityIpGroupResponseBodySecurityIpGroup() = default;
};
class CreateTenantSecurityIpGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<CreateTenantSecurityIpGroupResponseBodySecurityIpGroup> securityIpGroup{};

  CreateTenantSecurityIpGroupResponseBody() {}

  explicit CreateTenantSecurityIpGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (securityIpGroup) {
      res["SecurityIpGroup"] = securityIpGroup ? boost::any(securityIpGroup->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SecurityIpGroup") != m.end() && !m["SecurityIpGroup"].empty()) {
      if (typeid(map<string, boost::any>) == m["SecurityIpGroup"].type()) {
        CreateTenantSecurityIpGroupResponseBodySecurityIpGroup model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SecurityIpGroup"]));
        securityIpGroup = make_shared<CreateTenantSecurityIpGroupResponseBodySecurityIpGroup>(model1);
      }
    }
  }


  virtual ~CreateTenantSecurityIpGroupResponseBody() = default;
};
class CreateTenantSecurityIpGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateTenantSecurityIpGroupResponseBody> body{};

  CreateTenantSecurityIpGroupResponse() {}

  explicit CreateTenantSecurityIpGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateTenantSecurityIpGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateTenantSecurityIpGroupResponseBody>(model1);
      }
    }
  }


  virtual ~CreateTenantSecurityIpGroupResponse() = default;
};
class CreateTenantUserRequest : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> encryptionType{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> roles{};
  shared_ptr<string> tenantId{};
  shared_ptr<string> userName{};
  shared_ptr<string> userPassword{};
  shared_ptr<string> userType{};

  CreateTenantUserRequest() {}

  explicit CreateTenantUserRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (encryptionType) {
      res["EncryptionType"] = boost::any(*encryptionType);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (roles) {
      res["Roles"] = boost::any(*roles);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    if (userName) {
      res["UserName"] = boost::any(*userName);
    }
    if (userPassword) {
      res["UserPassword"] = boost::any(*userPassword);
    }
    if (userType) {
      res["UserType"] = boost::any(*userType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("EncryptionType") != m.end() && !m["EncryptionType"].empty()) {
      encryptionType = make_shared<string>(boost::any_cast<string>(m["EncryptionType"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Roles") != m.end() && !m["Roles"].empty()) {
      roles = make_shared<string>(boost::any_cast<string>(m["Roles"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["TenantId"]));
    }
    if (m.find("UserName") != m.end() && !m["UserName"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["UserName"]));
    }
    if (m.find("UserPassword") != m.end() && !m["UserPassword"].empty()) {
      userPassword = make_shared<string>(boost::any_cast<string>(m["UserPassword"]));
    }
    if (m.find("UserType") != m.end() && !m["UserType"].empty()) {
      userType = make_shared<string>(boost::any_cast<string>(m["UserType"]));
    }
  }


  virtual ~CreateTenantUserRequest() = default;
};
class CreateTenantUserResponseBodyTenantUserRoles : public Darabonba::Model {
public:
  shared_ptr<string> database{};
  shared_ptr<string> role{};

  CreateTenantUserResponseBodyTenantUserRoles() {}

  explicit CreateTenantUserResponseBodyTenantUserRoles(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (database) {
      res["Database"] = boost::any(*database);
    }
    if (role) {
      res["Role"] = boost::any(*role);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Database") != m.end() && !m["Database"].empty()) {
      database = make_shared<string>(boost::any_cast<string>(m["Database"]));
    }
    if (m.find("Role") != m.end() && !m["Role"].empty()) {
      role = make_shared<string>(boost::any_cast<string>(m["Role"]));
    }
  }


  virtual ~CreateTenantUserResponseBodyTenantUserRoles() = default;
};
class CreateTenantUserResponseBodyTenantUser : public Darabonba::Model {
public:
  shared_ptr<vector<CreateTenantUserResponseBodyTenantUserRoles>> roles{};
  shared_ptr<string> userName{};
  shared_ptr<string> userStatus{};
  shared_ptr<string> userType{};

  CreateTenantUserResponseBodyTenantUser() {}

  explicit CreateTenantUserResponseBodyTenantUser(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (roles) {
      vector<boost::any> temp1;
      for(auto item1:*roles){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Roles"] = boost::any(temp1);
    }
    if (userName) {
      res["UserName"] = boost::any(*userName);
    }
    if (userStatus) {
      res["UserStatus"] = boost::any(*userStatus);
    }
    if (userType) {
      res["UserType"] = boost::any(*userType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Roles") != m.end() && !m["Roles"].empty()) {
      if (typeid(vector<boost::any>) == m["Roles"].type()) {
        vector<CreateTenantUserResponseBodyTenantUserRoles> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Roles"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateTenantUserResponseBodyTenantUserRoles model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        roles = make_shared<vector<CreateTenantUserResponseBodyTenantUserRoles>>(expect1);
      }
    }
    if (m.find("UserName") != m.end() && !m["UserName"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["UserName"]));
    }
    if (m.find("UserStatus") != m.end() && !m["UserStatus"].empty()) {
      userStatus = make_shared<string>(boost::any_cast<string>(m["UserStatus"]));
    }
    if (m.find("UserType") != m.end() && !m["UserType"].empty()) {
      userType = make_shared<string>(boost::any_cast<string>(m["UserType"]));
    }
  }


  virtual ~CreateTenantUserResponseBodyTenantUser() = default;
};
class CreateTenantUserResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<CreateTenantUserResponseBodyTenantUser> tenantUser{};

  CreateTenantUserResponseBody() {}

  explicit CreateTenantUserResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (tenantUser) {
      res["TenantUser"] = tenantUser ? boost::any(tenantUser->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TenantUser") != m.end() && !m["TenantUser"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantUser"].type()) {
        CreateTenantUserResponseBodyTenantUser model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantUser"]));
        tenantUser = make_shared<CreateTenantUserResponseBodyTenantUser>(model1);
      }
    }
  }


  virtual ~CreateTenantUserResponseBody() = default;
};
class CreateTenantUserResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateTenantUserResponseBody> body{};

  CreateTenantUserResponse() {}

  explicit CreateTenantUserResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateTenantUserResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateTenantUserResponseBody>(model1);
      }
    }
  }


  virtual ~CreateTenantUserResponse() = default;
};
class DeleteDataSourceRequest : public Darabonba::Model {
public:
  shared_ptr<string> id{};

  DeleteDataSourceRequest() {}

  explicit DeleteDataSourceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
  }


  virtual ~DeleteDataSourceRequest() = default;
};
class DeleteDataSourceResponseBodyErrorDetail : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<map<string, boost::any>> extraContext{};
  shared_ptr<string> level{};
  shared_ptr<string> message{};
  shared_ptr<map<string, string>> messageMcmsContext{};
  shared_ptr<string> messageMcmsKey{};
  shared_ptr<string> proposal{};
  shared_ptr<map<string, string>> proposalMcmsContext{};
  shared_ptr<string> proposalMcmsKey{};
  shared_ptr<string> reason{};
  shared_ptr<map<string, string>> reasonMcmsContext{};
  shared_ptr<string> reasonMcmsKey{};
  shared_ptr<boost::any> upstreamErrorDetail{};

  DeleteDataSourceResponseBodyErrorDetail() {}

  explicit DeleteDataSourceResponseBodyErrorDetail(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (extraContext) {
      res["ExtraContext"] = boost::any(*extraContext);
    }
    if (level) {
      res["Level"] = boost::any(*level);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (messageMcmsContext) {
      res["MessageMcmsContext"] = boost::any(*messageMcmsContext);
    }
    if (messageMcmsKey) {
      res["MessageMcmsKey"] = boost::any(*messageMcmsKey);
    }
    if (proposal) {
      res["Proposal"] = boost::any(*proposal);
    }
    if (proposalMcmsContext) {
      res["ProposalMcmsContext"] = boost::any(*proposalMcmsContext);
    }
    if (proposalMcmsKey) {
      res["ProposalMcmsKey"] = boost::any(*proposalMcmsKey);
    }
    if (reason) {
      res["Reason"] = boost::any(*reason);
    }
    if (reasonMcmsContext) {
      res["ReasonMcmsContext"] = boost::any(*reasonMcmsContext);
    }
    if (reasonMcmsKey) {
      res["ReasonMcmsKey"] = boost::any(*reasonMcmsKey);
    }
    if (upstreamErrorDetail) {
      res["UpstreamErrorDetail"] = boost::any(*upstreamErrorDetail);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ExtraContext") != m.end() && !m["ExtraContext"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["ExtraContext"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      extraContext = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<string>(boost::any_cast<string>(m["Level"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("MessageMcmsContext") != m.end() && !m["MessageMcmsContext"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["MessageMcmsContext"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      messageMcmsContext = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("MessageMcmsKey") != m.end() && !m["MessageMcmsKey"].empty()) {
      messageMcmsKey = make_shared<string>(boost::any_cast<string>(m["MessageMcmsKey"]));
    }
    if (m.find("Proposal") != m.end() && !m["Proposal"].empty()) {
      proposal = make_shared<string>(boost::any_cast<string>(m["Proposal"]));
    }
    if (m.find("ProposalMcmsContext") != m.end() && !m["ProposalMcmsContext"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["ProposalMcmsContext"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      proposalMcmsContext = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("ProposalMcmsKey") != m.end() && !m["ProposalMcmsKey"].empty()) {
      proposalMcmsKey = make_shared<string>(boost::any_cast<string>(m["ProposalMcmsKey"]));
    }
    if (m.find("Reason") != m.end() && !m["Reason"].empty()) {
      reason = make_shared<string>(boost::any_cast<string>(m["Reason"]));
    }
    if (m.find("ReasonMcmsContext") != m.end() && !m["ReasonMcmsContext"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["ReasonMcmsContext"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      reasonMcmsContext = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("ReasonMcmsKey") != m.end() && !m["ReasonMcmsKey"].empty()) {
      reasonMcmsKey = make_shared<string>(boost::any_cast<string>(m["ReasonMcmsKey"]));
    }
    if (m.find("UpstreamErrorDetail") != m.end() && !m["UpstreamErrorDetail"].empty()) {
      upstreamErrorDetail = make_shared<boost::any>(boost::any_cast<boost::any>(m["UpstreamErrorDetail"]));
    }
  }


  virtual ~DeleteDataSourceResponseBodyErrorDetail() = default;
};
class DeleteDataSourceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> advice{};
  shared_ptr<string> code{};
  shared_ptr<string> cost{};
  shared_ptr<boost::any> data{};
  shared_ptr<DeleteDataSourceResponseBodyErrorDetail> errorDetail{};
  shared_ptr<string> message{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<long> totalCount{};

  DeleteDataSourceResponseBody() {}

  explicit DeleteDataSourceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (advice) {
      res["Advice"] = boost::any(*advice);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (cost) {
      res["Cost"] = boost::any(*cost);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (errorDetail) {
      res["ErrorDetail"] = errorDetail ? boost::any(errorDetail->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Advice") != m.end() && !m["Advice"].empty()) {
      advice = make_shared<string>(boost::any_cast<string>(m["Advice"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Cost") != m.end() && !m["Cost"].empty()) {
      cost = make_shared<string>(boost::any_cast<string>(m["Cost"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<boost::any>(boost::any_cast<boost::any>(m["Data"]));
    }
    if (m.find("ErrorDetail") != m.end() && !m["ErrorDetail"].empty()) {
      if (typeid(map<string, boost::any>) == m["ErrorDetail"].type()) {
        DeleteDataSourceResponseBodyErrorDetail model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ErrorDetail"]));
        errorDetail = make_shared<DeleteDataSourceResponseBodyErrorDetail>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DeleteDataSourceResponseBody() = default;
};
class DeleteDataSourceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteDataSourceResponseBody> body{};

  DeleteDataSourceResponse() {}

  explicit DeleteDataSourceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteDataSourceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteDataSourceResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteDataSourceResponse() = default;
};
class DeleteDatabasesRequest : public Darabonba::Model {
public:
  shared_ptr<string> databaseNames{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> tenantId{};

  DeleteDatabasesRequest() {}

  explicit DeleteDatabasesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (databaseNames) {
      res["DatabaseNames"] = boost::any(*databaseNames);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DatabaseNames") != m.end() && !m["DatabaseNames"].empty()) {
      databaseNames = make_shared<string>(boost::any_cast<string>(m["DatabaseNames"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["TenantId"]));
    }
  }


  virtual ~DeleteDatabasesRequest() = default;
};
class DeleteDatabasesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteDatabasesResponseBody() {}

  explicit DeleteDatabasesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteDatabasesResponseBody() = default;
};
class DeleteDatabasesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteDatabasesResponseBody> body{};

  DeleteDatabasesResponse() {}

  explicit DeleteDatabasesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteDatabasesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteDatabasesResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteDatabasesResponse() = default;
};
class DeleteInstancesRequest : public Darabonba::Model {
public:
  shared_ptr<string> backupRetainMode{};
  shared_ptr<bool> dryRun{};
  shared_ptr<string> instanceIds{};

  DeleteInstancesRequest() {}

  explicit DeleteInstancesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (backupRetainMode) {
      res["BackupRetainMode"] = boost::any(*backupRetainMode);
    }
    if (dryRun) {
      res["DryRun"] = boost::any(*dryRun);
    }
    if (instanceIds) {
      res["InstanceIds"] = boost::any(*instanceIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BackupRetainMode") != m.end() && !m["BackupRetainMode"].empty()) {
      backupRetainMode = make_shared<string>(boost::any_cast<string>(m["BackupRetainMode"]));
    }
    if (m.find("DryRun") != m.end() && !m["DryRun"].empty()) {
      dryRun = make_shared<bool>(boost::any_cast<bool>(m["DryRun"]));
    }
    if (m.find("InstanceIds") != m.end() && !m["InstanceIds"].empty()) {
      instanceIds = make_shared<string>(boost::any_cast<string>(m["InstanceIds"]));
    }
  }


  virtual ~DeleteInstancesRequest() = default;
};
class DeleteInstancesResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<bool> dryRunResult{};

  DeleteInstancesResponseBodyData() {}

  explicit DeleteInstancesResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dryRunResult) {
      res["DryRunResult"] = boost::any(*dryRunResult);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DryRunResult") != m.end() && !m["DryRunResult"].empty()) {
      dryRunResult = make_shared<bool>(boost::any_cast<bool>(m["DryRunResult"]));
    }
  }


  virtual ~DeleteInstancesResponseBodyData() = default;
};
class DeleteInstancesResponseBody : public Darabonba::Model {
public:
  shared_ptr<DeleteInstancesResponseBodyData> data{};
  shared_ptr<string> requestId{};

  DeleteInstancesResponseBody() {}

  explicit DeleteInstancesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        DeleteInstancesResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<DeleteInstancesResponseBodyData>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteInstancesResponseBody() = default;
};
class DeleteInstancesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteInstancesResponseBody> body{};

  DeleteInstancesResponse() {}

  explicit DeleteInstancesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteInstancesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteInstancesResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteInstancesResponse() = default;
};
class DeleteProjectRequest : public Darabonba::Model {
public:
  shared_ptr<string> id{};

  DeleteProjectRequest() {}

  explicit DeleteProjectRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
  }


  virtual ~DeleteProjectRequest() = default;
};
class DeleteProjectResponseBodyErrorDetail : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<map<string, boost::any>> extraContext{};
  shared_ptr<string> level{};
  shared_ptr<string> message{};
  shared_ptr<map<string, string>> messageMcmsContext{};
  shared_ptr<string> messageMcmsKey{};
  shared_ptr<string> proposal{};
  shared_ptr<map<string, string>> proposalMcmsContext{};
  shared_ptr<string> proposalMcmsKey{};
  shared_ptr<string> reason{};
  shared_ptr<map<string, string>> reasonMcmsContext{};
  shared_ptr<string> reasonMcmsKey{};
  shared_ptr<boost::any> upstreamErrorDetail{};

  DeleteProjectResponseBodyErrorDetail() {}

  explicit DeleteProjectResponseBodyErrorDetail(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (extraContext) {
      res["ExtraContext"] = boost::any(*extraContext);
    }
    if (level) {
      res["Level"] = boost::any(*level);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (messageMcmsContext) {
      res["MessageMcmsContext"] = boost::any(*messageMcmsContext);
    }
    if (messageMcmsKey) {
      res["MessageMcmsKey"] = boost::any(*messageMcmsKey);
    }
    if (proposal) {
      res["Proposal"] = boost::any(*proposal);
    }
    if (proposalMcmsContext) {
      res["ProposalMcmsContext"] = boost::any(*proposalMcmsContext);
    }
    if (proposalMcmsKey) {
      res["ProposalMcmsKey"] = boost::any(*proposalMcmsKey);
    }
    if (reason) {
      res["Reason"] = boost::any(*reason);
    }
    if (reasonMcmsContext) {
      res["ReasonMcmsContext"] = boost::any(*reasonMcmsContext);
    }
    if (reasonMcmsKey) {
      res["ReasonMcmsKey"] = boost::any(*reasonMcmsKey);
    }
    if (upstreamErrorDetail) {
      res["UpstreamErrorDetail"] = boost::any(*upstreamErrorDetail);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ExtraContext") != m.end() && !m["ExtraContext"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["ExtraContext"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      extraContext = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<string>(boost::any_cast<string>(m["Level"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("MessageMcmsContext") != m.end() && !m["MessageMcmsContext"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["MessageMcmsContext"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      messageMcmsContext = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("MessageMcmsKey") != m.end() && !m["MessageMcmsKey"].empty()) {
      messageMcmsKey = make_shared<string>(boost::any_cast<string>(m["MessageMcmsKey"]));
    }
    if (m.find("Proposal") != m.end() && !m["Proposal"].empty()) {
      proposal = make_shared<string>(boost::any_cast<string>(m["Proposal"]));
    }
    if (m.find("ProposalMcmsContext") != m.end() && !m["ProposalMcmsContext"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["ProposalMcmsContext"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      proposalMcmsContext = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("ProposalMcmsKey") != m.end() && !m["ProposalMcmsKey"].empty()) {
      proposalMcmsKey = make_shared<string>(boost::any_cast<string>(m["ProposalMcmsKey"]));
    }
    if (m.find("Reason") != m.end() && !m["Reason"].empty()) {
      reason = make_shared<string>(boost::any_cast<string>(m["Reason"]));
    }
    if (m.find("ReasonMcmsContext") != m.end() && !m["ReasonMcmsContext"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["ReasonMcmsContext"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      reasonMcmsContext = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("ReasonMcmsKey") != m.end() && !m["ReasonMcmsKey"].empty()) {
      reasonMcmsKey = make_shared<string>(boost::any_cast<string>(m["ReasonMcmsKey"]));
    }
    if (m.find("UpstreamErrorDetail") != m.end() && !m["UpstreamErrorDetail"].empty()) {
      upstreamErrorDetail = make_shared<boost::any>(boost::any_cast<boost::any>(m["UpstreamErrorDetail"]));
    }
  }


  virtual ~DeleteProjectResponseBodyErrorDetail() = default;
};
class DeleteProjectResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> advice{};
  shared_ptr<string> code{};
  shared_ptr<string> cost{};
  shared_ptr<boost::any> data{};
  shared_ptr<DeleteProjectResponseBodyErrorDetail> errorDetail{};
  shared_ptr<string> message{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<long> totalCount{};

  DeleteProjectResponseBody() {}

  explicit DeleteProjectResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (advice) {
      res["Advice"] = boost::any(*advice);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (cost) {
      res["Cost"] = boost::any(*cost);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (errorDetail) {
      res["ErrorDetail"] = errorDetail ? boost::any(errorDetail->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Advice") != m.end() && !m["Advice"].empty()) {
      advice = make_shared<string>(boost::any_cast<string>(m["Advice"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Cost") != m.end() && !m["Cost"].empty()) {
      cost = make_shared<string>(boost::any_cast<string>(m["Cost"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<boost::any>(boost::any_cast<boost::any>(m["Data"]));
    }
    if (m.find("ErrorDetail") != m.end() && !m["ErrorDetail"].empty()) {
      if (typeid(map<string, boost::any>) == m["ErrorDetail"].type()) {
        DeleteProjectResponseBodyErrorDetail model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ErrorDetail"]));
        errorDetail = make_shared<DeleteProjectResponseBodyErrorDetail>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DeleteProjectResponseBody() = default;
};
class DeleteProjectResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteProjectResponseBody> body{};

  DeleteProjectResponse() {}

  explicit DeleteProjectResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteProjectResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteProjectResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteProjectResponse() = default;
};
class DeleteSecurityIpGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> securityIpGroupName{};

  DeleteSecurityIpGroupRequest() {}

  explicit DeleteSecurityIpGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (securityIpGroupName) {
      res["SecurityIpGroupName"] = boost::any(*securityIpGroupName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("SecurityIpGroupName") != m.end() && !m["SecurityIpGroupName"].empty()) {
      securityIpGroupName = make_shared<string>(boost::any_cast<string>(m["SecurityIpGroupName"]));
    }
  }


  virtual ~DeleteSecurityIpGroupRequest() = default;
};
class DeleteSecurityIpGroupResponseBodySecurityIpGroup : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> securityIpGroupName{};

  DeleteSecurityIpGroupResponseBodySecurityIpGroup() {}

  explicit DeleteSecurityIpGroupResponseBodySecurityIpGroup(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (securityIpGroupName) {
      res["SecurityIpGroupName"] = boost::any(*securityIpGroupName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("SecurityIpGroupName") != m.end() && !m["SecurityIpGroupName"].empty()) {
      securityIpGroupName = make_shared<string>(boost::any_cast<string>(m["SecurityIpGroupName"]));
    }
  }


  virtual ~DeleteSecurityIpGroupResponseBodySecurityIpGroup() = default;
};
class DeleteSecurityIpGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DeleteSecurityIpGroupResponseBodySecurityIpGroup> securityIpGroup{};

  DeleteSecurityIpGroupResponseBody() {}

  explicit DeleteSecurityIpGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (securityIpGroup) {
      res["SecurityIpGroup"] = securityIpGroup ? boost::any(securityIpGroup->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SecurityIpGroup") != m.end() && !m["SecurityIpGroup"].empty()) {
      if (typeid(map<string, boost::any>) == m["SecurityIpGroup"].type()) {
        DeleteSecurityIpGroupResponseBodySecurityIpGroup model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SecurityIpGroup"]));
        securityIpGroup = make_shared<DeleteSecurityIpGroupResponseBodySecurityIpGroup>(model1);
      }
    }
  }


  virtual ~DeleteSecurityIpGroupResponseBody() = default;
};
class DeleteSecurityIpGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteSecurityIpGroupResponseBody> body{};

  DeleteSecurityIpGroupResponse() {}

  explicit DeleteSecurityIpGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteSecurityIpGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteSecurityIpGroupResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteSecurityIpGroupResponse() = default;
};
class DeleteTenantSecurityIpGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> securityIpGroupName{};
  shared_ptr<string> tenantId{};

  DeleteTenantSecurityIpGroupRequest() {}

  explicit DeleteTenantSecurityIpGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (securityIpGroupName) {
      res["SecurityIpGroupName"] = boost::any(*securityIpGroupName);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("SecurityIpGroupName") != m.end() && !m["SecurityIpGroupName"].empty()) {
      securityIpGroupName = make_shared<string>(boost::any_cast<string>(m["SecurityIpGroupName"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["TenantId"]));
    }
  }


  virtual ~DeleteTenantSecurityIpGroupRequest() = default;
};
class DeleteTenantSecurityIpGroupResponseBodySecurityIpGroup : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> securityIpGroupName{};
  shared_ptr<string> tenantId{};

  DeleteTenantSecurityIpGroupResponseBodySecurityIpGroup() {}

  explicit DeleteTenantSecurityIpGroupResponseBodySecurityIpGroup(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (securityIpGroupName) {
      res["SecurityIpGroupName"] = boost::any(*securityIpGroupName);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("SecurityIpGroupName") != m.end() && !m["SecurityIpGroupName"].empty()) {
      securityIpGroupName = make_shared<string>(boost::any_cast<string>(m["SecurityIpGroupName"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["TenantId"]));
    }
  }


  virtual ~DeleteTenantSecurityIpGroupResponseBodySecurityIpGroup() = default;
};
class DeleteTenantSecurityIpGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DeleteTenantSecurityIpGroupResponseBodySecurityIpGroup> securityIpGroup{};

  DeleteTenantSecurityIpGroupResponseBody() {}

  explicit DeleteTenantSecurityIpGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (securityIpGroup) {
      res["SecurityIpGroup"] = securityIpGroup ? boost::any(securityIpGroup->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SecurityIpGroup") != m.end() && !m["SecurityIpGroup"].empty()) {
      if (typeid(map<string, boost::any>) == m["SecurityIpGroup"].type()) {
        DeleteTenantSecurityIpGroupResponseBodySecurityIpGroup model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SecurityIpGroup"]));
        securityIpGroup = make_shared<DeleteTenantSecurityIpGroupResponseBodySecurityIpGroup>(model1);
      }
    }
  }


  virtual ~DeleteTenantSecurityIpGroupResponseBody() = default;
};
class DeleteTenantSecurityIpGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteTenantSecurityIpGroupResponseBody> body{};

  DeleteTenantSecurityIpGroupResponse() {}

  explicit DeleteTenantSecurityIpGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteTenantSecurityIpGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteTenantSecurityIpGroupResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteTenantSecurityIpGroupResponse() = default;
};
class DeleteTenantUsersRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> tenantId{};
  shared_ptr<string> users{};

  DeleteTenantUsersRequest() {}

  explicit DeleteTenantUsersRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    if (users) {
      res["Users"] = boost::any(*users);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["TenantId"]));
    }
    if (m.find("Users") != m.end() && !m["Users"].empty()) {
      users = make_shared<string>(boost::any_cast<string>(m["Users"]));
    }
  }


  virtual ~DeleteTenantUsersRequest() = default;
};
class DeleteTenantUsersResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteTenantUsersResponseBody() {}

  explicit DeleteTenantUsersResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteTenantUsersResponseBody() = default;
};
class DeleteTenantUsersResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteTenantUsersResponseBody> body{};

  DeleteTenantUsersResponse() {}

  explicit DeleteTenantUsersResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteTenantUsersResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteTenantUsersResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteTenantUsersResponse() = default;
};
class DeleteTenantsRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> tenantIds{};

  DeleteTenantsRequest() {}

  explicit DeleteTenantsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (tenantIds) {
      res["TenantIds"] = boost::any(*tenantIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("TenantIds") != m.end() && !m["TenantIds"].empty()) {
      tenantIds = make_shared<string>(boost::any_cast<string>(m["TenantIds"]));
    }
  }


  virtual ~DeleteTenantsRequest() = default;
};
class DeleteTenantsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<string>> tenantIds{};

  DeleteTenantsResponseBody() {}

  explicit DeleteTenantsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (tenantIds) {
      res["TenantIds"] = boost::any(*tenantIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TenantIds") != m.end() && !m["TenantIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["TenantIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["TenantIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      tenantIds = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DeleteTenantsResponseBody() = default;
};
class DeleteTenantsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteTenantsResponseBody> body{};

  DeleteTenantsResponse() {}

  explicit DeleteTenantsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteTenantsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteTenantsResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteTenantsResponse() = default;
};
class DescribeAnomalySQLListRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<string> dbName{};
  shared_ptr<string> endTime{};
  shared_ptr<map<string, boost::any>> filterCondition{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> nodeIp{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> SQLId{};
  shared_ptr<string> searchKeyWord{};
  shared_ptr<string> searchParameter{};
  shared_ptr<string> searchRule{};
  shared_ptr<string> searchValue{};
  shared_ptr<string> sortColumn{};
  shared_ptr<string> sortOrder{};
  shared_ptr<string> startTime{};
  shared_ptr<string> tenantId{};

  DescribeAnomalySQLListRequest() {}

  explicit DescribeAnomalySQLListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (dbName) {
      res["DbName"] = boost::any(*dbName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (filterCondition) {
      res["FilterCondition"] = boost::any(*filterCondition);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (nodeIp) {
      res["NodeIp"] = boost::any(*nodeIp);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (SQLId) {
      res["SQLId"] = boost::any(*SQLId);
    }
    if (searchKeyWord) {
      res["SearchKeyWord"] = boost::any(*searchKeyWord);
    }
    if (searchParameter) {
      res["SearchParameter"] = boost::any(*searchParameter);
    }
    if (searchRule) {
      res["SearchRule"] = boost::any(*searchRule);
    }
    if (searchValue) {
      res["SearchValue"] = boost::any(*searchValue);
    }
    if (sortColumn) {
      res["SortColumn"] = boost::any(*sortColumn);
    }
    if (sortOrder) {
      res["SortOrder"] = boost::any(*sortOrder);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("DbName") != m.end() && !m["DbName"].empty()) {
      dbName = make_shared<string>(boost::any_cast<string>(m["DbName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("FilterCondition") != m.end() && !m["FilterCondition"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["FilterCondition"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      filterCondition = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("NodeIp") != m.end() && !m["NodeIp"].empty()) {
      nodeIp = make_shared<string>(boost::any_cast<string>(m["NodeIp"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SQLId") != m.end() && !m["SQLId"].empty()) {
      SQLId = make_shared<string>(boost::any_cast<string>(m["SQLId"]));
    }
    if (m.find("SearchKeyWord") != m.end() && !m["SearchKeyWord"].empty()) {
      searchKeyWord = make_shared<string>(boost::any_cast<string>(m["SearchKeyWord"]));
    }
    if (m.find("SearchParameter") != m.end() && !m["SearchParameter"].empty()) {
      searchParameter = make_shared<string>(boost::any_cast<string>(m["SearchParameter"]));
    }
    if (m.find("SearchRule") != m.end() && !m["SearchRule"].empty()) {
      searchRule = make_shared<string>(boost::any_cast<string>(m["SearchRule"]));
    }
    if (m.find("SearchValue") != m.end() && !m["SearchValue"].empty()) {
      searchValue = make_shared<string>(boost::any_cast<string>(m["SearchValue"]));
    }
    if (m.find("SortColumn") != m.end() && !m["SortColumn"].empty()) {
      sortColumn = make_shared<string>(boost::any_cast<string>(m["SortColumn"]));
    }
    if (m.find("SortOrder") != m.end() && !m["SortOrder"].empty()) {
      sortOrder = make_shared<string>(boost::any_cast<string>(m["SortOrder"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["TenantId"]));
    }
  }


  virtual ~DescribeAnomalySQLListRequest() = default;
};
class DescribeAnomalySQLListShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<string> dbName{};
  shared_ptr<string> endTime{};
  shared_ptr<string> filterConditionShrink{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> nodeIp{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> SQLId{};
  shared_ptr<string> searchKeyWord{};
  shared_ptr<string> searchParameter{};
  shared_ptr<string> searchRule{};
  shared_ptr<string> searchValue{};
  shared_ptr<string> sortColumn{};
  shared_ptr<string> sortOrder{};
  shared_ptr<string> startTime{};
  shared_ptr<string> tenantId{};

  DescribeAnomalySQLListShrinkRequest() {}

  explicit DescribeAnomalySQLListShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (dbName) {
      res["DbName"] = boost::any(*dbName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (filterConditionShrink) {
      res["FilterCondition"] = boost::any(*filterConditionShrink);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (nodeIp) {
      res["NodeIp"] = boost::any(*nodeIp);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (SQLId) {
      res["SQLId"] = boost::any(*SQLId);
    }
    if (searchKeyWord) {
      res["SearchKeyWord"] = boost::any(*searchKeyWord);
    }
    if (searchParameter) {
      res["SearchParameter"] = boost::any(*searchParameter);
    }
    if (searchRule) {
      res["SearchRule"] = boost::any(*searchRule);
    }
    if (searchValue) {
      res["SearchValue"] = boost::any(*searchValue);
    }
    if (sortColumn) {
      res["SortColumn"] = boost::any(*sortColumn);
    }
    if (sortOrder) {
      res["SortOrder"] = boost::any(*sortOrder);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("DbName") != m.end() && !m["DbName"].empty()) {
      dbName = make_shared<string>(boost::any_cast<string>(m["DbName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("FilterCondition") != m.end() && !m["FilterCondition"].empty()) {
      filterConditionShrink = make_shared<string>(boost::any_cast<string>(m["FilterCondition"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("NodeIp") != m.end() && !m["NodeIp"].empty()) {
      nodeIp = make_shared<string>(boost::any_cast<string>(m["NodeIp"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SQLId") != m.end() && !m["SQLId"].empty()) {
      SQLId = make_shared<string>(boost::any_cast<string>(m["SQLId"]));
    }
    if (m.find("SearchKeyWord") != m.end() && !m["SearchKeyWord"].empty()) {
      searchKeyWord = make_shared<string>(boost::any_cast<string>(m["SearchKeyWord"]));
    }
    if (m.find("SearchParameter") != m.end() && !m["SearchParameter"].empty()) {
      searchParameter = make_shared<string>(boost::any_cast<string>(m["SearchParameter"]));
    }
    if (m.find("SearchRule") != m.end() && !m["SearchRule"].empty()) {
      searchRule = make_shared<string>(boost::any_cast<string>(m["SearchRule"]));
    }
    if (m.find("SearchValue") != m.end() && !m["SearchValue"].empty()) {
      searchValue = make_shared<string>(boost::any_cast<string>(m["SearchValue"]));
    }
    if (m.find("SortColumn") != m.end() && !m["SortColumn"].empty()) {
      sortColumn = make_shared<string>(boost::any_cast<string>(m["SortColumn"]));
    }
    if (m.find("SortOrder") != m.end() && !m["SortOrder"].empty()) {
      sortOrder = make_shared<string>(boost::any_cast<string>(m["SortOrder"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["TenantId"]));
    }
  }


  virtual ~DescribeAnomalySQLListShrinkRequest() = default;
};
class DescribeAnomalySQLListResponseBodyAnomalySQLList : public Darabonba::Model {
public:
  shared_ptr<double> cpuTime{};
  shared_ptr<string> dbName{};
  shared_ptr<string> diagnosis{};
  shared_ptr<string> diagnosisRule{};
  shared_ptr<long> executions{};
  shared_ptr<long> key{};
  shared_ptr<double> requestTime{};
  shared_ptr<string> requestTimeUTCString{};
  shared_ptr<string> SQLId{};
  shared_ptr<string> SQLText{};
  shared_ptr<string> suggestion{};
  shared_ptr<string> userName{};

  DescribeAnomalySQLListResponseBodyAnomalySQLList() {}

  explicit DescribeAnomalySQLListResponseBodyAnomalySQLList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cpuTime) {
      res["CpuTime"] = boost::any(*cpuTime);
    }
    if (dbName) {
      res["DbName"] = boost::any(*dbName);
    }
    if (diagnosis) {
      res["Diagnosis"] = boost::any(*diagnosis);
    }
    if (diagnosisRule) {
      res["DiagnosisRule"] = boost::any(*diagnosisRule);
    }
    if (executions) {
      res["Executions"] = boost::any(*executions);
    }
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (requestTime) {
      res["RequestTime"] = boost::any(*requestTime);
    }
    if (requestTimeUTCString) {
      res["RequestTimeUTCString"] = boost::any(*requestTimeUTCString);
    }
    if (SQLId) {
      res["SQLId"] = boost::any(*SQLId);
    }
    if (SQLText) {
      res["SQLText"] = boost::any(*SQLText);
    }
    if (suggestion) {
      res["Suggestion"] = boost::any(*suggestion);
    }
    if (userName) {
      res["UserName"] = boost::any(*userName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CpuTime") != m.end() && !m["CpuTime"].empty()) {
      cpuTime = make_shared<double>(boost::any_cast<double>(m["CpuTime"]));
    }
    if (m.find("DbName") != m.end() && !m["DbName"].empty()) {
      dbName = make_shared<string>(boost::any_cast<string>(m["DbName"]));
    }
    if (m.find("Diagnosis") != m.end() && !m["Diagnosis"].empty()) {
      diagnosis = make_shared<string>(boost::any_cast<string>(m["Diagnosis"]));
    }
    if (m.find("DiagnosisRule") != m.end() && !m["DiagnosisRule"].empty()) {
      diagnosisRule = make_shared<string>(boost::any_cast<string>(m["DiagnosisRule"]));
    }
    if (m.find("Executions") != m.end() && !m["Executions"].empty()) {
      executions = make_shared<long>(boost::any_cast<long>(m["Executions"]));
    }
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<long>(boost::any_cast<long>(m["Key"]));
    }
    if (m.find("RequestTime") != m.end() && !m["RequestTime"].empty()) {
      requestTime = make_shared<double>(boost::any_cast<double>(m["RequestTime"]));
    }
    if (m.find("RequestTimeUTCString") != m.end() && !m["RequestTimeUTCString"].empty()) {
      requestTimeUTCString = make_shared<string>(boost::any_cast<string>(m["RequestTimeUTCString"]));
    }
    if (m.find("SQLId") != m.end() && !m["SQLId"].empty()) {
      SQLId = make_shared<string>(boost::any_cast<string>(m["SQLId"]));
    }
    if (m.find("SQLText") != m.end() && !m["SQLText"].empty()) {
      SQLText = make_shared<string>(boost::any_cast<string>(m["SQLText"]));
    }
    if (m.find("Suggestion") != m.end() && !m["Suggestion"].empty()) {
      suggestion = make_shared<string>(boost::any_cast<string>(m["Suggestion"]));
    }
    if (m.find("UserName") != m.end() && !m["UserName"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["UserName"]));
    }
  }


  virtual ~DescribeAnomalySQLListResponseBodyAnomalySQLList() = default;
};
class DescribeAnomalySQLListResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeAnomalySQLListResponseBodyAnomalySQLList>> anomalySQLList{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeAnomalySQLListResponseBody() {}

  explicit DescribeAnomalySQLListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (anomalySQLList) {
      vector<boost::any> temp1;
      for(auto item1:*anomalySQLList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AnomalySQLList"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AnomalySQLList") != m.end() && !m["AnomalySQLList"].empty()) {
      if (typeid(vector<boost::any>) == m["AnomalySQLList"].type()) {
        vector<DescribeAnomalySQLListResponseBodyAnomalySQLList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AnomalySQLList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeAnomalySQLListResponseBodyAnomalySQLList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        anomalySQLList = make_shared<vector<DescribeAnomalySQLListResponseBodyAnomalySQLList>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeAnomalySQLListResponseBody() = default;
};
class DescribeAnomalySQLListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeAnomalySQLListResponseBody> body{};

  DescribeAnomalySQLListResponse() {}

  explicit DescribeAnomalySQLListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeAnomalySQLListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeAnomalySQLListResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeAnomalySQLListResponse() = default;
};
class DescribeAvailableCpuResourceRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> modifyType{};
  shared_ptr<string> tenantId{};

  DescribeAvailableCpuResourceRequest() {}

  explicit DescribeAvailableCpuResourceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (modifyType) {
      res["ModifyType"] = boost::any(*modifyType);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("ModifyType") != m.end() && !m["ModifyType"].empty()) {
      modifyType = make_shared<string>(boost::any_cast<string>(m["ModifyType"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["TenantId"]));
    }
  }


  virtual ~DescribeAvailableCpuResourceRequest() = default;
};
class DescribeAvailableCpuResourceResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> comment{};
  shared_ptr<long> maxCpu{};
  shared_ptr<long> minCpu{};
  shared_ptr<string> reviewCode{};
  shared_ptr<long> unitNum{};

  DescribeAvailableCpuResourceResponseBodyData() {}

  explicit DescribeAvailableCpuResourceResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (comment) {
      res["Comment"] = boost::any(*comment);
    }
    if (maxCpu) {
      res["MaxCpu"] = boost::any(*maxCpu);
    }
    if (minCpu) {
      res["MinCpu"] = boost::any(*minCpu);
    }
    if (reviewCode) {
      res["ReviewCode"] = boost::any(*reviewCode);
    }
    if (unitNum) {
      res["UnitNum"] = boost::any(*unitNum);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Comment") != m.end() && !m["Comment"].empty()) {
      comment = make_shared<string>(boost::any_cast<string>(m["Comment"]));
    }
    if (m.find("MaxCpu") != m.end() && !m["MaxCpu"].empty()) {
      maxCpu = make_shared<long>(boost::any_cast<long>(m["MaxCpu"]));
    }
    if (m.find("MinCpu") != m.end() && !m["MinCpu"].empty()) {
      minCpu = make_shared<long>(boost::any_cast<long>(m["MinCpu"]));
    }
    if (m.find("ReviewCode") != m.end() && !m["ReviewCode"].empty()) {
      reviewCode = make_shared<string>(boost::any_cast<string>(m["ReviewCode"]));
    }
    if (m.find("UnitNum") != m.end() && !m["UnitNum"].empty()) {
      unitNum = make_shared<long>(boost::any_cast<long>(m["UnitNum"]));
    }
  }


  virtual ~DescribeAvailableCpuResourceResponseBodyData() = default;
};
class DescribeAvailableCpuResourceResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeAvailableCpuResourceResponseBodyData>> data{};
  shared_ptr<string> requestId{};

  DescribeAvailableCpuResourceResponseBody() {}

  explicit DescribeAvailableCpuResourceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<DescribeAvailableCpuResourceResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeAvailableCpuResourceResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<DescribeAvailableCpuResourceResponseBodyData>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeAvailableCpuResourceResponseBody() = default;
};
class DescribeAvailableCpuResourceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeAvailableCpuResourceResponseBody> body{};

  DescribeAvailableCpuResourceResponse() {}

  explicit DescribeAvailableCpuResourceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeAvailableCpuResourceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeAvailableCpuResourceResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeAvailableCpuResourceResponse() = default;
};
class DescribeAvailableMemResourceRequest : public Darabonba::Model {
public:
  shared_ptr<long> cpuNum{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> tenantId{};
  shared_ptr<long> unitNum{};

  DescribeAvailableMemResourceRequest() {}

  explicit DescribeAvailableMemResourceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cpuNum) {
      res["CpuNum"] = boost::any(*cpuNum);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    if (unitNum) {
      res["UnitNum"] = boost::any(*unitNum);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CpuNum") != m.end() && !m["CpuNum"].empty()) {
      cpuNum = make_shared<long>(boost::any_cast<long>(m["CpuNum"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["TenantId"]));
    }
    if (m.find("UnitNum") != m.end() && !m["UnitNum"].empty()) {
      unitNum = make_shared<long>(boost::any_cast<long>(m["UnitNum"]));
    }
  }


  virtual ~DescribeAvailableMemResourceRequest() = default;
};
class DescribeAvailableMemResourceResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> maxMem{};
  shared_ptr<long> minMem{};
  shared_ptr<string> safeMem{};
  shared_ptr<long> usedMem{};

  DescribeAvailableMemResourceResponseBodyData() {}

  explicit DescribeAvailableMemResourceResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (maxMem) {
      res["MaxMem"] = boost::any(*maxMem);
    }
    if (minMem) {
      res["MinMem"] = boost::any(*minMem);
    }
    if (safeMem) {
      res["SafeMem"] = boost::any(*safeMem);
    }
    if (usedMem) {
      res["UsedMem"] = boost::any(*usedMem);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MaxMem") != m.end() && !m["MaxMem"].empty()) {
      maxMem = make_shared<long>(boost::any_cast<long>(m["MaxMem"]));
    }
    if (m.find("MinMem") != m.end() && !m["MinMem"].empty()) {
      minMem = make_shared<long>(boost::any_cast<long>(m["MinMem"]));
    }
    if (m.find("SafeMem") != m.end() && !m["SafeMem"].empty()) {
      safeMem = make_shared<string>(boost::any_cast<string>(m["SafeMem"]));
    }
    if (m.find("UsedMem") != m.end() && !m["UsedMem"].empty()) {
      usedMem = make_shared<long>(boost::any_cast<long>(m["UsedMem"]));
    }
  }


  virtual ~DescribeAvailableMemResourceResponseBodyData() = default;
};
class DescribeAvailableMemResourceResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeAvailableMemResourceResponseBodyData> data{};
  shared_ptr<string> requestId{};

  DescribeAvailableMemResourceResponseBody() {}

  explicit DescribeAvailableMemResourceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        DescribeAvailableMemResourceResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<DescribeAvailableMemResourceResponseBodyData>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeAvailableMemResourceResponseBody() = default;
};
class DescribeAvailableMemResourceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeAvailableMemResourceResponseBody> body{};

  DescribeAvailableMemResourceResponse() {}

  explicit DescribeAvailableMemResourceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeAvailableMemResourceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeAvailableMemResourceResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeAvailableMemResourceResponse() = default;
};
class DescribeAvailableSpecRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> spec{};
  shared_ptr<string> upgradeType{};

  DescribeAvailableSpecRequest() {}

  explicit DescribeAvailableSpecRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (spec) {
      res["Spec"] = boost::any(*spec);
    }
    if (upgradeType) {
      res["UpgradeType"] = boost::any(*upgradeType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Spec") != m.end() && !m["Spec"].empty()) {
      spec = make_shared<string>(boost::any_cast<string>(m["Spec"]));
    }
    if (m.find("UpgradeType") != m.end() && !m["UpgradeType"].empty()) {
      upgradeType = make_shared<string>(boost::any_cast<string>(m["UpgradeType"]));
    }
  }


  virtual ~DescribeAvailableSpecRequest() = default;
};
class DescribeAvailableSpecResponseBodyDataAvailableSpecificationsDiskSizeRange : public Darabonba::Model {
public:
  shared_ptr<long> max{};
  shared_ptr<long> min{};
  shared_ptr<long> step{};

  DescribeAvailableSpecResponseBodyDataAvailableSpecificationsDiskSizeRange() {}

  explicit DescribeAvailableSpecResponseBodyDataAvailableSpecificationsDiskSizeRange(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (max) {
      res["Max"] = boost::any(*max);
    }
    if (min) {
      res["Min"] = boost::any(*min);
    }
    if (step) {
      res["Step"] = boost::any(*step);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Max") != m.end() && !m["Max"].empty()) {
      max = make_shared<long>(boost::any_cast<long>(m["Max"]));
    }
    if (m.find("Min") != m.end() && !m["Min"].empty()) {
      min = make_shared<long>(boost::any_cast<long>(m["Min"]));
    }
    if (m.find("Step") != m.end() && !m["Step"].empty()) {
      step = make_shared<long>(boost::any_cast<long>(m["Step"]));
    }
  }


  virtual ~DescribeAvailableSpecResponseBodyDataAvailableSpecificationsDiskSizeRange() = default;
};
class DescribeAvailableSpecResponseBodyDataAvailableSpecificationsLogDiskSizeRange : public Darabonba::Model {
public:
  shared_ptr<long> max{};
  shared_ptr<long> min{};
  shared_ptr<long> step{};

  DescribeAvailableSpecResponseBodyDataAvailableSpecificationsLogDiskSizeRange() {}

  explicit DescribeAvailableSpecResponseBodyDataAvailableSpecificationsLogDiskSizeRange(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (max) {
      res["Max"] = boost::any(*max);
    }
    if (min) {
      res["Min"] = boost::any(*min);
    }
    if (step) {
      res["Step"] = boost::any(*step);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Max") != m.end() && !m["Max"].empty()) {
      max = make_shared<long>(boost::any_cast<long>(m["Max"]));
    }
    if (m.find("Min") != m.end() && !m["Min"].empty()) {
      min = make_shared<long>(boost::any_cast<long>(m["Min"]));
    }
    if (m.find("Step") != m.end() && !m["Step"].empty()) {
      step = make_shared<long>(boost::any_cast<long>(m["Step"]));
    }
  }


  virtual ~DescribeAvailableSpecResponseBodyDataAvailableSpecificationsLogDiskSizeRange() = default;
};
class DescribeAvailableSpecResponseBodyDataAvailableSpecifications : public Darabonba::Model {
public:
  shared_ptr<DescribeAvailableSpecResponseBodyDataAvailableSpecificationsDiskSizeRange> diskSizeRange{};
  shared_ptr<vector<string>> diskTypes{};
  shared_ptr<string> instanceClass{};
  shared_ptr<DescribeAvailableSpecResponseBodyDataAvailableSpecificationsLogDiskSizeRange> logDiskSizeRange{};
  shared_ptr<vector<long>> nodeNum{};
  shared_ptr<string> spec{};

  DescribeAvailableSpecResponseBodyDataAvailableSpecifications() {}

  explicit DescribeAvailableSpecResponseBodyDataAvailableSpecifications(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (diskSizeRange) {
      res["DiskSizeRange"] = diskSizeRange ? boost::any(diskSizeRange->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (diskTypes) {
      res["DiskTypes"] = boost::any(*diskTypes);
    }
    if (instanceClass) {
      res["InstanceClass"] = boost::any(*instanceClass);
    }
    if (logDiskSizeRange) {
      res["LogDiskSizeRange"] = logDiskSizeRange ? boost::any(logDiskSizeRange->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (nodeNum) {
      res["NodeNum"] = boost::any(*nodeNum);
    }
    if (spec) {
      res["Spec"] = boost::any(*spec);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DiskSizeRange") != m.end() && !m["DiskSizeRange"].empty()) {
      if (typeid(map<string, boost::any>) == m["DiskSizeRange"].type()) {
        DescribeAvailableSpecResponseBodyDataAvailableSpecificationsDiskSizeRange model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DiskSizeRange"]));
        diskSizeRange = make_shared<DescribeAvailableSpecResponseBodyDataAvailableSpecificationsDiskSizeRange>(model1);
      }
    }
    if (m.find("DiskTypes") != m.end() && !m["DiskTypes"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DiskTypes"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DiskTypes"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      diskTypes = make_shared<vector<string>>(toVec1);
    }
    if (m.find("InstanceClass") != m.end() && !m["InstanceClass"].empty()) {
      instanceClass = make_shared<string>(boost::any_cast<string>(m["InstanceClass"]));
    }
    if (m.find("LogDiskSizeRange") != m.end() && !m["LogDiskSizeRange"].empty()) {
      if (typeid(map<string, boost::any>) == m["LogDiskSizeRange"].type()) {
        DescribeAvailableSpecResponseBodyDataAvailableSpecificationsLogDiskSizeRange model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LogDiskSizeRange"]));
        logDiskSizeRange = make_shared<DescribeAvailableSpecResponseBodyDataAvailableSpecificationsLogDiskSizeRange>(model1);
      }
    }
    if (m.find("NodeNum") != m.end() && !m["NodeNum"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["NodeNum"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["NodeNum"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      nodeNum = make_shared<vector<long>>(toVec1);
    }
    if (m.find("Spec") != m.end() && !m["Spec"].empty()) {
      spec = make_shared<string>(boost::any_cast<string>(m["Spec"]));
    }
  }


  virtual ~DescribeAvailableSpecResponseBodyDataAvailableSpecifications() = default;
};
class DescribeAvailableSpecResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeAvailableSpecResponseBodyDataAvailableSpecifications>> availableSpecifications{};

  DescribeAvailableSpecResponseBodyData() {}

  explicit DescribeAvailableSpecResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (availableSpecifications) {
      vector<boost::any> temp1;
      for(auto item1:*availableSpecifications){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AvailableSpecifications"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AvailableSpecifications") != m.end() && !m["AvailableSpecifications"].empty()) {
      if (typeid(vector<boost::any>) == m["AvailableSpecifications"].type()) {
        vector<DescribeAvailableSpecResponseBodyDataAvailableSpecifications> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AvailableSpecifications"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeAvailableSpecResponseBodyDataAvailableSpecifications model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        availableSpecifications = make_shared<vector<DescribeAvailableSpecResponseBodyDataAvailableSpecifications>>(expect1);
      }
    }
  }


  virtual ~DescribeAvailableSpecResponseBodyData() = default;
};
class DescribeAvailableSpecResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeAvailableSpecResponseBodyData> data{};
  shared_ptr<string> requestId{};

  DescribeAvailableSpecResponseBody() {}

  explicit DescribeAvailableSpecResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        DescribeAvailableSpecResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<DescribeAvailableSpecResponseBodyData>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeAvailableSpecResponseBody() = default;
};
class DescribeAvailableSpecResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeAvailableSpecResponseBody> body{};

  DescribeAvailableSpecResponse() {}

  explicit DescribeAvailableSpecResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeAvailableSpecResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeAvailableSpecResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeAvailableSpecResponse() = default;
};
class DescribeAvailableZoneRequest : public Darabonba::Model {
public:
  shared_ptr<string> deployType{};
  shared_ptr<string> instanceType{};
  shared_ptr<string> obVersion{};
  shared_ptr<string> series{};
  shared_ptr<string> spec{};

  DescribeAvailableZoneRequest() {}

  explicit DescribeAvailableZoneRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deployType) {
      res["DeployType"] = boost::any(*deployType);
    }
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (obVersion) {
      res["ObVersion"] = boost::any(*obVersion);
    }
    if (series) {
      res["Series"] = boost::any(*series);
    }
    if (spec) {
      res["Spec"] = boost::any(*spec);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeployType") != m.end() && !m["DeployType"].empty()) {
      deployType = make_shared<string>(boost::any_cast<string>(m["DeployType"]));
    }
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("ObVersion") != m.end() && !m["ObVersion"].empty()) {
      obVersion = make_shared<string>(boost::any_cast<string>(m["ObVersion"]));
    }
    if (m.find("Series") != m.end() && !m["Series"].empty()) {
      series = make_shared<string>(boost::any_cast<string>(m["Series"]));
    }
    if (m.find("Spec") != m.end() && !m["Spec"].empty()) {
      spec = make_shared<string>(boost::any_cast<string>(m["Spec"]));
    }
  }


  virtual ~DescribeAvailableZoneRequest() = default;
};
class DescribeAvailableZoneResponseBodyDataAvailableZonesSupportSpecificationsDiskSizeRange : public Darabonba::Model {
public:
  shared_ptr<long> max{};
  shared_ptr<long> min{};
  shared_ptr<long> step{};

  DescribeAvailableZoneResponseBodyDataAvailableZonesSupportSpecificationsDiskSizeRange() {}

  explicit DescribeAvailableZoneResponseBodyDataAvailableZonesSupportSpecificationsDiskSizeRange(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (max) {
      res["Max"] = boost::any(*max);
    }
    if (min) {
      res["Min"] = boost::any(*min);
    }
    if (step) {
      res["Step"] = boost::any(*step);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Max") != m.end() && !m["Max"].empty()) {
      max = make_shared<long>(boost::any_cast<long>(m["Max"]));
    }
    if (m.find("Min") != m.end() && !m["Min"].empty()) {
      min = make_shared<long>(boost::any_cast<long>(m["Min"]));
    }
    if (m.find("Step") != m.end() && !m["Step"].empty()) {
      step = make_shared<long>(boost::any_cast<long>(m["Step"]));
    }
  }


  virtual ~DescribeAvailableZoneResponseBodyDataAvailableZonesSupportSpecificationsDiskSizeRange() = default;
};
class DescribeAvailableZoneResponseBodyDataAvailableZonesSupportSpecificationsSupportEngineVersions : public Darabonba::Model {
public:
  shared_ptr<string> obVersion{};
  shared_ptr<bool> supportIsolationOptimization{};
  shared_ptr<vector<string>> supportReplicaModes{};

  DescribeAvailableZoneResponseBodyDataAvailableZonesSupportSpecificationsSupportEngineVersions() {}

  explicit DescribeAvailableZoneResponseBodyDataAvailableZonesSupportSpecificationsSupportEngineVersions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (obVersion) {
      res["ObVersion"] = boost::any(*obVersion);
    }
    if (supportIsolationOptimization) {
      res["SupportIsolationOptimization"] = boost::any(*supportIsolationOptimization);
    }
    if (supportReplicaModes) {
      res["SupportReplicaModes"] = boost::any(*supportReplicaModes);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ObVersion") != m.end() && !m["ObVersion"].empty()) {
      obVersion = make_shared<string>(boost::any_cast<string>(m["ObVersion"]));
    }
    if (m.find("SupportIsolationOptimization") != m.end() && !m["SupportIsolationOptimization"].empty()) {
      supportIsolationOptimization = make_shared<bool>(boost::any_cast<bool>(m["SupportIsolationOptimization"]));
    }
    if (m.find("SupportReplicaModes") != m.end() && !m["SupportReplicaModes"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SupportReplicaModes"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SupportReplicaModes"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      supportReplicaModes = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeAvailableZoneResponseBodyDataAvailableZonesSupportSpecificationsSupportEngineVersions() = default;
};
class DescribeAvailableZoneResponseBodyDataAvailableZonesSupportSpecifications : public Darabonba::Model {
public:
  shared_ptr<DescribeAvailableZoneResponseBodyDataAvailableZonesSupportSpecificationsDiskSizeRange> diskSizeRange{};
  shared_ptr<vector<string>> diskTypes{};
  shared_ptr<string> instanceClass{};
  shared_ptr<string> spec{};
  shared_ptr<vector<DescribeAvailableZoneResponseBodyDataAvailableZonesSupportSpecificationsSupportEngineVersions>> supportEngineVersions{};

  DescribeAvailableZoneResponseBodyDataAvailableZonesSupportSpecifications() {}

  explicit DescribeAvailableZoneResponseBodyDataAvailableZonesSupportSpecifications(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (diskSizeRange) {
      res["DiskSizeRange"] = diskSizeRange ? boost::any(diskSizeRange->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (diskTypes) {
      res["DiskTypes"] = boost::any(*diskTypes);
    }
    if (instanceClass) {
      res["InstanceClass"] = boost::any(*instanceClass);
    }
    if (spec) {
      res["Spec"] = boost::any(*spec);
    }
    if (supportEngineVersions) {
      vector<boost::any> temp1;
      for(auto item1:*supportEngineVersions){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SupportEngineVersions"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DiskSizeRange") != m.end() && !m["DiskSizeRange"].empty()) {
      if (typeid(map<string, boost::any>) == m["DiskSizeRange"].type()) {
        DescribeAvailableZoneResponseBodyDataAvailableZonesSupportSpecificationsDiskSizeRange model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DiskSizeRange"]));
        diskSizeRange = make_shared<DescribeAvailableZoneResponseBodyDataAvailableZonesSupportSpecificationsDiskSizeRange>(model1);
      }
    }
    if (m.find("DiskTypes") != m.end() && !m["DiskTypes"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DiskTypes"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DiskTypes"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      diskTypes = make_shared<vector<string>>(toVec1);
    }
    if (m.find("InstanceClass") != m.end() && !m["InstanceClass"].empty()) {
      instanceClass = make_shared<string>(boost::any_cast<string>(m["InstanceClass"]));
    }
    if (m.find("Spec") != m.end() && !m["Spec"].empty()) {
      spec = make_shared<string>(boost::any_cast<string>(m["Spec"]));
    }
    if (m.find("SupportEngineVersions") != m.end() && !m["SupportEngineVersions"].empty()) {
      if (typeid(vector<boost::any>) == m["SupportEngineVersions"].type()) {
        vector<DescribeAvailableZoneResponseBodyDataAvailableZonesSupportSpecificationsSupportEngineVersions> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SupportEngineVersions"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeAvailableZoneResponseBodyDataAvailableZonesSupportSpecificationsSupportEngineVersions model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        supportEngineVersions = make_shared<vector<DescribeAvailableZoneResponseBodyDataAvailableZonesSupportSpecificationsSupportEngineVersions>>(expect1);
      }
    }
  }


  virtual ~DescribeAvailableZoneResponseBodyDataAvailableZonesSupportSpecifications() = default;
};
class DescribeAvailableZoneResponseBodyDataAvailableZones : public Darabonba::Model {
public:
  shared_ptr<string> channel{};
  shared_ptr<string> deployType{};
  shared_ptr<string> instanceType{};
  shared_ptr<string> region{};
  shared_ptr<string> series{};
  shared_ptr<vector<DescribeAvailableZoneResponseBodyDataAvailableZonesSupportSpecifications>> supportSpecifications{};
  shared_ptr<string> zones{};

  DescribeAvailableZoneResponseBodyDataAvailableZones() {}

  explicit DescribeAvailableZoneResponseBodyDataAvailableZones(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (channel) {
      res["Channel"] = boost::any(*channel);
    }
    if (deployType) {
      res["DeployType"] = boost::any(*deployType);
    }
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (series) {
      res["Series"] = boost::any(*series);
    }
    if (supportSpecifications) {
      vector<boost::any> temp1;
      for(auto item1:*supportSpecifications){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SupportSpecifications"] = boost::any(temp1);
    }
    if (zones) {
      res["Zones"] = boost::any(*zones);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Channel") != m.end() && !m["Channel"].empty()) {
      channel = make_shared<string>(boost::any_cast<string>(m["Channel"]));
    }
    if (m.find("DeployType") != m.end() && !m["DeployType"].empty()) {
      deployType = make_shared<string>(boost::any_cast<string>(m["DeployType"]));
    }
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("Series") != m.end() && !m["Series"].empty()) {
      series = make_shared<string>(boost::any_cast<string>(m["Series"]));
    }
    if (m.find("SupportSpecifications") != m.end() && !m["SupportSpecifications"].empty()) {
      if (typeid(vector<boost::any>) == m["SupportSpecifications"].type()) {
        vector<DescribeAvailableZoneResponseBodyDataAvailableZonesSupportSpecifications> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SupportSpecifications"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeAvailableZoneResponseBodyDataAvailableZonesSupportSpecifications model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        supportSpecifications = make_shared<vector<DescribeAvailableZoneResponseBodyDataAvailableZonesSupportSpecifications>>(expect1);
      }
    }
    if (m.find("Zones") != m.end() && !m["Zones"].empty()) {
      zones = make_shared<string>(boost::any_cast<string>(m["Zones"]));
    }
  }


  virtual ~DescribeAvailableZoneResponseBodyDataAvailableZones() = default;
};
class DescribeAvailableZoneResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeAvailableZoneResponseBodyDataAvailableZones>> availableZones{};

  DescribeAvailableZoneResponseBodyData() {}

  explicit DescribeAvailableZoneResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (availableZones) {
      vector<boost::any> temp1;
      for(auto item1:*availableZones){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AvailableZones"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AvailableZones") != m.end() && !m["AvailableZones"].empty()) {
      if (typeid(vector<boost::any>) == m["AvailableZones"].type()) {
        vector<DescribeAvailableZoneResponseBodyDataAvailableZones> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AvailableZones"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeAvailableZoneResponseBodyDataAvailableZones model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        availableZones = make_shared<vector<DescribeAvailableZoneResponseBodyDataAvailableZones>>(expect1);
      }
    }
  }


  virtual ~DescribeAvailableZoneResponseBodyData() = default;
};
class DescribeAvailableZoneResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeAvailableZoneResponseBodyData> data{};
  shared_ptr<string> requestId{};

  DescribeAvailableZoneResponseBody() {}

  explicit DescribeAvailableZoneResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        DescribeAvailableZoneResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<DescribeAvailableZoneResponseBodyData>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeAvailableZoneResponseBody() = default;
};
class DescribeAvailableZoneResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeAvailableZoneResponseBody> body{};

  DescribeAvailableZoneResponse() {}

  explicit DescribeAvailableZoneResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeAvailableZoneResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeAvailableZoneResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeAvailableZoneResponse() = default;
};
class DescribeBackupSetDownloadLinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> downloadTaskId{};
  shared_ptr<string> instanceId{};

  DescribeBackupSetDownloadLinkRequest() {}

  explicit DescribeBackupSetDownloadLinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (downloadTaskId) {
      res["DownloadTaskId"] = boost::any(*downloadTaskId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DownloadTaskId") != m.end() && !m["DownloadTaskId"].empty()) {
      downloadTaskId = make_shared<string>(boost::any_cast<string>(m["DownloadTaskId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~DescribeBackupSetDownloadLinkRequest() = default;
};
class DescribeBackupSetDownloadLinkResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> backupRestorableTime{};
  shared_ptr<string> backupSetId{};
  shared_ptr<string> downloadTaskCreateTime{};
  shared_ptr<long> downloadTaskId{};
  shared_ptr<string> downloadTaskStatus{};
  shared_ptr<string> internalUrl{};
  shared_ptr<long> urlAliveTime{};
  shared_ptr<string> urlExpiredTime{};

  DescribeBackupSetDownloadLinkResponseBodyData() {}

  explicit DescribeBackupSetDownloadLinkResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (backupRestorableTime) {
      res["BackupRestorableTime"] = boost::any(*backupRestorableTime);
    }
    if (backupSetId) {
      res["BackupSetId"] = boost::any(*backupSetId);
    }
    if (downloadTaskCreateTime) {
      res["DownloadTaskCreateTime"] = boost::any(*downloadTaskCreateTime);
    }
    if (downloadTaskId) {
      res["DownloadTaskId"] = boost::any(*downloadTaskId);
    }
    if (downloadTaskStatus) {
      res["DownloadTaskStatus"] = boost::any(*downloadTaskStatus);
    }
    if (internalUrl) {
      res["InternalUrl"] = boost::any(*internalUrl);
    }
    if (urlAliveTime) {
      res["UrlAliveTime"] = boost::any(*urlAliveTime);
    }
    if (urlExpiredTime) {
      res["UrlExpiredTime"] = boost::any(*urlExpiredTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BackupRestorableTime") != m.end() && !m["BackupRestorableTime"].empty()) {
      backupRestorableTime = make_shared<string>(boost::any_cast<string>(m["BackupRestorableTime"]));
    }
    if (m.find("BackupSetId") != m.end() && !m["BackupSetId"].empty()) {
      backupSetId = make_shared<string>(boost::any_cast<string>(m["BackupSetId"]));
    }
    if (m.find("DownloadTaskCreateTime") != m.end() && !m["DownloadTaskCreateTime"].empty()) {
      downloadTaskCreateTime = make_shared<string>(boost::any_cast<string>(m["DownloadTaskCreateTime"]));
    }
    if (m.find("DownloadTaskId") != m.end() && !m["DownloadTaskId"].empty()) {
      downloadTaskId = make_shared<long>(boost::any_cast<long>(m["DownloadTaskId"]));
    }
    if (m.find("DownloadTaskStatus") != m.end() && !m["DownloadTaskStatus"].empty()) {
      downloadTaskStatus = make_shared<string>(boost::any_cast<string>(m["DownloadTaskStatus"]));
    }
    if (m.find("InternalUrl") != m.end() && !m["InternalUrl"].empty()) {
      internalUrl = make_shared<string>(boost::any_cast<string>(m["InternalUrl"]));
    }
    if (m.find("UrlAliveTime") != m.end() && !m["UrlAliveTime"].empty()) {
      urlAliveTime = make_shared<long>(boost::any_cast<long>(m["UrlAliveTime"]));
    }
    if (m.find("UrlExpiredTime") != m.end() && !m["UrlExpiredTime"].empty()) {
      urlExpiredTime = make_shared<string>(boost::any_cast<string>(m["UrlExpiredTime"]));
    }
  }


  virtual ~DescribeBackupSetDownloadLinkResponseBodyData() = default;
};
class DescribeBackupSetDownloadLinkResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeBackupSetDownloadLinkResponseBodyData> data{};
  shared_ptr<string> requestId{};

  DescribeBackupSetDownloadLinkResponseBody() {}

  explicit DescribeBackupSetDownloadLinkResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        DescribeBackupSetDownloadLinkResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<DescribeBackupSetDownloadLinkResponseBodyData>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeBackupSetDownloadLinkResponseBody() = default;
};
class DescribeBackupSetDownloadLinkResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeBackupSetDownloadLinkResponseBody> body{};

  DescribeBackupSetDownloadLinkResponse() {}

  explicit DescribeBackupSetDownloadLinkResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeBackupSetDownloadLinkResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeBackupSetDownloadLinkResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeBackupSetDownloadLinkResponse() = default;
};
class DescribeCharsetRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> series{};
  shared_ptr<string> tenantMode{};

  DescribeCharsetRequest() {}

  explicit DescribeCharsetRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (series) {
      res["Series"] = boost::any(*series);
    }
    if (tenantMode) {
      res["TenantMode"] = boost::any(*tenantMode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Series") != m.end() && !m["Series"].empty()) {
      series = make_shared<string>(boost::any_cast<string>(m["Series"]));
    }
    if (m.find("TenantMode") != m.end() && !m["TenantMode"].empty()) {
      tenantMode = make_shared<string>(boost::any_cast<string>(m["TenantMode"]));
    }
  }


  virtual ~DescribeCharsetRequest() = default;
};
class DescribeCharsetResponseBodyCharset : public Darabonba::Model {
public:
  shared_ptr<string> charset{};
  shared_ptr<vector<string>> collations{};

  DescribeCharsetResponseBodyCharset() {}

  explicit DescribeCharsetResponseBodyCharset(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (charset) {
      res["Charset"] = boost::any(*charset);
    }
    if (collations) {
      res["Collations"] = boost::any(*collations);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Charset") != m.end() && !m["Charset"].empty()) {
      charset = make_shared<string>(boost::any_cast<string>(m["Charset"]));
    }
    if (m.find("Collations") != m.end() && !m["Collations"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Collations"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Collations"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      collations = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeCharsetResponseBodyCharset() = default;
};
class DescribeCharsetResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeCharsetResponseBodyCharset>> charset{};
  shared_ptr<string> requestId{};

  DescribeCharsetResponseBody() {}

  explicit DescribeCharsetResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (charset) {
      vector<boost::any> temp1;
      for(auto item1:*charset){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Charset"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Charset") != m.end() && !m["Charset"].empty()) {
      if (typeid(vector<boost::any>) == m["Charset"].type()) {
        vector<DescribeCharsetResponseBodyCharset> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Charset"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeCharsetResponseBodyCharset model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        charset = make_shared<vector<DescribeCharsetResponseBodyCharset>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeCharsetResponseBody() = default;
};
class DescribeCharsetResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeCharsetResponseBody> body{};

  DescribeCharsetResponse() {}

  explicit DescribeCharsetResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeCharsetResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeCharsetResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeCharsetResponse() = default;
};
class DescribeDataBackupSetRequest : public Darabonba::Model {
public:
  shared_ptr<string> backupObjectType{};
  shared_ptr<string> endTime{};
  shared_ptr<string> instanceId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> startTime{};
  shared_ptr<string> status{};

  DescribeDataBackupSetRequest() {}

  explicit DescribeDataBackupSetRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (backupObjectType) {
      res["BackupObjectType"] = boost::any(*backupObjectType);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BackupObjectType") != m.end() && !m["BackupObjectType"].empty()) {
      backupObjectType = make_shared<string>(boost::any_cast<string>(m["BackupObjectType"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeDataBackupSetRequest() = default;
};
class DescribeDataBackupSetResponseBodyDataBackupObjectsDatabaseTablesList : public Darabonba::Model {
public:
  shared_ptr<string> database{};
  shared_ptr<vector<string>> tables{};

  DescribeDataBackupSetResponseBodyDataBackupObjectsDatabaseTablesList() {}

  explicit DescribeDataBackupSetResponseBodyDataBackupObjectsDatabaseTablesList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (database) {
      res["Database"] = boost::any(*database);
    }
    if (tables) {
      res["Tables"] = boost::any(*tables);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Database") != m.end() && !m["Database"].empty()) {
      database = make_shared<string>(boost::any_cast<string>(m["Database"]));
    }
    if (m.find("Tables") != m.end() && !m["Tables"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Tables"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Tables"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      tables = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeDataBackupSetResponseBodyDataBackupObjectsDatabaseTablesList() = default;
};
class DescribeDataBackupSetResponseBodyDataBackupObjects : public Darabonba::Model {
public:
  shared_ptr<string> clusterName{};
  shared_ptr<vector<DescribeDataBackupSetResponseBodyDataBackupObjectsDatabaseTablesList>> databaseTablesList{};
  shared_ptr<string> tenantName{};

  DescribeDataBackupSetResponseBodyDataBackupObjects() {}

  explicit DescribeDataBackupSetResponseBodyDataBackupObjects(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterName) {
      res["ClusterName"] = boost::any(*clusterName);
    }
    if (databaseTablesList) {
      vector<boost::any> temp1;
      for(auto item1:*databaseTablesList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DatabaseTablesList"] = boost::any(temp1);
    }
    if (tenantName) {
      res["TenantName"] = boost::any(*tenantName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterName") != m.end() && !m["ClusterName"].empty()) {
      clusterName = make_shared<string>(boost::any_cast<string>(m["ClusterName"]));
    }
    if (m.find("DatabaseTablesList") != m.end() && !m["DatabaseTablesList"].empty()) {
      if (typeid(vector<boost::any>) == m["DatabaseTablesList"].type()) {
        vector<DescribeDataBackupSetResponseBodyDataBackupObjectsDatabaseTablesList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DatabaseTablesList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDataBackupSetResponseBodyDataBackupObjectsDatabaseTablesList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        databaseTablesList = make_shared<vector<DescribeDataBackupSetResponseBodyDataBackupObjectsDatabaseTablesList>>(expect1);
      }
    }
    if (m.find("TenantName") != m.end() && !m["TenantName"].empty()) {
      tenantName = make_shared<string>(boost::any_cast<string>(m["TenantName"]));
    }
  }


  virtual ~DescribeDataBackupSetResponseBodyDataBackupObjects() = default;
};
class DescribeDataBackupSetResponseBodyDataBackupResultsTableBackupResults : public Darabonba::Model {
public:
  shared_ptr<string> database{};
  shared_ptr<string> message{};
  shared_ptr<string> status{};
  shared_ptr<string> table{};

  DescribeDataBackupSetResponseBodyDataBackupResultsTableBackupResults() {}

  explicit DescribeDataBackupSetResponseBodyDataBackupResultsTableBackupResults(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (database) {
      res["Database"] = boost::any(*database);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (table) {
      res["Table"] = boost::any(*table);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Database") != m.end() && !m["Database"].empty()) {
      database = make_shared<string>(boost::any_cast<string>(m["Database"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Table") != m.end() && !m["Table"].empty()) {
      table = make_shared<string>(boost::any_cast<string>(m["Table"]));
    }
  }


  virtual ~DescribeDataBackupSetResponseBodyDataBackupResultsTableBackupResults() = default;
};
class DescribeDataBackupSetResponseBodyDataBackupResults : public Darabonba::Model {
public:
  shared_ptr<string> clusterName{};
  shared_ptr<vector<DescribeDataBackupSetResponseBodyDataBackupResultsTableBackupResults>> tableBackupResults{};
  shared_ptr<string> tenantName{};

  DescribeDataBackupSetResponseBodyDataBackupResults() {}

  explicit DescribeDataBackupSetResponseBodyDataBackupResults(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterName) {
      res["ClusterName"] = boost::any(*clusterName);
    }
    if (tableBackupResults) {
      vector<boost::any> temp1;
      for(auto item1:*tableBackupResults){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TableBackupResults"] = boost::any(temp1);
    }
    if (tenantName) {
      res["TenantName"] = boost::any(*tenantName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterName") != m.end() && !m["ClusterName"].empty()) {
      clusterName = make_shared<string>(boost::any_cast<string>(m["ClusterName"]));
    }
    if (m.find("TableBackupResults") != m.end() && !m["TableBackupResults"].empty()) {
      if (typeid(vector<boost::any>) == m["TableBackupResults"].type()) {
        vector<DescribeDataBackupSetResponseBodyDataBackupResultsTableBackupResults> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TableBackupResults"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDataBackupSetResponseBodyDataBackupResultsTableBackupResults model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tableBackupResults = make_shared<vector<DescribeDataBackupSetResponseBodyDataBackupResultsTableBackupResults>>(expect1);
      }
    }
    if (m.find("TenantName") != m.end() && !m["TenantName"].empty()) {
      tenantName = make_shared<string>(boost::any_cast<string>(m["TenantName"]));
    }
  }


  virtual ~DescribeDataBackupSetResponseBodyDataBackupResults() = default;
};
class DescribeDataBackupSetResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> backupObjectType{};
  shared_ptr<vector<DescribeDataBackupSetResponseBodyDataBackupObjects>> backupObjects{};
  shared_ptr<vector<DescribeDataBackupSetResponseBodyDataBackupResults>> backupResults{};
  shared_ptr<string> checkpoint{};
  shared_ptr<long> dataSize{};
  shared_ptr<long> dataVersion{};
  shared_ptr<long> downloadTaskId{};
  shared_ptr<string> downloadTaskStatus{};
  shared_ptr<string> endTime{};
  shared_ptr<string> method{};
  shared_ptr<string> policy{};
  shared_ptr<string> progress{};
  shared_ptr<long> setId{};
  shared_ptr<string> startTime{};
  shared_ptr<string> status{};
  shared_ptr<string> storageClass{};
  shared_ptr<string> type{};
  shared_ptr<string> validity{};

  DescribeDataBackupSetResponseBodyData() {}

  explicit DescribeDataBackupSetResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (backupObjectType) {
      res["BackupObjectType"] = boost::any(*backupObjectType);
    }
    if (backupObjects) {
      vector<boost::any> temp1;
      for(auto item1:*backupObjects){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["BackupObjects"] = boost::any(temp1);
    }
    if (backupResults) {
      vector<boost::any> temp1;
      for(auto item1:*backupResults){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["BackupResults"] = boost::any(temp1);
    }
    if (checkpoint) {
      res["Checkpoint"] = boost::any(*checkpoint);
    }
    if (dataSize) {
      res["DataSize"] = boost::any(*dataSize);
    }
    if (dataVersion) {
      res["DataVersion"] = boost::any(*dataVersion);
    }
    if (downloadTaskId) {
      res["DownloadTaskId"] = boost::any(*downloadTaskId);
    }
    if (downloadTaskStatus) {
      res["DownloadTaskStatus"] = boost::any(*downloadTaskStatus);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (method) {
      res["Method"] = boost::any(*method);
    }
    if (policy) {
      res["Policy"] = boost::any(*policy);
    }
    if (progress) {
      res["Progress"] = boost::any(*progress);
    }
    if (setId) {
      res["SetId"] = boost::any(*setId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (storageClass) {
      res["StorageClass"] = boost::any(*storageClass);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (validity) {
      res["Validity"] = boost::any(*validity);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BackupObjectType") != m.end() && !m["BackupObjectType"].empty()) {
      backupObjectType = make_shared<string>(boost::any_cast<string>(m["BackupObjectType"]));
    }
    if (m.find("BackupObjects") != m.end() && !m["BackupObjects"].empty()) {
      if (typeid(vector<boost::any>) == m["BackupObjects"].type()) {
        vector<DescribeDataBackupSetResponseBodyDataBackupObjects> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["BackupObjects"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDataBackupSetResponseBodyDataBackupObjects model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        backupObjects = make_shared<vector<DescribeDataBackupSetResponseBodyDataBackupObjects>>(expect1);
      }
    }
    if (m.find("BackupResults") != m.end() && !m["BackupResults"].empty()) {
      if (typeid(vector<boost::any>) == m["BackupResults"].type()) {
        vector<DescribeDataBackupSetResponseBodyDataBackupResults> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["BackupResults"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDataBackupSetResponseBodyDataBackupResults model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        backupResults = make_shared<vector<DescribeDataBackupSetResponseBodyDataBackupResults>>(expect1);
      }
    }
    if (m.find("Checkpoint") != m.end() && !m["Checkpoint"].empty()) {
      checkpoint = make_shared<string>(boost::any_cast<string>(m["Checkpoint"]));
    }
    if (m.find("DataSize") != m.end() && !m["DataSize"].empty()) {
      dataSize = make_shared<long>(boost::any_cast<long>(m["DataSize"]));
    }
    if (m.find("DataVersion") != m.end() && !m["DataVersion"].empty()) {
      dataVersion = make_shared<long>(boost::any_cast<long>(m["DataVersion"]));
    }
    if (m.find("DownloadTaskId") != m.end() && !m["DownloadTaskId"].empty()) {
      downloadTaskId = make_shared<long>(boost::any_cast<long>(m["DownloadTaskId"]));
    }
    if (m.find("DownloadTaskStatus") != m.end() && !m["DownloadTaskStatus"].empty()) {
      downloadTaskStatus = make_shared<string>(boost::any_cast<string>(m["DownloadTaskStatus"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("Method") != m.end() && !m["Method"].empty()) {
      method = make_shared<string>(boost::any_cast<string>(m["Method"]));
    }
    if (m.find("Policy") != m.end() && !m["Policy"].empty()) {
      policy = make_shared<string>(boost::any_cast<string>(m["Policy"]));
    }
    if (m.find("Progress") != m.end() && !m["Progress"].empty()) {
      progress = make_shared<string>(boost::any_cast<string>(m["Progress"]));
    }
    if (m.find("SetId") != m.end() && !m["SetId"].empty()) {
      setId = make_shared<long>(boost::any_cast<long>(m["SetId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("StorageClass") != m.end() && !m["StorageClass"].empty()) {
      storageClass = make_shared<string>(boost::any_cast<string>(m["StorageClass"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Validity") != m.end() && !m["Validity"].empty()) {
      validity = make_shared<string>(boost::any_cast<string>(m["Validity"]));
    }
  }


  virtual ~DescribeDataBackupSetResponseBodyData() = default;
};
class DescribeDataBackupSetResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDataBackupSetResponseBodyData>> data{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeDataBackupSetResponseBody() {}

  explicit DescribeDataBackupSetResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<DescribeDataBackupSetResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDataBackupSetResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<DescribeDataBackupSetResponseBodyData>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeDataBackupSetResponseBody() = default;
};
class DescribeDataBackupSetResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDataBackupSetResponseBody> body{};

  DescribeDataBackupSetResponse() {}

  explicit DescribeDataBackupSetResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDataBackupSetResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDataBackupSetResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDataBackupSetResponse() = default;
};
class DescribeDatabasesRequest : public Darabonba::Model {
public:
  shared_ptr<string> databaseName{};
  shared_ptr<string> instanceId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> searchKey{};
  shared_ptr<string> tenantId{};
  shared_ptr<bool> withTables{};

  DescribeDatabasesRequest() {}

  explicit DescribeDatabasesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (databaseName) {
      res["DatabaseName"] = boost::any(*databaseName);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (searchKey) {
      res["SearchKey"] = boost::any(*searchKey);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    if (withTables) {
      res["WithTables"] = boost::any(*withTables);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DatabaseName") != m.end() && !m["DatabaseName"].empty()) {
      databaseName = make_shared<string>(boost::any_cast<string>(m["DatabaseName"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SearchKey") != m.end() && !m["SearchKey"].empty()) {
      searchKey = make_shared<string>(boost::any_cast<string>(m["SearchKey"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["TenantId"]));
    }
    if (m.find("WithTables") != m.end() && !m["WithTables"].empty()) {
      withTables = make_shared<bool>(boost::any_cast<bool>(m["WithTables"]));
    }
  }


  virtual ~DescribeDatabasesRequest() = default;
};
class DescribeDatabasesResponseBodyDatabasesTables : public Darabonba::Model {
public:
  shared_ptr<string> tableName{};

  DescribeDatabasesResponseBodyDatabasesTables() {}

  explicit DescribeDatabasesResponseBodyDatabasesTables(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tableName) {
      res["TableName"] = boost::any(*tableName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TableName") != m.end() && !m["TableName"].empty()) {
      tableName = make_shared<string>(boost::any_cast<string>(m["TableName"]));
    }
  }


  virtual ~DescribeDatabasesResponseBodyDatabasesTables() = default;
};
class DescribeDatabasesResponseBodyDatabasesUsers : public Darabonba::Model {
public:
  shared_ptr<string> privileges{};
  shared_ptr<string> role{};
  shared_ptr<string> userName{};
  shared_ptr<string> userType{};

  DescribeDatabasesResponseBodyDatabasesUsers() {}

  explicit DescribeDatabasesResponseBodyDatabasesUsers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (privileges) {
      res["Privileges"] = boost::any(*privileges);
    }
    if (role) {
      res["Role"] = boost::any(*role);
    }
    if (userName) {
      res["UserName"] = boost::any(*userName);
    }
    if (userType) {
      res["UserType"] = boost::any(*userType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Privileges") != m.end() && !m["Privileges"].empty()) {
      privileges = make_shared<string>(boost::any_cast<string>(m["Privileges"]));
    }
    if (m.find("Role") != m.end() && !m["Role"].empty()) {
      role = make_shared<string>(boost::any_cast<string>(m["Role"]));
    }
    if (m.find("UserName") != m.end() && !m["UserName"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["UserName"]));
    }
    if (m.find("UserType") != m.end() && !m["UserType"].empty()) {
      userType = make_shared<string>(boost::any_cast<string>(m["UserType"]));
    }
  }


  virtual ~DescribeDatabasesResponseBodyDatabasesUsers() = default;
};
class DescribeDatabasesResponseBodyDatabases : public Darabonba::Model {
public:
  shared_ptr<string> collation{};
  shared_ptr<string> createTime{};
  shared_ptr<double> dataSize{};
  shared_ptr<string> databaseName{};
  shared_ptr<string> dbType{};
  shared_ptr<string> description{};
  shared_ptr<string> encoding{};
  shared_ptr<string> instanceId{};
  shared_ptr<double> requiredSize{};
  shared_ptr<string> status{};
  shared_ptr<vector<DescribeDatabasesResponseBodyDatabasesTables>> tables{};
  shared_ptr<string> tenantId{};
  shared_ptr<string> tenantName{};
  shared_ptr<vector<DescribeDatabasesResponseBodyDatabasesUsers>> users{};

  DescribeDatabasesResponseBodyDatabases() {}

  explicit DescribeDatabasesResponseBodyDatabases(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (collation) {
      res["Collation"] = boost::any(*collation);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (dataSize) {
      res["DataSize"] = boost::any(*dataSize);
    }
    if (databaseName) {
      res["DatabaseName"] = boost::any(*databaseName);
    }
    if (dbType) {
      res["DbType"] = boost::any(*dbType);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (encoding) {
      res["Encoding"] = boost::any(*encoding);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (requiredSize) {
      res["RequiredSize"] = boost::any(*requiredSize);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (tables) {
      vector<boost::any> temp1;
      for(auto item1:*tables){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tables"] = boost::any(temp1);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    if (tenantName) {
      res["TenantName"] = boost::any(*tenantName);
    }
    if (users) {
      vector<boost::any> temp1;
      for(auto item1:*users){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Users"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Collation") != m.end() && !m["Collation"].empty()) {
      collation = make_shared<string>(boost::any_cast<string>(m["Collation"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("DataSize") != m.end() && !m["DataSize"].empty()) {
      dataSize = make_shared<double>(boost::any_cast<double>(m["DataSize"]));
    }
    if (m.find("DatabaseName") != m.end() && !m["DatabaseName"].empty()) {
      databaseName = make_shared<string>(boost::any_cast<string>(m["DatabaseName"]));
    }
    if (m.find("DbType") != m.end() && !m["DbType"].empty()) {
      dbType = make_shared<string>(boost::any_cast<string>(m["DbType"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Encoding") != m.end() && !m["Encoding"].empty()) {
      encoding = make_shared<string>(boost::any_cast<string>(m["Encoding"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RequiredSize") != m.end() && !m["RequiredSize"].empty()) {
      requiredSize = make_shared<double>(boost::any_cast<double>(m["RequiredSize"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Tables") != m.end() && !m["Tables"].empty()) {
      if (typeid(vector<boost::any>) == m["Tables"].type()) {
        vector<DescribeDatabasesResponseBodyDatabasesTables> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tables"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDatabasesResponseBodyDatabasesTables model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tables = make_shared<vector<DescribeDatabasesResponseBodyDatabasesTables>>(expect1);
      }
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["TenantId"]));
    }
    if (m.find("TenantName") != m.end() && !m["TenantName"].empty()) {
      tenantName = make_shared<string>(boost::any_cast<string>(m["TenantName"]));
    }
    if (m.find("Users") != m.end() && !m["Users"].empty()) {
      if (typeid(vector<boost::any>) == m["Users"].type()) {
        vector<DescribeDatabasesResponseBodyDatabasesUsers> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Users"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDatabasesResponseBodyDatabasesUsers model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        users = make_shared<vector<DescribeDatabasesResponseBodyDatabasesUsers>>(expect1);
      }
    }
  }


  virtual ~DescribeDatabasesResponseBodyDatabases() = default;
};
class DescribeDatabasesResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDatabasesResponseBodyDatabases>> databases{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeDatabasesResponseBody() {}

  explicit DescribeDatabasesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (databases) {
      vector<boost::any> temp1;
      for(auto item1:*databases){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Databases"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Databases") != m.end() && !m["Databases"].empty()) {
      if (typeid(vector<boost::any>) == m["Databases"].type()) {
        vector<DescribeDatabasesResponseBodyDatabases> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Databases"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDatabasesResponseBodyDatabases model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        databases = make_shared<vector<DescribeDatabasesResponseBodyDatabases>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeDatabasesResponseBody() = default;
};
class DescribeDatabasesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDatabasesResponseBody> body{};

  DescribeDatabasesResponse() {}

  explicit DescribeDatabasesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDatabasesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDatabasesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDatabasesResponse() = default;
};
class DescribeInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<long> pageNumber{};

  DescribeInstanceRequest() {}

  explicit DescribeInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
  }


  virtual ~DescribeInstanceRequest() = default;
};
class DescribeInstanceResponseBodyInstanceDataDiskAutoScaleConfig : public Darabonba::Model {
public:
  shared_ptr<bool> autoScale{};
  shared_ptr<long> maxDiskSize{};
  shared_ptr<long> scaleStepInMerge{};
  shared_ptr<long> scaleStepInNormal{};
  shared_ptr<long> upperMergeThreshold{};
  shared_ptr<string> upperScaleStep{};
  shared_ptr<string> upperScaleStrategy{};
  shared_ptr<long> upperThreshold{};
  shared_ptr<long> upperbound{};

  DescribeInstanceResponseBodyInstanceDataDiskAutoScaleConfig() {}

  explicit DescribeInstanceResponseBodyInstanceDataDiskAutoScaleConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (autoScale) {
      res["AutoScale"] = boost::any(*autoScale);
    }
    if (maxDiskSize) {
      res["MaxDiskSize"] = boost::any(*maxDiskSize);
    }
    if (scaleStepInMerge) {
      res["ScaleStepInMerge"] = boost::any(*scaleStepInMerge);
    }
    if (scaleStepInNormal) {
      res["ScaleStepInNormal"] = boost::any(*scaleStepInNormal);
    }
    if (upperMergeThreshold) {
      res["UpperMergeThreshold"] = boost::any(*upperMergeThreshold);
    }
    if (upperScaleStep) {
      res["UpperScaleStep"] = boost::any(*upperScaleStep);
    }
    if (upperScaleStrategy) {
      res["UpperScaleStrategy"] = boost::any(*upperScaleStrategy);
    }
    if (upperThreshold) {
      res["UpperThreshold"] = boost::any(*upperThreshold);
    }
    if (upperbound) {
      res["Upperbound"] = boost::any(*upperbound);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AutoScale") != m.end() && !m["AutoScale"].empty()) {
      autoScale = make_shared<bool>(boost::any_cast<bool>(m["AutoScale"]));
    }
    if (m.find("MaxDiskSize") != m.end() && !m["MaxDiskSize"].empty()) {
      maxDiskSize = make_shared<long>(boost::any_cast<long>(m["MaxDiskSize"]));
    }
    if (m.find("ScaleStepInMerge") != m.end() && !m["ScaleStepInMerge"].empty()) {
      scaleStepInMerge = make_shared<long>(boost::any_cast<long>(m["ScaleStepInMerge"]));
    }
    if (m.find("ScaleStepInNormal") != m.end() && !m["ScaleStepInNormal"].empty()) {
      scaleStepInNormal = make_shared<long>(boost::any_cast<long>(m["ScaleStepInNormal"]));
    }
    if (m.find("UpperMergeThreshold") != m.end() && !m["UpperMergeThreshold"].empty()) {
      upperMergeThreshold = make_shared<long>(boost::any_cast<long>(m["UpperMergeThreshold"]));
    }
    if (m.find("UpperScaleStep") != m.end() && !m["UpperScaleStep"].empty()) {
      upperScaleStep = make_shared<string>(boost::any_cast<string>(m["UpperScaleStep"]));
    }
    if (m.find("UpperScaleStrategy") != m.end() && !m["UpperScaleStrategy"].empty()) {
      upperScaleStrategy = make_shared<string>(boost::any_cast<string>(m["UpperScaleStrategy"]));
    }
    if (m.find("UpperThreshold") != m.end() && !m["UpperThreshold"].empty()) {
      upperThreshold = make_shared<long>(boost::any_cast<long>(m["UpperThreshold"]));
    }
    if (m.find("Upperbound") != m.end() && !m["Upperbound"].empty()) {
      upperbound = make_shared<long>(boost::any_cast<long>(m["Upperbound"]));
    }
  }


  virtual ~DescribeInstanceResponseBodyInstanceDataDiskAutoScaleConfig() = default;
};
class DescribeInstanceResponseBodyInstanceReadOnlyResourceCapacityUnit : public Darabonba::Model {
public:
  shared_ptr<long> maxCapacityUnit{};
  shared_ptr<long> minCapacityUnit{};
  shared_ptr<string> usedCapacityUnit{};

  DescribeInstanceResponseBodyInstanceReadOnlyResourceCapacityUnit() {}

  explicit DescribeInstanceResponseBodyInstanceReadOnlyResourceCapacityUnit(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (maxCapacityUnit) {
      res["MaxCapacityUnit"] = boost::any(*maxCapacityUnit);
    }
    if (minCapacityUnit) {
      res["MinCapacityUnit"] = boost::any(*minCapacityUnit);
    }
    if (usedCapacityUnit) {
      res["UsedCapacityUnit"] = boost::any(*usedCapacityUnit);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MaxCapacityUnit") != m.end() && !m["MaxCapacityUnit"].empty()) {
      maxCapacityUnit = make_shared<long>(boost::any_cast<long>(m["MaxCapacityUnit"]));
    }
    if (m.find("MinCapacityUnit") != m.end() && !m["MinCapacityUnit"].empty()) {
      minCapacityUnit = make_shared<long>(boost::any_cast<long>(m["MinCapacityUnit"]));
    }
    if (m.find("UsedCapacityUnit") != m.end() && !m["UsedCapacityUnit"].empty()) {
      usedCapacityUnit = make_shared<string>(boost::any_cast<string>(m["UsedCapacityUnit"]));
    }
  }


  virtual ~DescribeInstanceResponseBodyInstanceReadOnlyResourceCapacityUnit() = default;
};
class DescribeInstanceResponseBodyInstanceReadOnlyResourceCpu : public Darabonba::Model {
public:
  shared_ptr<long> originalTotalCpu{};
  shared_ptr<long> totalCpu{};
  shared_ptr<long> unitCpu{};
  shared_ptr<long> usedCpu{};

  DescribeInstanceResponseBodyInstanceReadOnlyResourceCpu() {}

  explicit DescribeInstanceResponseBodyInstanceReadOnlyResourceCpu(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (originalTotalCpu) {
      res["OriginalTotalCpu"] = boost::any(*originalTotalCpu);
    }
    if (totalCpu) {
      res["TotalCpu"] = boost::any(*totalCpu);
    }
    if (unitCpu) {
      res["UnitCpu"] = boost::any(*unitCpu);
    }
    if (usedCpu) {
      res["UsedCpu"] = boost::any(*usedCpu);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OriginalTotalCpu") != m.end() && !m["OriginalTotalCpu"].empty()) {
      originalTotalCpu = make_shared<long>(boost::any_cast<long>(m["OriginalTotalCpu"]));
    }
    if (m.find("TotalCpu") != m.end() && !m["TotalCpu"].empty()) {
      totalCpu = make_shared<long>(boost::any_cast<long>(m["TotalCpu"]));
    }
    if (m.find("UnitCpu") != m.end() && !m["UnitCpu"].empty()) {
      unitCpu = make_shared<long>(boost::any_cast<long>(m["UnitCpu"]));
    }
    if (m.find("UsedCpu") != m.end() && !m["UsedCpu"].empty()) {
      usedCpu = make_shared<long>(boost::any_cast<long>(m["UsedCpu"]));
    }
  }


  virtual ~DescribeInstanceResponseBodyInstanceReadOnlyResourceCpu() = default;
};
class DescribeInstanceResponseBodyInstanceReadOnlyResourceDiskSize : public Darabonba::Model {
public:
  shared_ptr<double> dataUsedSize{};
  shared_ptr<double> maxDiskSize{};
  shared_ptr<vector<string>> maxDiskUsedObServer{};
  shared_ptr<double> maxDiskUsedPercent{};
  shared_ptr<long> originalTotalDiskSize{};
  shared_ptr<long> totalDiskSize{};
  shared_ptr<long> unitDiskSize{};
  shared_ptr<long> usedDiskSize{};

  DescribeInstanceResponseBodyInstanceReadOnlyResourceDiskSize() {}

  explicit DescribeInstanceResponseBodyInstanceReadOnlyResourceDiskSize(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataUsedSize) {
      res["DataUsedSize"] = boost::any(*dataUsedSize);
    }
    if (maxDiskSize) {
      res["MaxDiskSize"] = boost::any(*maxDiskSize);
    }
    if (maxDiskUsedObServer) {
      res["MaxDiskUsedObServer"] = boost::any(*maxDiskUsedObServer);
    }
    if (maxDiskUsedPercent) {
      res["MaxDiskUsedPercent"] = boost::any(*maxDiskUsedPercent);
    }
    if (originalTotalDiskSize) {
      res["OriginalTotalDiskSize"] = boost::any(*originalTotalDiskSize);
    }
    if (totalDiskSize) {
      res["TotalDiskSize"] = boost::any(*totalDiskSize);
    }
    if (unitDiskSize) {
      res["UnitDiskSize"] = boost::any(*unitDiskSize);
    }
    if (usedDiskSize) {
      res["UsedDiskSize"] = boost::any(*usedDiskSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataUsedSize") != m.end() && !m["DataUsedSize"].empty()) {
      dataUsedSize = make_shared<double>(boost::any_cast<double>(m["DataUsedSize"]));
    }
    if (m.find("MaxDiskSize") != m.end() && !m["MaxDiskSize"].empty()) {
      maxDiskSize = make_shared<double>(boost::any_cast<double>(m["MaxDiskSize"]));
    }
    if (m.find("MaxDiskUsedObServer") != m.end() && !m["MaxDiskUsedObServer"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["MaxDiskUsedObServer"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["MaxDiskUsedObServer"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      maxDiskUsedObServer = make_shared<vector<string>>(toVec1);
    }
    if (m.find("MaxDiskUsedPercent") != m.end() && !m["MaxDiskUsedPercent"].empty()) {
      maxDiskUsedPercent = make_shared<double>(boost::any_cast<double>(m["MaxDiskUsedPercent"]));
    }
    if (m.find("OriginalTotalDiskSize") != m.end() && !m["OriginalTotalDiskSize"].empty()) {
      originalTotalDiskSize = make_shared<long>(boost::any_cast<long>(m["OriginalTotalDiskSize"]));
    }
    if (m.find("TotalDiskSize") != m.end() && !m["TotalDiskSize"].empty()) {
      totalDiskSize = make_shared<long>(boost::any_cast<long>(m["TotalDiskSize"]));
    }
    if (m.find("UnitDiskSize") != m.end() && !m["UnitDiskSize"].empty()) {
      unitDiskSize = make_shared<long>(boost::any_cast<long>(m["UnitDiskSize"]));
    }
    if (m.find("UsedDiskSize") != m.end() && !m["UsedDiskSize"].empty()) {
      usedDiskSize = make_shared<long>(boost::any_cast<long>(m["UsedDiskSize"]));
    }
  }


  virtual ~DescribeInstanceResponseBodyInstanceReadOnlyResourceDiskSize() = default;
};
class DescribeInstanceResponseBodyInstanceReadOnlyResourceLogDiskSize : public Darabonba::Model {
public:
  shared_ptr<string> logAssignedSize{};
  shared_ptr<vector<string>> maxLogAssignedObServer{};
  shared_ptr<string> maxLogAssignedPercent{};
  shared_ptr<long> totalDiskSize{};
  shared_ptr<long> unitDiskSize{};

  DescribeInstanceResponseBodyInstanceReadOnlyResourceLogDiskSize() {}

  explicit DescribeInstanceResponseBodyInstanceReadOnlyResourceLogDiskSize(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (logAssignedSize) {
      res["LogAssignedSize"] = boost::any(*logAssignedSize);
    }
    if (maxLogAssignedObServer) {
      res["MaxLogAssignedObServer"] = boost::any(*maxLogAssignedObServer);
    }
    if (maxLogAssignedPercent) {
      res["MaxLogAssignedPercent"] = boost::any(*maxLogAssignedPercent);
    }
    if (totalDiskSize) {
      res["TotalDiskSize"] = boost::any(*totalDiskSize);
    }
    if (unitDiskSize) {
      res["UnitDiskSize"] = boost::any(*unitDiskSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LogAssignedSize") != m.end() && !m["LogAssignedSize"].empty()) {
      logAssignedSize = make_shared<string>(boost::any_cast<string>(m["LogAssignedSize"]));
    }
    if (m.find("MaxLogAssignedObServer") != m.end() && !m["MaxLogAssignedObServer"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["MaxLogAssignedObServer"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["MaxLogAssignedObServer"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      maxLogAssignedObServer = make_shared<vector<string>>(toVec1);
    }
    if (m.find("MaxLogAssignedPercent") != m.end() && !m["MaxLogAssignedPercent"].empty()) {
      maxLogAssignedPercent = make_shared<string>(boost::any_cast<string>(m["MaxLogAssignedPercent"]));
    }
    if (m.find("TotalDiskSize") != m.end() && !m["TotalDiskSize"].empty()) {
      totalDiskSize = make_shared<long>(boost::any_cast<long>(m["TotalDiskSize"]));
    }
    if (m.find("UnitDiskSize") != m.end() && !m["UnitDiskSize"].empty()) {
      unitDiskSize = make_shared<long>(boost::any_cast<long>(m["UnitDiskSize"]));
    }
  }


  virtual ~DescribeInstanceResponseBodyInstanceReadOnlyResourceLogDiskSize() = default;
};
class DescribeInstanceResponseBodyInstanceReadOnlyResourceMemory : public Darabonba::Model {
public:
  shared_ptr<long> originalTotalMemory{};
  shared_ptr<long> totalMemory{};
  shared_ptr<long> unitMemory{};
  shared_ptr<long> usedMemory{};

  DescribeInstanceResponseBodyInstanceReadOnlyResourceMemory() {}

  explicit DescribeInstanceResponseBodyInstanceReadOnlyResourceMemory(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (originalTotalMemory) {
      res["OriginalTotalMemory"] = boost::any(*originalTotalMemory);
    }
    if (totalMemory) {
      res["TotalMemory"] = boost::any(*totalMemory);
    }
    if (unitMemory) {
      res["UnitMemory"] = boost::any(*unitMemory);
    }
    if (usedMemory) {
      res["UsedMemory"] = boost::any(*usedMemory);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OriginalTotalMemory") != m.end() && !m["OriginalTotalMemory"].empty()) {
      originalTotalMemory = make_shared<long>(boost::any_cast<long>(m["OriginalTotalMemory"]));
    }
    if (m.find("TotalMemory") != m.end() && !m["TotalMemory"].empty()) {
      totalMemory = make_shared<long>(boost::any_cast<long>(m["TotalMemory"]));
    }
    if (m.find("UnitMemory") != m.end() && !m["UnitMemory"].empty()) {
      unitMemory = make_shared<long>(boost::any_cast<long>(m["UnitMemory"]));
    }
    if (m.find("UsedMemory") != m.end() && !m["UsedMemory"].empty()) {
      usedMemory = make_shared<long>(boost::any_cast<long>(m["UsedMemory"]));
    }
  }


  virtual ~DescribeInstanceResponseBodyInstanceReadOnlyResourceMemory() = default;
};
class DescribeInstanceResponseBodyInstanceReadOnlyResource : public Darabonba::Model {
public:
  shared_ptr<DescribeInstanceResponseBodyInstanceReadOnlyResourceCapacityUnit> capacityUnit{};
  shared_ptr<DescribeInstanceResponseBodyInstanceReadOnlyResourceCpu> cpu{};
  shared_ptr<DescribeInstanceResponseBodyInstanceReadOnlyResourceDiskSize> diskSize{};
  shared_ptr<DescribeInstanceResponseBodyInstanceReadOnlyResourceLogDiskSize> logDiskSize{};
  shared_ptr<DescribeInstanceResponseBodyInstanceReadOnlyResourceMemory> memory{};
  shared_ptr<long> unitCount{};

  DescribeInstanceResponseBodyInstanceReadOnlyResource() {}

  explicit DescribeInstanceResponseBodyInstanceReadOnlyResource(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (capacityUnit) {
      res["CapacityUnit"] = capacityUnit ? boost::any(capacityUnit->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (cpu) {
      res["Cpu"] = cpu ? boost::any(cpu->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (diskSize) {
      res["DiskSize"] = diskSize ? boost::any(diskSize->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (logDiskSize) {
      res["LogDiskSize"] = logDiskSize ? boost::any(logDiskSize->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (memory) {
      res["Memory"] = memory ? boost::any(memory->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (unitCount) {
      res["UnitCount"] = boost::any(*unitCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CapacityUnit") != m.end() && !m["CapacityUnit"].empty()) {
      if (typeid(map<string, boost::any>) == m["CapacityUnit"].type()) {
        DescribeInstanceResponseBodyInstanceReadOnlyResourceCapacityUnit model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CapacityUnit"]));
        capacityUnit = make_shared<DescribeInstanceResponseBodyInstanceReadOnlyResourceCapacityUnit>(model1);
      }
    }
    if (m.find("Cpu") != m.end() && !m["Cpu"].empty()) {
      if (typeid(map<string, boost::any>) == m["Cpu"].type()) {
        DescribeInstanceResponseBodyInstanceReadOnlyResourceCpu model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Cpu"]));
        cpu = make_shared<DescribeInstanceResponseBodyInstanceReadOnlyResourceCpu>(model1);
      }
    }
    if (m.find("DiskSize") != m.end() && !m["DiskSize"].empty()) {
      if (typeid(map<string, boost::any>) == m["DiskSize"].type()) {
        DescribeInstanceResponseBodyInstanceReadOnlyResourceDiskSize model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DiskSize"]));
        diskSize = make_shared<DescribeInstanceResponseBodyInstanceReadOnlyResourceDiskSize>(model1);
      }
    }
    if (m.find("LogDiskSize") != m.end() && !m["LogDiskSize"].empty()) {
      if (typeid(map<string, boost::any>) == m["LogDiskSize"].type()) {
        DescribeInstanceResponseBodyInstanceReadOnlyResourceLogDiskSize model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LogDiskSize"]));
        logDiskSize = make_shared<DescribeInstanceResponseBodyInstanceReadOnlyResourceLogDiskSize>(model1);
      }
    }
    if (m.find("Memory") != m.end() && !m["Memory"].empty()) {
      if (typeid(map<string, boost::any>) == m["Memory"].type()) {
        DescribeInstanceResponseBodyInstanceReadOnlyResourceMemory model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Memory"]));
        memory = make_shared<DescribeInstanceResponseBodyInstanceReadOnlyResourceMemory>(model1);
      }
    }
    if (m.find("UnitCount") != m.end() && !m["UnitCount"].empty()) {
      unitCount = make_shared<long>(boost::any_cast<long>(m["UnitCount"]));
    }
  }


  virtual ~DescribeInstanceResponseBodyInstanceReadOnlyResource() = default;
};
class DescribeInstanceResponseBodyInstanceResourceCapacityUnit : public Darabonba::Model {
public:
  shared_ptr<long> maxCapacityUnit{};
  shared_ptr<long> minCapacityUnit{};
  shared_ptr<string> usedCapacityUnit{};

  DescribeInstanceResponseBodyInstanceResourceCapacityUnit() {}

  explicit DescribeInstanceResponseBodyInstanceResourceCapacityUnit(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (maxCapacityUnit) {
      res["MaxCapacityUnit"] = boost::any(*maxCapacityUnit);
    }
    if (minCapacityUnit) {
      res["MinCapacityUnit"] = boost::any(*minCapacityUnit);
    }
    if (usedCapacityUnit) {
      res["UsedCapacityUnit"] = boost::any(*usedCapacityUnit);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MaxCapacityUnit") != m.end() && !m["MaxCapacityUnit"].empty()) {
      maxCapacityUnit = make_shared<long>(boost::any_cast<long>(m["MaxCapacityUnit"]));
    }
    if (m.find("MinCapacityUnit") != m.end() && !m["MinCapacityUnit"].empty()) {
      minCapacityUnit = make_shared<long>(boost::any_cast<long>(m["MinCapacityUnit"]));
    }
    if (m.find("UsedCapacityUnit") != m.end() && !m["UsedCapacityUnit"].empty()) {
      usedCapacityUnit = make_shared<string>(boost::any_cast<string>(m["UsedCapacityUnit"]));
    }
  }


  virtual ~DescribeInstanceResponseBodyInstanceResourceCapacityUnit() = default;
};
class DescribeInstanceResponseBodyInstanceResourceCpu : public Darabonba::Model {
public:
  shared_ptr<long> originalTotalCpu{};
  shared_ptr<long> totalCpu{};
  shared_ptr<long> unitCpu{};
  shared_ptr<long> usedCpu{};

  DescribeInstanceResponseBodyInstanceResourceCpu() {}

  explicit DescribeInstanceResponseBodyInstanceResourceCpu(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (originalTotalCpu) {
      res["OriginalTotalCpu"] = boost::any(*originalTotalCpu);
    }
    if (totalCpu) {
      res["TotalCpu"] = boost::any(*totalCpu);
    }
    if (unitCpu) {
      res["UnitCpu"] = boost::any(*unitCpu);
    }
    if (usedCpu) {
      res["UsedCpu"] = boost::any(*usedCpu);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OriginalTotalCpu") != m.end() && !m["OriginalTotalCpu"].empty()) {
      originalTotalCpu = make_shared<long>(boost::any_cast<long>(m["OriginalTotalCpu"]));
    }
    if (m.find("TotalCpu") != m.end() && !m["TotalCpu"].empty()) {
      totalCpu = make_shared<long>(boost::any_cast<long>(m["TotalCpu"]));
    }
    if (m.find("UnitCpu") != m.end() && !m["UnitCpu"].empty()) {
      unitCpu = make_shared<long>(boost::any_cast<long>(m["UnitCpu"]));
    }
    if (m.find("UsedCpu") != m.end() && !m["UsedCpu"].empty()) {
      usedCpu = make_shared<long>(boost::any_cast<long>(m["UsedCpu"]));
    }
  }


  virtual ~DescribeInstanceResponseBodyInstanceResourceCpu() = default;
};
class DescribeInstanceResponseBodyInstanceResourceDiskSize : public Darabonba::Model {
public:
  shared_ptr<double> dataUsedSize{};
  shared_ptr<double> maxDiskSize{};
  shared_ptr<vector<string>> maxDiskUsedObServer{};
  shared_ptr<double> maxDiskUsedPercent{};
  shared_ptr<long> originalTotalDiskSize{};
  shared_ptr<long> totalDiskSize{};
  shared_ptr<long> unitDiskSize{};
  shared_ptr<long> usedDiskSize{};

  DescribeInstanceResponseBodyInstanceResourceDiskSize() {}

  explicit DescribeInstanceResponseBodyInstanceResourceDiskSize(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataUsedSize) {
      res["DataUsedSize"] = boost::any(*dataUsedSize);
    }
    if (maxDiskSize) {
      res["MaxDiskSize"] = boost::any(*maxDiskSize);
    }
    if (maxDiskUsedObServer) {
      res["MaxDiskUsedObServer"] = boost::any(*maxDiskUsedObServer);
    }
    if (maxDiskUsedPercent) {
      res["MaxDiskUsedPercent"] = boost::any(*maxDiskUsedPercent);
    }
    if (originalTotalDiskSize) {
      res["OriginalTotalDiskSize"] = boost::any(*originalTotalDiskSize);
    }
    if (totalDiskSize) {
      res["TotalDiskSize"] = boost::any(*totalDiskSize);
    }
    if (unitDiskSize) {
      res["UnitDiskSize"] = boost::any(*unitDiskSize);
    }
    if (usedDiskSize) {
      res["UsedDiskSize"] = boost::any(*usedDiskSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataUsedSize") != m.end() && !m["DataUsedSize"].empty()) {
      dataUsedSize = make_shared<double>(boost::any_cast<double>(m["DataUsedSize"]));
    }
    if (m.find("MaxDiskSize") != m.end() && !m["MaxDiskSize"].empty()) {
      maxDiskSize = make_shared<double>(boost::any_cast<double>(m["MaxDiskSize"]));
    }
    if (m.find("MaxDiskUsedObServer") != m.end() && !m["MaxDiskUsedObServer"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["MaxDiskUsedObServer"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["MaxDiskUsedObServer"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      maxDiskUsedObServer = make_shared<vector<string>>(toVec1);
    }
    if (m.find("MaxDiskUsedPercent") != m.end() && !m["MaxDiskUsedPercent"].empty()) {
      maxDiskUsedPercent = make_shared<double>(boost::any_cast<double>(m["MaxDiskUsedPercent"]));
    }
    if (m.find("OriginalTotalDiskSize") != m.end() && !m["OriginalTotalDiskSize"].empty()) {
      originalTotalDiskSize = make_shared<long>(boost::any_cast<long>(m["OriginalTotalDiskSize"]));
    }
    if (m.find("TotalDiskSize") != m.end() && !m["TotalDiskSize"].empty()) {
      totalDiskSize = make_shared<long>(boost::any_cast<long>(m["TotalDiskSize"]));
    }
    if (m.find("UnitDiskSize") != m.end() && !m["UnitDiskSize"].empty()) {
      unitDiskSize = make_shared<long>(boost::any_cast<long>(m["UnitDiskSize"]));
    }
    if (m.find("UsedDiskSize") != m.end() && !m["UsedDiskSize"].empty()) {
      usedDiskSize = make_shared<long>(boost::any_cast<long>(m["UsedDiskSize"]));
    }
  }


  virtual ~DescribeInstanceResponseBodyInstanceResourceDiskSize() = default;
};
class DescribeInstanceResponseBodyInstanceResourceLogDiskSize : public Darabonba::Model {
public:
  shared_ptr<string> logAssignedSize{};
  shared_ptr<vector<string>> maxLogAssignedObServer{};
  shared_ptr<string> maxLogAssignedPercent{};
  shared_ptr<long> originalTotalDiskSize{};
  shared_ptr<long> totalDiskSize{};
  shared_ptr<long> unitDiskSize{};

  DescribeInstanceResponseBodyInstanceResourceLogDiskSize() {}

  explicit DescribeInstanceResponseBodyInstanceResourceLogDiskSize(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (logAssignedSize) {
      res["LogAssignedSize"] = boost::any(*logAssignedSize);
    }
    if (maxLogAssignedObServer) {
      res["MaxLogAssignedObServer"] = boost::any(*maxLogAssignedObServer);
    }
    if (maxLogAssignedPercent) {
      res["MaxLogAssignedPercent"] = boost::any(*maxLogAssignedPercent);
    }
    if (originalTotalDiskSize) {
      res["OriginalTotalDiskSize"] = boost::any(*originalTotalDiskSize);
    }
    if (totalDiskSize) {
      res["TotalDiskSize"] = boost::any(*totalDiskSize);
    }
    if (unitDiskSize) {
      res["UnitDiskSize"] = boost::any(*unitDiskSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LogAssignedSize") != m.end() && !m["LogAssignedSize"].empty()) {
      logAssignedSize = make_shared<string>(boost::any_cast<string>(m["LogAssignedSize"]));
    }
    if (m.find("MaxLogAssignedObServer") != m.end() && !m["MaxLogAssignedObServer"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["MaxLogAssignedObServer"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["MaxLogAssignedObServer"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      maxLogAssignedObServer = make_shared<vector<string>>(toVec1);
    }
    if (m.find("MaxLogAssignedPercent") != m.end() && !m["MaxLogAssignedPercent"].empty()) {
      maxLogAssignedPercent = make_shared<string>(boost::any_cast<string>(m["MaxLogAssignedPercent"]));
    }
    if (m.find("OriginalTotalDiskSize") != m.end() && !m["OriginalTotalDiskSize"].empty()) {
      originalTotalDiskSize = make_shared<long>(boost::any_cast<long>(m["OriginalTotalDiskSize"]));
    }
    if (m.find("TotalDiskSize") != m.end() && !m["TotalDiskSize"].empty()) {
      totalDiskSize = make_shared<long>(boost::any_cast<long>(m["TotalDiskSize"]));
    }
    if (m.find("UnitDiskSize") != m.end() && !m["UnitDiskSize"].empty()) {
      unitDiskSize = make_shared<long>(boost::any_cast<long>(m["UnitDiskSize"]));
    }
  }


  virtual ~DescribeInstanceResponseBodyInstanceResourceLogDiskSize() = default;
};
class DescribeInstanceResponseBodyInstanceResourceMemory : public Darabonba::Model {
public:
  shared_ptr<long> originalTotalMemory{};
  shared_ptr<long> totalMemory{};
  shared_ptr<long> unitMemory{};
  shared_ptr<long> usedMemory{};

  DescribeInstanceResponseBodyInstanceResourceMemory() {}

  explicit DescribeInstanceResponseBodyInstanceResourceMemory(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (originalTotalMemory) {
      res["OriginalTotalMemory"] = boost::any(*originalTotalMemory);
    }
    if (totalMemory) {
      res["TotalMemory"] = boost::any(*totalMemory);
    }
    if (unitMemory) {
      res["UnitMemory"] = boost::any(*unitMemory);
    }
    if (usedMemory) {
      res["UsedMemory"] = boost::any(*usedMemory);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OriginalTotalMemory") != m.end() && !m["OriginalTotalMemory"].empty()) {
      originalTotalMemory = make_shared<long>(boost::any_cast<long>(m["OriginalTotalMemory"]));
    }
    if (m.find("TotalMemory") != m.end() && !m["TotalMemory"].empty()) {
      totalMemory = make_shared<long>(boost::any_cast<long>(m["TotalMemory"]));
    }
    if (m.find("UnitMemory") != m.end() && !m["UnitMemory"].empty()) {
      unitMemory = make_shared<long>(boost::any_cast<long>(m["UnitMemory"]));
    }
    if (m.find("UsedMemory") != m.end() && !m["UsedMemory"].empty()) {
      usedMemory = make_shared<long>(boost::any_cast<long>(m["UsedMemory"]));
    }
  }


  virtual ~DescribeInstanceResponseBodyInstanceResourceMemory() = default;
};
class DescribeInstanceResponseBodyInstanceResource : public Darabonba::Model {
public:
  shared_ptr<DescribeInstanceResponseBodyInstanceResourceCapacityUnit> capacityUnit{};
  shared_ptr<DescribeInstanceResponseBodyInstanceResourceCpu> cpu{};
  shared_ptr<DescribeInstanceResponseBodyInstanceResourceDiskSize> diskSize{};
  shared_ptr<DescribeInstanceResponseBodyInstanceResourceLogDiskSize> logDiskSize{};
  shared_ptr<DescribeInstanceResponseBodyInstanceResourceMemory> memory{};
  shared_ptr<long> unitCount{};

  DescribeInstanceResponseBodyInstanceResource() {}

  explicit DescribeInstanceResponseBodyInstanceResource(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (capacityUnit) {
      res["CapacityUnit"] = capacityUnit ? boost::any(capacityUnit->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (cpu) {
      res["Cpu"] = cpu ? boost::any(cpu->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (diskSize) {
      res["DiskSize"] = diskSize ? boost::any(diskSize->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (logDiskSize) {
      res["LogDiskSize"] = logDiskSize ? boost::any(logDiskSize->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (memory) {
      res["Memory"] = memory ? boost::any(memory->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (unitCount) {
      res["UnitCount"] = boost::any(*unitCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CapacityUnit") != m.end() && !m["CapacityUnit"].empty()) {
      if (typeid(map<string, boost::any>) == m["CapacityUnit"].type()) {
        DescribeInstanceResponseBodyInstanceResourceCapacityUnit model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CapacityUnit"]));
        capacityUnit = make_shared<DescribeInstanceResponseBodyInstanceResourceCapacityUnit>(model1);
      }
    }
    if (m.find("Cpu") != m.end() && !m["Cpu"].empty()) {
      if (typeid(map<string, boost::any>) == m["Cpu"].type()) {
        DescribeInstanceResponseBodyInstanceResourceCpu model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Cpu"]));
        cpu = make_shared<DescribeInstanceResponseBodyInstanceResourceCpu>(model1);
      }
    }
    if (m.find("DiskSize") != m.end() && !m["DiskSize"].empty()) {
      if (typeid(map<string, boost::any>) == m["DiskSize"].type()) {
        DescribeInstanceResponseBodyInstanceResourceDiskSize model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DiskSize"]));
        diskSize = make_shared<DescribeInstanceResponseBodyInstanceResourceDiskSize>(model1);
      }
    }
    if (m.find("LogDiskSize") != m.end() && !m["LogDiskSize"].empty()) {
      if (typeid(map<string, boost::any>) == m["LogDiskSize"].type()) {
        DescribeInstanceResponseBodyInstanceResourceLogDiskSize model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LogDiskSize"]));
        logDiskSize = make_shared<DescribeInstanceResponseBodyInstanceResourceLogDiskSize>(model1);
      }
    }
    if (m.find("Memory") != m.end() && !m["Memory"].empty()) {
      if (typeid(map<string, boost::any>) == m["Memory"].type()) {
        DescribeInstanceResponseBodyInstanceResourceMemory model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Memory"]));
        memory = make_shared<DescribeInstanceResponseBodyInstanceResourceMemory>(model1);
      }
    }
    if (m.find("UnitCount") != m.end() && !m["UnitCount"].empty()) {
      unitCount = make_shared<long>(boost::any_cast<long>(m["UnitCount"]));
    }
  }


  virtual ~DescribeInstanceResponseBodyInstanceResource() = default;
};
class DescribeInstanceResponseBodyInstanceTenantCreatable : public Darabonba::Model {
public:
  shared_ptr<string> disableCreateTenantReason{};
  shared_ptr<bool> enableCreateTenant{};

  DescribeInstanceResponseBodyInstanceTenantCreatable() {}

  explicit DescribeInstanceResponseBodyInstanceTenantCreatable(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (disableCreateTenantReason) {
      res["DisableCreateTenantReason"] = boost::any(*disableCreateTenantReason);
    }
    if (enableCreateTenant) {
      res["EnableCreateTenant"] = boost::any(*enableCreateTenant);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DisableCreateTenantReason") != m.end() && !m["DisableCreateTenantReason"].empty()) {
      disableCreateTenantReason = make_shared<string>(boost::any_cast<string>(m["DisableCreateTenantReason"]));
    }
    if (m.find("EnableCreateTenant") != m.end() && !m["EnableCreateTenant"].empty()) {
      enableCreateTenant = make_shared<bool>(boost::any_cast<bool>(m["EnableCreateTenant"]));
    }
  }


  virtual ~DescribeInstanceResponseBodyInstanceTenantCreatable() = default;
};
class DescribeInstanceResponseBodyInstance : public Darabonba::Model {
public:
  shared_ptr<bool> autoRenewal{};
  shared_ptr<bool> autoUpgradeObVersion{};
  shared_ptr<vector<string>> availableZones{};
  shared_ptr<string> cpuArchitecture{};
  shared_ptr<string> createTime{};
  shared_ptr<bool> dataDiskAutoScale{};
  shared_ptr<DescribeInstanceResponseBodyInstanceDataDiskAutoScaleConfig> dataDiskAutoScaleConfig{};
  shared_ptr<string> dataMergeTime{};
  shared_ptr<string> deployMode{};
  shared_ptr<string> deployType{};
  shared_ptr<string> diskType{};
  shared_ptr<bool> enableIsolationOptimization{};
  shared_ptr<bool> enableProxyService{};
  shared_ptr<bool> enableReadOnlyReplica{};
  shared_ptr<bool> enableReadOnlyReplicaManagement{};
  shared_ptr<bool> enableUpgradeLogDisk{};
  shared_ptr<long> exclusiveUnitNumLimit{};
  shared_ptr<string> expireTime{};
  shared_ptr<bool> inTempCapacityStatus{};
  shared_ptr<string> instanceClass{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> instanceName{};
  shared_ptr<string> instanceRole{};
  shared_ptr<bool> isLatestObVersion{};
  shared_ptr<bool> isTrustEcs{};
  shared_ptr<bool> isolationOptimization{};
  shared_ptr<string> maintainTime{};
  shared_ptr<string> nodeNum{};
  shared_ptr<string> obRpmVersion{};
  shared_ptr<string> payType{};
  shared_ptr<string> proxyClusterId{};
  shared_ptr<string> proxyServiceStatus{};
  shared_ptr<DescribeInstanceResponseBodyInstanceReadOnlyResource> readOnlyResource{};
  shared_ptr<string> replicaMode{};
  shared_ptr<DescribeInstanceResponseBodyInstanceResource> resource{};
  shared_ptr<string> series{};
  shared_ptr<long> sharedUnitNumLimit{};
  shared_ptr<string> status{};
  shared_ptr<DescribeInstanceResponseBodyInstanceTenantCreatable> tenantCreatable{};
  shared_ptr<string> unitSpec{};
  shared_ptr<string> version{};
  shared_ptr<vector<string>> zones{};

  DescribeInstanceResponseBodyInstance() {}

  explicit DescribeInstanceResponseBodyInstance(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (autoRenewal) {
      res["AutoRenewal"] = boost::any(*autoRenewal);
    }
    if (autoUpgradeObVersion) {
      res["AutoUpgradeObVersion"] = boost::any(*autoUpgradeObVersion);
    }
    if (availableZones) {
      res["AvailableZones"] = boost::any(*availableZones);
    }
    if (cpuArchitecture) {
      res["CpuArchitecture"] = boost::any(*cpuArchitecture);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (dataDiskAutoScale) {
      res["DataDiskAutoScale"] = boost::any(*dataDiskAutoScale);
    }
    if (dataDiskAutoScaleConfig) {
      res["DataDiskAutoScaleConfig"] = dataDiskAutoScaleConfig ? boost::any(dataDiskAutoScaleConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (dataMergeTime) {
      res["DataMergeTime"] = boost::any(*dataMergeTime);
    }
    if (deployMode) {
      res["DeployMode"] = boost::any(*deployMode);
    }
    if (deployType) {
      res["DeployType"] = boost::any(*deployType);
    }
    if (diskType) {
      res["DiskType"] = boost::any(*diskType);
    }
    if (enableIsolationOptimization) {
      res["EnableIsolationOptimization"] = boost::any(*enableIsolationOptimization);
    }
    if (enableProxyService) {
      res["EnableProxyService"] = boost::any(*enableProxyService);
    }
    if (enableReadOnlyReplica) {
      res["EnableReadOnlyReplica"] = boost::any(*enableReadOnlyReplica);
    }
    if (enableReadOnlyReplicaManagement) {
      res["EnableReadOnlyReplicaManagement"] = boost::any(*enableReadOnlyReplicaManagement);
    }
    if (enableUpgradeLogDisk) {
      res["EnableUpgradeLogDisk"] = boost::any(*enableUpgradeLogDisk);
    }
    if (exclusiveUnitNumLimit) {
      res["ExclusiveUnitNumLimit"] = boost::any(*exclusiveUnitNumLimit);
    }
    if (expireTime) {
      res["ExpireTime"] = boost::any(*expireTime);
    }
    if (inTempCapacityStatus) {
      res["InTempCapacityStatus"] = boost::any(*inTempCapacityStatus);
    }
    if (instanceClass) {
      res["InstanceClass"] = boost::any(*instanceClass);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (instanceName) {
      res["InstanceName"] = boost::any(*instanceName);
    }
    if (instanceRole) {
      res["InstanceRole"] = boost::any(*instanceRole);
    }
    if (isLatestObVersion) {
      res["IsLatestObVersion"] = boost::any(*isLatestObVersion);
    }
    if (isTrustEcs) {
      res["IsTrustEcs"] = boost::any(*isTrustEcs);
    }
    if (isolationOptimization) {
      res["IsolationOptimization"] = boost::any(*isolationOptimization);
    }
    if (maintainTime) {
      res["MaintainTime"] = boost::any(*maintainTime);
    }
    if (nodeNum) {
      res["NodeNum"] = boost::any(*nodeNum);
    }
    if (obRpmVersion) {
      res["ObRpmVersion"] = boost::any(*obRpmVersion);
    }
    if (payType) {
      res["PayType"] = boost::any(*payType);
    }
    if (proxyClusterId) {
      res["ProxyClusterId"] = boost::any(*proxyClusterId);
    }
    if (proxyServiceStatus) {
      res["ProxyServiceStatus"] = boost::any(*proxyServiceStatus);
    }
    if (readOnlyResource) {
      res["ReadOnlyResource"] = readOnlyResource ? boost::any(readOnlyResource->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (replicaMode) {
      res["ReplicaMode"] = boost::any(*replicaMode);
    }
    if (resource) {
      res["Resource"] = resource ? boost::any(resource->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (series) {
      res["Series"] = boost::any(*series);
    }
    if (sharedUnitNumLimit) {
      res["SharedUnitNumLimit"] = boost::any(*sharedUnitNumLimit);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (tenantCreatable) {
      res["TenantCreatable"] = tenantCreatable ? boost::any(tenantCreatable->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (unitSpec) {
      res["UnitSpec"] = boost::any(*unitSpec);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    if (zones) {
      res["Zones"] = boost::any(*zones);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AutoRenewal") != m.end() && !m["AutoRenewal"].empty()) {
      autoRenewal = make_shared<bool>(boost::any_cast<bool>(m["AutoRenewal"]));
    }
    if (m.find("AutoUpgradeObVersion") != m.end() && !m["AutoUpgradeObVersion"].empty()) {
      autoUpgradeObVersion = make_shared<bool>(boost::any_cast<bool>(m["AutoUpgradeObVersion"]));
    }
    if (m.find("AvailableZones") != m.end() && !m["AvailableZones"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["AvailableZones"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["AvailableZones"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      availableZones = make_shared<vector<string>>(toVec1);
    }
    if (m.find("CpuArchitecture") != m.end() && !m["CpuArchitecture"].empty()) {
      cpuArchitecture = make_shared<string>(boost::any_cast<string>(m["CpuArchitecture"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("DataDiskAutoScale") != m.end() && !m["DataDiskAutoScale"].empty()) {
      dataDiskAutoScale = make_shared<bool>(boost::any_cast<bool>(m["DataDiskAutoScale"]));
    }
    if (m.find("DataDiskAutoScaleConfig") != m.end() && !m["DataDiskAutoScaleConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["DataDiskAutoScaleConfig"].type()) {
        DescribeInstanceResponseBodyInstanceDataDiskAutoScaleConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DataDiskAutoScaleConfig"]));
        dataDiskAutoScaleConfig = make_shared<DescribeInstanceResponseBodyInstanceDataDiskAutoScaleConfig>(model1);
      }
    }
    if (m.find("DataMergeTime") != m.end() && !m["DataMergeTime"].empty()) {
      dataMergeTime = make_shared<string>(boost::any_cast<string>(m["DataMergeTime"]));
    }
    if (m.find("DeployMode") != m.end() && !m["DeployMode"].empty()) {
      deployMode = make_shared<string>(boost::any_cast<string>(m["DeployMode"]));
    }
    if (m.find("DeployType") != m.end() && !m["DeployType"].empty()) {
      deployType = make_shared<string>(boost::any_cast<string>(m["DeployType"]));
    }
    if (m.find("DiskType") != m.end() && !m["DiskType"].empty()) {
      diskType = make_shared<string>(boost::any_cast<string>(m["DiskType"]));
    }
    if (m.find("EnableIsolationOptimization") != m.end() && !m["EnableIsolationOptimization"].empty()) {
      enableIsolationOptimization = make_shared<bool>(boost::any_cast<bool>(m["EnableIsolationOptimization"]));
    }
    if (m.find("EnableProxyService") != m.end() && !m["EnableProxyService"].empty()) {
      enableProxyService = make_shared<bool>(boost::any_cast<bool>(m["EnableProxyService"]));
    }
    if (m.find("EnableReadOnlyReplica") != m.end() && !m["EnableReadOnlyReplica"].empty()) {
      enableReadOnlyReplica = make_shared<bool>(boost::any_cast<bool>(m["EnableReadOnlyReplica"]));
    }
    if (m.find("EnableReadOnlyReplicaManagement") != m.end() && !m["EnableReadOnlyReplicaManagement"].empty()) {
      enableReadOnlyReplicaManagement = make_shared<bool>(boost::any_cast<bool>(m["EnableReadOnlyReplicaManagement"]));
    }
    if (m.find("EnableUpgradeLogDisk") != m.end() && !m["EnableUpgradeLogDisk"].empty()) {
      enableUpgradeLogDisk = make_shared<bool>(boost::any_cast<bool>(m["EnableUpgradeLogDisk"]));
    }
    if (m.find("ExclusiveUnitNumLimit") != m.end() && !m["ExclusiveUnitNumLimit"].empty()) {
      exclusiveUnitNumLimit = make_shared<long>(boost::any_cast<long>(m["ExclusiveUnitNumLimit"]));
    }
    if (m.find("ExpireTime") != m.end() && !m["ExpireTime"].empty()) {
      expireTime = make_shared<string>(boost::any_cast<string>(m["ExpireTime"]));
    }
    if (m.find("InTempCapacityStatus") != m.end() && !m["InTempCapacityStatus"].empty()) {
      inTempCapacityStatus = make_shared<bool>(boost::any_cast<bool>(m["InTempCapacityStatus"]));
    }
    if (m.find("InstanceClass") != m.end() && !m["InstanceClass"].empty()) {
      instanceClass = make_shared<string>(boost::any_cast<string>(m["InstanceClass"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("InstanceName") != m.end() && !m["InstanceName"].empty()) {
      instanceName = make_shared<string>(boost::any_cast<string>(m["InstanceName"]));
    }
    if (m.find("InstanceRole") != m.end() && !m["InstanceRole"].empty()) {
      instanceRole = make_shared<string>(boost::any_cast<string>(m["InstanceRole"]));
    }
    if (m.find("IsLatestObVersion") != m.end() && !m["IsLatestObVersion"].empty()) {
      isLatestObVersion = make_shared<bool>(boost::any_cast<bool>(m["IsLatestObVersion"]));
    }
    if (m.find("IsTrustEcs") != m.end() && !m["IsTrustEcs"].empty()) {
      isTrustEcs = make_shared<bool>(boost::any_cast<bool>(m["IsTrustEcs"]));
    }
    if (m.find("IsolationOptimization") != m.end() && !m["IsolationOptimization"].empty()) {
      isolationOptimization = make_shared<bool>(boost::any_cast<bool>(m["IsolationOptimization"]));
    }
    if (m.find("MaintainTime") != m.end() && !m["MaintainTime"].empty()) {
      maintainTime = make_shared<string>(boost::any_cast<string>(m["MaintainTime"]));
    }
    if (m.find("NodeNum") != m.end() && !m["NodeNum"].empty()) {
      nodeNum = make_shared<string>(boost::any_cast<string>(m["NodeNum"]));
    }
    if (m.find("ObRpmVersion") != m.end() && !m["ObRpmVersion"].empty()) {
      obRpmVersion = make_shared<string>(boost::any_cast<string>(m["ObRpmVersion"]));
    }
    if (m.find("PayType") != m.end() && !m["PayType"].empty()) {
      payType = make_shared<string>(boost::any_cast<string>(m["PayType"]));
    }
    if (m.find("ProxyClusterId") != m.end() && !m["ProxyClusterId"].empty()) {
      proxyClusterId = make_shared<string>(boost::any_cast<string>(m["ProxyClusterId"]));
    }
    if (m.find("ProxyServiceStatus") != m.end() && !m["ProxyServiceStatus"].empty()) {
      proxyServiceStatus = make_shared<string>(boost::any_cast<string>(m["ProxyServiceStatus"]));
    }
    if (m.find("ReadOnlyResource") != m.end() && !m["ReadOnlyResource"].empty()) {
      if (typeid(map<string, boost::any>) == m["ReadOnlyResource"].type()) {
        DescribeInstanceResponseBodyInstanceReadOnlyResource model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ReadOnlyResource"]));
        readOnlyResource = make_shared<DescribeInstanceResponseBodyInstanceReadOnlyResource>(model1);
      }
    }
    if (m.find("ReplicaMode") != m.end() && !m["ReplicaMode"].empty()) {
      replicaMode = make_shared<string>(boost::any_cast<string>(m["ReplicaMode"]));
    }
    if (m.find("Resource") != m.end() && !m["Resource"].empty()) {
      if (typeid(map<string, boost::any>) == m["Resource"].type()) {
        DescribeInstanceResponseBodyInstanceResource model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Resource"]));
        resource = make_shared<DescribeInstanceResponseBodyInstanceResource>(model1);
      }
    }
    if (m.find("Series") != m.end() && !m["Series"].empty()) {
      series = make_shared<string>(boost::any_cast<string>(m["Series"]));
    }
    if (m.find("SharedUnitNumLimit") != m.end() && !m["SharedUnitNumLimit"].empty()) {
      sharedUnitNumLimit = make_shared<long>(boost::any_cast<long>(m["SharedUnitNumLimit"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("TenantCreatable") != m.end() && !m["TenantCreatable"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantCreatable"].type()) {
        DescribeInstanceResponseBodyInstanceTenantCreatable model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantCreatable"]));
        tenantCreatable = make_shared<DescribeInstanceResponseBodyInstanceTenantCreatable>(model1);
      }
    }
    if (m.find("UnitSpec") != m.end() && !m["UnitSpec"].empty()) {
      unitSpec = make_shared<string>(boost::any_cast<string>(m["UnitSpec"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["Version"]));
    }
    if (m.find("Zones") != m.end() && !m["Zones"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Zones"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Zones"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      zones = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeInstanceResponseBodyInstance() = default;
};
class DescribeInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeInstanceResponseBodyInstance> instance{};
  shared_ptr<string> requestId{};

  DescribeInstanceResponseBody() {}

  explicit DescribeInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instance) {
      res["Instance"] = instance ? boost::any(instance->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Instance") != m.end() && !m["Instance"].empty()) {
      if (typeid(map<string, boost::any>) == m["Instance"].type()) {
        DescribeInstanceResponseBodyInstance model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Instance"]));
        instance = make_shared<DescribeInstanceResponseBodyInstance>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeInstanceResponseBody() = default;
};
class DescribeInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeInstanceResponseBody> body{};

  DescribeInstanceResponse() {}

  explicit DescribeInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeInstanceResponse() = default;
};
class DescribeInstanceCreatableZoneRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};

  DescribeInstanceCreatableZoneRequest() {}

  explicit DescribeInstanceCreatableZoneRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~DescribeInstanceCreatableZoneRequest() = default;
};
class DescribeInstanceCreatableZoneResponseBodyZoneList : public Darabonba::Model {
public:
  shared_ptr<bool> isInCluster{};
  shared_ptr<string> zone{};

  DescribeInstanceCreatableZoneResponseBodyZoneList() {}

  explicit DescribeInstanceCreatableZoneResponseBodyZoneList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (isInCluster) {
      res["IsInCluster"] = boost::any(*isInCluster);
    }
    if (zone) {
      res["Zone"] = boost::any(*zone);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IsInCluster") != m.end() && !m["IsInCluster"].empty()) {
      isInCluster = make_shared<bool>(boost::any_cast<bool>(m["IsInCluster"]));
    }
    if (m.find("Zone") != m.end() && !m["Zone"].empty()) {
      zone = make_shared<string>(boost::any_cast<string>(m["Zone"]));
    }
  }


  virtual ~DescribeInstanceCreatableZoneResponseBodyZoneList() = default;
};
class DescribeInstanceCreatableZoneResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeInstanceCreatableZoneResponseBodyZoneList>> zoneList{};

  DescribeInstanceCreatableZoneResponseBody() {}

  explicit DescribeInstanceCreatableZoneResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (zoneList) {
      vector<boost::any> temp1;
      for(auto item1:*zoneList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ZoneList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ZoneList") != m.end() && !m["ZoneList"].empty()) {
      if (typeid(vector<boost::any>) == m["ZoneList"].type()) {
        vector<DescribeInstanceCreatableZoneResponseBodyZoneList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ZoneList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeInstanceCreatableZoneResponseBodyZoneList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        zoneList = make_shared<vector<DescribeInstanceCreatableZoneResponseBodyZoneList>>(expect1);
      }
    }
  }


  virtual ~DescribeInstanceCreatableZoneResponseBody() = default;
};
class DescribeInstanceCreatableZoneResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeInstanceCreatableZoneResponseBody> body{};

  DescribeInstanceCreatableZoneResponse() {}

  explicit DescribeInstanceCreatableZoneResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeInstanceCreatableZoneResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeInstanceCreatableZoneResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeInstanceCreatableZoneResponse() = default;
};
class DescribeInstanceSSLRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};

  DescribeInstanceSSLRequest() {}

  explicit DescribeInstanceSSLRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~DescribeInstanceSSLRequest() = default;
};
class DescribeInstanceSSLResponseBodyInstanceSSL : public Darabonba::Model {
public:
  shared_ptr<string> caUrl{};
  shared_ptr<string> enableSSL{};
  shared_ptr<string> forceSSL{};
  shared_ptr<bool> forceSSLSupport{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> status{};
  shared_ptr<string> validPeriod{};

  DescribeInstanceSSLResponseBodyInstanceSSL() {}

  explicit DescribeInstanceSSLResponseBodyInstanceSSL(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (caUrl) {
      res["CaUrl"] = boost::any(*caUrl);
    }
    if (enableSSL) {
      res["EnableSSL"] = boost::any(*enableSSL);
    }
    if (forceSSL) {
      res["ForceSSL"] = boost::any(*forceSSL);
    }
    if (forceSSLSupport) {
      res["ForceSSLSupport"] = boost::any(*forceSSLSupport);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (validPeriod) {
      res["ValidPeriod"] = boost::any(*validPeriod);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CaUrl") != m.end() && !m["CaUrl"].empty()) {
      caUrl = make_shared<string>(boost::any_cast<string>(m["CaUrl"]));
    }
    if (m.find("EnableSSL") != m.end() && !m["EnableSSL"].empty()) {
      enableSSL = make_shared<string>(boost::any_cast<string>(m["EnableSSL"]));
    }
    if (m.find("ForceSSL") != m.end() && !m["ForceSSL"].empty()) {
      forceSSL = make_shared<string>(boost::any_cast<string>(m["ForceSSL"]));
    }
    if (m.find("ForceSSLSupport") != m.end() && !m["ForceSSLSupport"].empty()) {
      forceSSLSupport = make_shared<bool>(boost::any_cast<bool>(m["ForceSSLSupport"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("ValidPeriod") != m.end() && !m["ValidPeriod"].empty()) {
      validPeriod = make_shared<string>(boost::any_cast<string>(m["ValidPeriod"]));
    }
  }


  virtual ~DescribeInstanceSSLResponseBodyInstanceSSL() = default;
};
class DescribeInstanceSSLResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeInstanceSSLResponseBodyInstanceSSL> instanceSSL{};
  shared_ptr<string> requestId{};

  DescribeInstanceSSLResponseBody() {}

  explicit DescribeInstanceSSLResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceSSL) {
      res["InstanceSSL"] = instanceSSL ? boost::any(instanceSSL->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceSSL") != m.end() && !m["InstanceSSL"].empty()) {
      if (typeid(map<string, boost::any>) == m["InstanceSSL"].type()) {
        DescribeInstanceSSLResponseBodyInstanceSSL model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InstanceSSL"]));
        instanceSSL = make_shared<DescribeInstanceSSLResponseBodyInstanceSSL>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeInstanceSSLResponseBody() = default;
};
class DescribeInstanceSSLResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeInstanceSSLResponseBody> body{};

  DescribeInstanceSSLResponse() {}

  explicit DescribeInstanceSSLResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeInstanceSSLResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeInstanceSSLResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeInstanceSSLResponse() = default;
};
class DescribeInstanceSecurityConfigsRequest : public Darabonba::Model {
public:
  shared_ptr<string> checkId{};
  shared_ptr<string> instanceId{};

  DescribeInstanceSecurityConfigsRequest() {}

  explicit DescribeInstanceSecurityConfigsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (checkId) {
      res["CheckId"] = boost::any(*checkId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CheckId") != m.end() && !m["CheckId"].empty()) {
      checkId = make_shared<string>(boost::any_cast<string>(m["CheckId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~DescribeInstanceSecurityConfigsRequest() = default;
};
class DescribeInstanceSecurityConfigsResponseBodyInstanceSecurityConfigsSecurityConfigs : public Darabonba::Model {
public:
  shared_ptr<string> configDescription{};
  shared_ptr<string> configGroup{};
  shared_ptr<string> configName{};
  shared_ptr<bool> risk{};
  shared_ptr<string> riskDescription{};

  DescribeInstanceSecurityConfigsResponseBodyInstanceSecurityConfigsSecurityConfigs() {}

  explicit DescribeInstanceSecurityConfigsResponseBodyInstanceSecurityConfigsSecurityConfigs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configDescription) {
      res["ConfigDescription"] = boost::any(*configDescription);
    }
    if (configGroup) {
      res["ConfigGroup"] = boost::any(*configGroup);
    }
    if (configName) {
      res["ConfigName"] = boost::any(*configName);
    }
    if (risk) {
      res["Risk"] = boost::any(*risk);
    }
    if (riskDescription) {
      res["RiskDescription"] = boost::any(*riskDescription);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigDescription") != m.end() && !m["ConfigDescription"].empty()) {
      configDescription = make_shared<string>(boost::any_cast<string>(m["ConfigDescription"]));
    }
    if (m.find("ConfigGroup") != m.end() && !m["ConfigGroup"].empty()) {
      configGroup = make_shared<string>(boost::any_cast<string>(m["ConfigGroup"]));
    }
    if (m.find("ConfigName") != m.end() && !m["ConfigName"].empty()) {
      configName = make_shared<string>(boost::any_cast<string>(m["ConfigName"]));
    }
    if (m.find("Risk") != m.end() && !m["Risk"].empty()) {
      risk = make_shared<bool>(boost::any_cast<bool>(m["Risk"]));
    }
    if (m.find("RiskDescription") != m.end() && !m["RiskDescription"].empty()) {
      riskDescription = make_shared<string>(boost::any_cast<string>(m["RiskDescription"]));
    }
  }


  virtual ~DescribeInstanceSecurityConfigsResponseBodyInstanceSecurityConfigsSecurityConfigs() = default;
};
class DescribeInstanceSecurityConfigsResponseBodyInstanceSecurityConfigs : public Darabonba::Model {
public:
  shared_ptr<string> checkId{};
  shared_ptr<string> checkTime{};
  shared_ptr<string> instanceId{};
  shared_ptr<vector<DescribeInstanceSecurityConfigsResponseBodyInstanceSecurityConfigsSecurityConfigs>> securityConfigs{};
  shared_ptr<long> totalCheckCount{};
  shared_ptr<long> totalRiskCount{};

  DescribeInstanceSecurityConfigsResponseBodyInstanceSecurityConfigs() {}

  explicit DescribeInstanceSecurityConfigsResponseBodyInstanceSecurityConfigs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (checkId) {
      res["CheckId"] = boost::any(*checkId);
    }
    if (checkTime) {
      res["CheckTime"] = boost::any(*checkTime);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (securityConfigs) {
      vector<boost::any> temp1;
      for(auto item1:*securityConfigs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SecurityConfigs"] = boost::any(temp1);
    }
    if (totalCheckCount) {
      res["TotalCheckCount"] = boost::any(*totalCheckCount);
    }
    if (totalRiskCount) {
      res["TotalRiskCount"] = boost::any(*totalRiskCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CheckId") != m.end() && !m["CheckId"].empty()) {
      checkId = make_shared<string>(boost::any_cast<string>(m["CheckId"]));
    }
    if (m.find("CheckTime") != m.end() && !m["CheckTime"].empty()) {
      checkTime = make_shared<string>(boost::any_cast<string>(m["CheckTime"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("SecurityConfigs") != m.end() && !m["SecurityConfigs"].empty()) {
      if (typeid(vector<boost::any>) == m["SecurityConfigs"].type()) {
        vector<DescribeInstanceSecurityConfigsResponseBodyInstanceSecurityConfigsSecurityConfigs> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SecurityConfigs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeInstanceSecurityConfigsResponseBodyInstanceSecurityConfigsSecurityConfigs model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        securityConfigs = make_shared<vector<DescribeInstanceSecurityConfigsResponseBodyInstanceSecurityConfigsSecurityConfigs>>(expect1);
      }
    }
    if (m.find("TotalCheckCount") != m.end() && !m["TotalCheckCount"].empty()) {
      totalCheckCount = make_shared<long>(boost::any_cast<long>(m["TotalCheckCount"]));
    }
    if (m.find("TotalRiskCount") != m.end() && !m["TotalRiskCount"].empty()) {
      totalRiskCount = make_shared<long>(boost::any_cast<long>(m["TotalRiskCount"]));
    }
  }


  virtual ~DescribeInstanceSecurityConfigsResponseBodyInstanceSecurityConfigs() = default;
};
class DescribeInstanceSecurityConfigsResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeInstanceSecurityConfigsResponseBodyInstanceSecurityConfigs> instanceSecurityConfigs{};
  shared_ptr<string> requestId{};

  DescribeInstanceSecurityConfigsResponseBody() {}

  explicit DescribeInstanceSecurityConfigsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceSecurityConfigs) {
      res["InstanceSecurityConfigs"] = instanceSecurityConfigs ? boost::any(instanceSecurityConfigs->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceSecurityConfigs") != m.end() && !m["InstanceSecurityConfigs"].empty()) {
      if (typeid(map<string, boost::any>) == m["InstanceSecurityConfigs"].type()) {
        DescribeInstanceSecurityConfigsResponseBodyInstanceSecurityConfigs model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InstanceSecurityConfigs"]));
        instanceSecurityConfigs = make_shared<DescribeInstanceSecurityConfigsResponseBodyInstanceSecurityConfigs>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeInstanceSecurityConfigsResponseBody() = default;
};
class DescribeInstanceSecurityConfigsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeInstanceSecurityConfigsResponseBody> body{};

  DescribeInstanceSecurityConfigsResponse() {}

  explicit DescribeInstanceSecurityConfigsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeInstanceSecurityConfigsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeInstanceSecurityConfigsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeInstanceSecurityConfigsResponse() = default;
};
class DescribeInstanceTagsRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceIds{};
  shared_ptr<string> tags{};

  DescribeInstanceTagsRequest() {}

  explicit DescribeInstanceTagsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceIds) {
      res["InstanceIds"] = boost::any(*instanceIds);
    }
    if (tags) {
      res["Tags"] = boost::any(*tags);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceIds") != m.end() && !m["InstanceIds"].empty()) {
      instanceIds = make_shared<string>(boost::any_cast<string>(m["InstanceIds"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      tags = make_shared<string>(boost::any_cast<string>(m["Tags"]));
    }
  }


  virtual ~DescribeInstanceTagsRequest() = default;
};
class DescribeInstanceTagsResponseBodyTagResources : public Darabonba::Model {
public:
  shared_ptr<string> resourceId{};
  shared_ptr<string> resourceType{};
  shared_ptr<string> tag{};

  DescribeInstanceTagsResponseBodyTagResources() {}

  explicit DescribeInstanceTagsResponseBodyTagResources(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (tag) {
      res["Tag"] = boost::any(*tag);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      resourceId = make_shared<string>(boost::any_cast<string>(m["ResourceId"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      tag = make_shared<string>(boost::any_cast<string>(m["Tag"]));
    }
  }


  virtual ~DescribeInstanceTagsResponseBodyTagResources() = default;
};
class DescribeInstanceTagsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeInstanceTagsResponseBodyTagResources>> tagResources{};

  DescribeInstanceTagsResponseBody() {}

  explicit DescribeInstanceTagsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (tagResources) {
      vector<boost::any> temp1;
      for(auto item1:*tagResources){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TagResources"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TagResources") != m.end() && !m["TagResources"].empty()) {
      if (typeid(vector<boost::any>) == m["TagResources"].type()) {
        vector<DescribeInstanceTagsResponseBodyTagResources> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TagResources"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeInstanceTagsResponseBodyTagResources model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tagResources = make_shared<vector<DescribeInstanceTagsResponseBodyTagResources>>(expect1);
      }
    }
  }


  virtual ~DescribeInstanceTagsResponseBody() = default;
};
class DescribeInstanceTagsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeInstanceTagsResponseBody> body{};

  DescribeInstanceTagsResponse() {}

  explicit DescribeInstanceTagsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeInstanceTagsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeInstanceTagsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeInstanceTagsResponse() = default;
};
class DescribeInstanceTenantModesRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};

  DescribeInstanceTenantModesRequest() {}

  explicit DescribeInstanceTenantModesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~DescribeInstanceTenantModesRequest() = default;
};
class DescribeInstanceTenantModesResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<string>> instanceModes{};
  shared_ptr<string> requestId{};

  DescribeInstanceTenantModesResponseBody() {}

  explicit DescribeInstanceTenantModesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceModes) {
      res["InstanceModes"] = boost::any(*instanceModes);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceModes") != m.end() && !m["InstanceModes"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["InstanceModes"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["InstanceModes"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      instanceModes = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeInstanceTenantModesResponseBody() = default;
};
class DescribeInstanceTenantModesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeInstanceTenantModesResponseBody> body{};

  DescribeInstanceTenantModesResponse() {}

  explicit DescribeInstanceTenantModesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeInstanceTenantModesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeInstanceTenantModesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeInstanceTenantModesResponse() = default;
};
class DescribeInstanceTopologyRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};

  DescribeInstanceTopologyRequest() {}

  explicit DescribeInstanceTopologyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~DescribeInstanceTopologyRequest() = default;
};
class DescribeInstanceTopologyResponseBodyInstanceTopologyTenantsTenantZonesUnits : public Darabonba::Model {
public:
  shared_ptr<bool> enableCancelMigrateUnit{};
  shared_ptr<bool> enableMigrateUnit{};
  shared_ptr<bool> manualMigrate{};
  shared_ptr<string> nodeId{};
  shared_ptr<string> replicaType{};
  shared_ptr<double> unitCpu{};
  shared_ptr<long> unitDataSize{};
  shared_ptr<string> unitId{};
  shared_ptr<double> unitMemory{};
  shared_ptr<string> unitStatus{};

  DescribeInstanceTopologyResponseBodyInstanceTopologyTenantsTenantZonesUnits() {}

  explicit DescribeInstanceTopologyResponseBodyInstanceTopologyTenantsTenantZonesUnits(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (enableCancelMigrateUnit) {
      res["EnableCancelMigrateUnit"] = boost::any(*enableCancelMigrateUnit);
    }
    if (enableMigrateUnit) {
      res["EnableMigrateUnit"] = boost::any(*enableMigrateUnit);
    }
    if (manualMigrate) {
      res["ManualMigrate"] = boost::any(*manualMigrate);
    }
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    if (replicaType) {
      res["ReplicaType"] = boost::any(*replicaType);
    }
    if (unitCpu) {
      res["UnitCpu"] = boost::any(*unitCpu);
    }
    if (unitDataSize) {
      res["UnitDataSize"] = boost::any(*unitDataSize);
    }
    if (unitId) {
      res["UnitId"] = boost::any(*unitId);
    }
    if (unitMemory) {
      res["UnitMemory"] = boost::any(*unitMemory);
    }
    if (unitStatus) {
      res["UnitStatus"] = boost::any(*unitStatus);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EnableCancelMigrateUnit") != m.end() && !m["EnableCancelMigrateUnit"].empty()) {
      enableCancelMigrateUnit = make_shared<bool>(boost::any_cast<bool>(m["EnableCancelMigrateUnit"]));
    }
    if (m.find("EnableMigrateUnit") != m.end() && !m["EnableMigrateUnit"].empty()) {
      enableMigrateUnit = make_shared<bool>(boost::any_cast<bool>(m["EnableMigrateUnit"]));
    }
    if (m.find("ManualMigrate") != m.end() && !m["ManualMigrate"].empty()) {
      manualMigrate = make_shared<bool>(boost::any_cast<bool>(m["ManualMigrate"]));
    }
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<string>(boost::any_cast<string>(m["NodeId"]));
    }
    if (m.find("ReplicaType") != m.end() && !m["ReplicaType"].empty()) {
      replicaType = make_shared<string>(boost::any_cast<string>(m["ReplicaType"]));
    }
    if (m.find("UnitCpu") != m.end() && !m["UnitCpu"].empty()) {
      unitCpu = make_shared<double>(boost::any_cast<double>(m["UnitCpu"]));
    }
    if (m.find("UnitDataSize") != m.end() && !m["UnitDataSize"].empty()) {
      unitDataSize = make_shared<long>(boost::any_cast<long>(m["UnitDataSize"]));
    }
    if (m.find("UnitId") != m.end() && !m["UnitId"].empty()) {
      unitId = make_shared<string>(boost::any_cast<string>(m["UnitId"]));
    }
    if (m.find("UnitMemory") != m.end() && !m["UnitMemory"].empty()) {
      unitMemory = make_shared<double>(boost::any_cast<double>(m["UnitMemory"]));
    }
    if (m.find("UnitStatus") != m.end() && !m["UnitStatus"].empty()) {
      unitStatus = make_shared<string>(boost::any_cast<string>(m["UnitStatus"]));
    }
  }


  virtual ~DescribeInstanceTopologyResponseBodyInstanceTopologyTenantsTenantZonesUnits() = default;
};
class DescribeInstanceTopologyResponseBodyInstanceTopologyTenantsTenantZones : public Darabonba::Model {
public:
  shared_ptr<string> isPrimaryTenantZone{};
  shared_ptr<string> tenantZoneId{};
  shared_ptr<string> tenantZoneRole{};
  shared_ptr<vector<DescribeInstanceTopologyResponseBodyInstanceTopologyTenantsTenantZonesUnits>> units{};

  DescribeInstanceTopologyResponseBodyInstanceTopologyTenantsTenantZones() {}

  explicit DescribeInstanceTopologyResponseBodyInstanceTopologyTenantsTenantZones(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (isPrimaryTenantZone) {
      res["IsPrimaryTenantZone"] = boost::any(*isPrimaryTenantZone);
    }
    if (tenantZoneId) {
      res["TenantZoneId"] = boost::any(*tenantZoneId);
    }
    if (tenantZoneRole) {
      res["TenantZoneRole"] = boost::any(*tenantZoneRole);
    }
    if (units) {
      vector<boost::any> temp1;
      for(auto item1:*units){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Units"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IsPrimaryTenantZone") != m.end() && !m["IsPrimaryTenantZone"].empty()) {
      isPrimaryTenantZone = make_shared<string>(boost::any_cast<string>(m["IsPrimaryTenantZone"]));
    }
    if (m.find("TenantZoneId") != m.end() && !m["TenantZoneId"].empty()) {
      tenantZoneId = make_shared<string>(boost::any_cast<string>(m["TenantZoneId"]));
    }
    if (m.find("TenantZoneRole") != m.end() && !m["TenantZoneRole"].empty()) {
      tenantZoneRole = make_shared<string>(boost::any_cast<string>(m["TenantZoneRole"]));
    }
    if (m.find("Units") != m.end() && !m["Units"].empty()) {
      if (typeid(vector<boost::any>) == m["Units"].type()) {
        vector<DescribeInstanceTopologyResponseBodyInstanceTopologyTenantsTenantZonesUnits> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Units"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeInstanceTopologyResponseBodyInstanceTopologyTenantsTenantZonesUnits model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        units = make_shared<vector<DescribeInstanceTopologyResponseBodyInstanceTopologyTenantsTenantZonesUnits>>(expect1);
      }
    }
  }


  virtual ~DescribeInstanceTopologyResponseBodyInstanceTopologyTenantsTenantZones() = default;
};
class DescribeInstanceTopologyResponseBodyInstanceTopologyTenants : public Darabonba::Model {
public:
  shared_ptr<string> primaryZoneDeployType{};
  shared_ptr<double> tenantCpu{};
  shared_ptr<string> tenantDeployType{};
  shared_ptr<string> tenantId{};
  shared_ptr<double> tenantMemory{};
  shared_ptr<string> tenantMode{};
  shared_ptr<string> tenantName{};
  shared_ptr<string> tenantStatus{};
  shared_ptr<long> tenantUnitNum{};
  shared_ptr<vector<DescribeInstanceTopologyResponseBodyInstanceTopologyTenantsTenantZones>> tenantZones{};

  DescribeInstanceTopologyResponseBodyInstanceTopologyTenants() {}

  explicit DescribeInstanceTopologyResponseBodyInstanceTopologyTenants(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (primaryZoneDeployType) {
      res["PrimaryZoneDeployType"] = boost::any(*primaryZoneDeployType);
    }
    if (tenantCpu) {
      res["TenantCpu"] = boost::any(*tenantCpu);
    }
    if (tenantDeployType) {
      res["TenantDeployType"] = boost::any(*tenantDeployType);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    if (tenantMemory) {
      res["TenantMemory"] = boost::any(*tenantMemory);
    }
    if (tenantMode) {
      res["TenantMode"] = boost::any(*tenantMode);
    }
    if (tenantName) {
      res["TenantName"] = boost::any(*tenantName);
    }
    if (tenantStatus) {
      res["TenantStatus"] = boost::any(*tenantStatus);
    }
    if (tenantUnitNum) {
      res["TenantUnitNum"] = boost::any(*tenantUnitNum);
    }
    if (tenantZones) {
      vector<boost::any> temp1;
      for(auto item1:*tenantZones){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TenantZones"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PrimaryZoneDeployType") != m.end() && !m["PrimaryZoneDeployType"].empty()) {
      primaryZoneDeployType = make_shared<string>(boost::any_cast<string>(m["PrimaryZoneDeployType"]));
    }
    if (m.find("TenantCpu") != m.end() && !m["TenantCpu"].empty()) {
      tenantCpu = make_shared<double>(boost::any_cast<double>(m["TenantCpu"]));
    }
    if (m.find("TenantDeployType") != m.end() && !m["TenantDeployType"].empty()) {
      tenantDeployType = make_shared<string>(boost::any_cast<string>(m["TenantDeployType"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["TenantId"]));
    }
    if (m.find("TenantMemory") != m.end() && !m["TenantMemory"].empty()) {
      tenantMemory = make_shared<double>(boost::any_cast<double>(m["TenantMemory"]));
    }
    if (m.find("TenantMode") != m.end() && !m["TenantMode"].empty()) {
      tenantMode = make_shared<string>(boost::any_cast<string>(m["TenantMode"]));
    }
    if (m.find("TenantName") != m.end() && !m["TenantName"].empty()) {
      tenantName = make_shared<string>(boost::any_cast<string>(m["TenantName"]));
    }
    if (m.find("TenantStatus") != m.end() && !m["TenantStatus"].empty()) {
      tenantStatus = make_shared<string>(boost::any_cast<string>(m["TenantStatus"]));
    }
    if (m.find("TenantUnitNum") != m.end() && !m["TenantUnitNum"].empty()) {
      tenantUnitNum = make_shared<long>(boost::any_cast<long>(m["TenantUnitNum"]));
    }
    if (m.find("TenantZones") != m.end() && !m["TenantZones"].empty()) {
      if (typeid(vector<boost::any>) == m["TenantZones"].type()) {
        vector<DescribeInstanceTopologyResponseBodyInstanceTopologyTenantsTenantZones> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TenantZones"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeInstanceTopologyResponseBodyInstanceTopologyTenantsTenantZones model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tenantZones = make_shared<vector<DescribeInstanceTopologyResponseBodyInstanceTopologyTenantsTenantZones>>(expect1);
      }
    }
  }


  virtual ~DescribeInstanceTopologyResponseBodyInstanceTopologyTenants() = default;
};
class DescribeInstanceTopologyResponseBodyInstanceTopologyZonesNodesNodeResourceCpu : public Darabonba::Model {
public:
  shared_ptr<long> totalCpu{};
  shared_ptr<double> usedCpu{};

  DescribeInstanceTopologyResponseBodyInstanceTopologyZonesNodesNodeResourceCpu() {}

  explicit DescribeInstanceTopologyResponseBodyInstanceTopologyZonesNodesNodeResourceCpu(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (totalCpu) {
      res["TotalCpu"] = boost::any(*totalCpu);
    }
    if (usedCpu) {
      res["UsedCpu"] = boost::any(*usedCpu);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TotalCpu") != m.end() && !m["TotalCpu"].empty()) {
      totalCpu = make_shared<long>(boost::any_cast<long>(m["TotalCpu"]));
    }
    if (m.find("UsedCpu") != m.end() && !m["UsedCpu"].empty()) {
      usedCpu = make_shared<double>(boost::any_cast<double>(m["UsedCpu"]));
    }
  }


  virtual ~DescribeInstanceTopologyResponseBodyInstanceTopologyZonesNodesNodeResourceCpu() = default;
};
class DescribeInstanceTopologyResponseBodyInstanceTopologyZonesNodesNodeResourceDiskSize : public Darabonba::Model {
public:
  shared_ptr<double> totalDiskSize{};
  shared_ptr<double> usedDiskSize{};

  DescribeInstanceTopologyResponseBodyInstanceTopologyZonesNodesNodeResourceDiskSize() {}

  explicit DescribeInstanceTopologyResponseBodyInstanceTopologyZonesNodesNodeResourceDiskSize(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (totalDiskSize) {
      res["TotalDiskSize"] = boost::any(*totalDiskSize);
    }
    if (usedDiskSize) {
      res["UsedDiskSize"] = boost::any(*usedDiskSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TotalDiskSize") != m.end() && !m["TotalDiskSize"].empty()) {
      totalDiskSize = make_shared<double>(boost::any_cast<double>(m["TotalDiskSize"]));
    }
    if (m.find("UsedDiskSize") != m.end() && !m["UsedDiskSize"].empty()) {
      usedDiskSize = make_shared<double>(boost::any_cast<double>(m["UsedDiskSize"]));
    }
  }


  virtual ~DescribeInstanceTopologyResponseBodyInstanceTopologyZonesNodesNodeResourceDiskSize() = default;
};
class DescribeInstanceTopologyResponseBodyInstanceTopologyZonesNodesNodeResourceMemory : public Darabonba::Model {
public:
  shared_ptr<long> totalMemory{};
  shared_ptr<double> usedMemory{};

  DescribeInstanceTopologyResponseBodyInstanceTopologyZonesNodesNodeResourceMemory() {}

  explicit DescribeInstanceTopologyResponseBodyInstanceTopologyZonesNodesNodeResourceMemory(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (totalMemory) {
      res["TotalMemory"] = boost::any(*totalMemory);
    }
    if (usedMemory) {
      res["UsedMemory"] = boost::any(*usedMemory);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TotalMemory") != m.end() && !m["TotalMemory"].empty()) {
      totalMemory = make_shared<long>(boost::any_cast<long>(m["TotalMemory"]));
    }
    if (m.find("UsedMemory") != m.end() && !m["UsedMemory"].empty()) {
      usedMemory = make_shared<double>(boost::any_cast<double>(m["UsedMemory"]));
    }
  }


  virtual ~DescribeInstanceTopologyResponseBodyInstanceTopologyZonesNodesNodeResourceMemory() = default;
};
class DescribeInstanceTopologyResponseBodyInstanceTopologyZonesNodesNodeResource : public Darabonba::Model {
public:
  shared_ptr<DescribeInstanceTopologyResponseBodyInstanceTopologyZonesNodesNodeResourceCpu> cpu{};
  shared_ptr<DescribeInstanceTopologyResponseBodyInstanceTopologyZonesNodesNodeResourceDiskSize> diskSize{};
  shared_ptr<DescribeInstanceTopologyResponseBodyInstanceTopologyZonesNodesNodeResourceMemory> memory{};

  DescribeInstanceTopologyResponseBodyInstanceTopologyZonesNodesNodeResource() {}

  explicit DescribeInstanceTopologyResponseBodyInstanceTopologyZonesNodesNodeResource(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cpu) {
      res["Cpu"] = cpu ? boost::any(cpu->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (diskSize) {
      res["DiskSize"] = diskSize ? boost::any(diskSize->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (memory) {
      res["Memory"] = memory ? boost::any(memory->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Cpu") != m.end() && !m["Cpu"].empty()) {
      if (typeid(map<string, boost::any>) == m["Cpu"].type()) {
        DescribeInstanceTopologyResponseBodyInstanceTopologyZonesNodesNodeResourceCpu model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Cpu"]));
        cpu = make_shared<DescribeInstanceTopologyResponseBodyInstanceTopologyZonesNodesNodeResourceCpu>(model1);
      }
    }
    if (m.find("DiskSize") != m.end() && !m["DiskSize"].empty()) {
      if (typeid(map<string, boost::any>) == m["DiskSize"].type()) {
        DescribeInstanceTopologyResponseBodyInstanceTopologyZonesNodesNodeResourceDiskSize model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DiskSize"]));
        diskSize = make_shared<DescribeInstanceTopologyResponseBodyInstanceTopologyZonesNodesNodeResourceDiskSize>(model1);
      }
    }
    if (m.find("Memory") != m.end() && !m["Memory"].empty()) {
      if (typeid(map<string, boost::any>) == m["Memory"].type()) {
        DescribeInstanceTopologyResponseBodyInstanceTopologyZonesNodesNodeResourceMemory model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Memory"]));
        memory = make_shared<DescribeInstanceTopologyResponseBodyInstanceTopologyZonesNodesNodeResourceMemory>(model1);
      }
    }
  }


  virtual ~DescribeInstanceTopologyResponseBodyInstanceTopologyZonesNodesNodeResource() = default;
};
class DescribeInstanceTopologyResponseBodyInstanceTopologyZonesNodes : public Darabonba::Model {
public:
  shared_ptr<long> fullCopyId{};
  shared_ptr<long> nodeCopyId{};
  shared_ptr<string> nodeId{};
  shared_ptr<vector<DescribeInstanceTopologyResponseBodyInstanceTopologyZonesNodesNodeResource>> nodeResource{};
  shared_ptr<string> nodeStatus{};
  shared_ptr<long> readOnlyCopyId{};
  shared_ptr<string> replicaType{};

  DescribeInstanceTopologyResponseBodyInstanceTopologyZonesNodes() {}

  explicit DescribeInstanceTopologyResponseBodyInstanceTopologyZonesNodes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fullCopyId) {
      res["FullCopyId"] = boost::any(*fullCopyId);
    }
    if (nodeCopyId) {
      res["NodeCopyId"] = boost::any(*nodeCopyId);
    }
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    if (nodeResource) {
      vector<boost::any> temp1;
      for(auto item1:*nodeResource){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["NodeResource"] = boost::any(temp1);
    }
    if (nodeStatus) {
      res["NodeStatus"] = boost::any(*nodeStatus);
    }
    if (readOnlyCopyId) {
      res["ReadOnlyCopyId"] = boost::any(*readOnlyCopyId);
    }
    if (replicaType) {
      res["ReplicaType"] = boost::any(*replicaType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FullCopyId") != m.end() && !m["FullCopyId"].empty()) {
      fullCopyId = make_shared<long>(boost::any_cast<long>(m["FullCopyId"]));
    }
    if (m.find("NodeCopyId") != m.end() && !m["NodeCopyId"].empty()) {
      nodeCopyId = make_shared<long>(boost::any_cast<long>(m["NodeCopyId"]));
    }
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<string>(boost::any_cast<string>(m["NodeId"]));
    }
    if (m.find("NodeResource") != m.end() && !m["NodeResource"].empty()) {
      if (typeid(vector<boost::any>) == m["NodeResource"].type()) {
        vector<DescribeInstanceTopologyResponseBodyInstanceTopologyZonesNodesNodeResource> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["NodeResource"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeInstanceTopologyResponseBodyInstanceTopologyZonesNodesNodeResource model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        nodeResource = make_shared<vector<DescribeInstanceTopologyResponseBodyInstanceTopologyZonesNodesNodeResource>>(expect1);
      }
    }
    if (m.find("NodeStatus") != m.end() && !m["NodeStatus"].empty()) {
      nodeStatus = make_shared<string>(boost::any_cast<string>(m["NodeStatus"]));
    }
    if (m.find("ReadOnlyCopyId") != m.end() && !m["ReadOnlyCopyId"].empty()) {
      readOnlyCopyId = make_shared<long>(boost::any_cast<long>(m["ReadOnlyCopyId"]));
    }
    if (m.find("ReplicaType") != m.end() && !m["ReplicaType"].empty()) {
      replicaType = make_shared<string>(boost::any_cast<string>(m["ReplicaType"]));
    }
  }


  virtual ~DescribeInstanceTopologyResponseBodyInstanceTopologyZonesNodes() = default;
};
class DescribeInstanceTopologyResponseBodyInstanceTopologyZonesZoneResourceDiskSize : public Darabonba::Model {
public:
  shared_ptr<vector<string>> maxDiskUsedObServer{};
  shared_ptr<double> maxDiskUsedPercent{};

  DescribeInstanceTopologyResponseBodyInstanceTopologyZonesZoneResourceDiskSize() {}

  explicit DescribeInstanceTopologyResponseBodyInstanceTopologyZonesZoneResourceDiskSize(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (maxDiskUsedObServer) {
      res["MaxDiskUsedObServer"] = boost::any(*maxDiskUsedObServer);
    }
    if (maxDiskUsedPercent) {
      res["MaxDiskUsedPercent"] = boost::any(*maxDiskUsedPercent);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MaxDiskUsedObServer") != m.end() && !m["MaxDiskUsedObServer"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["MaxDiskUsedObServer"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["MaxDiskUsedObServer"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      maxDiskUsedObServer = make_shared<vector<string>>(toVec1);
    }
    if (m.find("MaxDiskUsedPercent") != m.end() && !m["MaxDiskUsedPercent"].empty()) {
      maxDiskUsedPercent = make_shared<double>(boost::any_cast<double>(m["MaxDiskUsedPercent"]));
    }
  }


  virtual ~DescribeInstanceTopologyResponseBodyInstanceTopologyZonesZoneResourceDiskSize() = default;
};
class DescribeInstanceTopologyResponseBodyInstanceTopologyZonesZoneResource : public Darabonba::Model {
public:
  shared_ptr<DescribeInstanceTopologyResponseBodyInstanceTopologyZonesZoneResourceDiskSize> diskSize{};

  DescribeInstanceTopologyResponseBodyInstanceTopologyZonesZoneResource() {}

  explicit DescribeInstanceTopologyResponseBodyInstanceTopologyZonesZoneResource(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (diskSize) {
      res["DiskSize"] = diskSize ? boost::any(diskSize->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DiskSize") != m.end() && !m["DiskSize"].empty()) {
      if (typeid(map<string, boost::any>) == m["DiskSize"].type()) {
        DescribeInstanceTopologyResponseBodyInstanceTopologyZonesZoneResourceDiskSize model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DiskSize"]));
        diskSize = make_shared<DescribeInstanceTopologyResponseBodyInstanceTopologyZonesZoneResourceDiskSize>(model1);
      }
    }
  }


  virtual ~DescribeInstanceTopologyResponseBodyInstanceTopologyZonesZoneResource() = default;
};
class DescribeInstanceTopologyResponseBodyInstanceTopologyZones : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeInstanceTopologyResponseBodyInstanceTopologyZonesNodes>> nodes{};
  shared_ptr<string> region{};
  shared_ptr<string> zoneDisk{};
  shared_ptr<string> zoneId{};
  shared_ptr<DescribeInstanceTopologyResponseBodyInstanceTopologyZonesZoneResource> zoneResource{};

  DescribeInstanceTopologyResponseBodyInstanceTopologyZones() {}

  explicit DescribeInstanceTopologyResponseBodyInstanceTopologyZones(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nodes) {
      vector<boost::any> temp1;
      for(auto item1:*nodes){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Nodes"] = boost::any(temp1);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (zoneDisk) {
      res["ZoneDisk"] = boost::any(*zoneDisk);
    }
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    if (zoneResource) {
      res["ZoneResource"] = zoneResource ? boost::any(zoneResource->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Nodes") != m.end() && !m["Nodes"].empty()) {
      if (typeid(vector<boost::any>) == m["Nodes"].type()) {
        vector<DescribeInstanceTopologyResponseBodyInstanceTopologyZonesNodes> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Nodes"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeInstanceTopologyResponseBodyInstanceTopologyZonesNodes model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        nodes = make_shared<vector<DescribeInstanceTopologyResponseBodyInstanceTopologyZonesNodes>>(expect1);
      }
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("ZoneDisk") != m.end() && !m["ZoneDisk"].empty()) {
      zoneDisk = make_shared<string>(boost::any_cast<string>(m["ZoneDisk"]));
    }
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["ZoneId"]));
    }
    if (m.find("ZoneResource") != m.end() && !m["ZoneResource"].empty()) {
      if (typeid(map<string, boost::any>) == m["ZoneResource"].type()) {
        DescribeInstanceTopologyResponseBodyInstanceTopologyZonesZoneResource model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ZoneResource"]));
        zoneResource = make_shared<DescribeInstanceTopologyResponseBodyInstanceTopologyZonesZoneResource>(model1);
      }
    }
  }


  virtual ~DescribeInstanceTopologyResponseBodyInstanceTopologyZones() = default;
};
class DescribeInstanceTopologyResponseBodyInstanceTopology : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeInstanceTopologyResponseBodyInstanceTopologyTenants>> tenants{};
  shared_ptr<vector<DescribeInstanceTopologyResponseBodyInstanceTopologyZones>> zones{};

  DescribeInstanceTopologyResponseBodyInstanceTopology() {}

  explicit DescribeInstanceTopologyResponseBodyInstanceTopology(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenants) {
      vector<boost::any> temp1;
      for(auto item1:*tenants){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tenants"] = boost::any(temp1);
    }
    if (zones) {
      vector<boost::any> temp1;
      for(auto item1:*zones){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Zones"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Tenants") != m.end() && !m["Tenants"].empty()) {
      if (typeid(vector<boost::any>) == m["Tenants"].type()) {
        vector<DescribeInstanceTopologyResponseBodyInstanceTopologyTenants> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tenants"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeInstanceTopologyResponseBodyInstanceTopologyTenants model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tenants = make_shared<vector<DescribeInstanceTopologyResponseBodyInstanceTopologyTenants>>(expect1);
      }
    }
    if (m.find("Zones") != m.end() && !m["Zones"].empty()) {
      if (typeid(vector<boost::any>) == m["Zones"].type()) {
        vector<DescribeInstanceTopologyResponseBodyInstanceTopologyZones> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Zones"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeInstanceTopologyResponseBodyInstanceTopologyZones model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        zones = make_shared<vector<DescribeInstanceTopologyResponseBodyInstanceTopologyZones>>(expect1);
      }
    }
  }


  virtual ~DescribeInstanceTopologyResponseBodyInstanceTopology() = default;
};
class DescribeInstanceTopologyResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeInstanceTopologyResponseBodyInstanceTopology> instanceTopology{};
  shared_ptr<string> requestId{};

  DescribeInstanceTopologyResponseBody() {}

  explicit DescribeInstanceTopologyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceTopology) {
      res["InstanceTopology"] = instanceTopology ? boost::any(instanceTopology->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceTopology") != m.end() && !m["InstanceTopology"].empty()) {
      if (typeid(map<string, boost::any>) == m["InstanceTopology"].type()) {
        DescribeInstanceTopologyResponseBodyInstanceTopology model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["InstanceTopology"]));
        instanceTopology = make_shared<DescribeInstanceTopologyResponseBodyInstanceTopology>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeInstanceTopologyResponseBody() = default;
};
class DescribeInstanceTopologyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeInstanceTopologyResponseBody> body{};

  DescribeInstanceTopologyResponse() {}

  explicit DescribeInstanceTopologyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeInstanceTopologyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeInstanceTopologyResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeInstanceTopologyResponse() = default;
};
class DescribeInstancesRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> instanceName{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> searchKey{};

  DescribeInstancesRequest() {}

  explicit DescribeInstancesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (instanceName) {
      res["InstanceName"] = boost::any(*instanceName);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (searchKey) {
      res["SearchKey"] = boost::any(*searchKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("InstanceName") != m.end() && !m["InstanceName"].empty()) {
      instanceName = make_shared<string>(boost::any_cast<string>(m["InstanceName"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("SearchKey") != m.end() && !m["SearchKey"].empty()) {
      searchKey = make_shared<string>(boost::any_cast<string>(m["SearchKey"]));
    }
  }


  virtual ~DescribeInstancesRequest() = default;
};
class DescribeInstancesResponseBodyInstancesDataDiskAutoScaleConfig : public Darabonba::Model {
public:
  shared_ptr<bool> autoScale{};
  shared_ptr<long> maxDiskSize{};
  shared_ptr<long> scaleStepInMerge{};
  shared_ptr<long> scaleStepInNormal{};
  shared_ptr<long> upperMergeThreshold{};
  shared_ptr<string> upperScaleStrategy{};
  shared_ptr<long> upperThreshold{};
  shared_ptr<long> upperbound{};

  DescribeInstancesResponseBodyInstancesDataDiskAutoScaleConfig() {}

  explicit DescribeInstancesResponseBodyInstancesDataDiskAutoScaleConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (autoScale) {
      res["AutoScale"] = boost::any(*autoScale);
    }
    if (maxDiskSize) {
      res["MaxDiskSize"] = boost::any(*maxDiskSize);
    }
    if (scaleStepInMerge) {
      res["ScaleStepInMerge"] = boost::any(*scaleStepInMerge);
    }
    if (scaleStepInNormal) {
      res["ScaleStepInNormal"] = boost::any(*scaleStepInNormal);
    }
    if (upperMergeThreshold) {
      res["UpperMergeThreshold"] = boost::any(*upperMergeThreshold);
    }
    if (upperScaleStrategy) {
      res["UpperScaleStrategy"] = boost::any(*upperScaleStrategy);
    }
    if (upperThreshold) {
      res["UpperThreshold"] = boost::any(*upperThreshold);
    }
    if (upperbound) {
      res["Upperbound"] = boost::any(*upperbound);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AutoScale") != m.end() && !m["AutoScale"].empty()) {
      autoScale = make_shared<bool>(boost::any_cast<bool>(m["AutoScale"]));
    }
    if (m.find("MaxDiskSize") != m.end() && !m["MaxDiskSize"].empty()) {
      maxDiskSize = make_shared<long>(boost::any_cast<long>(m["MaxDiskSize"]));
    }
    if (m.find("ScaleStepInMerge") != m.end() && !m["ScaleStepInMerge"].empty()) {
      scaleStepInMerge = make_shared<long>(boost::any_cast<long>(m["ScaleStepInMerge"]));
    }
    if (m.find("ScaleStepInNormal") != m.end() && !m["ScaleStepInNormal"].empty()) {
      scaleStepInNormal = make_shared<long>(boost::any_cast<long>(m["ScaleStepInNormal"]));
    }
    if (m.find("UpperMergeThreshold") != m.end() && !m["UpperMergeThreshold"].empty()) {
      upperMergeThreshold = make_shared<long>(boost::any_cast<long>(m["UpperMergeThreshold"]));
    }
    if (m.find("UpperScaleStrategy") != m.end() && !m["UpperScaleStrategy"].empty()) {
      upperScaleStrategy = make_shared<string>(boost::any_cast<string>(m["UpperScaleStrategy"]));
    }
    if (m.find("UpperThreshold") != m.end() && !m["UpperThreshold"].empty()) {
      upperThreshold = make_shared<long>(boost::any_cast<long>(m["UpperThreshold"]));
    }
    if (m.find("Upperbound") != m.end() && !m["Upperbound"].empty()) {
      upperbound = make_shared<long>(boost::any_cast<long>(m["Upperbound"]));
    }
  }


  virtual ~DescribeInstancesResponseBodyInstancesDataDiskAutoScaleConfig() = default;
};
class DescribeInstancesResponseBodyInstancesResourceCapacityUnit : public Darabonba::Model {
public:
  shared_ptr<long> maxCapacityUnit{};
  shared_ptr<long> minCapacityUnit{};
  shared_ptr<long> usedCapacityUnit{};

  DescribeInstancesResponseBodyInstancesResourceCapacityUnit() {}

  explicit DescribeInstancesResponseBodyInstancesResourceCapacityUnit(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (maxCapacityUnit) {
      res["MaxCapacityUnit"] = boost::any(*maxCapacityUnit);
    }
    if (minCapacityUnit) {
      res["MinCapacityUnit"] = boost::any(*minCapacityUnit);
    }
    if (usedCapacityUnit) {
      res["UsedCapacityUnit"] = boost::any(*usedCapacityUnit);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MaxCapacityUnit") != m.end() && !m["MaxCapacityUnit"].empty()) {
      maxCapacityUnit = make_shared<long>(boost::any_cast<long>(m["MaxCapacityUnit"]));
    }
    if (m.find("MinCapacityUnit") != m.end() && !m["MinCapacityUnit"].empty()) {
      minCapacityUnit = make_shared<long>(boost::any_cast<long>(m["MinCapacityUnit"]));
    }
    if (m.find("UsedCapacityUnit") != m.end() && !m["UsedCapacityUnit"].empty()) {
      usedCapacityUnit = make_shared<long>(boost::any_cast<long>(m["UsedCapacityUnit"]));
    }
  }


  virtual ~DescribeInstancesResponseBodyInstancesResourceCapacityUnit() = default;
};
class DescribeInstancesResponseBodyInstancesResourceCpu : public Darabonba::Model {
public:
  shared_ptr<long> originalTotalCpu{};
  shared_ptr<long> totalCpu{};
  shared_ptr<long> unitCpu{};
  shared_ptr<long> usedCpu{};

  DescribeInstancesResponseBodyInstancesResourceCpu() {}

  explicit DescribeInstancesResponseBodyInstancesResourceCpu(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (originalTotalCpu) {
      res["OriginalTotalCpu"] = boost::any(*originalTotalCpu);
    }
    if (totalCpu) {
      res["TotalCpu"] = boost::any(*totalCpu);
    }
    if (unitCpu) {
      res["UnitCpu"] = boost::any(*unitCpu);
    }
    if (usedCpu) {
      res["UsedCpu"] = boost::any(*usedCpu);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OriginalTotalCpu") != m.end() && !m["OriginalTotalCpu"].empty()) {
      originalTotalCpu = make_shared<long>(boost::any_cast<long>(m["OriginalTotalCpu"]));
    }
    if (m.find("TotalCpu") != m.end() && !m["TotalCpu"].empty()) {
      totalCpu = make_shared<long>(boost::any_cast<long>(m["TotalCpu"]));
    }
    if (m.find("UnitCpu") != m.end() && !m["UnitCpu"].empty()) {
      unitCpu = make_shared<long>(boost::any_cast<long>(m["UnitCpu"]));
    }
    if (m.find("UsedCpu") != m.end() && !m["UsedCpu"].empty()) {
      usedCpu = make_shared<long>(boost::any_cast<long>(m["UsedCpu"]));
    }
  }


  virtual ~DescribeInstancesResponseBodyInstancesResourceCpu() = default;
};
class DescribeInstancesResponseBodyInstancesResourceDiskSize : public Darabonba::Model {
public:
  shared_ptr<long> originalTotalDiskSize{};
  shared_ptr<long> totalDiskSize{};
  shared_ptr<long> unitDiskSize{};
  shared_ptr<long> usedDiskSize{};

  DescribeInstancesResponseBodyInstancesResourceDiskSize() {}

  explicit DescribeInstancesResponseBodyInstancesResourceDiskSize(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (originalTotalDiskSize) {
      res["OriginalTotalDiskSize"] = boost::any(*originalTotalDiskSize);
    }
    if (totalDiskSize) {
      res["TotalDiskSize"] = boost::any(*totalDiskSize);
    }
    if (unitDiskSize) {
      res["UnitDiskSize"] = boost::any(*unitDiskSize);
    }
    if (usedDiskSize) {
      res["UsedDiskSize"] = boost::any(*usedDiskSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OriginalTotalDiskSize") != m.end() && !m["OriginalTotalDiskSize"].empty()) {
      originalTotalDiskSize = make_shared<long>(boost::any_cast<long>(m["OriginalTotalDiskSize"]));
    }
    if (m.find("TotalDiskSize") != m.end() && !m["TotalDiskSize"].empty()) {
      totalDiskSize = make_shared<long>(boost::any_cast<long>(m["TotalDiskSize"]));
    }
    if (m.find("UnitDiskSize") != m.end() && !m["UnitDiskSize"].empty()) {
      unitDiskSize = make_shared<long>(boost::any_cast<long>(m["UnitDiskSize"]));
    }
    if (m.find("UsedDiskSize") != m.end() && !m["UsedDiskSize"].empty()) {
      usedDiskSize = make_shared<long>(boost::any_cast<long>(m["UsedDiskSize"]));
    }
  }


  virtual ~DescribeInstancesResponseBodyInstancesResourceDiskSize() = default;
};
class DescribeInstancesResponseBodyInstancesResourceMemory : public Darabonba::Model {
public:
  shared_ptr<long> originalTotalMemory{};
  shared_ptr<long> totalMemory{};
  shared_ptr<long> unitMemory{};
  shared_ptr<long> usedMemory{};

  DescribeInstancesResponseBodyInstancesResourceMemory() {}

  explicit DescribeInstancesResponseBodyInstancesResourceMemory(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (originalTotalMemory) {
      res["OriginalTotalMemory"] = boost::any(*originalTotalMemory);
    }
    if (totalMemory) {
      res["TotalMemory"] = boost::any(*totalMemory);
    }
    if (unitMemory) {
      res["UnitMemory"] = boost::any(*unitMemory);
    }
    if (usedMemory) {
      res["UsedMemory"] = boost::any(*usedMemory);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OriginalTotalMemory") != m.end() && !m["OriginalTotalMemory"].empty()) {
      originalTotalMemory = make_shared<long>(boost::any_cast<long>(m["OriginalTotalMemory"]));
    }
    if (m.find("TotalMemory") != m.end() && !m["TotalMemory"].empty()) {
      totalMemory = make_shared<long>(boost::any_cast<long>(m["TotalMemory"]));
    }
    if (m.find("UnitMemory") != m.end() && !m["UnitMemory"].empty()) {
      unitMemory = make_shared<long>(boost::any_cast<long>(m["UnitMemory"]));
    }
    if (m.find("UsedMemory") != m.end() && !m["UsedMemory"].empty()) {
      usedMemory = make_shared<long>(boost::any_cast<long>(m["UsedMemory"]));
    }
  }


  virtual ~DescribeInstancesResponseBodyInstancesResourceMemory() = default;
};
class DescribeInstancesResponseBodyInstancesResource : public Darabonba::Model {
public:
  shared_ptr<DescribeInstancesResponseBodyInstancesResourceCapacityUnit> capacityUnit{};
  shared_ptr<DescribeInstancesResponseBodyInstancesResourceCpu> cpu{};
  shared_ptr<DescribeInstancesResponseBodyInstancesResourceDiskSize> diskSize{};
  shared_ptr<DescribeInstancesResponseBodyInstancesResourceMemory> memory{};
  shared_ptr<long> unitCount{};

  DescribeInstancesResponseBodyInstancesResource() {}

  explicit DescribeInstancesResponseBodyInstancesResource(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (capacityUnit) {
      res["CapacityUnit"] = capacityUnit ? boost::any(capacityUnit->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (cpu) {
      res["Cpu"] = cpu ? boost::any(cpu->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (diskSize) {
      res["DiskSize"] = diskSize ? boost::any(diskSize->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (memory) {
      res["Memory"] = memory ? boost::any(memory->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (unitCount) {
      res["UnitCount"] = boost::any(*unitCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CapacityUnit") != m.end() && !m["CapacityUnit"].empty()) {
      if (typeid(map<string, boost::any>) == m["CapacityUnit"].type()) {
        DescribeInstancesResponseBodyInstancesResourceCapacityUnit model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CapacityUnit"]));
        capacityUnit = make_shared<DescribeInstancesResponseBodyInstancesResourceCapacityUnit>(model1);
      }
    }
    if (m.find("Cpu") != m.end() && !m["Cpu"].empty()) {
      if (typeid(map<string, boost::any>) == m["Cpu"].type()) {
        DescribeInstancesResponseBodyInstancesResourceCpu model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Cpu"]));
        cpu = make_shared<DescribeInstancesResponseBodyInstancesResourceCpu>(model1);
      }
    }
    if (m.find("DiskSize") != m.end() && !m["DiskSize"].empty()) {
      if (typeid(map<string, boost::any>) == m["DiskSize"].type()) {
        DescribeInstancesResponseBodyInstancesResourceDiskSize model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DiskSize"]));
        diskSize = make_shared<DescribeInstancesResponseBodyInstancesResourceDiskSize>(model1);
      }
    }
    if (m.find("Memory") != m.end() && !m["Memory"].empty()) {
      if (typeid(map<string, boost::any>) == m["Memory"].type()) {
        DescribeInstancesResponseBodyInstancesResourceMemory model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Memory"]));
        memory = make_shared<DescribeInstancesResponseBodyInstancesResourceMemory>(model1);
      }
    }
    if (m.find("UnitCount") != m.end() && !m["UnitCount"].empty()) {
      unitCount = make_shared<long>(boost::any_cast<long>(m["UnitCount"]));
    }
  }


  virtual ~DescribeInstancesResponseBodyInstancesResource() = default;
};
class DescribeInstancesResponseBodyInstances : public Darabonba::Model {
public:
  shared_ptr<vector<string>> availableZones{};
  shared_ptr<string> commodityCode{};
  shared_ptr<long> cpu{};
  shared_ptr<string> cpuArchitecture{};
  shared_ptr<string> createTime{};
  shared_ptr<DescribeInstancesResponseBodyInstancesDataDiskAutoScaleConfig> dataDiskAutoScaleConfig{};
  shared_ptr<string> deployMode{};
  shared_ptr<string> deployType{};
  shared_ptr<string> diskSize{};
  shared_ptr<string> diskType{};
  shared_ptr<bool> enableReadOnlyReplicaManagement{};
  shared_ptr<bool> enableUpgradeNodes{};
  shared_ptr<long> expireSeconds{};
  shared_ptr<string> expireTime{};
  shared_ptr<bool> inTempCapacityStatus{};
  shared_ptr<string> instanceClass{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> instanceName{};
  shared_ptr<string> instanceRole{};
  shared_ptr<string> instanceType{};
  shared_ptr<string> maintainTime{};
  shared_ptr<long> mem{};
  shared_ptr<string> payType{};
  shared_ptr<DescribeInstancesResponseBodyInstancesResource> resource{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> series{};
  shared_ptr<string> state{};
  shared_ptr<long> usedDiskSize{};
  shared_ptr<string> version{};
  shared_ptr<string> vpcId{};

  DescribeInstancesResponseBodyInstances() {}

  explicit DescribeInstancesResponseBodyInstances(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (availableZones) {
      res["AvailableZones"] = boost::any(*availableZones);
    }
    if (commodityCode) {
      res["CommodityCode"] = boost::any(*commodityCode);
    }
    if (cpu) {
      res["Cpu"] = boost::any(*cpu);
    }
    if (cpuArchitecture) {
      res["CpuArchitecture"] = boost::any(*cpuArchitecture);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (dataDiskAutoScaleConfig) {
      res["DataDiskAutoScaleConfig"] = dataDiskAutoScaleConfig ? boost::any(dataDiskAutoScaleConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (deployMode) {
      res["DeployMode"] = boost::any(*deployMode);
    }
    if (deployType) {
      res["DeployType"] = boost::any(*deployType);
    }
    if (diskSize) {
      res["DiskSize"] = boost::any(*diskSize);
    }
    if (diskType) {
      res["DiskType"] = boost::any(*diskType);
    }
    if (enableReadOnlyReplicaManagement) {
      res["EnableReadOnlyReplicaManagement"] = boost::any(*enableReadOnlyReplicaManagement);
    }
    if (enableUpgradeNodes) {
      res["EnableUpgradeNodes"] = boost::any(*enableUpgradeNodes);
    }
    if (expireSeconds) {
      res["ExpireSeconds"] = boost::any(*expireSeconds);
    }
    if (expireTime) {
      res["ExpireTime"] = boost::any(*expireTime);
    }
    if (inTempCapacityStatus) {
      res["InTempCapacityStatus"] = boost::any(*inTempCapacityStatus);
    }
    if (instanceClass) {
      res["InstanceClass"] = boost::any(*instanceClass);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (instanceName) {
      res["InstanceName"] = boost::any(*instanceName);
    }
    if (instanceRole) {
      res["InstanceRole"] = boost::any(*instanceRole);
    }
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (maintainTime) {
      res["MaintainTime"] = boost::any(*maintainTime);
    }
    if (mem) {
      res["Mem"] = boost::any(*mem);
    }
    if (payType) {
      res["PayType"] = boost::any(*payType);
    }
    if (resource) {
      res["Resource"] = resource ? boost::any(resource->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (series) {
      res["Series"] = boost::any(*series);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (usedDiskSize) {
      res["UsedDiskSize"] = boost::any(*usedDiskSize);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AvailableZones") != m.end() && !m["AvailableZones"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["AvailableZones"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["AvailableZones"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      availableZones = make_shared<vector<string>>(toVec1);
    }
    if (m.find("CommodityCode") != m.end() && !m["CommodityCode"].empty()) {
      commodityCode = make_shared<string>(boost::any_cast<string>(m["CommodityCode"]));
    }
    if (m.find("Cpu") != m.end() && !m["Cpu"].empty()) {
      cpu = make_shared<long>(boost::any_cast<long>(m["Cpu"]));
    }
    if (m.find("CpuArchitecture") != m.end() && !m["CpuArchitecture"].empty()) {
      cpuArchitecture = make_shared<string>(boost::any_cast<string>(m["CpuArchitecture"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("DataDiskAutoScaleConfig") != m.end() && !m["DataDiskAutoScaleConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["DataDiskAutoScaleConfig"].type()) {
        DescribeInstancesResponseBodyInstancesDataDiskAutoScaleConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DataDiskAutoScaleConfig"]));
        dataDiskAutoScaleConfig = make_shared<DescribeInstancesResponseBodyInstancesDataDiskAutoScaleConfig>(model1);
      }
    }
    if (m.find("DeployMode") != m.end() && !m["DeployMode"].empty()) {
      deployMode = make_shared<string>(boost::any_cast<string>(m["DeployMode"]));
    }
    if (m.find("DeployType") != m.end() && !m["DeployType"].empty()) {
      deployType = make_shared<string>(boost::any_cast<string>(m["DeployType"]));
    }
    if (m.find("DiskSize") != m.end() && !m["DiskSize"].empty()) {
      diskSize = make_shared<string>(boost::any_cast<string>(m["DiskSize"]));
    }
    if (m.find("DiskType") != m.end() && !m["DiskType"].empty()) {
      diskType = make_shared<string>(boost::any_cast<string>(m["DiskType"]));
    }
    if (m.find("EnableReadOnlyReplicaManagement") != m.end() && !m["EnableReadOnlyReplicaManagement"].empty()) {
      enableReadOnlyReplicaManagement = make_shared<bool>(boost::any_cast<bool>(m["EnableReadOnlyReplicaManagement"]));
    }
    if (m.find("EnableUpgradeNodes") != m.end() && !m["EnableUpgradeNodes"].empty()) {
      enableUpgradeNodes = make_shared<bool>(boost::any_cast<bool>(m["EnableUpgradeNodes"]));
    }
    if (m.find("ExpireSeconds") != m.end() && !m["ExpireSeconds"].empty()) {
      expireSeconds = make_shared<long>(boost::any_cast<long>(m["ExpireSeconds"]));
    }
    if (m.find("ExpireTime") != m.end() && !m["ExpireTime"].empty()) {
      expireTime = make_shared<string>(boost::any_cast<string>(m["ExpireTime"]));
    }
    if (m.find("InTempCapacityStatus") != m.end() && !m["InTempCapacityStatus"].empty()) {
      inTempCapacityStatus = make_shared<bool>(boost::any_cast<bool>(m["InTempCapacityStatus"]));
    }
    if (m.find("InstanceClass") != m.end() && !m["InstanceClass"].empty()) {
      instanceClass = make_shared<string>(boost::any_cast<string>(m["InstanceClass"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("InstanceName") != m.end() && !m["InstanceName"].empty()) {
      instanceName = make_shared<string>(boost::any_cast<string>(m["InstanceName"]));
    }
    if (m.find("InstanceRole") != m.end() && !m["InstanceRole"].empty()) {
      instanceRole = make_shared<string>(boost::any_cast<string>(m["InstanceRole"]));
    }
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("MaintainTime") != m.end() && !m["MaintainTime"].empty()) {
      maintainTime = make_shared<string>(boost::any_cast<string>(m["MaintainTime"]));
    }
    if (m.find("Mem") != m.end() && !m["Mem"].empty()) {
      mem = make_shared<long>(boost::any_cast<long>(m["Mem"]));
    }
    if (m.find("PayType") != m.end() && !m["PayType"].empty()) {
      payType = make_shared<string>(boost::any_cast<string>(m["PayType"]));
    }
    if (m.find("Resource") != m.end() && !m["Resource"].empty()) {
      if (typeid(map<string, boost::any>) == m["Resource"].type()) {
        DescribeInstancesResponseBodyInstancesResource model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Resource"]));
        resource = make_shared<DescribeInstancesResponseBodyInstancesResource>(model1);
      }
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("Series") != m.end() && !m["Series"].empty()) {
      series = make_shared<string>(boost::any_cast<string>(m["Series"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("UsedDiskSize") != m.end() && !m["UsedDiskSize"].empty()) {
      usedDiskSize = make_shared<long>(boost::any_cast<long>(m["UsedDiskSize"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["Version"]));
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
  }


  virtual ~DescribeInstancesResponseBodyInstances() = default;
};
class DescribeInstancesResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeInstancesResponseBodyInstances>> instances{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeInstancesResponseBody() {}

  explicit DescribeInstancesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instances) {
      vector<boost::any> temp1;
      for(auto item1:*instances){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Instances"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Instances") != m.end() && !m["Instances"].empty()) {
      if (typeid(vector<boost::any>) == m["Instances"].type()) {
        vector<DescribeInstancesResponseBodyInstances> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Instances"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeInstancesResponseBodyInstances model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        instances = make_shared<vector<DescribeInstancesResponseBodyInstances>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeInstancesResponseBody() = default;
};
class DescribeInstancesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeInstancesResponseBody> body{};

  DescribeInstancesResponse() {}

  explicit DescribeInstancesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeInstancesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeInstancesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeInstancesResponse() = default;
};
class DescribeMetricsDataRequest : public Darabonba::Model {
public:
  shared_ptr<string> endTime{};
  shared_ptr<string> groupByLabels{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> labels{};
  shared_ptr<string> limit{};
  shared_ptr<string> metrics{};
  shared_ptr<string> replicaType{};
  shared_ptr<string> sortMetricKey{};
  shared_ptr<string> sortOrder{};
  shared_ptr<string> startTime{};

  DescribeMetricsDataRequest() {}

  explicit DescribeMetricsDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (groupByLabels) {
      res["GroupByLabels"] = boost::any(*groupByLabels);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (labels) {
      res["Labels"] = boost::any(*labels);
    }
    if (limit) {
      res["Limit"] = boost::any(*limit);
    }
    if (metrics) {
      res["Metrics"] = boost::any(*metrics);
    }
    if (replicaType) {
      res["ReplicaType"] = boost::any(*replicaType);
    }
    if (sortMetricKey) {
      res["SortMetricKey"] = boost::any(*sortMetricKey);
    }
    if (sortOrder) {
      res["SortOrder"] = boost::any(*sortOrder);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("GroupByLabels") != m.end() && !m["GroupByLabels"].empty()) {
      groupByLabels = make_shared<string>(boost::any_cast<string>(m["GroupByLabels"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Labels") != m.end() && !m["Labels"].empty()) {
      labels = make_shared<string>(boost::any_cast<string>(m["Labels"]));
    }
    if (m.find("Limit") != m.end() && !m["Limit"].empty()) {
      limit = make_shared<string>(boost::any_cast<string>(m["Limit"]));
    }
    if (m.find("Metrics") != m.end() && !m["Metrics"].empty()) {
      metrics = make_shared<string>(boost::any_cast<string>(m["Metrics"]));
    }
    if (m.find("ReplicaType") != m.end() && !m["ReplicaType"].empty()) {
      replicaType = make_shared<string>(boost::any_cast<string>(m["ReplicaType"]));
    }
    if (m.find("SortMetricKey") != m.end() && !m["SortMetricKey"].empty()) {
      sortMetricKey = make_shared<string>(boost::any_cast<string>(m["SortMetricKey"]));
    }
    if (m.find("SortOrder") != m.end() && !m["SortOrder"].empty()) {
      sortOrder = make_shared<string>(boost::any_cast<string>(m["SortOrder"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeMetricsDataRequest() = default;
};
class DescribeMetricsDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> data{};
  shared_ptr<string> requestId{};

  DescribeMetricsDataResponseBody() {}

  explicit DescribeMetricsDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeMetricsDataResponseBody() = default;
};
class DescribeMetricsDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeMetricsDataResponseBody> body{};

  DescribeMetricsDataResponse() {}

  explicit DescribeMetricsDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeMetricsDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeMetricsDataResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeMetricsDataResponse() = default;
};
class DescribeNodeMetricsRequest : public Darabonba::Model {
public:
  shared_ptr<string> endTime{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> metrics{};
  shared_ptr<string> nodeIdList{};
  shared_ptr<string> nodeName{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> startTime{};
  shared_ptr<string> tenantId{};

  DescribeNodeMetricsRequest() {}

  explicit DescribeNodeMetricsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (metrics) {
      res["Metrics"] = boost::any(*metrics);
    }
    if (nodeIdList) {
      res["NodeIdList"] = boost::any(*nodeIdList);
    }
    if (nodeName) {
      res["NodeName"] = boost::any(*nodeName);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Metrics") != m.end() && !m["Metrics"].empty()) {
      metrics = make_shared<string>(boost::any_cast<string>(m["Metrics"]));
    }
    if (m.find("NodeIdList") != m.end() && !m["NodeIdList"].empty()) {
      nodeIdList = make_shared<string>(boost::any_cast<string>(m["NodeIdList"]));
    }
    if (m.find("NodeName") != m.end() && !m["NodeName"].empty()) {
      nodeName = make_shared<string>(boost::any_cast<string>(m["NodeName"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["TenantId"]));
    }
  }


  virtual ~DescribeNodeMetricsRequest() = default;
};
class DescribeNodeMetricsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> nodeMetrics{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeNodeMetricsResponseBody() {}

  explicit DescribeNodeMetricsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nodeMetrics) {
      res["NodeMetrics"] = boost::any(*nodeMetrics);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NodeMetrics") != m.end() && !m["NodeMetrics"].empty()) {
      nodeMetrics = make_shared<string>(boost::any_cast<string>(m["NodeMetrics"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeNodeMetricsResponseBody() = default;
};
class DescribeNodeMetricsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeNodeMetricsResponseBody> body{};

  DescribeNodeMetricsResponse() {}

  explicit DescribeNodeMetricsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeNodeMetricsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeNodeMetricsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeNodeMetricsResponse() = default;
};
class DescribeOasAnomalySQLListRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<long> current{};
  shared_ptr<string> dbName{};
  shared_ptr<bool> dynamicSql{};
  shared_ptr<string> endTime{};
  shared_ptr<string> filterCondition{};
  shared_ptr<string> instanceId{};
  shared_ptr<bool> mergeDynamicSql{};
  shared_ptr<string> nodeIp{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> searchKeyWord{};
  shared_ptr<string> searchParam{};
  shared_ptr<string> searchRule{};
  shared_ptr<string> searchValue{};
  shared_ptr<string> sqlId{};
  shared_ptr<long> sqlTextLength{};
  shared_ptr<string> startTime{};
  shared_ptr<string> tenantId{};

  DescribeOasAnomalySQLListRequest() {}

  explicit DescribeOasAnomalySQLListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (current) {
      res["Current"] = boost::any(*current);
    }
    if (dbName) {
      res["DbName"] = boost::any(*dbName);
    }
    if (dynamicSql) {
      res["DynamicSql"] = boost::any(*dynamicSql);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (filterCondition) {
      res["FilterCondition"] = boost::any(*filterCondition);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (mergeDynamicSql) {
      res["MergeDynamicSql"] = boost::any(*mergeDynamicSql);
    }
    if (nodeIp) {
      res["NodeIp"] = boost::any(*nodeIp);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (searchKeyWord) {
      res["SearchKeyWord"] = boost::any(*searchKeyWord);
    }
    if (searchParam) {
      res["SearchParam"] = boost::any(*searchParam);
    }
    if (searchRule) {
      res["SearchRule"] = boost::any(*searchRule);
    }
    if (searchValue) {
      res["SearchValue"] = boost::any(*searchValue);
    }
    if (sqlId) {
      res["SqlId"] = boost::any(*sqlId);
    }
    if (sqlTextLength) {
      res["SqlTextLength"] = boost::any(*sqlTextLength);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("Current") != m.end() && !m["Current"].empty()) {
      current = make_shared<long>(boost::any_cast<long>(m["Current"]));
    }
    if (m.find("DbName") != m.end() && !m["DbName"].empty()) {
      dbName = make_shared<string>(boost::any_cast<string>(m["DbName"]));
    }
    if (m.find("DynamicSql") != m.end() && !m["DynamicSql"].empty()) {
      dynamicSql = make_shared<bool>(boost::any_cast<bool>(m["DynamicSql"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("FilterCondition") != m.end() && !m["FilterCondition"].empty()) {
      filterCondition = make_shared<string>(boost::any_cast<string>(m["FilterCondition"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("MergeDynamicSql") != m.end() && !m["MergeDynamicSql"].empty()) {
      mergeDynamicSql = make_shared<bool>(boost::any_cast<bool>(m["MergeDynamicSql"]));
    }
    if (m.find("NodeIp") != m.end() && !m["NodeIp"].empty()) {
      nodeIp = make_shared<string>(boost::any_cast<string>(m["NodeIp"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SearchKeyWord") != m.end() && !m["SearchKeyWord"].empty()) {
      searchKeyWord = make_shared<string>(boost::any_cast<string>(m["SearchKeyWord"]));
    }
    if (m.find("SearchParam") != m.end() && !m["SearchParam"].empty()) {
      searchParam = make_shared<string>(boost::any_cast<string>(m["SearchParam"]));
    }
    if (m.find("SearchRule") != m.end() && !m["SearchRule"].empty()) {
      searchRule = make_shared<string>(boost::any_cast<string>(m["SearchRule"]));
    }
    if (m.find("SearchValue") != m.end() && !m["SearchValue"].empty()) {
      searchValue = make_shared<string>(boost::any_cast<string>(m["SearchValue"]));
    }
    if (m.find("SqlId") != m.end() && !m["SqlId"].empty()) {
      sqlId = make_shared<string>(boost::any_cast<string>(m["SqlId"]));
    }
    if (m.find("SqlTextLength") != m.end() && !m["SqlTextLength"].empty()) {
      sqlTextLength = make_shared<long>(boost::any_cast<long>(m["SqlTextLength"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["TenantId"]));
    }
  }


  virtual ~DescribeOasAnomalySQLListRequest() = default;
};
class DescribeOasAnomalySQLListResponseBodyDataSqlList : public Darabonba::Model {
public:
  shared_ptr<double> avgCpuTime{};
  shared_ptr<double> avgDbTime{};
  shared_ptr<double> avgElapsedTime{};
  shared_ptr<double> avgGetPlanTime{};
  shared_ptr<double> avgLogicalReads{};
  shared_ptr<double> avgRetryCount{};
  shared_ptr<double> cpuTime{};
  shared_ptr<string> dbName{};
  shared_ptr<vector<string>> diagTypes{};
  shared_ptr<string> diagnosis{};
  shared_ptr<double> executions{};
  shared_ptr<double> lastExecutedTime{};
  shared_ptr<string> riskLevel{};
  shared_ptr<string> sqlId{};
  shared_ptr<string> sqlTextShort{};
  shared_ptr<string> suggestion{};
  shared_ptr<double> sumDbTime{};
  shared_ptr<string> sumElapsedTime{};
  shared_ptr<double> sumRetryCount{};
  shared_ptr<string> userName{};

  DescribeOasAnomalySQLListResponseBodyDataSqlList() {}

  explicit DescribeOasAnomalySQLListResponseBodyDataSqlList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (avgCpuTime) {
      res["AvgCpuTime"] = boost::any(*avgCpuTime);
    }
    if (avgDbTime) {
      res["AvgDbTime"] = boost::any(*avgDbTime);
    }
    if (avgElapsedTime) {
      res["AvgElapsedTime"] = boost::any(*avgElapsedTime);
    }
    if (avgGetPlanTime) {
      res["AvgGetPlanTime"] = boost::any(*avgGetPlanTime);
    }
    if (avgLogicalReads) {
      res["AvgLogicalReads"] = boost::any(*avgLogicalReads);
    }
    if (avgRetryCount) {
      res["AvgRetryCount"] = boost::any(*avgRetryCount);
    }
    if (cpuTime) {
      res["CpuTime"] = boost::any(*cpuTime);
    }
    if (dbName) {
      res["DbName"] = boost::any(*dbName);
    }
    if (diagTypes) {
      res["DiagTypes"] = boost::any(*diagTypes);
    }
    if (diagnosis) {
      res["Diagnosis"] = boost::any(*diagnosis);
    }
    if (executions) {
      res["Executions"] = boost::any(*executions);
    }
    if (lastExecutedTime) {
      res["LastExecutedTime"] = boost::any(*lastExecutedTime);
    }
    if (riskLevel) {
      res["RiskLevel"] = boost::any(*riskLevel);
    }
    if (sqlId) {
      res["SqlId"] = boost::any(*sqlId);
    }
    if (sqlTextShort) {
      res["SqlTextShort"] = boost::any(*sqlTextShort);
    }
    if (suggestion) {
      res["Suggestion"] = boost::any(*suggestion);
    }
    if (sumDbTime) {
      res["SumDbTime"] = boost::any(*sumDbTime);
    }
    if (sumElapsedTime) {
      res["SumElapsedTime"] = boost::any(*sumElapsedTime);
    }
    if (sumRetryCount) {
      res["SumRetryCount"] = boost::any(*sumRetryCount);
    }
    if (userName) {
      res["UserName"] = boost::any(*userName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AvgCpuTime") != m.end() && !m["AvgCpuTime"].empty()) {
      avgCpuTime = make_shared<double>(boost::any_cast<double>(m["AvgCpuTime"]));
    }
    if (m.find("AvgDbTime") != m.end() && !m["AvgDbTime"].empty()) {
      avgDbTime = make_shared<double>(boost::any_cast<double>(m["AvgDbTime"]));
    }
    if (m.find("AvgElapsedTime") != m.end() && !m["AvgElapsedTime"].empty()) {
      avgElapsedTime = make_shared<double>(boost::any_cast<double>(m["AvgElapsedTime"]));
    }
    if (m.find("AvgGetPlanTime") != m.end() && !m["AvgGetPlanTime"].empty()) {
      avgGetPlanTime = make_shared<double>(boost::any_cast<double>(m["AvgGetPlanTime"]));
    }
    if (m.find("AvgLogicalReads") != m.end() && !m["AvgLogicalReads"].empty()) {
      avgLogicalReads = make_shared<double>(boost::any_cast<double>(m["AvgLogicalReads"]));
    }
    if (m.find("AvgRetryCount") != m.end() && !m["AvgRetryCount"].empty()) {
      avgRetryCount = make_shared<double>(boost::any_cast<double>(m["AvgRetryCount"]));
    }
    if (m.find("CpuTime") != m.end() && !m["CpuTime"].empty()) {
      cpuTime = make_shared<double>(boost::any_cast<double>(m["CpuTime"]));
    }
    if (m.find("DbName") != m.end() && !m["DbName"].empty()) {
      dbName = make_shared<string>(boost::any_cast<string>(m["DbName"]));
    }
    if (m.find("DiagTypes") != m.end() && !m["DiagTypes"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DiagTypes"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DiagTypes"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      diagTypes = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Diagnosis") != m.end() && !m["Diagnosis"].empty()) {
      diagnosis = make_shared<string>(boost::any_cast<string>(m["Diagnosis"]));
    }
    if (m.find("Executions") != m.end() && !m["Executions"].empty()) {
      executions = make_shared<double>(boost::any_cast<double>(m["Executions"]));
    }
    if (m.find("LastExecutedTime") != m.end() && !m["LastExecutedTime"].empty()) {
      lastExecutedTime = make_shared<double>(boost::any_cast<double>(m["LastExecutedTime"]));
    }
    if (m.find("RiskLevel") != m.end() && !m["RiskLevel"].empty()) {
      riskLevel = make_shared<string>(boost::any_cast<string>(m["RiskLevel"]));
    }
    if (m.find("SqlId") != m.end() && !m["SqlId"].empty()) {
      sqlId = make_shared<string>(boost::any_cast<string>(m["SqlId"]));
    }
    if (m.find("SqlTextShort") != m.end() && !m["SqlTextShort"].empty()) {
      sqlTextShort = make_shared<string>(boost::any_cast<string>(m["SqlTextShort"]));
    }
    if (m.find("Suggestion") != m.end() && !m["Suggestion"].empty()) {
      suggestion = make_shared<string>(boost::any_cast<string>(m["Suggestion"]));
    }
    if (m.find("SumDbTime") != m.end() && !m["SumDbTime"].empty()) {
      sumDbTime = make_shared<double>(boost::any_cast<double>(m["SumDbTime"]));
    }
    if (m.find("SumElapsedTime") != m.end() && !m["SumElapsedTime"].empty()) {
      sumElapsedTime = make_shared<string>(boost::any_cast<string>(m["SumElapsedTime"]));
    }
    if (m.find("SumRetryCount") != m.end() && !m["SumRetryCount"].empty()) {
      sumRetryCount = make_shared<double>(boost::any_cast<double>(m["SumRetryCount"]));
    }
    if (m.find("UserName") != m.end() && !m["UserName"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["UserName"]));
    }
  }


  virtual ~DescribeOasAnomalySQLListResponseBodyDataSqlList() = default;
};
class DescribeOasAnomalySQLListResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<double> avgCpuTime{};
  shared_ptr<double> avgDbTime{};
  shared_ptr<double> avgElapsedTime{};
  shared_ptr<double> avgGetPlanTime{};
  shared_ptr<double> avgLogicalReads{};
  shared_ptr<double> avgRetryCount{};
  shared_ptr<double> cpuTime{};
  shared_ptr<string> dbName{};
  shared_ptr<vector<string>> diagTypes{};
  shared_ptr<string> diagnosis{};
  shared_ptr<bool> dynamicSql{};
  shared_ptr<double> executions{};
  shared_ptr<double> lastExecutedTime{};
  shared_ptr<string> riskLevel{};
  shared_ptr<string> sqlId{};
  shared_ptr<vector<DescribeOasAnomalySQLListResponseBodyDataSqlList>> sqlList{};
  shared_ptr<string> sqlTextShort{};
  shared_ptr<string> suggestion{};
  shared_ptr<double> sumDbTime{};
  shared_ptr<string> sumElapsedTime{};
  shared_ptr<double> sumRetryCount{};
  shared_ptr<string> userName{};

  DescribeOasAnomalySQLListResponseBodyData() {}

  explicit DescribeOasAnomalySQLListResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (avgCpuTime) {
      res["AvgCpuTime"] = boost::any(*avgCpuTime);
    }
    if (avgDbTime) {
      res["AvgDbTime"] = boost::any(*avgDbTime);
    }
    if (avgElapsedTime) {
      res["AvgElapsedTime"] = boost::any(*avgElapsedTime);
    }
    if (avgGetPlanTime) {
      res["AvgGetPlanTime"] = boost::any(*avgGetPlanTime);
    }
    if (avgLogicalReads) {
      res["AvgLogicalReads"] = boost::any(*avgLogicalReads);
    }
    if (avgRetryCount) {
      res["AvgRetryCount"] = boost::any(*avgRetryCount);
    }
    if (cpuTime) {
      res["CpuTime"] = boost::any(*cpuTime);
    }
    if (dbName) {
      res["DbName"] = boost::any(*dbName);
    }
    if (diagTypes) {
      res["DiagTypes"] = boost::any(*diagTypes);
    }
    if (diagnosis) {
      res["Diagnosis"] = boost::any(*diagnosis);
    }
    if (dynamicSql) {
      res["DynamicSql"] = boost::any(*dynamicSql);
    }
    if (executions) {
      res["Executions"] = boost::any(*executions);
    }
    if (lastExecutedTime) {
      res["LastExecutedTime"] = boost::any(*lastExecutedTime);
    }
    if (riskLevel) {
      res["RiskLevel"] = boost::any(*riskLevel);
    }
    if (sqlId) {
      res["SqlId"] = boost::any(*sqlId);
    }
    if (sqlList) {
      vector<boost::any> temp1;
      for(auto item1:*sqlList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SqlList"] = boost::any(temp1);
    }
    if (sqlTextShort) {
      res["SqlTextShort"] = boost::any(*sqlTextShort);
    }
    if (suggestion) {
      res["Suggestion"] = boost::any(*suggestion);
    }
    if (sumDbTime) {
      res["SumDbTime"] = boost::any(*sumDbTime);
    }
    if (sumElapsedTime) {
      res["SumElapsedTime"] = boost::any(*sumElapsedTime);
    }
    if (sumRetryCount) {
      res["SumRetryCount"] = boost::any(*sumRetryCount);
    }
    if (userName) {
      res["UserName"] = boost::any(*userName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AvgCpuTime") != m.end() && !m["AvgCpuTime"].empty()) {
      avgCpuTime = make_shared<double>(boost::any_cast<double>(m["AvgCpuTime"]));
    }
    if (m.find("AvgDbTime") != m.end() && !m["AvgDbTime"].empty()) {
      avgDbTime = make_shared<double>(boost::any_cast<double>(m["AvgDbTime"]));
    }
    if (m.find("AvgElapsedTime") != m.end() && !m["AvgElapsedTime"].empty()) {
      avgElapsedTime = make_shared<double>(boost::any_cast<double>(m["AvgElapsedTime"]));
    }
    if (m.find("AvgGetPlanTime") != m.end() && !m["AvgGetPlanTime"].empty()) {
      avgGetPlanTime = make_shared<double>(boost::any_cast<double>(m["AvgGetPlanTime"]));
    }
    if (m.find("AvgLogicalReads") != m.end() && !m["AvgLogicalReads"].empty()) {
      avgLogicalReads = make_shared<double>(boost::any_cast<double>(m["AvgLogicalReads"]));
    }
    if (m.find("AvgRetryCount") != m.end() && !m["AvgRetryCount"].empty()) {
      avgRetryCount = make_shared<double>(boost::any_cast<double>(m["AvgRetryCount"]));
    }
    if (m.find("CpuTime") != m.end() && !m["CpuTime"].empty()) {
      cpuTime = make_shared<double>(boost::any_cast<double>(m["CpuTime"]));
    }
    if (m.find("DbName") != m.end() && !m["DbName"].empty()) {
      dbName = make_shared<string>(boost::any_cast<string>(m["DbName"]));
    }
    if (m.find("DiagTypes") != m.end() && !m["DiagTypes"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DiagTypes"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DiagTypes"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      diagTypes = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Diagnosis") != m.end() && !m["Diagnosis"].empty()) {
      diagnosis = make_shared<string>(boost::any_cast<string>(m["Diagnosis"]));
    }
    if (m.find("DynamicSql") != m.end() && !m["DynamicSql"].empty()) {
      dynamicSql = make_shared<bool>(boost::any_cast<bool>(m["DynamicSql"]));
    }
    if (m.find("Executions") != m.end() && !m["Executions"].empty()) {
      executions = make_shared<double>(boost::any_cast<double>(m["Executions"]));
    }
    if (m.find("LastExecutedTime") != m.end() && !m["LastExecutedTime"].empty()) {
      lastExecutedTime = make_shared<double>(boost::any_cast<double>(m["LastExecutedTime"]));
    }
    if (m.find("RiskLevel") != m.end() && !m["RiskLevel"].empty()) {
      riskLevel = make_shared<string>(boost::any_cast<string>(m["RiskLevel"]));
    }
    if (m.find("SqlId") != m.end() && !m["SqlId"].empty()) {
      sqlId = make_shared<string>(boost::any_cast<string>(m["SqlId"]));
    }
    if (m.find("SqlList") != m.end() && !m["SqlList"].empty()) {
      if (typeid(vector<boost::any>) == m["SqlList"].type()) {
        vector<DescribeOasAnomalySQLListResponseBodyDataSqlList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SqlList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeOasAnomalySQLListResponseBodyDataSqlList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        sqlList = make_shared<vector<DescribeOasAnomalySQLListResponseBodyDataSqlList>>(expect1);
      }
    }
    if (m.find("SqlTextShort") != m.end() && !m["SqlTextShort"].empty()) {
      sqlTextShort = make_shared<string>(boost::any_cast<string>(m["SqlTextShort"]));
    }
    if (m.find("Suggestion") != m.end() && !m["Suggestion"].empty()) {
      suggestion = make_shared<string>(boost::any_cast<string>(m["Suggestion"]));
    }
    if (m.find("SumDbTime") != m.end() && !m["SumDbTime"].empty()) {
      sumDbTime = make_shared<double>(boost::any_cast<double>(m["SumDbTime"]));
    }
    if (m.find("SumElapsedTime") != m.end() && !m["SumElapsedTime"].empty()) {
      sumElapsedTime = make_shared<string>(boost::any_cast<string>(m["SumElapsedTime"]));
    }
    if (m.find("SumRetryCount") != m.end() && !m["SumRetryCount"].empty()) {
      sumRetryCount = make_shared<double>(boost::any_cast<double>(m["SumRetryCount"]));
    }
    if (m.find("UserName") != m.end() && !m["UserName"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["UserName"]));
    }
  }


  virtual ~DescribeOasAnomalySQLListResponseBodyData() = default;
};
class DescribeOasAnomalySQLListResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeOasAnomalySQLListResponseBodyData>> data{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  DescribeOasAnomalySQLListResponseBody() {}

  explicit DescribeOasAnomalySQLListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<DescribeOasAnomalySQLListResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeOasAnomalySQLListResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<DescribeOasAnomalySQLListResponseBodyData>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeOasAnomalySQLListResponseBody() = default;
};
class DescribeOasAnomalySQLListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeOasAnomalySQLListResponseBody> body{};

  DescribeOasAnomalySQLListResponse() {}

  explicit DescribeOasAnomalySQLListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeOasAnomalySQLListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeOasAnomalySQLListResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeOasAnomalySQLListResponse() = default;
};
class DescribeOasSQLDetailsRequest : public Darabonba::Model {
public:
  shared_ptr<string> dbName{};
  shared_ptr<bool> dynamicSql{};
  shared_ptr<string> endTime{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> sqlId{};
  shared_ptr<string> startTime{};
  shared_ptr<string> tenantId{};

  DescribeOasSQLDetailsRequest() {}

  explicit DescribeOasSQLDetailsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dbName) {
      res["DbName"] = boost::any(*dbName);
    }
    if (dynamicSql) {
      res["DynamicSql"] = boost::any(*dynamicSql);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (sqlId) {
      res["SqlId"] = boost::any(*sqlId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DbName") != m.end() && !m["DbName"].empty()) {
      dbName = make_shared<string>(boost::any_cast<string>(m["DbName"]));
    }
    if (m.find("DynamicSql") != m.end() && !m["DynamicSql"].empty()) {
      dynamicSql = make_shared<bool>(boost::any_cast<bool>(m["DynamicSql"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("SqlId") != m.end() && !m["SqlId"].empty()) {
      sqlId = make_shared<string>(boost::any_cast<string>(m["SqlId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["TenantId"]));
    }
  }


  virtual ~DescribeOasSQLDetailsRequest() = default;
};
class DescribeOasSQLDetailsResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> dbName{};
  shared_ptr<string> fulltext{};
  shared_ptr<string> statement{};
  shared_ptr<vector<string>> tables{};
  shared_ptr<string> userName{};

  DescribeOasSQLDetailsResponseBodyData() {}

  explicit DescribeOasSQLDetailsResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dbName) {
      res["DbName"] = boost::any(*dbName);
    }
    if (fulltext) {
      res["Fulltext"] = boost::any(*fulltext);
    }
    if (statement) {
      res["Statement"] = boost::any(*statement);
    }
    if (tables) {
      res["Tables"] = boost::any(*tables);
    }
    if (userName) {
      res["UserName"] = boost::any(*userName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DbName") != m.end() && !m["DbName"].empty()) {
      dbName = make_shared<string>(boost::any_cast<string>(m["DbName"]));
    }
    if (m.find("Fulltext") != m.end() && !m["Fulltext"].empty()) {
      fulltext = make_shared<string>(boost::any_cast<string>(m["Fulltext"]));
    }
    if (m.find("Statement") != m.end() && !m["Statement"].empty()) {
      statement = make_shared<string>(boost::any_cast<string>(m["Statement"]));
    }
    if (m.find("Tables") != m.end() && !m["Tables"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Tables"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Tables"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      tables = make_shared<vector<string>>(toVec1);
    }
    if (m.find("UserName") != m.end() && !m["UserName"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["UserName"]));
    }
  }


  virtual ~DescribeOasSQLDetailsResponseBodyData() = default;
};
class DescribeOasSQLDetailsResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeOasSQLDetailsResponseBodyData> data{};
  shared_ptr<string> requestId{};

  DescribeOasSQLDetailsResponseBody() {}

  explicit DescribeOasSQLDetailsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        DescribeOasSQLDetailsResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<DescribeOasSQLDetailsResponseBodyData>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeOasSQLDetailsResponseBody() = default;
};
class DescribeOasSQLDetailsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeOasSQLDetailsResponseBody> body{};

  DescribeOasSQLDetailsResponse() {}

  explicit DescribeOasSQLDetailsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeOasSQLDetailsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeOasSQLDetailsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeOasSQLDetailsResponse() = default;
};
class DescribeOasSQLHistoryListRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<string> dbName{};
  shared_ptr<bool> dynamicSql{};
  shared_ptr<string> endTime{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> nodeIp{};
  shared_ptr<string> sqlId{};
  shared_ptr<string> startTime{};
  shared_ptr<string> tenantId{};

  DescribeOasSQLHistoryListRequest() {}

  explicit DescribeOasSQLHistoryListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (dbName) {
      res["DbName"] = boost::any(*dbName);
    }
    if (dynamicSql) {
      res["DynamicSql"] = boost::any(*dynamicSql);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (nodeIp) {
      res["NodeIp"] = boost::any(*nodeIp);
    }
    if (sqlId) {
      res["SqlId"] = boost::any(*sqlId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("DbName") != m.end() && !m["DbName"].empty()) {
      dbName = make_shared<string>(boost::any_cast<string>(m["DbName"]));
    }
    if (m.find("DynamicSql") != m.end() && !m["DynamicSql"].empty()) {
      dynamicSql = make_shared<bool>(boost::any_cast<bool>(m["DynamicSql"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("NodeIp") != m.end() && !m["NodeIp"].empty()) {
      nodeIp = make_shared<string>(boost::any_cast<string>(m["NodeIp"]));
    }
    if (m.find("SqlId") != m.end() && !m["SqlId"].empty()) {
      sqlId = make_shared<string>(boost::any_cast<string>(m["SqlId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["TenantId"]));
    }
  }


  virtual ~DescribeOasSQLHistoryListRequest() = default;
};
class DescribeOasSQLHistoryListResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> avgAffectedRows{};
  shared_ptr<double> avgApplicationWaitTime{};
  shared_ptr<long> avgBlockCacheHit{};
  shared_ptr<long> avgBlockIndexCacheHit{};
  shared_ptr<long> avgBloomFilterCacheHit{};
  shared_ptr<double> avgConcurrencyWaitTime{};
  shared_ptr<double> avgCpuTime{};
  shared_ptr<double> avgDbTime{};
  shared_ptr<double> avgDecodeTime{};
  shared_ptr<long> avgDiskReads{};
  shared_ptr<double> avgElapsedTime{};
  shared_ptr<double> avgExecuteTime{};
  shared_ptr<double> avgExecutorRpcCount{};
  shared_ptr<double> avgExpectedWorkerCount{};
  shared_ptr<double> avgGetPlanTime{};
  shared_ptr<long> avgLogicalReads{};
  shared_ptr<long> avgMemstoreReadRows{};
  shared_ptr<double> avgNetTime{};
  shared_ptr<double> avgNetWaitTime{};
  shared_ptr<double> avgPartitionCount{};
  shared_ptr<double> avgQueueTime{};
  shared_ptr<long> avgReturnRows{};
  shared_ptr<long> avgRowCacheHit{};
  shared_ptr<long> avgRpcCount{};
  shared_ptr<double> avgScheduleTime{};
  shared_ptr<long> avgSsstoreReadRows{};
  shared_ptr<double> avgUsedWorkerCount{};
  shared_ptr<double> avgUserIoWaitTime{};
  shared_ptr<double> avgWaitCount{};
  shared_ptr<double> avgWaitTime{};
  shared_ptr<string> dbName{};
  shared_ptr<double> distPlanPercentage{};
  shared_ptr<double> execPs{};
  shared_ptr<long> executions{};
  shared_ptr<long> failCount{};
  shared_ptr<double> failPercentage{};
  shared_ptr<double> localPlanPercentage{};
  shared_ptr<double> maxAffectedRows{};
  shared_ptr<double> maxApplicationWaitTime{};
  shared_ptr<double> maxConcurrencyWaitTime{};
  shared_ptr<double> maxCpuTime{};
  shared_ptr<double> maxDiskReads{};
  shared_ptr<double> maxElapsedTime{};
  shared_ptr<double> maxReturnRows{};
  shared_ptr<double> maxUserIoWaitTime{};
  shared_ptr<double> maxWaitTime{};
  shared_ptr<double> missPlanPercentage{};
  shared_ptr<long> missPlans{};
  shared_ptr<double> remotePlanPercentage{};
  shared_ptr<long> remotePlans{};
  shared_ptr<double> retCode4012Count{};
  shared_ptr<double> retCode4013Count{};
  shared_ptr<double> retCode5001Count{};
  shared_ptr<double> retCode5024Count{};
  shared_ptr<double> retCode5167Count{};
  shared_ptr<double> retCode5217Count{};
  shared_ptr<double> retCode6002Count{};
  shared_ptr<long> retryCount{};
  shared_ptr<string> SQLId{};
  shared_ptr<string> server{};
  shared_ptr<double> strongConsistencyPercentage{};
  shared_ptr<double> sumDbTime{};
  shared_ptr<double> sumElapsedTime{};
  shared_ptr<double> sumLogicalReads{};
  shared_ptr<double> sumWaitTime{};
  shared_ptr<double> tableScanPercentage{};
  shared_ptr<string> timestamp{};
  shared_ptr<string> userName{};
  shared_ptr<double> weakConsistencyPercentage{};

  DescribeOasSQLHistoryListResponseBodyData() {}

  explicit DescribeOasSQLHistoryListResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (avgAffectedRows) {
      res["AvgAffectedRows"] = boost::any(*avgAffectedRows);
    }
    if (avgApplicationWaitTime) {
      res["AvgApplicationWaitTime"] = boost::any(*avgApplicationWaitTime);
    }
    if (avgBlockCacheHit) {
      res["AvgBlockCacheHit"] = boost::any(*avgBlockCacheHit);
    }
    if (avgBlockIndexCacheHit) {
      res["AvgBlockIndexCacheHit"] = boost::any(*avgBlockIndexCacheHit);
    }
    if (avgBloomFilterCacheHit) {
      res["AvgBloomFilterCacheHit"] = boost::any(*avgBloomFilterCacheHit);
    }
    if (avgConcurrencyWaitTime) {
      res["AvgConcurrencyWaitTime"] = boost::any(*avgConcurrencyWaitTime);
    }
    if (avgCpuTime) {
      res["AvgCpuTime"] = boost::any(*avgCpuTime);
    }
    if (avgDbTime) {
      res["AvgDbTime"] = boost::any(*avgDbTime);
    }
    if (avgDecodeTime) {
      res["AvgDecodeTime"] = boost::any(*avgDecodeTime);
    }
    if (avgDiskReads) {
      res["AvgDiskReads"] = boost::any(*avgDiskReads);
    }
    if (avgElapsedTime) {
      res["AvgElapsedTime"] = boost::any(*avgElapsedTime);
    }
    if (avgExecuteTime) {
      res["AvgExecuteTime"] = boost::any(*avgExecuteTime);
    }
    if (avgExecutorRpcCount) {
      res["AvgExecutorRpcCount"] = boost::any(*avgExecutorRpcCount);
    }
    if (avgExpectedWorkerCount) {
      res["AvgExpectedWorkerCount"] = boost::any(*avgExpectedWorkerCount);
    }
    if (avgGetPlanTime) {
      res["AvgGetPlanTime"] = boost::any(*avgGetPlanTime);
    }
    if (avgLogicalReads) {
      res["AvgLogicalReads"] = boost::any(*avgLogicalReads);
    }
    if (avgMemstoreReadRows) {
      res["AvgMemstoreReadRows"] = boost::any(*avgMemstoreReadRows);
    }
    if (avgNetTime) {
      res["AvgNetTime"] = boost::any(*avgNetTime);
    }
    if (avgNetWaitTime) {
      res["AvgNetWaitTime"] = boost::any(*avgNetWaitTime);
    }
    if (avgPartitionCount) {
      res["AvgPartitionCount"] = boost::any(*avgPartitionCount);
    }
    if (avgQueueTime) {
      res["AvgQueueTime"] = boost::any(*avgQueueTime);
    }
    if (avgReturnRows) {
      res["AvgReturnRows"] = boost::any(*avgReturnRows);
    }
    if (avgRowCacheHit) {
      res["AvgRowCacheHit"] = boost::any(*avgRowCacheHit);
    }
    if (avgRpcCount) {
      res["AvgRpcCount"] = boost::any(*avgRpcCount);
    }
    if (avgScheduleTime) {
      res["AvgScheduleTime"] = boost::any(*avgScheduleTime);
    }
    if (avgSsstoreReadRows) {
      res["AvgSsstoreReadRows"] = boost::any(*avgSsstoreReadRows);
    }
    if (avgUsedWorkerCount) {
      res["AvgUsedWorkerCount"] = boost::any(*avgUsedWorkerCount);
    }
    if (avgUserIoWaitTime) {
      res["AvgUserIoWaitTime"] = boost::any(*avgUserIoWaitTime);
    }
    if (avgWaitCount) {
      res["AvgWaitCount"] = boost::any(*avgWaitCount);
    }
    if (avgWaitTime) {
      res["AvgWaitTime"] = boost::any(*avgWaitTime);
    }
    if (dbName) {
      res["DbName"] = boost::any(*dbName);
    }
    if (distPlanPercentage) {
      res["DistPlanPercentage"] = boost::any(*distPlanPercentage);
    }
    if (execPs) {
      res["ExecPs"] = boost::any(*execPs);
    }
    if (executions) {
      res["Executions"] = boost::any(*executions);
    }
    if (failCount) {
      res["FailCount"] = boost::any(*failCount);
    }
    if (failPercentage) {
      res["FailPercentage"] = boost::any(*failPercentage);
    }
    if (localPlanPercentage) {
      res["LocalPlanPercentage"] = boost::any(*localPlanPercentage);
    }
    if (maxAffectedRows) {
      res["MaxAffectedRows"] = boost::any(*maxAffectedRows);
    }
    if (maxApplicationWaitTime) {
      res["MaxApplicationWaitTime"] = boost::any(*maxApplicationWaitTime);
    }
    if (maxConcurrencyWaitTime) {
      res["MaxConcurrencyWaitTime"] = boost::any(*maxConcurrencyWaitTime);
    }
    if (maxCpuTime) {
      res["MaxCpuTime"] = boost::any(*maxCpuTime);
    }
    if (maxDiskReads) {
      res["MaxDiskReads"] = boost::any(*maxDiskReads);
    }
    if (maxElapsedTime) {
      res["MaxElapsedTime"] = boost::any(*maxElapsedTime);
    }
    if (maxReturnRows) {
      res["MaxReturnRows"] = boost::any(*maxReturnRows);
    }
    if (maxUserIoWaitTime) {
      res["MaxUserIoWaitTime"] = boost::any(*maxUserIoWaitTime);
    }
    if (maxWaitTime) {
      res["MaxWaitTime"] = boost::any(*maxWaitTime);
    }
    if (missPlanPercentage) {
      res["MissPlanPercentage"] = boost::any(*missPlanPercentage);
    }
    if (missPlans) {
      res["MissPlans"] = boost::any(*missPlans);
    }
    if (remotePlanPercentage) {
      res["RemotePlanPercentage"] = boost::any(*remotePlanPercentage);
    }
    if (remotePlans) {
      res["RemotePlans"] = boost::any(*remotePlans);
    }
    if (retCode4012Count) {
      res["RetCode4012Count"] = boost::any(*retCode4012Count);
    }
    if (retCode4013Count) {
      res["RetCode4013Count"] = boost::any(*retCode4013Count);
    }
    if (retCode5001Count) {
      res["RetCode5001Count"] = boost::any(*retCode5001Count);
    }
    if (retCode5024Count) {
      res["RetCode5024Count"] = boost::any(*retCode5024Count);
    }
    if (retCode5167Count) {
      res["RetCode5167Count"] = boost::any(*retCode5167Count);
    }
    if (retCode5217Count) {
      res["RetCode5217Count"] = boost::any(*retCode5217Count);
    }
    if (retCode6002Count) {
      res["RetCode6002Count"] = boost::any(*retCode6002Count);
    }
    if (retryCount) {
      res["RetryCount"] = boost::any(*retryCount);
    }
    if (SQLId) {
      res["SQLId"] = boost::any(*SQLId);
    }
    if (server) {
      res["Server"] = boost::any(*server);
    }
    if (strongConsistencyPercentage) {
      res["StrongConsistencyPercentage"] = boost::any(*strongConsistencyPercentage);
    }
    if (sumDbTime) {
      res["SumDbTime"] = boost::any(*sumDbTime);
    }
    if (sumElapsedTime) {
      res["SumElapsedTime"] = boost::any(*sumElapsedTime);
    }
    if (sumLogicalReads) {
      res["SumLogicalReads"] = boost::any(*sumLogicalReads);
    }
    if (sumWaitTime) {
      res["SumWaitTime"] = boost::any(*sumWaitTime);
    }
    if (tableScanPercentage) {
      res["TableScanPercentage"] = boost::any(*tableScanPercentage);
    }
    if (timestamp) {
      res["Timestamp"] = boost::any(*timestamp);
    }
    if (userName) {
      res["UserName"] = boost::any(*userName);
    }
    if (weakConsistencyPercentage) {
      res["WeakConsistencyPercentage"] = boost::any(*weakConsistencyPercentage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AvgAffectedRows") != m.end() && !m["AvgAffectedRows"].empty()) {
      avgAffectedRows = make_shared<long>(boost::any_cast<long>(m["AvgAffectedRows"]));
    }
    if (m.find("AvgApplicationWaitTime") != m.end() && !m["AvgApplicationWaitTime"].empty()) {
      avgApplicationWaitTime = make_shared<double>(boost::any_cast<double>(m["AvgApplicationWaitTime"]));
    }
    if (m.find("AvgBlockCacheHit") != m.end() && !m["AvgBlockCacheHit"].empty()) {
      avgBlockCacheHit = make_shared<long>(boost::any_cast<long>(m["AvgBlockCacheHit"]));
    }
    if (m.find("AvgBlockIndexCacheHit") != m.end() && !m["AvgBlockIndexCacheHit"].empty()) {
      avgBlockIndexCacheHit = make_shared<long>(boost::any_cast<long>(m["AvgBlockIndexCacheHit"]));
    }
    if (m.find("AvgBloomFilterCacheHit") != m.end() && !m["AvgBloomFilterCacheHit"].empty()) {
      avgBloomFilterCacheHit = make_shared<long>(boost::any_cast<long>(m["AvgBloomFilterCacheHit"]));
    }
    if (m.find("AvgConcurrencyWaitTime") != m.end() && !m["AvgConcurrencyWaitTime"].empty()) {
      avgConcurrencyWaitTime = make_shared<double>(boost::any_cast<double>(m["AvgConcurrencyWaitTime"]));
    }
    if (m.find("AvgCpuTime") != m.end() && !m["AvgCpuTime"].empty()) {
      avgCpuTime = make_shared<double>(boost::any_cast<double>(m["AvgCpuTime"]));
    }
    if (m.find("AvgDbTime") != m.end() && !m["AvgDbTime"].empty()) {
      avgDbTime = make_shared<double>(boost::any_cast<double>(m["AvgDbTime"]));
    }
    if (m.find("AvgDecodeTime") != m.end() && !m["AvgDecodeTime"].empty()) {
      avgDecodeTime = make_shared<double>(boost::any_cast<double>(m["AvgDecodeTime"]));
    }
    if (m.find("AvgDiskReads") != m.end() && !m["AvgDiskReads"].empty()) {
      avgDiskReads = make_shared<long>(boost::any_cast<long>(m["AvgDiskReads"]));
    }
    if (m.find("AvgElapsedTime") != m.end() && !m["AvgElapsedTime"].empty()) {
      avgElapsedTime = make_shared<double>(boost::any_cast<double>(m["AvgElapsedTime"]));
    }
    if (m.find("AvgExecuteTime") != m.end() && !m["AvgExecuteTime"].empty()) {
      avgExecuteTime = make_shared<double>(boost::any_cast<double>(m["AvgExecuteTime"]));
    }
    if (m.find("AvgExecutorRpcCount") != m.end() && !m["AvgExecutorRpcCount"].empty()) {
      avgExecutorRpcCount = make_shared<double>(boost::any_cast<double>(m["AvgExecutorRpcCount"]));
    }
    if (m.find("AvgExpectedWorkerCount") != m.end() && !m["AvgExpectedWorkerCount"].empty()) {
      avgExpectedWorkerCount = make_shared<double>(boost::any_cast<double>(m["AvgExpectedWorkerCount"]));
    }
    if (m.find("AvgGetPlanTime") != m.end() && !m["AvgGetPlanTime"].empty()) {
      avgGetPlanTime = make_shared<double>(boost::any_cast<double>(m["AvgGetPlanTime"]));
    }
    if (m.find("AvgLogicalReads") != m.end() && !m["AvgLogicalReads"].empty()) {
      avgLogicalReads = make_shared<long>(boost::any_cast<long>(m["AvgLogicalReads"]));
    }
    if (m.find("AvgMemstoreReadRows") != m.end() && !m["AvgMemstoreReadRows"].empty()) {
      avgMemstoreReadRows = make_shared<long>(boost::any_cast<long>(m["AvgMemstoreReadRows"]));
    }
    if (m.find("AvgNetTime") != m.end() && !m["AvgNetTime"].empty()) {
      avgNetTime = make_shared<double>(boost::any_cast<double>(m["AvgNetTime"]));
    }
    if (m.find("AvgNetWaitTime") != m.end() && !m["AvgNetWaitTime"].empty()) {
      avgNetWaitTime = make_shared<double>(boost::any_cast<double>(m["AvgNetWaitTime"]));
    }
    if (m.find("AvgPartitionCount") != m.end() && !m["AvgPartitionCount"].empty()) {
      avgPartitionCount = make_shared<double>(boost::any_cast<double>(m["AvgPartitionCount"]));
    }
    if (m.find("AvgQueueTime") != m.end() && !m["AvgQueueTime"].empty()) {
      avgQueueTime = make_shared<double>(boost::any_cast<double>(m["AvgQueueTime"]));
    }
    if (m.find("AvgReturnRows") != m.end() && !m["AvgReturnRows"].empty()) {
      avgReturnRows = make_shared<long>(boost::any_cast<long>(m["AvgReturnRows"]));
    }
    if (m.find("AvgRowCacheHit") != m.end() && !m["AvgRowCacheHit"].empty()) {
      avgRowCacheHit = make_shared<long>(boost::any_cast<long>(m["AvgRowCacheHit"]));
    }
    if (m.find("AvgRpcCount") != m.end() && !m["AvgRpcCount"].empty()) {
      avgRpcCount = make_shared<long>(boost::any_cast<long>(m["AvgRpcCount"]));
    }
    if (m.find("AvgScheduleTime") != m.end() && !m["AvgScheduleTime"].empty()) {
      avgScheduleTime = make_shared<double>(boost::any_cast<double>(m["AvgScheduleTime"]));
    }
    if (m.find("AvgSsstoreReadRows") != m.end() && !m["AvgSsstoreReadRows"].empty()) {
      avgSsstoreReadRows = make_shared<long>(boost::any_cast<long>(m["AvgSsstoreReadRows"]));
    }
    if (m.find("AvgUsedWorkerCount") != m.end() && !m["AvgUsedWorkerCount"].empty()) {
      avgUsedWorkerCount = make_shared<double>(boost::any_cast<double>(m["AvgUsedWorkerCount"]));
    }
    if (m.find("AvgUserIoWaitTime") != m.end() && !m["AvgUserIoWaitTime"].empty()) {
      avgUserIoWaitTime = make_shared<double>(boost::any_cast<double>(m["AvgUserIoWaitTime"]));
    }
    if (m.find("AvgWaitCount") != m.end() && !m["AvgWaitCount"].empty()) {
      avgWaitCount = make_shared<double>(boost::any_cast<double>(m["AvgWaitCount"]));
    }
    if (m.find("AvgWaitTime") != m.end() && !m["AvgWaitTime"].empty()) {
      avgWaitTime = make_shared<double>(boost::any_cast<double>(m["AvgWaitTime"]));
    }
    if (m.find("DbName") != m.end() && !m["DbName"].empty()) {
      dbName = make_shared<string>(boost::any_cast<string>(m["DbName"]));
    }
    if (m.find("DistPlanPercentage") != m.end() && !m["DistPlanPercentage"].empty()) {
      distPlanPercentage = make_shared<double>(boost::any_cast<double>(m["DistPlanPercentage"]));
    }
    if (m.find("ExecPs") != m.end() && !m["ExecPs"].empty()) {
      execPs = make_shared<double>(boost::any_cast<double>(m["ExecPs"]));
    }
    if (m.find("Executions") != m.end() && !m["Executions"].empty()) {
      executions = make_shared<long>(boost::any_cast<long>(m["Executions"]));
    }
    if (m.find("FailCount") != m.end() && !m["FailCount"].empty()) {
      failCount = make_shared<long>(boost::any_cast<long>(m["FailCount"]));
    }
    if (m.find("FailPercentage") != m.end() && !m["FailPercentage"].empty()) {
      failPercentage = make_shared<double>(boost::any_cast<double>(m["FailPercentage"]));
    }
    if (m.find("LocalPlanPercentage") != m.end() && !m["LocalPlanPercentage"].empty()) {
      localPlanPercentage = make_shared<double>(boost::any_cast<double>(m["LocalPlanPercentage"]));
    }
    if (m.find("MaxAffectedRows") != m.end() && !m["MaxAffectedRows"].empty()) {
      maxAffectedRows = make_shared<double>(boost::any_cast<double>(m["MaxAffectedRows"]));
    }
    if (m.find("MaxApplicationWaitTime") != m.end() && !m["MaxApplicationWaitTime"].empty()) {
      maxApplicationWaitTime = make_shared<double>(boost::any_cast<double>(m["MaxApplicationWaitTime"]));
    }
    if (m.find("MaxConcurrencyWaitTime") != m.end() && !m["MaxConcurrencyWaitTime"].empty()) {
      maxConcurrencyWaitTime = make_shared<double>(boost::any_cast<double>(m["MaxConcurrencyWaitTime"]));
    }
    if (m.find("MaxCpuTime") != m.end() && !m["MaxCpuTime"].empty()) {
      maxCpuTime = make_shared<double>(boost::any_cast<double>(m["MaxCpuTime"]));
    }
    if (m.find("MaxDiskReads") != m.end() && !m["MaxDiskReads"].empty()) {
      maxDiskReads = make_shared<double>(boost::any_cast<double>(m["MaxDiskReads"]));
    }
    if (m.find("MaxElapsedTime") != m.end() && !m["MaxElapsedTime"].empty()) {
      maxElapsedTime = make_shared<double>(boost::any_cast<double>(m["MaxElapsedTime"]));
    }
    if (m.find("MaxReturnRows") != m.end() && !m["MaxReturnRows"].empty()) {
      maxReturnRows = make_shared<double>(boost::any_cast<double>(m["MaxReturnRows"]));
    }
    if (m.find("MaxUserIoWaitTime") != m.end() && !m["MaxUserIoWaitTime"].empty()) {
      maxUserIoWaitTime = make_shared<double>(boost::any_cast<double>(m["MaxUserIoWaitTime"]));
    }
    if (m.find("MaxWaitTime") != m.end() && !m["MaxWaitTime"].empty()) {
      maxWaitTime = make_shared<double>(boost::any_cast<double>(m["MaxWaitTime"]));
    }
    if (m.find("MissPlanPercentage") != m.end() && !m["MissPlanPercentage"].empty()) {
      missPlanPercentage = make_shared<double>(boost::any_cast<double>(m["MissPlanPercentage"]));
    }
    if (m.find("MissPlans") != m.end() && !m["MissPlans"].empty()) {
      missPlans = make_shared<long>(boost::any_cast<long>(m["MissPlans"]));
    }
    if (m.find("RemotePlanPercentage") != m.end() && !m["RemotePlanPercentage"].empty()) {
      remotePlanPercentage = make_shared<double>(boost::any_cast<double>(m["RemotePlanPercentage"]));
    }
    if (m.find("RemotePlans") != m.end() && !m["RemotePlans"].empty()) {
      remotePlans = make_shared<long>(boost::any_cast<long>(m["RemotePlans"]));
    }
    if (m.find("RetCode4012Count") != m.end() && !m["RetCode4012Count"].empty()) {
      retCode4012Count = make_shared<double>(boost::any_cast<double>(m["RetCode4012Count"]));
    }
    if (m.find("RetCode4013Count") != m.end() && !m["RetCode4013Count"].empty()) {
      retCode4013Count = make_shared<double>(boost::any_cast<double>(m["RetCode4013Count"]));
    }
    if (m.find("RetCode5001Count") != m.end() && !m["RetCode5001Count"].empty()) {
      retCode5001Count = make_shared<double>(boost::any_cast<double>(m["RetCode5001Count"]));
    }
    if (m.find("RetCode5024Count") != m.end() && !m["RetCode5024Count"].empty()) {
      retCode5024Count = make_shared<double>(boost::any_cast<double>(m["RetCode5024Count"]));
    }
    if (m.find("RetCode5167Count") != m.end() && !m["RetCode5167Count"].empty()) {
      retCode5167Count = make_shared<double>(boost::any_cast<double>(m["RetCode5167Count"]));
    }
    if (m.find("RetCode5217Count") != m.end() && !m["RetCode5217Count"].empty()) {
      retCode5217Count = make_shared<double>(boost::any_cast<double>(m["RetCode5217Count"]));
    }
    if (m.find("RetCode6002Count") != m.end() && !m["RetCode6002Count"].empty()) {
      retCode6002Count = make_shared<double>(boost::any_cast<double>(m["RetCode6002Count"]));
    }
    if (m.find("RetryCount") != m.end() && !m["RetryCount"].empty()) {
      retryCount = make_shared<long>(boost::any_cast<long>(m["RetryCount"]));
    }
    if (m.find("SQLId") != m.end() && !m["SQLId"].empty()) {
      SQLId = make_shared<string>(boost::any_cast<string>(m["SQLId"]));
    }
    if (m.find("Server") != m.end() && !m["Server"].empty()) {
      server = make_shared<string>(boost::any_cast<string>(m["Server"]));
    }
    if (m.find("StrongConsistencyPercentage") != m.end() && !m["StrongConsistencyPercentage"].empty()) {
      strongConsistencyPercentage = make_shared<double>(boost::any_cast<double>(m["StrongConsistencyPercentage"]));
    }
    if (m.find("SumDbTime") != m.end() && !m["SumDbTime"].empty()) {
      sumDbTime = make_shared<double>(boost::any_cast<double>(m["SumDbTime"]));
    }
    if (m.find("SumElapsedTime") != m.end() && !m["SumElapsedTime"].empty()) {
      sumElapsedTime = make_shared<double>(boost::any_cast<double>(m["SumElapsedTime"]));
    }
    if (m.find("SumLogicalReads") != m.end() && !m["SumLogicalReads"].empty()) {
      sumLogicalReads = make_shared<double>(boost::any_cast<double>(m["SumLogicalReads"]));
    }
    if (m.find("SumWaitTime") != m.end() && !m["SumWaitTime"].empty()) {
      sumWaitTime = make_shared<double>(boost::any_cast<double>(m["SumWaitTime"]));
    }
    if (m.find("TableScanPercentage") != m.end() && !m["TableScanPercentage"].empty()) {
      tableScanPercentage = make_shared<double>(boost::any_cast<double>(m["TableScanPercentage"]));
    }
    if (m.find("Timestamp") != m.end() && !m["Timestamp"].empty()) {
      timestamp = make_shared<string>(boost::any_cast<string>(m["Timestamp"]));
    }
    if (m.find("UserName") != m.end() && !m["UserName"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["UserName"]));
    }
    if (m.find("WeakConsistencyPercentage") != m.end() && !m["WeakConsistencyPercentage"].empty()) {
      weakConsistencyPercentage = make_shared<double>(boost::any_cast<double>(m["WeakConsistencyPercentage"]));
    }
  }


  virtual ~DescribeOasSQLHistoryListResponseBodyData() = default;
};
class DescribeOasSQLHistoryListResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeOasSQLHistoryListResponseBodyData>> data{};
  shared_ptr<string> requestId{};

  DescribeOasSQLHistoryListResponseBody() {}

  explicit DescribeOasSQLHistoryListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<DescribeOasSQLHistoryListResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeOasSQLHistoryListResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<DescribeOasSQLHistoryListResponseBodyData>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeOasSQLHistoryListResponseBody() = default;
};
class DescribeOasSQLHistoryListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeOasSQLHistoryListResponseBody> body{};

  DescribeOasSQLHistoryListResponse() {}

  explicit DescribeOasSQLHistoryListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeOasSQLHistoryListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeOasSQLHistoryListResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeOasSQLHistoryListResponse() = default;
};
class DescribeOasSQLPlansRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<string> dbName{};
  shared_ptr<bool> dynamicSql{};
  shared_ptr<string> endTime{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> sqlId{};
  shared_ptr<string> startTime{};
  shared_ptr<string> tenantId{};

  DescribeOasSQLPlansRequest() {}

  explicit DescribeOasSQLPlansRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (dbName) {
      res["DbName"] = boost::any(*dbName);
    }
    if (dynamicSql) {
      res["DynamicSql"] = boost::any(*dynamicSql);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (sqlId) {
      res["SqlId"] = boost::any(*sqlId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("DbName") != m.end() && !m["DbName"].empty()) {
      dbName = make_shared<string>(boost::any_cast<string>(m["DbName"]));
    }
    if (m.find("DynamicSql") != m.end() && !m["DynamicSql"].empty()) {
      dynamicSql = make_shared<bool>(boost::any_cast<bool>(m["DynamicSql"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("SqlId") != m.end() && !m["SqlId"].empty()) {
      sqlId = make_shared<string>(boost::any_cast<string>(m["SqlId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["TenantId"]));
    }
  }


  virtual ~DescribeOasSQLPlansRequest() = default;
};
class DescribeOasSQLPlansResponseBodyDataPlanExplain : public Darabonba::Model {
public:
  shared_ptr<string> planJsonString{};

  DescribeOasSQLPlansResponseBodyDataPlanExplain() {}

  explicit DescribeOasSQLPlansResponseBodyDataPlanExplain(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (planJsonString) {
      res["PlanJsonString"] = boost::any(*planJsonString);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PlanJsonString") != m.end() && !m["PlanJsonString"].empty()) {
      planJsonString = make_shared<string>(boost::any_cast<string>(m["PlanJsonString"]));
    }
  }


  virtual ~DescribeOasSQLPlansResponseBodyDataPlanExplain() = default;
};
class DescribeOasSQLPlansResponseBodyDataPlans : public Darabonba::Model {
public:
  shared_ptr<double> avgApplicationWaitTime{};
  shared_ptr<double> avgBufferGets{};
  shared_ptr<double> avgConcurrencyWaitTime{};
  shared_ptr<double> avgCpuTime{};
  shared_ptr<double> avgDiskReads{};
  shared_ptr<double> avgDiskWrites{};
  shared_ptr<double> avgElapsedTime{};
  shared_ptr<double> avgRowProcessed{};
  shared_ptr<double> avgUserIoWaitTime{};
  shared_ptr<long> collectTimeUs{};
  shared_ptr<double> delayedLargeQueryPercentage{};
  shared_ptr<double> execPs{};
  shared_ptr<long> executions{};
  shared_ptr<string> firstLoadTime{};
  shared_ptr<long> firstLoadTimeUs{};
  shared_ptr<bool> hitDiagnosis{};
  shared_ptr<double> hitPercentage{};
  shared_ptr<double> largeQueryPercentage{};
  shared_ptr<long> mergedVersion{};
  shared_ptr<long> obDbId{};
  shared_ptr<long> obServerId{};
  shared_ptr<string> outlineData{};
  shared_ptr<long> outlineId{};
  shared_ptr<string> planHash{};
  shared_ptr<long> planId{};
  shared_ptr<long> planSize{};
  shared_ptr<string> planType{};
  shared_ptr<string> planUnionHash{};
  shared_ptr<long> schemaVersion{};
  shared_ptr<string> server{};
  shared_ptr<long> serverId{};
  shared_ptr<string> sqlId{};
  shared_ptr<bool> tableScan{};
  shared_ptr<double> timeoutPercentage{};
  shared_ptr<string> uid{};

  DescribeOasSQLPlansResponseBodyDataPlans() {}

  explicit DescribeOasSQLPlansResponseBodyDataPlans(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (avgApplicationWaitTime) {
      res["AvgApplicationWaitTime"] = boost::any(*avgApplicationWaitTime);
    }
    if (avgBufferGets) {
      res["AvgBufferGets"] = boost::any(*avgBufferGets);
    }
    if (avgConcurrencyWaitTime) {
      res["AvgConcurrencyWaitTime"] = boost::any(*avgConcurrencyWaitTime);
    }
    if (avgCpuTime) {
      res["AvgCpuTime"] = boost::any(*avgCpuTime);
    }
    if (avgDiskReads) {
      res["AvgDiskReads"] = boost::any(*avgDiskReads);
    }
    if (avgDiskWrites) {
      res["AvgDiskWrites"] = boost::any(*avgDiskWrites);
    }
    if (avgElapsedTime) {
      res["AvgElapsedTime"] = boost::any(*avgElapsedTime);
    }
    if (avgRowProcessed) {
      res["AvgRowProcessed"] = boost::any(*avgRowProcessed);
    }
    if (avgUserIoWaitTime) {
      res["AvgUserIoWaitTime"] = boost::any(*avgUserIoWaitTime);
    }
    if (collectTimeUs) {
      res["CollectTimeUs"] = boost::any(*collectTimeUs);
    }
    if (delayedLargeQueryPercentage) {
      res["DelayedLargeQueryPercentage"] = boost::any(*delayedLargeQueryPercentage);
    }
    if (execPs) {
      res["ExecPs"] = boost::any(*execPs);
    }
    if (executions) {
      res["Executions"] = boost::any(*executions);
    }
    if (firstLoadTime) {
      res["FirstLoadTime"] = boost::any(*firstLoadTime);
    }
    if (firstLoadTimeUs) {
      res["FirstLoadTimeUs"] = boost::any(*firstLoadTimeUs);
    }
    if (hitDiagnosis) {
      res["HitDiagnosis"] = boost::any(*hitDiagnosis);
    }
    if (hitPercentage) {
      res["HitPercentage"] = boost::any(*hitPercentage);
    }
    if (largeQueryPercentage) {
      res["LargeQueryPercentage"] = boost::any(*largeQueryPercentage);
    }
    if (mergedVersion) {
      res["MergedVersion"] = boost::any(*mergedVersion);
    }
    if (obDbId) {
      res["ObDbId"] = boost::any(*obDbId);
    }
    if (obServerId) {
      res["ObServerId"] = boost::any(*obServerId);
    }
    if (outlineData) {
      res["OutlineData"] = boost::any(*outlineData);
    }
    if (outlineId) {
      res["OutlineId"] = boost::any(*outlineId);
    }
    if (planHash) {
      res["PlanHash"] = boost::any(*planHash);
    }
    if (planId) {
      res["PlanId"] = boost::any(*planId);
    }
    if (planSize) {
      res["PlanSize"] = boost::any(*planSize);
    }
    if (planType) {
      res["PlanType"] = boost::any(*planType);
    }
    if (planUnionHash) {
      res["PlanUnionHash"] = boost::any(*planUnionHash);
    }
    if (schemaVersion) {
      res["SchemaVersion"] = boost::any(*schemaVersion);
    }
    if (server) {
      res["Server"] = boost::any(*server);
    }
    if (serverId) {
      res["ServerId"] = boost::any(*serverId);
    }
    if (sqlId) {
      res["SqlId"] = boost::any(*sqlId);
    }
    if (tableScan) {
      res["TableScan"] = boost::any(*tableScan);
    }
    if (timeoutPercentage) {
      res["TimeoutPercentage"] = boost::any(*timeoutPercentage);
    }
    if (uid) {
      res["Uid"] = boost::any(*uid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AvgApplicationWaitTime") != m.end() && !m["AvgApplicationWaitTime"].empty()) {
      avgApplicationWaitTime = make_shared<double>(boost::any_cast<double>(m["AvgApplicationWaitTime"]));
    }
    if (m.find("AvgBufferGets") != m.end() && !m["AvgBufferGets"].empty()) {
      avgBufferGets = make_shared<double>(boost::any_cast<double>(m["AvgBufferGets"]));
    }
    if (m.find("AvgConcurrencyWaitTime") != m.end() && !m["AvgConcurrencyWaitTime"].empty()) {
      avgConcurrencyWaitTime = make_shared<double>(boost::any_cast<double>(m["AvgConcurrencyWaitTime"]));
    }
    if (m.find("AvgCpuTime") != m.end() && !m["AvgCpuTime"].empty()) {
      avgCpuTime = make_shared<double>(boost::any_cast<double>(m["AvgCpuTime"]));
    }
    if (m.find("AvgDiskReads") != m.end() && !m["AvgDiskReads"].empty()) {
      avgDiskReads = make_shared<double>(boost::any_cast<double>(m["AvgDiskReads"]));
    }
    if (m.find("AvgDiskWrites") != m.end() && !m["AvgDiskWrites"].empty()) {
      avgDiskWrites = make_shared<double>(boost::any_cast<double>(m["AvgDiskWrites"]));
    }
    if (m.find("AvgElapsedTime") != m.end() && !m["AvgElapsedTime"].empty()) {
      avgElapsedTime = make_shared<double>(boost::any_cast<double>(m["AvgElapsedTime"]));
    }
    if (m.find("AvgRowProcessed") != m.end() && !m["AvgRowProcessed"].empty()) {
      avgRowProcessed = make_shared<double>(boost::any_cast<double>(m["AvgRowProcessed"]));
    }
    if (m.find("AvgUserIoWaitTime") != m.end() && !m["AvgUserIoWaitTime"].empty()) {
      avgUserIoWaitTime = make_shared<double>(boost::any_cast<double>(m["AvgUserIoWaitTime"]));
    }
    if (m.find("CollectTimeUs") != m.end() && !m["CollectTimeUs"].empty()) {
      collectTimeUs = make_shared<long>(boost::any_cast<long>(m["CollectTimeUs"]));
    }
    if (m.find("DelayedLargeQueryPercentage") != m.end() && !m["DelayedLargeQueryPercentage"].empty()) {
      delayedLargeQueryPercentage = make_shared<double>(boost::any_cast<double>(m["DelayedLargeQueryPercentage"]));
    }
    if (m.find("ExecPs") != m.end() && !m["ExecPs"].empty()) {
      execPs = make_shared<double>(boost::any_cast<double>(m["ExecPs"]));
    }
    if (m.find("Executions") != m.end() && !m["Executions"].empty()) {
      executions = make_shared<long>(boost::any_cast<long>(m["Executions"]));
    }
    if (m.find("FirstLoadTime") != m.end() && !m["FirstLoadTime"].empty()) {
      firstLoadTime = make_shared<string>(boost::any_cast<string>(m["FirstLoadTime"]));
    }
    if (m.find("FirstLoadTimeUs") != m.end() && !m["FirstLoadTimeUs"].empty()) {
      firstLoadTimeUs = make_shared<long>(boost::any_cast<long>(m["FirstLoadTimeUs"]));
    }
    if (m.find("HitDiagnosis") != m.end() && !m["HitDiagnosis"].empty()) {
      hitDiagnosis = make_shared<bool>(boost::any_cast<bool>(m["HitDiagnosis"]));
    }
    if (m.find("HitPercentage") != m.end() && !m["HitPercentage"].empty()) {
      hitPercentage = make_shared<double>(boost::any_cast<double>(m["HitPercentage"]));
    }
    if (m.find("LargeQueryPercentage") != m.end() && !m["LargeQueryPercentage"].empty()) {
      largeQueryPercentage = make_shared<double>(boost::any_cast<double>(m["LargeQueryPercentage"]));
    }
    if (m.find("MergedVersion") != m.end() && !m["MergedVersion"].empty()) {
      mergedVersion = make_shared<long>(boost::any_cast<long>(m["MergedVersion"]));
    }
    if (m.find("ObDbId") != m.end() && !m["ObDbId"].empty()) {
      obDbId = make_shared<long>(boost::any_cast<long>(m["ObDbId"]));
    }
    if (m.find("ObServerId") != m.end() && !m["ObServerId"].empty()) {
      obServerId = make_shared<long>(boost::any_cast<long>(m["ObServerId"]));
    }
    if (m.find("OutlineData") != m.end() && !m["OutlineData"].empty()) {
      outlineData = make_shared<string>(boost::any_cast<string>(m["OutlineData"]));
    }
    if (m.find("OutlineId") != m.end() && !m["OutlineId"].empty()) {
      outlineId = make_shared<long>(boost::any_cast<long>(m["OutlineId"]));
    }
    if (m.find("PlanHash") != m.end() && !m["PlanHash"].empty()) {
      planHash = make_shared<string>(boost::any_cast<string>(m["PlanHash"]));
    }
    if (m.find("PlanId") != m.end() && !m["PlanId"].empty()) {
      planId = make_shared<long>(boost::any_cast<long>(m["PlanId"]));
    }
    if (m.find("PlanSize") != m.end() && !m["PlanSize"].empty()) {
      planSize = make_shared<long>(boost::any_cast<long>(m["PlanSize"]));
    }
    if (m.find("PlanType") != m.end() && !m["PlanType"].empty()) {
      planType = make_shared<string>(boost::any_cast<string>(m["PlanType"]));
    }
    if (m.find("PlanUnionHash") != m.end() && !m["PlanUnionHash"].empty()) {
      planUnionHash = make_shared<string>(boost::any_cast<string>(m["PlanUnionHash"]));
    }
    if (m.find("SchemaVersion") != m.end() && !m["SchemaVersion"].empty()) {
      schemaVersion = make_shared<long>(boost::any_cast<long>(m["SchemaVersion"]));
    }
    if (m.find("Server") != m.end() && !m["Server"].empty()) {
      server = make_shared<string>(boost::any_cast<string>(m["Server"]));
    }
    if (m.find("ServerId") != m.end() && !m["ServerId"].empty()) {
      serverId = make_shared<long>(boost::any_cast<long>(m["ServerId"]));
    }
    if (m.find("SqlId") != m.end() && !m["SqlId"].empty()) {
      sqlId = make_shared<string>(boost::any_cast<string>(m["SqlId"]));
    }
    if (m.find("TableScan") != m.end() && !m["TableScan"].empty()) {
      tableScan = make_shared<bool>(boost::any_cast<bool>(m["TableScan"]));
    }
    if (m.find("TimeoutPercentage") != m.end() && !m["TimeoutPercentage"].empty()) {
      timeoutPercentage = make_shared<double>(boost::any_cast<double>(m["TimeoutPercentage"]));
    }
    if (m.find("Uid") != m.end() && !m["Uid"].empty()) {
      uid = make_shared<string>(boost::any_cast<string>(m["Uid"]));
    }
  }


  virtual ~DescribeOasSQLPlansResponseBodyDataPlans() = default;
};
class DescribeOasSQLPlansResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<double> avgCpuTime{};
  shared_ptr<bool> bounded{};
  shared_ptr<long> executions{};
  shared_ptr<string> firstLoadTime{};
  shared_ptr<bool> hitDiagnosis{};
  shared_ptr<double> hitPercentage{};
  shared_ptr<long> mergedVersion{};
  shared_ptr<DescribeOasSQLPlansResponseBodyDataPlanExplain> planExplain{};
  shared_ptr<string> planHash{};
  shared_ptr<string> planType{};
  shared_ptr<string> planUnionHash{};
  shared_ptr<vector<DescribeOasSQLPlansResponseBodyDataPlans>> plans{};
  shared_ptr<string> querySql{};

  DescribeOasSQLPlansResponseBodyData() {}

  explicit DescribeOasSQLPlansResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (avgCpuTime) {
      res["AvgCpuTime"] = boost::any(*avgCpuTime);
    }
    if (bounded) {
      res["Bounded"] = boost::any(*bounded);
    }
    if (executions) {
      res["Executions"] = boost::any(*executions);
    }
    if (firstLoadTime) {
      res["FirstLoadTime"] = boost::any(*firstLoadTime);
    }
    if (hitDiagnosis) {
      res["HitDiagnosis"] = boost::any(*hitDiagnosis);
    }
    if (hitPercentage) {
      res["HitPercentage"] = boost::any(*hitPercentage);
    }
    if (mergedVersion) {
      res["MergedVersion"] = boost::any(*mergedVersion);
    }
    if (planExplain) {
      res["PlanExplain"] = planExplain ? boost::any(planExplain->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (planHash) {
      res["PlanHash"] = boost::any(*planHash);
    }
    if (planType) {
      res["PlanType"] = boost::any(*planType);
    }
    if (planUnionHash) {
      res["PlanUnionHash"] = boost::any(*planUnionHash);
    }
    if (plans) {
      vector<boost::any> temp1;
      for(auto item1:*plans){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Plans"] = boost::any(temp1);
    }
    if (querySql) {
      res["QuerySql"] = boost::any(*querySql);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AvgCpuTime") != m.end() && !m["AvgCpuTime"].empty()) {
      avgCpuTime = make_shared<double>(boost::any_cast<double>(m["AvgCpuTime"]));
    }
    if (m.find("Bounded") != m.end() && !m["Bounded"].empty()) {
      bounded = make_shared<bool>(boost::any_cast<bool>(m["Bounded"]));
    }
    if (m.find("Executions") != m.end() && !m["Executions"].empty()) {
      executions = make_shared<long>(boost::any_cast<long>(m["Executions"]));
    }
    if (m.find("FirstLoadTime") != m.end() && !m["FirstLoadTime"].empty()) {
      firstLoadTime = make_shared<string>(boost::any_cast<string>(m["FirstLoadTime"]));
    }
    if (m.find("HitDiagnosis") != m.end() && !m["HitDiagnosis"].empty()) {
      hitDiagnosis = make_shared<bool>(boost::any_cast<bool>(m["HitDiagnosis"]));
    }
    if (m.find("HitPercentage") != m.end() && !m["HitPercentage"].empty()) {
      hitPercentage = make_shared<double>(boost::any_cast<double>(m["HitPercentage"]));
    }
    if (m.find("MergedVersion") != m.end() && !m["MergedVersion"].empty()) {
      mergedVersion = make_shared<long>(boost::any_cast<long>(m["MergedVersion"]));
    }
    if (m.find("PlanExplain") != m.end() && !m["PlanExplain"].empty()) {
      if (typeid(map<string, boost::any>) == m["PlanExplain"].type()) {
        DescribeOasSQLPlansResponseBodyDataPlanExplain model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PlanExplain"]));
        planExplain = make_shared<DescribeOasSQLPlansResponseBodyDataPlanExplain>(model1);
      }
    }
    if (m.find("PlanHash") != m.end() && !m["PlanHash"].empty()) {
      planHash = make_shared<string>(boost::any_cast<string>(m["PlanHash"]));
    }
    if (m.find("PlanType") != m.end() && !m["PlanType"].empty()) {
      planType = make_shared<string>(boost::any_cast<string>(m["PlanType"]));
    }
    if (m.find("PlanUnionHash") != m.end() && !m["PlanUnionHash"].empty()) {
      planUnionHash = make_shared<string>(boost::any_cast<string>(m["PlanUnionHash"]));
    }
    if (m.find("Plans") != m.end() && !m["Plans"].empty()) {
      if (typeid(vector<boost::any>) == m["Plans"].type()) {
        vector<DescribeOasSQLPlansResponseBodyDataPlans> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Plans"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeOasSQLPlansResponseBodyDataPlans model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        plans = make_shared<vector<DescribeOasSQLPlansResponseBodyDataPlans>>(expect1);
      }
    }
    if (m.find("QuerySql") != m.end() && !m["QuerySql"].empty()) {
      querySql = make_shared<string>(boost::any_cast<string>(m["QuerySql"]));
    }
  }


  virtual ~DescribeOasSQLPlansResponseBodyData() = default;
};
class DescribeOasSQLPlansResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeOasSQLPlansResponseBodyData>> data{};
  shared_ptr<string> requestId{};

  DescribeOasSQLPlansResponseBody() {}

  explicit DescribeOasSQLPlansResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<DescribeOasSQLPlansResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeOasSQLPlansResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<DescribeOasSQLPlansResponseBodyData>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeOasSQLPlansResponseBody() = default;
};
class DescribeOasSQLPlansResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeOasSQLPlansResponseBody> body{};

  DescribeOasSQLPlansResponse() {}

  explicit DescribeOasSQLPlansResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeOasSQLPlansResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeOasSQLPlansResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeOasSQLPlansResponse() = default;
};
class DescribeOasSlowSQLListRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<string> dbName{};
  shared_ptr<bool> dynamicSql{};
  shared_ptr<string> endTime{};
  shared_ptr<string> filterCondition{};
  shared_ptr<string> instanceId{};
  shared_ptr<bool> mergeDynamicSql{};
  shared_ptr<string> nodeIp{};
  shared_ptr<string> searchKeyWord{};
  shared_ptr<string> searchParam{};
  shared_ptr<string> searchRule{};
  shared_ptr<string> searchValue{};
  shared_ptr<string> sqlId{};
  shared_ptr<long> sqlTextLength{};
  shared_ptr<string> startTime{};
  shared_ptr<string> tenantId{};

  DescribeOasSlowSQLListRequest() {}

  explicit DescribeOasSlowSQLListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (dbName) {
      res["DbName"] = boost::any(*dbName);
    }
    if (dynamicSql) {
      res["DynamicSql"] = boost::any(*dynamicSql);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (filterCondition) {
      res["FilterCondition"] = boost::any(*filterCondition);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (mergeDynamicSql) {
      res["MergeDynamicSql"] = boost::any(*mergeDynamicSql);
    }
    if (nodeIp) {
      res["NodeIp"] = boost::any(*nodeIp);
    }
    if (searchKeyWord) {
      res["SearchKeyWord"] = boost::any(*searchKeyWord);
    }
    if (searchParam) {
      res["SearchParam"] = boost::any(*searchParam);
    }
    if (searchRule) {
      res["SearchRule"] = boost::any(*searchRule);
    }
    if (searchValue) {
      res["SearchValue"] = boost::any(*searchValue);
    }
    if (sqlId) {
      res["SqlId"] = boost::any(*sqlId);
    }
    if (sqlTextLength) {
      res["SqlTextLength"] = boost::any(*sqlTextLength);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("DbName") != m.end() && !m["DbName"].empty()) {
      dbName = make_shared<string>(boost::any_cast<string>(m["DbName"]));
    }
    if (m.find("DynamicSql") != m.end() && !m["DynamicSql"].empty()) {
      dynamicSql = make_shared<bool>(boost::any_cast<bool>(m["DynamicSql"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("FilterCondition") != m.end() && !m["FilterCondition"].empty()) {
      filterCondition = make_shared<string>(boost::any_cast<string>(m["FilterCondition"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("MergeDynamicSql") != m.end() && !m["MergeDynamicSql"].empty()) {
      mergeDynamicSql = make_shared<bool>(boost::any_cast<bool>(m["MergeDynamicSql"]));
    }
    if (m.find("NodeIp") != m.end() && !m["NodeIp"].empty()) {
      nodeIp = make_shared<string>(boost::any_cast<string>(m["NodeIp"]));
    }
    if (m.find("SearchKeyWord") != m.end() && !m["SearchKeyWord"].empty()) {
      searchKeyWord = make_shared<string>(boost::any_cast<string>(m["SearchKeyWord"]));
    }
    if (m.find("SearchParam") != m.end() && !m["SearchParam"].empty()) {
      searchParam = make_shared<string>(boost::any_cast<string>(m["SearchParam"]));
    }
    if (m.find("SearchRule") != m.end() && !m["SearchRule"].empty()) {
      searchRule = make_shared<string>(boost::any_cast<string>(m["SearchRule"]));
    }
    if (m.find("SearchValue") != m.end() && !m["SearchValue"].empty()) {
      searchValue = make_shared<string>(boost::any_cast<string>(m["SearchValue"]));
    }
    if (m.find("SqlId") != m.end() && !m["SqlId"].empty()) {
      sqlId = make_shared<string>(boost::any_cast<string>(m["SqlId"]));
    }
    if (m.find("SqlTextLength") != m.end() && !m["SqlTextLength"].empty()) {
      sqlTextLength = make_shared<long>(boost::any_cast<long>(m["SqlTextLength"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["TenantId"]));
    }
  }


  virtual ~DescribeOasSlowSQLListRequest() = default;
};
class DescribeOasSlowSQLListResponseBodyDataSqlList : public Darabonba::Model {
public:
  shared_ptr<double> avgAffectedRows{};
  shared_ptr<double> avgApplicationWaitTime{};
  shared_ptr<double> avgBlockCacheHit{};
  shared_ptr<double> avgBlockIndexCacheHit{};
  shared_ptr<double> avgBloomFilterCacheHit{};
  shared_ptr<double> avgConcurrencyWaitTime{};
  shared_ptr<double> avgCpuTime{};
  shared_ptr<double> avgDbTime{};
  shared_ptr<double> avgDecodeTime{};
  shared_ptr<double> avgDiskReads{};
  shared_ptr<double> avgElapsedTime{};
  shared_ptr<double> avgExecuteTime{};
  shared_ptr<double> avgExecutorRpcCount{};
  shared_ptr<double> avgExpectedWorkerCount{};
  shared_ptr<double> avgGetPlanTime{};
  shared_ptr<double> avgLogicalReads{};
  shared_ptr<double> avgMemstoreReadRows{};
  shared_ptr<double> avgNetTime{};
  shared_ptr<double> avgNetWaitTime{};
  shared_ptr<double> avgPartitionCount{};
  shared_ptr<double> avgQueueTime{};
  shared_ptr<double> avgReturnRows{};
  shared_ptr<double> avgRowCacheHit{};
  shared_ptr<double> avgRpcCount{};
  shared_ptr<double> avgScheduleTime{};
  shared_ptr<double> avgSsstoreReadRows{};
  shared_ptr<double> avgUsedWorkerCount{};
  shared_ptr<double> avgUserIoWaitTime{};
  shared_ptr<double> avgWaitCount{};
  shared_ptr<double> avgWaitTime{};
  shared_ptr<string> clientIp{};
  shared_ptr<string> dbName{};
  shared_ptr<double> distPlanPercentage{};
  shared_ptr<double> execPs{};
  shared_ptr<double> executions{};
  shared_ptr<double> failCount{};
  shared_ptr<double> failPercentage{};
  shared_ptr<bool> inner{};
  shared_ptr<double> localPlanPercentage{};
  shared_ptr<double> maxAffectedRows{};
  shared_ptr<double> maxApplicationWaitTime{};
  shared_ptr<double> maxConcurrencyWaitTime{};
  shared_ptr<double> maxCpuTime{};
  shared_ptr<double> maxDiskReads{};
  shared_ptr<double> maxElapsedTime{};
  shared_ptr<double> maxReturnRows{};
  shared_ptr<double> maxUserIoWaitTime{};
  shared_ptr<double> maxWaitTime{};
  shared_ptr<double> missPlanPercentage{};
  shared_ptr<double> missPlans{};
  shared_ptr<double> remotePlanPercentage{};
  shared_ptr<double> remotePlans{};
  shared_ptr<long> retCode4012Count{};
  shared_ptr<long> retCode4013Count{};
  shared_ptr<long> retCode5001Count{};
  shared_ptr<long> retCode5024Count{};
  shared_ptr<long> retCode5167Count{};
  shared_ptr<long> retCode5217Count{};
  shared_ptr<long> retCode6002Count{};
  shared_ptr<double> retryCount{};
  shared_ptr<double> rpcCount{};
  shared_ptr<string> server{};
  shared_ptr<string> serverIp{};
  shared_ptr<long> serverPort{};
  shared_ptr<string> sqlId{};
  shared_ptr<string> sqlTextShort{};
  shared_ptr<string> sqlType{};
  shared_ptr<double> strongConsistencyPercentage{};
  shared_ptr<double> sumDbTime{};
  shared_ptr<double> sumElapsedTime{};
  shared_ptr<double> sumLogicalReads{};
  shared_ptr<double> sumWaitTime{};
  shared_ptr<double> tableScanPercentage{};
  shared_ptr<double> totalWaitTime{};
  shared_ptr<string> userName{};
  shared_ptr<string> waitEvent{};
  shared_ptr<double> weakConsistencyPercentage{};

  DescribeOasSlowSQLListResponseBodyDataSqlList() {}

  explicit DescribeOasSlowSQLListResponseBodyDataSqlList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (avgAffectedRows) {
      res["AvgAffectedRows"] = boost::any(*avgAffectedRows);
    }
    if (avgApplicationWaitTime) {
      res["AvgApplicationWaitTime"] = boost::any(*avgApplicationWaitTime);
    }
    if (avgBlockCacheHit) {
      res["AvgBlockCacheHit"] = boost::any(*avgBlockCacheHit);
    }
    if (avgBlockIndexCacheHit) {
      res["AvgBlockIndexCacheHit"] = boost::any(*avgBlockIndexCacheHit);
    }
    if (avgBloomFilterCacheHit) {
      res["AvgBloomFilterCacheHit"] = boost::any(*avgBloomFilterCacheHit);
    }
    if (avgConcurrencyWaitTime) {
      res["AvgConcurrencyWaitTime"] = boost::any(*avgConcurrencyWaitTime);
    }
    if (avgCpuTime) {
      res["AvgCpuTime"] = boost::any(*avgCpuTime);
    }
    if (avgDbTime) {
      res["AvgDbTime"] = boost::any(*avgDbTime);
    }
    if (avgDecodeTime) {
      res["AvgDecodeTime"] = boost::any(*avgDecodeTime);
    }
    if (avgDiskReads) {
      res["AvgDiskReads"] = boost::any(*avgDiskReads);
    }
    if (avgElapsedTime) {
      res["AvgElapsedTime"] = boost::any(*avgElapsedTime);
    }
    if (avgExecuteTime) {
      res["AvgExecuteTime"] = boost::any(*avgExecuteTime);
    }
    if (avgExecutorRpcCount) {
      res["AvgExecutorRpcCount"] = boost::any(*avgExecutorRpcCount);
    }
    if (avgExpectedWorkerCount) {
      res["AvgExpectedWorkerCount"] = boost::any(*avgExpectedWorkerCount);
    }
    if (avgGetPlanTime) {
      res["AvgGetPlanTime"] = boost::any(*avgGetPlanTime);
    }
    if (avgLogicalReads) {
      res["AvgLogicalReads"] = boost::any(*avgLogicalReads);
    }
    if (avgMemstoreReadRows) {
      res["AvgMemstoreReadRows"] = boost::any(*avgMemstoreReadRows);
    }
    if (avgNetTime) {
      res["AvgNetTime"] = boost::any(*avgNetTime);
    }
    if (avgNetWaitTime) {
      res["AvgNetWaitTime"] = boost::any(*avgNetWaitTime);
    }
    if (avgPartitionCount) {
      res["AvgPartitionCount"] = boost::any(*avgPartitionCount);
    }
    if (avgQueueTime) {
      res["AvgQueueTime"] = boost::any(*avgQueueTime);
    }
    if (avgReturnRows) {
      res["AvgReturnRows"] = boost::any(*avgReturnRows);
    }
    if (avgRowCacheHit) {
      res["AvgRowCacheHit"] = boost::any(*avgRowCacheHit);
    }
    if (avgRpcCount) {
      res["AvgRpcCount"] = boost::any(*avgRpcCount);
    }
    if (avgScheduleTime) {
      res["AvgScheduleTime"] = boost::any(*avgScheduleTime);
    }
    if (avgSsstoreReadRows) {
      res["AvgSsstoreReadRows"] = boost::any(*avgSsstoreReadRows);
    }
    if (avgUsedWorkerCount) {
      res["AvgUsedWorkerCount"] = boost::any(*avgUsedWorkerCount);
    }
    if (avgUserIoWaitTime) {
      res["AvgUserIoWaitTime"] = boost::any(*avgUserIoWaitTime);
    }
    if (avgWaitCount) {
      res["AvgWaitCount"] = boost::any(*avgWaitCount);
    }
    if (avgWaitTime) {
      res["AvgWaitTime"] = boost::any(*avgWaitTime);
    }
    if (clientIp) {
      res["ClientIp"] = boost::any(*clientIp);
    }
    if (dbName) {
      res["DbName"] = boost::any(*dbName);
    }
    if (distPlanPercentage) {
      res["DistPlanPercentage"] = boost::any(*distPlanPercentage);
    }
    if (execPs) {
      res["ExecPs"] = boost::any(*execPs);
    }
    if (executions) {
      res["Executions"] = boost::any(*executions);
    }
    if (failCount) {
      res["FailCount"] = boost::any(*failCount);
    }
    if (failPercentage) {
      res["FailPercentage"] = boost::any(*failPercentage);
    }
    if (inner) {
      res["Inner"] = boost::any(*inner);
    }
    if (localPlanPercentage) {
      res["LocalPlanPercentage"] = boost::any(*localPlanPercentage);
    }
    if (maxAffectedRows) {
      res["MaxAffectedRows"] = boost::any(*maxAffectedRows);
    }
    if (maxApplicationWaitTime) {
      res["MaxApplicationWaitTime"] = boost::any(*maxApplicationWaitTime);
    }
    if (maxConcurrencyWaitTime) {
      res["MaxConcurrencyWaitTime"] = boost::any(*maxConcurrencyWaitTime);
    }
    if (maxCpuTime) {
      res["MaxCpuTime"] = boost::any(*maxCpuTime);
    }
    if (maxDiskReads) {
      res["MaxDiskReads"] = boost::any(*maxDiskReads);
    }
    if (maxElapsedTime) {
      res["MaxElapsedTime"] = boost::any(*maxElapsedTime);
    }
    if (maxReturnRows) {
      res["MaxReturnRows"] = boost::any(*maxReturnRows);
    }
    if (maxUserIoWaitTime) {
      res["MaxUserIoWaitTime"] = boost::any(*maxUserIoWaitTime);
    }
    if (maxWaitTime) {
      res["MaxWaitTime"] = boost::any(*maxWaitTime);
    }
    if (missPlanPercentage) {
      res["MissPlanPercentage"] = boost::any(*missPlanPercentage);
    }
    if (missPlans) {
      res["MissPlans"] = boost::any(*missPlans);
    }
    if (remotePlanPercentage) {
      res["RemotePlanPercentage"] = boost::any(*remotePlanPercentage);
    }
    if (remotePlans) {
      res["RemotePlans"] = boost::any(*remotePlans);
    }
    if (retCode4012Count) {
      res["RetCode4012Count"] = boost::any(*retCode4012Count);
    }
    if (retCode4013Count) {
      res["RetCode4013Count"] = boost::any(*retCode4013Count);
    }
    if (retCode5001Count) {
      res["RetCode5001Count"] = boost::any(*retCode5001Count);
    }
    if (retCode5024Count) {
      res["RetCode5024Count"] = boost::any(*retCode5024Count);
    }
    if (retCode5167Count) {
      res["RetCode5167Count"] = boost::any(*retCode5167Count);
    }
    if (retCode5217Count) {
      res["RetCode5217Count"] = boost::any(*retCode5217Count);
    }
    if (retCode6002Count) {
      res["RetCode6002Count"] = boost::any(*retCode6002Count);
    }
    if (retryCount) {
      res["RetryCount"] = boost::any(*retryCount);
    }
    if (rpcCount) {
      res["RpcCount"] = boost::any(*rpcCount);
    }
    if (server) {
      res["Server"] = boost::any(*server);
    }
    if (serverIp) {
      res["ServerIp"] = boost::any(*serverIp);
    }
    if (serverPort) {
      res["ServerPort"] = boost::any(*serverPort);
    }
    if (sqlId) {
      res["SqlId"] = boost::any(*sqlId);
    }
    if (sqlTextShort) {
      res["SqlTextShort"] = boost::any(*sqlTextShort);
    }
    if (sqlType) {
      res["SqlType"] = boost::any(*sqlType);
    }
    if (strongConsistencyPercentage) {
      res["StrongConsistencyPercentage"] = boost::any(*strongConsistencyPercentage);
    }
    if (sumDbTime) {
      res["SumDbTime"] = boost::any(*sumDbTime);
    }
    if (sumElapsedTime) {
      res["SumElapsedTime"] = boost::any(*sumElapsedTime);
    }
    if (sumLogicalReads) {
      res["SumLogicalReads"] = boost::any(*sumLogicalReads);
    }
    if (sumWaitTime) {
      res["SumWaitTime"] = boost::any(*sumWaitTime);
    }
    if (tableScanPercentage) {
      res["TableScanPercentage"] = boost::any(*tableScanPercentage);
    }
    if (totalWaitTime) {
      res["TotalWaitTime"] = boost::any(*totalWaitTime);
    }
    if (userName) {
      res["UserName"] = boost::any(*userName);
    }
    if (waitEvent) {
      res["WaitEvent"] = boost::any(*waitEvent);
    }
    if (weakConsistencyPercentage) {
      res["WeakConsistencyPercentage"] = boost::any(*weakConsistencyPercentage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AvgAffectedRows") != m.end() && !m["AvgAffectedRows"].empty()) {
      avgAffectedRows = make_shared<double>(boost::any_cast<double>(m["AvgAffectedRows"]));
    }
    if (m.find("AvgApplicationWaitTime") != m.end() && !m["AvgApplicationWaitTime"].empty()) {
      avgApplicationWaitTime = make_shared<double>(boost::any_cast<double>(m["AvgApplicationWaitTime"]));
    }
    if (m.find("AvgBlockCacheHit") != m.end() && !m["AvgBlockCacheHit"].empty()) {
      avgBlockCacheHit = make_shared<double>(boost::any_cast<double>(m["AvgBlockCacheHit"]));
    }
    if (m.find("AvgBlockIndexCacheHit") != m.end() && !m["AvgBlockIndexCacheHit"].empty()) {
      avgBlockIndexCacheHit = make_shared<double>(boost::any_cast<double>(m["AvgBlockIndexCacheHit"]));
    }
    if (m.find("AvgBloomFilterCacheHit") != m.end() && !m["AvgBloomFilterCacheHit"].empty()) {
      avgBloomFilterCacheHit = make_shared<double>(boost::any_cast<double>(m["AvgBloomFilterCacheHit"]));
    }
    if (m.find("AvgConcurrencyWaitTime") != m.end() && !m["AvgConcurrencyWaitTime"].empty()) {
      avgConcurrencyWaitTime = make_shared<double>(boost::any_cast<double>(m["AvgConcurrencyWaitTime"]));
    }
    if (m.find("AvgCpuTime") != m.end() && !m["AvgCpuTime"].empty()) {
      avgCpuTime = make_shared<double>(boost::any_cast<double>(m["AvgCpuTime"]));
    }
    if (m.find("AvgDbTime") != m.end() && !m["AvgDbTime"].empty()) {
      avgDbTime = make_shared<double>(boost::any_cast<double>(m["AvgDbTime"]));
    }
    if (m.find("AvgDecodeTime") != m.end() && !m["AvgDecodeTime"].empty()) {
      avgDecodeTime = make_shared<double>(boost::any_cast<double>(m["AvgDecodeTime"]));
    }
    if (m.find("AvgDiskReads") != m.end() && !m["AvgDiskReads"].empty()) {
      avgDiskReads = make_shared<double>(boost::any_cast<double>(m["AvgDiskReads"]));
    }
    if (m.find("AvgElapsedTime") != m.end() && !m["AvgElapsedTime"].empty()) {
      avgElapsedTime = make_shared<double>(boost::any_cast<double>(m["AvgElapsedTime"]));
    }
    if (m.find("AvgExecuteTime") != m.end() && !m["AvgExecuteTime"].empty()) {
      avgExecuteTime = make_shared<double>(boost::any_cast<double>(m["AvgExecuteTime"]));
    }
    if (m.find("AvgExecutorRpcCount") != m.end() && !m["AvgExecutorRpcCount"].empty()) {
      avgExecutorRpcCount = make_shared<double>(boost::any_cast<double>(m["AvgExecutorRpcCount"]));
    }
    if (m.find("AvgExpectedWorkerCount") != m.end() && !m["AvgExpectedWorkerCount"].empty()) {
      avgExpectedWorkerCount = make_shared<double>(boost::any_cast<double>(m["AvgExpectedWorkerCount"]));
    }
    if (m.find("AvgGetPlanTime") != m.end() && !m["AvgGetPlanTime"].empty()) {
      avgGetPlanTime = make_shared<double>(boost::any_cast<double>(m["AvgGetPlanTime"]));
    }
    if (m.find("AvgLogicalReads") != m.end() && !m["AvgLogicalReads"].empty()) {
      avgLogicalReads = make_shared<double>(boost::any_cast<double>(m["AvgLogicalReads"]));
    }
    if (m.find("AvgMemstoreReadRows") != m.end() && !m["AvgMemstoreReadRows"].empty()) {
      avgMemstoreReadRows = make_shared<double>(boost::any_cast<double>(m["AvgMemstoreReadRows"]));
    }
    if (m.find("AvgNetTime") != m.end() && !m["AvgNetTime"].empty()) {
      avgNetTime = make_shared<double>(boost::any_cast<double>(m["AvgNetTime"]));
    }
    if (m.find("AvgNetWaitTime") != m.end() && !m["AvgNetWaitTime"].empty()) {
      avgNetWaitTime = make_shared<double>(boost::any_cast<double>(m["AvgNetWaitTime"]));
    }
    if (m.find("AvgPartitionCount") != m.end() && !m["AvgPartitionCount"].empty()) {
      avgPartitionCount = make_shared<double>(boost::any_cast<double>(m["AvgPartitionCount"]));
    }
    if (m.find("AvgQueueTime") != m.end() && !m["AvgQueueTime"].empty()) {
      avgQueueTime = make_shared<double>(boost::any_cast<double>(m["AvgQueueTime"]));
    }
    if (m.find("AvgReturnRows") != m.end() && !m["AvgReturnRows"].empty()) {
      avgReturnRows = make_shared<double>(boost::any_cast<double>(m["AvgReturnRows"]));
    }
    if (m.find("AvgRowCacheHit") != m.end() && !m["AvgRowCacheHit"].empty()) {
      avgRowCacheHit = make_shared<double>(boost::any_cast<double>(m["AvgRowCacheHit"]));
    }
    if (m.find("AvgRpcCount") != m.end() && !m["AvgRpcCount"].empty()) {
      avgRpcCount = make_shared<double>(boost::any_cast<double>(m["AvgRpcCount"]));
    }
    if (m.find("AvgScheduleTime") != m.end() && !m["AvgScheduleTime"].empty()) {
      avgScheduleTime = make_shared<double>(boost::any_cast<double>(m["AvgScheduleTime"]));
    }
    if (m.find("AvgSsstoreReadRows") != m.end() && !m["AvgSsstoreReadRows"].empty()) {
      avgSsstoreReadRows = make_shared<double>(boost::any_cast<double>(m["AvgSsstoreReadRows"]));
    }
    if (m.find("AvgUsedWorkerCount") != m.end() && !m["AvgUsedWorkerCount"].empty()) {
      avgUsedWorkerCount = make_shared<double>(boost::any_cast<double>(m["AvgUsedWorkerCount"]));
    }
    if (m.find("AvgUserIoWaitTime") != m.end() && !m["AvgUserIoWaitTime"].empty()) {
      avgUserIoWaitTime = make_shared<double>(boost::any_cast<double>(m["AvgUserIoWaitTime"]));
    }
    if (m.find("AvgWaitCount") != m.end() && !m["AvgWaitCount"].empty()) {
      avgWaitCount = make_shared<double>(boost::any_cast<double>(m["AvgWaitCount"]));
    }
    if (m.find("AvgWaitTime") != m.end() && !m["AvgWaitTime"].empty()) {
      avgWaitTime = make_shared<double>(boost::any_cast<double>(m["AvgWaitTime"]));
    }
    if (m.find("ClientIp") != m.end() && !m["ClientIp"].empty()) {
      clientIp = make_shared<string>(boost::any_cast<string>(m["ClientIp"]));
    }
    if (m.find("DbName") != m.end() && !m["DbName"].empty()) {
      dbName = make_shared<string>(boost::any_cast<string>(m["DbName"]));
    }
    if (m.find("DistPlanPercentage") != m.end() && !m["DistPlanPercentage"].empty()) {
      distPlanPercentage = make_shared<double>(boost::any_cast<double>(m["DistPlanPercentage"]));
    }
    if (m.find("ExecPs") != m.end() && !m["ExecPs"].empty()) {
      execPs = make_shared<double>(boost::any_cast<double>(m["ExecPs"]));
    }
    if (m.find("Executions") != m.end() && !m["Executions"].empty()) {
      executions = make_shared<double>(boost::any_cast<double>(m["Executions"]));
    }
    if (m.find("FailCount") != m.end() && !m["FailCount"].empty()) {
      failCount = make_shared<double>(boost::any_cast<double>(m["FailCount"]));
    }
    if (m.find("FailPercentage") != m.end() && !m["FailPercentage"].empty()) {
      failPercentage = make_shared<double>(boost::any_cast<double>(m["FailPercentage"]));
    }
    if (m.find("Inner") != m.end() && !m["Inner"].empty()) {
      inner = make_shared<bool>(boost::any_cast<bool>(m["Inner"]));
    }
    if (m.find("LocalPlanPercentage") != m.end() && !m["LocalPlanPercentage"].empty()) {
      localPlanPercentage = make_shared<double>(boost::any_cast<double>(m["LocalPlanPercentage"]));
    }
    if (m.find("MaxAffectedRows") != m.end() && !m["MaxAffectedRows"].empty()) {
      maxAffectedRows = make_shared<double>(boost::any_cast<double>(m["MaxAffectedRows"]));
    }
    if (m.find("MaxApplicationWaitTime") != m.end() && !m["MaxApplicationWaitTime"].empty()) {
      maxApplicationWaitTime = make_shared<double>(boost::any_cast<double>(m["MaxApplicationWaitTime"]));
    }
    if (m.find("MaxConcurrencyWaitTime") != m.end() && !m["MaxConcurrencyWaitTime"].empty()) {
      maxConcurrencyWaitTime = make_shared<double>(boost::any_cast<double>(m["MaxConcurrencyWaitTime"]));
    }
    if (m.find("MaxCpuTime") != m.end() && !m["MaxCpuTime"].empty()) {
      maxCpuTime = make_shared<double>(boost::any_cast<double>(m["MaxCpuTime"]));
    }
    if (m.find("MaxDiskReads") != m.end() && !m["MaxDiskReads"].empty()) {
      maxDiskReads = make_shared<double>(boost::any_cast<double>(m["MaxDiskReads"]));
    }
    if (m.find("MaxElapsedTime") != m.end() && !m["MaxElapsedTime"].empty()) {
      maxElapsedTime = make_shared<double>(boost::any_cast<double>(m["MaxElapsedTime"]));
    }
    if (m.find("MaxReturnRows") != m.end() && !m["MaxReturnRows"].empty()) {
      maxReturnRows = make_shared<double>(boost::any_cast<double>(m["MaxReturnRows"]));
    }
    if (m.find("MaxUserIoWaitTime") != m.end() && !m["MaxUserIoWaitTime"].empty()) {
      maxUserIoWaitTime = make_shared<double>(boost::any_cast<double>(m["MaxUserIoWaitTime"]));
    }
    if (m.find("MaxWaitTime") != m.end() && !m["MaxWaitTime"].empty()) {
      maxWaitTime = make_shared<double>(boost::any_cast<double>(m["MaxWaitTime"]));
    }
    if (m.find("MissPlanPercentage") != m.end() && !m["MissPlanPercentage"].empty()) {
      missPlanPercentage = make_shared<double>(boost::any_cast<double>(m["MissPlanPercentage"]));
    }
    if (m.find("MissPlans") != m.end() && !m["MissPlans"].empty()) {
      missPlans = make_shared<double>(boost::any_cast<double>(m["MissPlans"]));
    }
    if (m.find("RemotePlanPercentage") != m.end() && !m["RemotePlanPercentage"].empty()) {
      remotePlanPercentage = make_shared<double>(boost::any_cast<double>(m["RemotePlanPercentage"]));
    }
    if (m.find("RemotePlans") != m.end() && !m["RemotePlans"].empty()) {
      remotePlans = make_shared<double>(boost::any_cast<double>(m["RemotePlans"]));
    }
    if (m.find("RetCode4012Count") != m.end() && !m["RetCode4012Count"].empty()) {
      retCode4012Count = make_shared<long>(boost::any_cast<long>(m["RetCode4012Count"]));
    }
    if (m.find("RetCode4013Count") != m.end() && !m["RetCode4013Count"].empty()) {
      retCode4013Count = make_shared<long>(boost::any_cast<long>(m["RetCode4013Count"]));
    }
    if (m.find("RetCode5001Count") != m.end() && !m["RetCode5001Count"].empty()) {
      retCode5001Count = make_shared<long>(boost::any_cast<long>(m["RetCode5001Count"]));
    }
    if (m.find("RetCode5024Count") != m.end() && !m["RetCode5024Count"].empty()) {
      retCode5024Count = make_shared<long>(boost::any_cast<long>(m["RetCode5024Count"]));
    }
    if (m.find("RetCode5167Count") != m.end() && !m["RetCode5167Count"].empty()) {
      retCode5167Count = make_shared<long>(boost::any_cast<long>(m["RetCode5167Count"]));
    }
    if (m.find("RetCode5217Count") != m.end() && !m["RetCode5217Count"].empty()) {
      retCode5217Count = make_shared<long>(boost::any_cast<long>(m["RetCode5217Count"]));
    }
    if (m.find("RetCode6002Count") != m.end() && !m["RetCode6002Count"].empty()) {
      retCode6002Count = make_shared<long>(boost::any_cast<long>(m["RetCode6002Count"]));
    }
    if (m.find("RetryCount") != m.end() && !m["RetryCount"].empty()) {
      retryCount = make_shared<double>(boost::any_cast<double>(m["RetryCount"]));
    }
    if (m.find("RpcCount") != m.end() && !m["RpcCount"].empty()) {
      rpcCount = make_shared<double>(boost::any_cast<double>(m["RpcCount"]));
    }
    if (m.find("Server") != m.end() && !m["Server"].empty()) {
      server = make_shared<string>(boost::any_cast<string>(m["Server"]));
    }
    if (m.find("ServerIp") != m.end() && !m["ServerIp"].empty()) {
      serverIp = make_shared<string>(boost::any_cast<string>(m["ServerIp"]));
    }
    if (m.find("ServerPort") != m.end() && !m["ServerPort"].empty()) {
      serverPort = make_shared<long>(boost::any_cast<long>(m["ServerPort"]));
    }
    if (m.find("SqlId") != m.end() && !m["SqlId"].empty()) {
      sqlId = make_shared<string>(boost::any_cast<string>(m["SqlId"]));
    }
    if (m.find("SqlTextShort") != m.end() && !m["SqlTextShort"].empty()) {
      sqlTextShort = make_shared<string>(boost::any_cast<string>(m["SqlTextShort"]));
    }
    if (m.find("SqlType") != m.end() && !m["SqlType"].empty()) {
      sqlType = make_shared<string>(boost::any_cast<string>(m["SqlType"]));
    }
    if (m.find("StrongConsistencyPercentage") != m.end() && !m["StrongConsistencyPercentage"].empty()) {
      strongConsistencyPercentage = make_shared<double>(boost::any_cast<double>(m["StrongConsistencyPercentage"]));
    }
    if (m.find("SumDbTime") != m.end() && !m["SumDbTime"].empty()) {
      sumDbTime = make_shared<double>(boost::any_cast<double>(m["SumDbTime"]));
    }
    if (m.find("SumElapsedTime") != m.end() && !m["SumElapsedTime"].empty()) {
      sumElapsedTime = make_shared<double>(boost::any_cast<double>(m["SumElapsedTime"]));
    }
    if (m.find("SumLogicalReads") != m.end() && !m["SumLogicalReads"].empty()) {
      sumLogicalReads = make_shared<double>(boost::any_cast<double>(m["SumLogicalReads"]));
    }
    if (m.find("SumWaitTime") != m.end() && !m["SumWaitTime"].empty()) {
      sumWaitTime = make_shared<double>(boost::any_cast<double>(m["SumWaitTime"]));
    }
    if (m.find("TableScanPercentage") != m.end() && !m["TableScanPercentage"].empty()) {
      tableScanPercentage = make_shared<double>(boost::any_cast<double>(m["TableScanPercentage"]));
    }
    if (m.find("TotalWaitTime") != m.end() && !m["TotalWaitTime"].empty()) {
      totalWaitTime = make_shared<double>(boost::any_cast<double>(m["TotalWaitTime"]));
    }
    if (m.find("UserName") != m.end() && !m["UserName"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["UserName"]));
    }
    if (m.find("WaitEvent") != m.end() && !m["WaitEvent"].empty()) {
      waitEvent = make_shared<string>(boost::any_cast<string>(m["WaitEvent"]));
    }
    if (m.find("WeakConsistencyPercentage") != m.end() && !m["WeakConsistencyPercentage"].empty()) {
      weakConsistencyPercentage = make_shared<double>(boost::any_cast<double>(m["WeakConsistencyPercentage"]));
    }
  }


  virtual ~DescribeOasSlowSQLListResponseBodyDataSqlList() = default;
};
class DescribeOasSlowSQLListResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<double> avgAffectedRows{};
  shared_ptr<double> avgApplicationWaitTime{};
  shared_ptr<double> avgBlockCacheHit{};
  shared_ptr<double> avgBlockIndexCacheHit{};
  shared_ptr<double> avgBloomFilterCacheHit{};
  shared_ptr<double> avgConcurrencyWaitTime{};
  shared_ptr<double> avgCpuTime{};
  shared_ptr<double> avgDbTime{};
  shared_ptr<double> avgDecodeTime{};
  shared_ptr<double> avgDiskReads{};
  shared_ptr<double> avgElapsedTime{};
  shared_ptr<double> avgExecuteTime{};
  shared_ptr<double> avgExecutorRpcCount{};
  shared_ptr<double> avgExpectedWorkerCount{};
  shared_ptr<double> avgGetPlanTime{};
  shared_ptr<double> avgLogicalReads{};
  shared_ptr<double> avgMemstoreReadRows{};
  shared_ptr<double> avgNetTime{};
  shared_ptr<double> avgNetWaitTime{};
  shared_ptr<double> avgPartitionCount{};
  shared_ptr<double> avgQueueTime{};
  shared_ptr<double> avgReturnRows{};
  shared_ptr<double> avgRowCacheHit{};
  shared_ptr<double> avgRpcCount{};
  shared_ptr<double> avgScheduleTime{};
  shared_ptr<double> avgSsstoreReadRows{};
  shared_ptr<double> avgUsedWorkerCount{};
  shared_ptr<double> avgUserIoWaitTime{};
  shared_ptr<double> avgWaitCount{};
  shared_ptr<double> avgWaitTime{};
  shared_ptr<string> clientIp{};
  shared_ptr<string> dbName{};
  shared_ptr<double> distPlanPercentage{};
  shared_ptr<bool> dynamicSql{};
  shared_ptr<double> execPs{};
  shared_ptr<double> executions{};
  shared_ptr<double> failCount{};
  shared_ptr<double> failPercentage{};
  shared_ptr<bool> inner{};
  shared_ptr<double> localPlanPercentage{};
  shared_ptr<double> maxAffectedRows{};
  shared_ptr<double> maxApplicationWaitTime{};
  shared_ptr<double> maxConcurrencyWaitTime{};
  shared_ptr<double> maxCpuTime{};
  shared_ptr<double> maxDiskReads{};
  shared_ptr<double> maxElapsedTime{};
  shared_ptr<double> maxReturnRows{};
  shared_ptr<double> maxUserIoWaitTime{};
  shared_ptr<double> maxWaitTime{};
  shared_ptr<double> missPlanPercentage{};
  shared_ptr<double> missPlans{};
  shared_ptr<double> remotePlanPercentage{};
  shared_ptr<double> remotePlans{};
  shared_ptr<long> retCode4012Count{};
  shared_ptr<long> retCode4013Count{};
  shared_ptr<long> retCode5001Count{};
  shared_ptr<long> retCode5024Count{};
  shared_ptr<long> retCode5167Count{};
  shared_ptr<long> retCode5217Count{};
  shared_ptr<long> retCode6002Count{};
  shared_ptr<double> retryCount{};
  shared_ptr<double> rpcCount{};
  shared_ptr<string> server{};
  shared_ptr<string> serverIp{};
  shared_ptr<long> serverPort{};
  shared_ptr<string> sqlId{};
  shared_ptr<vector<DescribeOasSlowSQLListResponseBodyDataSqlList>> sqlList{};
  shared_ptr<string> sqlTextShort{};
  shared_ptr<string> sqlType{};
  shared_ptr<double> strongConsistencyPercentage{};
  shared_ptr<double> sumDbTime{};
  shared_ptr<double> sumElapsedTime{};
  shared_ptr<double> sumLogicalReads{};
  shared_ptr<double> sumWaitTime{};
  shared_ptr<double> tableScanPercentage{};
  shared_ptr<double> totalWaitTime{};
  shared_ptr<string> userName{};
  shared_ptr<string> waitEvent{};
  shared_ptr<double> weakConsistencyPercentage{};

  DescribeOasSlowSQLListResponseBodyData() {}

  explicit DescribeOasSlowSQLListResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (avgAffectedRows) {
      res["AvgAffectedRows"] = boost::any(*avgAffectedRows);
    }
    if (avgApplicationWaitTime) {
      res["AvgApplicationWaitTime"] = boost::any(*avgApplicationWaitTime);
    }
    if (avgBlockCacheHit) {
      res["AvgBlockCacheHit"] = boost::any(*avgBlockCacheHit);
    }
    if (avgBlockIndexCacheHit) {
      res["AvgBlockIndexCacheHit"] = boost::any(*avgBlockIndexCacheHit);
    }
    if (avgBloomFilterCacheHit) {
      res["AvgBloomFilterCacheHit"] = boost::any(*avgBloomFilterCacheHit);
    }
    if (avgConcurrencyWaitTime) {
      res["AvgConcurrencyWaitTime"] = boost::any(*avgConcurrencyWaitTime);
    }
    if (avgCpuTime) {
      res["AvgCpuTime"] = boost::any(*avgCpuTime);
    }
    if (avgDbTime) {
      res["AvgDbTime"] = boost::any(*avgDbTime);
    }
    if (avgDecodeTime) {
      res["AvgDecodeTime"] = boost::any(*avgDecodeTime);
    }
    if (avgDiskReads) {
      res["AvgDiskReads"] = boost::any(*avgDiskReads);
    }
    if (avgElapsedTime) {
      res["AvgElapsedTime"] = boost::any(*avgElapsedTime);
    }
    if (avgExecuteTime) {
      res["AvgExecuteTime"] = boost::any(*avgExecuteTime);
    }
    if (avgExecutorRpcCount) {
      res["AvgExecutorRpcCount"] = boost::any(*avgExecutorRpcCount);
    }
    if (avgExpectedWorkerCount) {
      res["AvgExpectedWorkerCount"] = boost::any(*avgExpectedWorkerCount);
    }
    if (avgGetPlanTime) {
      res["AvgGetPlanTime"] = boost::any(*avgGetPlanTime);
    }
    if (avgLogicalReads) {
      res["AvgLogicalReads"] = boost::any(*avgLogicalReads);
    }
    if (avgMemstoreReadRows) {
      res["AvgMemstoreReadRows"] = boost::any(*avgMemstoreReadRows);
    }
    if (avgNetTime) {
      res["AvgNetTime"] = boost::any(*avgNetTime);
    }
    if (avgNetWaitTime) {
      res["AvgNetWaitTime"] = boost::any(*avgNetWaitTime);
    }
    if (avgPartitionCount) {
      res["AvgPartitionCount"] = boost::any(*avgPartitionCount);
    }
    if (avgQueueTime) {
      res["AvgQueueTime"] = boost::any(*avgQueueTime);
    }
    if (avgReturnRows) {
      res["AvgReturnRows"] = boost::any(*avgReturnRows);
    }
    if (avgRowCacheHit) {
      res["AvgRowCacheHit"] = boost::any(*avgRowCacheHit);
    }
    if (avgRpcCount) {
      res["AvgRpcCount"] = boost::any(*avgRpcCount);
    }
    if (avgScheduleTime) {
      res["AvgScheduleTime"] = boost::any(*avgScheduleTime);
    }
    if (avgSsstoreReadRows) {
      res["AvgSsstoreReadRows"] = boost::any(*avgSsstoreReadRows);
    }
    if (avgUsedWorkerCount) {
      res["AvgUsedWorkerCount"] = boost::any(*avgUsedWorkerCount);
    }
    if (avgUserIoWaitTime) {
      res["AvgUserIoWaitTime"] = boost::any(*avgUserIoWaitTime);
    }
    if (avgWaitCount) {
      res["AvgWaitCount"] = boost::any(*avgWaitCount);
    }
    if (avgWaitTime) {
      res["AvgWaitTime"] = boost::any(*avgWaitTime);
    }
    if (clientIp) {
      res["ClientIp"] = boost::any(*clientIp);
    }
    if (dbName) {
      res["DbName"] = boost::any(*dbName);
    }
    if (distPlanPercentage) {
      res["DistPlanPercentage"] = boost::any(*distPlanPercentage);
    }
    if (dynamicSql) {
      res["DynamicSql"] = boost::any(*dynamicSql);
    }
    if (execPs) {
      res["ExecPs"] = boost::any(*execPs);
    }
    if (executions) {
      res["Executions"] = boost::any(*executions);
    }
    if (failCount) {
      res["FailCount"] = boost::any(*failCount);
    }
    if (failPercentage) {
      res["FailPercentage"] = boost::any(*failPercentage);
    }
    if (inner) {
      res["Inner"] = boost::any(*inner);
    }
    if (localPlanPercentage) {
      res["LocalPlanPercentage"] = boost::any(*localPlanPercentage);
    }
    if (maxAffectedRows) {
      res["MaxAffectedRows"] = boost::any(*maxAffectedRows);
    }
    if (maxApplicationWaitTime) {
      res["MaxApplicationWaitTime"] = boost::any(*maxApplicationWaitTime);
    }
    if (maxConcurrencyWaitTime) {
      res["MaxConcurrencyWaitTime"] = boost::any(*maxConcurrencyWaitTime);
    }
    if (maxCpuTime) {
      res["MaxCpuTime"] = boost::any(*maxCpuTime);
    }
    if (maxDiskReads) {
      res["MaxDiskReads"] = boost::any(*maxDiskReads);
    }
    if (maxElapsedTime) {
      res["MaxElapsedTime"] = boost::any(*maxElapsedTime);
    }
    if (maxReturnRows) {
      res["MaxReturnRows"] = boost::any(*maxReturnRows);
    }
    if (maxUserIoWaitTime) {
      res["MaxUserIoWaitTime"] = boost::any(*maxUserIoWaitTime);
    }
    if (maxWaitTime) {
      res["MaxWaitTime"] = boost::any(*maxWaitTime);
    }
    if (missPlanPercentage) {
      res["MissPlanPercentage"] = boost::any(*missPlanPercentage);
    }
    if (missPlans) {
      res["MissPlans"] = boost::any(*missPlans);
    }
    if (remotePlanPercentage) {
      res["RemotePlanPercentage"] = boost::any(*remotePlanPercentage);
    }
    if (remotePlans) {
      res["RemotePlans"] = boost::any(*remotePlans);
    }
    if (retCode4012Count) {
      res["RetCode4012Count"] = boost::any(*retCode4012Count);
    }
    if (retCode4013Count) {
      res["RetCode4013Count"] = boost::any(*retCode4013Count);
    }
    if (retCode5001Count) {
      res["RetCode5001Count"] = boost::any(*retCode5001Count);
    }
    if (retCode5024Count) {
      res["RetCode5024Count"] = boost::any(*retCode5024Count);
    }
    if (retCode5167Count) {
      res["RetCode5167Count"] = boost::any(*retCode5167Count);
    }
    if (retCode5217Count) {
      res["RetCode5217Count"] = boost::any(*retCode5217Count);
    }
    if (retCode6002Count) {
      res["RetCode6002Count"] = boost::any(*retCode6002Count);
    }
    if (retryCount) {
      res["RetryCount"] = boost::any(*retryCount);
    }
    if (rpcCount) {
      res["RpcCount"] = boost::any(*rpcCount);
    }
    if (server) {
      res["Server"] = boost::any(*server);
    }
    if (serverIp) {
      res["ServerIp"] = boost::any(*serverIp);
    }
    if (serverPort) {
      res["ServerPort"] = boost::any(*serverPort);
    }
    if (sqlId) {
      res["SqlId"] = boost::any(*sqlId);
    }
    if (sqlList) {
      vector<boost::any> temp1;
      for(auto item1:*sqlList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SqlList"] = boost::any(temp1);
    }
    if (sqlTextShort) {
      res["SqlTextShort"] = boost::any(*sqlTextShort);
    }
    if (sqlType) {
      res["SqlType"] = boost::any(*sqlType);
    }
    if (strongConsistencyPercentage) {
      res["StrongConsistencyPercentage"] = boost::any(*strongConsistencyPercentage);
    }
    if (sumDbTime) {
      res["SumDbTime"] = boost::any(*sumDbTime);
    }
    if (sumElapsedTime) {
      res["SumElapsedTime"] = boost::any(*sumElapsedTime);
    }
    if (sumLogicalReads) {
      res["SumLogicalReads"] = boost::any(*sumLogicalReads);
    }
    if (sumWaitTime) {
      res["SumWaitTime"] = boost::any(*sumWaitTime);
    }
    if (tableScanPercentage) {
      res["TableScanPercentage"] = boost::any(*tableScanPercentage);
    }
    if (totalWaitTime) {
      res["TotalWaitTime"] = boost::any(*totalWaitTime);
    }
    if (userName) {
      res["UserName"] = boost::any(*userName);
    }
    if (waitEvent) {
      res["WaitEvent"] = boost::any(*waitEvent);
    }
    if (weakConsistencyPercentage) {
      res["WeakConsistencyPercentage"] = boost::any(*weakConsistencyPercentage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AvgAffectedRows") != m.end() && !m["AvgAffectedRows"].empty()) {
      avgAffectedRows = make_shared<double>(boost::any_cast<double>(m["AvgAffectedRows"]));
    }
    if (m.find("AvgApplicationWaitTime") != m.end() && !m["AvgApplicationWaitTime"].empty()) {
      avgApplicationWaitTime = make_shared<double>(boost::any_cast<double>(m["AvgApplicationWaitTime"]));
    }
    if (m.find("AvgBlockCacheHit") != m.end() && !m["AvgBlockCacheHit"].empty()) {
      avgBlockCacheHit = make_shared<double>(boost::any_cast<double>(m["AvgBlockCacheHit"]));
    }
    if (m.find("AvgBlockIndexCacheHit") != m.end() && !m["AvgBlockIndexCacheHit"].empty()) {
      avgBlockIndexCacheHit = make_shared<double>(boost::any_cast<double>(m["AvgBlockIndexCacheHit"]));
    }
    if (m.find("AvgBloomFilterCacheHit") != m.end() && !m["AvgBloomFilterCacheHit"].empty()) {
      avgBloomFilterCacheHit = make_shared<double>(boost::any_cast<double>(m["AvgBloomFilterCacheHit"]));
    }
    if (m.find("AvgConcurrencyWaitTime") != m.end() && !m["AvgConcurrencyWaitTime"].empty()) {
      avgConcurrencyWaitTime = make_shared<double>(boost::any_cast<double>(m["AvgConcurrencyWaitTime"]));
    }
    if (m.find("AvgCpuTime") != m.end() && !m["AvgCpuTime"].empty()) {
      avgCpuTime = make_shared<double>(boost::any_cast<double>(m["AvgCpuTime"]));
    }
    if (m.find("AvgDbTime") != m.end() && !m["AvgDbTime"].empty()) {
      avgDbTime = make_shared<double>(boost::any_cast<double>(m["AvgDbTime"]));
    }
    if (m.find("AvgDecodeTime") != m.end() && !m["AvgDecodeTime"].empty()) {
      avgDecodeTime = make_shared<double>(boost::any_cast<double>(m["AvgDecodeTime"]));
    }
    if (m.find("AvgDiskReads") != m.end() && !m["AvgDiskReads"].empty()) {
      avgDiskReads = make_shared<double>(boost::any_cast<double>(m["AvgDiskReads"]));
    }
    if (m.find("AvgElapsedTime") != m.end() && !m["AvgElapsedTime"].empty()) {
      avgElapsedTime = make_shared<double>(boost::any_cast<double>(m["AvgElapsedTime"]));
    }
    if (m.find("AvgExecuteTime") != m.end() && !m["AvgExecuteTime"].empty()) {
      avgExecuteTime = make_shared<double>(boost::any_cast<double>(m["AvgExecuteTime"]));
    }
    if (m.find("AvgExecutorRpcCount") != m.end() && !m["AvgExecutorRpcCount"].empty()) {
      avgExecutorRpcCount = make_shared<double>(boost::any_cast<double>(m["AvgExecutorRpcCount"]));
    }
    if (m.find("AvgExpectedWorkerCount") != m.end() && !m["AvgExpectedWorkerCount"].empty()) {
      avgExpectedWorkerCount = make_shared<double>(boost::any_cast<double>(m["AvgExpectedWorkerCount"]));
    }
    if (m.find("AvgGetPlanTime") != m.end() && !m["AvgGetPlanTime"].empty()) {
      avgGetPlanTime = make_shared<double>(boost::any_cast<double>(m["AvgGetPlanTime"]));
    }
    if (m.find("AvgLogicalReads") != m.end() && !m["AvgLogicalReads"].empty()) {
      avgLogicalReads = make_shared<double>(boost::any_cast<double>(m["AvgLogicalReads"]));
    }
    if (m.find("AvgMemstoreReadRows") != m.end() && !m["AvgMemstoreReadRows"].empty()) {
      avgMemstoreReadRows = make_shared<double>(boost::any_cast<double>(m["AvgMemstoreReadRows"]));
    }
    if (m.find("AvgNetTime") != m.end() && !m["AvgNetTime"].empty()) {
      avgNetTime = make_shared<double>(boost::any_cast<double>(m["AvgNetTime"]));
    }
    if (m.find("AvgNetWaitTime") != m.end() && !m["AvgNetWaitTime"].empty()) {
      avgNetWaitTime = make_shared<double>(boost::any_cast<double>(m["AvgNetWaitTime"]));
    }
    if (m.find("AvgPartitionCount") != m.end() && !m["AvgPartitionCount"].empty()) {
      avgPartitionCount = make_shared<double>(boost::any_cast<double>(m["AvgPartitionCount"]));
    }
    if (m.find("AvgQueueTime") != m.end() && !m["AvgQueueTime"].empty()) {
      avgQueueTime = make_shared<double>(boost::any_cast<double>(m["AvgQueueTime"]));
    }
    if (m.find("AvgReturnRows") != m.end() && !m["AvgReturnRows"].empty()) {
      avgReturnRows = make_shared<double>(boost::any_cast<double>(m["AvgReturnRows"]));
    }
    if (m.find("AvgRowCacheHit") != m.end() && !m["AvgRowCacheHit"].empty()) {
      avgRowCacheHit = make_shared<double>(boost::any_cast<double>(m["AvgRowCacheHit"]));
    }
    if (m.find("AvgRpcCount") != m.end() && !m["AvgRpcCount"].empty()) {
      avgRpcCount = make_shared<double>(boost::any_cast<double>(m["AvgRpcCount"]));
    }
    if (m.find("AvgScheduleTime") != m.end() && !m["AvgScheduleTime"].empty()) {
      avgScheduleTime = make_shared<double>(boost::any_cast<double>(m["AvgScheduleTime"]));
    }
    if (m.find("AvgSsstoreReadRows") != m.end() && !m["AvgSsstoreReadRows"].empty()) {
      avgSsstoreReadRows = make_shared<double>(boost::any_cast<double>(m["AvgSsstoreReadRows"]));
    }
    if (m.find("AvgUsedWorkerCount") != m.end() && !m["AvgUsedWorkerCount"].empty()) {
      avgUsedWorkerCount = make_shared<double>(boost::any_cast<double>(m["AvgUsedWorkerCount"]));
    }
    if (m.find("AvgUserIoWaitTime") != m.end() && !m["AvgUserIoWaitTime"].empty()) {
      avgUserIoWaitTime = make_shared<double>(boost::any_cast<double>(m["AvgUserIoWaitTime"]));
    }
    if (m.find("AvgWaitCount") != m.end() && !m["AvgWaitCount"].empty()) {
      avgWaitCount = make_shared<double>(boost::any_cast<double>(m["AvgWaitCount"]));
    }
    if (m.find("AvgWaitTime") != m.end() && !m["AvgWaitTime"].empty()) {
      avgWaitTime = make_shared<double>(boost::any_cast<double>(m["AvgWaitTime"]));
    }
    if (m.find("ClientIp") != m.end() && !m["ClientIp"].empty()) {
      clientIp = make_shared<string>(boost::any_cast<string>(m["ClientIp"]));
    }
    if (m.find("DbName") != m.end() && !m["DbName"].empty()) {
      dbName = make_shared<string>(boost::any_cast<string>(m["DbName"]));
    }
    if (m.find("DistPlanPercentage") != m.end() && !m["DistPlanPercentage"].empty()) {
      distPlanPercentage = make_shared<double>(boost::any_cast<double>(m["DistPlanPercentage"]));
    }
    if (m.find("DynamicSql") != m.end() && !m["DynamicSql"].empty()) {
      dynamicSql = make_shared<bool>(boost::any_cast<bool>(m["DynamicSql"]));
    }
    if (m.find("ExecPs") != m.end() && !m["ExecPs"].empty()) {
      execPs = make_shared<double>(boost::any_cast<double>(m["ExecPs"]));
    }
    if (m.find("Executions") != m.end() && !m["Executions"].empty()) {
      executions = make_shared<double>(boost::any_cast<double>(m["Executions"]));
    }
    if (m.find("FailCount") != m.end() && !m["FailCount"].empty()) {
      failCount = make_shared<double>(boost::any_cast<double>(m["FailCount"]));
    }
    if (m.find("FailPercentage") != m.end() && !m["FailPercentage"].empty()) {
      failPercentage = make_shared<double>(boost::any_cast<double>(m["FailPercentage"]));
    }
    if (m.find("Inner") != m.end() && !m["Inner"].empty()) {
      inner = make_shared<bool>(boost::any_cast<bool>(m["Inner"]));
    }
    if (m.find("LocalPlanPercentage") != m.end() && !m["LocalPlanPercentage"].empty()) {
      localPlanPercentage = make_shared<double>(boost::any_cast<double>(m["LocalPlanPercentage"]));
    }
    if (m.find("MaxAffectedRows") != m.end() && !m["MaxAffectedRows"].empty()) {
      maxAffectedRows = make_shared<double>(boost::any_cast<double>(m["MaxAffectedRows"]));
    }
    if (m.find("MaxApplicationWaitTime") != m.end() && !m["MaxApplicationWaitTime"].empty()) {
      maxApplicationWaitTime = make_shared<double>(boost::any_cast<double>(m["MaxApplicationWaitTime"]));
    }
    if (m.find("MaxConcurrencyWaitTime") != m.end() && !m["MaxConcurrencyWaitTime"].empty()) {
      maxConcurrencyWaitTime = make_shared<double>(boost::any_cast<double>(m["MaxConcurrencyWaitTime"]));
    }
    if (m.find("MaxCpuTime") != m.end() && !m["MaxCpuTime"].empty()) {
      maxCpuTime = make_shared<double>(boost::any_cast<double>(m["MaxCpuTime"]));
    }
    if (m.find("MaxDiskReads") != m.end() && !m["MaxDiskReads"].empty()) {
      maxDiskReads = make_shared<double>(boost::any_cast<double>(m["MaxDiskReads"]));
    }
    if (m.find("MaxElapsedTime") != m.end() && !m["MaxElapsedTime"].empty()) {
      maxElapsedTime = make_shared<double>(boost::any_cast<double>(m["MaxElapsedTime"]));
    }
    if (m.find("MaxReturnRows") != m.end() && !m["MaxReturnRows"].empty()) {
      maxReturnRows = make_shared<double>(boost::any_cast<double>(m["MaxReturnRows"]));
    }
    if (m.find("MaxUserIoWaitTime") != m.end() && !m["MaxUserIoWaitTime"].empty()) {
      maxUserIoWaitTime = make_shared<double>(boost::any_cast<double>(m["MaxUserIoWaitTime"]));
    }
    if (m.find("MaxWaitTime") != m.end() && !m["MaxWaitTime"].empty()) {
      maxWaitTime = make_shared<double>(boost::any_cast<double>(m["MaxWaitTime"]));
    }
    if (m.find("MissPlanPercentage") != m.end() && !m["MissPlanPercentage"].empty()) {
      missPlanPercentage = make_shared<double>(boost::any_cast<double>(m["MissPlanPercentage"]));
    }
    if (m.find("MissPlans") != m.end() && !m["MissPlans"].empty()) {
      missPlans = make_shared<double>(boost::any_cast<double>(m["MissPlans"]));
    }
    if (m.find("RemotePlanPercentage") != m.end() && !m["RemotePlanPercentage"].empty()) {
      remotePlanPercentage = make_shared<double>(boost::any_cast<double>(m["RemotePlanPercentage"]));
    }
    if (m.find("RemotePlans") != m.end() && !m["RemotePlans"].empty()) {
      remotePlans = make_shared<double>(boost::any_cast<double>(m["RemotePlans"]));
    }
    if (m.find("RetCode4012Count") != m.end() && !m["RetCode4012Count"].empty()) {
      retCode4012Count = make_shared<long>(boost::any_cast<long>(m["RetCode4012Count"]));
    }
    if (m.find("RetCode4013Count") != m.end() && !m["RetCode4013Count"].empty()) {
      retCode4013Count = make_shared<long>(boost::any_cast<long>(m["RetCode4013Count"]));
    }
    if (m.find("RetCode5001Count") != m.end() && !m["RetCode5001Count"].empty()) {
      retCode5001Count = make_shared<long>(boost::any_cast<long>(m["RetCode5001Count"]));
    }
    if (m.find("RetCode5024Count") != m.end() && !m["RetCode5024Count"].empty()) {
      retCode5024Count = make_shared<long>(boost::any_cast<long>(m["RetCode5024Count"]));
    }
    if (m.find("RetCode5167Count") != m.end() && !m["RetCode5167Count"].empty()) {
      retCode5167Count = make_shared<long>(boost::any_cast<long>(m["RetCode5167Count"]));
    }
    if (m.find("RetCode5217Count") != m.end() && !m["RetCode5217Count"].empty()) {
      retCode5217Count = make_shared<long>(boost::any_cast<long>(m["RetCode5217Count"]));
    }
    if (m.find("RetCode6002Count") != m.end() && !m["RetCode6002Count"].empty()) {
      retCode6002Count = make_shared<long>(boost::any_cast<long>(m["RetCode6002Count"]));
    }
    if (m.find("RetryCount") != m.end() && !m["RetryCount"].empty()) {
      retryCount = make_shared<double>(boost::any_cast<double>(m["RetryCount"]));
    }
    if (m.find("RpcCount") != m.end() && !m["RpcCount"].empty()) {
      rpcCount = make_shared<double>(boost::any_cast<double>(m["RpcCount"]));
    }
    if (m.find("Server") != m.end() && !m["Server"].empty()) {
      server = make_shared<string>(boost::any_cast<string>(m["Server"]));
    }
    if (m.find("ServerIp") != m.end() && !m["ServerIp"].empty()) {
      serverIp = make_shared<string>(boost::any_cast<string>(m["ServerIp"]));
    }
    if (m.find("ServerPort") != m.end() && !m["ServerPort"].empty()) {
      serverPort = make_shared<long>(boost::any_cast<long>(m["ServerPort"]));
    }
    if (m.find("SqlId") != m.end() && !m["SqlId"].empty()) {
      sqlId = make_shared<string>(boost::any_cast<string>(m["SqlId"]));
    }
    if (m.find("SqlList") != m.end() && !m["SqlList"].empty()) {
      if (typeid(vector<boost::any>) == m["SqlList"].type()) {
        vector<DescribeOasSlowSQLListResponseBodyDataSqlList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SqlList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeOasSlowSQLListResponseBodyDataSqlList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        sqlList = make_shared<vector<DescribeOasSlowSQLListResponseBodyDataSqlList>>(expect1);
      }
    }
    if (m.find("SqlTextShort") != m.end() && !m["SqlTextShort"].empty()) {
      sqlTextShort = make_shared<string>(boost::any_cast<string>(m["SqlTextShort"]));
    }
    if (m.find("SqlType") != m.end() && !m["SqlType"].empty()) {
      sqlType = make_shared<string>(boost::any_cast<string>(m["SqlType"]));
    }
    if (m.find("StrongConsistencyPercentage") != m.end() && !m["StrongConsistencyPercentage"].empty()) {
      strongConsistencyPercentage = make_shared<double>(boost::any_cast<double>(m["StrongConsistencyPercentage"]));
    }
    if (m.find("SumDbTime") != m.end() && !m["SumDbTime"].empty()) {
      sumDbTime = make_shared<double>(boost::any_cast<double>(m["SumDbTime"]));
    }
    if (m.find("SumElapsedTime") != m.end() && !m["SumElapsedTime"].empty()) {
      sumElapsedTime = make_shared<double>(boost::any_cast<double>(m["SumElapsedTime"]));
    }
    if (m.find("SumLogicalReads") != m.end() && !m["SumLogicalReads"].empty()) {
      sumLogicalReads = make_shared<double>(boost::any_cast<double>(m["SumLogicalReads"]));
    }
    if (m.find("SumWaitTime") != m.end() && !m["SumWaitTime"].empty()) {
      sumWaitTime = make_shared<double>(boost::any_cast<double>(m["SumWaitTime"]));
    }
    if (m.find("TableScanPercentage") != m.end() && !m["TableScanPercentage"].empty()) {
      tableScanPercentage = make_shared<double>(boost::any_cast<double>(m["TableScanPercentage"]));
    }
    if (m.find("TotalWaitTime") != m.end() && !m["TotalWaitTime"].empty()) {
      totalWaitTime = make_shared<double>(boost::any_cast<double>(m["TotalWaitTime"]));
    }
    if (m.find("UserName") != m.end() && !m["UserName"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["UserName"]));
    }
    if (m.find("WaitEvent") != m.end() && !m["WaitEvent"].empty()) {
      waitEvent = make_shared<string>(boost::any_cast<string>(m["WaitEvent"]));
    }
    if (m.find("WeakConsistencyPercentage") != m.end() && !m["WeakConsistencyPercentage"].empty()) {
      weakConsistencyPercentage = make_shared<double>(boost::any_cast<double>(m["WeakConsistencyPercentage"]));
    }
  }


  virtual ~DescribeOasSlowSQLListResponseBodyData() = default;
};
class DescribeOasSlowSQLListResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeOasSlowSQLListResponseBodyData>> data{};
  shared_ptr<string> requestId{};

  DescribeOasSlowSQLListResponseBody() {}

  explicit DescribeOasSlowSQLListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<DescribeOasSlowSQLListResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeOasSlowSQLListResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<DescribeOasSlowSQLListResponseBodyData>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeOasSlowSQLListResponseBody() = default;
};
class DescribeOasSlowSQLListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeOasSlowSQLListResponseBody> body{};

  DescribeOasSlowSQLListResponse() {}

  explicit DescribeOasSlowSQLListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeOasSlowSQLListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeOasSlowSQLListResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeOasSlowSQLListResponse() = default;
};
class DescribeOasTopSQLListRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<string> dbName{};
  shared_ptr<bool> dynamicSql{};
  shared_ptr<string> endTime{};
  shared_ptr<string> filterCondition{};
  shared_ptr<string> instanceId{};
  shared_ptr<bool> mergeDynamicSql{};
  shared_ptr<string> nodeIp{};
  shared_ptr<string> searchKeyWord{};
  shared_ptr<string> searchParam{};
  shared_ptr<string> searchRule{};
  shared_ptr<string> searchValue{};
  shared_ptr<string> sqlId{};
  shared_ptr<long> sqlTextLength{};
  shared_ptr<string> startTime{};
  shared_ptr<string> tenantId{};

  DescribeOasTopSQLListRequest() {}

  explicit DescribeOasTopSQLListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (dbName) {
      res["DbName"] = boost::any(*dbName);
    }
    if (dynamicSql) {
      res["DynamicSql"] = boost::any(*dynamicSql);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (filterCondition) {
      res["FilterCondition"] = boost::any(*filterCondition);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (mergeDynamicSql) {
      res["MergeDynamicSql"] = boost::any(*mergeDynamicSql);
    }
    if (nodeIp) {
      res["NodeIp"] = boost::any(*nodeIp);
    }
    if (searchKeyWord) {
      res["SearchKeyWord"] = boost::any(*searchKeyWord);
    }
    if (searchParam) {
      res["SearchParam"] = boost::any(*searchParam);
    }
    if (searchRule) {
      res["SearchRule"] = boost::any(*searchRule);
    }
    if (searchValue) {
      res["SearchValue"] = boost::any(*searchValue);
    }
    if (sqlId) {
      res["SqlId"] = boost::any(*sqlId);
    }
    if (sqlTextLength) {
      res["SqlTextLength"] = boost::any(*sqlTextLength);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("DbName") != m.end() && !m["DbName"].empty()) {
      dbName = make_shared<string>(boost::any_cast<string>(m["DbName"]));
    }
    if (m.find("DynamicSql") != m.end() && !m["DynamicSql"].empty()) {
      dynamicSql = make_shared<bool>(boost::any_cast<bool>(m["DynamicSql"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("FilterCondition") != m.end() && !m["FilterCondition"].empty()) {
      filterCondition = make_shared<string>(boost::any_cast<string>(m["FilterCondition"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("MergeDynamicSql") != m.end() && !m["MergeDynamicSql"].empty()) {
      mergeDynamicSql = make_shared<bool>(boost::any_cast<bool>(m["MergeDynamicSql"]));
    }
    if (m.find("NodeIp") != m.end() && !m["NodeIp"].empty()) {
      nodeIp = make_shared<string>(boost::any_cast<string>(m["NodeIp"]));
    }
    if (m.find("SearchKeyWord") != m.end() && !m["SearchKeyWord"].empty()) {
      searchKeyWord = make_shared<string>(boost::any_cast<string>(m["SearchKeyWord"]));
    }
    if (m.find("SearchParam") != m.end() && !m["SearchParam"].empty()) {
      searchParam = make_shared<string>(boost::any_cast<string>(m["SearchParam"]));
    }
    if (m.find("SearchRule") != m.end() && !m["SearchRule"].empty()) {
      searchRule = make_shared<string>(boost::any_cast<string>(m["SearchRule"]));
    }
    if (m.find("SearchValue") != m.end() && !m["SearchValue"].empty()) {
      searchValue = make_shared<string>(boost::any_cast<string>(m["SearchValue"]));
    }
    if (m.find("SqlId") != m.end() && !m["SqlId"].empty()) {
      sqlId = make_shared<string>(boost::any_cast<string>(m["SqlId"]));
    }
    if (m.find("SqlTextLength") != m.end() && !m["SqlTextLength"].empty()) {
      sqlTextLength = make_shared<long>(boost::any_cast<long>(m["SqlTextLength"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["TenantId"]));
    }
  }


  virtual ~DescribeOasTopSQLListRequest() = default;
};
class DescribeOasTopSQLListResponseBodyDataSqlList : public Darabonba::Model {
public:
  shared_ptr<double> avgAffectedRows{};
  shared_ptr<double> avgApplicationWaitTime{};
  shared_ptr<double> avgBlockCacheHit{};
  shared_ptr<double> avgBlockIndexCacheHit{};
  shared_ptr<double> avgBloomFilterCacheHit{};
  shared_ptr<double> avgConcurrencyWaitTime{};
  shared_ptr<double> avgCpuTime{};
  shared_ptr<double> avgDbTime{};
  shared_ptr<double> avgDecodeTime{};
  shared_ptr<double> avgDiskReads{};
  shared_ptr<double> avgElapsedTime{};
  shared_ptr<double> avgExecuteTime{};
  shared_ptr<double> avgExecutorRpcCount{};
  shared_ptr<double> avgExpectedWorkerCount{};
  shared_ptr<double> avgGetPlanTime{};
  shared_ptr<double> avgLogicalReads{};
  shared_ptr<double> avgMemstoreReadRows{};
  shared_ptr<double> avgNetTime{};
  shared_ptr<double> avgNetWaitTime{};
  shared_ptr<double> avgPartitionCount{};
  shared_ptr<double> avgQueueTime{};
  shared_ptr<double> avgReturnRows{};
  shared_ptr<double> avgRowCacheHit{};
  shared_ptr<double> avgRpcCount{};
  shared_ptr<double> avgScheduleTime{};
  shared_ptr<double> avgSsstoreReadRows{};
  shared_ptr<double> avgUsedWorkerCount{};
  shared_ptr<double> avgUserIoWaitTime{};
  shared_ptr<double> avgWaitCount{};
  shared_ptr<double> avgWaitTime{};
  shared_ptr<string> clientIp{};
  shared_ptr<double> cpuPercentage{};
  shared_ptr<string> dbName{};
  shared_ptr<double> distPlanPercentage{};
  shared_ptr<double> execPs{};
  shared_ptr<double> executions{};
  shared_ptr<double> failCount{};
  shared_ptr<double> failPercentage{};
  shared_ptr<bool> inner{};
  shared_ptr<double> localPlanPercentage{};
  shared_ptr<double> maxAffectedRows{};
  shared_ptr<double> maxApplicationWaitTime{};
  shared_ptr<double> maxConcurrencyWaitTime{};
  shared_ptr<double> maxCpuTime{};
  shared_ptr<double> maxDiskReads{};
  shared_ptr<double> maxElapsedTime{};
  shared_ptr<double> maxReturnRows{};
  shared_ptr<double> maxUserIoWaitTime{};
  shared_ptr<double> maxWaitTime{};
  shared_ptr<double> missPlanPercentage{};
  shared_ptr<double> missPlans{};
  shared_ptr<double> remotePlanPercentage{};
  shared_ptr<double> remotePlans{};
  shared_ptr<long> retCode4012Count{};
  shared_ptr<long> retCode4013Count{};
  shared_ptr<long> retCode5001Count{};
  shared_ptr<long> retCode5024Count{};
  shared_ptr<long> retCode5167Count{};
  shared_ptr<long> retCode5217Count{};
  shared_ptr<long> retCode6002Count{};
  shared_ptr<double> retryCount{};
  shared_ptr<double> rpcCount{};
  shared_ptr<string> server{};
  shared_ptr<string> serverIp{};
  shared_ptr<long> serverPort{};
  shared_ptr<string> sqlId{};
  shared_ptr<string> sqlTextShort{};
  shared_ptr<string> sqlType{};
  shared_ptr<double> strongConsistencyPercentage{};
  shared_ptr<double> sumDbTime{};
  shared_ptr<double> sumElapsedTime{};
  shared_ptr<double> sumLogicalReads{};
  shared_ptr<double> sumWaitTime{};
  shared_ptr<double> tableScanPercentage{};
  shared_ptr<double> totalWaitTime{};
  shared_ptr<string> userName{};
  shared_ptr<string> waitEvent{};
  shared_ptr<double> weakConsistencyPercentage{};

  DescribeOasTopSQLListResponseBodyDataSqlList() {}

  explicit DescribeOasTopSQLListResponseBodyDataSqlList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (avgAffectedRows) {
      res["AvgAffectedRows"] = boost::any(*avgAffectedRows);
    }
    if (avgApplicationWaitTime) {
      res["AvgApplicationWaitTime"] = boost::any(*avgApplicationWaitTime);
    }
    if (avgBlockCacheHit) {
      res["AvgBlockCacheHit"] = boost::any(*avgBlockCacheHit);
    }
    if (avgBlockIndexCacheHit) {
      res["AvgBlockIndexCacheHit"] = boost::any(*avgBlockIndexCacheHit);
    }
    if (avgBloomFilterCacheHit) {
      res["AvgBloomFilterCacheHit"] = boost::any(*avgBloomFilterCacheHit);
    }
    if (avgConcurrencyWaitTime) {
      res["AvgConcurrencyWaitTime"] = boost::any(*avgConcurrencyWaitTime);
    }
    if (avgCpuTime) {
      res["AvgCpuTime"] = boost::any(*avgCpuTime);
    }
    if (avgDbTime) {
      res["AvgDbTime"] = boost::any(*avgDbTime);
    }
    if (avgDecodeTime) {
      res["AvgDecodeTime"] = boost::any(*avgDecodeTime);
    }
    if (avgDiskReads) {
      res["AvgDiskReads"] = boost::any(*avgDiskReads);
    }
    if (avgElapsedTime) {
      res["AvgElapsedTime"] = boost::any(*avgElapsedTime);
    }
    if (avgExecuteTime) {
      res["AvgExecuteTime"] = boost::any(*avgExecuteTime);
    }
    if (avgExecutorRpcCount) {
      res["AvgExecutorRpcCount"] = boost::any(*avgExecutorRpcCount);
    }
    if (avgExpectedWorkerCount) {
      res["AvgExpectedWorkerCount"] = boost::any(*avgExpectedWorkerCount);
    }
    if (avgGetPlanTime) {
      res["AvgGetPlanTime"] = boost::any(*avgGetPlanTime);
    }
    if (avgLogicalReads) {
      res["AvgLogicalReads"] = boost::any(*avgLogicalReads);
    }
    if (avgMemstoreReadRows) {
      res["AvgMemstoreReadRows"] = boost::any(*avgMemstoreReadRows);
    }
    if (avgNetTime) {
      res["AvgNetTime"] = boost::any(*avgNetTime);
    }
    if (avgNetWaitTime) {
      res["AvgNetWaitTime"] = boost::any(*avgNetWaitTime);
    }
    if (avgPartitionCount) {
      res["AvgPartitionCount"] = boost::any(*avgPartitionCount);
    }
    if (avgQueueTime) {
      res["AvgQueueTime"] = boost::any(*avgQueueTime);
    }
    if (avgReturnRows) {
      res["AvgReturnRows"] = boost::any(*avgReturnRows);
    }
    if (avgRowCacheHit) {
      res["AvgRowCacheHit"] = boost::any(*avgRowCacheHit);
    }
    if (avgRpcCount) {
      res["AvgRpcCount"] = boost::any(*avgRpcCount);
    }
    if (avgScheduleTime) {
      res["AvgScheduleTime"] = boost::any(*avgScheduleTime);
    }
    if (avgSsstoreReadRows) {
      res["AvgSsstoreReadRows"] = boost::any(*avgSsstoreReadRows);
    }
    if (avgUsedWorkerCount) {
      res["AvgUsedWorkerCount"] = boost::any(*avgUsedWorkerCount);
    }
    if (avgUserIoWaitTime) {
      res["AvgUserIoWaitTime"] = boost::any(*avgUserIoWaitTime);
    }
    if (avgWaitCount) {
      res["AvgWaitCount"] = boost::any(*avgWaitCount);
    }
    if (avgWaitTime) {
      res["AvgWaitTime"] = boost::any(*avgWaitTime);
    }
    if (clientIp) {
      res["ClientIp"] = boost::any(*clientIp);
    }
    if (cpuPercentage) {
      res["CpuPercentage"] = boost::any(*cpuPercentage);
    }
    if (dbName) {
      res["DbName"] = boost::any(*dbName);
    }
    if (distPlanPercentage) {
      res["DistPlanPercentage"] = boost::any(*distPlanPercentage);
    }
    if (execPs) {
      res["ExecPs"] = boost::any(*execPs);
    }
    if (executions) {
      res["Executions"] = boost::any(*executions);
    }
    if (failCount) {
      res["FailCount"] = boost::any(*failCount);
    }
    if (failPercentage) {
      res["FailPercentage"] = boost::any(*failPercentage);
    }
    if (inner) {
      res["Inner"] = boost::any(*inner);
    }
    if (localPlanPercentage) {
      res["LocalPlanPercentage"] = boost::any(*localPlanPercentage);
    }
    if (maxAffectedRows) {
      res["MaxAffectedRows"] = boost::any(*maxAffectedRows);
    }
    if (maxApplicationWaitTime) {
      res["MaxApplicationWaitTime"] = boost::any(*maxApplicationWaitTime);
    }
    if (maxConcurrencyWaitTime) {
      res["MaxConcurrencyWaitTime"] = boost::any(*maxConcurrencyWaitTime);
    }
    if (maxCpuTime) {
      res["MaxCpuTime"] = boost::any(*maxCpuTime);
    }
    if (maxDiskReads) {
      res["MaxDiskReads"] = boost::any(*maxDiskReads);
    }
    if (maxElapsedTime) {
      res["MaxElapsedTime"] = boost::any(*maxElapsedTime);
    }
    if (maxReturnRows) {
      res["MaxReturnRows"] = boost::any(*maxReturnRows);
    }
    if (maxUserIoWaitTime) {
      res["MaxUserIoWaitTime"] = boost::any(*maxUserIoWaitTime);
    }
    if (maxWaitTime) {
      res["MaxWaitTime"] = boost::any(*maxWaitTime);
    }
    if (missPlanPercentage) {
      res["MissPlanPercentage"] = boost::any(*missPlanPercentage);
    }
    if (missPlans) {
      res["MissPlans"] = boost::any(*missPlans);
    }
    if (remotePlanPercentage) {
      res["RemotePlanPercentage"] = boost::any(*remotePlanPercentage);
    }
    if (remotePlans) {
      res["RemotePlans"] = boost::any(*remotePlans);
    }
    if (retCode4012Count) {
      res["RetCode4012Count"] = boost::any(*retCode4012Count);
    }
    if (retCode4013Count) {
      res["RetCode4013Count"] = boost::any(*retCode4013Count);
    }
    if (retCode5001Count) {
      res["RetCode5001Count"] = boost::any(*retCode5001Count);
    }
    if (retCode5024Count) {
      res["RetCode5024Count"] = boost::any(*retCode5024Count);
    }
    if (retCode5167Count) {
      res["RetCode5167Count"] = boost::any(*retCode5167Count);
    }
    if (retCode5217Count) {
      res["RetCode5217Count"] = boost::any(*retCode5217Count);
    }
    if (retCode6002Count) {
      res["RetCode6002Count"] = boost::any(*retCode6002Count);
    }
    if (retryCount) {
      res["RetryCount"] = boost::any(*retryCount);
    }
    if (rpcCount) {
      res["RpcCount"] = boost::any(*rpcCount);
    }
    if (server) {
      res["Server"] = boost::any(*server);
    }
    if (serverIp) {
      res["ServerIp"] = boost::any(*serverIp);
    }
    if (serverPort) {
      res["ServerPort"] = boost::any(*serverPort);
    }
    if (sqlId) {
      res["SqlId"] = boost::any(*sqlId);
    }
    if (sqlTextShort) {
      res["SqlTextShort"] = boost::any(*sqlTextShort);
    }
    if (sqlType) {
      res["SqlType"] = boost::any(*sqlType);
    }
    if (strongConsistencyPercentage) {
      res["StrongConsistencyPercentage"] = boost::any(*strongConsistencyPercentage);
    }
    if (sumDbTime) {
      res["SumDbTime"] = boost::any(*sumDbTime);
    }
    if (sumElapsedTime) {
      res["SumElapsedTime"] = boost::any(*sumElapsedTime);
    }
    if (sumLogicalReads) {
      res["SumLogicalReads"] = boost::any(*sumLogicalReads);
    }
    if (sumWaitTime) {
      res["SumWaitTime"] = boost::any(*sumWaitTime);
    }
    if (tableScanPercentage) {
      res["TableScanPercentage"] = boost::any(*tableScanPercentage);
    }
    if (totalWaitTime) {
      res["TotalWaitTime"] = boost::any(*totalWaitTime);
    }
    if (userName) {
      res["UserName"] = boost::any(*userName);
    }
    if (waitEvent) {
      res["WaitEvent"] = boost::any(*waitEvent);
    }
    if (weakConsistencyPercentage) {
      res["WeakConsistencyPercentage"] = boost::any(*weakConsistencyPercentage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AvgAffectedRows") != m.end() && !m["AvgAffectedRows"].empty()) {
      avgAffectedRows = make_shared<double>(boost::any_cast<double>(m["AvgAffectedRows"]));
    }
    if (m.find("AvgApplicationWaitTime") != m.end() && !m["AvgApplicationWaitTime"].empty()) {
      avgApplicationWaitTime = make_shared<double>(boost::any_cast<double>(m["AvgApplicationWaitTime"]));
    }
    if (m.find("AvgBlockCacheHit") != m.end() && !m["AvgBlockCacheHit"].empty()) {
      avgBlockCacheHit = make_shared<double>(boost::any_cast<double>(m["AvgBlockCacheHit"]));
    }
    if (m.find("AvgBlockIndexCacheHit") != m.end() && !m["AvgBlockIndexCacheHit"].empty()) {
      avgBlockIndexCacheHit = make_shared<double>(boost::any_cast<double>(m["AvgBlockIndexCacheHit"]));
    }
    if (m.find("AvgBloomFilterCacheHit") != m.end() && !m["AvgBloomFilterCacheHit"].empty()) {
      avgBloomFilterCacheHit = make_shared<double>(boost::any_cast<double>(m["AvgBloomFilterCacheHit"]));
    }
    if (m.find("AvgConcurrencyWaitTime") != m.end() && !m["AvgConcurrencyWaitTime"].empty()) {
      avgConcurrencyWaitTime = make_shared<double>(boost::any_cast<double>(m["AvgConcurrencyWaitTime"]));
    }
    if (m.find("AvgCpuTime") != m.end() && !m["AvgCpuTime"].empty()) {
      avgCpuTime = make_shared<double>(boost::any_cast<double>(m["AvgCpuTime"]));
    }
    if (m.find("AvgDbTime") != m.end() && !m["AvgDbTime"].empty()) {
      avgDbTime = make_shared<double>(boost::any_cast<double>(m["AvgDbTime"]));
    }
    if (m.find("AvgDecodeTime") != m.end() && !m["AvgDecodeTime"].empty()) {
      avgDecodeTime = make_shared<double>(boost::any_cast<double>(m["AvgDecodeTime"]));
    }
    if (m.find("AvgDiskReads") != m.end() && !m["AvgDiskReads"].empty()) {
      avgDiskReads = make_shared<double>(boost::any_cast<double>(m["AvgDiskReads"]));
    }
    if (m.find("AvgElapsedTime") != m.end() && !m["AvgElapsedTime"].empty()) {
      avgElapsedTime = make_shared<double>(boost::any_cast<double>(m["AvgElapsedTime"]));
    }
    if (m.find("AvgExecuteTime") != m.end() && !m["AvgExecuteTime"].empty()) {
      avgExecuteTime = make_shared<double>(boost::any_cast<double>(m["AvgExecuteTime"]));
    }
    if (m.find("AvgExecutorRpcCount") != m.end() && !m["AvgExecutorRpcCount"].empty()) {
      avgExecutorRpcCount = make_shared<double>(boost::any_cast<double>(m["AvgExecutorRpcCount"]));
    }
    if (m.find("AvgExpectedWorkerCount") != m.end() && !m["AvgExpectedWorkerCount"].empty()) {
      avgExpectedWorkerCount = make_shared<double>(boost::any_cast<double>(m["AvgExpectedWorkerCount"]));
    }
    if (m.find("AvgGetPlanTime") != m.end() && !m["AvgGetPlanTime"].empty()) {
      avgGetPlanTime = make_shared<double>(boost::any_cast<double>(m["AvgGetPlanTime"]));
    }
    if (m.find("AvgLogicalReads") != m.end() && !m["AvgLogicalReads"].empty()) {
      avgLogicalReads = make_shared<double>(boost::any_cast<double>(m["AvgLogicalReads"]));
    }
    if (m.find("AvgMemstoreReadRows") != m.end() && !m["AvgMemstoreReadRows"].empty()) {
      avgMemstoreReadRows = make_shared<double>(boost::any_cast<double>(m["AvgMemstoreReadRows"]));
    }
    if (m.find("AvgNetTime") != m.end() && !m["AvgNetTime"].empty()) {
      avgNetTime = make_shared<double>(boost::any_cast<double>(m["AvgNetTime"]));
    }
    if (m.find("AvgNetWaitTime") != m.end() && !m["AvgNetWaitTime"].empty()) {
      avgNetWaitTime = make_shared<double>(boost::any_cast<double>(m["AvgNetWaitTime"]));
    }
    if (m.find("AvgPartitionCount") != m.end() && !m["AvgPartitionCount"].empty()) {
      avgPartitionCount = make_shared<double>(boost::any_cast<double>(m["AvgPartitionCount"]));
    }
    if (m.find("AvgQueueTime") != m.end() && !m["AvgQueueTime"].empty()) {
      avgQueueTime = make_shared<double>(boost::any_cast<double>(m["AvgQueueTime"]));
    }
    if (m.find("AvgReturnRows") != m.end() && !m["AvgReturnRows"].empty()) {
      avgReturnRows = make_shared<double>(boost::any_cast<double>(m["AvgReturnRows"]));
    }
    if (m.find("AvgRowCacheHit") != m.end() && !m["AvgRowCacheHit"].empty()) {
      avgRowCacheHit = make_shared<double>(boost::any_cast<double>(m["AvgRowCacheHit"]));
    }
    if (m.find("AvgRpcCount") != m.end() && !m["AvgRpcCount"].empty()) {
      avgRpcCount = make_shared<double>(boost::any_cast<double>(m["AvgRpcCount"]));
    }
    if (m.find("AvgScheduleTime") != m.end() && !m["AvgScheduleTime"].empty()) {
      avgScheduleTime = make_shared<double>(boost::any_cast<double>(m["AvgScheduleTime"]));
    }
    if (m.find("AvgSsstoreReadRows") != m.end() && !m["AvgSsstoreReadRows"].empty()) {
      avgSsstoreReadRows = make_shared<double>(boost::any_cast<double>(m["AvgSsstoreReadRows"]));
    }
    if (m.find("AvgUsedWorkerCount") != m.end() && !m["AvgUsedWorkerCount"].empty()) {
      avgUsedWorkerCount = make_shared<double>(boost::any_cast<double>(m["AvgUsedWorkerCount"]));
    }
    if (m.find("AvgUserIoWaitTime") != m.end() && !m["AvgUserIoWaitTime"].empty()) {
      avgUserIoWaitTime = make_shared<double>(boost::any_cast<double>(m["AvgUserIoWaitTime"]));
    }
    if (m.find("AvgWaitCount") != m.end() && !m["AvgWaitCount"].empty()) {
      avgWaitCount = make_shared<double>(boost::any_cast<double>(m["AvgWaitCount"]));
    }
    if (m.find("AvgWaitTime") != m.end() && !m["AvgWaitTime"].empty()) {
      avgWaitTime = make_shared<double>(boost::any_cast<double>(m["AvgWaitTime"]));
    }
    if (m.find("ClientIp") != m.end() && !m["ClientIp"].empty()) {
      clientIp = make_shared<string>(boost::any_cast<string>(m["ClientIp"]));
    }
    if (m.find("CpuPercentage") != m.end() && !m["CpuPercentage"].empty()) {
      cpuPercentage = make_shared<double>(boost::any_cast<double>(m["CpuPercentage"]));
    }
    if (m.find("DbName") != m.end() && !m["DbName"].empty()) {
      dbName = make_shared<string>(boost::any_cast<string>(m["DbName"]));
    }
    if (m.find("DistPlanPercentage") != m.end() && !m["DistPlanPercentage"].empty()) {
      distPlanPercentage = make_shared<double>(boost::any_cast<double>(m["DistPlanPercentage"]));
    }
    if (m.find("ExecPs") != m.end() && !m["ExecPs"].empty()) {
      execPs = make_shared<double>(boost::any_cast<double>(m["ExecPs"]));
    }
    if (m.find("Executions") != m.end() && !m["Executions"].empty()) {
      executions = make_shared<double>(boost::any_cast<double>(m["Executions"]));
    }
    if (m.find("FailCount") != m.end() && !m["FailCount"].empty()) {
      failCount = make_shared<double>(boost::any_cast<double>(m["FailCount"]));
    }
    if (m.find("FailPercentage") != m.end() && !m["FailPercentage"].empty()) {
      failPercentage = make_shared<double>(boost::any_cast<double>(m["FailPercentage"]));
    }
    if (m.find("Inner") != m.end() && !m["Inner"].empty()) {
      inner = make_shared<bool>(boost::any_cast<bool>(m["Inner"]));
    }
    if (m.find("LocalPlanPercentage") != m.end() && !m["LocalPlanPercentage"].empty()) {
      localPlanPercentage = make_shared<double>(boost::any_cast<double>(m["LocalPlanPercentage"]));
    }
    if (m.find("MaxAffectedRows") != m.end() && !m["MaxAffectedRows"].empty()) {
      maxAffectedRows = make_shared<double>(boost::any_cast<double>(m["MaxAffectedRows"]));
    }
    if (m.find("MaxApplicationWaitTime") != m.end() && !m["MaxApplicationWaitTime"].empty()) {
      maxApplicationWaitTime = make_shared<double>(boost::any_cast<double>(m["MaxApplicationWaitTime"]));
    }
    if (m.find("MaxConcurrencyWaitTime") != m.end() && !m["MaxConcurrencyWaitTime"].empty()) {
      maxConcurrencyWaitTime = make_shared<double>(boost::any_cast<double>(m["MaxConcurrencyWaitTime"]));
    }
    if (m.find("MaxCpuTime") != m.end() && !m["MaxCpuTime"].empty()) {
      maxCpuTime = make_shared<double>(boost::any_cast<double>(m["MaxCpuTime"]));
    }
    if (m.find("MaxDiskReads") != m.end() && !m["MaxDiskReads"].empty()) {
      maxDiskReads = make_shared<double>(boost::any_cast<double>(m["MaxDiskReads"]));
    }
    if (m.find("MaxElapsedTime") != m.end() && !m["MaxElapsedTime"].empty()) {
      maxElapsedTime = make_shared<double>(boost::any_cast<double>(m["MaxElapsedTime"]));
    }
    if (m.find("MaxReturnRows") != m.end() && !m["MaxReturnRows"].empty()) {
      maxReturnRows = make_shared<double>(boost::any_cast<double>(m["MaxReturnRows"]));
    }
    if (m.find("MaxUserIoWaitTime") != m.end() && !m["MaxUserIoWaitTime"].empty()) {
      maxUserIoWaitTime = make_shared<double>(boost::any_cast<double>(m["MaxUserIoWaitTime"]));
    }
    if (m.find("MaxWaitTime") != m.end() && !m["MaxWaitTime"].empty()) {
      maxWaitTime = make_shared<double>(boost::any_cast<double>(m["MaxWaitTime"]));
    }
    if (m.find("MissPlanPercentage") != m.end() && !m["MissPlanPercentage"].empty()) {
      missPlanPercentage = make_shared<double>(boost::any_cast<double>(m["MissPlanPercentage"]));
    }
    if (m.find("MissPlans") != m.end() && !m["MissPlans"].empty()) {
      missPlans = make_shared<double>(boost::any_cast<double>(m["MissPlans"]));
    }
    if (m.find("RemotePlanPercentage") != m.end() && !m["RemotePlanPercentage"].empty()) {
      remotePlanPercentage = make_shared<double>(boost::any_cast<double>(m["RemotePlanPercentage"]));
    }
    if (m.find("RemotePlans") != m.end() && !m["RemotePlans"].empty()) {
      remotePlans = make_shared<double>(boost::any_cast<double>(m["RemotePlans"]));
    }
    if (m.find("RetCode4012Count") != m.end() && !m["RetCode4012Count"].empty()) {
      retCode4012Count = make_shared<long>(boost::any_cast<long>(m["RetCode4012Count"]));
    }
    if (m.find("RetCode4013Count") != m.end() && !m["RetCode4013Count"].empty()) {
      retCode4013Count = make_shared<long>(boost::any_cast<long>(m["RetCode4013Count"]));
    }
    if (m.find("RetCode5001Count") != m.end() && !m["RetCode5001Count"].empty()) {
      retCode5001Count = make_shared<long>(boost::any_cast<long>(m["RetCode5001Count"]));
    }
    if (m.find("RetCode5024Count") != m.end() && !m["RetCode5024Count"].empty()) {
      retCode5024Count = make_shared<long>(boost::any_cast<long>(m["RetCode5024Count"]));
    }
    if (m.find("RetCode5167Count") != m.end() && !m["RetCode5167Count"].empty()) {
      retCode5167Count = make_shared<long>(boost::any_cast<long>(m["RetCode5167Count"]));
    }
    if (m.find("RetCode5217Count") != m.end() && !m["RetCode5217Count"].empty()) {
      retCode5217Count = make_shared<long>(boost::any_cast<long>(m["RetCode5217Count"]));
    }
    if (m.find("RetCode6002Count") != m.end() && !m["RetCode6002Count"].empty()) {
      retCode6002Count = make_shared<long>(boost::any_cast<long>(m["RetCode6002Count"]));
    }
    if (m.find("RetryCount") != m.end() && !m["RetryCount"].empty()) {
      retryCount = make_shared<double>(boost::any_cast<double>(m["RetryCount"]));
    }
    if (m.find("RpcCount") != m.end() && !m["RpcCount"].empty()) {
      rpcCount = make_shared<double>(boost::any_cast<double>(m["RpcCount"]));
    }
    if (m.find("Server") != m.end() && !m["Server"].empty()) {
      server = make_shared<string>(boost::any_cast<string>(m["Server"]));
    }
    if (m.find("ServerIp") != m.end() && !m["ServerIp"].empty()) {
      serverIp = make_shared<string>(boost::any_cast<string>(m["ServerIp"]));
    }
    if (m.find("ServerPort") != m.end() && !m["ServerPort"].empty()) {
      serverPort = make_shared<long>(boost::any_cast<long>(m["ServerPort"]));
    }
    if (m.find("SqlId") != m.end() && !m["SqlId"].empty()) {
      sqlId = make_shared<string>(boost::any_cast<string>(m["SqlId"]));
    }
    if (m.find("SqlTextShort") != m.end() && !m["SqlTextShort"].empty()) {
      sqlTextShort = make_shared<string>(boost::any_cast<string>(m["SqlTextShort"]));
    }
    if (m.find("SqlType") != m.end() && !m["SqlType"].empty()) {
      sqlType = make_shared<string>(boost::any_cast<string>(m["SqlType"]));
    }
    if (m.find("StrongConsistencyPercentage") != m.end() && !m["StrongConsistencyPercentage"].empty()) {
      strongConsistencyPercentage = make_shared<double>(boost::any_cast<double>(m["StrongConsistencyPercentage"]));
    }
    if (m.find("SumDbTime") != m.end() && !m["SumDbTime"].empty()) {
      sumDbTime = make_shared<double>(boost::any_cast<double>(m["SumDbTime"]));
    }
    if (m.find("SumElapsedTime") != m.end() && !m["SumElapsedTime"].empty()) {
      sumElapsedTime = make_shared<double>(boost::any_cast<double>(m["SumElapsedTime"]));
    }
    if (m.find("SumLogicalReads") != m.end() && !m["SumLogicalReads"].empty()) {
      sumLogicalReads = make_shared<double>(boost::any_cast<double>(m["SumLogicalReads"]));
    }
    if (m.find("SumWaitTime") != m.end() && !m["SumWaitTime"].empty()) {
      sumWaitTime = make_shared<double>(boost::any_cast<double>(m["SumWaitTime"]));
    }
    if (m.find("TableScanPercentage") != m.end() && !m["TableScanPercentage"].empty()) {
      tableScanPercentage = make_shared<double>(boost::any_cast<double>(m["TableScanPercentage"]));
    }
    if (m.find("TotalWaitTime") != m.end() && !m["TotalWaitTime"].empty()) {
      totalWaitTime = make_shared<double>(boost::any_cast<double>(m["TotalWaitTime"]));
    }
    if (m.find("UserName") != m.end() && !m["UserName"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["UserName"]));
    }
    if (m.find("WaitEvent") != m.end() && !m["WaitEvent"].empty()) {
      waitEvent = make_shared<string>(boost::any_cast<string>(m["WaitEvent"]));
    }
    if (m.find("WeakConsistencyPercentage") != m.end() && !m["WeakConsistencyPercentage"].empty()) {
      weakConsistencyPercentage = make_shared<double>(boost::any_cast<double>(m["WeakConsistencyPercentage"]));
    }
  }


  virtual ~DescribeOasTopSQLListResponseBodyDataSqlList() = default;
};
class DescribeOasTopSQLListResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<double> avgAffectedRows{};
  shared_ptr<double> avgApplicationWaitTime{};
  shared_ptr<double> avgBlockCacheHit{};
  shared_ptr<double> avgBlockIndexCacheHit{};
  shared_ptr<double> avgBloomFilterCacheHit{};
  shared_ptr<double> avgConcurrencyWaitTime{};
  shared_ptr<double> avgCpuTime{};
  shared_ptr<double> avgDbTime{};
  shared_ptr<double> avgDecodeTime{};
  shared_ptr<double> avgDiskReads{};
  shared_ptr<double> avgElapsedTime{};
  shared_ptr<double> avgExecuteTime{};
  shared_ptr<double> avgExecutorRpcCount{};
  shared_ptr<double> avgExpectedWorkerCount{};
  shared_ptr<double> avgGetPlanTime{};
  shared_ptr<double> avgLogicalReads{};
  shared_ptr<double> avgMemstoreReadRows{};
  shared_ptr<double> avgNetTime{};
  shared_ptr<double> avgNetWaitTime{};
  shared_ptr<double> avgPartitionCount{};
  shared_ptr<double> avgQueueTime{};
  shared_ptr<double> avgReturnRows{};
  shared_ptr<double> avgRowCacheHit{};
  shared_ptr<double> avgRpcCount{};
  shared_ptr<double> avgScheduleTime{};
  shared_ptr<double> avgSsstoreReadRows{};
  shared_ptr<double> avgUsedWorkerCount{};
  shared_ptr<double> avgUserIoWaitTime{};
  shared_ptr<double> avgWaitCount{};
  shared_ptr<double> avgWaitTime{};
  shared_ptr<string> clientIp{};
  shared_ptr<double> cpuPercentage{};
  shared_ptr<string> dbName{};
  shared_ptr<double> distPlanPercentage{};
  shared_ptr<bool> dynamicSql{};
  shared_ptr<double> execPs{};
  shared_ptr<double> executions{};
  shared_ptr<double> failCount{};
  shared_ptr<double> failPercentage{};
  shared_ptr<bool> inner{};
  shared_ptr<long> lastFailCode{};
  shared_ptr<double> localPlanPercentage{};
  shared_ptr<double> maxAffectedRows{};
  shared_ptr<double> maxApplicationWaitTime{};
  shared_ptr<double> maxConcurrencyWaitTime{};
  shared_ptr<double> maxCpuTime{};
  shared_ptr<double> maxDiskReads{};
  shared_ptr<double> maxElapsedTime{};
  shared_ptr<double> maxReturnRows{};
  shared_ptr<double> maxUserIoWaitTime{};
  shared_ptr<double> maxWaitTime{};
  shared_ptr<double> missPlanPercentage{};
  shared_ptr<double> missPlans{};
  shared_ptr<double> remotePlanPercentage{};
  shared_ptr<double> remotePlans{};
  shared_ptr<long> retCode4012Count{};
  shared_ptr<long> retCode4013Count{};
  shared_ptr<long> retCode5001Count{};
  shared_ptr<long> retCode5024Count{};
  shared_ptr<long> retCode5167Count{};
  shared_ptr<long> retCode5217Count{};
  shared_ptr<long> retCode6002Count{};
  shared_ptr<double> retryCount{};
  shared_ptr<double> rpcCount{};
  shared_ptr<string> server{};
  shared_ptr<string> serverIp{};
  shared_ptr<long> serverPort{};
  shared_ptr<string> sqlId{};
  shared_ptr<vector<DescribeOasTopSQLListResponseBodyDataSqlList>> sqlList{};
  shared_ptr<string> sqlTextShort{};
  shared_ptr<string> sqlType{};
  shared_ptr<double> strongConsistencyPercentage{};
  shared_ptr<double> sumDbTime{};
  shared_ptr<double> sumElapsedTime{};
  shared_ptr<double> sumLogicalReads{};
  shared_ptr<double> sumWaitTime{};
  shared_ptr<double> tableScanPercentage{};
  shared_ptr<double> totalWaitTime{};
  shared_ptr<string> userName{};
  shared_ptr<string> waitEvent{};
  shared_ptr<double> weakConsistencyPercentage{};

  DescribeOasTopSQLListResponseBodyData() {}

  explicit DescribeOasTopSQLListResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (avgAffectedRows) {
      res["AvgAffectedRows"] = boost::any(*avgAffectedRows);
    }
    if (avgApplicationWaitTime) {
      res["AvgApplicationWaitTime"] = boost::any(*avgApplicationWaitTime);
    }
    if (avgBlockCacheHit) {
      res["AvgBlockCacheHit"] = boost::any(*avgBlockCacheHit);
    }
    if (avgBlockIndexCacheHit) {
      res["AvgBlockIndexCacheHit"] = boost::any(*avgBlockIndexCacheHit);
    }
    if (avgBloomFilterCacheHit) {
      res["AvgBloomFilterCacheHit"] = boost::any(*avgBloomFilterCacheHit);
    }
    if (avgConcurrencyWaitTime) {
      res["AvgConcurrencyWaitTime"] = boost::any(*avgConcurrencyWaitTime);
    }
    if (avgCpuTime) {
      res["AvgCpuTime"] = boost::any(*avgCpuTime);
    }
    if (avgDbTime) {
      res["AvgDbTime"] = boost::any(*avgDbTime);
    }
    if (avgDecodeTime) {
      res["AvgDecodeTime"] = boost::any(*avgDecodeTime);
    }
    if (avgDiskReads) {
      res["AvgDiskReads"] = boost::any(*avgDiskReads);
    }
    if (avgElapsedTime) {
      res["AvgElapsedTime"] = boost::any(*avgElapsedTime);
    }
    if (avgExecuteTime) {
      res["AvgExecuteTime"] = boost::any(*avgExecuteTime);
    }
    if (avgExecutorRpcCount) {
      res["AvgExecutorRpcCount"] = boost::any(*avgExecutorRpcCount);
    }
    if (avgExpectedWorkerCount) {
      res["AvgExpectedWorkerCount"] = boost::any(*avgExpectedWorkerCount);
    }
    if (avgGetPlanTime) {
      res["AvgGetPlanTime"] = boost::any(*avgGetPlanTime);
    }
    if (avgLogicalReads) {
      res["AvgLogicalReads"] = boost::any(*avgLogicalReads);
    }
    if (avgMemstoreReadRows) {
      res["AvgMemstoreReadRows"] = boost::any(*avgMemstoreReadRows);
    }
    if (avgNetTime) {
      res["AvgNetTime"] = boost::any(*avgNetTime);
    }
    if (avgNetWaitTime) {
      res["AvgNetWaitTime"] = boost::any(*avgNetWaitTime);
    }
    if (avgPartitionCount) {
      res["AvgPartitionCount"] = boost::any(*avgPartitionCount);
    }
    if (avgQueueTime) {
      res["AvgQueueTime"] = boost::any(*avgQueueTime);
    }
    if (avgReturnRows) {
      res["AvgReturnRows"] = boost::any(*avgReturnRows);
    }
    if (avgRowCacheHit) {
      res["AvgRowCacheHit"] = boost::any(*avgRowCacheHit);
    }
    if (avgRpcCount) {
      res["AvgRpcCount"] = boost::any(*avgRpcCount);
    }
    if (avgScheduleTime) {
      res["AvgScheduleTime"] = boost::any(*avgScheduleTime);
    }
    if (avgSsstoreReadRows) {
      res["AvgSsstoreReadRows"] = boost::any(*avgSsstoreReadRows);
    }
    if (avgUsedWorkerCount) {
      res["AvgUsedWorkerCount"] = boost::any(*avgUsedWorkerCount);
    }
    if (avgUserIoWaitTime) {
      res["AvgUserIoWaitTime"] = boost::any(*avgUserIoWaitTime);
    }
    if (avgWaitCount) {
      res["AvgWaitCount"] = boost::any(*avgWaitCount);
    }
    if (avgWaitTime) {
      res["AvgWaitTime"] = boost::any(*avgWaitTime);
    }
    if (clientIp) {
      res["ClientIp"] = boost::any(*clientIp);
    }
    if (cpuPercentage) {
      res["CpuPercentage"] = boost::any(*cpuPercentage);
    }
    if (dbName) {
      res["DbName"] = boost::any(*dbName);
    }
    if (distPlanPercentage) {
      res["DistPlanPercentage"] = boost::any(*distPlanPercentage);
    }
    if (dynamicSql) {
      res["DynamicSql"] = boost::any(*dynamicSql);
    }
    if (execPs) {
      res["ExecPs"] = boost::any(*execPs);
    }
    if (executions) {
      res["Executions"] = boost::any(*executions);
    }
    if (failCount) {
      res["FailCount"] = boost::any(*failCount);
    }
    if (failPercentage) {
      res["FailPercentage"] = boost::any(*failPercentage);
    }
    if (inner) {
      res["Inner"] = boost::any(*inner);
    }
    if (lastFailCode) {
      res["LastFailCode"] = boost::any(*lastFailCode);
    }
    if (localPlanPercentage) {
      res["LocalPlanPercentage"] = boost::any(*localPlanPercentage);
    }
    if (maxAffectedRows) {
      res["MaxAffectedRows"] = boost::any(*maxAffectedRows);
    }
    if (maxApplicationWaitTime) {
      res["MaxApplicationWaitTime"] = boost::any(*maxApplicationWaitTime);
    }
    if (maxConcurrencyWaitTime) {
      res["MaxConcurrencyWaitTime"] = boost::any(*maxConcurrencyWaitTime);
    }
    if (maxCpuTime) {
      res["MaxCpuTime"] = boost::any(*maxCpuTime);
    }
    if (maxDiskReads) {
      res["MaxDiskReads"] = boost::any(*maxDiskReads);
    }
    if (maxElapsedTime) {
      res["MaxElapsedTime"] = boost::any(*maxElapsedTime);
    }
    if (maxReturnRows) {
      res["MaxReturnRows"] = boost::any(*maxReturnRows);
    }
    if (maxUserIoWaitTime) {
      res["MaxUserIoWaitTime"] = boost::any(*maxUserIoWaitTime);
    }
    if (maxWaitTime) {
      res["MaxWaitTime"] = boost::any(*maxWaitTime);
    }
    if (missPlanPercentage) {
      res["MissPlanPercentage"] = boost::any(*missPlanPercentage);
    }
    if (missPlans) {
      res["MissPlans"] = boost::any(*missPlans);
    }
    if (remotePlanPercentage) {
      res["RemotePlanPercentage"] = boost::any(*remotePlanPercentage);
    }
    if (remotePlans) {
      res["RemotePlans"] = boost::any(*remotePlans);
    }
    if (retCode4012Count) {
      res["RetCode4012Count"] = boost::any(*retCode4012Count);
    }
    if (retCode4013Count) {
      res["RetCode4013Count"] = boost::any(*retCode4013Count);
    }
    if (retCode5001Count) {
      res["RetCode5001Count"] = boost::any(*retCode5001Count);
    }
    if (retCode5024Count) {
      res["RetCode5024Count"] = boost::any(*retCode5024Count);
    }
    if (retCode5167Count) {
      res["RetCode5167Count"] = boost::any(*retCode5167Count);
    }
    if (retCode5217Count) {
      res["RetCode5217Count"] = boost::any(*retCode5217Count);
    }
    if (retCode6002Count) {
      res["RetCode6002Count"] = boost::any(*retCode6002Count);
    }
    if (retryCount) {
      res["RetryCount"] = boost::any(*retryCount);
    }
    if (rpcCount) {
      res["RpcCount"] = boost::any(*rpcCount);
    }
    if (server) {
      res["Server"] = boost::any(*server);
    }
    if (serverIp) {
      res["ServerIp"] = boost::any(*serverIp);
    }
    if (serverPort) {
      res["ServerPort"] = boost::any(*serverPort);
    }
    if (sqlId) {
      res["SqlId"] = boost::any(*sqlId);
    }
    if (sqlList) {
      vector<boost::any> temp1;
      for(auto item1:*sqlList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SqlList"] = boost::any(temp1);
    }
    if (sqlTextShort) {
      res["SqlTextShort"] = boost::any(*sqlTextShort);
    }
    if (sqlType) {
      res["SqlType"] = boost::any(*sqlType);
    }
    if (strongConsistencyPercentage) {
      res["StrongConsistencyPercentage"] = boost::any(*strongConsistencyPercentage);
    }
    if (sumDbTime) {
      res["SumDbTime"] = boost::any(*sumDbTime);
    }
    if (sumElapsedTime) {
      res["SumElapsedTime"] = boost::any(*sumElapsedTime);
    }
    if (sumLogicalReads) {
      res["SumLogicalReads"] = boost::any(*sumLogicalReads);
    }
    if (sumWaitTime) {
      res["SumWaitTime"] = boost::any(*sumWaitTime);
    }
    if (tableScanPercentage) {
      res["TableScanPercentage"] = boost::any(*tableScanPercentage);
    }
    if (totalWaitTime) {
      res["TotalWaitTime"] = boost::any(*totalWaitTime);
    }
    if (userName) {
      res["UserName"] = boost::any(*userName);
    }
    if (waitEvent) {
      res["WaitEvent"] = boost::any(*waitEvent);
    }
    if (weakConsistencyPercentage) {
      res["WeakConsistencyPercentage"] = boost::any(*weakConsistencyPercentage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AvgAffectedRows") != m.end() && !m["AvgAffectedRows"].empty()) {
      avgAffectedRows = make_shared<double>(boost::any_cast<double>(m["AvgAffectedRows"]));
    }
    if (m.find("AvgApplicationWaitTime") != m.end() && !m["AvgApplicationWaitTime"].empty()) {
      avgApplicationWaitTime = make_shared<double>(boost::any_cast<double>(m["AvgApplicationWaitTime"]));
    }
    if (m.find("AvgBlockCacheHit") != m.end() && !m["AvgBlockCacheHit"].empty()) {
      avgBlockCacheHit = make_shared<double>(boost::any_cast<double>(m["AvgBlockCacheHit"]));
    }
    if (m.find("AvgBlockIndexCacheHit") != m.end() && !m["AvgBlockIndexCacheHit"].empty()) {
      avgBlockIndexCacheHit = make_shared<double>(boost::any_cast<double>(m["AvgBlockIndexCacheHit"]));
    }
    if (m.find("AvgBloomFilterCacheHit") != m.end() && !m["AvgBloomFilterCacheHit"].empty()) {
      avgBloomFilterCacheHit = make_shared<double>(boost::any_cast<double>(m["AvgBloomFilterCacheHit"]));
    }
    if (m.find("AvgConcurrencyWaitTime") != m.end() && !m["AvgConcurrencyWaitTime"].empty()) {
      avgConcurrencyWaitTime = make_shared<double>(boost::any_cast<double>(m["AvgConcurrencyWaitTime"]));
    }
    if (m.find("AvgCpuTime") != m.end() && !m["AvgCpuTime"].empty()) {
      avgCpuTime = make_shared<double>(boost::any_cast<double>(m["AvgCpuTime"]));
    }
    if (m.find("AvgDbTime") != m.end() && !m["AvgDbTime"].empty()) {
      avgDbTime = make_shared<double>(boost::any_cast<double>(m["AvgDbTime"]));
    }
    if (m.find("AvgDecodeTime") != m.end() && !m["AvgDecodeTime"].empty()) {
      avgDecodeTime = make_shared<double>(boost::any_cast<double>(m["AvgDecodeTime"]));
    }
    if (m.find("AvgDiskReads") != m.end() && !m["AvgDiskReads"].empty()) {
      avgDiskReads = make_shared<double>(boost::any_cast<double>(m["AvgDiskReads"]));
    }
    if (m.find("AvgElapsedTime") != m.end() && !m["AvgElapsedTime"].empty()) {
      avgElapsedTime = make_shared<double>(boost::any_cast<double>(m["AvgElapsedTime"]));
    }
    if (m.find("AvgExecuteTime") != m.end() && !m["AvgExecuteTime"].empty()) {
      avgExecuteTime = make_shared<double>(boost::any_cast<double>(m["AvgExecuteTime"]));
    }
    if (m.find("AvgExecutorRpcCount") != m.end() && !m["AvgExecutorRpcCount"].empty()) {
      avgExecutorRpcCount = make_shared<double>(boost::any_cast<double>(m["AvgExecutorRpcCount"]));
    }
    if (m.find("AvgExpectedWorkerCount") != m.end() && !m["AvgExpectedWorkerCount"].empty()) {
      avgExpectedWorkerCount = make_shared<double>(boost::any_cast<double>(m["AvgExpectedWorkerCount"]));
    }
    if (m.find("AvgGetPlanTime") != m.end() && !m["AvgGetPlanTime"].empty()) {
      avgGetPlanTime = make_shared<double>(boost::any_cast<double>(m["AvgGetPlanTime"]));
    }
    if (m.find("AvgLogicalReads") != m.end() && !m["AvgLogicalReads"].empty()) {
      avgLogicalReads = make_shared<double>(boost::any_cast<double>(m["AvgLogicalReads"]));
    }
    if (m.find("AvgMemstoreReadRows") != m.end() && !m["AvgMemstoreReadRows"].empty()) {
      avgMemstoreReadRows = make_shared<double>(boost::any_cast<double>(m["AvgMemstoreReadRows"]));
    }
    if (m.find("AvgNetTime") != m.end() && !m["AvgNetTime"].empty()) {
      avgNetTime = make_shared<double>(boost::any_cast<double>(m["AvgNetTime"]));
    }
    if (m.find("AvgNetWaitTime") != m.end() && !m["AvgNetWaitTime"].empty()) {
      avgNetWaitTime = make_shared<double>(boost::any_cast<double>(m["AvgNetWaitTime"]));
    }
    if (m.find("AvgPartitionCount") != m.end() && !m["AvgPartitionCount"].empty()) {
      avgPartitionCount = make_shared<double>(boost::any_cast<double>(m["AvgPartitionCount"]));
    }
    if (m.find("AvgQueueTime") != m.end() && !m["AvgQueueTime"].empty()) {
      avgQueueTime = make_shared<double>(boost::any_cast<double>(m["AvgQueueTime"]));
    }
    if (m.find("AvgReturnRows") != m.end() && !m["AvgReturnRows"].empty()) {
      avgReturnRows = make_shared<double>(boost::any_cast<double>(m["AvgReturnRows"]));
    }
    if (m.find("AvgRowCacheHit") != m.end() && !m["AvgRowCacheHit"].empty()) {
      avgRowCacheHit = make_shared<double>(boost::any_cast<double>(m["AvgRowCacheHit"]));
    }
    if (m.find("AvgRpcCount") != m.end() && !m["AvgRpcCount"].empty()) {
      avgRpcCount = make_shared<double>(boost::any_cast<double>(m["AvgRpcCount"]));
    }
    if (m.find("AvgScheduleTime") != m.end() && !m["AvgScheduleTime"].empty()) {
      avgScheduleTime = make_shared<double>(boost::any_cast<double>(m["AvgScheduleTime"]));
    }
    if (m.find("AvgSsstoreReadRows") != m.end() && !m["AvgSsstoreReadRows"].empty()) {
      avgSsstoreReadRows = make_shared<double>(boost::any_cast<double>(m["AvgSsstoreReadRows"]));
    }
    if (m.find("AvgUsedWorkerCount") != m.end() && !m["AvgUsedWorkerCount"].empty()) {
      avgUsedWorkerCount = make_shared<double>(boost::any_cast<double>(m["AvgUsedWorkerCount"]));
    }
    if (m.find("AvgUserIoWaitTime") != m.end() && !m["AvgUserIoWaitTime"].empty()) {
      avgUserIoWaitTime = make_shared<double>(boost::any_cast<double>(m["AvgUserIoWaitTime"]));
    }
    if (m.find("AvgWaitCount") != m.end() && !m["AvgWaitCount"].empty()) {
      avgWaitCount = make_shared<double>(boost::any_cast<double>(m["AvgWaitCount"]));
    }
    if (m.find("AvgWaitTime") != m.end() && !m["AvgWaitTime"].empty()) {
      avgWaitTime = make_shared<double>(boost::any_cast<double>(m["AvgWaitTime"]));
    }
    if (m.find("ClientIp") != m.end() && !m["ClientIp"].empty()) {
      clientIp = make_shared<string>(boost::any_cast<string>(m["ClientIp"]));
    }
    if (m.find("CpuPercentage") != m.end() && !m["CpuPercentage"].empty()) {
      cpuPercentage = make_shared<double>(boost::any_cast<double>(m["CpuPercentage"]));
    }
    if (m.find("DbName") != m.end() && !m["DbName"].empty()) {
      dbName = make_shared<string>(boost::any_cast<string>(m["DbName"]));
    }
    if (m.find("DistPlanPercentage") != m.end() && !m["DistPlanPercentage"].empty()) {
      distPlanPercentage = make_shared<double>(boost::any_cast<double>(m["DistPlanPercentage"]));
    }
    if (m.find("DynamicSql") != m.end() && !m["DynamicSql"].empty()) {
      dynamicSql = make_shared<bool>(boost::any_cast<bool>(m["DynamicSql"]));
    }
    if (m.find("ExecPs") != m.end() && !m["ExecPs"].empty()) {
      execPs = make_shared<double>(boost::any_cast<double>(m["ExecPs"]));
    }
    if (m.find("Executions") != m.end() && !m["Executions"].empty()) {
      executions = make_shared<double>(boost::any_cast<double>(m["Executions"]));
    }
    if (m.find("FailCount") != m.end() && !m["FailCount"].empty()) {
      failCount = make_shared<double>(boost::any_cast<double>(m["FailCount"]));
    }
    if (m.find("FailPercentage") != m.end() && !m["FailPercentage"].empty()) {
      failPercentage = make_shared<double>(boost::any_cast<double>(m["FailPercentage"]));
    }
    if (m.find("Inner") != m.end() && !m["Inner"].empty()) {
      inner = make_shared<bool>(boost::any_cast<bool>(m["Inner"]));
    }
    if (m.find("LastFailCode") != m.end() && !m["LastFailCode"].empty()) {
      lastFailCode = make_shared<long>(boost::any_cast<long>(m["LastFailCode"]));
    }
    if (m.find("LocalPlanPercentage") != m.end() && !m["LocalPlanPercentage"].empty()) {
      localPlanPercentage = make_shared<double>(boost::any_cast<double>(m["LocalPlanPercentage"]));
    }
    if (m.find("MaxAffectedRows") != m.end() && !m["MaxAffectedRows"].empty()) {
      maxAffectedRows = make_shared<double>(boost::any_cast<double>(m["MaxAffectedRows"]));
    }
    if (m.find("MaxApplicationWaitTime") != m.end() && !m["MaxApplicationWaitTime"].empty()) {
      maxApplicationWaitTime = make_shared<double>(boost::any_cast<double>(m["MaxApplicationWaitTime"]));
    }
    if (m.find("MaxConcurrencyWaitTime") != m.end() && !m["MaxConcurrencyWaitTime"].empty()) {
      maxConcurrencyWaitTime = make_shared<double>(boost::any_cast<double>(m["MaxConcurrencyWaitTime"]));
    }
    if (m.find("MaxCpuTime") != m.end() && !m["MaxCpuTime"].empty()) {
      maxCpuTime = make_shared<double>(boost::any_cast<double>(m["MaxCpuTime"]));
    }
    if (m.find("MaxDiskReads") != m.end() && !m["MaxDiskReads"].empty()) {
      maxDiskReads = make_shared<double>(boost::any_cast<double>(m["MaxDiskReads"]));
    }
    if (m.find("MaxElapsedTime") != m.end() && !m["MaxElapsedTime"].empty()) {
      maxElapsedTime = make_shared<double>(boost::any_cast<double>(m["MaxElapsedTime"]));
    }
    if (m.find("MaxReturnRows") != m.end() && !m["MaxReturnRows"].empty()) {
      maxReturnRows = make_shared<double>(boost::any_cast<double>(m["MaxReturnRows"]));
    }
    if (m.find("MaxUserIoWaitTime") != m.end() && !m["MaxUserIoWaitTime"].empty()) {
      maxUserIoWaitTime = make_shared<double>(boost::any_cast<double>(m["MaxUserIoWaitTime"]));
    }
    if (m.find("MaxWaitTime") != m.end() && !m["MaxWaitTime"].empty()) {
      maxWaitTime = make_shared<double>(boost::any_cast<double>(m["MaxWaitTime"]));
    }
    if (m.find("MissPlanPercentage") != m.end() && !m["MissPlanPercentage"].empty()) {
      missPlanPercentage = make_shared<double>(boost::any_cast<double>(m["MissPlanPercentage"]));
    }
    if (m.find("MissPlans") != m.end() && !m["MissPlans"].empty()) {
      missPlans = make_shared<double>(boost::any_cast<double>(m["MissPlans"]));
    }
    if (m.find("RemotePlanPercentage") != m.end() && !m["RemotePlanPercentage"].empty()) {
      remotePlanPercentage = make_shared<double>(boost::any_cast<double>(m["RemotePlanPercentage"]));
    }
    if (m.find("RemotePlans") != m.end() && !m["RemotePlans"].empty()) {
      remotePlans = make_shared<double>(boost::any_cast<double>(m["RemotePlans"]));
    }
    if (m.find("RetCode4012Count") != m.end() && !m["RetCode4012Count"].empty()) {
      retCode4012Count = make_shared<long>(boost::any_cast<long>(m["RetCode4012Count"]));
    }
    if (m.find("RetCode4013Count") != m.end() && !m["RetCode4013Count"].empty()) {
      retCode4013Count = make_shared<long>(boost::any_cast<long>(m["RetCode4013Count"]));
    }
    if (m.find("RetCode5001Count") != m.end() && !m["RetCode5001Count"].empty()) {
      retCode5001Count = make_shared<long>(boost::any_cast<long>(m["RetCode5001Count"]));
    }
    if (m.find("RetCode5024Count") != m.end() && !m["RetCode5024Count"].empty()) {
      retCode5024Count = make_shared<long>(boost::any_cast<long>(m["RetCode5024Count"]));
    }
    if (m.find("RetCode5167Count") != m.end() && !m["RetCode5167Count"].empty()) {
      retCode5167Count = make_shared<long>(boost::any_cast<long>(m["RetCode5167Count"]));
    }
    if (m.find("RetCode5217Count") != m.end() && !m["RetCode5217Count"].empty()) {
      retCode5217Count = make_shared<long>(boost::any_cast<long>(m["RetCode5217Count"]));
    }
    if (m.find("RetCode6002Count") != m.end() && !m["RetCode6002Count"].empty()) {
      retCode6002Count = make_shared<long>(boost::any_cast<long>(m["RetCode6002Count"]));
    }
    if (m.find("RetryCount") != m.end() && !m["RetryCount"].empty()) {
      retryCount = make_shared<double>(boost::any_cast<double>(m["RetryCount"]));
    }
    if (m.find("RpcCount") != m.end() && !m["RpcCount"].empty()) {
      rpcCount = make_shared<double>(boost::any_cast<double>(m["RpcCount"]));
    }
    if (m.find("Server") != m.end() && !m["Server"].empty()) {
      server = make_shared<string>(boost::any_cast<string>(m["Server"]));
    }
    if (m.find("ServerIp") != m.end() && !m["ServerIp"].empty()) {
      serverIp = make_shared<string>(boost::any_cast<string>(m["ServerIp"]));
    }
    if (m.find("ServerPort") != m.end() && !m["ServerPort"].empty()) {
      serverPort = make_shared<long>(boost::any_cast<long>(m["ServerPort"]));
    }
    if (m.find("SqlId") != m.end() && !m["SqlId"].empty()) {
      sqlId = make_shared<string>(boost::any_cast<string>(m["SqlId"]));
    }
    if (m.find("SqlList") != m.end() && !m["SqlList"].empty()) {
      if (typeid(vector<boost::any>) == m["SqlList"].type()) {
        vector<DescribeOasTopSQLListResponseBodyDataSqlList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SqlList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeOasTopSQLListResponseBodyDataSqlList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        sqlList = make_shared<vector<DescribeOasTopSQLListResponseBodyDataSqlList>>(expect1);
      }
    }
    if (m.find("SqlTextShort") != m.end() && !m["SqlTextShort"].empty()) {
      sqlTextShort = make_shared<string>(boost::any_cast<string>(m["SqlTextShort"]));
    }
    if (m.find("SqlType") != m.end() && !m["SqlType"].empty()) {
      sqlType = make_shared<string>(boost::any_cast<string>(m["SqlType"]));
    }
    if (m.find("StrongConsistencyPercentage") != m.end() && !m["StrongConsistencyPercentage"].empty()) {
      strongConsistencyPercentage = make_shared<double>(boost::any_cast<double>(m["StrongConsistencyPercentage"]));
    }
    if (m.find("SumDbTime") != m.end() && !m["SumDbTime"].empty()) {
      sumDbTime = make_shared<double>(boost::any_cast<double>(m["SumDbTime"]));
    }
    if (m.find("SumElapsedTime") != m.end() && !m["SumElapsedTime"].empty()) {
      sumElapsedTime = make_shared<double>(boost::any_cast<double>(m["SumElapsedTime"]));
    }
    if (m.find("SumLogicalReads") != m.end() && !m["SumLogicalReads"].empty()) {
      sumLogicalReads = make_shared<double>(boost::any_cast<double>(m["SumLogicalReads"]));
    }
    if (m.find("SumWaitTime") != m.end() && !m["SumWaitTime"].empty()) {
      sumWaitTime = make_shared<double>(boost::any_cast<double>(m["SumWaitTime"]));
    }
    if (m.find("TableScanPercentage") != m.end() && !m["TableScanPercentage"].empty()) {
      tableScanPercentage = make_shared<double>(boost::any_cast<double>(m["TableScanPercentage"]));
    }
    if (m.find("TotalWaitTime") != m.end() && !m["TotalWaitTime"].empty()) {
      totalWaitTime = make_shared<double>(boost::any_cast<double>(m["TotalWaitTime"]));
    }
    if (m.find("UserName") != m.end() && !m["UserName"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["UserName"]));
    }
    if (m.find("WaitEvent") != m.end() && !m["WaitEvent"].empty()) {
      waitEvent = make_shared<string>(boost::any_cast<string>(m["WaitEvent"]));
    }
    if (m.find("WeakConsistencyPercentage") != m.end() && !m["WeakConsistencyPercentage"].empty()) {
      weakConsistencyPercentage = make_shared<double>(boost::any_cast<double>(m["WeakConsistencyPercentage"]));
    }
  }


  virtual ~DescribeOasTopSQLListResponseBodyData() = default;
};
class DescribeOasTopSQLListResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeOasTopSQLListResponseBodyData>> data{};
  shared_ptr<string> requestId{};

  DescribeOasTopSQLListResponseBody() {}

  explicit DescribeOasTopSQLListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<DescribeOasTopSQLListResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeOasTopSQLListResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<DescribeOasTopSQLListResponseBodyData>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeOasTopSQLListResponseBody() = default;
};
class DescribeOasTopSQLListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeOasTopSQLListResponseBody> body{};

  DescribeOasTopSQLListResponse() {}

  explicit DescribeOasTopSQLListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeOasTopSQLListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeOasTopSQLListResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeOasTopSQLListResponse() = default;
};
class DescribeOutlineBindingRequest : public Darabonba::Model {
public:
  shared_ptr<string> databaseName{};
  shared_ptr<string> instanceId{};
  shared_ptr<bool> isConcurrentLimit{};
  shared_ptr<string> SQLId{};
  shared_ptr<string> tableName{};
  shared_ptr<string> tenantId{};

  DescribeOutlineBindingRequest() {}

  explicit DescribeOutlineBindingRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (databaseName) {
      res["DatabaseName"] = boost::any(*databaseName);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (isConcurrentLimit) {
      res["IsConcurrentLimit"] = boost::any(*isConcurrentLimit);
    }
    if (SQLId) {
      res["SQLId"] = boost::any(*SQLId);
    }
    if (tableName) {
      res["TableName"] = boost::any(*tableName);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DatabaseName") != m.end() && !m["DatabaseName"].empty()) {
      databaseName = make_shared<string>(boost::any_cast<string>(m["DatabaseName"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("IsConcurrentLimit") != m.end() && !m["IsConcurrentLimit"].empty()) {
      isConcurrentLimit = make_shared<bool>(boost::any_cast<bool>(m["IsConcurrentLimit"]));
    }
    if (m.find("SQLId") != m.end() && !m["SQLId"].empty()) {
      SQLId = make_shared<string>(boost::any_cast<string>(m["SQLId"]));
    }
    if (m.find("TableName") != m.end() && !m["TableName"].empty()) {
      tableName = make_shared<string>(boost::any_cast<string>(m["TableName"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["TenantId"]));
    }
  }


  virtual ~DescribeOutlineBindingRequest() = default;
};
class DescribeOutlineBindingResponseBodyOutlineBinding : public Darabonba::Model {
public:
  shared_ptr<string> bindIndex{};
  shared_ptr<string> bindPlan{};
  shared_ptr<long> maxConcurrent{};
  shared_ptr<long> outlineId{};
  shared_ptr<string> tableName{};

  DescribeOutlineBindingResponseBodyOutlineBinding() {}

  explicit DescribeOutlineBindingResponseBodyOutlineBinding(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bindIndex) {
      res["BindIndex"] = boost::any(*bindIndex);
    }
    if (bindPlan) {
      res["BindPlan"] = boost::any(*bindPlan);
    }
    if (maxConcurrent) {
      res["MaxConcurrent"] = boost::any(*maxConcurrent);
    }
    if (outlineId) {
      res["OutlineId"] = boost::any(*outlineId);
    }
    if (tableName) {
      res["TableName"] = boost::any(*tableName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BindIndex") != m.end() && !m["BindIndex"].empty()) {
      bindIndex = make_shared<string>(boost::any_cast<string>(m["BindIndex"]));
    }
    if (m.find("BindPlan") != m.end() && !m["BindPlan"].empty()) {
      bindPlan = make_shared<string>(boost::any_cast<string>(m["BindPlan"]));
    }
    if (m.find("MaxConcurrent") != m.end() && !m["MaxConcurrent"].empty()) {
      maxConcurrent = make_shared<long>(boost::any_cast<long>(m["MaxConcurrent"]));
    }
    if (m.find("OutlineId") != m.end() && !m["OutlineId"].empty()) {
      outlineId = make_shared<long>(boost::any_cast<long>(m["OutlineId"]));
    }
    if (m.find("TableName") != m.end() && !m["TableName"].empty()) {
      tableName = make_shared<string>(boost::any_cast<string>(m["TableName"]));
    }
  }


  virtual ~DescribeOutlineBindingResponseBodyOutlineBinding() = default;
};
class DescribeOutlineBindingResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeOutlineBindingResponseBodyOutlineBinding> outlineBinding{};
  shared_ptr<string> requestId{};

  DescribeOutlineBindingResponseBody() {}

  explicit DescribeOutlineBindingResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (outlineBinding) {
      res["OutlineBinding"] = outlineBinding ? boost::any(outlineBinding->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OutlineBinding") != m.end() && !m["OutlineBinding"].empty()) {
      if (typeid(map<string, boost::any>) == m["OutlineBinding"].type()) {
        DescribeOutlineBindingResponseBodyOutlineBinding model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OutlineBinding"]));
        outlineBinding = make_shared<DescribeOutlineBindingResponseBodyOutlineBinding>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeOutlineBindingResponseBody() = default;
};
class DescribeOutlineBindingResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeOutlineBindingResponseBody> body{};

  DescribeOutlineBindingResponse() {}

  explicit DescribeOutlineBindingResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeOutlineBindingResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeOutlineBindingResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeOutlineBindingResponse() = default;
};
class DescribeParametersRequest : public Darabonba::Model {
public:
  shared_ptr<string> dimension{};
  shared_ptr<string> dimensionValue{};
  shared_ptr<string> instanceId{};

  DescribeParametersRequest() {}

  explicit DescribeParametersRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dimension) {
      res["Dimension"] = boost::any(*dimension);
    }
    if (dimensionValue) {
      res["DimensionValue"] = boost::any(*dimensionValue);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Dimension") != m.end() && !m["Dimension"].empty()) {
      dimension = make_shared<string>(boost::any_cast<string>(m["Dimension"]));
    }
    if (m.find("DimensionValue") != m.end() && !m["DimensionValue"].empty()) {
      dimensionValue = make_shared<string>(boost::any_cast<string>(m["DimensionValue"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~DescribeParametersRequest() = default;
};
class DescribeParametersResponseBodyParameters : public Darabonba::Model {
public:
  shared_ptr<vector<string>> acceptableValue{};
  shared_ptr<string> currentValue{};
  shared_ptr<string> defaultValue{};
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<bool> needReboot{};
  shared_ptr<bool> readonly{};
  shared_ptr<vector<string>> rejectedValue{};
  shared_ptr<string> unit{};
  shared_ptr<string> valueType{};

  DescribeParametersResponseBodyParameters() {}

  explicit DescribeParametersResponseBodyParameters(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptableValue) {
      res["AcceptableValue"] = boost::any(*acceptableValue);
    }
    if (currentValue) {
      res["CurrentValue"] = boost::any(*currentValue);
    }
    if (defaultValue) {
      res["DefaultValue"] = boost::any(*defaultValue);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (needReboot) {
      res["NeedReboot"] = boost::any(*needReboot);
    }
    if (readonly) {
      res["Readonly"] = boost::any(*readonly);
    }
    if (rejectedValue) {
      res["RejectedValue"] = boost::any(*rejectedValue);
    }
    if (unit) {
      res["Unit"] = boost::any(*unit);
    }
    if (valueType) {
      res["ValueType"] = boost::any(*valueType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptableValue") != m.end() && !m["AcceptableValue"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["AcceptableValue"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["AcceptableValue"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      acceptableValue = make_shared<vector<string>>(toVec1);
    }
    if (m.find("CurrentValue") != m.end() && !m["CurrentValue"].empty()) {
      currentValue = make_shared<string>(boost::any_cast<string>(m["CurrentValue"]));
    }
    if (m.find("DefaultValue") != m.end() && !m["DefaultValue"].empty()) {
      defaultValue = make_shared<string>(boost::any_cast<string>(m["DefaultValue"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("NeedReboot") != m.end() && !m["NeedReboot"].empty()) {
      needReboot = make_shared<bool>(boost::any_cast<bool>(m["NeedReboot"]));
    }
    if (m.find("Readonly") != m.end() && !m["Readonly"].empty()) {
      readonly = make_shared<bool>(boost::any_cast<bool>(m["Readonly"]));
    }
    if (m.find("RejectedValue") != m.end() && !m["RejectedValue"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["RejectedValue"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["RejectedValue"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      rejectedValue = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Unit") != m.end() && !m["Unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["Unit"]));
    }
    if (m.find("ValueType") != m.end() && !m["ValueType"].empty()) {
      valueType = make_shared<string>(boost::any_cast<string>(m["ValueType"]));
    }
  }


  virtual ~DescribeParametersResponseBodyParameters() = default;
};
class DescribeParametersResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeParametersResponseBodyParameters>> parameters{};
  shared_ptr<string> requestId{};

  DescribeParametersResponseBody() {}

  explicit DescribeParametersResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (parameters) {
      vector<boost::any> temp1;
      for(auto item1:*parameters){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Parameters"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Parameters") != m.end() && !m["Parameters"].empty()) {
      if (typeid(vector<boost::any>) == m["Parameters"].type()) {
        vector<DescribeParametersResponseBodyParameters> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Parameters"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeParametersResponseBodyParameters model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        parameters = make_shared<vector<DescribeParametersResponseBodyParameters>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeParametersResponseBody() = default;
};
class DescribeParametersResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeParametersResponseBody> body{};

  DescribeParametersResponse() {}

  explicit DescribeParametersResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeParametersResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeParametersResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeParametersResponse() = default;
};
class DescribeParametersHistoryRequest : public Darabonba::Model {
public:
  shared_ptr<string> dimension{};
  shared_ptr<string> dimensionValue{};
  shared_ptr<string> endTime{};
  shared_ptr<string> instanceId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> startTime{};

  DescribeParametersHistoryRequest() {}

  explicit DescribeParametersHistoryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dimension) {
      res["Dimension"] = boost::any(*dimension);
    }
    if (dimensionValue) {
      res["DimensionValue"] = boost::any(*dimensionValue);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Dimension") != m.end() && !m["Dimension"].empty()) {
      dimension = make_shared<string>(boost::any_cast<string>(m["Dimension"]));
    }
    if (m.find("DimensionValue") != m.end() && !m["DimensionValue"].empty()) {
      dimensionValue = make_shared<string>(boost::any_cast<string>(m["DimensionValue"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~DescribeParametersHistoryRequest() = default;
};
class DescribeParametersHistoryResponseBodyRespondParameters : public Darabonba::Model {
public:
  shared_ptr<string> createTime{};
  shared_ptr<string> dimensionValue{};
  shared_ptr<string> name{};
  shared_ptr<string> newValue{};
  shared_ptr<string> oldValue{};
  shared_ptr<string> status{};
  shared_ptr<string> updateTime{};

  DescribeParametersHistoryResponseBodyRespondParameters() {}

  explicit DescribeParametersHistoryResponseBodyRespondParameters(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (dimensionValue) {
      res["DimensionValue"] = boost::any(*dimensionValue);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (newValue) {
      res["NewValue"] = boost::any(*newValue);
    }
    if (oldValue) {
      res["OldValue"] = boost::any(*oldValue);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("DimensionValue") != m.end() && !m["DimensionValue"].empty()) {
      dimensionValue = make_shared<string>(boost::any_cast<string>(m["DimensionValue"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("NewValue") != m.end() && !m["NewValue"].empty()) {
      newValue = make_shared<string>(boost::any_cast<string>(m["NewValue"]));
    }
    if (m.find("OldValue") != m.end() && !m["OldValue"].empty()) {
      oldValue = make_shared<string>(boost::any_cast<string>(m["OldValue"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<string>(boost::any_cast<string>(m["UpdateTime"]));
    }
  }


  virtual ~DescribeParametersHistoryResponseBodyRespondParameters() = default;
};
class DescribeParametersHistoryResponseBodyRespond : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<vector<DescribeParametersHistoryResponseBodyRespondParameters>> parameters{};
  shared_ptr<long> totalCount{};

  DescribeParametersHistoryResponseBodyRespond() {}

  explicit DescribeParametersHistoryResponseBodyRespond(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (parameters) {
      vector<boost::any> temp1;
      for(auto item1:*parameters){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Parameters"] = boost::any(temp1);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("Parameters") != m.end() && !m["Parameters"].empty()) {
      if (typeid(vector<boost::any>) == m["Parameters"].type()) {
        vector<DescribeParametersHistoryResponseBodyRespondParameters> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Parameters"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeParametersHistoryResponseBodyRespondParameters model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        parameters = make_shared<vector<DescribeParametersHistoryResponseBodyRespondParameters>>(expect1);
      }
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeParametersHistoryResponseBodyRespond() = default;
};
class DescribeParametersHistoryResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeParametersHistoryResponseBodyRespond>> respond{};

  DescribeParametersHistoryResponseBody() {}

  explicit DescribeParametersHistoryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (respond) {
      vector<boost::any> temp1;
      for(auto item1:*respond){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Respond"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Respond") != m.end() && !m["Respond"].empty()) {
      if (typeid(vector<boost::any>) == m["Respond"].type()) {
        vector<DescribeParametersHistoryResponseBodyRespond> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Respond"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeParametersHistoryResponseBodyRespond model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        respond = make_shared<vector<DescribeParametersHistoryResponseBodyRespond>>(expect1);
      }
    }
  }


  virtual ~DescribeParametersHistoryResponseBody() = default;
};
class DescribeParametersHistoryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeParametersHistoryResponseBody> body{};

  DescribeParametersHistoryResponse() {}

  explicit DescribeParametersHistoryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeParametersHistoryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeParametersHistoryResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeParametersHistoryResponse() = default;
};
class DescribeProjectRequest : public Darabonba::Model {
public:
  shared_ptr<string> id{};

  DescribeProjectRequest() {}

  explicit DescribeProjectRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
  }


  virtual ~DescribeProjectRequest() = default;
};
class DescribeProjectResponseBodyDataAlarmStats : public Darabonba::Model {
public:
  shared_ptr<string> alarmContent{};
  shared_ptr<bool> alarming{};
  shared_ptr<bool> openMonitor{};
  shared_ptr<long> recentlyTriggerCount{};
  shared_ptr<map<string, long>> ruleToRecentlyTriggerCount{};
  shared_ptr<string> target{};

  DescribeProjectResponseBodyDataAlarmStats() {}

  explicit DescribeProjectResponseBodyDataAlarmStats(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alarmContent) {
      res["AlarmContent"] = boost::any(*alarmContent);
    }
    if (alarming) {
      res["Alarming"] = boost::any(*alarming);
    }
    if (openMonitor) {
      res["OpenMonitor"] = boost::any(*openMonitor);
    }
    if (recentlyTriggerCount) {
      res["RecentlyTriggerCount"] = boost::any(*recentlyTriggerCount);
    }
    if (ruleToRecentlyTriggerCount) {
      res["RuleToRecentlyTriggerCount"] = boost::any(*ruleToRecentlyTriggerCount);
    }
    if (target) {
      res["Target"] = boost::any(*target);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlarmContent") != m.end() && !m["AlarmContent"].empty()) {
      alarmContent = make_shared<string>(boost::any_cast<string>(m["AlarmContent"]));
    }
    if (m.find("Alarming") != m.end() && !m["Alarming"].empty()) {
      alarming = make_shared<bool>(boost::any_cast<bool>(m["Alarming"]));
    }
    if (m.find("OpenMonitor") != m.end() && !m["OpenMonitor"].empty()) {
      openMonitor = make_shared<bool>(boost::any_cast<bool>(m["OpenMonitor"]));
    }
    if (m.find("RecentlyTriggerCount") != m.end() && !m["RecentlyTriggerCount"].empty()) {
      recentlyTriggerCount = make_shared<long>(boost::any_cast<long>(m["RecentlyTriggerCount"]));
    }
    if (m.find("RuleToRecentlyTriggerCount") != m.end() && !m["RuleToRecentlyTriggerCount"].empty()) {
      map<string, long> map1 = boost::any_cast<map<string, long>>(m["RuleToRecentlyTriggerCount"]);
      map<string, long> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      ruleToRecentlyTriggerCount = make_shared<map<string, long>>(toMap1);
    }
    if (m.find("Target") != m.end() && !m["Target"].empty()) {
      target = make_shared<string>(boost::any_cast<string>(m["Target"]));
    }
  }


  virtual ~DescribeProjectResponseBodyDataAlarmStats() = default;
};
class DescribeProjectResponseBodyDataCommonTransferConfig : public Darabonba::Model {
public:
  shared_ptr<bool> activeActive{};
  shared_ptr<string> dataWorksBusinessName{};
  shared_ptr<string> datahubTopicType{};
  shared_ptr<long> mqPartition{};
  shared_ptr<string> mqPartitionMode{};
  shared_ptr<string> mqSerializerType{};
  shared_ptr<bool> rocketMqEnableMsgTrace{};
  shared_ptr<string> rocketMqMsgTags{};
  shared_ptr<string> rocketMqProducerGroup{};
  shared_ptr<long> rocketMqSendMsgTimeout{};
  shared_ptr<string> tableCategory{};

  DescribeProjectResponseBodyDataCommonTransferConfig() {}

  explicit DescribeProjectResponseBodyDataCommonTransferConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (activeActive) {
      res["ActiveActive"] = boost::any(*activeActive);
    }
    if (dataWorksBusinessName) {
      res["DataWorksBusinessName"] = boost::any(*dataWorksBusinessName);
    }
    if (datahubTopicType) {
      res["DatahubTopicType"] = boost::any(*datahubTopicType);
    }
    if (mqPartition) {
      res["MqPartition"] = boost::any(*mqPartition);
    }
    if (mqPartitionMode) {
      res["MqPartitionMode"] = boost::any(*mqPartitionMode);
    }
    if (mqSerializerType) {
      res["MqSerializerType"] = boost::any(*mqSerializerType);
    }
    if (rocketMqEnableMsgTrace) {
      res["RocketMqEnableMsgTrace"] = boost::any(*rocketMqEnableMsgTrace);
    }
    if (rocketMqMsgTags) {
      res["RocketMqMsgTags"] = boost::any(*rocketMqMsgTags);
    }
    if (rocketMqProducerGroup) {
      res["RocketMqProducerGroup"] = boost::any(*rocketMqProducerGroup);
    }
    if (rocketMqSendMsgTimeout) {
      res["RocketMqSendMsgTimeout"] = boost::any(*rocketMqSendMsgTimeout);
    }
    if (tableCategory) {
      res["TableCategory"] = boost::any(*tableCategory);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ActiveActive") != m.end() && !m["ActiveActive"].empty()) {
      activeActive = make_shared<bool>(boost::any_cast<bool>(m["ActiveActive"]));
    }
    if (m.find("DataWorksBusinessName") != m.end() && !m["DataWorksBusinessName"].empty()) {
      dataWorksBusinessName = make_shared<string>(boost::any_cast<string>(m["DataWorksBusinessName"]));
    }
    if (m.find("DatahubTopicType") != m.end() && !m["DatahubTopicType"].empty()) {
      datahubTopicType = make_shared<string>(boost::any_cast<string>(m["DatahubTopicType"]));
    }
    if (m.find("MqPartition") != m.end() && !m["MqPartition"].empty()) {
      mqPartition = make_shared<long>(boost::any_cast<long>(m["MqPartition"]));
    }
    if (m.find("MqPartitionMode") != m.end() && !m["MqPartitionMode"].empty()) {
      mqPartitionMode = make_shared<string>(boost::any_cast<string>(m["MqPartitionMode"]));
    }
    if (m.find("MqSerializerType") != m.end() && !m["MqSerializerType"].empty()) {
      mqSerializerType = make_shared<string>(boost::any_cast<string>(m["MqSerializerType"]));
    }
    if (m.find("RocketMqEnableMsgTrace") != m.end() && !m["RocketMqEnableMsgTrace"].empty()) {
      rocketMqEnableMsgTrace = make_shared<bool>(boost::any_cast<bool>(m["RocketMqEnableMsgTrace"]));
    }
    if (m.find("RocketMqMsgTags") != m.end() && !m["RocketMqMsgTags"].empty()) {
      rocketMqMsgTags = make_shared<string>(boost::any_cast<string>(m["RocketMqMsgTags"]));
    }
    if (m.find("RocketMqProducerGroup") != m.end() && !m["RocketMqProducerGroup"].empty()) {
      rocketMqProducerGroup = make_shared<string>(boost::any_cast<string>(m["RocketMqProducerGroup"]));
    }
    if (m.find("RocketMqSendMsgTimeout") != m.end() && !m["RocketMqSendMsgTimeout"].empty()) {
      rocketMqSendMsgTimeout = make_shared<long>(boost::any_cast<long>(m["RocketMqSendMsgTimeout"]));
    }
    if (m.find("TableCategory") != m.end() && !m["TableCategory"].empty()) {
      tableCategory = make_shared<string>(boost::any_cast<string>(m["TableCategory"]));
    }
  }


  virtual ~DescribeProjectResponseBodyDataCommonTransferConfig() = default;
};
class DescribeProjectResponseBodyDataExtraInfo : public Darabonba::Model {
public:
  shared_ptr<bool> accessObSource{};
  shared_ptr<bool> ignoreUnsupportDdl{};
  shared_ptr<long> incrSyncTimestamp{};
  shared_ptr<long> logServiceStartCheckpoint{};
  shared_ptr<long> maxConnectorCount{};
  shared_ptr<bool> monitoringIncr{};
  shared_ptr<bool> overwriteConfig{};
  shared_ptr<vector<string>> reverseSubtopics{};
  shared_ptr<long> runningProgress{};
  shared_ptr<string> runningStep{};
  shared_ptr<long> sourceStoreKeptHour{};
  shared_ptr<bool> storeIncr{};
  shared_ptr<map<string, vector<DataExtraInfoSubCondsValue>>> subConds{};
  shared_ptr<map<string, vector<DataExtraInfoSubDbsValue>>> subDbs{};
  shared_ptr<map<string, string>> subIds{};
  shared_ptr<vector<string>> subtopics{};
  shared_ptr<long> syncDelay{};
  shared_ptr<long> syncDelaySampleTimestamp{};

  DescribeProjectResponseBodyDataExtraInfo() {}

  explicit DescribeProjectResponseBodyDataExtraInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessObSource) {
      res["AccessObSource"] = boost::any(*accessObSource);
    }
    if (ignoreUnsupportDdl) {
      res["IgnoreUnsupportDdl"] = boost::any(*ignoreUnsupportDdl);
    }
    if (incrSyncTimestamp) {
      res["IncrSyncTimestamp"] = boost::any(*incrSyncTimestamp);
    }
    if (logServiceStartCheckpoint) {
      res["LogServiceStartCheckpoint"] = boost::any(*logServiceStartCheckpoint);
    }
    if (maxConnectorCount) {
      res["MaxConnectorCount"] = boost::any(*maxConnectorCount);
    }
    if (monitoringIncr) {
      res["MonitoringIncr"] = boost::any(*monitoringIncr);
    }
    if (overwriteConfig) {
      res["OverwriteConfig"] = boost::any(*overwriteConfig);
    }
    if (reverseSubtopics) {
      res["ReverseSubtopics"] = boost::any(*reverseSubtopics);
    }
    if (runningProgress) {
      res["RunningProgress"] = boost::any(*runningProgress);
    }
    if (runningStep) {
      res["RunningStep"] = boost::any(*runningStep);
    }
    if (sourceStoreKeptHour) {
      res["SourceStoreKeptHour"] = boost::any(*sourceStoreKeptHour);
    }
    if (storeIncr) {
      res["StoreIncr"] = boost::any(*storeIncr);
    }
    if (subConds) {
      map<string, boost::any> temp1;
      for(auto item1:*subConds){
        vector<boost::any> temp2;
        for(auto item2:item1.second){
          temp2.push_back(boost::any(item2.toMap()));
        }
        temp1[item1.first] = boost::any(temp2);
      }
      res["SubConds"] = boost::any(temp1);
    }
    if (subDbs) {
      map<string, boost::any> temp1;
      for(auto item1:*subDbs){
        vector<boost::any> temp2;
        for(auto item2:item1.second){
          temp2.push_back(boost::any(item2.toMap()));
        }
        temp1[item1.first] = boost::any(temp2);
      }
      res["SubDbs"] = boost::any(temp1);
    }
    if (subIds) {
      res["SubIds"] = boost::any(*subIds);
    }
    if (subtopics) {
      res["Subtopics"] = boost::any(*subtopics);
    }
    if (syncDelay) {
      res["SyncDelay"] = boost::any(*syncDelay);
    }
    if (syncDelaySampleTimestamp) {
      res["SyncDelaySampleTimestamp"] = boost::any(*syncDelaySampleTimestamp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccessObSource") != m.end() && !m["AccessObSource"].empty()) {
      accessObSource = make_shared<bool>(boost::any_cast<bool>(m["AccessObSource"]));
    }
    if (m.find("IgnoreUnsupportDdl") != m.end() && !m["IgnoreUnsupportDdl"].empty()) {
      ignoreUnsupportDdl = make_shared<bool>(boost::any_cast<bool>(m["IgnoreUnsupportDdl"]));
    }
    if (m.find("IncrSyncTimestamp") != m.end() && !m["IncrSyncTimestamp"].empty()) {
      incrSyncTimestamp = make_shared<long>(boost::any_cast<long>(m["IncrSyncTimestamp"]));
    }
    if (m.find("LogServiceStartCheckpoint") != m.end() && !m["LogServiceStartCheckpoint"].empty()) {
      logServiceStartCheckpoint = make_shared<long>(boost::any_cast<long>(m["LogServiceStartCheckpoint"]));
    }
    if (m.find("MaxConnectorCount") != m.end() && !m["MaxConnectorCount"].empty()) {
      maxConnectorCount = make_shared<long>(boost::any_cast<long>(m["MaxConnectorCount"]));
    }
    if (m.find("MonitoringIncr") != m.end() && !m["MonitoringIncr"].empty()) {
      monitoringIncr = make_shared<bool>(boost::any_cast<bool>(m["MonitoringIncr"]));
    }
    if (m.find("OverwriteConfig") != m.end() && !m["OverwriteConfig"].empty()) {
      overwriteConfig = make_shared<bool>(boost::any_cast<bool>(m["OverwriteConfig"]));
    }
    if (m.find("ReverseSubtopics") != m.end() && !m["ReverseSubtopics"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ReverseSubtopics"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ReverseSubtopics"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      reverseSubtopics = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RunningProgress") != m.end() && !m["RunningProgress"].empty()) {
      runningProgress = make_shared<long>(boost::any_cast<long>(m["RunningProgress"]));
    }
    if (m.find("RunningStep") != m.end() && !m["RunningStep"].empty()) {
      runningStep = make_shared<string>(boost::any_cast<string>(m["RunningStep"]));
    }
    if (m.find("SourceStoreKeptHour") != m.end() && !m["SourceStoreKeptHour"].empty()) {
      sourceStoreKeptHour = make_shared<long>(boost::any_cast<long>(m["SourceStoreKeptHour"]));
    }
    if (m.find("StoreIncr") != m.end() && !m["StoreIncr"].empty()) {
      storeIncr = make_shared<bool>(boost::any_cast<bool>(m["StoreIncr"]));
    }
    if (m.find("SubConds") != m.end() && !m["SubConds"].empty()) {
      if (typeid(map<string, boost::any>) == m["SubConds"].type()) {
        map<string, vector<DataExtraInfoSubCondsValue>> expect1;
        for(auto item1:boost::any_cast<map<string, boost::any>>(m["SubConds"])){
          if (typeid(vector<boost::any>) == item1.second.type()) {
            vector<DataExtraInfoSubCondsValue> expect2;
            for(auto item2:boost::any_cast<vector<boost::any>>(item1.second)){
              if (typeid(map<string, boost::any>) == item2.type()) {
                DataExtraInfoSubCondsValue model3;
                model3.fromMap(boost::any_cast<map<string, boost::any>>(item2));
                expect2.push_back(model3);
              }
            }
            expect1[item1.first] = expect2;
          }
        }
        subConds = make_shared<map<string, vector<DataExtraInfoSubCondsValue>>>(expect1);
      }
    }
    if (m.find("SubDbs") != m.end() && !m["SubDbs"].empty()) {
      if (typeid(map<string, boost::any>) == m["SubDbs"].type()) {
        map<string, vector<DataExtraInfoSubDbsValue>> expect1;
        for(auto item1:boost::any_cast<map<string, boost::any>>(m["SubDbs"])){
          if (typeid(vector<boost::any>) == item1.second.type()) {
            vector<DataExtraInfoSubDbsValue> expect2;
            for(auto item2:boost::any_cast<vector<boost::any>>(item1.second)){
              if (typeid(map<string, boost::any>) == item2.type()) {
                DataExtraInfoSubDbsValue model3;
                model3.fromMap(boost::any_cast<map<string, boost::any>>(item2));
                expect2.push_back(model3);
              }
            }
            expect1[item1.first] = expect2;
          }
        }
        subDbs = make_shared<map<string, vector<DataExtraInfoSubDbsValue>>>(expect1);
      }
    }
    if (m.find("SubIds") != m.end() && !m["SubIds"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["SubIds"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      subIds = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("Subtopics") != m.end() && !m["Subtopics"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Subtopics"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Subtopics"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      subtopics = make_shared<vector<string>>(toVec1);
    }
    if (m.find("SyncDelay") != m.end() && !m["SyncDelay"].empty()) {
      syncDelay = make_shared<long>(boost::any_cast<long>(m["SyncDelay"]));
    }
    if (m.find("SyncDelaySampleTimestamp") != m.end() && !m["SyncDelaySampleTimestamp"].empty()) {
      syncDelaySampleTimestamp = make_shared<long>(boost::any_cast<long>(m["SyncDelaySampleTimestamp"]));
    }
  }


  virtual ~DescribeProjectResponseBodyDataExtraInfo() = default;
};
class DescribeProjectResponseBodyDataFullTransferConfig : public Darabonba::Model {
public:
  shared_ptr<bool> allowDestTableNotEmpty{};
  shared_ptr<string> fullTransferSpeedMode{};
  shared_ptr<string> fullVerifySpeedMode{};
  shared_ptr<bool> nonePkUkTruncateDstTable{};
  shared_ptr<long> readWorkerNum{};
  shared_ptr<long> throttleIOPS{};
  shared_ptr<long> throttleRps{};
  shared_ptr<long> writeWorkerNum{};

  DescribeProjectResponseBodyDataFullTransferConfig() {}

  explicit DescribeProjectResponseBodyDataFullTransferConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (allowDestTableNotEmpty) {
      res["AllowDestTableNotEmpty"] = boost::any(*allowDestTableNotEmpty);
    }
    if (fullTransferSpeedMode) {
      res["FullTransferSpeedMode"] = boost::any(*fullTransferSpeedMode);
    }
    if (fullVerifySpeedMode) {
      res["FullVerifySpeedMode"] = boost::any(*fullVerifySpeedMode);
    }
    if (nonePkUkTruncateDstTable) {
      res["NonePkUkTruncateDstTable"] = boost::any(*nonePkUkTruncateDstTable);
    }
    if (readWorkerNum) {
      res["ReadWorkerNum"] = boost::any(*readWorkerNum);
    }
    if (throttleIOPS) {
      res["ThrottleIOPS"] = boost::any(*throttleIOPS);
    }
    if (throttleRps) {
      res["ThrottleRps"] = boost::any(*throttleRps);
    }
    if (writeWorkerNum) {
      res["WriteWorkerNum"] = boost::any(*writeWorkerNum);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AllowDestTableNotEmpty") != m.end() && !m["AllowDestTableNotEmpty"].empty()) {
      allowDestTableNotEmpty = make_shared<bool>(boost::any_cast<bool>(m["AllowDestTableNotEmpty"]));
    }
    if (m.find("FullTransferSpeedMode") != m.end() && !m["FullTransferSpeedMode"].empty()) {
      fullTransferSpeedMode = make_shared<string>(boost::any_cast<string>(m["FullTransferSpeedMode"]));
    }
    if (m.find("FullVerifySpeedMode") != m.end() && !m["FullVerifySpeedMode"].empty()) {
      fullVerifySpeedMode = make_shared<string>(boost::any_cast<string>(m["FullVerifySpeedMode"]));
    }
    if (m.find("NonePkUkTruncateDstTable") != m.end() && !m["NonePkUkTruncateDstTable"].empty()) {
      nonePkUkTruncateDstTable = make_shared<bool>(boost::any_cast<bool>(m["NonePkUkTruncateDstTable"]));
    }
    if (m.find("ReadWorkerNum") != m.end() && !m["ReadWorkerNum"].empty()) {
      readWorkerNum = make_shared<long>(boost::any_cast<long>(m["ReadWorkerNum"]));
    }
    if (m.find("ThrottleIOPS") != m.end() && !m["ThrottleIOPS"].empty()) {
      throttleIOPS = make_shared<long>(boost::any_cast<long>(m["ThrottleIOPS"]));
    }
    if (m.find("ThrottleRps") != m.end() && !m["ThrottleRps"].empty()) {
      throttleRps = make_shared<long>(boost::any_cast<long>(m["ThrottleRps"]));
    }
    if (m.find("WriteWorkerNum") != m.end() && !m["WriteWorkerNum"].empty()) {
      writeWorkerNum = make_shared<long>(boost::any_cast<long>(m["WriteWorkerNum"]));
    }
  }


  virtual ~DescribeProjectResponseBodyDataFullTransferConfig() = default;
};
class DescribeProjectResponseBodyDataIncrTransferConfig : public Darabonba::Model {
public:
  shared_ptr<bool> enableIncrSyncStatistics{};
  shared_ptr<bool> enableSequencingWithinTxn{};
  shared_ptr<long> incrSyncConcurrency{};
  shared_ptr<vector<string>> recordTypeWhiteList{};
  shared_ptr<long> startTimestamp{};
  shared_ptr<long> storeLogKeptHour{};
  shared_ptr<vector<string>> supportDDLTypes{};
  shared_ptr<long> throttleIOPS{};
  shared_ptr<long> throttleRps{};

  DescribeProjectResponseBodyDataIncrTransferConfig() {}

  explicit DescribeProjectResponseBodyDataIncrTransferConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (enableIncrSyncStatistics) {
      res["EnableIncrSyncStatistics"] = boost::any(*enableIncrSyncStatistics);
    }
    if (enableSequencingWithinTxn) {
      res["EnableSequencingWithinTxn"] = boost::any(*enableSequencingWithinTxn);
    }
    if (incrSyncConcurrency) {
      res["IncrSyncConcurrency"] = boost::any(*incrSyncConcurrency);
    }
    if (recordTypeWhiteList) {
      res["RecordTypeWhiteList"] = boost::any(*recordTypeWhiteList);
    }
    if (startTimestamp) {
      res["StartTimestamp"] = boost::any(*startTimestamp);
    }
    if (storeLogKeptHour) {
      res["StoreLogKeptHour"] = boost::any(*storeLogKeptHour);
    }
    if (supportDDLTypes) {
      res["SupportDDLTypes"] = boost::any(*supportDDLTypes);
    }
    if (throttleIOPS) {
      res["ThrottleIOPS"] = boost::any(*throttleIOPS);
    }
    if (throttleRps) {
      res["ThrottleRps"] = boost::any(*throttleRps);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EnableIncrSyncStatistics") != m.end() && !m["EnableIncrSyncStatistics"].empty()) {
      enableIncrSyncStatistics = make_shared<bool>(boost::any_cast<bool>(m["EnableIncrSyncStatistics"]));
    }
    if (m.find("EnableSequencingWithinTxn") != m.end() && !m["EnableSequencingWithinTxn"].empty()) {
      enableSequencingWithinTxn = make_shared<bool>(boost::any_cast<bool>(m["EnableSequencingWithinTxn"]));
    }
    if (m.find("IncrSyncConcurrency") != m.end() && !m["IncrSyncConcurrency"].empty()) {
      incrSyncConcurrency = make_shared<long>(boost::any_cast<long>(m["IncrSyncConcurrency"]));
    }
    if (m.find("RecordTypeWhiteList") != m.end() && !m["RecordTypeWhiteList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["RecordTypeWhiteList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["RecordTypeWhiteList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      recordTypeWhiteList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("StartTimestamp") != m.end() && !m["StartTimestamp"].empty()) {
      startTimestamp = make_shared<long>(boost::any_cast<long>(m["StartTimestamp"]));
    }
    if (m.find("StoreLogKeptHour") != m.end() && !m["StoreLogKeptHour"].empty()) {
      storeLogKeptHour = make_shared<long>(boost::any_cast<long>(m["StoreLogKeptHour"]));
    }
    if (m.find("SupportDDLTypes") != m.end() && !m["SupportDDLTypes"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SupportDDLTypes"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SupportDDLTypes"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      supportDDLTypes = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ThrottleIOPS") != m.end() && !m["ThrottleIOPS"].empty()) {
      throttleIOPS = make_shared<long>(boost::any_cast<long>(m["ThrottleIOPS"]));
    }
    if (m.find("ThrottleRps") != m.end() && !m["ThrottleRps"].empty()) {
      throttleRps = make_shared<long>(boost::any_cast<long>(m["ThrottleRps"]));
    }
  }


  virtual ~DescribeProjectResponseBodyDataIncrTransferConfig() = default;
};
class DescribeProjectResponseBodyDataLabels : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<string> name{};

  DescribeProjectResponseBodyDataLabels() {}

  explicit DescribeProjectResponseBodyDataLabels(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~DescribeProjectResponseBodyDataLabels() = default;
};
class DescribeProjectResponseBodyDataReverseIncrTransferConfig : public Darabonba::Model {
public:
  shared_ptr<bool> enableIncrSyncStatistics{};
  shared_ptr<bool> enableSequencingWithinTxn{};
  shared_ptr<long> incrSyncConcurrency{};
  shared_ptr<vector<string>> recordTypeWhiteList{};
  shared_ptr<long> startTimestamp{};
  shared_ptr<long> storeLogKeptHour{};
  shared_ptr<vector<string>> supportDDLTypes{};
  shared_ptr<long> throttleIOPS{};
  shared_ptr<long> throttleRps{};

  DescribeProjectResponseBodyDataReverseIncrTransferConfig() {}

  explicit DescribeProjectResponseBodyDataReverseIncrTransferConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (enableIncrSyncStatistics) {
      res["EnableIncrSyncStatistics"] = boost::any(*enableIncrSyncStatistics);
    }
    if (enableSequencingWithinTxn) {
      res["EnableSequencingWithinTxn"] = boost::any(*enableSequencingWithinTxn);
    }
    if (incrSyncConcurrency) {
      res["IncrSyncConcurrency"] = boost::any(*incrSyncConcurrency);
    }
    if (recordTypeWhiteList) {
      res["RecordTypeWhiteList"] = boost::any(*recordTypeWhiteList);
    }
    if (startTimestamp) {
      res["StartTimestamp"] = boost::any(*startTimestamp);
    }
    if (storeLogKeptHour) {
      res["StoreLogKeptHour"] = boost::any(*storeLogKeptHour);
    }
    if (supportDDLTypes) {
      res["SupportDDLTypes"] = boost::any(*supportDDLTypes);
    }
    if (throttleIOPS) {
      res["ThrottleIOPS"] = boost::any(*throttleIOPS);
    }
    if (throttleRps) {
      res["ThrottleRps"] = boost::any(*throttleRps);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EnableIncrSyncStatistics") != m.end() && !m["EnableIncrSyncStatistics"].empty()) {
      enableIncrSyncStatistics = make_shared<bool>(boost::any_cast<bool>(m["EnableIncrSyncStatistics"]));
    }
    if (m.find("EnableSequencingWithinTxn") != m.end() && !m["EnableSequencingWithinTxn"].empty()) {
      enableSequencingWithinTxn = make_shared<bool>(boost::any_cast<bool>(m["EnableSequencingWithinTxn"]));
    }
    if (m.find("IncrSyncConcurrency") != m.end() && !m["IncrSyncConcurrency"].empty()) {
      incrSyncConcurrency = make_shared<long>(boost::any_cast<long>(m["IncrSyncConcurrency"]));
    }
    if (m.find("RecordTypeWhiteList") != m.end() && !m["RecordTypeWhiteList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["RecordTypeWhiteList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["RecordTypeWhiteList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      recordTypeWhiteList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("StartTimestamp") != m.end() && !m["StartTimestamp"].empty()) {
      startTimestamp = make_shared<long>(boost::any_cast<long>(m["StartTimestamp"]));
    }
    if (m.find("StoreLogKeptHour") != m.end() && !m["StoreLogKeptHour"].empty()) {
      storeLogKeptHour = make_shared<long>(boost::any_cast<long>(m["StoreLogKeptHour"]));
    }
    if (m.find("SupportDDLTypes") != m.end() && !m["SupportDDLTypes"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SupportDDLTypes"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SupportDDLTypes"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      supportDDLTypes = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ThrottleIOPS") != m.end() && !m["ThrottleIOPS"].empty()) {
      throttleIOPS = make_shared<long>(boost::any_cast<long>(m["ThrottleIOPS"]));
    }
    if (m.find("ThrottleRps") != m.end() && !m["ThrottleRps"].empty()) {
      throttleRps = make_shared<long>(boost::any_cast<long>(m["ThrottleRps"]));
    }
  }


  virtual ~DescribeProjectResponseBodyDataReverseIncrTransferConfig() = default;
};
class DescribeProjectResponseBodyDataSinkConnectInfo : public Darabonba::Model {
public:
  shared_ptr<string> charset{};
  shared_ptr<boost::any> connExtraAttributes{};
  shared_ptr<string> connectionInfo{};
  shared_ptr<string> dbEngine{};
  shared_ptr<string> endpointId{};
  shared_ptr<string> endpointName{};
  shared_ptr<string> endpointSide{};
  shared_ptr<string> host{};
  shared_ptr<string> id{};
  shared_ptr<string> nlsLengthSemantics{};
  shared_ptr<string> ocpName{};
  shared_ptr<string> operatingSystem{};
  shared_ptr<string> owner{};
  shared_ptr<long> port{};
  shared_ptr<string> region{};
  shared_ptr<string> resourceOwner{};
  shared_ptr<string> timezone{};
  shared_ptr<string> username{};
  shared_ptr<string> version{};

  DescribeProjectResponseBodyDataSinkConnectInfo() {}

  explicit DescribeProjectResponseBodyDataSinkConnectInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (charset) {
      res["Charset"] = boost::any(*charset);
    }
    if (connExtraAttributes) {
      res["ConnExtraAttributes"] = boost::any(*connExtraAttributes);
    }
    if (connectionInfo) {
      res["ConnectionInfo"] = boost::any(*connectionInfo);
    }
    if (dbEngine) {
      res["DbEngine"] = boost::any(*dbEngine);
    }
    if (endpointId) {
      res["EndpointId"] = boost::any(*endpointId);
    }
    if (endpointName) {
      res["EndpointName"] = boost::any(*endpointName);
    }
    if (endpointSide) {
      res["EndpointSide"] = boost::any(*endpointSide);
    }
    if (host) {
      res["Host"] = boost::any(*host);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (nlsLengthSemantics) {
      res["NlsLengthSemantics"] = boost::any(*nlsLengthSemantics);
    }
    if (ocpName) {
      res["OcpName"] = boost::any(*ocpName);
    }
    if (operatingSystem) {
      res["OperatingSystem"] = boost::any(*operatingSystem);
    }
    if (owner) {
      res["Owner"] = boost::any(*owner);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (resourceOwner) {
      res["ResourceOwner"] = boost::any(*resourceOwner);
    }
    if (timezone) {
      res["Timezone"] = boost::any(*timezone);
    }
    if (username) {
      res["Username"] = boost::any(*username);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Charset") != m.end() && !m["Charset"].empty()) {
      charset = make_shared<string>(boost::any_cast<string>(m["Charset"]));
    }
    if (m.find("ConnExtraAttributes") != m.end() && !m["ConnExtraAttributes"].empty()) {
      connExtraAttributes = make_shared<boost::any>(boost::any_cast<boost::any>(m["ConnExtraAttributes"]));
    }
    if (m.find("ConnectionInfo") != m.end() && !m["ConnectionInfo"].empty()) {
      connectionInfo = make_shared<string>(boost::any_cast<string>(m["ConnectionInfo"]));
    }
    if (m.find("DbEngine") != m.end() && !m["DbEngine"].empty()) {
      dbEngine = make_shared<string>(boost::any_cast<string>(m["DbEngine"]));
    }
    if (m.find("EndpointId") != m.end() && !m["EndpointId"].empty()) {
      endpointId = make_shared<string>(boost::any_cast<string>(m["EndpointId"]));
    }
    if (m.find("EndpointName") != m.end() && !m["EndpointName"].empty()) {
      endpointName = make_shared<string>(boost::any_cast<string>(m["EndpointName"]));
    }
    if (m.find("EndpointSide") != m.end() && !m["EndpointSide"].empty()) {
      endpointSide = make_shared<string>(boost::any_cast<string>(m["EndpointSide"]));
    }
    if (m.find("Host") != m.end() && !m["Host"].empty()) {
      host = make_shared<string>(boost::any_cast<string>(m["Host"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("NlsLengthSemantics") != m.end() && !m["NlsLengthSemantics"].empty()) {
      nlsLengthSemantics = make_shared<string>(boost::any_cast<string>(m["NlsLengthSemantics"]));
    }
    if (m.find("OcpName") != m.end() && !m["OcpName"].empty()) {
      ocpName = make_shared<string>(boost::any_cast<string>(m["OcpName"]));
    }
    if (m.find("OperatingSystem") != m.end() && !m["OperatingSystem"].empty()) {
      operatingSystem = make_shared<string>(boost::any_cast<string>(m["OperatingSystem"]));
    }
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      owner = make_shared<string>(boost::any_cast<string>(m["Owner"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<long>(boost::any_cast<long>(m["Port"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("ResourceOwner") != m.end() && !m["ResourceOwner"].empty()) {
      resourceOwner = make_shared<string>(boost::any_cast<string>(m["ResourceOwner"]));
    }
    if (m.find("Timezone") != m.end() && !m["Timezone"].empty()) {
      timezone = make_shared<string>(boost::any_cast<string>(m["Timezone"]));
    }
    if (m.find("Username") != m.end() && !m["Username"].empty()) {
      username = make_shared<string>(boost::any_cast<string>(m["Username"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["Version"]));
    }
  }


  virtual ~DescribeProjectResponseBodyDataSinkConnectInfo() = default;
};
class DescribeProjectResponseBodyDataSourceConnectInfo : public Darabonba::Model {
public:
  shared_ptr<string> charset{};
  shared_ptr<boost::any> connExtraAttributes{};
  shared_ptr<string> connectionInfo{};
  shared_ptr<string> dbEngine{};
  shared_ptr<string> endpointId{};
  shared_ptr<string> endpointName{};
  shared_ptr<string> endpointSide{};
  shared_ptr<string> host{};
  shared_ptr<string> id{};
  shared_ptr<string> nlsLengthSemantics{};
  shared_ptr<string> ocpName{};
  shared_ptr<string> operatingSystem{};
  shared_ptr<string> owner{};
  shared_ptr<long> port{};
  shared_ptr<string> region{};
  shared_ptr<string> resourceOwner{};
  shared_ptr<string> timezone{};
  shared_ptr<string> username{};
  shared_ptr<string> version{};

  DescribeProjectResponseBodyDataSourceConnectInfo() {}

  explicit DescribeProjectResponseBodyDataSourceConnectInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (charset) {
      res["Charset"] = boost::any(*charset);
    }
    if (connExtraAttributes) {
      res["ConnExtraAttributes"] = boost::any(*connExtraAttributes);
    }
    if (connectionInfo) {
      res["ConnectionInfo"] = boost::any(*connectionInfo);
    }
    if (dbEngine) {
      res["DbEngine"] = boost::any(*dbEngine);
    }
    if (endpointId) {
      res["EndpointId"] = boost::any(*endpointId);
    }
    if (endpointName) {
      res["EndpointName"] = boost::any(*endpointName);
    }
    if (endpointSide) {
      res["EndpointSide"] = boost::any(*endpointSide);
    }
    if (host) {
      res["Host"] = boost::any(*host);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (nlsLengthSemantics) {
      res["NlsLengthSemantics"] = boost::any(*nlsLengthSemantics);
    }
    if (ocpName) {
      res["OcpName"] = boost::any(*ocpName);
    }
    if (operatingSystem) {
      res["OperatingSystem"] = boost::any(*operatingSystem);
    }
    if (owner) {
      res["Owner"] = boost::any(*owner);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (resourceOwner) {
      res["ResourceOwner"] = boost::any(*resourceOwner);
    }
    if (timezone) {
      res["Timezone"] = boost::any(*timezone);
    }
    if (username) {
      res["Username"] = boost::any(*username);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Charset") != m.end() && !m["Charset"].empty()) {
      charset = make_shared<string>(boost::any_cast<string>(m["Charset"]));
    }
    if (m.find("ConnExtraAttributes") != m.end() && !m["ConnExtraAttributes"].empty()) {
      connExtraAttributes = make_shared<boost::any>(boost::any_cast<boost::any>(m["ConnExtraAttributes"]));
    }
    if (m.find("ConnectionInfo") != m.end() && !m["ConnectionInfo"].empty()) {
      connectionInfo = make_shared<string>(boost::any_cast<string>(m["ConnectionInfo"]));
    }
    if (m.find("DbEngine") != m.end() && !m["DbEngine"].empty()) {
      dbEngine = make_shared<string>(boost::any_cast<string>(m["DbEngine"]));
    }
    if (m.find("EndpointId") != m.end() && !m["EndpointId"].empty()) {
      endpointId = make_shared<string>(boost::any_cast<string>(m["EndpointId"]));
    }
    if (m.find("EndpointName") != m.end() && !m["EndpointName"].empty()) {
      endpointName = make_shared<string>(boost::any_cast<string>(m["EndpointName"]));
    }
    if (m.find("EndpointSide") != m.end() && !m["EndpointSide"].empty()) {
      endpointSide = make_shared<string>(boost::any_cast<string>(m["EndpointSide"]));
    }
    if (m.find("Host") != m.end() && !m["Host"].empty()) {
      host = make_shared<string>(boost::any_cast<string>(m["Host"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("NlsLengthSemantics") != m.end() && !m["NlsLengthSemantics"].empty()) {
      nlsLengthSemantics = make_shared<string>(boost::any_cast<string>(m["NlsLengthSemantics"]));
    }
    if (m.find("OcpName") != m.end() && !m["OcpName"].empty()) {
      ocpName = make_shared<string>(boost::any_cast<string>(m["OcpName"]));
    }
    if (m.find("OperatingSystem") != m.end() && !m["OperatingSystem"].empty()) {
      operatingSystem = make_shared<string>(boost::any_cast<string>(m["OperatingSystem"]));
    }
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      owner = make_shared<string>(boost::any_cast<string>(m["Owner"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<long>(boost::any_cast<long>(m["Port"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("ResourceOwner") != m.end() && !m["ResourceOwner"].empty()) {
      resourceOwner = make_shared<string>(boost::any_cast<string>(m["ResourceOwner"]));
    }
    if (m.find("Timezone") != m.end() && !m["Timezone"].empty()) {
      timezone = make_shared<string>(boost::any_cast<string>(m["Timezone"]));
    }
    if (m.find("Username") != m.end() && !m["Username"].empty()) {
      username = make_shared<string>(boost::any_cast<string>(m["Username"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["Version"]));
    }
  }


  virtual ~DescribeProjectResponseBodyDataSourceConnectInfo() = default;
};
class DescribeProjectResponseBodyDataStepsExtraInfoErrorDetails : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<map<string, boost::any>> extraContext{};
  shared_ptr<string> level{};
  shared_ptr<string> message{};
  shared_ptr<map<string, string>> messageMcmsContext{};
  shared_ptr<string> messageMcmsKey{};
  shared_ptr<string> proposal{};
  shared_ptr<map<string, string>> proposalMcmsContext{};
  shared_ptr<string> proposalMcmsKey{};
  shared_ptr<string> reason{};
  shared_ptr<map<string, string>> reasonMcmsContext{};
  shared_ptr<string> reasonMcmsKey{};
  shared_ptr<boost::any> upstreamErrorDetail{};

  DescribeProjectResponseBodyDataStepsExtraInfoErrorDetails() {}

  explicit DescribeProjectResponseBodyDataStepsExtraInfoErrorDetails(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (extraContext) {
      res["ExtraContext"] = boost::any(*extraContext);
    }
    if (level) {
      res["Level"] = boost::any(*level);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (messageMcmsContext) {
      res["MessageMcmsContext"] = boost::any(*messageMcmsContext);
    }
    if (messageMcmsKey) {
      res["MessageMcmsKey"] = boost::any(*messageMcmsKey);
    }
    if (proposal) {
      res["Proposal"] = boost::any(*proposal);
    }
    if (proposalMcmsContext) {
      res["ProposalMcmsContext"] = boost::any(*proposalMcmsContext);
    }
    if (proposalMcmsKey) {
      res["ProposalMcmsKey"] = boost::any(*proposalMcmsKey);
    }
    if (reason) {
      res["Reason"] = boost::any(*reason);
    }
    if (reasonMcmsContext) {
      res["ReasonMcmsContext"] = boost::any(*reasonMcmsContext);
    }
    if (reasonMcmsKey) {
      res["ReasonMcmsKey"] = boost::any(*reasonMcmsKey);
    }
    if (upstreamErrorDetail) {
      res["UpstreamErrorDetail"] = boost::any(*upstreamErrorDetail);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ExtraContext") != m.end() && !m["ExtraContext"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["ExtraContext"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      extraContext = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<string>(boost::any_cast<string>(m["Level"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("MessageMcmsContext") != m.end() && !m["MessageMcmsContext"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["MessageMcmsContext"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      messageMcmsContext = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("MessageMcmsKey") != m.end() && !m["MessageMcmsKey"].empty()) {
      messageMcmsKey = make_shared<string>(boost::any_cast<string>(m["MessageMcmsKey"]));
    }
    if (m.find("Proposal") != m.end() && !m["Proposal"].empty()) {
      proposal = make_shared<string>(boost::any_cast<string>(m["Proposal"]));
    }
    if (m.find("ProposalMcmsContext") != m.end() && !m["ProposalMcmsContext"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["ProposalMcmsContext"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      proposalMcmsContext = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("ProposalMcmsKey") != m.end() && !m["ProposalMcmsKey"].empty()) {
      proposalMcmsKey = make_shared<string>(boost::any_cast<string>(m["ProposalMcmsKey"]));
    }
    if (m.find("Reason") != m.end() && !m["Reason"].empty()) {
      reason = make_shared<string>(boost::any_cast<string>(m["Reason"]));
    }
    if (m.find("ReasonMcmsContext") != m.end() && !m["ReasonMcmsContext"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["ReasonMcmsContext"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      reasonMcmsContext = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("ReasonMcmsKey") != m.end() && !m["ReasonMcmsKey"].empty()) {
      reasonMcmsKey = make_shared<string>(boost::any_cast<string>(m["ReasonMcmsKey"]));
    }
    if (m.find("UpstreamErrorDetail") != m.end() && !m["UpstreamErrorDetail"].empty()) {
      upstreamErrorDetail = make_shared<boost::any>(boost::any_cast<boost::any>(m["UpstreamErrorDetail"]));
    }
  }


  virtual ~DescribeProjectResponseBodyDataStepsExtraInfoErrorDetails() = default;
};
class DescribeProjectResponseBodyDataStepsExtraInfo : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<vector<DescribeProjectResponseBodyDataStepsExtraInfoErrorDetails>> errorDetails{};
  shared_ptr<string> errorMsg{};
  shared_ptr<map<string, string>> errorParam{};
  shared_ptr<string> failedTime{};

  DescribeProjectResponseBodyDataStepsExtraInfo() {}

  explicit DescribeProjectResponseBodyDataStepsExtraInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorDetails) {
      vector<boost::any> temp1;
      for(auto item1:*errorDetails){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ErrorDetails"] = boost::any(temp1);
    }
    if (errorMsg) {
      res["ErrorMsg"] = boost::any(*errorMsg);
    }
    if (errorParam) {
      res["ErrorParam"] = boost::any(*errorParam);
    }
    if (failedTime) {
      res["FailedTime"] = boost::any(*failedTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorDetails") != m.end() && !m["ErrorDetails"].empty()) {
      if (typeid(vector<boost::any>) == m["ErrorDetails"].type()) {
        vector<DescribeProjectResponseBodyDataStepsExtraInfoErrorDetails> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ErrorDetails"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeProjectResponseBodyDataStepsExtraInfoErrorDetails model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        errorDetails = make_shared<vector<DescribeProjectResponseBodyDataStepsExtraInfoErrorDetails>>(expect1);
      }
    }
    if (m.find("ErrorMsg") != m.end() && !m["ErrorMsg"].empty()) {
      errorMsg = make_shared<string>(boost::any_cast<string>(m["ErrorMsg"]));
    }
    if (m.find("ErrorParam") != m.end() && !m["ErrorParam"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["ErrorParam"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      errorParam = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("FailedTime") != m.end() && !m["FailedTime"].empty()) {
      failedTime = make_shared<string>(boost::any_cast<string>(m["FailedTime"]));
    }
  }


  virtual ~DescribeProjectResponseBodyDataStepsExtraInfo() = default;
};
class DescribeProjectResponseBodyDataSteps : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<DescribeProjectResponseBodyDataStepsExtraInfo> extraInfo{};
  shared_ptr<string> finishTime{};
  shared_ptr<string> name{};
  shared_ptr<long> order{};
  shared_ptr<long> progress{};
  shared_ptr<string> startTime{};
  shared_ptr<string> status{};
  shared_ptr<map<string, boost::any>> stepInfo{};

  DescribeProjectResponseBodyDataSteps() {}

  explicit DescribeProjectResponseBodyDataSteps(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (extraInfo) {
      res["ExtraInfo"] = extraInfo ? boost::any(extraInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (finishTime) {
      res["FinishTime"] = boost::any(*finishTime);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (order) {
      res["Order"] = boost::any(*order);
    }
    if (progress) {
      res["Progress"] = boost::any(*progress);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (stepInfo) {
      res["StepInfo"] = boost::any(*stepInfo);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("ExtraInfo") != m.end() && !m["ExtraInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["ExtraInfo"].type()) {
        DescribeProjectResponseBodyDataStepsExtraInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ExtraInfo"]));
        extraInfo = make_shared<DescribeProjectResponseBodyDataStepsExtraInfo>(model1);
      }
    }
    if (m.find("FinishTime") != m.end() && !m["FinishTime"].empty()) {
      finishTime = make_shared<string>(boost::any_cast<string>(m["FinishTime"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Order") != m.end() && !m["Order"].empty()) {
      order = make_shared<long>(boost::any_cast<long>(m["Order"]));
    }
    if (m.find("Progress") != m.end() && !m["Progress"].empty()) {
      progress = make_shared<long>(boost::any_cast<long>(m["Progress"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("StepInfo") != m.end() && !m["StepInfo"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["StepInfo"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      stepInfo = make_shared<map<string, boost::any>>(toMap1);
    }
  }


  virtual ~DescribeProjectResponseBodyDataSteps() = default;
};
class DescribeProjectResponseBodyDataStructTransferConfig : public Darabonba::Model {
public:
  shared_ptr<string> byteCharConvertStrategy{};
  shared_ptr<bool> deferIndexCreation{};

  DescribeProjectResponseBodyDataStructTransferConfig() {}

  explicit DescribeProjectResponseBodyDataStructTransferConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (byteCharConvertStrategy) {
      res["ByteCharConvertStrategy"] = boost::any(*byteCharConvertStrategy);
    }
    if (deferIndexCreation) {
      res["DeferIndexCreation"] = boost::any(*deferIndexCreation);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ByteCharConvertStrategy") != m.end() && !m["ByteCharConvertStrategy"].empty()) {
      byteCharConvertStrategy = make_shared<string>(boost::any_cast<string>(m["ByteCharConvertStrategy"]));
    }
    if (m.find("DeferIndexCreation") != m.end() && !m["DeferIndexCreation"].empty()) {
      deferIndexCreation = make_shared<bool>(boost::any_cast<bool>(m["DeferIndexCreation"]));
    }
  }


  virtual ~DescribeProjectResponseBodyDataStructTransferConfig() = default;
};
class DescribeProjectResponseBodyDataTransferMappingDatabasesSpecificTablesAdbTableSchema : public Darabonba::Model {
public:
  shared_ptr<vector<string>> distributedKeys{};
  shared_ptr<string> partitionLifeCycle{};
  shared_ptr<string> partitionStatement{};
  shared_ptr<vector<string>> primaryKeys{};

  DescribeProjectResponseBodyDataTransferMappingDatabasesSpecificTablesAdbTableSchema() {}

  explicit DescribeProjectResponseBodyDataTransferMappingDatabasesSpecificTablesAdbTableSchema(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (distributedKeys) {
      res["DistributedKeys"] = boost::any(*distributedKeys);
    }
    if (partitionLifeCycle) {
      res["PartitionLifeCycle"] = boost::any(*partitionLifeCycle);
    }
    if (partitionStatement) {
      res["PartitionStatement"] = boost::any(*partitionStatement);
    }
    if (primaryKeys) {
      res["PrimaryKeys"] = boost::any(*primaryKeys);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DistributedKeys") != m.end() && !m["DistributedKeys"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DistributedKeys"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DistributedKeys"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      distributedKeys = make_shared<vector<string>>(toVec1);
    }
    if (m.find("PartitionLifeCycle") != m.end() && !m["PartitionLifeCycle"].empty()) {
      partitionLifeCycle = make_shared<string>(boost::any_cast<string>(m["PartitionLifeCycle"]));
    }
    if (m.find("PartitionStatement") != m.end() && !m["PartitionStatement"].empty()) {
      partitionStatement = make_shared<string>(boost::any_cast<string>(m["PartitionStatement"]));
    }
    if (m.find("PrimaryKeys") != m.end() && !m["PrimaryKeys"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["PrimaryKeys"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["PrimaryKeys"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      primaryKeys = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeProjectResponseBodyDataTransferMappingDatabasesSpecificTablesAdbTableSchema() = default;
};
class DescribeProjectResponseBodyDataTransferMappingDatabasesSpecificTables : public Darabonba::Model {
public:
  shared_ptr<DescribeProjectResponseBodyDataTransferMappingDatabasesSpecificTablesAdbTableSchema> adbTableSchema{};
  shared_ptr<vector<string>> filterColumns{};
  shared_ptr<string> id{};
  shared_ptr<string> mappedName{};
  shared_ptr<string> name{};
  shared_ptr<vector<string>> shardColumns{};
  shared_ptr<string> whereClause{};

  DescribeProjectResponseBodyDataTransferMappingDatabasesSpecificTables() {}

  explicit DescribeProjectResponseBodyDataTransferMappingDatabasesSpecificTables(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (adbTableSchema) {
      res["AdbTableSchema"] = adbTableSchema ? boost::any(adbTableSchema->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (filterColumns) {
      res["FilterColumns"] = boost::any(*filterColumns);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (mappedName) {
      res["MappedName"] = boost::any(*mappedName);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (shardColumns) {
      res["ShardColumns"] = boost::any(*shardColumns);
    }
    if (whereClause) {
      res["WhereClause"] = boost::any(*whereClause);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AdbTableSchema") != m.end() && !m["AdbTableSchema"].empty()) {
      if (typeid(map<string, boost::any>) == m["AdbTableSchema"].type()) {
        DescribeProjectResponseBodyDataTransferMappingDatabasesSpecificTablesAdbTableSchema model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AdbTableSchema"]));
        adbTableSchema = make_shared<DescribeProjectResponseBodyDataTransferMappingDatabasesSpecificTablesAdbTableSchema>(model1);
      }
    }
    if (m.find("FilterColumns") != m.end() && !m["FilterColumns"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["FilterColumns"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["FilterColumns"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      filterColumns = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("MappedName") != m.end() && !m["MappedName"].empty()) {
      mappedName = make_shared<string>(boost::any_cast<string>(m["MappedName"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ShardColumns") != m.end() && !m["ShardColumns"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ShardColumns"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ShardColumns"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      shardColumns = make_shared<vector<string>>(toVec1);
    }
    if (m.find("WhereClause") != m.end() && !m["WhereClause"].empty()) {
      whereClause = make_shared<string>(boost::any_cast<string>(m["WhereClause"]));
    }
  }


  virtual ~DescribeProjectResponseBodyDataTransferMappingDatabasesSpecificTables() = default;
};
class DescribeProjectResponseBodyDataTransferMappingDatabasesSpecificViewsAdbTableSchema : public Darabonba::Model {
public:
  shared_ptr<vector<string>> distributedKeys{};
  shared_ptr<string> partitionLifeCycle{};
  shared_ptr<string> partitionStatement{};
  shared_ptr<vector<string>> primaryKeys{};

  DescribeProjectResponseBodyDataTransferMappingDatabasesSpecificViewsAdbTableSchema() {}

  explicit DescribeProjectResponseBodyDataTransferMappingDatabasesSpecificViewsAdbTableSchema(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (distributedKeys) {
      res["DistributedKeys"] = boost::any(*distributedKeys);
    }
    if (partitionLifeCycle) {
      res["PartitionLifeCycle"] = boost::any(*partitionLifeCycle);
    }
    if (partitionStatement) {
      res["PartitionStatement"] = boost::any(*partitionStatement);
    }
    if (primaryKeys) {
      res["PrimaryKeys"] = boost::any(*primaryKeys);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DistributedKeys") != m.end() && !m["DistributedKeys"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DistributedKeys"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DistributedKeys"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      distributedKeys = make_shared<vector<string>>(toVec1);
    }
    if (m.find("PartitionLifeCycle") != m.end() && !m["PartitionLifeCycle"].empty()) {
      partitionLifeCycle = make_shared<string>(boost::any_cast<string>(m["PartitionLifeCycle"]));
    }
    if (m.find("PartitionStatement") != m.end() && !m["PartitionStatement"].empty()) {
      partitionStatement = make_shared<string>(boost::any_cast<string>(m["PartitionStatement"]));
    }
    if (m.find("PrimaryKeys") != m.end() && !m["PrimaryKeys"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["PrimaryKeys"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["PrimaryKeys"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      primaryKeys = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeProjectResponseBodyDataTransferMappingDatabasesSpecificViewsAdbTableSchema() = default;
};
class DescribeProjectResponseBodyDataTransferMappingDatabasesSpecificViews : public Darabonba::Model {
public:
  shared_ptr<DescribeProjectResponseBodyDataTransferMappingDatabasesSpecificViewsAdbTableSchema> adbTableSchema{};
  shared_ptr<vector<string>> filterColumns{};
  shared_ptr<string> id{};
  shared_ptr<string> mappedName{};
  shared_ptr<string> name{};
  shared_ptr<vector<string>> shardColumns{};
  shared_ptr<string> whereClause{};

  DescribeProjectResponseBodyDataTransferMappingDatabasesSpecificViews() {}

  explicit DescribeProjectResponseBodyDataTransferMappingDatabasesSpecificViews(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (adbTableSchema) {
      res["AdbTableSchema"] = adbTableSchema ? boost::any(adbTableSchema->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (filterColumns) {
      res["FilterColumns"] = boost::any(*filterColumns);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (mappedName) {
      res["MappedName"] = boost::any(*mappedName);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (shardColumns) {
      res["ShardColumns"] = boost::any(*shardColumns);
    }
    if (whereClause) {
      res["WhereClause"] = boost::any(*whereClause);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AdbTableSchema") != m.end() && !m["AdbTableSchema"].empty()) {
      if (typeid(map<string, boost::any>) == m["AdbTableSchema"].type()) {
        DescribeProjectResponseBodyDataTransferMappingDatabasesSpecificViewsAdbTableSchema model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AdbTableSchema"]));
        adbTableSchema = make_shared<DescribeProjectResponseBodyDataTransferMappingDatabasesSpecificViewsAdbTableSchema>(model1);
      }
    }
    if (m.find("FilterColumns") != m.end() && !m["FilterColumns"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["FilterColumns"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["FilterColumns"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      filterColumns = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("MappedName") != m.end() && !m["MappedName"].empty()) {
      mappedName = make_shared<string>(boost::any_cast<string>(m["MappedName"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ShardColumns") != m.end() && !m["ShardColumns"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ShardColumns"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ShardColumns"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      shardColumns = make_shared<vector<string>>(toVec1);
    }
    if (m.find("WhereClause") != m.end() && !m["WhereClause"].empty()) {
      whereClause = make_shared<string>(boost::any_cast<string>(m["WhereClause"]));
    }
  }


  virtual ~DescribeProjectResponseBodyDataTransferMappingDatabasesSpecificViews() = default;
};
class DescribeProjectResponseBodyDataTransferMappingDatabasesTablesAdbTableSchema : public Darabonba::Model {
public:
  shared_ptr<vector<string>> distributedKeys{};
  shared_ptr<string> partitionLifeCycle{};
  shared_ptr<string> partitionStatement{};
  shared_ptr<vector<string>> primaryKeys{};

  DescribeProjectResponseBodyDataTransferMappingDatabasesTablesAdbTableSchema() {}

  explicit DescribeProjectResponseBodyDataTransferMappingDatabasesTablesAdbTableSchema(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (distributedKeys) {
      res["DistributedKeys"] = boost::any(*distributedKeys);
    }
    if (partitionLifeCycle) {
      res["PartitionLifeCycle"] = boost::any(*partitionLifeCycle);
    }
    if (partitionStatement) {
      res["PartitionStatement"] = boost::any(*partitionStatement);
    }
    if (primaryKeys) {
      res["PrimaryKeys"] = boost::any(*primaryKeys);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DistributedKeys") != m.end() && !m["DistributedKeys"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DistributedKeys"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DistributedKeys"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      distributedKeys = make_shared<vector<string>>(toVec1);
    }
    if (m.find("PartitionLifeCycle") != m.end() && !m["PartitionLifeCycle"].empty()) {
      partitionLifeCycle = make_shared<string>(boost::any_cast<string>(m["PartitionLifeCycle"]));
    }
    if (m.find("PartitionStatement") != m.end() && !m["PartitionStatement"].empty()) {
      partitionStatement = make_shared<string>(boost::any_cast<string>(m["PartitionStatement"]));
    }
    if (m.find("PrimaryKeys") != m.end() && !m["PrimaryKeys"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["PrimaryKeys"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["PrimaryKeys"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      primaryKeys = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeProjectResponseBodyDataTransferMappingDatabasesTablesAdbTableSchema() = default;
};
class DescribeProjectResponseBodyDataTransferMappingDatabasesTables : public Darabonba::Model {
public:
  shared_ptr<DescribeProjectResponseBodyDataTransferMappingDatabasesTablesAdbTableSchema> adbTableSchema{};
  shared_ptr<vector<string>> filterColumns{};
  shared_ptr<string> id{};
  shared_ptr<string> mappedName{};
  shared_ptr<string> name{};
  shared_ptr<vector<string>> shardColumns{};
  shared_ptr<string> whereClause{};

  DescribeProjectResponseBodyDataTransferMappingDatabasesTables() {}

  explicit DescribeProjectResponseBodyDataTransferMappingDatabasesTables(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (adbTableSchema) {
      res["AdbTableSchema"] = adbTableSchema ? boost::any(adbTableSchema->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (filterColumns) {
      res["FilterColumns"] = boost::any(*filterColumns);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (mappedName) {
      res["MappedName"] = boost::any(*mappedName);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (shardColumns) {
      res["ShardColumns"] = boost::any(*shardColumns);
    }
    if (whereClause) {
      res["WhereClause"] = boost::any(*whereClause);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AdbTableSchema") != m.end() && !m["AdbTableSchema"].empty()) {
      if (typeid(map<string, boost::any>) == m["AdbTableSchema"].type()) {
        DescribeProjectResponseBodyDataTransferMappingDatabasesTablesAdbTableSchema model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AdbTableSchema"]));
        adbTableSchema = make_shared<DescribeProjectResponseBodyDataTransferMappingDatabasesTablesAdbTableSchema>(model1);
      }
    }
    if (m.find("FilterColumns") != m.end() && !m["FilterColumns"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["FilterColumns"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["FilterColumns"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      filterColumns = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("MappedName") != m.end() && !m["MappedName"].empty()) {
      mappedName = make_shared<string>(boost::any_cast<string>(m["MappedName"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ShardColumns") != m.end() && !m["ShardColumns"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ShardColumns"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ShardColumns"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      shardColumns = make_shared<vector<string>>(toVec1);
    }
    if (m.find("WhereClause") != m.end() && !m["WhereClause"].empty()) {
      whereClause = make_shared<string>(boost::any_cast<string>(m["WhereClause"]));
    }
  }


  virtual ~DescribeProjectResponseBodyDataTransferMappingDatabasesTables() = default;
};
class DescribeProjectResponseBodyDataTransferMappingDatabasesViewsAdbTableSchema : public Darabonba::Model {
public:
  shared_ptr<vector<string>> distributedKeys{};
  shared_ptr<string> partitionLifeCycle{};
  shared_ptr<string> partitionStatement{};
  shared_ptr<vector<string>> primaryKeys{};

  DescribeProjectResponseBodyDataTransferMappingDatabasesViewsAdbTableSchema() {}

  explicit DescribeProjectResponseBodyDataTransferMappingDatabasesViewsAdbTableSchema(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (distributedKeys) {
      res["DistributedKeys"] = boost::any(*distributedKeys);
    }
    if (partitionLifeCycle) {
      res["PartitionLifeCycle"] = boost::any(*partitionLifeCycle);
    }
    if (partitionStatement) {
      res["PartitionStatement"] = boost::any(*partitionStatement);
    }
    if (primaryKeys) {
      res["PrimaryKeys"] = boost::any(*primaryKeys);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DistributedKeys") != m.end() && !m["DistributedKeys"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DistributedKeys"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DistributedKeys"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      distributedKeys = make_shared<vector<string>>(toVec1);
    }
    if (m.find("PartitionLifeCycle") != m.end() && !m["PartitionLifeCycle"].empty()) {
      partitionLifeCycle = make_shared<string>(boost::any_cast<string>(m["PartitionLifeCycle"]));
    }
    if (m.find("PartitionStatement") != m.end() && !m["PartitionStatement"].empty()) {
      partitionStatement = make_shared<string>(boost::any_cast<string>(m["PartitionStatement"]));
    }
    if (m.find("PrimaryKeys") != m.end() && !m["PrimaryKeys"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["PrimaryKeys"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["PrimaryKeys"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      primaryKeys = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeProjectResponseBodyDataTransferMappingDatabasesViewsAdbTableSchema() = default;
};
class DescribeProjectResponseBodyDataTransferMappingDatabasesViews : public Darabonba::Model {
public:
  shared_ptr<DescribeProjectResponseBodyDataTransferMappingDatabasesViewsAdbTableSchema> adbTableSchema{};
  shared_ptr<vector<string>> filterColumns{};
  shared_ptr<string> id{};
  shared_ptr<string> mappedName{};
  shared_ptr<string> name{};
  shared_ptr<vector<string>> shardColumns{};
  shared_ptr<string> whereClause{};

  DescribeProjectResponseBodyDataTransferMappingDatabasesViews() {}

  explicit DescribeProjectResponseBodyDataTransferMappingDatabasesViews(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (adbTableSchema) {
      res["AdbTableSchema"] = adbTableSchema ? boost::any(adbTableSchema->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (filterColumns) {
      res["FilterColumns"] = boost::any(*filterColumns);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (mappedName) {
      res["MappedName"] = boost::any(*mappedName);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (shardColumns) {
      res["ShardColumns"] = boost::any(*shardColumns);
    }
    if (whereClause) {
      res["WhereClause"] = boost::any(*whereClause);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AdbTableSchema") != m.end() && !m["AdbTableSchema"].empty()) {
      if (typeid(map<string, boost::any>) == m["AdbTableSchema"].type()) {
        DescribeProjectResponseBodyDataTransferMappingDatabasesViewsAdbTableSchema model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AdbTableSchema"]));
        adbTableSchema = make_shared<DescribeProjectResponseBodyDataTransferMappingDatabasesViewsAdbTableSchema>(model1);
      }
    }
    if (m.find("FilterColumns") != m.end() && !m["FilterColumns"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["FilterColumns"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["FilterColumns"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      filterColumns = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("MappedName") != m.end() && !m["MappedName"].empty()) {
      mappedName = make_shared<string>(boost::any_cast<string>(m["MappedName"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ShardColumns") != m.end() && !m["ShardColumns"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ShardColumns"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ShardColumns"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      shardColumns = make_shared<vector<string>>(toVec1);
    }
    if (m.find("WhereClause") != m.end() && !m["WhereClause"].empty()) {
      whereClause = make_shared<string>(boost::any_cast<string>(m["WhereClause"]));
    }
  }


  virtual ~DescribeProjectResponseBodyDataTransferMappingDatabasesViews() = default;
};
class DescribeProjectResponseBodyDataTransferMappingDatabases : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<string> mappedName{};
  shared_ptr<string> name{};
  shared_ptr<vector<DescribeProjectResponseBodyDataTransferMappingDatabasesSpecificTables>> specificTables{};
  shared_ptr<vector<DescribeProjectResponseBodyDataTransferMappingDatabasesSpecificViews>> specificViews{};
  shared_ptr<vector<DescribeProjectResponseBodyDataTransferMappingDatabasesTables>> tables{};
  shared_ptr<string> tenantName{};
  shared_ptr<string> type{};
  shared_ptr<vector<DescribeProjectResponseBodyDataTransferMappingDatabasesViews>> views{};

  DescribeProjectResponseBodyDataTransferMappingDatabases() {}

  explicit DescribeProjectResponseBodyDataTransferMappingDatabases(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (mappedName) {
      res["MappedName"] = boost::any(*mappedName);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (specificTables) {
      vector<boost::any> temp1;
      for(auto item1:*specificTables){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SpecificTables"] = boost::any(temp1);
    }
    if (specificViews) {
      vector<boost::any> temp1;
      for(auto item1:*specificViews){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SpecificViews"] = boost::any(temp1);
    }
    if (tables) {
      vector<boost::any> temp1;
      for(auto item1:*tables){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tables"] = boost::any(temp1);
    }
    if (tenantName) {
      res["TenantName"] = boost::any(*tenantName);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (views) {
      vector<boost::any> temp1;
      for(auto item1:*views){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Views"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("MappedName") != m.end() && !m["MappedName"].empty()) {
      mappedName = make_shared<string>(boost::any_cast<string>(m["MappedName"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("SpecificTables") != m.end() && !m["SpecificTables"].empty()) {
      if (typeid(vector<boost::any>) == m["SpecificTables"].type()) {
        vector<DescribeProjectResponseBodyDataTransferMappingDatabasesSpecificTables> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SpecificTables"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeProjectResponseBodyDataTransferMappingDatabasesSpecificTables model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        specificTables = make_shared<vector<DescribeProjectResponseBodyDataTransferMappingDatabasesSpecificTables>>(expect1);
      }
    }
    if (m.find("SpecificViews") != m.end() && !m["SpecificViews"].empty()) {
      if (typeid(vector<boost::any>) == m["SpecificViews"].type()) {
        vector<DescribeProjectResponseBodyDataTransferMappingDatabasesSpecificViews> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SpecificViews"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeProjectResponseBodyDataTransferMappingDatabasesSpecificViews model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        specificViews = make_shared<vector<DescribeProjectResponseBodyDataTransferMappingDatabasesSpecificViews>>(expect1);
      }
    }
    if (m.find("Tables") != m.end() && !m["Tables"].empty()) {
      if (typeid(vector<boost::any>) == m["Tables"].type()) {
        vector<DescribeProjectResponseBodyDataTransferMappingDatabasesTables> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tables"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeProjectResponseBodyDataTransferMappingDatabasesTables model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tables = make_shared<vector<DescribeProjectResponseBodyDataTransferMappingDatabasesTables>>(expect1);
      }
    }
    if (m.find("TenantName") != m.end() && !m["TenantName"].empty()) {
      tenantName = make_shared<string>(boost::any_cast<string>(m["TenantName"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Views") != m.end() && !m["Views"].empty()) {
      if (typeid(vector<boost::any>) == m["Views"].type()) {
        vector<DescribeProjectResponseBodyDataTransferMappingDatabasesViews> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Views"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeProjectResponseBodyDataTransferMappingDatabasesViews model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        views = make_shared<vector<DescribeProjectResponseBodyDataTransferMappingDatabasesViews>>(expect1);
      }
    }
  }


  virtual ~DescribeProjectResponseBodyDataTransferMappingDatabases() = default;
};
class DescribeProjectResponseBodyDataTransferMappingDatabasesBlackSpecificTablesAdbTableSchema : public Darabonba::Model {
public:
  shared_ptr<vector<string>> distributedKeys{};
  shared_ptr<string> partitionLifeCycle{};
  shared_ptr<string> partitionStatement{};
  shared_ptr<vector<string>> primaryKeys{};

  DescribeProjectResponseBodyDataTransferMappingDatabasesBlackSpecificTablesAdbTableSchema() {}

  explicit DescribeProjectResponseBodyDataTransferMappingDatabasesBlackSpecificTablesAdbTableSchema(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (distributedKeys) {
      res["DistributedKeys"] = boost::any(*distributedKeys);
    }
    if (partitionLifeCycle) {
      res["PartitionLifeCycle"] = boost::any(*partitionLifeCycle);
    }
    if (partitionStatement) {
      res["PartitionStatement"] = boost::any(*partitionStatement);
    }
    if (primaryKeys) {
      res["PrimaryKeys"] = boost::any(*primaryKeys);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DistributedKeys") != m.end() && !m["DistributedKeys"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DistributedKeys"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DistributedKeys"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      distributedKeys = make_shared<vector<string>>(toVec1);
    }
    if (m.find("PartitionLifeCycle") != m.end() && !m["PartitionLifeCycle"].empty()) {
      partitionLifeCycle = make_shared<string>(boost::any_cast<string>(m["PartitionLifeCycle"]));
    }
    if (m.find("PartitionStatement") != m.end() && !m["PartitionStatement"].empty()) {
      partitionStatement = make_shared<string>(boost::any_cast<string>(m["PartitionStatement"]));
    }
    if (m.find("PrimaryKeys") != m.end() && !m["PrimaryKeys"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["PrimaryKeys"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["PrimaryKeys"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      primaryKeys = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeProjectResponseBodyDataTransferMappingDatabasesBlackSpecificTablesAdbTableSchema() = default;
};
class DescribeProjectResponseBodyDataTransferMappingDatabasesBlackSpecificTables : public Darabonba::Model {
public:
  shared_ptr<DescribeProjectResponseBodyDataTransferMappingDatabasesBlackSpecificTablesAdbTableSchema> adbTableSchema{};
  shared_ptr<vector<string>> filterColumns{};
  shared_ptr<string> id{};
  shared_ptr<string> mappedName{};
  shared_ptr<string> name{};
  shared_ptr<vector<string>> shardColumns{};
  shared_ptr<string> whereClause{};

  DescribeProjectResponseBodyDataTransferMappingDatabasesBlackSpecificTables() {}

  explicit DescribeProjectResponseBodyDataTransferMappingDatabasesBlackSpecificTables(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (adbTableSchema) {
      res["AdbTableSchema"] = adbTableSchema ? boost::any(adbTableSchema->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (filterColumns) {
      res["FilterColumns"] = boost::any(*filterColumns);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (mappedName) {
      res["MappedName"] = boost::any(*mappedName);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (shardColumns) {
      res["ShardColumns"] = boost::any(*shardColumns);
    }
    if (whereClause) {
      res["WhereClause"] = boost::any(*whereClause);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AdbTableSchema") != m.end() && !m["AdbTableSchema"].empty()) {
      if (typeid(map<string, boost::any>) == m["AdbTableSchema"].type()) {
        DescribeProjectResponseBodyDataTransferMappingDatabasesBlackSpecificTablesAdbTableSchema model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AdbTableSchema"]));
        adbTableSchema = make_shared<DescribeProjectResponseBodyDataTransferMappingDatabasesBlackSpecificTablesAdbTableSchema>(model1);
      }
    }
    if (m.find("FilterColumns") != m.end() && !m["FilterColumns"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["FilterColumns"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["FilterColumns"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      filterColumns = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("MappedName") != m.end() && !m["MappedName"].empty()) {
      mappedName = make_shared<string>(boost::any_cast<string>(m["MappedName"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ShardColumns") != m.end() && !m["ShardColumns"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ShardColumns"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ShardColumns"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      shardColumns = make_shared<vector<string>>(toVec1);
    }
    if (m.find("WhereClause") != m.end() && !m["WhereClause"].empty()) {
      whereClause = make_shared<string>(boost::any_cast<string>(m["WhereClause"]));
    }
  }


  virtual ~DescribeProjectResponseBodyDataTransferMappingDatabasesBlackSpecificTables() = default;
};
class DescribeProjectResponseBodyDataTransferMappingDatabasesBlackSpecificViewsAdbTableSchema : public Darabonba::Model {
public:
  shared_ptr<vector<string>> distributedKeys{};
  shared_ptr<string> partitionLifeCycle{};
  shared_ptr<string> partitionStatement{};
  shared_ptr<vector<string>> primaryKeys{};

  DescribeProjectResponseBodyDataTransferMappingDatabasesBlackSpecificViewsAdbTableSchema() {}

  explicit DescribeProjectResponseBodyDataTransferMappingDatabasesBlackSpecificViewsAdbTableSchema(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (distributedKeys) {
      res["DistributedKeys"] = boost::any(*distributedKeys);
    }
    if (partitionLifeCycle) {
      res["PartitionLifeCycle"] = boost::any(*partitionLifeCycle);
    }
    if (partitionStatement) {
      res["PartitionStatement"] = boost::any(*partitionStatement);
    }
    if (primaryKeys) {
      res["PrimaryKeys"] = boost::any(*primaryKeys);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DistributedKeys") != m.end() && !m["DistributedKeys"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DistributedKeys"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DistributedKeys"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      distributedKeys = make_shared<vector<string>>(toVec1);
    }
    if (m.find("PartitionLifeCycle") != m.end() && !m["PartitionLifeCycle"].empty()) {
      partitionLifeCycle = make_shared<string>(boost::any_cast<string>(m["PartitionLifeCycle"]));
    }
    if (m.find("PartitionStatement") != m.end() && !m["PartitionStatement"].empty()) {
      partitionStatement = make_shared<string>(boost::any_cast<string>(m["PartitionStatement"]));
    }
    if (m.find("PrimaryKeys") != m.end() && !m["PrimaryKeys"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["PrimaryKeys"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["PrimaryKeys"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      primaryKeys = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeProjectResponseBodyDataTransferMappingDatabasesBlackSpecificViewsAdbTableSchema() = default;
};
class DescribeProjectResponseBodyDataTransferMappingDatabasesBlackSpecificViews : public Darabonba::Model {
public:
  shared_ptr<DescribeProjectResponseBodyDataTransferMappingDatabasesBlackSpecificViewsAdbTableSchema> adbTableSchema{};
  shared_ptr<vector<string>> filterColumns{};
  shared_ptr<string> id{};
  shared_ptr<string> mappedName{};
  shared_ptr<string> name{};
  shared_ptr<vector<string>> shardColumns{};
  shared_ptr<string> whereClause{};

  DescribeProjectResponseBodyDataTransferMappingDatabasesBlackSpecificViews() {}

  explicit DescribeProjectResponseBodyDataTransferMappingDatabasesBlackSpecificViews(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (adbTableSchema) {
      res["AdbTableSchema"] = adbTableSchema ? boost::any(adbTableSchema->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (filterColumns) {
      res["FilterColumns"] = boost::any(*filterColumns);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (mappedName) {
      res["MappedName"] = boost::any(*mappedName);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (shardColumns) {
      res["ShardColumns"] = boost::any(*shardColumns);
    }
    if (whereClause) {
      res["WhereClause"] = boost::any(*whereClause);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AdbTableSchema") != m.end() && !m["AdbTableSchema"].empty()) {
      if (typeid(map<string, boost::any>) == m["AdbTableSchema"].type()) {
        DescribeProjectResponseBodyDataTransferMappingDatabasesBlackSpecificViewsAdbTableSchema model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AdbTableSchema"]));
        adbTableSchema = make_shared<DescribeProjectResponseBodyDataTransferMappingDatabasesBlackSpecificViewsAdbTableSchema>(model1);
      }
    }
    if (m.find("FilterColumns") != m.end() && !m["FilterColumns"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["FilterColumns"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["FilterColumns"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      filterColumns = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("MappedName") != m.end() && !m["MappedName"].empty()) {
      mappedName = make_shared<string>(boost::any_cast<string>(m["MappedName"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ShardColumns") != m.end() && !m["ShardColumns"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ShardColumns"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ShardColumns"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      shardColumns = make_shared<vector<string>>(toVec1);
    }
    if (m.find("WhereClause") != m.end() && !m["WhereClause"].empty()) {
      whereClause = make_shared<string>(boost::any_cast<string>(m["WhereClause"]));
    }
  }


  virtual ~DescribeProjectResponseBodyDataTransferMappingDatabasesBlackSpecificViews() = default;
};
class DescribeProjectResponseBodyDataTransferMappingDatabasesBlackTablesAdbTableSchema : public Darabonba::Model {
public:
  shared_ptr<vector<string>> distributedKeys{};
  shared_ptr<string> partitionLifeCycle{};
  shared_ptr<string> partitionStatement{};
  shared_ptr<vector<string>> primaryKeys{};

  DescribeProjectResponseBodyDataTransferMappingDatabasesBlackTablesAdbTableSchema() {}

  explicit DescribeProjectResponseBodyDataTransferMappingDatabasesBlackTablesAdbTableSchema(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (distributedKeys) {
      res["DistributedKeys"] = boost::any(*distributedKeys);
    }
    if (partitionLifeCycle) {
      res["PartitionLifeCycle"] = boost::any(*partitionLifeCycle);
    }
    if (partitionStatement) {
      res["PartitionStatement"] = boost::any(*partitionStatement);
    }
    if (primaryKeys) {
      res["PrimaryKeys"] = boost::any(*primaryKeys);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DistributedKeys") != m.end() && !m["DistributedKeys"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DistributedKeys"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DistributedKeys"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      distributedKeys = make_shared<vector<string>>(toVec1);
    }
    if (m.find("PartitionLifeCycle") != m.end() && !m["PartitionLifeCycle"].empty()) {
      partitionLifeCycle = make_shared<string>(boost::any_cast<string>(m["PartitionLifeCycle"]));
    }
    if (m.find("PartitionStatement") != m.end() && !m["PartitionStatement"].empty()) {
      partitionStatement = make_shared<string>(boost::any_cast<string>(m["PartitionStatement"]));
    }
    if (m.find("PrimaryKeys") != m.end() && !m["PrimaryKeys"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["PrimaryKeys"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["PrimaryKeys"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      primaryKeys = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeProjectResponseBodyDataTransferMappingDatabasesBlackTablesAdbTableSchema() = default;
};
class DescribeProjectResponseBodyDataTransferMappingDatabasesBlackTables : public Darabonba::Model {
public:
  shared_ptr<DescribeProjectResponseBodyDataTransferMappingDatabasesBlackTablesAdbTableSchema> adbTableSchema{};
  shared_ptr<vector<string>> filterColumns{};
  shared_ptr<string> id{};
  shared_ptr<string> mappedName{};
  shared_ptr<string> name{};
  shared_ptr<vector<string>> shardColumns{};
  shared_ptr<string> whereClause{};

  DescribeProjectResponseBodyDataTransferMappingDatabasesBlackTables() {}

  explicit DescribeProjectResponseBodyDataTransferMappingDatabasesBlackTables(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (adbTableSchema) {
      res["AdbTableSchema"] = adbTableSchema ? boost::any(adbTableSchema->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (filterColumns) {
      res["FilterColumns"] = boost::any(*filterColumns);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (mappedName) {
      res["MappedName"] = boost::any(*mappedName);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (shardColumns) {
      res["ShardColumns"] = boost::any(*shardColumns);
    }
    if (whereClause) {
      res["WhereClause"] = boost::any(*whereClause);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AdbTableSchema") != m.end() && !m["AdbTableSchema"].empty()) {
      if (typeid(map<string, boost::any>) == m["AdbTableSchema"].type()) {
        DescribeProjectResponseBodyDataTransferMappingDatabasesBlackTablesAdbTableSchema model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AdbTableSchema"]));
        adbTableSchema = make_shared<DescribeProjectResponseBodyDataTransferMappingDatabasesBlackTablesAdbTableSchema>(model1);
      }
    }
    if (m.find("FilterColumns") != m.end() && !m["FilterColumns"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["FilterColumns"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["FilterColumns"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      filterColumns = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("MappedName") != m.end() && !m["MappedName"].empty()) {
      mappedName = make_shared<string>(boost::any_cast<string>(m["MappedName"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ShardColumns") != m.end() && !m["ShardColumns"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ShardColumns"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ShardColumns"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      shardColumns = make_shared<vector<string>>(toVec1);
    }
    if (m.find("WhereClause") != m.end() && !m["WhereClause"].empty()) {
      whereClause = make_shared<string>(boost::any_cast<string>(m["WhereClause"]));
    }
  }


  virtual ~DescribeProjectResponseBodyDataTransferMappingDatabasesBlackTables() = default;
};
class DescribeProjectResponseBodyDataTransferMappingDatabasesBlackViewsAdbTableSchema : public Darabonba::Model {
public:
  shared_ptr<vector<string>> distributedKeys{};
  shared_ptr<string> partitionLifeCycle{};
  shared_ptr<string> partitionStatement{};
  shared_ptr<vector<string>> primaryKeys{};

  DescribeProjectResponseBodyDataTransferMappingDatabasesBlackViewsAdbTableSchema() {}

  explicit DescribeProjectResponseBodyDataTransferMappingDatabasesBlackViewsAdbTableSchema(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (distributedKeys) {
      res["DistributedKeys"] = boost::any(*distributedKeys);
    }
    if (partitionLifeCycle) {
      res["PartitionLifeCycle"] = boost::any(*partitionLifeCycle);
    }
    if (partitionStatement) {
      res["PartitionStatement"] = boost::any(*partitionStatement);
    }
    if (primaryKeys) {
      res["PrimaryKeys"] = boost::any(*primaryKeys);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DistributedKeys") != m.end() && !m["DistributedKeys"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DistributedKeys"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DistributedKeys"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      distributedKeys = make_shared<vector<string>>(toVec1);
    }
    if (m.find("PartitionLifeCycle") != m.end() && !m["PartitionLifeCycle"].empty()) {
      partitionLifeCycle = make_shared<string>(boost::any_cast<string>(m["PartitionLifeCycle"]));
    }
    if (m.find("PartitionStatement") != m.end() && !m["PartitionStatement"].empty()) {
      partitionStatement = make_shared<string>(boost::any_cast<string>(m["PartitionStatement"]));
    }
    if (m.find("PrimaryKeys") != m.end() && !m["PrimaryKeys"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["PrimaryKeys"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["PrimaryKeys"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      primaryKeys = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeProjectResponseBodyDataTransferMappingDatabasesBlackViewsAdbTableSchema() = default;
};
class DescribeProjectResponseBodyDataTransferMappingDatabasesBlackViews : public Darabonba::Model {
public:
  shared_ptr<DescribeProjectResponseBodyDataTransferMappingDatabasesBlackViewsAdbTableSchema> adbTableSchema{};
  shared_ptr<vector<string>> filterColumns{};
  shared_ptr<string> id{};
  shared_ptr<string> mappedName{};
  shared_ptr<string> name{};
  shared_ptr<vector<string>> shardColumns{};
  shared_ptr<string> whereClause{};

  DescribeProjectResponseBodyDataTransferMappingDatabasesBlackViews() {}

  explicit DescribeProjectResponseBodyDataTransferMappingDatabasesBlackViews(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (adbTableSchema) {
      res["AdbTableSchema"] = adbTableSchema ? boost::any(adbTableSchema->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (filterColumns) {
      res["FilterColumns"] = boost::any(*filterColumns);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (mappedName) {
      res["MappedName"] = boost::any(*mappedName);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (shardColumns) {
      res["ShardColumns"] = boost::any(*shardColumns);
    }
    if (whereClause) {
      res["WhereClause"] = boost::any(*whereClause);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AdbTableSchema") != m.end() && !m["AdbTableSchema"].empty()) {
      if (typeid(map<string, boost::any>) == m["AdbTableSchema"].type()) {
        DescribeProjectResponseBodyDataTransferMappingDatabasesBlackViewsAdbTableSchema model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AdbTableSchema"]));
        adbTableSchema = make_shared<DescribeProjectResponseBodyDataTransferMappingDatabasesBlackViewsAdbTableSchema>(model1);
      }
    }
    if (m.find("FilterColumns") != m.end() && !m["FilterColumns"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["FilterColumns"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["FilterColumns"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      filterColumns = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("MappedName") != m.end() && !m["MappedName"].empty()) {
      mappedName = make_shared<string>(boost::any_cast<string>(m["MappedName"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ShardColumns") != m.end() && !m["ShardColumns"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ShardColumns"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ShardColumns"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      shardColumns = make_shared<vector<string>>(toVec1);
    }
    if (m.find("WhereClause") != m.end() && !m["WhereClause"].empty()) {
      whereClause = make_shared<string>(boost::any_cast<string>(m["WhereClause"]));
    }
  }


  virtual ~DescribeProjectResponseBodyDataTransferMappingDatabasesBlackViews() = default;
};
class DescribeProjectResponseBodyDataTransferMappingDatabasesBlack : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<string> mappedName{};
  shared_ptr<string> name{};
  shared_ptr<vector<DescribeProjectResponseBodyDataTransferMappingDatabasesBlackSpecificTables>> specificTables{};
  shared_ptr<vector<DescribeProjectResponseBodyDataTransferMappingDatabasesBlackSpecificViews>> specificViews{};
  shared_ptr<vector<DescribeProjectResponseBodyDataTransferMappingDatabasesBlackTables>> tables{};
  shared_ptr<string> tenantName{};
  shared_ptr<string> type{};
  shared_ptr<vector<DescribeProjectResponseBodyDataTransferMappingDatabasesBlackViews>> views{};

  DescribeProjectResponseBodyDataTransferMappingDatabasesBlack() {}

  explicit DescribeProjectResponseBodyDataTransferMappingDatabasesBlack(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (mappedName) {
      res["MappedName"] = boost::any(*mappedName);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (specificTables) {
      vector<boost::any> temp1;
      for(auto item1:*specificTables){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SpecificTables"] = boost::any(temp1);
    }
    if (specificViews) {
      vector<boost::any> temp1;
      for(auto item1:*specificViews){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SpecificViews"] = boost::any(temp1);
    }
    if (tables) {
      vector<boost::any> temp1;
      for(auto item1:*tables){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tables"] = boost::any(temp1);
    }
    if (tenantName) {
      res["TenantName"] = boost::any(*tenantName);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (views) {
      vector<boost::any> temp1;
      for(auto item1:*views){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Views"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("MappedName") != m.end() && !m["MappedName"].empty()) {
      mappedName = make_shared<string>(boost::any_cast<string>(m["MappedName"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("SpecificTables") != m.end() && !m["SpecificTables"].empty()) {
      if (typeid(vector<boost::any>) == m["SpecificTables"].type()) {
        vector<DescribeProjectResponseBodyDataTransferMappingDatabasesBlackSpecificTables> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SpecificTables"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeProjectResponseBodyDataTransferMappingDatabasesBlackSpecificTables model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        specificTables = make_shared<vector<DescribeProjectResponseBodyDataTransferMappingDatabasesBlackSpecificTables>>(expect1);
      }
    }
    if (m.find("SpecificViews") != m.end() && !m["SpecificViews"].empty()) {
      if (typeid(vector<boost::any>) == m["SpecificViews"].type()) {
        vector<DescribeProjectResponseBodyDataTransferMappingDatabasesBlackSpecificViews> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SpecificViews"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeProjectResponseBodyDataTransferMappingDatabasesBlackSpecificViews model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        specificViews = make_shared<vector<DescribeProjectResponseBodyDataTransferMappingDatabasesBlackSpecificViews>>(expect1);
      }
    }
    if (m.find("Tables") != m.end() && !m["Tables"].empty()) {
      if (typeid(vector<boost::any>) == m["Tables"].type()) {
        vector<DescribeProjectResponseBodyDataTransferMappingDatabasesBlackTables> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tables"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeProjectResponseBodyDataTransferMappingDatabasesBlackTables model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tables = make_shared<vector<DescribeProjectResponseBodyDataTransferMappingDatabasesBlackTables>>(expect1);
      }
    }
    if (m.find("TenantName") != m.end() && !m["TenantName"].empty()) {
      tenantName = make_shared<string>(boost::any_cast<string>(m["TenantName"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Views") != m.end() && !m["Views"].empty()) {
      if (typeid(vector<boost::any>) == m["Views"].type()) {
        vector<DescribeProjectResponseBodyDataTransferMappingDatabasesBlackViews> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Views"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeProjectResponseBodyDataTransferMappingDatabasesBlackViews model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        views = make_shared<vector<DescribeProjectResponseBodyDataTransferMappingDatabasesBlackViews>>(expect1);
      }
    }
  }


  virtual ~DescribeProjectResponseBodyDataTransferMappingDatabasesBlack() = default;
};
class DescribeProjectResponseBodyDataTransferMapping : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeProjectResponseBodyDataTransferMappingDatabases>> databases{};
  shared_ptr<vector<DescribeProjectResponseBodyDataTransferMappingDatabasesBlack>> databasesBlack{};
  shared_ptr<string> mode{};
  shared_ptr<vector<string>> tableAndViewBlackList{};
  shared_ptr<vector<string>> tableAndViewWhiteList{};

  DescribeProjectResponseBodyDataTransferMapping() {}

  explicit DescribeProjectResponseBodyDataTransferMapping(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (databases) {
      vector<boost::any> temp1;
      for(auto item1:*databases){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Databases"] = boost::any(temp1);
    }
    if (databasesBlack) {
      vector<boost::any> temp1;
      for(auto item1:*databasesBlack){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DatabasesBlack"] = boost::any(temp1);
    }
    if (mode) {
      res["Mode"] = boost::any(*mode);
    }
    if (tableAndViewBlackList) {
      res["TableAndViewBlackList"] = boost::any(*tableAndViewBlackList);
    }
    if (tableAndViewWhiteList) {
      res["TableAndViewWhiteList"] = boost::any(*tableAndViewWhiteList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Databases") != m.end() && !m["Databases"].empty()) {
      if (typeid(vector<boost::any>) == m["Databases"].type()) {
        vector<DescribeProjectResponseBodyDataTransferMappingDatabases> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Databases"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeProjectResponseBodyDataTransferMappingDatabases model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        databases = make_shared<vector<DescribeProjectResponseBodyDataTransferMappingDatabases>>(expect1);
      }
    }
    if (m.find("DatabasesBlack") != m.end() && !m["DatabasesBlack"].empty()) {
      if (typeid(vector<boost::any>) == m["DatabasesBlack"].type()) {
        vector<DescribeProjectResponseBodyDataTransferMappingDatabasesBlack> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DatabasesBlack"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeProjectResponseBodyDataTransferMappingDatabasesBlack model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        databasesBlack = make_shared<vector<DescribeProjectResponseBodyDataTransferMappingDatabasesBlack>>(expect1);
      }
    }
    if (m.find("Mode") != m.end() && !m["Mode"].empty()) {
      mode = make_shared<string>(boost::any_cast<string>(m["Mode"]));
    }
    if (m.find("TableAndViewBlackList") != m.end() && !m["TableAndViewBlackList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["TableAndViewBlackList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["TableAndViewBlackList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      tableAndViewBlackList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("TableAndViewWhiteList") != m.end() && !m["TableAndViewWhiteList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["TableAndViewWhiteList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["TableAndViewWhiteList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      tableAndViewWhiteList = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeProjectResponseBodyDataTransferMapping() = default;
};
class DescribeProjectResponseBodyDataWorkerGradeInfo : public Darabonba::Model {
public:
  shared_ptr<bool> autoRenewal{};
  shared_ptr<string> chargeType{};
  shared_ptr<string> destRegion{};
  shared_ptr<string> destType{};
  shared_ptr<string> endTime{};
  shared_ptr<bool> expired{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> grade{};
  shared_ptr<string> id{};
  shared_ptr<string> name{};
  shared_ptr<string> sourceRegion{};
  shared_ptr<string> sourceType{};
  shared_ptr<string> spec{};
  shared_ptr<string> specName{};

  DescribeProjectResponseBodyDataWorkerGradeInfo() {}

  explicit DescribeProjectResponseBodyDataWorkerGradeInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (autoRenewal) {
      res["AutoRenewal"] = boost::any(*autoRenewal);
    }
    if (chargeType) {
      res["ChargeType"] = boost::any(*chargeType);
    }
    if (destRegion) {
      res["DestRegion"] = boost::any(*destRegion);
    }
    if (destType) {
      res["DestType"] = boost::any(*destType);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (expired) {
      res["Expired"] = boost::any(*expired);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (grade) {
      res["Grade"] = boost::any(*grade);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (sourceRegion) {
      res["SourceRegion"] = boost::any(*sourceRegion);
    }
    if (sourceType) {
      res["SourceType"] = boost::any(*sourceType);
    }
    if (spec) {
      res["Spec"] = boost::any(*spec);
    }
    if (specName) {
      res["SpecName"] = boost::any(*specName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AutoRenewal") != m.end() && !m["AutoRenewal"].empty()) {
      autoRenewal = make_shared<bool>(boost::any_cast<bool>(m["AutoRenewal"]));
    }
    if (m.find("ChargeType") != m.end() && !m["ChargeType"].empty()) {
      chargeType = make_shared<string>(boost::any_cast<string>(m["ChargeType"]));
    }
    if (m.find("DestRegion") != m.end() && !m["DestRegion"].empty()) {
      destRegion = make_shared<string>(boost::any_cast<string>(m["DestRegion"]));
    }
    if (m.find("DestType") != m.end() && !m["DestType"].empty()) {
      destType = make_shared<string>(boost::any_cast<string>(m["DestType"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("Expired") != m.end() && !m["Expired"].empty()) {
      expired = make_shared<bool>(boost::any_cast<bool>(m["Expired"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["GmtCreate"]));
    }
    if (m.find("Grade") != m.end() && !m["Grade"].empty()) {
      grade = make_shared<string>(boost::any_cast<string>(m["Grade"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("SourceRegion") != m.end() && !m["SourceRegion"].empty()) {
      sourceRegion = make_shared<string>(boost::any_cast<string>(m["SourceRegion"]));
    }
    if (m.find("SourceType") != m.end() && !m["SourceType"].empty()) {
      sourceType = make_shared<string>(boost::any_cast<string>(m["SourceType"]));
    }
    if (m.find("Spec") != m.end() && !m["Spec"].empty()) {
      spec = make_shared<string>(boost::any_cast<string>(m["Spec"]));
    }
    if (m.find("SpecName") != m.end() && !m["SpecName"].empty()) {
      specName = make_shared<string>(boost::any_cast<string>(m["SpecName"]));
    }
  }


  virtual ~DescribeProjectResponseBodyDataWorkerGradeInfo() = default;
};
class DescribeProjectResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<DescribeProjectResponseBodyDataAlarmStats> alarmStats{};
  shared_ptr<DescribeProjectResponseBodyDataCommonTransferConfig> commonTransferConfig{};
  shared_ptr<string> destConnId{};
  shared_ptr<bool> enableFullTransfer{};
  shared_ptr<bool> enableFullVerify{};
  shared_ptr<bool> enableIncrTransfer{};
  shared_ptr<bool> enableIncrVerify{};
  shared_ptr<bool> enableReverseIncrTransfer{};
  shared_ptr<bool> enableStructTransfer{};
  shared_ptr<DescribeProjectResponseBodyDataExtraInfo> extraInfo{};
  shared_ptr<DescribeProjectResponseBodyDataFullTransferConfig> fullTransferConfig{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> gmtFinish{};
  shared_ptr<string> gmtModified{};
  shared_ptr<string> gmtStart{};
  shared_ptr<string> id{};
  shared_ptr<string> importance{};
  shared_ptr<DescribeProjectResponseBodyDataIncrTransferConfig> incrTransferConfig{};
  shared_ptr<bool> isMerging{};
  shared_ptr<bool> isModifying{};
  shared_ptr<bool> isSubProject{};
  shared_ptr<vector<DescribeProjectResponseBodyDataLabels>> labels{};
  shared_ptr<string> name{};
  shared_ptr<string> owner{};
  shared_ptr<DescribeProjectResponseBodyDataReverseIncrTransferConfig> reverseIncrTransferConfig{};
  shared_ptr<DescribeProjectResponseBodyDataSinkConnectInfo> sinkConnectInfo{};
  shared_ptr<string> sinkEndpointType{};
  shared_ptr<DescribeProjectResponseBodyDataSourceConnectInfo> sourceConnectInfo{};
  shared_ptr<string> sourceEndpointType{};
  shared_ptr<string> status{};
  shared_ptr<vector<DescribeProjectResponseBodyDataSteps>> steps{};
  shared_ptr<DescribeProjectResponseBodyDataStructTransferConfig> structTransferConfig{};
  shared_ptr<DescribeProjectResponseBodyDataTransferMapping> transferMapping{};
  shared_ptr<string> type{};
  shared_ptr<string> workerGradeId{};
  shared_ptr<DescribeProjectResponseBodyDataWorkerGradeInfo> workerGradeInfo{};

  DescribeProjectResponseBodyData() {}

  explicit DescribeProjectResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alarmStats) {
      res["AlarmStats"] = alarmStats ? boost::any(alarmStats->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (commonTransferConfig) {
      res["CommonTransferConfig"] = commonTransferConfig ? boost::any(commonTransferConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (destConnId) {
      res["DestConnId"] = boost::any(*destConnId);
    }
    if (enableFullTransfer) {
      res["EnableFullTransfer"] = boost::any(*enableFullTransfer);
    }
    if (enableFullVerify) {
      res["EnableFullVerify"] = boost::any(*enableFullVerify);
    }
    if (enableIncrTransfer) {
      res["EnableIncrTransfer"] = boost::any(*enableIncrTransfer);
    }
    if (enableIncrVerify) {
      res["EnableIncrVerify"] = boost::any(*enableIncrVerify);
    }
    if (enableReverseIncrTransfer) {
      res["EnableReverseIncrTransfer"] = boost::any(*enableReverseIncrTransfer);
    }
    if (enableStructTransfer) {
      res["EnableStructTransfer"] = boost::any(*enableStructTransfer);
    }
    if (extraInfo) {
      res["ExtraInfo"] = extraInfo ? boost::any(extraInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (fullTransferConfig) {
      res["FullTransferConfig"] = fullTransferConfig ? boost::any(fullTransferConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtFinish) {
      res["GmtFinish"] = boost::any(*gmtFinish);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (gmtStart) {
      res["GmtStart"] = boost::any(*gmtStart);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (importance) {
      res["Importance"] = boost::any(*importance);
    }
    if (incrTransferConfig) {
      res["IncrTransferConfig"] = incrTransferConfig ? boost::any(incrTransferConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (isMerging) {
      res["IsMerging"] = boost::any(*isMerging);
    }
    if (isModifying) {
      res["IsModifying"] = boost::any(*isModifying);
    }
    if (isSubProject) {
      res["IsSubProject"] = boost::any(*isSubProject);
    }
    if (labels) {
      vector<boost::any> temp1;
      for(auto item1:*labels){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Labels"] = boost::any(temp1);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (owner) {
      res["Owner"] = boost::any(*owner);
    }
    if (reverseIncrTransferConfig) {
      res["ReverseIncrTransferConfig"] = reverseIncrTransferConfig ? boost::any(reverseIncrTransferConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (sinkConnectInfo) {
      res["SinkConnectInfo"] = sinkConnectInfo ? boost::any(sinkConnectInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (sinkEndpointType) {
      res["SinkEndpointType"] = boost::any(*sinkEndpointType);
    }
    if (sourceConnectInfo) {
      res["SourceConnectInfo"] = sourceConnectInfo ? boost::any(sourceConnectInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (sourceEndpointType) {
      res["SourceEndpointType"] = boost::any(*sourceEndpointType);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (steps) {
      vector<boost::any> temp1;
      for(auto item1:*steps){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Steps"] = boost::any(temp1);
    }
    if (structTransferConfig) {
      res["StructTransferConfig"] = structTransferConfig ? boost::any(structTransferConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (transferMapping) {
      res["TransferMapping"] = transferMapping ? boost::any(transferMapping->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (workerGradeId) {
      res["WorkerGradeId"] = boost::any(*workerGradeId);
    }
    if (workerGradeInfo) {
      res["WorkerGradeInfo"] = workerGradeInfo ? boost::any(workerGradeInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlarmStats") != m.end() && !m["AlarmStats"].empty()) {
      if (typeid(map<string, boost::any>) == m["AlarmStats"].type()) {
        DescribeProjectResponseBodyDataAlarmStats model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AlarmStats"]));
        alarmStats = make_shared<DescribeProjectResponseBodyDataAlarmStats>(model1);
      }
    }
    if (m.find("CommonTransferConfig") != m.end() && !m["CommonTransferConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["CommonTransferConfig"].type()) {
        DescribeProjectResponseBodyDataCommonTransferConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CommonTransferConfig"]));
        commonTransferConfig = make_shared<DescribeProjectResponseBodyDataCommonTransferConfig>(model1);
      }
    }
    if (m.find("DestConnId") != m.end() && !m["DestConnId"].empty()) {
      destConnId = make_shared<string>(boost::any_cast<string>(m["DestConnId"]));
    }
    if (m.find("EnableFullTransfer") != m.end() && !m["EnableFullTransfer"].empty()) {
      enableFullTransfer = make_shared<bool>(boost::any_cast<bool>(m["EnableFullTransfer"]));
    }
    if (m.find("EnableFullVerify") != m.end() && !m["EnableFullVerify"].empty()) {
      enableFullVerify = make_shared<bool>(boost::any_cast<bool>(m["EnableFullVerify"]));
    }
    if (m.find("EnableIncrTransfer") != m.end() && !m["EnableIncrTransfer"].empty()) {
      enableIncrTransfer = make_shared<bool>(boost::any_cast<bool>(m["EnableIncrTransfer"]));
    }
    if (m.find("EnableIncrVerify") != m.end() && !m["EnableIncrVerify"].empty()) {
      enableIncrVerify = make_shared<bool>(boost::any_cast<bool>(m["EnableIncrVerify"]));
    }
    if (m.find("EnableReverseIncrTransfer") != m.end() && !m["EnableReverseIncrTransfer"].empty()) {
      enableReverseIncrTransfer = make_shared<bool>(boost::any_cast<bool>(m["EnableReverseIncrTransfer"]));
    }
    if (m.find("EnableStructTransfer") != m.end() && !m["EnableStructTransfer"].empty()) {
      enableStructTransfer = make_shared<bool>(boost::any_cast<bool>(m["EnableStructTransfer"]));
    }
    if (m.find("ExtraInfo") != m.end() && !m["ExtraInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["ExtraInfo"].type()) {
        DescribeProjectResponseBodyDataExtraInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ExtraInfo"]));
        extraInfo = make_shared<DescribeProjectResponseBodyDataExtraInfo>(model1);
      }
    }
    if (m.find("FullTransferConfig") != m.end() && !m["FullTransferConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["FullTransferConfig"].type()) {
        DescribeProjectResponseBodyDataFullTransferConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FullTransferConfig"]));
        fullTransferConfig = make_shared<DescribeProjectResponseBodyDataFullTransferConfig>(model1);
      }
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["GmtCreate"]));
    }
    if (m.find("GmtFinish") != m.end() && !m["GmtFinish"].empty()) {
      gmtFinish = make_shared<string>(boost::any_cast<string>(m["GmtFinish"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<string>(boost::any_cast<string>(m["GmtModified"]));
    }
    if (m.find("GmtStart") != m.end() && !m["GmtStart"].empty()) {
      gmtStart = make_shared<string>(boost::any_cast<string>(m["GmtStart"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Importance") != m.end() && !m["Importance"].empty()) {
      importance = make_shared<string>(boost::any_cast<string>(m["Importance"]));
    }
    if (m.find("IncrTransferConfig") != m.end() && !m["IncrTransferConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["IncrTransferConfig"].type()) {
        DescribeProjectResponseBodyDataIncrTransferConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["IncrTransferConfig"]));
        incrTransferConfig = make_shared<DescribeProjectResponseBodyDataIncrTransferConfig>(model1);
      }
    }
    if (m.find("IsMerging") != m.end() && !m["IsMerging"].empty()) {
      isMerging = make_shared<bool>(boost::any_cast<bool>(m["IsMerging"]));
    }
    if (m.find("IsModifying") != m.end() && !m["IsModifying"].empty()) {
      isModifying = make_shared<bool>(boost::any_cast<bool>(m["IsModifying"]));
    }
    if (m.find("IsSubProject") != m.end() && !m["IsSubProject"].empty()) {
      isSubProject = make_shared<bool>(boost::any_cast<bool>(m["IsSubProject"]));
    }
    if (m.find("Labels") != m.end() && !m["Labels"].empty()) {
      if (typeid(vector<boost::any>) == m["Labels"].type()) {
        vector<DescribeProjectResponseBodyDataLabels> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Labels"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeProjectResponseBodyDataLabels model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        labels = make_shared<vector<DescribeProjectResponseBodyDataLabels>>(expect1);
      }
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      owner = make_shared<string>(boost::any_cast<string>(m["Owner"]));
    }
    if (m.find("ReverseIncrTransferConfig") != m.end() && !m["ReverseIncrTransferConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["ReverseIncrTransferConfig"].type()) {
        DescribeProjectResponseBodyDataReverseIncrTransferConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ReverseIncrTransferConfig"]));
        reverseIncrTransferConfig = make_shared<DescribeProjectResponseBodyDataReverseIncrTransferConfig>(model1);
      }
    }
    if (m.find("SinkConnectInfo") != m.end() && !m["SinkConnectInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["SinkConnectInfo"].type()) {
        DescribeProjectResponseBodyDataSinkConnectInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SinkConnectInfo"]));
        sinkConnectInfo = make_shared<DescribeProjectResponseBodyDataSinkConnectInfo>(model1);
      }
    }
    if (m.find("SinkEndpointType") != m.end() && !m["SinkEndpointType"].empty()) {
      sinkEndpointType = make_shared<string>(boost::any_cast<string>(m["SinkEndpointType"]));
    }
    if (m.find("SourceConnectInfo") != m.end() && !m["SourceConnectInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["SourceConnectInfo"].type()) {
        DescribeProjectResponseBodyDataSourceConnectInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SourceConnectInfo"]));
        sourceConnectInfo = make_shared<DescribeProjectResponseBodyDataSourceConnectInfo>(model1);
      }
    }
    if (m.find("SourceEndpointType") != m.end() && !m["SourceEndpointType"].empty()) {
      sourceEndpointType = make_shared<string>(boost::any_cast<string>(m["SourceEndpointType"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Steps") != m.end() && !m["Steps"].empty()) {
      if (typeid(vector<boost::any>) == m["Steps"].type()) {
        vector<DescribeProjectResponseBodyDataSteps> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Steps"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeProjectResponseBodyDataSteps model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        steps = make_shared<vector<DescribeProjectResponseBodyDataSteps>>(expect1);
      }
    }
    if (m.find("StructTransferConfig") != m.end() && !m["StructTransferConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["StructTransferConfig"].type()) {
        DescribeProjectResponseBodyDataStructTransferConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["StructTransferConfig"]));
        structTransferConfig = make_shared<DescribeProjectResponseBodyDataStructTransferConfig>(model1);
      }
    }
    if (m.find("TransferMapping") != m.end() && !m["TransferMapping"].empty()) {
      if (typeid(map<string, boost::any>) == m["TransferMapping"].type()) {
        DescribeProjectResponseBodyDataTransferMapping model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TransferMapping"]));
        transferMapping = make_shared<DescribeProjectResponseBodyDataTransferMapping>(model1);
      }
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("WorkerGradeId") != m.end() && !m["WorkerGradeId"].empty()) {
      workerGradeId = make_shared<string>(boost::any_cast<string>(m["WorkerGradeId"]));
    }
    if (m.find("WorkerGradeInfo") != m.end() && !m["WorkerGradeInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["WorkerGradeInfo"].type()) {
        DescribeProjectResponseBodyDataWorkerGradeInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["WorkerGradeInfo"]));
        workerGradeInfo = make_shared<DescribeProjectResponseBodyDataWorkerGradeInfo>(model1);
      }
    }
  }


  virtual ~DescribeProjectResponseBodyData() = default;
};
class DescribeProjectResponseBodyErrorDetail : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<map<string, boost::any>> extraContext{};
  shared_ptr<string> level{};
  shared_ptr<string> message{};
  shared_ptr<map<string, string>> messageMcmsContext{};
  shared_ptr<string> messageMcmsKey{};
  shared_ptr<string> proposal{};
  shared_ptr<map<string, string>> proposalMcmsContext{};
  shared_ptr<string> proposalMcmsKey{};
  shared_ptr<string> reason{};
  shared_ptr<map<string, string>> reasonMcmsContext{};
  shared_ptr<string> reasonMcmsKey{};
  shared_ptr<boost::any> upstreamErrorDetail{};

  DescribeProjectResponseBodyErrorDetail() {}

  explicit DescribeProjectResponseBodyErrorDetail(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (extraContext) {
      res["ExtraContext"] = boost::any(*extraContext);
    }
    if (level) {
      res["Level"] = boost::any(*level);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (messageMcmsContext) {
      res["MessageMcmsContext"] = boost::any(*messageMcmsContext);
    }
    if (messageMcmsKey) {
      res["MessageMcmsKey"] = boost::any(*messageMcmsKey);
    }
    if (proposal) {
      res["Proposal"] = boost::any(*proposal);
    }
    if (proposalMcmsContext) {
      res["ProposalMcmsContext"] = boost::any(*proposalMcmsContext);
    }
    if (proposalMcmsKey) {
      res["ProposalMcmsKey"] = boost::any(*proposalMcmsKey);
    }
    if (reason) {
      res["Reason"] = boost::any(*reason);
    }
    if (reasonMcmsContext) {
      res["ReasonMcmsContext"] = boost::any(*reasonMcmsContext);
    }
    if (reasonMcmsKey) {
      res["ReasonMcmsKey"] = boost::any(*reasonMcmsKey);
    }
    if (upstreamErrorDetail) {
      res["UpstreamErrorDetail"] = boost::any(*upstreamErrorDetail);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ExtraContext") != m.end() && !m["ExtraContext"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["ExtraContext"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      extraContext = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<string>(boost::any_cast<string>(m["Level"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("MessageMcmsContext") != m.end() && !m["MessageMcmsContext"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["MessageMcmsContext"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      messageMcmsContext = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("MessageMcmsKey") != m.end() && !m["MessageMcmsKey"].empty()) {
      messageMcmsKey = make_shared<string>(boost::any_cast<string>(m["MessageMcmsKey"]));
    }
    if (m.find("Proposal") != m.end() && !m["Proposal"].empty()) {
      proposal = make_shared<string>(boost::any_cast<string>(m["Proposal"]));
    }
    if (m.find("ProposalMcmsContext") != m.end() && !m["ProposalMcmsContext"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["ProposalMcmsContext"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      proposalMcmsContext = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("ProposalMcmsKey") != m.end() && !m["ProposalMcmsKey"].empty()) {
      proposalMcmsKey = make_shared<string>(boost::any_cast<string>(m["ProposalMcmsKey"]));
    }
    if (m.find("Reason") != m.end() && !m["Reason"].empty()) {
      reason = make_shared<string>(boost::any_cast<string>(m["Reason"]));
    }
    if (m.find("ReasonMcmsContext") != m.end() && !m["ReasonMcmsContext"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["ReasonMcmsContext"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      reasonMcmsContext = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("ReasonMcmsKey") != m.end() && !m["ReasonMcmsKey"].empty()) {
      reasonMcmsKey = make_shared<string>(boost::any_cast<string>(m["ReasonMcmsKey"]));
    }
    if (m.find("UpstreamErrorDetail") != m.end() && !m["UpstreamErrorDetail"].empty()) {
      upstreamErrorDetail = make_shared<boost::any>(boost::any_cast<boost::any>(m["UpstreamErrorDetail"]));
    }
  }


  virtual ~DescribeProjectResponseBodyErrorDetail() = default;
};
class DescribeProjectResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> advice{};
  shared_ptr<string> code{};
  shared_ptr<string> cost{};
  shared_ptr<DescribeProjectResponseBodyData> data{};
  shared_ptr<DescribeProjectResponseBodyErrorDetail> errorDetail{};
  shared_ptr<string> message{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<long> totalCount{};

  DescribeProjectResponseBody() {}

  explicit DescribeProjectResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (advice) {
      res["Advice"] = boost::any(*advice);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (cost) {
      res["Cost"] = boost::any(*cost);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorDetail) {
      res["ErrorDetail"] = errorDetail ? boost::any(errorDetail->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Advice") != m.end() && !m["Advice"].empty()) {
      advice = make_shared<string>(boost::any_cast<string>(m["Advice"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Cost") != m.end() && !m["Cost"].empty()) {
      cost = make_shared<string>(boost::any_cast<string>(m["Cost"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        DescribeProjectResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<DescribeProjectResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorDetail") != m.end() && !m["ErrorDetail"].empty()) {
      if (typeid(map<string, boost::any>) == m["ErrorDetail"].type()) {
        DescribeProjectResponseBodyErrorDetail model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ErrorDetail"]));
        errorDetail = make_shared<DescribeProjectResponseBodyErrorDetail>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeProjectResponseBody() = default;
};
class DescribeProjectResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeProjectResponseBody> body{};

  DescribeProjectResponse() {}

  explicit DescribeProjectResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeProjectResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeProjectResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeProjectResponse() = default;
};
class DescribeProjectComponentsRequest : public Darabonba::Model {
public:
  shared_ptr<string> id{};

  DescribeProjectComponentsRequest() {}

  explicit DescribeProjectComponentsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
  }


  virtual ~DescribeProjectComponentsRequest() = default;
};
class DescribeProjectComponentsResponseBodyDataFullImportComponentsErrorDetails : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<map<string, boost::any>> extraContext{};
  shared_ptr<string> level{};
  shared_ptr<string> message{};
  shared_ptr<map<string, string>> messageMcmsContext{};
  shared_ptr<string> messageMcmsKey{};
  shared_ptr<string> proposal{};
  shared_ptr<map<string, string>> proposalMcmsContext{};
  shared_ptr<string> proposalMcmsKey{};
  shared_ptr<string> reason{};
  shared_ptr<map<string, string>> reasonMcmsContext{};
  shared_ptr<string> reasonMcmsKey{};
  shared_ptr<boost::any> upstreamErrorDetail{};

  DescribeProjectComponentsResponseBodyDataFullImportComponentsErrorDetails() {}

  explicit DescribeProjectComponentsResponseBodyDataFullImportComponentsErrorDetails(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (extraContext) {
      res["ExtraContext"] = boost::any(*extraContext);
    }
    if (level) {
      res["Level"] = boost::any(*level);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (messageMcmsContext) {
      res["MessageMcmsContext"] = boost::any(*messageMcmsContext);
    }
    if (messageMcmsKey) {
      res["MessageMcmsKey"] = boost::any(*messageMcmsKey);
    }
    if (proposal) {
      res["Proposal"] = boost::any(*proposal);
    }
    if (proposalMcmsContext) {
      res["ProposalMcmsContext"] = boost::any(*proposalMcmsContext);
    }
    if (proposalMcmsKey) {
      res["ProposalMcmsKey"] = boost::any(*proposalMcmsKey);
    }
    if (reason) {
      res["Reason"] = boost::any(*reason);
    }
    if (reasonMcmsContext) {
      res["ReasonMcmsContext"] = boost::any(*reasonMcmsContext);
    }
    if (reasonMcmsKey) {
      res["ReasonMcmsKey"] = boost::any(*reasonMcmsKey);
    }
    if (upstreamErrorDetail) {
      res["UpstreamErrorDetail"] = boost::any(*upstreamErrorDetail);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ExtraContext") != m.end() && !m["ExtraContext"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["ExtraContext"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      extraContext = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<string>(boost::any_cast<string>(m["Level"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("MessageMcmsContext") != m.end() && !m["MessageMcmsContext"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["MessageMcmsContext"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      messageMcmsContext = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("MessageMcmsKey") != m.end() && !m["MessageMcmsKey"].empty()) {
      messageMcmsKey = make_shared<string>(boost::any_cast<string>(m["MessageMcmsKey"]));
    }
    if (m.find("Proposal") != m.end() && !m["Proposal"].empty()) {
      proposal = make_shared<string>(boost::any_cast<string>(m["Proposal"]));
    }
    if (m.find("ProposalMcmsContext") != m.end() && !m["ProposalMcmsContext"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["ProposalMcmsContext"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      proposalMcmsContext = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("ProposalMcmsKey") != m.end() && !m["ProposalMcmsKey"].empty()) {
      proposalMcmsKey = make_shared<string>(boost::any_cast<string>(m["ProposalMcmsKey"]));
    }
    if (m.find("Reason") != m.end() && !m["Reason"].empty()) {
      reason = make_shared<string>(boost::any_cast<string>(m["Reason"]));
    }
    if (m.find("ReasonMcmsContext") != m.end() && !m["ReasonMcmsContext"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["ReasonMcmsContext"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      reasonMcmsContext = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("ReasonMcmsKey") != m.end() && !m["ReasonMcmsKey"].empty()) {
      reasonMcmsKey = make_shared<string>(boost::any_cast<string>(m["ReasonMcmsKey"]));
    }
    if (m.find("UpstreamErrorDetail") != m.end() && !m["UpstreamErrorDetail"].empty()) {
      upstreamErrorDetail = make_shared<boost::any>(boost::any_cast<boost::any>(m["UpstreamErrorDetail"]));
    }
  }


  virtual ~DescribeProjectComponentsResponseBodyDataFullImportComponentsErrorDetails() = default;
};
class DescribeProjectComponentsResponseBodyDataFullImportComponents : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeProjectComponentsResponseBodyDataFullImportComponentsErrorDetails>> errorDetails{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> gmtModify{};
  shared_ptr<string> identity{};
  shared_ptr<string> ip{};
  shared_ptr<string> name{};
  shared_ptr<long> progress{};
  shared_ptr<string> region{};
  shared_ptr<string> status{};

  DescribeProjectComponentsResponseBodyDataFullImportComponents() {}

  explicit DescribeProjectComponentsResponseBodyDataFullImportComponents(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorDetails) {
      vector<boost::any> temp1;
      for(auto item1:*errorDetails){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ErrorDetails"] = boost::any(temp1);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModify) {
      res["GmtModify"] = boost::any(*gmtModify);
    }
    if (identity) {
      res["Identity"] = boost::any(*identity);
    }
    if (ip) {
      res["Ip"] = boost::any(*ip);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (progress) {
      res["Progress"] = boost::any(*progress);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorDetails") != m.end() && !m["ErrorDetails"].empty()) {
      if (typeid(vector<boost::any>) == m["ErrorDetails"].type()) {
        vector<DescribeProjectComponentsResponseBodyDataFullImportComponentsErrorDetails> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ErrorDetails"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeProjectComponentsResponseBodyDataFullImportComponentsErrorDetails model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        errorDetails = make_shared<vector<DescribeProjectComponentsResponseBodyDataFullImportComponentsErrorDetails>>(expect1);
      }
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["GmtCreate"]));
    }
    if (m.find("GmtModify") != m.end() && !m["GmtModify"].empty()) {
      gmtModify = make_shared<string>(boost::any_cast<string>(m["GmtModify"]));
    }
    if (m.find("Identity") != m.end() && !m["Identity"].empty()) {
      identity = make_shared<string>(boost::any_cast<string>(m["Identity"]));
    }
    if (m.find("Ip") != m.end() && !m["Ip"].empty()) {
      ip = make_shared<string>(boost::any_cast<string>(m["Ip"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Progress") != m.end() && !m["Progress"].empty()) {
      progress = make_shared<long>(boost::any_cast<long>(m["Progress"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeProjectComponentsResponseBodyDataFullImportComponents() = default;
};
class DescribeProjectComponentsResponseBodyDataFullVerifyComponentsErrorDetails : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<map<string, boost::any>> extraContext{};
  shared_ptr<string> level{};
  shared_ptr<string> message{};
  shared_ptr<map<string, string>> messageMcmsContext{};
  shared_ptr<string> messageMcmsKey{};
  shared_ptr<string> proposal{};
  shared_ptr<map<string, string>> proposalMcmsContext{};
  shared_ptr<string> proposalMcmsKey{};
  shared_ptr<string> reason{};
  shared_ptr<map<string, string>> reasonMcmsContext{};
  shared_ptr<string> reasonMcmsKey{};
  shared_ptr<boost::any> upstreamErrorDetail{};

  DescribeProjectComponentsResponseBodyDataFullVerifyComponentsErrorDetails() {}

  explicit DescribeProjectComponentsResponseBodyDataFullVerifyComponentsErrorDetails(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (extraContext) {
      res["ExtraContext"] = boost::any(*extraContext);
    }
    if (level) {
      res["Level"] = boost::any(*level);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (messageMcmsContext) {
      res["MessageMcmsContext"] = boost::any(*messageMcmsContext);
    }
    if (messageMcmsKey) {
      res["MessageMcmsKey"] = boost::any(*messageMcmsKey);
    }
    if (proposal) {
      res["Proposal"] = boost::any(*proposal);
    }
    if (proposalMcmsContext) {
      res["ProposalMcmsContext"] = boost::any(*proposalMcmsContext);
    }
    if (proposalMcmsKey) {
      res["ProposalMcmsKey"] = boost::any(*proposalMcmsKey);
    }
    if (reason) {
      res["Reason"] = boost::any(*reason);
    }
    if (reasonMcmsContext) {
      res["ReasonMcmsContext"] = boost::any(*reasonMcmsContext);
    }
    if (reasonMcmsKey) {
      res["ReasonMcmsKey"] = boost::any(*reasonMcmsKey);
    }
    if (upstreamErrorDetail) {
      res["UpstreamErrorDetail"] = boost::any(*upstreamErrorDetail);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ExtraContext") != m.end() && !m["ExtraContext"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["ExtraContext"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      extraContext = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<string>(boost::any_cast<string>(m["Level"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("MessageMcmsContext") != m.end() && !m["MessageMcmsContext"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["MessageMcmsContext"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      messageMcmsContext = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("MessageMcmsKey") != m.end() && !m["MessageMcmsKey"].empty()) {
      messageMcmsKey = make_shared<string>(boost::any_cast<string>(m["MessageMcmsKey"]));
    }
    if (m.find("Proposal") != m.end() && !m["Proposal"].empty()) {
      proposal = make_shared<string>(boost::any_cast<string>(m["Proposal"]));
    }
    if (m.find("ProposalMcmsContext") != m.end() && !m["ProposalMcmsContext"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["ProposalMcmsContext"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      proposalMcmsContext = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("ProposalMcmsKey") != m.end() && !m["ProposalMcmsKey"].empty()) {
      proposalMcmsKey = make_shared<string>(boost::any_cast<string>(m["ProposalMcmsKey"]));
    }
    if (m.find("Reason") != m.end() && !m["Reason"].empty()) {
      reason = make_shared<string>(boost::any_cast<string>(m["Reason"]));
    }
    if (m.find("ReasonMcmsContext") != m.end() && !m["ReasonMcmsContext"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["ReasonMcmsContext"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      reasonMcmsContext = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("ReasonMcmsKey") != m.end() && !m["ReasonMcmsKey"].empty()) {
      reasonMcmsKey = make_shared<string>(boost::any_cast<string>(m["ReasonMcmsKey"]));
    }
    if (m.find("UpstreamErrorDetail") != m.end() && !m["UpstreamErrorDetail"].empty()) {
      upstreamErrorDetail = make_shared<boost::any>(boost::any_cast<boost::any>(m["UpstreamErrorDetail"]));
    }
  }


  virtual ~DescribeProjectComponentsResponseBodyDataFullVerifyComponentsErrorDetails() = default;
};
class DescribeProjectComponentsResponseBodyDataFullVerifyComponents : public Darabonba::Model {
public:
  shared_ptr<long> consistentQuantity{};
  shared_ptr<vector<DescribeProjectComponentsResponseBodyDataFullVerifyComponentsErrorDetails>> errorDetails{};
  shared_ptr<long> inconsistentQuantity{};
  shared_ptr<string> ip{};
  shared_ptr<string> name{};
  shared_ptr<string> progress{};
  shared_ptr<long> recordProgress{};
  shared_ptr<string> region{};
  shared_ptr<string> status{};
  shared_ptr<long> taskId{};

  DescribeProjectComponentsResponseBodyDataFullVerifyComponents() {}

  explicit DescribeProjectComponentsResponseBodyDataFullVerifyComponents(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (consistentQuantity) {
      res["ConsistentQuantity"] = boost::any(*consistentQuantity);
    }
    if (errorDetails) {
      vector<boost::any> temp1;
      for(auto item1:*errorDetails){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ErrorDetails"] = boost::any(temp1);
    }
    if (inconsistentQuantity) {
      res["InconsistentQuantity"] = boost::any(*inconsistentQuantity);
    }
    if (ip) {
      res["Ip"] = boost::any(*ip);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (progress) {
      res["Progress"] = boost::any(*progress);
    }
    if (recordProgress) {
      res["RecordProgress"] = boost::any(*recordProgress);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConsistentQuantity") != m.end() && !m["ConsistentQuantity"].empty()) {
      consistentQuantity = make_shared<long>(boost::any_cast<long>(m["ConsistentQuantity"]));
    }
    if (m.find("ErrorDetails") != m.end() && !m["ErrorDetails"].empty()) {
      if (typeid(vector<boost::any>) == m["ErrorDetails"].type()) {
        vector<DescribeProjectComponentsResponseBodyDataFullVerifyComponentsErrorDetails> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ErrorDetails"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeProjectComponentsResponseBodyDataFullVerifyComponentsErrorDetails model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        errorDetails = make_shared<vector<DescribeProjectComponentsResponseBodyDataFullVerifyComponentsErrorDetails>>(expect1);
      }
    }
    if (m.find("InconsistentQuantity") != m.end() && !m["InconsistentQuantity"].empty()) {
      inconsistentQuantity = make_shared<long>(boost::any_cast<long>(m["InconsistentQuantity"]));
    }
    if (m.find("Ip") != m.end() && !m["Ip"].empty()) {
      ip = make_shared<string>(boost::any_cast<string>(m["Ip"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Progress") != m.end() && !m["Progress"].empty()) {
      progress = make_shared<string>(boost::any_cast<string>(m["Progress"]));
    }
    if (m.find("RecordProgress") != m.end() && !m["RecordProgress"].empty()) {
      recordProgress = make_shared<long>(boost::any_cast<long>(m["RecordProgress"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<long>(boost::any_cast<long>(m["TaskId"]));
    }
  }


  virtual ~DescribeProjectComponentsResponseBodyDataFullVerifyComponents() = default;
};
class DescribeProjectComponentsResponseBodyDataIncrSyncComponentsErrorDetails : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<map<string, boost::any>> extraContext{};
  shared_ptr<string> level{};
  shared_ptr<string> message{};
  shared_ptr<map<string, string>> messageMcmsContext{};
  shared_ptr<string> messageMcmsKey{};
  shared_ptr<string> proposal{};
  shared_ptr<map<string, string>> proposalMcmsContext{};
  shared_ptr<string> proposalMcmsKey{};
  shared_ptr<string> reason{};
  shared_ptr<map<string, string>> reasonMcmsContext{};
  shared_ptr<string> reasonMcmsKey{};
  shared_ptr<boost::any> upstreamErrorDetail{};

  DescribeProjectComponentsResponseBodyDataIncrSyncComponentsErrorDetails() {}

  explicit DescribeProjectComponentsResponseBodyDataIncrSyncComponentsErrorDetails(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (extraContext) {
      res["ExtraContext"] = boost::any(*extraContext);
    }
    if (level) {
      res["Level"] = boost::any(*level);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (messageMcmsContext) {
      res["MessageMcmsContext"] = boost::any(*messageMcmsContext);
    }
    if (messageMcmsKey) {
      res["MessageMcmsKey"] = boost::any(*messageMcmsKey);
    }
    if (proposal) {
      res["Proposal"] = boost::any(*proposal);
    }
    if (proposalMcmsContext) {
      res["ProposalMcmsContext"] = boost::any(*proposalMcmsContext);
    }
    if (proposalMcmsKey) {
      res["ProposalMcmsKey"] = boost::any(*proposalMcmsKey);
    }
    if (reason) {
      res["Reason"] = boost::any(*reason);
    }
    if (reasonMcmsContext) {
      res["ReasonMcmsContext"] = boost::any(*reasonMcmsContext);
    }
    if (reasonMcmsKey) {
      res["ReasonMcmsKey"] = boost::any(*reasonMcmsKey);
    }
    if (upstreamErrorDetail) {
      res["UpstreamErrorDetail"] = boost::any(*upstreamErrorDetail);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ExtraContext") != m.end() && !m["ExtraContext"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["ExtraContext"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      extraContext = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<string>(boost::any_cast<string>(m["Level"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("MessageMcmsContext") != m.end() && !m["MessageMcmsContext"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["MessageMcmsContext"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      messageMcmsContext = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("MessageMcmsKey") != m.end() && !m["MessageMcmsKey"].empty()) {
      messageMcmsKey = make_shared<string>(boost::any_cast<string>(m["MessageMcmsKey"]));
    }
    if (m.find("Proposal") != m.end() && !m["Proposal"].empty()) {
      proposal = make_shared<string>(boost::any_cast<string>(m["Proposal"]));
    }
    if (m.find("ProposalMcmsContext") != m.end() && !m["ProposalMcmsContext"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["ProposalMcmsContext"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      proposalMcmsContext = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("ProposalMcmsKey") != m.end() && !m["ProposalMcmsKey"].empty()) {
      proposalMcmsKey = make_shared<string>(boost::any_cast<string>(m["ProposalMcmsKey"]));
    }
    if (m.find("Reason") != m.end() && !m["Reason"].empty()) {
      reason = make_shared<string>(boost::any_cast<string>(m["Reason"]));
    }
    if (m.find("ReasonMcmsContext") != m.end() && !m["ReasonMcmsContext"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["ReasonMcmsContext"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      reasonMcmsContext = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("ReasonMcmsKey") != m.end() && !m["ReasonMcmsKey"].empty()) {
      reasonMcmsKey = make_shared<string>(boost::any_cast<string>(m["ReasonMcmsKey"]));
    }
    if (m.find("UpstreamErrorDetail") != m.end() && !m["UpstreamErrorDetail"].empty()) {
      upstreamErrorDetail = make_shared<boost::any>(boost::any_cast<boost::any>(m["UpstreamErrorDetail"]));
    }
  }


  virtual ~DescribeProjectComponentsResponseBodyDataIncrSyncComponentsErrorDetails() = default;
};
class DescribeProjectComponentsResponseBodyDataIncrSyncComponents : public Darabonba::Model {
public:
  shared_ptr<string> checkpoint{};
  shared_ptr<long> checkpointSampleTimestamp{};
  shared_ptr<long> delay{};
  shared_ptr<vector<DescribeProjectComponentsResponseBodyDataIncrSyncComponentsErrorDetails>> errorDetails{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> gmtModify{};
  shared_ptr<string> identity{};
  shared_ptr<string> ip{};
  shared_ptr<string> name{};
  shared_ptr<string> region{};
  shared_ptr<string> status{};
  shared_ptr<vector<string>> subtopics{};
  shared_ptr<long> tps{};

  DescribeProjectComponentsResponseBodyDataIncrSyncComponents() {}

  explicit DescribeProjectComponentsResponseBodyDataIncrSyncComponents(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (checkpoint) {
      res["Checkpoint"] = boost::any(*checkpoint);
    }
    if (checkpointSampleTimestamp) {
      res["CheckpointSampleTimestamp"] = boost::any(*checkpointSampleTimestamp);
    }
    if (delay) {
      res["Delay"] = boost::any(*delay);
    }
    if (errorDetails) {
      vector<boost::any> temp1;
      for(auto item1:*errorDetails){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ErrorDetails"] = boost::any(temp1);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModify) {
      res["GmtModify"] = boost::any(*gmtModify);
    }
    if (identity) {
      res["Identity"] = boost::any(*identity);
    }
    if (ip) {
      res["Ip"] = boost::any(*ip);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (subtopics) {
      res["Subtopics"] = boost::any(*subtopics);
    }
    if (tps) {
      res["Tps"] = boost::any(*tps);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Checkpoint") != m.end() && !m["Checkpoint"].empty()) {
      checkpoint = make_shared<string>(boost::any_cast<string>(m["Checkpoint"]));
    }
    if (m.find("CheckpointSampleTimestamp") != m.end() && !m["CheckpointSampleTimestamp"].empty()) {
      checkpointSampleTimestamp = make_shared<long>(boost::any_cast<long>(m["CheckpointSampleTimestamp"]));
    }
    if (m.find("Delay") != m.end() && !m["Delay"].empty()) {
      delay = make_shared<long>(boost::any_cast<long>(m["Delay"]));
    }
    if (m.find("ErrorDetails") != m.end() && !m["ErrorDetails"].empty()) {
      if (typeid(vector<boost::any>) == m["ErrorDetails"].type()) {
        vector<DescribeProjectComponentsResponseBodyDataIncrSyncComponentsErrorDetails> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ErrorDetails"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeProjectComponentsResponseBodyDataIncrSyncComponentsErrorDetails model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        errorDetails = make_shared<vector<DescribeProjectComponentsResponseBodyDataIncrSyncComponentsErrorDetails>>(expect1);
      }
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["GmtCreate"]));
    }
    if (m.find("GmtModify") != m.end() && !m["GmtModify"].empty()) {
      gmtModify = make_shared<string>(boost::any_cast<string>(m["GmtModify"]));
    }
    if (m.find("Identity") != m.end() && !m["Identity"].empty()) {
      identity = make_shared<string>(boost::any_cast<string>(m["Identity"]));
    }
    if (m.find("Ip") != m.end() && !m["Ip"].empty()) {
      ip = make_shared<string>(boost::any_cast<string>(m["Ip"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Subtopics") != m.end() && !m["Subtopics"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Subtopics"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Subtopics"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      subtopics = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Tps") != m.end() && !m["Tps"].empty()) {
      tps = make_shared<long>(boost::any_cast<long>(m["Tps"]));
    }
  }


  virtual ~DescribeProjectComponentsResponseBodyDataIncrSyncComponents() = default;
};
class DescribeProjectComponentsResponseBodyDataReverseIncrSyncComponentsErrorDetails : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<map<string, boost::any>> extraContext{};
  shared_ptr<string> level{};
  shared_ptr<string> message{};
  shared_ptr<map<string, string>> messageMcmsContext{};
  shared_ptr<string> messageMcmsKey{};
  shared_ptr<string> proposal{};
  shared_ptr<map<string, string>> proposalMcmsContext{};
  shared_ptr<string> proposalMcmsKey{};
  shared_ptr<string> reason{};
  shared_ptr<map<string, string>> reasonMcmsContext{};
  shared_ptr<string> reasonMcmsKey{};
  shared_ptr<boost::any> upstreamErrorDetail{};

  DescribeProjectComponentsResponseBodyDataReverseIncrSyncComponentsErrorDetails() {}

  explicit DescribeProjectComponentsResponseBodyDataReverseIncrSyncComponentsErrorDetails(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (extraContext) {
      res["ExtraContext"] = boost::any(*extraContext);
    }
    if (level) {
      res["Level"] = boost::any(*level);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (messageMcmsContext) {
      res["MessageMcmsContext"] = boost::any(*messageMcmsContext);
    }
    if (messageMcmsKey) {
      res["MessageMcmsKey"] = boost::any(*messageMcmsKey);
    }
    if (proposal) {
      res["Proposal"] = boost::any(*proposal);
    }
    if (proposalMcmsContext) {
      res["ProposalMcmsContext"] = boost::any(*proposalMcmsContext);
    }
    if (proposalMcmsKey) {
      res["ProposalMcmsKey"] = boost::any(*proposalMcmsKey);
    }
    if (reason) {
      res["Reason"] = boost::any(*reason);
    }
    if (reasonMcmsContext) {
      res["ReasonMcmsContext"] = boost::any(*reasonMcmsContext);
    }
    if (reasonMcmsKey) {
      res["ReasonMcmsKey"] = boost::any(*reasonMcmsKey);
    }
    if (upstreamErrorDetail) {
      res["UpstreamErrorDetail"] = boost::any(*upstreamErrorDetail);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ExtraContext") != m.end() && !m["ExtraContext"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["ExtraContext"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      extraContext = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<string>(boost::any_cast<string>(m["Level"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("MessageMcmsContext") != m.end() && !m["MessageMcmsContext"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["MessageMcmsContext"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      messageMcmsContext = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("MessageMcmsKey") != m.end() && !m["MessageMcmsKey"].empty()) {
      messageMcmsKey = make_shared<string>(boost::any_cast<string>(m["MessageMcmsKey"]));
    }
    if (m.find("Proposal") != m.end() && !m["Proposal"].empty()) {
      proposal = make_shared<string>(boost::any_cast<string>(m["Proposal"]));
    }
    if (m.find("ProposalMcmsContext") != m.end() && !m["ProposalMcmsContext"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["ProposalMcmsContext"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      proposalMcmsContext = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("ProposalMcmsKey") != m.end() && !m["ProposalMcmsKey"].empty()) {
      proposalMcmsKey = make_shared<string>(boost::any_cast<string>(m["ProposalMcmsKey"]));
    }
    if (m.find("Reason") != m.end() && !m["Reason"].empty()) {
      reason = make_shared<string>(boost::any_cast<string>(m["Reason"]));
    }
    if (m.find("ReasonMcmsContext") != m.end() && !m["ReasonMcmsContext"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["ReasonMcmsContext"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      reasonMcmsContext = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("ReasonMcmsKey") != m.end() && !m["ReasonMcmsKey"].empty()) {
      reasonMcmsKey = make_shared<string>(boost::any_cast<string>(m["ReasonMcmsKey"]));
    }
    if (m.find("UpstreamErrorDetail") != m.end() && !m["UpstreamErrorDetail"].empty()) {
      upstreamErrorDetail = make_shared<boost::any>(boost::any_cast<boost::any>(m["UpstreamErrorDetail"]));
    }
  }


  virtual ~DescribeProjectComponentsResponseBodyDataReverseIncrSyncComponentsErrorDetails() = default;
};
class DescribeProjectComponentsResponseBodyDataReverseIncrSyncComponents : public Darabonba::Model {
public:
  shared_ptr<string> checkpoint{};
  shared_ptr<long> checkpointSampleTimestamp{};
  shared_ptr<long> delay{};
  shared_ptr<vector<DescribeProjectComponentsResponseBodyDataReverseIncrSyncComponentsErrorDetails>> errorDetails{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> gmtModify{};
  shared_ptr<string> identity{};
  shared_ptr<string> ip{};
  shared_ptr<string> name{};
  shared_ptr<string> region{};
  shared_ptr<string> status{};
  shared_ptr<vector<string>> subtopics{};
  shared_ptr<long> tps{};

  DescribeProjectComponentsResponseBodyDataReverseIncrSyncComponents() {}

  explicit DescribeProjectComponentsResponseBodyDataReverseIncrSyncComponents(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (checkpoint) {
      res["Checkpoint"] = boost::any(*checkpoint);
    }
    if (checkpointSampleTimestamp) {
      res["CheckpointSampleTimestamp"] = boost::any(*checkpointSampleTimestamp);
    }
    if (delay) {
      res["Delay"] = boost::any(*delay);
    }
    if (errorDetails) {
      vector<boost::any> temp1;
      for(auto item1:*errorDetails){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ErrorDetails"] = boost::any(temp1);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModify) {
      res["GmtModify"] = boost::any(*gmtModify);
    }
    if (identity) {
      res["Identity"] = boost::any(*identity);
    }
    if (ip) {
      res["Ip"] = boost::any(*ip);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (subtopics) {
      res["Subtopics"] = boost::any(*subtopics);
    }
    if (tps) {
      res["Tps"] = boost::any(*tps);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Checkpoint") != m.end() && !m["Checkpoint"].empty()) {
      checkpoint = make_shared<string>(boost::any_cast<string>(m["Checkpoint"]));
    }
    if (m.find("CheckpointSampleTimestamp") != m.end() && !m["CheckpointSampleTimestamp"].empty()) {
      checkpointSampleTimestamp = make_shared<long>(boost::any_cast<long>(m["CheckpointSampleTimestamp"]));
    }
    if (m.find("Delay") != m.end() && !m["Delay"].empty()) {
      delay = make_shared<long>(boost::any_cast<long>(m["Delay"]));
    }
    if (m.find("ErrorDetails") != m.end() && !m["ErrorDetails"].empty()) {
      if (typeid(vector<boost::any>) == m["ErrorDetails"].type()) {
        vector<DescribeProjectComponentsResponseBodyDataReverseIncrSyncComponentsErrorDetails> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ErrorDetails"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeProjectComponentsResponseBodyDataReverseIncrSyncComponentsErrorDetails model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        errorDetails = make_shared<vector<DescribeProjectComponentsResponseBodyDataReverseIncrSyncComponentsErrorDetails>>(expect1);
      }
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["GmtCreate"]));
    }
    if (m.find("GmtModify") != m.end() && !m["GmtModify"].empty()) {
      gmtModify = make_shared<string>(boost::any_cast<string>(m["GmtModify"]));
    }
    if (m.find("Identity") != m.end() && !m["Identity"].empty()) {
      identity = make_shared<string>(boost::any_cast<string>(m["Identity"]));
    }
    if (m.find("Ip") != m.end() && !m["Ip"].empty()) {
      ip = make_shared<string>(boost::any_cast<string>(m["Ip"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Subtopics") != m.end() && !m["Subtopics"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Subtopics"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Subtopics"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      subtopics = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Tps") != m.end() && !m["Tps"].empty()) {
      tps = make_shared<long>(boost::any_cast<long>(m["Tps"]));
    }
  }


  virtual ~DescribeProjectComponentsResponseBodyDataReverseIncrSyncComponents() = default;
};
class DescribeProjectComponentsResponseBodyDataReverseStoreListErrorDetails : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<map<string, boost::any>> extraContext{};
  shared_ptr<string> level{};
  shared_ptr<string> message{};
  shared_ptr<map<string, string>> messageMcmsContext{};
  shared_ptr<string> messageMcmsKey{};
  shared_ptr<string> proposal{};
  shared_ptr<map<string, string>> proposalMcmsContext{};
  shared_ptr<string> proposalMcmsKey{};
  shared_ptr<string> reason{};
  shared_ptr<map<string, string>> reasonMcmsContext{};
  shared_ptr<string> reasonMcmsKey{};
  shared_ptr<boost::any> upstreamErrorDetail{};

  DescribeProjectComponentsResponseBodyDataReverseStoreListErrorDetails() {}

  explicit DescribeProjectComponentsResponseBodyDataReverseStoreListErrorDetails(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (extraContext) {
      res["ExtraContext"] = boost::any(*extraContext);
    }
    if (level) {
      res["Level"] = boost::any(*level);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (messageMcmsContext) {
      res["MessageMcmsContext"] = boost::any(*messageMcmsContext);
    }
    if (messageMcmsKey) {
      res["MessageMcmsKey"] = boost::any(*messageMcmsKey);
    }
    if (proposal) {
      res["Proposal"] = boost::any(*proposal);
    }
    if (proposalMcmsContext) {
      res["ProposalMcmsContext"] = boost::any(*proposalMcmsContext);
    }
    if (proposalMcmsKey) {
      res["ProposalMcmsKey"] = boost::any(*proposalMcmsKey);
    }
    if (reason) {
      res["Reason"] = boost::any(*reason);
    }
    if (reasonMcmsContext) {
      res["ReasonMcmsContext"] = boost::any(*reasonMcmsContext);
    }
    if (reasonMcmsKey) {
      res["ReasonMcmsKey"] = boost::any(*reasonMcmsKey);
    }
    if (upstreamErrorDetail) {
      res["UpstreamErrorDetail"] = boost::any(*upstreamErrorDetail);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ExtraContext") != m.end() && !m["ExtraContext"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["ExtraContext"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      extraContext = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<string>(boost::any_cast<string>(m["Level"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("MessageMcmsContext") != m.end() && !m["MessageMcmsContext"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["MessageMcmsContext"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      messageMcmsContext = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("MessageMcmsKey") != m.end() && !m["MessageMcmsKey"].empty()) {
      messageMcmsKey = make_shared<string>(boost::any_cast<string>(m["MessageMcmsKey"]));
    }
    if (m.find("Proposal") != m.end() && !m["Proposal"].empty()) {
      proposal = make_shared<string>(boost::any_cast<string>(m["Proposal"]));
    }
    if (m.find("ProposalMcmsContext") != m.end() && !m["ProposalMcmsContext"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["ProposalMcmsContext"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      proposalMcmsContext = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("ProposalMcmsKey") != m.end() && !m["ProposalMcmsKey"].empty()) {
      proposalMcmsKey = make_shared<string>(boost::any_cast<string>(m["ProposalMcmsKey"]));
    }
    if (m.find("Reason") != m.end() && !m["Reason"].empty()) {
      reason = make_shared<string>(boost::any_cast<string>(m["Reason"]));
    }
    if (m.find("ReasonMcmsContext") != m.end() && !m["ReasonMcmsContext"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["ReasonMcmsContext"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      reasonMcmsContext = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("ReasonMcmsKey") != m.end() && !m["ReasonMcmsKey"].empty()) {
      reasonMcmsKey = make_shared<string>(boost::any_cast<string>(m["ReasonMcmsKey"]));
    }
    if (m.find("UpstreamErrorDetail") != m.end() && !m["UpstreamErrorDetail"].empty()) {
      upstreamErrorDetail = make_shared<boost::any>(boost::any_cast<boost::any>(m["UpstreamErrorDetail"]));
    }
  }


  virtual ~DescribeProjectComponentsResponseBodyDataReverseStoreListErrorDetails() = default;
};
class DescribeProjectComponentsResponseBodyDataReverseStoreList : public Darabonba::Model {
public:
  shared_ptr<string> beginCheckpoint{};
  shared_ptr<long> conn{};
  shared_ptr<long> delay{};
  shared_ptr<string> endCheckpoint{};
  shared_ptr<string> errMsg{};
  shared_ptr<vector<DescribeProjectComponentsResponseBodyDataReverseStoreListErrorDetails>> errorDetails{};
  shared_ptr<long> gmt{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> gmtModified{};
  shared_ptr<string> ip{};
  shared_ptr<long> latelyHeartbeatTimeSec{};
  shared_ptr<string> name{};
  shared_ptr<long> port{};
  shared_ptr<string> region{};
  shared_ptr<string> status{};
  shared_ptr<long> storePort{};
  shared_ptr<string> subtopic{};
  shared_ptr<bool> toSwitch{};
  shared_ptr<string> topic{};
  shared_ptr<long> tps{};

  DescribeProjectComponentsResponseBodyDataReverseStoreList() {}

  explicit DescribeProjectComponentsResponseBodyDataReverseStoreList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (beginCheckpoint) {
      res["BeginCheckpoint"] = boost::any(*beginCheckpoint);
    }
    if (conn) {
      res["Conn"] = boost::any(*conn);
    }
    if (delay) {
      res["Delay"] = boost::any(*delay);
    }
    if (endCheckpoint) {
      res["EndCheckpoint"] = boost::any(*endCheckpoint);
    }
    if (errMsg) {
      res["ErrMsg"] = boost::any(*errMsg);
    }
    if (errorDetails) {
      vector<boost::any> temp1;
      for(auto item1:*errorDetails){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ErrorDetails"] = boost::any(temp1);
    }
    if (gmt) {
      res["Gmt"] = boost::any(*gmt);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (ip) {
      res["Ip"] = boost::any(*ip);
    }
    if (latelyHeartbeatTimeSec) {
      res["LatelyHeartbeatTimeSec"] = boost::any(*latelyHeartbeatTimeSec);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (storePort) {
      res["StorePort"] = boost::any(*storePort);
    }
    if (subtopic) {
      res["Subtopic"] = boost::any(*subtopic);
    }
    if (toSwitch) {
      res["ToSwitch"] = boost::any(*toSwitch);
    }
    if (topic) {
      res["Topic"] = boost::any(*topic);
    }
    if (tps) {
      res["Tps"] = boost::any(*tps);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BeginCheckpoint") != m.end() && !m["BeginCheckpoint"].empty()) {
      beginCheckpoint = make_shared<string>(boost::any_cast<string>(m["BeginCheckpoint"]));
    }
    if (m.find("Conn") != m.end() && !m["Conn"].empty()) {
      conn = make_shared<long>(boost::any_cast<long>(m["Conn"]));
    }
    if (m.find("Delay") != m.end() && !m["Delay"].empty()) {
      delay = make_shared<long>(boost::any_cast<long>(m["Delay"]));
    }
    if (m.find("EndCheckpoint") != m.end() && !m["EndCheckpoint"].empty()) {
      endCheckpoint = make_shared<string>(boost::any_cast<string>(m["EndCheckpoint"]));
    }
    if (m.find("ErrMsg") != m.end() && !m["ErrMsg"].empty()) {
      errMsg = make_shared<string>(boost::any_cast<string>(m["ErrMsg"]));
    }
    if (m.find("ErrorDetails") != m.end() && !m["ErrorDetails"].empty()) {
      if (typeid(vector<boost::any>) == m["ErrorDetails"].type()) {
        vector<DescribeProjectComponentsResponseBodyDataReverseStoreListErrorDetails> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ErrorDetails"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeProjectComponentsResponseBodyDataReverseStoreListErrorDetails model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        errorDetails = make_shared<vector<DescribeProjectComponentsResponseBodyDataReverseStoreListErrorDetails>>(expect1);
      }
    }
    if (m.find("Gmt") != m.end() && !m["Gmt"].empty()) {
      gmt = make_shared<long>(boost::any_cast<long>(m["Gmt"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["GmtCreate"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<string>(boost::any_cast<string>(m["GmtModified"]));
    }
    if (m.find("Ip") != m.end() && !m["Ip"].empty()) {
      ip = make_shared<string>(boost::any_cast<string>(m["Ip"]));
    }
    if (m.find("LatelyHeartbeatTimeSec") != m.end() && !m["LatelyHeartbeatTimeSec"].empty()) {
      latelyHeartbeatTimeSec = make_shared<long>(boost::any_cast<long>(m["LatelyHeartbeatTimeSec"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<long>(boost::any_cast<long>(m["Port"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("StorePort") != m.end() && !m["StorePort"].empty()) {
      storePort = make_shared<long>(boost::any_cast<long>(m["StorePort"]));
    }
    if (m.find("Subtopic") != m.end() && !m["Subtopic"].empty()) {
      subtopic = make_shared<string>(boost::any_cast<string>(m["Subtopic"]));
    }
    if (m.find("ToSwitch") != m.end() && !m["ToSwitch"].empty()) {
      toSwitch = make_shared<bool>(boost::any_cast<bool>(m["ToSwitch"]));
    }
    if (m.find("Topic") != m.end() && !m["Topic"].empty()) {
      topic = make_shared<string>(boost::any_cast<string>(m["Topic"]));
    }
    if (m.find("Tps") != m.end() && !m["Tps"].empty()) {
      tps = make_shared<long>(boost::any_cast<long>(m["Tps"]));
    }
  }


  virtual ~DescribeProjectComponentsResponseBodyDataReverseStoreList() = default;
};
class DescribeProjectComponentsResponseBodyDataStoreListErrorDetails : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<map<string, boost::any>> extraContext{};
  shared_ptr<string> level{};
  shared_ptr<string> message{};
  shared_ptr<map<string, string>> messageMcmsContext{};
  shared_ptr<string> messageMcmsKey{};
  shared_ptr<string> proposal{};
  shared_ptr<map<string, string>> proposalMcmsContext{};
  shared_ptr<string> proposalMcmsKey{};
  shared_ptr<string> reason{};
  shared_ptr<map<string, string>> reasonMcmsContext{};
  shared_ptr<string> reasonMcmsKey{};
  shared_ptr<boost::any> upstreamErrorDetail{};

  DescribeProjectComponentsResponseBodyDataStoreListErrorDetails() {}

  explicit DescribeProjectComponentsResponseBodyDataStoreListErrorDetails(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (extraContext) {
      res["ExtraContext"] = boost::any(*extraContext);
    }
    if (level) {
      res["Level"] = boost::any(*level);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (messageMcmsContext) {
      res["MessageMcmsContext"] = boost::any(*messageMcmsContext);
    }
    if (messageMcmsKey) {
      res["MessageMcmsKey"] = boost::any(*messageMcmsKey);
    }
    if (proposal) {
      res["Proposal"] = boost::any(*proposal);
    }
    if (proposalMcmsContext) {
      res["ProposalMcmsContext"] = boost::any(*proposalMcmsContext);
    }
    if (proposalMcmsKey) {
      res["ProposalMcmsKey"] = boost::any(*proposalMcmsKey);
    }
    if (reason) {
      res["Reason"] = boost::any(*reason);
    }
    if (reasonMcmsContext) {
      res["ReasonMcmsContext"] = boost::any(*reasonMcmsContext);
    }
    if (reasonMcmsKey) {
      res["ReasonMcmsKey"] = boost::any(*reasonMcmsKey);
    }
    if (upstreamErrorDetail) {
      res["UpstreamErrorDetail"] = boost::any(*upstreamErrorDetail);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ExtraContext") != m.end() && !m["ExtraContext"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["ExtraContext"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      extraContext = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<string>(boost::any_cast<string>(m["Level"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("MessageMcmsContext") != m.end() && !m["MessageMcmsContext"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["MessageMcmsContext"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      messageMcmsContext = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("MessageMcmsKey") != m.end() && !m["MessageMcmsKey"].empty()) {
      messageMcmsKey = make_shared<string>(boost::any_cast<string>(m["MessageMcmsKey"]));
    }
    if (m.find("Proposal") != m.end() && !m["Proposal"].empty()) {
      proposal = make_shared<string>(boost::any_cast<string>(m["Proposal"]));
    }
    if (m.find("ProposalMcmsContext") != m.end() && !m["ProposalMcmsContext"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["ProposalMcmsContext"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      proposalMcmsContext = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("ProposalMcmsKey") != m.end() && !m["ProposalMcmsKey"].empty()) {
      proposalMcmsKey = make_shared<string>(boost::any_cast<string>(m["ProposalMcmsKey"]));
    }
    if (m.find("Reason") != m.end() && !m["Reason"].empty()) {
      reason = make_shared<string>(boost::any_cast<string>(m["Reason"]));
    }
    if (m.find("ReasonMcmsContext") != m.end() && !m["ReasonMcmsContext"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["ReasonMcmsContext"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      reasonMcmsContext = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("ReasonMcmsKey") != m.end() && !m["ReasonMcmsKey"].empty()) {
      reasonMcmsKey = make_shared<string>(boost::any_cast<string>(m["ReasonMcmsKey"]));
    }
    if (m.find("UpstreamErrorDetail") != m.end() && !m["UpstreamErrorDetail"].empty()) {
      upstreamErrorDetail = make_shared<boost::any>(boost::any_cast<boost::any>(m["UpstreamErrorDetail"]));
    }
  }


  virtual ~DescribeProjectComponentsResponseBodyDataStoreListErrorDetails() = default;
};
class DescribeProjectComponentsResponseBodyDataStoreList : public Darabonba::Model {
public:
  shared_ptr<string> beginCheckpoint{};
  shared_ptr<long> conn{};
  shared_ptr<long> delay{};
  shared_ptr<string> endCheckpoint{};
  shared_ptr<string> errMsg{};
  shared_ptr<vector<DescribeProjectComponentsResponseBodyDataStoreListErrorDetails>> errorDetails{};
  shared_ptr<long> gmt{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> gmtModified{};
  shared_ptr<string> ip{};
  shared_ptr<long> latelyHeartbeatTimeSec{};
  shared_ptr<string> name{};
  shared_ptr<long> port{};
  shared_ptr<string> region{};
  shared_ptr<string> status{};
  shared_ptr<long> storePort{};
  shared_ptr<string> subtopic{};
  shared_ptr<bool> toSwitch{};
  shared_ptr<string> topic{};
  shared_ptr<long> tps{};

  DescribeProjectComponentsResponseBodyDataStoreList() {}

  explicit DescribeProjectComponentsResponseBodyDataStoreList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (beginCheckpoint) {
      res["BeginCheckpoint"] = boost::any(*beginCheckpoint);
    }
    if (conn) {
      res["Conn"] = boost::any(*conn);
    }
    if (delay) {
      res["Delay"] = boost::any(*delay);
    }
    if (endCheckpoint) {
      res["EndCheckpoint"] = boost::any(*endCheckpoint);
    }
    if (errMsg) {
      res["ErrMsg"] = boost::any(*errMsg);
    }
    if (errorDetails) {
      vector<boost::any> temp1;
      for(auto item1:*errorDetails){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ErrorDetails"] = boost::any(temp1);
    }
    if (gmt) {
      res["Gmt"] = boost::any(*gmt);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (ip) {
      res["Ip"] = boost::any(*ip);
    }
    if (latelyHeartbeatTimeSec) {
      res["LatelyHeartbeatTimeSec"] = boost::any(*latelyHeartbeatTimeSec);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (storePort) {
      res["StorePort"] = boost::any(*storePort);
    }
    if (subtopic) {
      res["Subtopic"] = boost::any(*subtopic);
    }
    if (toSwitch) {
      res["ToSwitch"] = boost::any(*toSwitch);
    }
    if (topic) {
      res["Topic"] = boost::any(*topic);
    }
    if (tps) {
      res["Tps"] = boost::any(*tps);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BeginCheckpoint") != m.end() && !m["BeginCheckpoint"].empty()) {
      beginCheckpoint = make_shared<string>(boost::any_cast<string>(m["BeginCheckpoint"]));
    }
    if (m.find("Conn") != m.end() && !m["Conn"].empty()) {
      conn = make_shared<long>(boost::any_cast<long>(m["Conn"]));
    }
    if (m.find("Delay") != m.end() && !m["Delay"].empty()) {
      delay = make_shared<long>(boost::any_cast<long>(m["Delay"]));
    }
    if (m.find("EndCheckpoint") != m.end() && !m["EndCheckpoint"].empty()) {
      endCheckpoint = make_shared<string>(boost::any_cast<string>(m["EndCheckpoint"]));
    }
    if (m.find("ErrMsg") != m.end() && !m["ErrMsg"].empty()) {
      errMsg = make_shared<string>(boost::any_cast<string>(m["ErrMsg"]));
    }
    if (m.find("ErrorDetails") != m.end() && !m["ErrorDetails"].empty()) {
      if (typeid(vector<boost::any>) == m["ErrorDetails"].type()) {
        vector<DescribeProjectComponentsResponseBodyDataStoreListErrorDetails> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ErrorDetails"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeProjectComponentsResponseBodyDataStoreListErrorDetails model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        errorDetails = make_shared<vector<DescribeProjectComponentsResponseBodyDataStoreListErrorDetails>>(expect1);
      }
    }
    if (m.find("Gmt") != m.end() && !m["Gmt"].empty()) {
      gmt = make_shared<long>(boost::any_cast<long>(m["Gmt"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["GmtCreate"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<string>(boost::any_cast<string>(m["GmtModified"]));
    }
    if (m.find("Ip") != m.end() && !m["Ip"].empty()) {
      ip = make_shared<string>(boost::any_cast<string>(m["Ip"]));
    }
    if (m.find("LatelyHeartbeatTimeSec") != m.end() && !m["LatelyHeartbeatTimeSec"].empty()) {
      latelyHeartbeatTimeSec = make_shared<long>(boost::any_cast<long>(m["LatelyHeartbeatTimeSec"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<long>(boost::any_cast<long>(m["Port"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("StorePort") != m.end() && !m["StorePort"].empty()) {
      storePort = make_shared<long>(boost::any_cast<long>(m["StorePort"]));
    }
    if (m.find("Subtopic") != m.end() && !m["Subtopic"].empty()) {
      subtopic = make_shared<string>(boost::any_cast<string>(m["Subtopic"]));
    }
    if (m.find("ToSwitch") != m.end() && !m["ToSwitch"].empty()) {
      toSwitch = make_shared<bool>(boost::any_cast<bool>(m["ToSwitch"]));
    }
    if (m.find("Topic") != m.end() && !m["Topic"].empty()) {
      topic = make_shared<string>(boost::any_cast<string>(m["Topic"]));
    }
    if (m.find("Tps") != m.end() && !m["Tps"].empty()) {
      tps = make_shared<long>(boost::any_cast<long>(m["Tps"]));
    }
  }


  virtual ~DescribeProjectComponentsResponseBodyDataStoreList() = default;
};
class DescribeProjectComponentsResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeProjectComponentsResponseBodyDataFullImportComponents>> fullImportComponents{};
  shared_ptr<vector<DescribeProjectComponentsResponseBodyDataFullVerifyComponents>> fullVerifyComponents{};
  shared_ptr<vector<DescribeProjectComponentsResponseBodyDataIncrSyncComponents>> incrSyncComponents{};
  shared_ptr<vector<DescribeProjectComponentsResponseBodyDataReverseIncrSyncComponents>> reverseIncrSyncComponents{};
  shared_ptr<vector<DescribeProjectComponentsResponseBodyDataReverseStoreList>> reverseStoreList{};
  shared_ptr<vector<DescribeProjectComponentsResponseBodyDataStoreList>> storeList{};

  DescribeProjectComponentsResponseBodyData() {}

  explicit DescribeProjectComponentsResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fullImportComponents) {
      vector<boost::any> temp1;
      for(auto item1:*fullImportComponents){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["FullImportComponents"] = boost::any(temp1);
    }
    if (fullVerifyComponents) {
      vector<boost::any> temp1;
      for(auto item1:*fullVerifyComponents){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["FullVerifyComponents"] = boost::any(temp1);
    }
    if (incrSyncComponents) {
      vector<boost::any> temp1;
      for(auto item1:*incrSyncComponents){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["IncrSyncComponents"] = boost::any(temp1);
    }
    if (reverseIncrSyncComponents) {
      vector<boost::any> temp1;
      for(auto item1:*reverseIncrSyncComponents){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ReverseIncrSyncComponents"] = boost::any(temp1);
    }
    if (reverseStoreList) {
      vector<boost::any> temp1;
      for(auto item1:*reverseStoreList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ReverseStoreList"] = boost::any(temp1);
    }
    if (storeList) {
      vector<boost::any> temp1;
      for(auto item1:*storeList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["StoreList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FullImportComponents") != m.end() && !m["FullImportComponents"].empty()) {
      if (typeid(vector<boost::any>) == m["FullImportComponents"].type()) {
        vector<DescribeProjectComponentsResponseBodyDataFullImportComponents> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["FullImportComponents"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeProjectComponentsResponseBodyDataFullImportComponents model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        fullImportComponents = make_shared<vector<DescribeProjectComponentsResponseBodyDataFullImportComponents>>(expect1);
      }
    }
    if (m.find("FullVerifyComponents") != m.end() && !m["FullVerifyComponents"].empty()) {
      if (typeid(vector<boost::any>) == m["FullVerifyComponents"].type()) {
        vector<DescribeProjectComponentsResponseBodyDataFullVerifyComponents> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["FullVerifyComponents"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeProjectComponentsResponseBodyDataFullVerifyComponents model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        fullVerifyComponents = make_shared<vector<DescribeProjectComponentsResponseBodyDataFullVerifyComponents>>(expect1);
      }
    }
    if (m.find("IncrSyncComponents") != m.end() && !m["IncrSyncComponents"].empty()) {
      if (typeid(vector<boost::any>) == m["IncrSyncComponents"].type()) {
        vector<DescribeProjectComponentsResponseBodyDataIncrSyncComponents> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["IncrSyncComponents"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeProjectComponentsResponseBodyDataIncrSyncComponents model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        incrSyncComponents = make_shared<vector<DescribeProjectComponentsResponseBodyDataIncrSyncComponents>>(expect1);
      }
    }
    if (m.find("ReverseIncrSyncComponents") != m.end() && !m["ReverseIncrSyncComponents"].empty()) {
      if (typeid(vector<boost::any>) == m["ReverseIncrSyncComponents"].type()) {
        vector<DescribeProjectComponentsResponseBodyDataReverseIncrSyncComponents> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ReverseIncrSyncComponents"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeProjectComponentsResponseBodyDataReverseIncrSyncComponents model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        reverseIncrSyncComponents = make_shared<vector<DescribeProjectComponentsResponseBodyDataReverseIncrSyncComponents>>(expect1);
      }
    }
    if (m.find("ReverseStoreList") != m.end() && !m["ReverseStoreList"].empty()) {
      if (typeid(vector<boost::any>) == m["ReverseStoreList"].type()) {
        vector<DescribeProjectComponentsResponseBodyDataReverseStoreList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ReverseStoreList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeProjectComponentsResponseBodyDataReverseStoreList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        reverseStoreList = make_shared<vector<DescribeProjectComponentsResponseBodyDataReverseStoreList>>(expect1);
      }
    }
    if (m.find("StoreList") != m.end() && !m["StoreList"].empty()) {
      if (typeid(vector<boost::any>) == m["StoreList"].type()) {
        vector<DescribeProjectComponentsResponseBodyDataStoreList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["StoreList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeProjectComponentsResponseBodyDataStoreList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        storeList = make_shared<vector<DescribeProjectComponentsResponseBodyDataStoreList>>(expect1);
      }
    }
  }


  virtual ~DescribeProjectComponentsResponseBodyData() = default;
};
class DescribeProjectComponentsResponseBodyErrorDetail : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<map<string, boost::any>> extraContext{};
  shared_ptr<string> level{};
  shared_ptr<string> message{};
  shared_ptr<map<string, string>> messageMcmsContext{};
  shared_ptr<string> messageMcmsKey{};
  shared_ptr<string> proposal{};
  shared_ptr<map<string, string>> proposalMcmsContext{};
  shared_ptr<string> proposalMcmsKey{};
  shared_ptr<string> reason{};
  shared_ptr<map<string, string>> reasonMcmsContext{};
  shared_ptr<string> reasonMcmsKey{};
  shared_ptr<boost::any> upstreamErrorDetail{};

  DescribeProjectComponentsResponseBodyErrorDetail() {}

  explicit DescribeProjectComponentsResponseBodyErrorDetail(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (extraContext) {
      res["ExtraContext"] = boost::any(*extraContext);
    }
    if (level) {
      res["Level"] = boost::any(*level);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (messageMcmsContext) {
      res["MessageMcmsContext"] = boost::any(*messageMcmsContext);
    }
    if (messageMcmsKey) {
      res["MessageMcmsKey"] = boost::any(*messageMcmsKey);
    }
    if (proposal) {
      res["Proposal"] = boost::any(*proposal);
    }
    if (proposalMcmsContext) {
      res["ProposalMcmsContext"] = boost::any(*proposalMcmsContext);
    }
    if (proposalMcmsKey) {
      res["ProposalMcmsKey"] = boost::any(*proposalMcmsKey);
    }
    if (reason) {
      res["Reason"] = boost::any(*reason);
    }
    if (reasonMcmsContext) {
      res["ReasonMcmsContext"] = boost::any(*reasonMcmsContext);
    }
    if (reasonMcmsKey) {
      res["ReasonMcmsKey"] = boost::any(*reasonMcmsKey);
    }
    if (upstreamErrorDetail) {
      res["UpstreamErrorDetail"] = boost::any(*upstreamErrorDetail);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ExtraContext") != m.end() && !m["ExtraContext"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["ExtraContext"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      extraContext = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<string>(boost::any_cast<string>(m["Level"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("MessageMcmsContext") != m.end() && !m["MessageMcmsContext"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["MessageMcmsContext"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      messageMcmsContext = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("MessageMcmsKey") != m.end() && !m["MessageMcmsKey"].empty()) {
      messageMcmsKey = make_shared<string>(boost::any_cast<string>(m["MessageMcmsKey"]));
    }
    if (m.find("Proposal") != m.end() && !m["Proposal"].empty()) {
      proposal = make_shared<string>(boost::any_cast<string>(m["Proposal"]));
    }
    if (m.find("ProposalMcmsContext") != m.end() && !m["ProposalMcmsContext"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["ProposalMcmsContext"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      proposalMcmsContext = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("ProposalMcmsKey") != m.end() && !m["ProposalMcmsKey"].empty()) {
      proposalMcmsKey = make_shared<string>(boost::any_cast<string>(m["ProposalMcmsKey"]));
    }
    if (m.find("Reason") != m.end() && !m["Reason"].empty()) {
      reason = make_shared<string>(boost::any_cast<string>(m["Reason"]));
    }
    if (m.find("ReasonMcmsContext") != m.end() && !m["ReasonMcmsContext"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["ReasonMcmsContext"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      reasonMcmsContext = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("ReasonMcmsKey") != m.end() && !m["ReasonMcmsKey"].empty()) {
      reasonMcmsKey = make_shared<string>(boost::any_cast<string>(m["ReasonMcmsKey"]));
    }
    if (m.find("UpstreamErrorDetail") != m.end() && !m["UpstreamErrorDetail"].empty()) {
      upstreamErrorDetail = make_shared<boost::any>(boost::any_cast<boost::any>(m["UpstreamErrorDetail"]));
    }
  }


  virtual ~DescribeProjectComponentsResponseBodyErrorDetail() = default;
};
class DescribeProjectComponentsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> advice{};
  shared_ptr<string> code{};
  shared_ptr<string> cost{};
  shared_ptr<DescribeProjectComponentsResponseBodyData> data{};
  shared_ptr<DescribeProjectComponentsResponseBodyErrorDetail> errorDetail{};
  shared_ptr<string> message{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<long> totalCount{};

  DescribeProjectComponentsResponseBody() {}

  explicit DescribeProjectComponentsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (advice) {
      res["Advice"] = boost::any(*advice);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (cost) {
      res["Cost"] = boost::any(*cost);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorDetail) {
      res["ErrorDetail"] = errorDetail ? boost::any(errorDetail->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Advice") != m.end() && !m["Advice"].empty()) {
      advice = make_shared<string>(boost::any_cast<string>(m["Advice"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Cost") != m.end() && !m["Cost"].empty()) {
      cost = make_shared<string>(boost::any_cast<string>(m["Cost"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        DescribeProjectComponentsResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<DescribeProjectComponentsResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorDetail") != m.end() && !m["ErrorDetail"].empty()) {
      if (typeid(map<string, boost::any>) == m["ErrorDetail"].type()) {
        DescribeProjectComponentsResponseBodyErrorDetail model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ErrorDetail"]));
        errorDetail = make_shared<DescribeProjectComponentsResponseBodyErrorDetail>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeProjectComponentsResponseBody() = default;
};
class DescribeProjectComponentsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeProjectComponentsResponseBody> body{};

  DescribeProjectComponentsResponse() {}

  explicit DescribeProjectComponentsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeProjectComponentsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeProjectComponentsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeProjectComponentsResponse() = default;
};
class DescribeProjectProgressRequest : public Darabonba::Model {
public:
  shared_ptr<string> id{};

  DescribeProjectProgressRequest() {}

  explicit DescribeProjectProgressRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
  }


  virtual ~DescribeProjectProgressRequest() = default;
};
class DescribeProjectProgressResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> alarmLevel{};
  shared_ptr<string> currentStep{};
  shared_ptr<bool> enableFullTransfer{};
  shared_ptr<bool> enableIncrSync{};
  shared_ptr<bool> enableReverseIncrTransfer{};
  shared_ptr<bool> enableStructTransfer{};
  shared_ptr<long> fullTransferProgress{};
  shared_ptr<long> incrSyncCheckpoint{};
  shared_ptr<string> projectId{};
  shared_ptr<long> reverseIncrTransferCheckpoint{};
  shared_ptr<string> status{};
  shared_ptr<long> structTransferProgress{};

  DescribeProjectProgressResponseBodyData() {}

  explicit DescribeProjectProgressResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alarmLevel) {
      res["AlarmLevel"] = boost::any(*alarmLevel);
    }
    if (currentStep) {
      res["CurrentStep"] = boost::any(*currentStep);
    }
    if (enableFullTransfer) {
      res["EnableFullTransfer"] = boost::any(*enableFullTransfer);
    }
    if (enableIncrSync) {
      res["EnableIncrSync"] = boost::any(*enableIncrSync);
    }
    if (enableReverseIncrTransfer) {
      res["EnableReverseIncrTransfer"] = boost::any(*enableReverseIncrTransfer);
    }
    if (enableStructTransfer) {
      res["EnableStructTransfer"] = boost::any(*enableStructTransfer);
    }
    if (fullTransferProgress) {
      res["FullTransferProgress"] = boost::any(*fullTransferProgress);
    }
    if (incrSyncCheckpoint) {
      res["IncrSyncCheckpoint"] = boost::any(*incrSyncCheckpoint);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (reverseIncrTransferCheckpoint) {
      res["ReverseIncrTransferCheckpoint"] = boost::any(*reverseIncrTransferCheckpoint);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (structTransferProgress) {
      res["StructTransferProgress"] = boost::any(*structTransferProgress);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlarmLevel") != m.end() && !m["AlarmLevel"].empty()) {
      alarmLevel = make_shared<string>(boost::any_cast<string>(m["AlarmLevel"]));
    }
    if (m.find("CurrentStep") != m.end() && !m["CurrentStep"].empty()) {
      currentStep = make_shared<string>(boost::any_cast<string>(m["CurrentStep"]));
    }
    if (m.find("EnableFullTransfer") != m.end() && !m["EnableFullTransfer"].empty()) {
      enableFullTransfer = make_shared<bool>(boost::any_cast<bool>(m["EnableFullTransfer"]));
    }
    if (m.find("EnableIncrSync") != m.end() && !m["EnableIncrSync"].empty()) {
      enableIncrSync = make_shared<bool>(boost::any_cast<bool>(m["EnableIncrSync"]));
    }
    if (m.find("EnableReverseIncrTransfer") != m.end() && !m["EnableReverseIncrTransfer"].empty()) {
      enableReverseIncrTransfer = make_shared<bool>(boost::any_cast<bool>(m["EnableReverseIncrTransfer"]));
    }
    if (m.find("EnableStructTransfer") != m.end() && !m["EnableStructTransfer"].empty()) {
      enableStructTransfer = make_shared<bool>(boost::any_cast<bool>(m["EnableStructTransfer"]));
    }
    if (m.find("FullTransferProgress") != m.end() && !m["FullTransferProgress"].empty()) {
      fullTransferProgress = make_shared<long>(boost::any_cast<long>(m["FullTransferProgress"]));
    }
    if (m.find("IncrSyncCheckpoint") != m.end() && !m["IncrSyncCheckpoint"].empty()) {
      incrSyncCheckpoint = make_shared<long>(boost::any_cast<long>(m["IncrSyncCheckpoint"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("ReverseIncrTransferCheckpoint") != m.end() && !m["ReverseIncrTransferCheckpoint"].empty()) {
      reverseIncrTransferCheckpoint = make_shared<long>(boost::any_cast<long>(m["ReverseIncrTransferCheckpoint"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("StructTransferProgress") != m.end() && !m["StructTransferProgress"].empty()) {
      structTransferProgress = make_shared<long>(boost::any_cast<long>(m["StructTransferProgress"]));
    }
  }


  virtual ~DescribeProjectProgressResponseBodyData() = default;
};
class DescribeProjectProgressResponseBodyErrorDetail : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<map<string, boost::any>> extraContext{};
  shared_ptr<string> level{};
  shared_ptr<string> message{};
  shared_ptr<map<string, string>> messageMcmsContext{};
  shared_ptr<string> messageMcmsKey{};
  shared_ptr<string> proposal{};
  shared_ptr<map<string, string>> proposalMcmsContext{};
  shared_ptr<string> proposalMcmsKey{};
  shared_ptr<string> reason{};
  shared_ptr<map<string, string>> reasonMcmsContext{};
  shared_ptr<string> reasonMcmsKey{};
  shared_ptr<boost::any> upstreamErrorDetail{};

  DescribeProjectProgressResponseBodyErrorDetail() {}

  explicit DescribeProjectProgressResponseBodyErrorDetail(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (extraContext) {
      res["ExtraContext"] = boost::any(*extraContext);
    }
    if (level) {
      res["Level"] = boost::any(*level);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (messageMcmsContext) {
      res["MessageMcmsContext"] = boost::any(*messageMcmsContext);
    }
    if (messageMcmsKey) {
      res["MessageMcmsKey"] = boost::any(*messageMcmsKey);
    }
    if (proposal) {
      res["Proposal"] = boost::any(*proposal);
    }
    if (proposalMcmsContext) {
      res["ProposalMcmsContext"] = boost::any(*proposalMcmsContext);
    }
    if (proposalMcmsKey) {
      res["ProposalMcmsKey"] = boost::any(*proposalMcmsKey);
    }
    if (reason) {
      res["Reason"] = boost::any(*reason);
    }
    if (reasonMcmsContext) {
      res["ReasonMcmsContext"] = boost::any(*reasonMcmsContext);
    }
    if (reasonMcmsKey) {
      res["ReasonMcmsKey"] = boost::any(*reasonMcmsKey);
    }
    if (upstreamErrorDetail) {
      res["UpstreamErrorDetail"] = boost::any(*upstreamErrorDetail);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ExtraContext") != m.end() && !m["ExtraContext"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["ExtraContext"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      extraContext = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<string>(boost::any_cast<string>(m["Level"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("MessageMcmsContext") != m.end() && !m["MessageMcmsContext"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["MessageMcmsContext"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      messageMcmsContext = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("MessageMcmsKey") != m.end() && !m["MessageMcmsKey"].empty()) {
      messageMcmsKey = make_shared<string>(boost::any_cast<string>(m["MessageMcmsKey"]));
    }
    if (m.find("Proposal") != m.end() && !m["Proposal"].empty()) {
      proposal = make_shared<string>(boost::any_cast<string>(m["Proposal"]));
    }
    if (m.find("ProposalMcmsContext") != m.end() && !m["ProposalMcmsContext"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["ProposalMcmsContext"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      proposalMcmsContext = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("ProposalMcmsKey") != m.end() && !m["ProposalMcmsKey"].empty()) {
      proposalMcmsKey = make_shared<string>(boost::any_cast<string>(m["ProposalMcmsKey"]));
    }
    if (m.find("Reason") != m.end() && !m["Reason"].empty()) {
      reason = make_shared<string>(boost::any_cast<string>(m["Reason"]));
    }
    if (m.find("ReasonMcmsContext") != m.end() && !m["ReasonMcmsContext"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["ReasonMcmsContext"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      reasonMcmsContext = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("ReasonMcmsKey") != m.end() && !m["ReasonMcmsKey"].empty()) {
      reasonMcmsKey = make_shared<string>(boost::any_cast<string>(m["ReasonMcmsKey"]));
    }
    if (m.find("UpstreamErrorDetail") != m.end() && !m["UpstreamErrorDetail"].empty()) {
      upstreamErrorDetail = make_shared<boost::any>(boost::any_cast<boost::any>(m["UpstreamErrorDetail"]));
    }
  }


  virtual ~DescribeProjectProgressResponseBodyErrorDetail() = default;
};
class DescribeProjectProgressResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> advice{};
  shared_ptr<string> code{};
  shared_ptr<string> cost{};
  shared_ptr<DescribeProjectProgressResponseBodyData> data{};
  shared_ptr<DescribeProjectProgressResponseBodyErrorDetail> errorDetail{};
  shared_ptr<string> message{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<long> totalCount{};

  DescribeProjectProgressResponseBody() {}

  explicit DescribeProjectProgressResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (advice) {
      res["Advice"] = boost::any(*advice);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (cost) {
      res["Cost"] = boost::any(*cost);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorDetail) {
      res["ErrorDetail"] = errorDetail ? boost::any(errorDetail->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Advice") != m.end() && !m["Advice"].empty()) {
      advice = make_shared<string>(boost::any_cast<string>(m["Advice"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Cost") != m.end() && !m["Cost"].empty()) {
      cost = make_shared<string>(boost::any_cast<string>(m["Cost"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        DescribeProjectProgressResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<DescribeProjectProgressResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorDetail") != m.end() && !m["ErrorDetail"].empty()) {
      if (typeid(map<string, boost::any>) == m["ErrorDetail"].type()) {
        DescribeProjectProgressResponseBodyErrorDetail model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ErrorDetail"]));
        errorDetail = make_shared<DescribeProjectProgressResponseBodyErrorDetail>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeProjectProgressResponseBody() = default;
};
class DescribeProjectProgressResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeProjectProgressResponseBody> body{};

  DescribeProjectProgressResponse() {}

  explicit DescribeProjectProgressResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeProjectProgressResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeProjectProgressResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeProjectProgressResponse() = default;
};
class DescribeProjectStepMetricRequest : public Darabonba::Model {
public:
  shared_ptr<string> aggregator{};
  shared_ptr<long> beginTimestamp{};
  shared_ptr<long> endTimestamp{};
  shared_ptr<long> maxPointNum{};
  shared_ptr<string> metricType{};
  shared_ptr<string> projectId{};
  shared_ptr<string> stepName{};

  DescribeProjectStepMetricRequest() {}

  explicit DescribeProjectStepMetricRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aggregator) {
      res["Aggregator"] = boost::any(*aggregator);
    }
    if (beginTimestamp) {
      res["BeginTimestamp"] = boost::any(*beginTimestamp);
    }
    if (endTimestamp) {
      res["EndTimestamp"] = boost::any(*endTimestamp);
    }
    if (maxPointNum) {
      res["MaxPointNum"] = boost::any(*maxPointNum);
    }
    if (metricType) {
      res["MetricType"] = boost::any(*metricType);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (stepName) {
      res["StepName"] = boost::any(*stepName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Aggregator") != m.end() && !m["Aggregator"].empty()) {
      aggregator = make_shared<string>(boost::any_cast<string>(m["Aggregator"]));
    }
    if (m.find("BeginTimestamp") != m.end() && !m["BeginTimestamp"].empty()) {
      beginTimestamp = make_shared<long>(boost::any_cast<long>(m["BeginTimestamp"]));
    }
    if (m.find("EndTimestamp") != m.end() && !m["EndTimestamp"].empty()) {
      endTimestamp = make_shared<long>(boost::any_cast<long>(m["EndTimestamp"]));
    }
    if (m.find("MaxPointNum") != m.end() && !m["MaxPointNum"].empty()) {
      maxPointNum = make_shared<long>(boost::any_cast<long>(m["MaxPointNum"]));
    }
    if (m.find("MetricType") != m.end() && !m["MetricType"].empty()) {
      metricType = make_shared<string>(boost::any_cast<string>(m["MetricType"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("StepName") != m.end() && !m["StepName"].empty()) {
      stepName = make_shared<string>(boost::any_cast<string>(m["StepName"]));
    }
  }


  virtual ~DescribeProjectStepMetricRequest() = default;
};
class DescribeProjectStepMetricResponseBodyDataMetricsDataPoints : public Darabonba::Model {
public:
  shared_ptr<long> timestamp{};
  shared_ptr<double> value{};

  DescribeProjectStepMetricResponseBodyDataMetricsDataPoints() {}

  explicit DescribeProjectStepMetricResponseBodyDataMetricsDataPoints(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (timestamp) {
      res["Timestamp"] = boost::any(*timestamp);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Timestamp") != m.end() && !m["Timestamp"].empty()) {
      timestamp = make_shared<long>(boost::any_cast<long>(m["Timestamp"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<double>(boost::any_cast<double>(m["Value"]));
    }
  }


  virtual ~DescribeProjectStepMetricResponseBodyDataMetricsDataPoints() = default;
};
class DescribeProjectStepMetricResponseBodyDataMetrics : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeProjectStepMetricResponseBodyDataMetricsDataPoints>> dataPoints{};
  shared_ptr<string> name{};
  shared_ptr<map<string, string>> tags{};

  DescribeProjectStepMetricResponseBodyDataMetrics() {}

  explicit DescribeProjectStepMetricResponseBodyDataMetrics(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataPoints) {
      vector<boost::any> temp1;
      for(auto item1:*dataPoints){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DataPoints"] = boost::any(temp1);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (tags) {
      res["Tags"] = boost::any(*tags);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DataPoints") != m.end() && !m["DataPoints"].empty()) {
      if (typeid(vector<boost::any>) == m["DataPoints"].type()) {
        vector<DescribeProjectStepMetricResponseBodyDataMetricsDataPoints> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DataPoints"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeProjectStepMetricResponseBodyDataMetricsDataPoints model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dataPoints = make_shared<vector<DescribeProjectStepMetricResponseBodyDataMetricsDataPoints>>(expect1);
      }
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["Tags"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      tags = make_shared<map<string, string>>(toMap1);
    }
  }


  virtual ~DescribeProjectStepMetricResponseBodyDataMetrics() = default;
};
class DescribeProjectStepMetricResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> aggregator{};
  shared_ptr<vector<DescribeProjectStepMetricResponseBodyDataMetrics>> metrics{};
  shared_ptr<long> referenceValue{};

  DescribeProjectStepMetricResponseBodyData() {}

  explicit DescribeProjectStepMetricResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aggregator) {
      res["Aggregator"] = boost::any(*aggregator);
    }
    if (metrics) {
      vector<boost::any> temp1;
      for(auto item1:*metrics){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Metrics"] = boost::any(temp1);
    }
    if (referenceValue) {
      res["ReferenceValue"] = boost::any(*referenceValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Aggregator") != m.end() && !m["Aggregator"].empty()) {
      aggregator = make_shared<string>(boost::any_cast<string>(m["Aggregator"]));
    }
    if (m.find("Metrics") != m.end() && !m["Metrics"].empty()) {
      if (typeid(vector<boost::any>) == m["Metrics"].type()) {
        vector<DescribeProjectStepMetricResponseBodyDataMetrics> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Metrics"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeProjectStepMetricResponseBodyDataMetrics model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        metrics = make_shared<vector<DescribeProjectStepMetricResponseBodyDataMetrics>>(expect1);
      }
    }
    if (m.find("ReferenceValue") != m.end() && !m["ReferenceValue"].empty()) {
      referenceValue = make_shared<long>(boost::any_cast<long>(m["ReferenceValue"]));
    }
  }


  virtual ~DescribeProjectStepMetricResponseBodyData() = default;
};
class DescribeProjectStepMetricResponseBodyErrorDetail : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<map<string, boost::any>> extraContext{};
  shared_ptr<string> level{};
  shared_ptr<string> message{};
  shared_ptr<map<string, string>> messageMcmsContext{};
  shared_ptr<string> messageMcmsKey{};
  shared_ptr<string> proposal{};
  shared_ptr<map<string, string>> proposalMcmsContext{};
  shared_ptr<string> proposalMcmsKey{};
  shared_ptr<string> reason{};
  shared_ptr<map<string, string>> reasonMcmsContext{};
  shared_ptr<string> reasonMcmsKey{};
  shared_ptr<boost::any> upstreamErrorDetail{};

  DescribeProjectStepMetricResponseBodyErrorDetail() {}

  explicit DescribeProjectStepMetricResponseBodyErrorDetail(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (extraContext) {
      res["ExtraContext"] = boost::any(*extraContext);
    }
    if (level) {
      res["Level"] = boost::any(*level);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (messageMcmsContext) {
      res["MessageMcmsContext"] = boost::any(*messageMcmsContext);
    }
    if (messageMcmsKey) {
      res["MessageMcmsKey"] = boost::any(*messageMcmsKey);
    }
    if (proposal) {
      res["Proposal"] = boost::any(*proposal);
    }
    if (proposalMcmsContext) {
      res["ProposalMcmsContext"] = boost::any(*proposalMcmsContext);
    }
    if (proposalMcmsKey) {
      res["ProposalMcmsKey"] = boost::any(*proposalMcmsKey);
    }
    if (reason) {
      res["Reason"] = boost::any(*reason);
    }
    if (reasonMcmsContext) {
      res["ReasonMcmsContext"] = boost::any(*reasonMcmsContext);
    }
    if (reasonMcmsKey) {
      res["ReasonMcmsKey"] = boost::any(*reasonMcmsKey);
    }
    if (upstreamErrorDetail) {
      res["UpstreamErrorDetail"] = boost::any(*upstreamErrorDetail);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ExtraContext") != m.end() && !m["ExtraContext"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["ExtraContext"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      extraContext = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<string>(boost::any_cast<string>(m["Level"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("MessageMcmsContext") != m.end() && !m["MessageMcmsContext"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["MessageMcmsContext"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      messageMcmsContext = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("MessageMcmsKey") != m.end() && !m["MessageMcmsKey"].empty()) {
      messageMcmsKey = make_shared<string>(boost::any_cast<string>(m["MessageMcmsKey"]));
    }
    if (m.find("Proposal") != m.end() && !m["Proposal"].empty()) {
      proposal = make_shared<string>(boost::any_cast<string>(m["Proposal"]));
    }
    if (m.find("ProposalMcmsContext") != m.end() && !m["ProposalMcmsContext"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["ProposalMcmsContext"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      proposalMcmsContext = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("ProposalMcmsKey") != m.end() && !m["ProposalMcmsKey"].empty()) {
      proposalMcmsKey = make_shared<string>(boost::any_cast<string>(m["ProposalMcmsKey"]));
    }
    if (m.find("Reason") != m.end() && !m["Reason"].empty()) {
      reason = make_shared<string>(boost::any_cast<string>(m["Reason"]));
    }
    if (m.find("ReasonMcmsContext") != m.end() && !m["ReasonMcmsContext"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["ReasonMcmsContext"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      reasonMcmsContext = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("ReasonMcmsKey") != m.end() && !m["ReasonMcmsKey"].empty()) {
      reasonMcmsKey = make_shared<string>(boost::any_cast<string>(m["ReasonMcmsKey"]));
    }
    if (m.find("UpstreamErrorDetail") != m.end() && !m["UpstreamErrorDetail"].empty()) {
      upstreamErrorDetail = make_shared<boost::any>(boost::any_cast<boost::any>(m["UpstreamErrorDetail"]));
    }
  }


  virtual ~DescribeProjectStepMetricResponseBodyErrorDetail() = default;
};
class DescribeProjectStepMetricResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> advice{};
  shared_ptr<string> code{};
  shared_ptr<string> cost{};
  shared_ptr<DescribeProjectStepMetricResponseBodyData> data{};
  shared_ptr<DescribeProjectStepMetricResponseBodyErrorDetail> errorDetail{};
  shared_ptr<string> message{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<long> totalCount{};

  DescribeProjectStepMetricResponseBody() {}

  explicit DescribeProjectStepMetricResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (advice) {
      res["Advice"] = boost::any(*advice);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (cost) {
      res["Cost"] = boost::any(*cost);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorDetail) {
      res["ErrorDetail"] = errorDetail ? boost::any(errorDetail->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Advice") != m.end() && !m["Advice"].empty()) {
      advice = make_shared<string>(boost::any_cast<string>(m["Advice"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Cost") != m.end() && !m["Cost"].empty()) {
      cost = make_shared<string>(boost::any_cast<string>(m["Cost"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        DescribeProjectStepMetricResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<DescribeProjectStepMetricResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorDetail") != m.end() && !m["ErrorDetail"].empty()) {
      if (typeid(map<string, boost::any>) == m["ErrorDetail"].type()) {
        DescribeProjectStepMetricResponseBodyErrorDetail model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ErrorDetail"]));
        errorDetail = make_shared<DescribeProjectStepMetricResponseBodyErrorDetail>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeProjectStepMetricResponseBody() = default;
};
class DescribeProjectStepMetricResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeProjectStepMetricResponseBody> body{};

  DescribeProjectStepMetricResponse() {}

  explicit DescribeProjectStepMetricResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeProjectStepMetricResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeProjectStepMetricResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeProjectStepMetricResponse() = default;
};
class DescribeProjectStepsRequest : public Darabonba::Model {
public:
  shared_ptr<string> id{};

  DescribeProjectStepsRequest() {}

  explicit DescribeProjectStepsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
  }


  virtual ~DescribeProjectStepsRequest() = default;
};
class DescribeProjectStepsResponseBodyDataExtraInfoErrorDetails : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<map<string, boost::any>> extraContext{};
  shared_ptr<string> level{};
  shared_ptr<string> message{};
  shared_ptr<map<string, string>> messageMcmsContext{};
  shared_ptr<string> messageMcmsKey{};
  shared_ptr<string> proposal{};
  shared_ptr<map<string, string>> proposalMcmsContext{};
  shared_ptr<string> proposalMcmsKey{};
  shared_ptr<string> reason{};
  shared_ptr<map<string, string>> reasonMcmsContext{};
  shared_ptr<string> reasonMcmsKey{};
  shared_ptr<boost::any> upstreamErrorDetail{};

  DescribeProjectStepsResponseBodyDataExtraInfoErrorDetails() {}

  explicit DescribeProjectStepsResponseBodyDataExtraInfoErrorDetails(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (extraContext) {
      res["ExtraContext"] = boost::any(*extraContext);
    }
    if (level) {
      res["Level"] = boost::any(*level);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (messageMcmsContext) {
      res["MessageMcmsContext"] = boost::any(*messageMcmsContext);
    }
    if (messageMcmsKey) {
      res["MessageMcmsKey"] = boost::any(*messageMcmsKey);
    }
    if (proposal) {
      res["Proposal"] = boost::any(*proposal);
    }
    if (proposalMcmsContext) {
      res["ProposalMcmsContext"] = boost::any(*proposalMcmsContext);
    }
    if (proposalMcmsKey) {
      res["ProposalMcmsKey"] = boost::any(*proposalMcmsKey);
    }
    if (reason) {
      res["Reason"] = boost::any(*reason);
    }
    if (reasonMcmsContext) {
      res["ReasonMcmsContext"] = boost::any(*reasonMcmsContext);
    }
    if (reasonMcmsKey) {
      res["ReasonMcmsKey"] = boost::any(*reasonMcmsKey);
    }
    if (upstreamErrorDetail) {
      res["UpstreamErrorDetail"] = boost::any(*upstreamErrorDetail);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ExtraContext") != m.end() && !m["ExtraContext"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["ExtraContext"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      extraContext = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<string>(boost::any_cast<string>(m["Level"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("MessageMcmsContext") != m.end() && !m["MessageMcmsContext"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["MessageMcmsContext"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      messageMcmsContext = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("MessageMcmsKey") != m.end() && !m["MessageMcmsKey"].empty()) {
      messageMcmsKey = make_shared<string>(boost::any_cast<string>(m["MessageMcmsKey"]));
    }
    if (m.find("Proposal") != m.end() && !m["Proposal"].empty()) {
      proposal = make_shared<string>(boost::any_cast<string>(m["Proposal"]));
    }
    if (m.find("ProposalMcmsContext") != m.end() && !m["ProposalMcmsContext"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["ProposalMcmsContext"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      proposalMcmsContext = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("ProposalMcmsKey") != m.end() && !m["ProposalMcmsKey"].empty()) {
      proposalMcmsKey = make_shared<string>(boost::any_cast<string>(m["ProposalMcmsKey"]));
    }
    if (m.find("Reason") != m.end() && !m["Reason"].empty()) {
      reason = make_shared<string>(boost::any_cast<string>(m["Reason"]));
    }
    if (m.find("ReasonMcmsContext") != m.end() && !m["ReasonMcmsContext"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["ReasonMcmsContext"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      reasonMcmsContext = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("ReasonMcmsKey") != m.end() && !m["ReasonMcmsKey"].empty()) {
      reasonMcmsKey = make_shared<string>(boost::any_cast<string>(m["ReasonMcmsKey"]));
    }
    if (m.find("UpstreamErrorDetail") != m.end() && !m["UpstreamErrorDetail"].empty()) {
      upstreamErrorDetail = make_shared<boost::any>(boost::any_cast<boost::any>(m["UpstreamErrorDetail"]));
    }
  }


  virtual ~DescribeProjectStepsResponseBodyDataExtraInfoErrorDetails() = default;
};
class DescribeProjectStepsResponseBodyDataExtraInfo : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<vector<DescribeProjectStepsResponseBodyDataExtraInfoErrorDetails>> errorDetails{};
  shared_ptr<string> errorMsg{};
  shared_ptr<map<string, string>> errorParam{};
  shared_ptr<string> failedTime{};

  DescribeProjectStepsResponseBodyDataExtraInfo() {}

  explicit DescribeProjectStepsResponseBodyDataExtraInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorDetails) {
      vector<boost::any> temp1;
      for(auto item1:*errorDetails){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ErrorDetails"] = boost::any(temp1);
    }
    if (errorMsg) {
      res["ErrorMsg"] = boost::any(*errorMsg);
    }
    if (errorParam) {
      res["ErrorParam"] = boost::any(*errorParam);
    }
    if (failedTime) {
      res["FailedTime"] = boost::any(*failedTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorDetails") != m.end() && !m["ErrorDetails"].empty()) {
      if (typeid(vector<boost::any>) == m["ErrorDetails"].type()) {
        vector<DescribeProjectStepsResponseBodyDataExtraInfoErrorDetails> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ErrorDetails"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeProjectStepsResponseBodyDataExtraInfoErrorDetails model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        errorDetails = make_shared<vector<DescribeProjectStepsResponseBodyDataExtraInfoErrorDetails>>(expect1);
      }
    }
    if (m.find("ErrorMsg") != m.end() && !m["ErrorMsg"].empty()) {
      errorMsg = make_shared<string>(boost::any_cast<string>(m["ErrorMsg"]));
    }
    if (m.find("ErrorParam") != m.end() && !m["ErrorParam"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["ErrorParam"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      errorParam = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("FailedTime") != m.end() && !m["FailedTime"].empty()) {
      failedTime = make_shared<string>(boost::any_cast<string>(m["FailedTime"]));
    }
  }


  virtual ~DescribeProjectStepsResponseBodyDataExtraInfo() = default;
};
class DescribeProjectStepsResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<DescribeProjectStepsResponseBodyDataExtraInfo> extraInfo{};
  shared_ptr<string> finishTime{};
  shared_ptr<string> name{};
  shared_ptr<long> order{};
  shared_ptr<long> progress{};
  shared_ptr<string> startTime{};
  shared_ptr<string> status{};
  shared_ptr<map<string, boost::any>> stepInfo{};

  DescribeProjectStepsResponseBodyData() {}

  explicit DescribeProjectStepsResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (extraInfo) {
      res["ExtraInfo"] = extraInfo ? boost::any(extraInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (finishTime) {
      res["FinishTime"] = boost::any(*finishTime);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (order) {
      res["Order"] = boost::any(*order);
    }
    if (progress) {
      res["Progress"] = boost::any(*progress);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (stepInfo) {
      res["StepInfo"] = boost::any(*stepInfo);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("ExtraInfo") != m.end() && !m["ExtraInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["ExtraInfo"].type()) {
        DescribeProjectStepsResponseBodyDataExtraInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ExtraInfo"]));
        extraInfo = make_shared<DescribeProjectStepsResponseBodyDataExtraInfo>(model1);
      }
    }
    if (m.find("FinishTime") != m.end() && !m["FinishTime"].empty()) {
      finishTime = make_shared<string>(boost::any_cast<string>(m["FinishTime"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Order") != m.end() && !m["Order"].empty()) {
      order = make_shared<long>(boost::any_cast<long>(m["Order"]));
    }
    if (m.find("Progress") != m.end() && !m["Progress"].empty()) {
      progress = make_shared<long>(boost::any_cast<long>(m["Progress"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("StepInfo") != m.end() && !m["StepInfo"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["StepInfo"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      stepInfo = make_shared<map<string, boost::any>>(toMap1);
    }
  }


  virtual ~DescribeProjectStepsResponseBodyData() = default;
};
class DescribeProjectStepsResponseBodyErrorDetail : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<map<string, boost::any>> extraContext{};
  shared_ptr<string> level{};
  shared_ptr<string> message{};
  shared_ptr<map<string, string>> messageMcmsContext{};
  shared_ptr<string> messageMcmsKey{};
  shared_ptr<string> proposal{};
  shared_ptr<map<string, string>> proposalMcmsContext{};
  shared_ptr<string> proposalMcmsKey{};
  shared_ptr<string> reason{};
  shared_ptr<map<string, string>> reasonMcmsContext{};
  shared_ptr<string> reasonMcmsKey{};
  shared_ptr<boost::any> upstreamErrorDetail{};

  DescribeProjectStepsResponseBodyErrorDetail() {}

  explicit DescribeProjectStepsResponseBodyErrorDetail(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (extraContext) {
      res["ExtraContext"] = boost::any(*extraContext);
    }
    if (level) {
      res["Level"] = boost::any(*level);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (messageMcmsContext) {
      res["MessageMcmsContext"] = boost::any(*messageMcmsContext);
    }
    if (messageMcmsKey) {
      res["MessageMcmsKey"] = boost::any(*messageMcmsKey);
    }
    if (proposal) {
      res["Proposal"] = boost::any(*proposal);
    }
    if (proposalMcmsContext) {
      res["ProposalMcmsContext"] = boost::any(*proposalMcmsContext);
    }
    if (proposalMcmsKey) {
      res["ProposalMcmsKey"] = boost::any(*proposalMcmsKey);
    }
    if (reason) {
      res["Reason"] = boost::any(*reason);
    }
    if (reasonMcmsContext) {
      res["ReasonMcmsContext"] = boost::any(*reasonMcmsContext);
    }
    if (reasonMcmsKey) {
      res["ReasonMcmsKey"] = boost::any(*reasonMcmsKey);
    }
    if (upstreamErrorDetail) {
      res["UpstreamErrorDetail"] = boost::any(*upstreamErrorDetail);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ExtraContext") != m.end() && !m["ExtraContext"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["ExtraContext"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      extraContext = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<string>(boost::any_cast<string>(m["Level"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("MessageMcmsContext") != m.end() && !m["MessageMcmsContext"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["MessageMcmsContext"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      messageMcmsContext = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("MessageMcmsKey") != m.end() && !m["MessageMcmsKey"].empty()) {
      messageMcmsKey = make_shared<string>(boost::any_cast<string>(m["MessageMcmsKey"]));
    }
    if (m.find("Proposal") != m.end() && !m["Proposal"].empty()) {
      proposal = make_shared<string>(boost::any_cast<string>(m["Proposal"]));
    }
    if (m.find("ProposalMcmsContext") != m.end() && !m["ProposalMcmsContext"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["ProposalMcmsContext"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      proposalMcmsContext = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("ProposalMcmsKey") != m.end() && !m["ProposalMcmsKey"].empty()) {
      proposalMcmsKey = make_shared<string>(boost::any_cast<string>(m["ProposalMcmsKey"]));
    }
    if (m.find("Reason") != m.end() && !m["Reason"].empty()) {
      reason = make_shared<string>(boost::any_cast<string>(m["Reason"]));
    }
    if (m.find("ReasonMcmsContext") != m.end() && !m["ReasonMcmsContext"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["ReasonMcmsContext"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      reasonMcmsContext = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("ReasonMcmsKey") != m.end() && !m["ReasonMcmsKey"].empty()) {
      reasonMcmsKey = make_shared<string>(boost::any_cast<string>(m["ReasonMcmsKey"]));
    }
    if (m.find("UpstreamErrorDetail") != m.end() && !m["UpstreamErrorDetail"].empty()) {
      upstreamErrorDetail = make_shared<boost::any>(boost::any_cast<boost::any>(m["UpstreamErrorDetail"]));
    }
  }


  virtual ~DescribeProjectStepsResponseBodyErrorDetail() = default;
};
class DescribeProjectStepsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> advice{};
  shared_ptr<string> code{};
  shared_ptr<string> cost{};
  shared_ptr<vector<DescribeProjectStepsResponseBodyData>> data{};
  shared_ptr<DescribeProjectStepsResponseBodyErrorDetail> errorDetail{};
  shared_ptr<string> message{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<long> totalCount{};

  DescribeProjectStepsResponseBody() {}

  explicit DescribeProjectStepsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (advice) {
      res["Advice"] = boost::any(*advice);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (cost) {
      res["Cost"] = boost::any(*cost);
    }
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (errorDetail) {
      res["ErrorDetail"] = errorDetail ? boost::any(errorDetail->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Advice") != m.end() && !m["Advice"].empty()) {
      advice = make_shared<string>(boost::any_cast<string>(m["Advice"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Cost") != m.end() && !m["Cost"].empty()) {
      cost = make_shared<string>(boost::any_cast<string>(m["Cost"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<DescribeProjectStepsResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeProjectStepsResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<DescribeProjectStepsResponseBodyData>>(expect1);
      }
    }
    if (m.find("ErrorDetail") != m.end() && !m["ErrorDetail"].empty()) {
      if (typeid(map<string, boost::any>) == m["ErrorDetail"].type()) {
        DescribeProjectStepsResponseBodyErrorDetail model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ErrorDetail"]));
        errorDetail = make_shared<DescribeProjectStepsResponseBodyErrorDetail>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeProjectStepsResponseBody() = default;
};
class DescribeProjectStepsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeProjectStepsResponseBody> body{};

  DescribeProjectStepsResponse() {}

  explicit DescribeProjectStepsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeProjectStepsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeProjectStepsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeProjectStepsResponse() = default;
};
class DescribeRecommendIndexRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> SQLId{};
  shared_ptr<string> tenantId{};

  DescribeRecommendIndexRequest() {}

  explicit DescribeRecommendIndexRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (SQLId) {
      res["SQLId"] = boost::any(*SQLId);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("SQLId") != m.end() && !m["SQLId"].empty()) {
      SQLId = make_shared<string>(boost::any_cast<string>(m["SQLId"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["TenantId"]));
    }
  }


  virtual ~DescribeRecommendIndexRequest() = default;
};
class DescribeRecommendIndexResponseBodyRecommendIndex : public Darabonba::Model {
public:
  shared_ptr<string> suggestIndex{};
  shared_ptr<string> tableList{};
  shared_ptr<string> tenantMode{};

  DescribeRecommendIndexResponseBodyRecommendIndex() {}

  explicit DescribeRecommendIndexResponseBodyRecommendIndex(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (suggestIndex) {
      res["SuggestIndex"] = boost::any(*suggestIndex);
    }
    if (tableList) {
      res["TableList"] = boost::any(*tableList);
    }
    if (tenantMode) {
      res["TenantMode"] = boost::any(*tenantMode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SuggestIndex") != m.end() && !m["SuggestIndex"].empty()) {
      suggestIndex = make_shared<string>(boost::any_cast<string>(m["SuggestIndex"]));
    }
    if (m.find("TableList") != m.end() && !m["TableList"].empty()) {
      tableList = make_shared<string>(boost::any_cast<string>(m["TableList"]));
    }
    if (m.find("TenantMode") != m.end() && !m["TenantMode"].empty()) {
      tenantMode = make_shared<string>(boost::any_cast<string>(m["TenantMode"]));
    }
  }


  virtual ~DescribeRecommendIndexResponseBodyRecommendIndex() = default;
};
class DescribeRecommendIndexResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeRecommendIndexResponseBodyRecommendIndex> recommendIndex{};
  shared_ptr<string> requestId{};

  DescribeRecommendIndexResponseBody() {}

  explicit DescribeRecommendIndexResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (recommendIndex) {
      res["RecommendIndex"] = recommendIndex ? boost::any(recommendIndex->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RecommendIndex") != m.end() && !m["RecommendIndex"].empty()) {
      if (typeid(map<string, boost::any>) == m["RecommendIndex"].type()) {
        DescribeRecommendIndexResponseBodyRecommendIndex model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RecommendIndex"]));
        recommendIndex = make_shared<DescribeRecommendIndexResponseBodyRecommendIndex>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeRecommendIndexResponseBody() = default;
};
class DescribeRecommendIndexResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeRecommendIndexResponseBody> body{};

  DescribeRecommendIndexResponse() {}

  explicit DescribeRecommendIndexResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeRecommendIndexResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeRecommendIndexResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeRecommendIndexResponse() = default;
};
class DescribeSQLDetailsRequest : public Darabonba::Model {
public:
  shared_ptr<string> SQLId{};
  shared_ptr<string> tenantId{};

  DescribeSQLDetailsRequest() {}

  explicit DescribeSQLDetailsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (SQLId) {
      res["SQLId"] = boost::any(*SQLId);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SQLId") != m.end() && !m["SQLId"].empty()) {
      SQLId = make_shared<string>(boost::any_cast<string>(m["SQLId"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["TenantId"]));
    }
  }


  virtual ~DescribeSQLDetailsRequest() = default;
};
class DescribeSQLDetailsResponseBodySQLDetails : public Darabonba::Model {
public:
  shared_ptr<string> dbName{};
  shared_ptr<string> SQLText{};
  shared_ptr<string> userName{};

  DescribeSQLDetailsResponseBodySQLDetails() {}

  explicit DescribeSQLDetailsResponseBodySQLDetails(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dbName) {
      res["DbName"] = boost::any(*dbName);
    }
    if (SQLText) {
      res["SQLText"] = boost::any(*SQLText);
    }
    if (userName) {
      res["UserName"] = boost::any(*userName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DbName") != m.end() && !m["DbName"].empty()) {
      dbName = make_shared<string>(boost::any_cast<string>(m["DbName"]));
    }
    if (m.find("SQLText") != m.end() && !m["SQLText"].empty()) {
      SQLText = make_shared<string>(boost::any_cast<string>(m["SQLText"]));
    }
    if (m.find("UserName") != m.end() && !m["UserName"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["UserName"]));
    }
  }


  virtual ~DescribeSQLDetailsResponseBodySQLDetails() = default;
};
class DescribeSQLDetailsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeSQLDetailsResponseBodySQLDetails>> SQLDetails{};

  DescribeSQLDetailsResponseBody() {}

  explicit DescribeSQLDetailsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (SQLDetails) {
      vector<boost::any> temp1;
      for(auto item1:*SQLDetails){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SQLDetails"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SQLDetails") != m.end() && !m["SQLDetails"].empty()) {
      if (typeid(vector<boost::any>) == m["SQLDetails"].type()) {
        vector<DescribeSQLDetailsResponseBodySQLDetails> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SQLDetails"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeSQLDetailsResponseBodySQLDetails model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        SQLDetails = make_shared<vector<DescribeSQLDetailsResponseBodySQLDetails>>(expect1);
      }
    }
  }


  virtual ~DescribeSQLDetailsResponseBody() = default;
};
class DescribeSQLDetailsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeSQLDetailsResponseBody> body{};

  DescribeSQLDetailsResponse() {}

  explicit DescribeSQLDetailsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeSQLDetailsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeSQLDetailsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeSQLDetailsResponse() = default;
};
class DescribeSQLHistoryListRequest : public Darabonba::Model {
public:
  shared_ptr<string> endTime{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> SQLId{};
  shared_ptr<string> startTime{};
  shared_ptr<string> tenantId{};

  DescribeSQLHistoryListRequest() {}

  explicit DescribeSQLHistoryListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (SQLId) {
      res["SQLId"] = boost::any(*SQLId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SQLId") != m.end() && !m["SQLId"].empty()) {
      SQLId = make_shared<string>(boost::any_cast<string>(m["SQLId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["TenantId"]));
    }
  }


  virtual ~DescribeSQLHistoryListRequest() = default;
};
class DescribeSQLHistoryListResponseBodySQLHistoryListList : public Darabonba::Model {
public:
  shared_ptr<long> affectedRows{};
  shared_ptr<double> appWaitTime{};
  shared_ptr<long> blockCacheHit{};
  shared_ptr<long> blockIndexCacheHit{};
  shared_ptr<long> bloomFilterCacheHit{};
  shared_ptr<string> clientIp{};
  shared_ptr<double> concurrencyWaitTime{};
  shared_ptr<double> cpuTime{};
  shared_ptr<string> dbName{};
  shared_ptr<double> decodeTime{};
  shared_ptr<long> diskRead{};
  shared_ptr<double> elapsedTime{};
  shared_ptr<long> endTime{};
  shared_ptr<string> endTimeUTCString{};
  shared_ptr<string> event{};
  shared_ptr<long> execPerSecond{};
  shared_ptr<double> executeTime{};
  shared_ptr<long> executions{};
  shared_ptr<long> failTimes{};
  shared_ptr<double> getPlanTime{};
  shared_ptr<double> IOWaitTime{};
  shared_ptr<long> logicalRead{};
  shared_ptr<double> maxCpuTime{};
  shared_ptr<double> maxElapsedTime{};
  shared_ptr<long> memstoreReadRowCount{};
  shared_ptr<long> missPlans{};
  shared_ptr<double> netWaitTime{};
  shared_ptr<string> nodeIp{};
  shared_ptr<double> queueTime{};
  shared_ptr<long> RPCCount{};
  shared_ptr<long> remotePlans{};
  shared_ptr<long> retryCount{};
  shared_ptr<long> returnRows{};
  shared_ptr<long> rowCacheHit{};
  shared_ptr<double> scheduleTime{};
  shared_ptr<long> ssstoreReadRowCount{};
  shared_ptr<double> totalWaitTime{};
  shared_ptr<string> userName{};

  DescribeSQLHistoryListResponseBodySQLHistoryListList() {}

  explicit DescribeSQLHistoryListResponseBodySQLHistoryListList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (affectedRows) {
      res["AffectedRows"] = boost::any(*affectedRows);
    }
    if (appWaitTime) {
      res["AppWaitTime"] = boost::any(*appWaitTime);
    }
    if (blockCacheHit) {
      res["BlockCacheHit"] = boost::any(*blockCacheHit);
    }
    if (blockIndexCacheHit) {
      res["BlockIndexCacheHit"] = boost::any(*blockIndexCacheHit);
    }
    if (bloomFilterCacheHit) {
      res["BloomFilterCacheHit"] = boost::any(*bloomFilterCacheHit);
    }
    if (clientIp) {
      res["ClientIp"] = boost::any(*clientIp);
    }
    if (concurrencyWaitTime) {
      res["ConcurrencyWaitTime"] = boost::any(*concurrencyWaitTime);
    }
    if (cpuTime) {
      res["CpuTime"] = boost::any(*cpuTime);
    }
    if (dbName) {
      res["DbName"] = boost::any(*dbName);
    }
    if (decodeTime) {
      res["DecodeTime"] = boost::any(*decodeTime);
    }
    if (diskRead) {
      res["DiskRead"] = boost::any(*diskRead);
    }
    if (elapsedTime) {
      res["ElapsedTime"] = boost::any(*elapsedTime);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (endTimeUTCString) {
      res["EndTimeUTCString"] = boost::any(*endTimeUTCString);
    }
    if (event) {
      res["Event"] = boost::any(*event);
    }
    if (execPerSecond) {
      res["ExecPerSecond"] = boost::any(*execPerSecond);
    }
    if (executeTime) {
      res["ExecuteTime"] = boost::any(*executeTime);
    }
    if (executions) {
      res["Executions"] = boost::any(*executions);
    }
    if (failTimes) {
      res["FailTimes"] = boost::any(*failTimes);
    }
    if (getPlanTime) {
      res["GetPlanTime"] = boost::any(*getPlanTime);
    }
    if (IOWaitTime) {
      res["IOWaitTime"] = boost::any(*IOWaitTime);
    }
    if (logicalRead) {
      res["LogicalRead"] = boost::any(*logicalRead);
    }
    if (maxCpuTime) {
      res["MaxCpuTime"] = boost::any(*maxCpuTime);
    }
    if (maxElapsedTime) {
      res["MaxElapsedTime"] = boost::any(*maxElapsedTime);
    }
    if (memstoreReadRowCount) {
      res["MemstoreReadRowCount"] = boost::any(*memstoreReadRowCount);
    }
    if (missPlans) {
      res["MissPlans"] = boost::any(*missPlans);
    }
    if (netWaitTime) {
      res["NetWaitTime"] = boost::any(*netWaitTime);
    }
    if (nodeIp) {
      res["NodeIp"] = boost::any(*nodeIp);
    }
    if (queueTime) {
      res["QueueTime"] = boost::any(*queueTime);
    }
    if (RPCCount) {
      res["RPCCount"] = boost::any(*RPCCount);
    }
    if (remotePlans) {
      res["RemotePlans"] = boost::any(*remotePlans);
    }
    if (retryCount) {
      res["RetryCount"] = boost::any(*retryCount);
    }
    if (returnRows) {
      res["ReturnRows"] = boost::any(*returnRows);
    }
    if (rowCacheHit) {
      res["RowCacheHit"] = boost::any(*rowCacheHit);
    }
    if (scheduleTime) {
      res["ScheduleTime"] = boost::any(*scheduleTime);
    }
    if (ssstoreReadRowCount) {
      res["SsstoreReadRowCount"] = boost::any(*ssstoreReadRowCount);
    }
    if (totalWaitTime) {
      res["TotalWaitTime"] = boost::any(*totalWaitTime);
    }
    if (userName) {
      res["UserName"] = boost::any(*userName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AffectedRows") != m.end() && !m["AffectedRows"].empty()) {
      affectedRows = make_shared<long>(boost::any_cast<long>(m["AffectedRows"]));
    }
    if (m.find("AppWaitTime") != m.end() && !m["AppWaitTime"].empty()) {
      appWaitTime = make_shared<double>(boost::any_cast<double>(m["AppWaitTime"]));
    }
    if (m.find("BlockCacheHit") != m.end() && !m["BlockCacheHit"].empty()) {
      blockCacheHit = make_shared<long>(boost::any_cast<long>(m["BlockCacheHit"]));
    }
    if (m.find("BlockIndexCacheHit") != m.end() && !m["BlockIndexCacheHit"].empty()) {
      blockIndexCacheHit = make_shared<long>(boost::any_cast<long>(m["BlockIndexCacheHit"]));
    }
    if (m.find("BloomFilterCacheHit") != m.end() && !m["BloomFilterCacheHit"].empty()) {
      bloomFilterCacheHit = make_shared<long>(boost::any_cast<long>(m["BloomFilterCacheHit"]));
    }
    if (m.find("ClientIp") != m.end() && !m["ClientIp"].empty()) {
      clientIp = make_shared<string>(boost::any_cast<string>(m["ClientIp"]));
    }
    if (m.find("ConcurrencyWaitTime") != m.end() && !m["ConcurrencyWaitTime"].empty()) {
      concurrencyWaitTime = make_shared<double>(boost::any_cast<double>(m["ConcurrencyWaitTime"]));
    }
    if (m.find("CpuTime") != m.end() && !m["CpuTime"].empty()) {
      cpuTime = make_shared<double>(boost::any_cast<double>(m["CpuTime"]));
    }
    if (m.find("DbName") != m.end() && !m["DbName"].empty()) {
      dbName = make_shared<string>(boost::any_cast<string>(m["DbName"]));
    }
    if (m.find("DecodeTime") != m.end() && !m["DecodeTime"].empty()) {
      decodeTime = make_shared<double>(boost::any_cast<double>(m["DecodeTime"]));
    }
    if (m.find("DiskRead") != m.end() && !m["DiskRead"].empty()) {
      diskRead = make_shared<long>(boost::any_cast<long>(m["DiskRead"]));
    }
    if (m.find("ElapsedTime") != m.end() && !m["ElapsedTime"].empty()) {
      elapsedTime = make_shared<double>(boost::any_cast<double>(m["ElapsedTime"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("EndTimeUTCString") != m.end() && !m["EndTimeUTCString"].empty()) {
      endTimeUTCString = make_shared<string>(boost::any_cast<string>(m["EndTimeUTCString"]));
    }
    if (m.find("Event") != m.end() && !m["Event"].empty()) {
      event = make_shared<string>(boost::any_cast<string>(m["Event"]));
    }
    if (m.find("ExecPerSecond") != m.end() && !m["ExecPerSecond"].empty()) {
      execPerSecond = make_shared<long>(boost::any_cast<long>(m["ExecPerSecond"]));
    }
    if (m.find("ExecuteTime") != m.end() && !m["ExecuteTime"].empty()) {
      executeTime = make_shared<double>(boost::any_cast<double>(m["ExecuteTime"]));
    }
    if (m.find("Executions") != m.end() && !m["Executions"].empty()) {
      executions = make_shared<long>(boost::any_cast<long>(m["Executions"]));
    }
    if (m.find("FailTimes") != m.end() && !m["FailTimes"].empty()) {
      failTimes = make_shared<long>(boost::any_cast<long>(m["FailTimes"]));
    }
    if (m.find("GetPlanTime") != m.end() && !m["GetPlanTime"].empty()) {
      getPlanTime = make_shared<double>(boost::any_cast<double>(m["GetPlanTime"]));
    }
    if (m.find("IOWaitTime") != m.end() && !m["IOWaitTime"].empty()) {
      IOWaitTime = make_shared<double>(boost::any_cast<double>(m["IOWaitTime"]));
    }
    if (m.find("LogicalRead") != m.end() && !m["LogicalRead"].empty()) {
      logicalRead = make_shared<long>(boost::any_cast<long>(m["LogicalRead"]));
    }
    if (m.find("MaxCpuTime") != m.end() && !m["MaxCpuTime"].empty()) {
      maxCpuTime = make_shared<double>(boost::any_cast<double>(m["MaxCpuTime"]));
    }
    if (m.find("MaxElapsedTime") != m.end() && !m["MaxElapsedTime"].empty()) {
      maxElapsedTime = make_shared<double>(boost::any_cast<double>(m["MaxElapsedTime"]));
    }
    if (m.find("MemstoreReadRowCount") != m.end() && !m["MemstoreReadRowCount"].empty()) {
      memstoreReadRowCount = make_shared<long>(boost::any_cast<long>(m["MemstoreReadRowCount"]));
    }
    if (m.find("MissPlans") != m.end() && !m["MissPlans"].empty()) {
      missPlans = make_shared<long>(boost::any_cast<long>(m["MissPlans"]));
    }
    if (m.find("NetWaitTime") != m.end() && !m["NetWaitTime"].empty()) {
      netWaitTime = make_shared<double>(boost::any_cast<double>(m["NetWaitTime"]));
    }
    if (m.find("NodeIp") != m.end() && !m["NodeIp"].empty()) {
      nodeIp = make_shared<string>(boost::any_cast<string>(m["NodeIp"]));
    }
    if (m.find("QueueTime") != m.end() && !m["QueueTime"].empty()) {
      queueTime = make_shared<double>(boost::any_cast<double>(m["QueueTime"]));
    }
    if (m.find("RPCCount") != m.end() && !m["RPCCount"].empty()) {
      RPCCount = make_shared<long>(boost::any_cast<long>(m["RPCCount"]));
    }
    if (m.find("RemotePlans") != m.end() && !m["RemotePlans"].empty()) {
      remotePlans = make_shared<long>(boost::any_cast<long>(m["RemotePlans"]));
    }
    if (m.find("RetryCount") != m.end() && !m["RetryCount"].empty()) {
      retryCount = make_shared<long>(boost::any_cast<long>(m["RetryCount"]));
    }
    if (m.find("ReturnRows") != m.end() && !m["ReturnRows"].empty()) {
      returnRows = make_shared<long>(boost::any_cast<long>(m["ReturnRows"]));
    }
    if (m.find("RowCacheHit") != m.end() && !m["RowCacheHit"].empty()) {
      rowCacheHit = make_shared<long>(boost::any_cast<long>(m["RowCacheHit"]));
    }
    if (m.find("ScheduleTime") != m.end() && !m["ScheduleTime"].empty()) {
      scheduleTime = make_shared<double>(boost::any_cast<double>(m["ScheduleTime"]));
    }
    if (m.find("SsstoreReadRowCount") != m.end() && !m["SsstoreReadRowCount"].empty()) {
      ssstoreReadRowCount = make_shared<long>(boost::any_cast<long>(m["SsstoreReadRowCount"]));
    }
    if (m.find("TotalWaitTime") != m.end() && !m["TotalWaitTime"].empty()) {
      totalWaitTime = make_shared<double>(boost::any_cast<double>(m["TotalWaitTime"]));
    }
    if (m.find("UserName") != m.end() && !m["UserName"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["UserName"]));
    }
  }


  virtual ~DescribeSQLHistoryListResponseBodySQLHistoryListList() = default;
};
class DescribeSQLHistoryListResponseBodySQLHistoryList : public Darabonba::Model {
public:
  shared_ptr<long> count{};
  shared_ptr<vector<DescribeSQLHistoryListResponseBodySQLHistoryListList>> list{};

  DescribeSQLHistoryListResponseBodySQLHistoryList() {}

  explicit DescribeSQLHistoryListResponseBodySQLHistoryList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (list) {
      vector<boost::any> temp1;
      for(auto item1:*list){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["List"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(vector<boost::any>) == m["List"].type()) {
        vector<DescribeSQLHistoryListResponseBodySQLHistoryListList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["List"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeSQLHistoryListResponseBodySQLHistoryListList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        list = make_shared<vector<DescribeSQLHistoryListResponseBodySQLHistoryListList>>(expect1);
      }
    }
  }


  virtual ~DescribeSQLHistoryListResponseBodySQLHistoryList() = default;
};
class DescribeSQLHistoryListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeSQLHistoryListResponseBodySQLHistoryList> SQLHistoryList{};

  DescribeSQLHistoryListResponseBody() {}

  explicit DescribeSQLHistoryListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (SQLHistoryList) {
      res["SQLHistoryList"] = SQLHistoryList ? boost::any(SQLHistoryList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SQLHistoryList") != m.end() && !m["SQLHistoryList"].empty()) {
      if (typeid(map<string, boost::any>) == m["SQLHistoryList"].type()) {
        DescribeSQLHistoryListResponseBodySQLHistoryList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SQLHistoryList"]));
        SQLHistoryList = make_shared<DescribeSQLHistoryListResponseBodySQLHistoryList>(model1);
      }
    }
  }


  virtual ~DescribeSQLHistoryListResponseBody() = default;
};
class DescribeSQLHistoryListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeSQLHistoryListResponseBody> body{};

  DescribeSQLHistoryListResponse() {}

  explicit DescribeSQLHistoryListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeSQLHistoryListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeSQLHistoryListResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeSQLHistoryListResponse() = default;
};
class DescribeSQLPlansRequest : public Darabonba::Model {
public:
  shared_ptr<string> SQLId{};
  shared_ptr<string> tenantId{};

  DescribeSQLPlansRequest() {}

  explicit DescribeSQLPlansRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (SQLId) {
      res["SQLId"] = boost::any(*SQLId);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SQLId") != m.end() && !m["SQLId"].empty()) {
      SQLId = make_shared<string>(boost::any_cast<string>(m["SQLId"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["TenantId"]));
    }
  }


  virtual ~DescribeSQLPlansRequest() = default;
};
class DescribeSQLPlansResponseBodySQLPlans : public Darabonba::Model {
public:
  shared_ptr<double> avgExecutionMS{};
  shared_ptr<long> avgExecutionTimeMS{};
  shared_ptr<long> firstLoadTime{};
  shared_ptr<string> firstLoadTimeUTCString{};
  shared_ptr<long> hitCount{};
  shared_ptr<long> mergedVersion{};
  shared_ptr<string> nodeIp{};
  shared_ptr<string> outlineData{};
  shared_ptr<long> outlineId{};
  shared_ptr<long> outlineTime{};
  shared_ptr<string> outlineTimeUTCString{};
  shared_ptr<string> planFull{};
  shared_ptr<long> planId{};
  shared_ptr<string> planInfo{};
  shared_ptr<string> planUnionHash{};
  shared_ptr<string> querySQL{};

  DescribeSQLPlansResponseBodySQLPlans() {}

  explicit DescribeSQLPlansResponseBodySQLPlans(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (avgExecutionMS) {
      res["AvgExecutionMS"] = boost::any(*avgExecutionMS);
    }
    if (avgExecutionTimeMS) {
      res["AvgExecutionTimeMS"] = boost::any(*avgExecutionTimeMS);
    }
    if (firstLoadTime) {
      res["FirstLoadTime"] = boost::any(*firstLoadTime);
    }
    if (firstLoadTimeUTCString) {
      res["FirstLoadTimeUTCString"] = boost::any(*firstLoadTimeUTCString);
    }
    if (hitCount) {
      res["HitCount"] = boost::any(*hitCount);
    }
    if (mergedVersion) {
      res["MergedVersion"] = boost::any(*mergedVersion);
    }
    if (nodeIp) {
      res["NodeIp"] = boost::any(*nodeIp);
    }
    if (outlineData) {
      res["OutlineData"] = boost::any(*outlineData);
    }
    if (outlineId) {
      res["OutlineId"] = boost::any(*outlineId);
    }
    if (outlineTime) {
      res["OutlineTime"] = boost::any(*outlineTime);
    }
    if (outlineTimeUTCString) {
      res["OutlineTimeUTCString"] = boost::any(*outlineTimeUTCString);
    }
    if (planFull) {
      res["PlanFull"] = boost::any(*planFull);
    }
    if (planId) {
      res["PlanId"] = boost::any(*planId);
    }
    if (planInfo) {
      res["PlanInfo"] = boost::any(*planInfo);
    }
    if (planUnionHash) {
      res["PlanUnionHash"] = boost::any(*planUnionHash);
    }
    if (querySQL) {
      res["QuerySQL"] = boost::any(*querySQL);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AvgExecutionMS") != m.end() && !m["AvgExecutionMS"].empty()) {
      avgExecutionMS = make_shared<double>(boost::any_cast<double>(m["AvgExecutionMS"]));
    }
    if (m.find("AvgExecutionTimeMS") != m.end() && !m["AvgExecutionTimeMS"].empty()) {
      avgExecutionTimeMS = make_shared<long>(boost::any_cast<long>(m["AvgExecutionTimeMS"]));
    }
    if (m.find("FirstLoadTime") != m.end() && !m["FirstLoadTime"].empty()) {
      firstLoadTime = make_shared<long>(boost::any_cast<long>(m["FirstLoadTime"]));
    }
    if (m.find("FirstLoadTimeUTCString") != m.end() && !m["FirstLoadTimeUTCString"].empty()) {
      firstLoadTimeUTCString = make_shared<string>(boost::any_cast<string>(m["FirstLoadTimeUTCString"]));
    }
    if (m.find("HitCount") != m.end() && !m["HitCount"].empty()) {
      hitCount = make_shared<long>(boost::any_cast<long>(m["HitCount"]));
    }
    if (m.find("MergedVersion") != m.end() && !m["MergedVersion"].empty()) {
      mergedVersion = make_shared<long>(boost::any_cast<long>(m["MergedVersion"]));
    }
    if (m.find("NodeIp") != m.end() && !m["NodeIp"].empty()) {
      nodeIp = make_shared<string>(boost::any_cast<string>(m["NodeIp"]));
    }
    if (m.find("OutlineData") != m.end() && !m["OutlineData"].empty()) {
      outlineData = make_shared<string>(boost::any_cast<string>(m["OutlineData"]));
    }
    if (m.find("OutlineId") != m.end() && !m["OutlineId"].empty()) {
      outlineId = make_shared<long>(boost::any_cast<long>(m["OutlineId"]));
    }
    if (m.find("OutlineTime") != m.end() && !m["OutlineTime"].empty()) {
      outlineTime = make_shared<long>(boost::any_cast<long>(m["OutlineTime"]));
    }
    if (m.find("OutlineTimeUTCString") != m.end() && !m["OutlineTimeUTCString"].empty()) {
      outlineTimeUTCString = make_shared<string>(boost::any_cast<string>(m["OutlineTimeUTCString"]));
    }
    if (m.find("PlanFull") != m.end() && !m["PlanFull"].empty()) {
      planFull = make_shared<string>(boost::any_cast<string>(m["PlanFull"]));
    }
    if (m.find("PlanId") != m.end() && !m["PlanId"].empty()) {
      planId = make_shared<long>(boost::any_cast<long>(m["PlanId"]));
    }
    if (m.find("PlanInfo") != m.end() && !m["PlanInfo"].empty()) {
      planInfo = make_shared<string>(boost::any_cast<string>(m["PlanInfo"]));
    }
    if (m.find("PlanUnionHash") != m.end() && !m["PlanUnionHash"].empty()) {
      planUnionHash = make_shared<string>(boost::any_cast<string>(m["PlanUnionHash"]));
    }
    if (m.find("QuerySQL") != m.end() && !m["QuerySQL"].empty()) {
      querySQL = make_shared<string>(boost::any_cast<string>(m["QuerySQL"]));
    }
  }


  virtual ~DescribeSQLPlansResponseBodySQLPlans() = default;
};
class DescribeSQLPlansResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeSQLPlansResponseBodySQLPlans>> SQLPlans{};

  DescribeSQLPlansResponseBody() {}

  explicit DescribeSQLPlansResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (SQLPlans) {
      vector<boost::any> temp1;
      for(auto item1:*SQLPlans){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SQLPlans"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SQLPlans") != m.end() && !m["SQLPlans"].empty()) {
      if (typeid(vector<boost::any>) == m["SQLPlans"].type()) {
        vector<DescribeSQLPlansResponseBodySQLPlans> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SQLPlans"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeSQLPlansResponseBodySQLPlans model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        SQLPlans = make_shared<vector<DescribeSQLPlansResponseBodySQLPlans>>(expect1);
      }
    }
  }


  virtual ~DescribeSQLPlansResponseBody() = default;
};
class DescribeSQLPlansResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeSQLPlansResponseBody> body{};

  DescribeSQLPlansResponse() {}

  explicit DescribeSQLPlansResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeSQLPlansResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeSQLPlansResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeSQLPlansResponse() = default;
};
class DescribeSQLSamplesRequest : public Darabonba::Model {
public:
  shared_ptr<string> dbName{};
  shared_ptr<string> endTime{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> sqlId{};
  shared_ptr<string> startTime{};
  shared_ptr<string> tenantId{};

  DescribeSQLSamplesRequest() {}

  explicit DescribeSQLSamplesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dbName) {
      res["DbName"] = boost::any(*dbName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (sqlId) {
      res["SqlId"] = boost::any(*sqlId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DbName") != m.end() && !m["DbName"].empty()) {
      dbName = make_shared<string>(boost::any_cast<string>(m["DbName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("SqlId") != m.end() && !m["SqlId"].empty()) {
      sqlId = make_shared<string>(boost::any_cast<string>(m["SqlId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["TenantId"]));
    }
  }


  virtual ~DescribeSQLSamplesRequest() = default;
};
class DescribeSQLSamplesResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<double> affectedRows{};
  shared_ptr<double> applicationWaitTime{};
  shared_ptr<double> blockCacheHit{};
  shared_ptr<double> blockIndexCacheHit{};
  shared_ptr<double> bloomFilterCacheHit{};
  shared_ptr<string> clientIp{};
  shared_ptr<string> clientPort{};
  shared_ptr<double> concurrencyWaitTime{};
  shared_ptr<string> consistencyLevel{};
  shared_ptr<double> cpuTime{};
  shared_ptr<string> dbName{};
  shared_ptr<double> decodeTime{};
  shared_ptr<double> diskReads{};
  shared_ptr<double> elapsedTime{};
  shared_ptr<double> executeTime{};
  shared_ptr<bool> executorRpc{};
  shared_ptr<double> expectedWorkerCount{};
  shared_ptr<string> fullSqlText{};
  shared_ptr<double> getPlanTime{};
  shared_ptr<bool> hitPlan{};
  shared_ptr<bool> inner{};
  shared_ptr<double> memstoreReadRows{};
  shared_ptr<double> netTime{};
  shared_ptr<double> netWaitTime{};
  shared_ptr<double> obDbId{};
  shared_ptr<double> obServerId{};
  shared_ptr<double> obUserId{};
  shared_ptr<double> partitionCount{};
  shared_ptr<double> planId{};
  shared_ptr<string> planType{};
  shared_ptr<double> queueTime{};
  shared_ptr<string> requestId{};
  shared_ptr<string> requestTime{};
  shared_ptr<double> retCode{};
  shared_ptr<double> retryCount{};
  shared_ptr<double> returnRows{};
  shared_ptr<double> rowCacheHit{};
  shared_ptr<double> rpcCount{};
  shared_ptr<double> scheduleTime{};
  shared_ptr<string> server{};
  shared_ptr<string> sqlType{};
  shared_ptr<double> ssstoreReadRows{};
  shared_ptr<string> statement{};
  shared_ptr<bool> tableScan{};
  shared_ptr<string> traceId{};
  shared_ptr<string> transHash{};
  shared_ptr<double> usedWorkerCount{};
  shared_ptr<double> userIoWaitTime{};
  shared_ptr<string> userName{};
  shared_ptr<double> waitCount{};
  shared_ptr<string> waitEvent{};
  shared_ptr<double> waitTime{};

  DescribeSQLSamplesResponseBodyData() {}

  explicit DescribeSQLSamplesResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (affectedRows) {
      res["AffectedRows"] = boost::any(*affectedRows);
    }
    if (applicationWaitTime) {
      res["ApplicationWaitTime"] = boost::any(*applicationWaitTime);
    }
    if (blockCacheHit) {
      res["BlockCacheHit"] = boost::any(*blockCacheHit);
    }
    if (blockIndexCacheHit) {
      res["BlockIndexCacheHit"] = boost::any(*blockIndexCacheHit);
    }
    if (bloomFilterCacheHit) {
      res["BloomFilterCacheHit"] = boost::any(*bloomFilterCacheHit);
    }
    if (clientIp) {
      res["ClientIp"] = boost::any(*clientIp);
    }
    if (clientPort) {
      res["ClientPort"] = boost::any(*clientPort);
    }
    if (concurrencyWaitTime) {
      res["ConcurrencyWaitTime"] = boost::any(*concurrencyWaitTime);
    }
    if (consistencyLevel) {
      res["ConsistencyLevel"] = boost::any(*consistencyLevel);
    }
    if (cpuTime) {
      res["CpuTime"] = boost::any(*cpuTime);
    }
    if (dbName) {
      res["DbName"] = boost::any(*dbName);
    }
    if (decodeTime) {
      res["DecodeTime"] = boost::any(*decodeTime);
    }
    if (diskReads) {
      res["DiskReads"] = boost::any(*diskReads);
    }
    if (elapsedTime) {
      res["ElapsedTime"] = boost::any(*elapsedTime);
    }
    if (executeTime) {
      res["ExecuteTime"] = boost::any(*executeTime);
    }
    if (executorRpc) {
      res["ExecutorRpc"] = boost::any(*executorRpc);
    }
    if (expectedWorkerCount) {
      res["ExpectedWorkerCount"] = boost::any(*expectedWorkerCount);
    }
    if (fullSqlText) {
      res["FullSqlText"] = boost::any(*fullSqlText);
    }
    if (getPlanTime) {
      res["GetPlanTime"] = boost::any(*getPlanTime);
    }
    if (hitPlan) {
      res["HitPlan"] = boost::any(*hitPlan);
    }
    if (inner) {
      res["Inner"] = boost::any(*inner);
    }
    if (memstoreReadRows) {
      res["MemstoreReadRows"] = boost::any(*memstoreReadRows);
    }
    if (netTime) {
      res["NetTime"] = boost::any(*netTime);
    }
    if (netWaitTime) {
      res["NetWaitTime"] = boost::any(*netWaitTime);
    }
    if (obDbId) {
      res["ObDbId"] = boost::any(*obDbId);
    }
    if (obServerId) {
      res["ObServerId"] = boost::any(*obServerId);
    }
    if (obUserId) {
      res["ObUserId"] = boost::any(*obUserId);
    }
    if (partitionCount) {
      res["PartitionCount"] = boost::any(*partitionCount);
    }
    if (planId) {
      res["PlanId"] = boost::any(*planId);
    }
    if (planType) {
      res["PlanType"] = boost::any(*planType);
    }
    if (queueTime) {
      res["QueueTime"] = boost::any(*queueTime);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (requestTime) {
      res["RequestTime"] = boost::any(*requestTime);
    }
    if (retCode) {
      res["RetCode"] = boost::any(*retCode);
    }
    if (retryCount) {
      res["RetryCount"] = boost::any(*retryCount);
    }
    if (returnRows) {
      res["ReturnRows"] = boost::any(*returnRows);
    }
    if (rowCacheHit) {
      res["RowCacheHit"] = boost::any(*rowCacheHit);
    }
    if (rpcCount) {
      res["RpcCount"] = boost::any(*rpcCount);
    }
    if (scheduleTime) {
      res["ScheduleTime"] = boost::any(*scheduleTime);
    }
    if (server) {
      res["Server"] = boost::any(*server);
    }
    if (sqlType) {
      res["SqlType"] = boost::any(*sqlType);
    }
    if (ssstoreReadRows) {
      res["SsstoreReadRows"] = boost::any(*ssstoreReadRows);
    }
    if (statement) {
      res["Statement"] = boost::any(*statement);
    }
    if (tableScan) {
      res["TableScan"] = boost::any(*tableScan);
    }
    if (traceId) {
      res["TraceId"] = boost::any(*traceId);
    }
    if (transHash) {
      res["TransHash"] = boost::any(*transHash);
    }
    if (usedWorkerCount) {
      res["UsedWorkerCount"] = boost::any(*usedWorkerCount);
    }
    if (userIoWaitTime) {
      res["UserIoWaitTime"] = boost::any(*userIoWaitTime);
    }
    if (userName) {
      res["UserName"] = boost::any(*userName);
    }
    if (waitCount) {
      res["WaitCount"] = boost::any(*waitCount);
    }
    if (waitEvent) {
      res["WaitEvent"] = boost::any(*waitEvent);
    }
    if (waitTime) {
      res["WaitTime"] = boost::any(*waitTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AffectedRows") != m.end() && !m["AffectedRows"].empty()) {
      affectedRows = make_shared<double>(boost::any_cast<double>(m["AffectedRows"]));
    }
    if (m.find("ApplicationWaitTime") != m.end() && !m["ApplicationWaitTime"].empty()) {
      applicationWaitTime = make_shared<double>(boost::any_cast<double>(m["ApplicationWaitTime"]));
    }
    if (m.find("BlockCacheHit") != m.end() && !m["BlockCacheHit"].empty()) {
      blockCacheHit = make_shared<double>(boost::any_cast<double>(m["BlockCacheHit"]));
    }
    if (m.find("BlockIndexCacheHit") != m.end() && !m["BlockIndexCacheHit"].empty()) {
      blockIndexCacheHit = make_shared<double>(boost::any_cast<double>(m["BlockIndexCacheHit"]));
    }
    if (m.find("BloomFilterCacheHit") != m.end() && !m["BloomFilterCacheHit"].empty()) {
      bloomFilterCacheHit = make_shared<double>(boost::any_cast<double>(m["BloomFilterCacheHit"]));
    }
    if (m.find("ClientIp") != m.end() && !m["ClientIp"].empty()) {
      clientIp = make_shared<string>(boost::any_cast<string>(m["ClientIp"]));
    }
    if (m.find("ClientPort") != m.end() && !m["ClientPort"].empty()) {
      clientPort = make_shared<string>(boost::any_cast<string>(m["ClientPort"]));
    }
    if (m.find("ConcurrencyWaitTime") != m.end() && !m["ConcurrencyWaitTime"].empty()) {
      concurrencyWaitTime = make_shared<double>(boost::any_cast<double>(m["ConcurrencyWaitTime"]));
    }
    if (m.find("ConsistencyLevel") != m.end() && !m["ConsistencyLevel"].empty()) {
      consistencyLevel = make_shared<string>(boost::any_cast<string>(m["ConsistencyLevel"]));
    }
    if (m.find("CpuTime") != m.end() && !m["CpuTime"].empty()) {
      cpuTime = make_shared<double>(boost::any_cast<double>(m["CpuTime"]));
    }
    if (m.find("DbName") != m.end() && !m["DbName"].empty()) {
      dbName = make_shared<string>(boost::any_cast<string>(m["DbName"]));
    }
    if (m.find("DecodeTime") != m.end() && !m["DecodeTime"].empty()) {
      decodeTime = make_shared<double>(boost::any_cast<double>(m["DecodeTime"]));
    }
    if (m.find("DiskReads") != m.end() && !m["DiskReads"].empty()) {
      diskReads = make_shared<double>(boost::any_cast<double>(m["DiskReads"]));
    }
    if (m.find("ElapsedTime") != m.end() && !m["ElapsedTime"].empty()) {
      elapsedTime = make_shared<double>(boost::any_cast<double>(m["ElapsedTime"]));
    }
    if (m.find("ExecuteTime") != m.end() && !m["ExecuteTime"].empty()) {
      executeTime = make_shared<double>(boost::any_cast<double>(m["ExecuteTime"]));
    }
    if (m.find("ExecutorRpc") != m.end() && !m["ExecutorRpc"].empty()) {
      executorRpc = make_shared<bool>(boost::any_cast<bool>(m["ExecutorRpc"]));
    }
    if (m.find("ExpectedWorkerCount") != m.end() && !m["ExpectedWorkerCount"].empty()) {
      expectedWorkerCount = make_shared<double>(boost::any_cast<double>(m["ExpectedWorkerCount"]));
    }
    if (m.find("FullSqlText") != m.end() && !m["FullSqlText"].empty()) {
      fullSqlText = make_shared<string>(boost::any_cast<string>(m["FullSqlText"]));
    }
    if (m.find("GetPlanTime") != m.end() && !m["GetPlanTime"].empty()) {
      getPlanTime = make_shared<double>(boost::any_cast<double>(m["GetPlanTime"]));
    }
    if (m.find("HitPlan") != m.end() && !m["HitPlan"].empty()) {
      hitPlan = make_shared<bool>(boost::any_cast<bool>(m["HitPlan"]));
    }
    if (m.find("Inner") != m.end() && !m["Inner"].empty()) {
      inner = make_shared<bool>(boost::any_cast<bool>(m["Inner"]));
    }
    if (m.find("MemstoreReadRows") != m.end() && !m["MemstoreReadRows"].empty()) {
      memstoreReadRows = make_shared<double>(boost::any_cast<double>(m["MemstoreReadRows"]));
    }
    if (m.find("NetTime") != m.end() && !m["NetTime"].empty()) {
      netTime = make_shared<double>(boost::any_cast<double>(m["NetTime"]));
    }
    if (m.find("NetWaitTime") != m.end() && !m["NetWaitTime"].empty()) {
      netWaitTime = make_shared<double>(boost::any_cast<double>(m["NetWaitTime"]));
    }
    if (m.find("ObDbId") != m.end() && !m["ObDbId"].empty()) {
      obDbId = make_shared<double>(boost::any_cast<double>(m["ObDbId"]));
    }
    if (m.find("ObServerId") != m.end() && !m["ObServerId"].empty()) {
      obServerId = make_shared<double>(boost::any_cast<double>(m["ObServerId"]));
    }
    if (m.find("ObUserId") != m.end() && !m["ObUserId"].empty()) {
      obUserId = make_shared<double>(boost::any_cast<double>(m["ObUserId"]));
    }
    if (m.find("PartitionCount") != m.end() && !m["PartitionCount"].empty()) {
      partitionCount = make_shared<double>(boost::any_cast<double>(m["PartitionCount"]));
    }
    if (m.find("PlanId") != m.end() && !m["PlanId"].empty()) {
      planId = make_shared<double>(boost::any_cast<double>(m["PlanId"]));
    }
    if (m.find("PlanType") != m.end() && !m["PlanType"].empty()) {
      planType = make_shared<string>(boost::any_cast<string>(m["PlanType"]));
    }
    if (m.find("QueueTime") != m.end() && !m["QueueTime"].empty()) {
      queueTime = make_shared<double>(boost::any_cast<double>(m["QueueTime"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("RequestTime") != m.end() && !m["RequestTime"].empty()) {
      requestTime = make_shared<string>(boost::any_cast<string>(m["RequestTime"]));
    }
    if (m.find("RetCode") != m.end() && !m["RetCode"].empty()) {
      retCode = make_shared<double>(boost::any_cast<double>(m["RetCode"]));
    }
    if (m.find("RetryCount") != m.end() && !m["RetryCount"].empty()) {
      retryCount = make_shared<double>(boost::any_cast<double>(m["RetryCount"]));
    }
    if (m.find("ReturnRows") != m.end() && !m["ReturnRows"].empty()) {
      returnRows = make_shared<double>(boost::any_cast<double>(m["ReturnRows"]));
    }
    if (m.find("RowCacheHit") != m.end() && !m["RowCacheHit"].empty()) {
      rowCacheHit = make_shared<double>(boost::any_cast<double>(m["RowCacheHit"]));
    }
    if (m.find("RpcCount") != m.end() && !m["RpcCount"].empty()) {
      rpcCount = make_shared<double>(boost::any_cast<double>(m["RpcCount"]));
    }
    if (m.find("ScheduleTime") != m.end() && !m["ScheduleTime"].empty()) {
      scheduleTime = make_shared<double>(boost::any_cast<double>(m["ScheduleTime"]));
    }
    if (m.find("Server") != m.end() && !m["Server"].empty()) {
      server = make_shared<string>(boost::any_cast<string>(m["Server"]));
    }
    if (m.find("SqlType") != m.end() && !m["SqlType"].empty()) {
      sqlType = make_shared<string>(boost::any_cast<string>(m["SqlType"]));
    }
    if (m.find("SsstoreReadRows") != m.end() && !m["SsstoreReadRows"].empty()) {
      ssstoreReadRows = make_shared<double>(boost::any_cast<double>(m["SsstoreReadRows"]));
    }
    if (m.find("Statement") != m.end() && !m["Statement"].empty()) {
      statement = make_shared<string>(boost::any_cast<string>(m["Statement"]));
    }
    if (m.find("TableScan") != m.end() && !m["TableScan"].empty()) {
      tableScan = make_shared<bool>(boost::any_cast<bool>(m["TableScan"]));
    }
    if (m.find("TraceId") != m.end() && !m["TraceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["TraceId"]));
    }
    if (m.find("TransHash") != m.end() && !m["TransHash"].empty()) {
      transHash = make_shared<string>(boost::any_cast<string>(m["TransHash"]));
    }
    if (m.find("UsedWorkerCount") != m.end() && !m["UsedWorkerCount"].empty()) {
      usedWorkerCount = make_shared<double>(boost::any_cast<double>(m["UsedWorkerCount"]));
    }
    if (m.find("UserIoWaitTime") != m.end() && !m["UserIoWaitTime"].empty()) {
      userIoWaitTime = make_shared<double>(boost::any_cast<double>(m["UserIoWaitTime"]));
    }
    if (m.find("UserName") != m.end() && !m["UserName"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["UserName"]));
    }
    if (m.find("WaitCount") != m.end() && !m["WaitCount"].empty()) {
      waitCount = make_shared<double>(boost::any_cast<double>(m["WaitCount"]));
    }
    if (m.find("WaitEvent") != m.end() && !m["WaitEvent"].empty()) {
      waitEvent = make_shared<string>(boost::any_cast<string>(m["WaitEvent"]));
    }
    if (m.find("WaitTime") != m.end() && !m["WaitTime"].empty()) {
      waitTime = make_shared<double>(boost::any_cast<double>(m["WaitTime"]));
    }
  }


  virtual ~DescribeSQLSamplesResponseBodyData() = default;
};
class DescribeSQLSamplesResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeSQLSamplesResponseBodyData>> data{};
  shared_ptr<string> requestId{};

  DescribeSQLSamplesResponseBody() {}

  explicit DescribeSQLSamplesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<DescribeSQLSamplesResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeSQLSamplesResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<DescribeSQLSamplesResponseBodyData>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeSQLSamplesResponseBody() = default;
};
class DescribeSQLSamplesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeSQLSamplesResponseBody> body{};

  DescribeSQLSamplesResponse() {}

  explicit DescribeSQLSamplesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeSQLSamplesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeSQLSamplesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeSQLSamplesResponse() = default;
};
class DescribeSampleSqlRawTextsRequest : public Darabonba::Model {
public:
  shared_ptr<string> dbName{};
  shared_ptr<string> endTime{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> limit{};
  shared_ptr<string> sqlId{};
  shared_ptr<string> startTime{};
  shared_ptr<string> tenantId{};
  shared_ptr<string> traceId{};

  DescribeSampleSqlRawTextsRequest() {}

  explicit DescribeSampleSqlRawTextsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dbName) {
      res["DbName"] = boost::any(*dbName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (limit) {
      res["Limit"] = boost::any(*limit);
    }
    if (sqlId) {
      res["SqlId"] = boost::any(*sqlId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    if (traceId) {
      res["TraceId"] = boost::any(*traceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DbName") != m.end() && !m["DbName"].empty()) {
      dbName = make_shared<string>(boost::any_cast<string>(m["DbName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Limit") != m.end() && !m["Limit"].empty()) {
      limit = make_shared<string>(boost::any_cast<string>(m["Limit"]));
    }
    if (m.find("SqlId") != m.end() && !m["SqlId"].empty()) {
      sqlId = make_shared<string>(boost::any_cast<string>(m["SqlId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["TenantId"]));
    }
    if (m.find("TraceId") != m.end() && !m["TraceId"].empty()) {
      traceId = make_shared<string>(boost::any_cast<string>(m["TraceId"]));
    }
  }


  virtual ~DescribeSampleSqlRawTextsRequest() = default;
};
class DescribeSampleSqlRawTextsResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<string>> sqlText{};

  DescribeSampleSqlRawTextsResponseBodyData() {}

  explicit DescribeSampleSqlRawTextsResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sqlText) {
      res["SqlText"] = boost::any(*sqlText);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SqlText") != m.end() && !m["SqlText"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SqlText"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SqlText"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      sqlText = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeSampleSqlRawTextsResponseBodyData() = default;
};
class DescribeSampleSqlRawTextsResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeSampleSqlRawTextsResponseBodyData> data{};
  shared_ptr<string> requestId{};

  DescribeSampleSqlRawTextsResponseBody() {}

  explicit DescribeSampleSqlRawTextsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        DescribeSampleSqlRawTextsResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<DescribeSampleSqlRawTextsResponseBodyData>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeSampleSqlRawTextsResponseBody() = default;
};
class DescribeSampleSqlRawTextsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeSampleSqlRawTextsResponseBody> body{};

  DescribeSampleSqlRawTextsResponse() {}

  explicit DescribeSampleSqlRawTextsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeSampleSqlRawTextsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeSampleSqlRawTextsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeSampleSqlRawTextsResponse() = default;
};
class DescribeSecurityIpGroupsRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};

  DescribeSecurityIpGroupsRequest() {}

  explicit DescribeSecurityIpGroupsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~DescribeSecurityIpGroupsRequest() = default;
};
class DescribeSecurityIpGroupsResponseBodySecurityIpGroups : public Darabonba::Model {
public:
  shared_ptr<string> securityIpGroupName{};
  shared_ptr<string> securityIps{};

  DescribeSecurityIpGroupsResponseBodySecurityIpGroups() {}

  explicit DescribeSecurityIpGroupsResponseBodySecurityIpGroups(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (securityIpGroupName) {
      res["SecurityIpGroupName"] = boost::any(*securityIpGroupName);
    }
    if (securityIps) {
      res["SecurityIps"] = boost::any(*securityIps);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SecurityIpGroupName") != m.end() && !m["SecurityIpGroupName"].empty()) {
      securityIpGroupName = make_shared<string>(boost::any_cast<string>(m["SecurityIpGroupName"]));
    }
    if (m.find("SecurityIps") != m.end() && !m["SecurityIps"].empty()) {
      securityIps = make_shared<string>(boost::any_cast<string>(m["SecurityIps"]));
    }
  }


  virtual ~DescribeSecurityIpGroupsResponseBodySecurityIpGroups() = default;
};
class DescribeSecurityIpGroupsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeSecurityIpGroupsResponseBodySecurityIpGroups>> securityIpGroups{};
  shared_ptr<long> totalCount{};

  DescribeSecurityIpGroupsResponseBody() {}

  explicit DescribeSecurityIpGroupsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (securityIpGroups) {
      vector<boost::any> temp1;
      for(auto item1:*securityIpGroups){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SecurityIpGroups"] = boost::any(temp1);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SecurityIpGroups") != m.end() && !m["SecurityIpGroups"].empty()) {
      if (typeid(vector<boost::any>) == m["SecurityIpGroups"].type()) {
        vector<DescribeSecurityIpGroupsResponseBodySecurityIpGroups> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SecurityIpGroups"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeSecurityIpGroupsResponseBodySecurityIpGroups model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        securityIpGroups = make_shared<vector<DescribeSecurityIpGroupsResponseBodySecurityIpGroups>>(expect1);
      }
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeSecurityIpGroupsResponseBody() = default;
};
class DescribeSecurityIpGroupsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeSecurityIpGroupsResponseBody> body{};

  DescribeSecurityIpGroupsResponse() {}

  explicit DescribeSecurityIpGroupsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeSecurityIpGroupsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeSecurityIpGroupsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeSecurityIpGroupsResponse() = default;
};
class DescribeSlowSQLHistoryListRequest : public Darabonba::Model {
public:
  shared_ptr<string> endTime{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> SQLId{};
  shared_ptr<string> startTime{};
  shared_ptr<string> tenantId{};

  DescribeSlowSQLHistoryListRequest() {}

  explicit DescribeSlowSQLHistoryListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (SQLId) {
      res["SQLId"] = boost::any(*SQLId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SQLId") != m.end() && !m["SQLId"].empty()) {
      SQLId = make_shared<string>(boost::any_cast<string>(m["SQLId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["TenantId"]));
    }
  }


  virtual ~DescribeSlowSQLHistoryListRequest() = default;
};
class DescribeSlowSQLHistoryListResponseBodySlowSQLHistoryListList : public Darabonba::Model {
public:
  shared_ptr<double> affectedRows{};
  shared_ptr<double> appWaitTime{};
  shared_ptr<double> blockCacheHit{};
  shared_ptr<double> blockIndexCacheHit{};
  shared_ptr<double> bloomFilterCacheHit{};
  shared_ptr<string> clientIp{};
  shared_ptr<double> concurrencyWaitTime{};
  shared_ptr<double> cpuTime{};
  shared_ptr<string> dbName{};
  shared_ptr<double> decodeTime{};
  shared_ptr<double> diskRead{};
  shared_ptr<double> elapsedTime{};
  shared_ptr<string> endTimeUTCString{};
  shared_ptr<string> event{};
  shared_ptr<double> execPerSecond{};
  shared_ptr<double> executeTime{};
  shared_ptr<double> executions{};
  shared_ptr<double> failTimes{};
  shared_ptr<double> getPlanTime{};
  shared_ptr<double> IOWaitTime{};
  shared_ptr<double> logicalRead{};
  shared_ptr<double> maxCpuTime{};
  shared_ptr<double> maxElapsedTime{};
  shared_ptr<double> memstoreReadRowCount{};
  shared_ptr<double> missPlans{};
  shared_ptr<double> netWaitTime{};
  shared_ptr<string> nodeIp{};
  shared_ptr<double> queueTime{};
  shared_ptr<double> RPCCount{};
  shared_ptr<double> remotePlans{};
  shared_ptr<double> retryCount{};
  shared_ptr<double> returnRows{};
  shared_ptr<double> rowCacheHit{};
  shared_ptr<double> scheduleTime{};
  shared_ptr<string> sqlId{};
  shared_ptr<string> sqlType{};
  shared_ptr<double> ssstoreReadRowCount{};
  shared_ptr<string> tenantName{};
  shared_ptr<double> totalWaitTime{};
  shared_ptr<string> userName{};

  DescribeSlowSQLHistoryListResponseBodySlowSQLHistoryListList() {}

  explicit DescribeSlowSQLHistoryListResponseBodySlowSQLHistoryListList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (affectedRows) {
      res["AffectedRows"] = boost::any(*affectedRows);
    }
    if (appWaitTime) {
      res["AppWaitTime"] = boost::any(*appWaitTime);
    }
    if (blockCacheHit) {
      res["BlockCacheHit"] = boost::any(*blockCacheHit);
    }
    if (blockIndexCacheHit) {
      res["BlockIndexCacheHit"] = boost::any(*blockIndexCacheHit);
    }
    if (bloomFilterCacheHit) {
      res["BloomFilterCacheHit"] = boost::any(*bloomFilterCacheHit);
    }
    if (clientIp) {
      res["ClientIp"] = boost::any(*clientIp);
    }
    if (concurrencyWaitTime) {
      res["ConcurrencyWaitTime"] = boost::any(*concurrencyWaitTime);
    }
    if (cpuTime) {
      res["CpuTime"] = boost::any(*cpuTime);
    }
    if (dbName) {
      res["DbName"] = boost::any(*dbName);
    }
    if (decodeTime) {
      res["DecodeTime"] = boost::any(*decodeTime);
    }
    if (diskRead) {
      res["DiskRead"] = boost::any(*diskRead);
    }
    if (elapsedTime) {
      res["ElapsedTime"] = boost::any(*elapsedTime);
    }
    if (endTimeUTCString) {
      res["EndTimeUTCString"] = boost::any(*endTimeUTCString);
    }
    if (event) {
      res["Event"] = boost::any(*event);
    }
    if (execPerSecond) {
      res["ExecPerSecond"] = boost::any(*execPerSecond);
    }
    if (executeTime) {
      res["ExecuteTime"] = boost::any(*executeTime);
    }
    if (executions) {
      res["Executions"] = boost::any(*executions);
    }
    if (failTimes) {
      res["FailTimes"] = boost::any(*failTimes);
    }
    if (getPlanTime) {
      res["GetPlanTime"] = boost::any(*getPlanTime);
    }
    if (IOWaitTime) {
      res["IOWaitTime"] = boost::any(*IOWaitTime);
    }
    if (logicalRead) {
      res["LogicalRead"] = boost::any(*logicalRead);
    }
    if (maxCpuTime) {
      res["MaxCpuTime"] = boost::any(*maxCpuTime);
    }
    if (maxElapsedTime) {
      res["MaxElapsedTime"] = boost::any(*maxElapsedTime);
    }
    if (memstoreReadRowCount) {
      res["MemstoreReadRowCount"] = boost::any(*memstoreReadRowCount);
    }
    if (missPlans) {
      res["MissPlans"] = boost::any(*missPlans);
    }
    if (netWaitTime) {
      res["NetWaitTime"] = boost::any(*netWaitTime);
    }
    if (nodeIp) {
      res["NodeIp"] = boost::any(*nodeIp);
    }
    if (queueTime) {
      res["QueueTime"] = boost::any(*queueTime);
    }
    if (RPCCount) {
      res["RPCCount"] = boost::any(*RPCCount);
    }
    if (remotePlans) {
      res["RemotePlans"] = boost::any(*remotePlans);
    }
    if (retryCount) {
      res["RetryCount"] = boost::any(*retryCount);
    }
    if (returnRows) {
      res["ReturnRows"] = boost::any(*returnRows);
    }
    if (rowCacheHit) {
      res["RowCacheHit"] = boost::any(*rowCacheHit);
    }
    if (scheduleTime) {
      res["ScheduleTime"] = boost::any(*scheduleTime);
    }
    if (sqlId) {
      res["SqlId"] = boost::any(*sqlId);
    }
    if (sqlType) {
      res["SqlType"] = boost::any(*sqlType);
    }
    if (ssstoreReadRowCount) {
      res["SsstoreReadRowCount"] = boost::any(*ssstoreReadRowCount);
    }
    if (tenantName) {
      res["TenantName"] = boost::any(*tenantName);
    }
    if (totalWaitTime) {
      res["TotalWaitTime"] = boost::any(*totalWaitTime);
    }
    if (userName) {
      res["UserName"] = boost::any(*userName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AffectedRows") != m.end() && !m["AffectedRows"].empty()) {
      affectedRows = make_shared<double>(boost::any_cast<double>(m["AffectedRows"]));
    }
    if (m.find("AppWaitTime") != m.end() && !m["AppWaitTime"].empty()) {
      appWaitTime = make_shared<double>(boost::any_cast<double>(m["AppWaitTime"]));
    }
    if (m.find("BlockCacheHit") != m.end() && !m["BlockCacheHit"].empty()) {
      blockCacheHit = make_shared<double>(boost::any_cast<double>(m["BlockCacheHit"]));
    }
    if (m.find("BlockIndexCacheHit") != m.end() && !m["BlockIndexCacheHit"].empty()) {
      blockIndexCacheHit = make_shared<double>(boost::any_cast<double>(m["BlockIndexCacheHit"]));
    }
    if (m.find("BloomFilterCacheHit") != m.end() && !m["BloomFilterCacheHit"].empty()) {
      bloomFilterCacheHit = make_shared<double>(boost::any_cast<double>(m["BloomFilterCacheHit"]));
    }
    if (m.find("ClientIp") != m.end() && !m["ClientIp"].empty()) {
      clientIp = make_shared<string>(boost::any_cast<string>(m["ClientIp"]));
    }
    if (m.find("ConcurrencyWaitTime") != m.end() && !m["ConcurrencyWaitTime"].empty()) {
      concurrencyWaitTime = make_shared<double>(boost::any_cast<double>(m["ConcurrencyWaitTime"]));
    }
    if (m.find("CpuTime") != m.end() && !m["CpuTime"].empty()) {
      cpuTime = make_shared<double>(boost::any_cast<double>(m["CpuTime"]));
    }
    if (m.find("DbName") != m.end() && !m["DbName"].empty()) {
      dbName = make_shared<string>(boost::any_cast<string>(m["DbName"]));
    }
    if (m.find("DecodeTime") != m.end() && !m["DecodeTime"].empty()) {
      decodeTime = make_shared<double>(boost::any_cast<double>(m["DecodeTime"]));
    }
    if (m.find("DiskRead") != m.end() && !m["DiskRead"].empty()) {
      diskRead = make_shared<double>(boost::any_cast<double>(m["DiskRead"]));
    }
    if (m.find("ElapsedTime") != m.end() && !m["ElapsedTime"].empty()) {
      elapsedTime = make_shared<double>(boost::any_cast<double>(m["ElapsedTime"]));
    }
    if (m.find("EndTimeUTCString") != m.end() && !m["EndTimeUTCString"].empty()) {
      endTimeUTCString = make_shared<string>(boost::any_cast<string>(m["EndTimeUTCString"]));
    }
    if (m.find("Event") != m.end() && !m["Event"].empty()) {
      event = make_shared<string>(boost::any_cast<string>(m["Event"]));
    }
    if (m.find("ExecPerSecond") != m.end() && !m["ExecPerSecond"].empty()) {
      execPerSecond = make_shared<double>(boost::any_cast<double>(m["ExecPerSecond"]));
    }
    if (m.find("ExecuteTime") != m.end() && !m["ExecuteTime"].empty()) {
      executeTime = make_shared<double>(boost::any_cast<double>(m["ExecuteTime"]));
    }
    if (m.find("Executions") != m.end() && !m["Executions"].empty()) {
      executions = make_shared<double>(boost::any_cast<double>(m["Executions"]));
    }
    if (m.find("FailTimes") != m.end() && !m["FailTimes"].empty()) {
      failTimes = make_shared<double>(boost::any_cast<double>(m["FailTimes"]));
    }
    if (m.find("GetPlanTime") != m.end() && !m["GetPlanTime"].empty()) {
      getPlanTime = make_shared<double>(boost::any_cast<double>(m["GetPlanTime"]));
    }
    if (m.find("IOWaitTime") != m.end() && !m["IOWaitTime"].empty()) {
      IOWaitTime = make_shared<double>(boost::any_cast<double>(m["IOWaitTime"]));
    }
    if (m.find("LogicalRead") != m.end() && !m["LogicalRead"].empty()) {
      logicalRead = make_shared<double>(boost::any_cast<double>(m["LogicalRead"]));
    }
    if (m.find("MaxCpuTime") != m.end() && !m["MaxCpuTime"].empty()) {
      maxCpuTime = make_shared<double>(boost::any_cast<double>(m["MaxCpuTime"]));
    }
    if (m.find("MaxElapsedTime") != m.end() && !m["MaxElapsedTime"].empty()) {
      maxElapsedTime = make_shared<double>(boost::any_cast<double>(m["MaxElapsedTime"]));
    }
    if (m.find("MemstoreReadRowCount") != m.end() && !m["MemstoreReadRowCount"].empty()) {
      memstoreReadRowCount = make_shared<double>(boost::any_cast<double>(m["MemstoreReadRowCount"]));
    }
    if (m.find("MissPlans") != m.end() && !m["MissPlans"].empty()) {
      missPlans = make_shared<double>(boost::any_cast<double>(m["MissPlans"]));
    }
    if (m.find("NetWaitTime") != m.end() && !m["NetWaitTime"].empty()) {
      netWaitTime = make_shared<double>(boost::any_cast<double>(m["NetWaitTime"]));
    }
    if (m.find("NodeIp") != m.end() && !m["NodeIp"].empty()) {
      nodeIp = make_shared<string>(boost::any_cast<string>(m["NodeIp"]));
    }
    if (m.find("QueueTime") != m.end() && !m["QueueTime"].empty()) {
      queueTime = make_shared<double>(boost::any_cast<double>(m["QueueTime"]));
    }
    if (m.find("RPCCount") != m.end() && !m["RPCCount"].empty()) {
      RPCCount = make_shared<double>(boost::any_cast<double>(m["RPCCount"]));
    }
    if (m.find("RemotePlans") != m.end() && !m["RemotePlans"].empty()) {
      remotePlans = make_shared<double>(boost::any_cast<double>(m["RemotePlans"]));
    }
    if (m.find("RetryCount") != m.end() && !m["RetryCount"].empty()) {
      retryCount = make_shared<double>(boost::any_cast<double>(m["RetryCount"]));
    }
    if (m.find("ReturnRows") != m.end() && !m["ReturnRows"].empty()) {
      returnRows = make_shared<double>(boost::any_cast<double>(m["ReturnRows"]));
    }
    if (m.find("RowCacheHit") != m.end() && !m["RowCacheHit"].empty()) {
      rowCacheHit = make_shared<double>(boost::any_cast<double>(m["RowCacheHit"]));
    }
    if (m.find("ScheduleTime") != m.end() && !m["ScheduleTime"].empty()) {
      scheduleTime = make_shared<double>(boost::any_cast<double>(m["ScheduleTime"]));
    }
    if (m.find("SqlId") != m.end() && !m["SqlId"].empty()) {
      sqlId = make_shared<string>(boost::any_cast<string>(m["SqlId"]));
    }
    if (m.find("SqlType") != m.end() && !m["SqlType"].empty()) {
      sqlType = make_shared<string>(boost::any_cast<string>(m["SqlType"]));
    }
    if (m.find("SsstoreReadRowCount") != m.end() && !m["SsstoreReadRowCount"].empty()) {
      ssstoreReadRowCount = make_shared<double>(boost::any_cast<double>(m["SsstoreReadRowCount"]));
    }
    if (m.find("TenantName") != m.end() && !m["TenantName"].empty()) {
      tenantName = make_shared<string>(boost::any_cast<string>(m["TenantName"]));
    }
    if (m.find("TotalWaitTime") != m.end() && !m["TotalWaitTime"].empty()) {
      totalWaitTime = make_shared<double>(boost::any_cast<double>(m["TotalWaitTime"]));
    }
    if (m.find("UserName") != m.end() && !m["UserName"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["UserName"]));
    }
  }


  virtual ~DescribeSlowSQLHistoryListResponseBodySlowSQLHistoryListList() = default;
};
class DescribeSlowSQLHistoryListResponseBodySlowSQLHistoryList : public Darabonba::Model {
public:
  shared_ptr<long> count{};
  shared_ptr<vector<DescribeSlowSQLHistoryListResponseBodySlowSQLHistoryListList>> list{};

  DescribeSlowSQLHistoryListResponseBodySlowSQLHistoryList() {}

  explicit DescribeSlowSQLHistoryListResponseBodySlowSQLHistoryList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (list) {
      vector<boost::any> temp1;
      for(auto item1:*list){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["List"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(vector<boost::any>) == m["List"].type()) {
        vector<DescribeSlowSQLHistoryListResponseBodySlowSQLHistoryListList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["List"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeSlowSQLHistoryListResponseBodySlowSQLHistoryListList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        list = make_shared<vector<DescribeSlowSQLHistoryListResponseBodySlowSQLHistoryListList>>(expect1);
      }
    }
  }


  virtual ~DescribeSlowSQLHistoryListResponseBodySlowSQLHistoryList() = default;
};
class DescribeSlowSQLHistoryListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeSlowSQLHistoryListResponseBodySlowSQLHistoryList> slowSQLHistoryList{};

  DescribeSlowSQLHistoryListResponseBody() {}

  explicit DescribeSlowSQLHistoryListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (slowSQLHistoryList) {
      res["SlowSQLHistoryList"] = slowSQLHistoryList ? boost::any(slowSQLHistoryList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SlowSQLHistoryList") != m.end() && !m["SlowSQLHistoryList"].empty()) {
      if (typeid(map<string, boost::any>) == m["SlowSQLHistoryList"].type()) {
        DescribeSlowSQLHistoryListResponseBodySlowSQLHistoryList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SlowSQLHistoryList"]));
        slowSQLHistoryList = make_shared<DescribeSlowSQLHistoryListResponseBodySlowSQLHistoryList>(model1);
      }
    }
  }


  virtual ~DescribeSlowSQLHistoryListResponseBody() = default;
};
class DescribeSlowSQLHistoryListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeSlowSQLHistoryListResponseBody> body{};

  DescribeSlowSQLHistoryListResponse() {}

  explicit DescribeSlowSQLHistoryListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeSlowSQLHistoryListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeSlowSQLHistoryListResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeSlowSQLHistoryListResponse() = default;
};
class DescribeSlowSQLListRequest : public Darabonba::Model {
public:
  shared_ptr<string> dbName{};
  shared_ptr<string> endTime{};
  shared_ptr<map<string, boost::any>> filterCondition{};
  shared_ptr<string> nodeIp{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> SQLId{};
  shared_ptr<string> searchKeyWord{};
  shared_ptr<string> searchParameter{};
  shared_ptr<string> searchRule{};
  shared_ptr<string> searchValue{};
  shared_ptr<string> sortColumn{};
  shared_ptr<string> sortOrder{};
  shared_ptr<string> startTime{};
  shared_ptr<string> tenantId{};

  DescribeSlowSQLListRequest() {}

  explicit DescribeSlowSQLListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dbName) {
      res["DbName"] = boost::any(*dbName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (filterCondition) {
      res["FilterCondition"] = boost::any(*filterCondition);
    }
    if (nodeIp) {
      res["NodeIp"] = boost::any(*nodeIp);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (SQLId) {
      res["SQLId"] = boost::any(*SQLId);
    }
    if (searchKeyWord) {
      res["SearchKeyWord"] = boost::any(*searchKeyWord);
    }
    if (searchParameter) {
      res["SearchParameter"] = boost::any(*searchParameter);
    }
    if (searchRule) {
      res["SearchRule"] = boost::any(*searchRule);
    }
    if (searchValue) {
      res["SearchValue"] = boost::any(*searchValue);
    }
    if (sortColumn) {
      res["SortColumn"] = boost::any(*sortColumn);
    }
    if (sortOrder) {
      res["SortOrder"] = boost::any(*sortOrder);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DbName") != m.end() && !m["DbName"].empty()) {
      dbName = make_shared<string>(boost::any_cast<string>(m["DbName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("FilterCondition") != m.end() && !m["FilterCondition"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["FilterCondition"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      filterCondition = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("NodeIp") != m.end() && !m["NodeIp"].empty()) {
      nodeIp = make_shared<string>(boost::any_cast<string>(m["NodeIp"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SQLId") != m.end() && !m["SQLId"].empty()) {
      SQLId = make_shared<string>(boost::any_cast<string>(m["SQLId"]));
    }
    if (m.find("SearchKeyWord") != m.end() && !m["SearchKeyWord"].empty()) {
      searchKeyWord = make_shared<string>(boost::any_cast<string>(m["SearchKeyWord"]));
    }
    if (m.find("SearchParameter") != m.end() && !m["SearchParameter"].empty()) {
      searchParameter = make_shared<string>(boost::any_cast<string>(m["SearchParameter"]));
    }
    if (m.find("SearchRule") != m.end() && !m["SearchRule"].empty()) {
      searchRule = make_shared<string>(boost::any_cast<string>(m["SearchRule"]));
    }
    if (m.find("SearchValue") != m.end() && !m["SearchValue"].empty()) {
      searchValue = make_shared<string>(boost::any_cast<string>(m["SearchValue"]));
    }
    if (m.find("SortColumn") != m.end() && !m["SortColumn"].empty()) {
      sortColumn = make_shared<string>(boost::any_cast<string>(m["SortColumn"]));
    }
    if (m.find("SortOrder") != m.end() && !m["SortOrder"].empty()) {
      sortOrder = make_shared<string>(boost::any_cast<string>(m["SortOrder"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["TenantId"]));
    }
  }


  virtual ~DescribeSlowSQLListRequest() = default;
};
class DescribeSlowSQLListShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> dbName{};
  shared_ptr<string> endTime{};
  shared_ptr<string> filterConditionShrink{};
  shared_ptr<string> nodeIp{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> SQLId{};
  shared_ptr<string> searchKeyWord{};
  shared_ptr<string> searchParameter{};
  shared_ptr<string> searchRule{};
  shared_ptr<string> searchValue{};
  shared_ptr<string> sortColumn{};
  shared_ptr<string> sortOrder{};
  shared_ptr<string> startTime{};
  shared_ptr<string> tenantId{};

  DescribeSlowSQLListShrinkRequest() {}

  explicit DescribeSlowSQLListShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dbName) {
      res["DbName"] = boost::any(*dbName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (filterConditionShrink) {
      res["FilterCondition"] = boost::any(*filterConditionShrink);
    }
    if (nodeIp) {
      res["NodeIp"] = boost::any(*nodeIp);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (SQLId) {
      res["SQLId"] = boost::any(*SQLId);
    }
    if (searchKeyWord) {
      res["SearchKeyWord"] = boost::any(*searchKeyWord);
    }
    if (searchParameter) {
      res["SearchParameter"] = boost::any(*searchParameter);
    }
    if (searchRule) {
      res["SearchRule"] = boost::any(*searchRule);
    }
    if (searchValue) {
      res["SearchValue"] = boost::any(*searchValue);
    }
    if (sortColumn) {
      res["SortColumn"] = boost::any(*sortColumn);
    }
    if (sortOrder) {
      res["SortOrder"] = boost::any(*sortOrder);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DbName") != m.end() && !m["DbName"].empty()) {
      dbName = make_shared<string>(boost::any_cast<string>(m["DbName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("FilterCondition") != m.end() && !m["FilterCondition"].empty()) {
      filterConditionShrink = make_shared<string>(boost::any_cast<string>(m["FilterCondition"]));
    }
    if (m.find("NodeIp") != m.end() && !m["NodeIp"].empty()) {
      nodeIp = make_shared<string>(boost::any_cast<string>(m["NodeIp"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SQLId") != m.end() && !m["SQLId"].empty()) {
      SQLId = make_shared<string>(boost::any_cast<string>(m["SQLId"]));
    }
    if (m.find("SearchKeyWord") != m.end() && !m["SearchKeyWord"].empty()) {
      searchKeyWord = make_shared<string>(boost::any_cast<string>(m["SearchKeyWord"]));
    }
    if (m.find("SearchParameter") != m.end() && !m["SearchParameter"].empty()) {
      searchParameter = make_shared<string>(boost::any_cast<string>(m["SearchParameter"]));
    }
    if (m.find("SearchRule") != m.end() && !m["SearchRule"].empty()) {
      searchRule = make_shared<string>(boost::any_cast<string>(m["SearchRule"]));
    }
    if (m.find("SearchValue") != m.end() && !m["SearchValue"].empty()) {
      searchValue = make_shared<string>(boost::any_cast<string>(m["SearchValue"]));
    }
    if (m.find("SortColumn") != m.end() && !m["SortColumn"].empty()) {
      sortColumn = make_shared<string>(boost::any_cast<string>(m["SortColumn"]));
    }
    if (m.find("SortOrder") != m.end() && !m["SortOrder"].empty()) {
      sortOrder = make_shared<string>(boost::any_cast<string>(m["SortOrder"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["TenantId"]));
    }
  }


  virtual ~DescribeSlowSQLListShrinkRequest() = default;
};
class DescribeSlowSQLListResponseBodySlowSQLList : public Darabonba::Model {
public:
  shared_ptr<long> affectedRows{};
  shared_ptr<double> appWaitTime{};
  shared_ptr<long> blockCacheHit{};
  shared_ptr<long> blockIndexCacheHit{};
  shared_ptr<long> bloomFilterCacheHit{};
  shared_ptr<string> clientIp{};
  shared_ptr<double> concurrencyWaitTime{};
  shared_ptr<double> cpuTime{};
  shared_ptr<string> dbName{};
  shared_ptr<double> decodeTime{};
  shared_ptr<long> diskRead{};
  shared_ptr<double> elapsedTime{};
  shared_ptr<string> event{};
  shared_ptr<double> execPerSecond{};
  shared_ptr<double> executeTime{};
  shared_ptr<long> executions{};
  shared_ptr<long> failTimes{};
  shared_ptr<double> getPlanTime{};
  shared_ptr<double> IOWaitTime{};
  shared_ptr<long> key{};
  shared_ptr<long> logicalRead{};
  shared_ptr<double> maxCpuTime{};
  shared_ptr<double> maxElapsedTime{};
  shared_ptr<long> memstoreReadRowCount{};
  shared_ptr<long> missPlans{};
  shared_ptr<double> netWaitTime{};
  shared_ptr<string> nodeIp{};
  shared_ptr<double> queueTime{};
  shared_ptr<long> RPCCount{};
  shared_ptr<long> remotePlans{};
  shared_ptr<long> retryCount{};
  shared_ptr<long> returnRows{};
  shared_ptr<long> rowCacheHit{};
  shared_ptr<string> SQLId{};
  shared_ptr<string> SQLText{};
  shared_ptr<long> SQLType{};
  shared_ptr<double> scheduleTime{};
  shared_ptr<long> ssstoreReadRowCount{};
  shared_ptr<double> totalWaitTime{};
  shared_ptr<string> userName{};

  DescribeSlowSQLListResponseBodySlowSQLList() {}

  explicit DescribeSlowSQLListResponseBodySlowSQLList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (affectedRows) {
      res["AffectedRows"] = boost::any(*affectedRows);
    }
    if (appWaitTime) {
      res["AppWaitTime"] = boost::any(*appWaitTime);
    }
    if (blockCacheHit) {
      res["BlockCacheHit"] = boost::any(*blockCacheHit);
    }
    if (blockIndexCacheHit) {
      res["BlockIndexCacheHit"] = boost::any(*blockIndexCacheHit);
    }
    if (bloomFilterCacheHit) {
      res["BloomFilterCacheHit"] = boost::any(*bloomFilterCacheHit);
    }
    if (clientIp) {
      res["ClientIp"] = boost::any(*clientIp);
    }
    if (concurrencyWaitTime) {
      res["ConcurrencyWaitTime"] = boost::any(*concurrencyWaitTime);
    }
    if (cpuTime) {
      res["CpuTime"] = boost::any(*cpuTime);
    }
    if (dbName) {
      res["DbName"] = boost::any(*dbName);
    }
    if (decodeTime) {
      res["DecodeTime"] = boost::any(*decodeTime);
    }
    if (diskRead) {
      res["DiskRead"] = boost::any(*diskRead);
    }
    if (elapsedTime) {
      res["ElapsedTime"] = boost::any(*elapsedTime);
    }
    if (event) {
      res["Event"] = boost::any(*event);
    }
    if (execPerSecond) {
      res["ExecPerSecond"] = boost::any(*execPerSecond);
    }
    if (executeTime) {
      res["ExecuteTime"] = boost::any(*executeTime);
    }
    if (executions) {
      res["Executions"] = boost::any(*executions);
    }
    if (failTimes) {
      res["FailTimes"] = boost::any(*failTimes);
    }
    if (getPlanTime) {
      res["GetPlanTime"] = boost::any(*getPlanTime);
    }
    if (IOWaitTime) {
      res["IOWaitTime"] = boost::any(*IOWaitTime);
    }
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (logicalRead) {
      res["LogicalRead"] = boost::any(*logicalRead);
    }
    if (maxCpuTime) {
      res["MaxCpuTime"] = boost::any(*maxCpuTime);
    }
    if (maxElapsedTime) {
      res["MaxElapsedTime"] = boost::any(*maxElapsedTime);
    }
    if (memstoreReadRowCount) {
      res["MemstoreReadRowCount"] = boost::any(*memstoreReadRowCount);
    }
    if (missPlans) {
      res["MissPlans"] = boost::any(*missPlans);
    }
    if (netWaitTime) {
      res["NetWaitTime"] = boost::any(*netWaitTime);
    }
    if (nodeIp) {
      res["NodeIp"] = boost::any(*nodeIp);
    }
    if (queueTime) {
      res["QueueTime"] = boost::any(*queueTime);
    }
    if (RPCCount) {
      res["RPCCount"] = boost::any(*RPCCount);
    }
    if (remotePlans) {
      res["RemotePlans"] = boost::any(*remotePlans);
    }
    if (retryCount) {
      res["RetryCount"] = boost::any(*retryCount);
    }
    if (returnRows) {
      res["ReturnRows"] = boost::any(*returnRows);
    }
    if (rowCacheHit) {
      res["RowCacheHit"] = boost::any(*rowCacheHit);
    }
    if (SQLId) {
      res["SQLId"] = boost::any(*SQLId);
    }
    if (SQLText) {
      res["SQLText"] = boost::any(*SQLText);
    }
    if (SQLType) {
      res["SQLType"] = boost::any(*SQLType);
    }
    if (scheduleTime) {
      res["ScheduleTime"] = boost::any(*scheduleTime);
    }
    if (ssstoreReadRowCount) {
      res["SsstoreReadRowCount"] = boost::any(*ssstoreReadRowCount);
    }
    if (totalWaitTime) {
      res["TotalWaitTime"] = boost::any(*totalWaitTime);
    }
    if (userName) {
      res["UserName"] = boost::any(*userName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AffectedRows") != m.end() && !m["AffectedRows"].empty()) {
      affectedRows = make_shared<long>(boost::any_cast<long>(m["AffectedRows"]));
    }
    if (m.find("AppWaitTime") != m.end() && !m["AppWaitTime"].empty()) {
      appWaitTime = make_shared<double>(boost::any_cast<double>(m["AppWaitTime"]));
    }
    if (m.find("BlockCacheHit") != m.end() && !m["BlockCacheHit"].empty()) {
      blockCacheHit = make_shared<long>(boost::any_cast<long>(m["BlockCacheHit"]));
    }
    if (m.find("BlockIndexCacheHit") != m.end() && !m["BlockIndexCacheHit"].empty()) {
      blockIndexCacheHit = make_shared<long>(boost::any_cast<long>(m["BlockIndexCacheHit"]));
    }
    if (m.find("BloomFilterCacheHit") != m.end() && !m["BloomFilterCacheHit"].empty()) {
      bloomFilterCacheHit = make_shared<long>(boost::any_cast<long>(m["BloomFilterCacheHit"]));
    }
    if (m.find("ClientIp") != m.end() && !m["ClientIp"].empty()) {
      clientIp = make_shared<string>(boost::any_cast<string>(m["ClientIp"]));
    }
    if (m.find("ConcurrencyWaitTime") != m.end() && !m["ConcurrencyWaitTime"].empty()) {
      concurrencyWaitTime = make_shared<double>(boost::any_cast<double>(m["ConcurrencyWaitTime"]));
    }
    if (m.find("CpuTime") != m.end() && !m["CpuTime"].empty()) {
      cpuTime = make_shared<double>(boost::any_cast<double>(m["CpuTime"]));
    }
    if (m.find("DbName") != m.end() && !m["DbName"].empty()) {
      dbName = make_shared<string>(boost::any_cast<string>(m["DbName"]));
    }
    if (m.find("DecodeTime") != m.end() && !m["DecodeTime"].empty()) {
      decodeTime = make_shared<double>(boost::any_cast<double>(m["DecodeTime"]));
    }
    if (m.find("DiskRead") != m.end() && !m["DiskRead"].empty()) {
      diskRead = make_shared<long>(boost::any_cast<long>(m["DiskRead"]));
    }
    if (m.find("ElapsedTime") != m.end() && !m["ElapsedTime"].empty()) {
      elapsedTime = make_shared<double>(boost::any_cast<double>(m["ElapsedTime"]));
    }
    if (m.find("Event") != m.end() && !m["Event"].empty()) {
      event = make_shared<string>(boost::any_cast<string>(m["Event"]));
    }
    if (m.find("ExecPerSecond") != m.end() && !m["ExecPerSecond"].empty()) {
      execPerSecond = make_shared<double>(boost::any_cast<double>(m["ExecPerSecond"]));
    }
    if (m.find("ExecuteTime") != m.end() && !m["ExecuteTime"].empty()) {
      executeTime = make_shared<double>(boost::any_cast<double>(m["ExecuteTime"]));
    }
    if (m.find("Executions") != m.end() && !m["Executions"].empty()) {
      executions = make_shared<long>(boost::any_cast<long>(m["Executions"]));
    }
    if (m.find("FailTimes") != m.end() && !m["FailTimes"].empty()) {
      failTimes = make_shared<long>(boost::any_cast<long>(m["FailTimes"]));
    }
    if (m.find("GetPlanTime") != m.end() && !m["GetPlanTime"].empty()) {
      getPlanTime = make_shared<double>(boost::any_cast<double>(m["GetPlanTime"]));
    }
    if (m.find("IOWaitTime") != m.end() && !m["IOWaitTime"].empty()) {
      IOWaitTime = make_shared<double>(boost::any_cast<double>(m["IOWaitTime"]));
    }
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<long>(boost::any_cast<long>(m["Key"]));
    }
    if (m.find("LogicalRead") != m.end() && !m["LogicalRead"].empty()) {
      logicalRead = make_shared<long>(boost::any_cast<long>(m["LogicalRead"]));
    }
    if (m.find("MaxCpuTime") != m.end() && !m["MaxCpuTime"].empty()) {
      maxCpuTime = make_shared<double>(boost::any_cast<double>(m["MaxCpuTime"]));
    }
    if (m.find("MaxElapsedTime") != m.end() && !m["MaxElapsedTime"].empty()) {
      maxElapsedTime = make_shared<double>(boost::any_cast<double>(m["MaxElapsedTime"]));
    }
    if (m.find("MemstoreReadRowCount") != m.end() && !m["MemstoreReadRowCount"].empty()) {
      memstoreReadRowCount = make_shared<long>(boost::any_cast<long>(m["MemstoreReadRowCount"]));
    }
    if (m.find("MissPlans") != m.end() && !m["MissPlans"].empty()) {
      missPlans = make_shared<long>(boost::any_cast<long>(m["MissPlans"]));
    }
    if (m.find("NetWaitTime") != m.end() && !m["NetWaitTime"].empty()) {
      netWaitTime = make_shared<double>(boost::any_cast<double>(m["NetWaitTime"]));
    }
    if (m.find("NodeIp") != m.end() && !m["NodeIp"].empty()) {
      nodeIp = make_shared<string>(boost::any_cast<string>(m["NodeIp"]));
    }
    if (m.find("QueueTime") != m.end() && !m["QueueTime"].empty()) {
      queueTime = make_shared<double>(boost::any_cast<double>(m["QueueTime"]));
    }
    if (m.find("RPCCount") != m.end() && !m["RPCCount"].empty()) {
      RPCCount = make_shared<long>(boost::any_cast<long>(m["RPCCount"]));
    }
    if (m.find("RemotePlans") != m.end() && !m["RemotePlans"].empty()) {
      remotePlans = make_shared<long>(boost::any_cast<long>(m["RemotePlans"]));
    }
    if (m.find("RetryCount") != m.end() && !m["RetryCount"].empty()) {
      retryCount = make_shared<long>(boost::any_cast<long>(m["RetryCount"]));
    }
    if (m.find("ReturnRows") != m.end() && !m["ReturnRows"].empty()) {
      returnRows = make_shared<long>(boost::any_cast<long>(m["ReturnRows"]));
    }
    if (m.find("RowCacheHit") != m.end() && !m["RowCacheHit"].empty()) {
      rowCacheHit = make_shared<long>(boost::any_cast<long>(m["RowCacheHit"]));
    }
    if (m.find("SQLId") != m.end() && !m["SQLId"].empty()) {
      SQLId = make_shared<string>(boost::any_cast<string>(m["SQLId"]));
    }
    if (m.find("SQLText") != m.end() && !m["SQLText"].empty()) {
      SQLText = make_shared<string>(boost::any_cast<string>(m["SQLText"]));
    }
    if (m.find("SQLType") != m.end() && !m["SQLType"].empty()) {
      SQLType = make_shared<long>(boost::any_cast<long>(m["SQLType"]));
    }
    if (m.find("ScheduleTime") != m.end() && !m["ScheduleTime"].empty()) {
      scheduleTime = make_shared<double>(boost::any_cast<double>(m["ScheduleTime"]));
    }
    if (m.find("SsstoreReadRowCount") != m.end() && !m["SsstoreReadRowCount"].empty()) {
      ssstoreReadRowCount = make_shared<long>(boost::any_cast<long>(m["SsstoreReadRowCount"]));
    }
    if (m.find("TotalWaitTime") != m.end() && !m["TotalWaitTime"].empty()) {
      totalWaitTime = make_shared<double>(boost::any_cast<double>(m["TotalWaitTime"]));
    }
    if (m.find("UserName") != m.end() && !m["UserName"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["UserName"]));
    }
  }


  virtual ~DescribeSlowSQLListResponseBodySlowSQLList() = default;
};
class DescribeSlowSQLListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeSlowSQLListResponseBodySlowSQLList>> slowSQLList{};
  shared_ptr<long> totalCount{};

  DescribeSlowSQLListResponseBody() {}

  explicit DescribeSlowSQLListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (slowSQLList) {
      vector<boost::any> temp1;
      for(auto item1:*slowSQLList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SlowSQLList"] = boost::any(temp1);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SlowSQLList") != m.end() && !m["SlowSQLList"].empty()) {
      if (typeid(vector<boost::any>) == m["SlowSQLList"].type()) {
        vector<DescribeSlowSQLListResponseBodySlowSQLList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SlowSQLList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeSlowSQLListResponseBodySlowSQLList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        slowSQLList = make_shared<vector<DescribeSlowSQLListResponseBodySlowSQLList>>(expect1);
      }
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeSlowSQLListResponseBody() = default;
};
class DescribeSlowSQLListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeSlowSQLListResponseBody> body{};

  DescribeSlowSQLListResponse() {}

  explicit DescribeSlowSQLListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeSlowSQLListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeSlowSQLListResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeSlowSQLListResponse() = default;
};
class DescribeTenantRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> tenantId{};

  DescribeTenantRequest() {}

  explicit DescribeTenantRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["TenantId"]));
    }
  }


  virtual ~DescribeTenantRequest() = default;
};
class DescribeTenantResponseBodyTenantReadOnlyResourceCapacityUnit : public Darabonba::Model {
public:
  shared_ptr<long> maxCapacityUnit{};
  shared_ptr<long> minCapacityUnit{};
  shared_ptr<long> usedCapacit{};

  DescribeTenantResponseBodyTenantReadOnlyResourceCapacityUnit() {}

  explicit DescribeTenantResponseBodyTenantReadOnlyResourceCapacityUnit(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (maxCapacityUnit) {
      res["MaxCapacityUnit"] = boost::any(*maxCapacityUnit);
    }
    if (minCapacityUnit) {
      res["MinCapacityUnit"] = boost::any(*minCapacityUnit);
    }
    if (usedCapacit) {
      res["UsedCapacit"] = boost::any(*usedCapacit);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MaxCapacityUnit") != m.end() && !m["MaxCapacityUnit"].empty()) {
      maxCapacityUnit = make_shared<long>(boost::any_cast<long>(m["MaxCapacityUnit"]));
    }
    if (m.find("MinCapacityUnit") != m.end() && !m["MinCapacityUnit"].empty()) {
      minCapacityUnit = make_shared<long>(boost::any_cast<long>(m["MinCapacityUnit"]));
    }
    if (m.find("UsedCapacit") != m.end() && !m["UsedCapacit"].empty()) {
      usedCapacit = make_shared<long>(boost::any_cast<long>(m["UsedCapacit"]));
    }
  }


  virtual ~DescribeTenantResponseBodyTenantReadOnlyResourceCapacityUnit() = default;
};
class DescribeTenantResponseBodyTenantReadOnlyResourceCpu : public Darabonba::Model {
public:
  shared_ptr<double> totalCpu{};
  shared_ptr<double> unitCpu{};
  shared_ptr<double> usedCpu{};

  DescribeTenantResponseBodyTenantReadOnlyResourceCpu() {}

  explicit DescribeTenantResponseBodyTenantReadOnlyResourceCpu(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (totalCpu) {
      res["TotalCpu"] = boost::any(*totalCpu);
    }
    if (unitCpu) {
      res["UnitCpu"] = boost::any(*unitCpu);
    }
    if (usedCpu) {
      res["UsedCpu"] = boost::any(*usedCpu);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TotalCpu") != m.end() && !m["TotalCpu"].empty()) {
      totalCpu = make_shared<double>(boost::any_cast<double>(m["TotalCpu"]));
    }
    if (m.find("UnitCpu") != m.end() && !m["UnitCpu"].empty()) {
      unitCpu = make_shared<double>(boost::any_cast<double>(m["UnitCpu"]));
    }
    if (m.find("UsedCpu") != m.end() && !m["UsedCpu"].empty()) {
      usedCpu = make_shared<double>(boost::any_cast<double>(m["UsedCpu"]));
    }
  }


  virtual ~DescribeTenantResponseBodyTenantReadOnlyResourceCpu() = default;
};
class DescribeTenantResponseBodyTenantReadOnlyResourceDiskSize : public Darabonba::Model {
public:
  shared_ptr<double> usedDiskSize{};

  DescribeTenantResponseBodyTenantReadOnlyResourceDiskSize() {}

  explicit DescribeTenantResponseBodyTenantReadOnlyResourceDiskSize(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (usedDiskSize) {
      res["UsedDiskSize"] = boost::any(*usedDiskSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("UsedDiskSize") != m.end() && !m["UsedDiskSize"].empty()) {
      usedDiskSize = make_shared<double>(boost::any_cast<double>(m["UsedDiskSize"]));
    }
  }


  virtual ~DescribeTenantResponseBodyTenantReadOnlyResourceDiskSize() = default;
};
class DescribeTenantResponseBodyTenantReadOnlyResourceLogDiskSize : public Darabonba::Model {
public:
  shared_ptr<long> totalLogDisk{};
  shared_ptr<long> unitLogDisk{};

  DescribeTenantResponseBodyTenantReadOnlyResourceLogDiskSize() {}

  explicit DescribeTenantResponseBodyTenantReadOnlyResourceLogDiskSize(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (totalLogDisk) {
      res["TotalLogDisk"] = boost::any(*totalLogDisk);
    }
    if (unitLogDisk) {
      res["UnitLogDisk"] = boost::any(*unitLogDisk);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TotalLogDisk") != m.end() && !m["TotalLogDisk"].empty()) {
      totalLogDisk = make_shared<long>(boost::any_cast<long>(m["TotalLogDisk"]));
    }
    if (m.find("UnitLogDisk") != m.end() && !m["UnitLogDisk"].empty()) {
      unitLogDisk = make_shared<long>(boost::any_cast<long>(m["UnitLogDisk"]));
    }
  }


  virtual ~DescribeTenantResponseBodyTenantReadOnlyResourceLogDiskSize() = default;
};
class DescribeTenantResponseBodyTenantReadOnlyResourceMemory : public Darabonba::Model {
public:
  shared_ptr<double> totalMemory{};
  shared_ptr<double> unitMemory{};
  shared_ptr<double> usedMemory{};

  DescribeTenantResponseBodyTenantReadOnlyResourceMemory() {}

  explicit DescribeTenantResponseBodyTenantReadOnlyResourceMemory(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (totalMemory) {
      res["TotalMemory"] = boost::any(*totalMemory);
    }
    if (unitMemory) {
      res["UnitMemory"] = boost::any(*unitMemory);
    }
    if (usedMemory) {
      res["UsedMemory"] = boost::any(*usedMemory);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TotalMemory") != m.end() && !m["TotalMemory"].empty()) {
      totalMemory = make_shared<double>(boost::any_cast<double>(m["TotalMemory"]));
    }
    if (m.find("UnitMemory") != m.end() && !m["UnitMemory"].empty()) {
      unitMemory = make_shared<double>(boost::any_cast<double>(m["UnitMemory"]));
    }
    if (m.find("UsedMemory") != m.end() && !m["UsedMemory"].empty()) {
      usedMemory = make_shared<double>(boost::any_cast<double>(m["UsedMemory"]));
    }
  }


  virtual ~DescribeTenantResponseBodyTenantReadOnlyResourceMemory() = default;
};
class DescribeTenantResponseBodyTenantReadOnlyResource : public Darabonba::Model {
public:
  shared_ptr<DescribeTenantResponseBodyTenantReadOnlyResourceCapacityUnit> capacityUnit{};
  shared_ptr<DescribeTenantResponseBodyTenantReadOnlyResourceCpu> cpu{};
  shared_ptr<DescribeTenantResponseBodyTenantReadOnlyResourceDiskSize> diskSize{};
  shared_ptr<DescribeTenantResponseBodyTenantReadOnlyResourceLogDiskSize> logDiskSize{};
  shared_ptr<DescribeTenantResponseBodyTenantReadOnlyResourceMemory> memory{};
  shared_ptr<long> unitNum{};

  DescribeTenantResponseBodyTenantReadOnlyResource() {}

  explicit DescribeTenantResponseBodyTenantReadOnlyResource(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (capacityUnit) {
      res["CapacityUnit"] = capacityUnit ? boost::any(capacityUnit->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (cpu) {
      res["Cpu"] = cpu ? boost::any(cpu->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (diskSize) {
      res["DiskSize"] = diskSize ? boost::any(diskSize->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (logDiskSize) {
      res["LogDiskSize"] = logDiskSize ? boost::any(logDiskSize->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (memory) {
      res["Memory"] = memory ? boost::any(memory->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (unitNum) {
      res["UnitNum"] = boost::any(*unitNum);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CapacityUnit") != m.end() && !m["CapacityUnit"].empty()) {
      if (typeid(map<string, boost::any>) == m["CapacityUnit"].type()) {
        DescribeTenantResponseBodyTenantReadOnlyResourceCapacityUnit model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CapacityUnit"]));
        capacityUnit = make_shared<DescribeTenantResponseBodyTenantReadOnlyResourceCapacityUnit>(model1);
      }
    }
    if (m.find("Cpu") != m.end() && !m["Cpu"].empty()) {
      if (typeid(map<string, boost::any>) == m["Cpu"].type()) {
        DescribeTenantResponseBodyTenantReadOnlyResourceCpu model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Cpu"]));
        cpu = make_shared<DescribeTenantResponseBodyTenantReadOnlyResourceCpu>(model1);
      }
    }
    if (m.find("DiskSize") != m.end() && !m["DiskSize"].empty()) {
      if (typeid(map<string, boost::any>) == m["DiskSize"].type()) {
        DescribeTenantResponseBodyTenantReadOnlyResourceDiskSize model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DiskSize"]));
        diskSize = make_shared<DescribeTenantResponseBodyTenantReadOnlyResourceDiskSize>(model1);
      }
    }
    if (m.find("LogDiskSize") != m.end() && !m["LogDiskSize"].empty()) {
      if (typeid(map<string, boost::any>) == m["LogDiskSize"].type()) {
        DescribeTenantResponseBodyTenantReadOnlyResourceLogDiskSize model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LogDiskSize"]));
        logDiskSize = make_shared<DescribeTenantResponseBodyTenantReadOnlyResourceLogDiskSize>(model1);
      }
    }
    if (m.find("Memory") != m.end() && !m["Memory"].empty()) {
      if (typeid(map<string, boost::any>) == m["Memory"].type()) {
        DescribeTenantResponseBodyTenantReadOnlyResourceMemory model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Memory"]));
        memory = make_shared<DescribeTenantResponseBodyTenantReadOnlyResourceMemory>(model1);
      }
    }
    if (m.find("UnitNum") != m.end() && !m["UnitNum"].empty()) {
      unitNum = make_shared<long>(boost::any_cast<long>(m["UnitNum"]));
    }
  }


  virtual ~DescribeTenantResponseBodyTenantReadOnlyResource() = default;
};
class DescribeTenantResponseBodyTenantTenantConnections : public Darabonba::Model {
public:
  shared_ptr<string> addressType{};
  shared_ptr<string> connectionReplicaType{};
  shared_ptr<vector<string>> connectionZones{};
  shared_ptr<bool> enableTransactionSplit{};
  shared_ptr<string> internetAddress{};
  shared_ptr<string> internetAddressStatus{};
  shared_ptr<long> internetPort{};
  shared_ptr<string> intranetAddress{};
  shared_ptr<string> intranetAddressMasterZoneId{};
  shared_ptr<string> intranetAddressSlaveZoneId{};
  shared_ptr<string> intranetAddressStatus{};
  shared_ptr<long> intranetPort{};
  shared_ptr<long> maxConnectionNum{};
  shared_ptr<long> parallelQueryDegree{};
  shared_ptr<string> tenantEndpointId{};
  shared_ptr<bool> transactionSplit{};
  shared_ptr<string> vSwitchId{};
  shared_ptr<string> vpcId{};

  DescribeTenantResponseBodyTenantTenantConnections() {}

  explicit DescribeTenantResponseBodyTenantTenantConnections(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (addressType) {
      res["AddressType"] = boost::any(*addressType);
    }
    if (connectionReplicaType) {
      res["ConnectionReplicaType"] = boost::any(*connectionReplicaType);
    }
    if (connectionZones) {
      res["ConnectionZones"] = boost::any(*connectionZones);
    }
    if (enableTransactionSplit) {
      res["EnableTransactionSplit"] = boost::any(*enableTransactionSplit);
    }
    if (internetAddress) {
      res["InternetAddress"] = boost::any(*internetAddress);
    }
    if (internetAddressStatus) {
      res["InternetAddressStatus"] = boost::any(*internetAddressStatus);
    }
    if (internetPort) {
      res["InternetPort"] = boost::any(*internetPort);
    }
    if (intranetAddress) {
      res["IntranetAddress"] = boost::any(*intranetAddress);
    }
    if (intranetAddressMasterZoneId) {
      res["IntranetAddressMasterZoneId"] = boost::any(*intranetAddressMasterZoneId);
    }
    if (intranetAddressSlaveZoneId) {
      res["IntranetAddressSlaveZoneId"] = boost::any(*intranetAddressSlaveZoneId);
    }
    if (intranetAddressStatus) {
      res["IntranetAddressStatus"] = boost::any(*intranetAddressStatus);
    }
    if (intranetPort) {
      res["IntranetPort"] = boost::any(*intranetPort);
    }
    if (maxConnectionNum) {
      res["MaxConnectionNum"] = boost::any(*maxConnectionNum);
    }
    if (parallelQueryDegree) {
      res["ParallelQueryDegree"] = boost::any(*parallelQueryDegree);
    }
    if (tenantEndpointId) {
      res["TenantEndpointId"] = boost::any(*tenantEndpointId);
    }
    if (transactionSplit) {
      res["TransactionSplit"] = boost::any(*transactionSplit);
    }
    if (vSwitchId) {
      res["VSwitchId"] = boost::any(*vSwitchId);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AddressType") != m.end() && !m["AddressType"].empty()) {
      addressType = make_shared<string>(boost::any_cast<string>(m["AddressType"]));
    }
    if (m.find("ConnectionReplicaType") != m.end() && !m["ConnectionReplicaType"].empty()) {
      connectionReplicaType = make_shared<string>(boost::any_cast<string>(m["ConnectionReplicaType"]));
    }
    if (m.find("ConnectionZones") != m.end() && !m["ConnectionZones"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ConnectionZones"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ConnectionZones"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      connectionZones = make_shared<vector<string>>(toVec1);
    }
    if (m.find("EnableTransactionSplit") != m.end() && !m["EnableTransactionSplit"].empty()) {
      enableTransactionSplit = make_shared<bool>(boost::any_cast<bool>(m["EnableTransactionSplit"]));
    }
    if (m.find("InternetAddress") != m.end() && !m["InternetAddress"].empty()) {
      internetAddress = make_shared<string>(boost::any_cast<string>(m["InternetAddress"]));
    }
    if (m.find("InternetAddressStatus") != m.end() && !m["InternetAddressStatus"].empty()) {
      internetAddressStatus = make_shared<string>(boost::any_cast<string>(m["InternetAddressStatus"]));
    }
    if (m.find("InternetPort") != m.end() && !m["InternetPort"].empty()) {
      internetPort = make_shared<long>(boost::any_cast<long>(m["InternetPort"]));
    }
    if (m.find("IntranetAddress") != m.end() && !m["IntranetAddress"].empty()) {
      intranetAddress = make_shared<string>(boost::any_cast<string>(m["IntranetAddress"]));
    }
    if (m.find("IntranetAddressMasterZoneId") != m.end() && !m["IntranetAddressMasterZoneId"].empty()) {
      intranetAddressMasterZoneId = make_shared<string>(boost::any_cast<string>(m["IntranetAddressMasterZoneId"]));
    }
    if (m.find("IntranetAddressSlaveZoneId") != m.end() && !m["IntranetAddressSlaveZoneId"].empty()) {
      intranetAddressSlaveZoneId = make_shared<string>(boost::any_cast<string>(m["IntranetAddressSlaveZoneId"]));
    }
    if (m.find("IntranetAddressStatus") != m.end() && !m["IntranetAddressStatus"].empty()) {
      intranetAddressStatus = make_shared<string>(boost::any_cast<string>(m["IntranetAddressStatus"]));
    }
    if (m.find("IntranetPort") != m.end() && !m["IntranetPort"].empty()) {
      intranetPort = make_shared<long>(boost::any_cast<long>(m["IntranetPort"]));
    }
    if (m.find("MaxConnectionNum") != m.end() && !m["MaxConnectionNum"].empty()) {
      maxConnectionNum = make_shared<long>(boost::any_cast<long>(m["MaxConnectionNum"]));
    }
    if (m.find("ParallelQueryDegree") != m.end() && !m["ParallelQueryDegree"].empty()) {
      parallelQueryDegree = make_shared<long>(boost::any_cast<long>(m["ParallelQueryDegree"]));
    }
    if (m.find("TenantEndpointId") != m.end() && !m["TenantEndpointId"].empty()) {
      tenantEndpointId = make_shared<string>(boost::any_cast<string>(m["TenantEndpointId"]));
    }
    if (m.find("TransactionSplit") != m.end() && !m["TransactionSplit"].empty()) {
      transactionSplit = make_shared<bool>(boost::any_cast<bool>(m["TransactionSplit"]));
    }
    if (m.find("VSwitchId") != m.end() && !m["VSwitchId"].empty()) {
      vSwitchId = make_shared<string>(boost::any_cast<string>(m["VSwitchId"]));
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
  }


  virtual ~DescribeTenantResponseBodyTenantTenantConnections() = default;
};
class DescribeTenantResponseBodyTenantTenantResourceCapacityUnit : public Darabonba::Model {
public:
  shared_ptr<long> maxCapacityUnit{};
  shared_ptr<long> minCapacityUnit{};
  shared_ptr<long> usedCapacit{};

  DescribeTenantResponseBodyTenantTenantResourceCapacityUnit() {}

  explicit DescribeTenantResponseBodyTenantTenantResourceCapacityUnit(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (maxCapacityUnit) {
      res["MaxCapacityUnit"] = boost::any(*maxCapacityUnit);
    }
    if (minCapacityUnit) {
      res["MinCapacityUnit"] = boost::any(*minCapacityUnit);
    }
    if (usedCapacit) {
      res["UsedCapacit"] = boost::any(*usedCapacit);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MaxCapacityUnit") != m.end() && !m["MaxCapacityUnit"].empty()) {
      maxCapacityUnit = make_shared<long>(boost::any_cast<long>(m["MaxCapacityUnit"]));
    }
    if (m.find("MinCapacityUnit") != m.end() && !m["MinCapacityUnit"].empty()) {
      minCapacityUnit = make_shared<long>(boost::any_cast<long>(m["MinCapacityUnit"]));
    }
    if (m.find("UsedCapacit") != m.end() && !m["UsedCapacit"].empty()) {
      usedCapacit = make_shared<long>(boost::any_cast<long>(m["UsedCapacit"]));
    }
  }


  virtual ~DescribeTenantResponseBodyTenantTenantResourceCapacityUnit() = default;
};
class DescribeTenantResponseBodyTenantTenantResourceCpu : public Darabonba::Model {
public:
  shared_ptr<double> totalCpu{};
  shared_ptr<double> unitCpu{};
  shared_ptr<double> usedCpu{};

  DescribeTenantResponseBodyTenantTenantResourceCpu() {}

  explicit DescribeTenantResponseBodyTenantTenantResourceCpu(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (totalCpu) {
      res["TotalCpu"] = boost::any(*totalCpu);
    }
    if (unitCpu) {
      res["UnitCpu"] = boost::any(*unitCpu);
    }
    if (usedCpu) {
      res["UsedCpu"] = boost::any(*usedCpu);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TotalCpu") != m.end() && !m["TotalCpu"].empty()) {
      totalCpu = make_shared<double>(boost::any_cast<double>(m["TotalCpu"]));
    }
    if (m.find("UnitCpu") != m.end() && !m["UnitCpu"].empty()) {
      unitCpu = make_shared<double>(boost::any_cast<double>(m["UnitCpu"]));
    }
    if (m.find("UsedCpu") != m.end() && !m["UsedCpu"].empty()) {
      usedCpu = make_shared<double>(boost::any_cast<double>(m["UsedCpu"]));
    }
  }


  virtual ~DescribeTenantResponseBodyTenantTenantResourceCpu() = default;
};
class DescribeTenantResponseBodyTenantTenantResourceDiskSize : public Darabonba::Model {
public:
  shared_ptr<double> usedDiskSize{};

  DescribeTenantResponseBodyTenantTenantResourceDiskSize() {}

  explicit DescribeTenantResponseBodyTenantTenantResourceDiskSize(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (usedDiskSize) {
      res["UsedDiskSize"] = boost::any(*usedDiskSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("UsedDiskSize") != m.end() && !m["UsedDiskSize"].empty()) {
      usedDiskSize = make_shared<double>(boost::any_cast<double>(m["UsedDiskSize"]));
    }
  }


  virtual ~DescribeTenantResponseBodyTenantTenantResourceDiskSize() = default;
};
class DescribeTenantResponseBodyTenantTenantResourceLogDiskSize : public Darabonba::Model {
public:
  shared_ptr<long> totalLogDisk{};
  shared_ptr<long> unitLogDisk{};

  DescribeTenantResponseBodyTenantTenantResourceLogDiskSize() {}

  explicit DescribeTenantResponseBodyTenantTenantResourceLogDiskSize(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (totalLogDisk) {
      res["TotalLogDisk"] = boost::any(*totalLogDisk);
    }
    if (unitLogDisk) {
      res["UnitLogDisk"] = boost::any(*unitLogDisk);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TotalLogDisk") != m.end() && !m["TotalLogDisk"].empty()) {
      totalLogDisk = make_shared<long>(boost::any_cast<long>(m["TotalLogDisk"]));
    }
    if (m.find("UnitLogDisk") != m.end() && !m["UnitLogDisk"].empty()) {
      unitLogDisk = make_shared<long>(boost::any_cast<long>(m["UnitLogDisk"]));
    }
  }


  virtual ~DescribeTenantResponseBodyTenantTenantResourceLogDiskSize() = default;
};
class DescribeTenantResponseBodyTenantTenantResourceMemory : public Darabonba::Model {
public:
  shared_ptr<double> totalMemory{};
  shared_ptr<double> unitMemory{};
  shared_ptr<double> usedMemory{};

  DescribeTenantResponseBodyTenantTenantResourceMemory() {}

  explicit DescribeTenantResponseBodyTenantTenantResourceMemory(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (totalMemory) {
      res["TotalMemory"] = boost::any(*totalMemory);
    }
    if (unitMemory) {
      res["UnitMemory"] = boost::any(*unitMemory);
    }
    if (usedMemory) {
      res["UsedMemory"] = boost::any(*usedMemory);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TotalMemory") != m.end() && !m["TotalMemory"].empty()) {
      totalMemory = make_shared<double>(boost::any_cast<double>(m["TotalMemory"]));
    }
    if (m.find("UnitMemory") != m.end() && !m["UnitMemory"].empty()) {
      unitMemory = make_shared<double>(boost::any_cast<double>(m["UnitMemory"]));
    }
    if (m.find("UsedMemory") != m.end() && !m["UsedMemory"].empty()) {
      usedMemory = make_shared<double>(boost::any_cast<double>(m["UsedMemory"]));
    }
  }


  virtual ~DescribeTenantResponseBodyTenantTenantResourceMemory() = default;
};
class DescribeTenantResponseBodyTenantTenantResource : public Darabonba::Model {
public:
  shared_ptr<DescribeTenantResponseBodyTenantTenantResourceCapacityUnit> capacityUnit{};
  shared_ptr<DescribeTenantResponseBodyTenantTenantResourceCpu> cpu{};
  shared_ptr<DescribeTenantResponseBodyTenantTenantResourceDiskSize> diskSize{};
  shared_ptr<DescribeTenantResponseBodyTenantTenantResourceLogDiskSize> logDiskSize{};
  shared_ptr<DescribeTenantResponseBodyTenantTenantResourceMemory> memory{};
  shared_ptr<long> unitNum{};

  DescribeTenantResponseBodyTenantTenantResource() {}

  explicit DescribeTenantResponseBodyTenantTenantResource(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (capacityUnit) {
      res["CapacityUnit"] = capacityUnit ? boost::any(capacityUnit->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (cpu) {
      res["Cpu"] = cpu ? boost::any(cpu->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (diskSize) {
      res["DiskSize"] = diskSize ? boost::any(diskSize->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (logDiskSize) {
      res["LogDiskSize"] = logDiskSize ? boost::any(logDiskSize->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (memory) {
      res["Memory"] = memory ? boost::any(memory->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (unitNum) {
      res["UnitNum"] = boost::any(*unitNum);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CapacityUnit") != m.end() && !m["CapacityUnit"].empty()) {
      if (typeid(map<string, boost::any>) == m["CapacityUnit"].type()) {
        DescribeTenantResponseBodyTenantTenantResourceCapacityUnit model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CapacityUnit"]));
        capacityUnit = make_shared<DescribeTenantResponseBodyTenantTenantResourceCapacityUnit>(model1);
      }
    }
    if (m.find("Cpu") != m.end() && !m["Cpu"].empty()) {
      if (typeid(map<string, boost::any>) == m["Cpu"].type()) {
        DescribeTenantResponseBodyTenantTenantResourceCpu model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Cpu"]));
        cpu = make_shared<DescribeTenantResponseBodyTenantTenantResourceCpu>(model1);
      }
    }
    if (m.find("DiskSize") != m.end() && !m["DiskSize"].empty()) {
      if (typeid(map<string, boost::any>) == m["DiskSize"].type()) {
        DescribeTenantResponseBodyTenantTenantResourceDiskSize model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DiskSize"]));
        diskSize = make_shared<DescribeTenantResponseBodyTenantTenantResourceDiskSize>(model1);
      }
    }
    if (m.find("LogDiskSize") != m.end() && !m["LogDiskSize"].empty()) {
      if (typeid(map<string, boost::any>) == m["LogDiskSize"].type()) {
        DescribeTenantResponseBodyTenantTenantResourceLogDiskSize model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LogDiskSize"]));
        logDiskSize = make_shared<DescribeTenantResponseBodyTenantTenantResourceLogDiskSize>(model1);
      }
    }
    if (m.find("Memory") != m.end() && !m["Memory"].empty()) {
      if (typeid(map<string, boost::any>) == m["Memory"].type()) {
        DescribeTenantResponseBodyTenantTenantResourceMemory model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Memory"]));
        memory = make_shared<DescribeTenantResponseBodyTenantTenantResourceMemory>(model1);
      }
    }
    if (m.find("UnitNum") != m.end() && !m["UnitNum"].empty()) {
      unitNum = make_shared<long>(boost::any_cast<long>(m["UnitNum"]));
    }
  }


  virtual ~DescribeTenantResponseBodyTenantTenantResource() = default;
};
class DescribeTenantResponseBodyTenantTenantZonesTenantZoneReplicas : public Darabonba::Model {
public:
  shared_ptr<long> fullCopyId{};
  shared_ptr<string> logicZoneName{};
  shared_ptr<string> readOnlyCopyId{};
  shared_ptr<long> zoneCopyId{};
  shared_ptr<string> zoneNodes{};
  shared_ptr<string> zoneReplicaType{};

  DescribeTenantResponseBodyTenantTenantZonesTenantZoneReplicas() {}

  explicit DescribeTenantResponseBodyTenantTenantZonesTenantZoneReplicas(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fullCopyId) {
      res["FullCopyId"] = boost::any(*fullCopyId);
    }
    if (logicZoneName) {
      res["LogicZoneName"] = boost::any(*logicZoneName);
    }
    if (readOnlyCopyId) {
      res["ReadOnlyCopyId"] = boost::any(*readOnlyCopyId);
    }
    if (zoneCopyId) {
      res["ZoneCopyId"] = boost::any(*zoneCopyId);
    }
    if (zoneNodes) {
      res["ZoneNodes"] = boost::any(*zoneNodes);
    }
    if (zoneReplicaType) {
      res["ZoneReplicaType"] = boost::any(*zoneReplicaType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FullCopyId") != m.end() && !m["FullCopyId"].empty()) {
      fullCopyId = make_shared<long>(boost::any_cast<long>(m["FullCopyId"]));
    }
    if (m.find("LogicZoneName") != m.end() && !m["LogicZoneName"].empty()) {
      logicZoneName = make_shared<string>(boost::any_cast<string>(m["LogicZoneName"]));
    }
    if (m.find("ReadOnlyCopyId") != m.end() && !m["ReadOnlyCopyId"].empty()) {
      readOnlyCopyId = make_shared<string>(boost::any_cast<string>(m["ReadOnlyCopyId"]));
    }
    if (m.find("ZoneCopyId") != m.end() && !m["ZoneCopyId"].empty()) {
      zoneCopyId = make_shared<long>(boost::any_cast<long>(m["ZoneCopyId"]));
    }
    if (m.find("ZoneNodes") != m.end() && !m["ZoneNodes"].empty()) {
      zoneNodes = make_shared<string>(boost::any_cast<string>(m["ZoneNodes"]));
    }
    if (m.find("ZoneReplicaType") != m.end() && !m["ZoneReplicaType"].empty()) {
      zoneReplicaType = make_shared<string>(boost::any_cast<string>(m["ZoneReplicaType"]));
    }
  }


  virtual ~DescribeTenantResponseBodyTenantTenantZonesTenantZoneReplicas() = default;
};
class DescribeTenantResponseBodyTenantTenantZones : public Darabonba::Model {
public:
  shared_ptr<string> region{};
  shared_ptr<string> tenantZoneId{};
  shared_ptr<vector<DescribeTenantResponseBodyTenantTenantZonesTenantZoneReplicas>> tenantZoneReplicas{};
  shared_ptr<string> tenantZoneRole{};

  DescribeTenantResponseBodyTenantTenantZones() {}

  explicit DescribeTenantResponseBodyTenantTenantZones(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (tenantZoneId) {
      res["TenantZoneId"] = boost::any(*tenantZoneId);
    }
    if (tenantZoneReplicas) {
      vector<boost::any> temp1;
      for(auto item1:*tenantZoneReplicas){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TenantZoneReplicas"] = boost::any(temp1);
    }
    if (tenantZoneRole) {
      res["TenantZoneRole"] = boost::any(*tenantZoneRole);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("TenantZoneId") != m.end() && !m["TenantZoneId"].empty()) {
      tenantZoneId = make_shared<string>(boost::any_cast<string>(m["TenantZoneId"]));
    }
    if (m.find("TenantZoneReplicas") != m.end() && !m["TenantZoneReplicas"].empty()) {
      if (typeid(vector<boost::any>) == m["TenantZoneReplicas"].type()) {
        vector<DescribeTenantResponseBodyTenantTenantZonesTenantZoneReplicas> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TenantZoneReplicas"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeTenantResponseBodyTenantTenantZonesTenantZoneReplicas model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tenantZoneReplicas = make_shared<vector<DescribeTenantResponseBodyTenantTenantZonesTenantZoneReplicas>>(expect1);
      }
    }
    if (m.find("TenantZoneRole") != m.end() && !m["TenantZoneRole"].empty()) {
      tenantZoneRole = make_shared<string>(boost::any_cast<string>(m["TenantZoneRole"]));
    }
  }


  virtual ~DescribeTenantResponseBodyTenantTenantZones() = default;
};
class DescribeTenantResponseBodyTenant : public Darabonba::Model {
public:
  shared_ptr<vector<string>> availableZones{};
  shared_ptr<string> charset{};
  shared_ptr<string> clogServiceStatus{};
  shared_ptr<string> collation{};
  shared_ptr<string> createTime{};
  shared_ptr<string> dataMergeTime{};
  shared_ptr<string> deployMode{};
  shared_ptr<string> deployType{};
  shared_ptr<string> description{};
  shared_ptr<string> diskType{};
  shared_ptr<bool> enableBinlogService{};
  shared_ptr<bool> enableClogService{};
  shared_ptr<bool> enableInternetAddressService{};
  shared_ptr<bool> enableParallelQuery{};
  shared_ptr<bool> enableReadOnlyReplica{};
  shared_ptr<bool> enableReadWriteSplit{};
  shared_ptr<string> instanceType{};
  shared_ptr<string> masterIntranetAddressZone{};
  shared_ptr<long> maxParallelQueryDegree{};
  shared_ptr<string> payType{};
  shared_ptr<string> primaryZone{};
  shared_ptr<string> primaryZoneDeployType{};
  shared_ptr<DescribeTenantResponseBodyTenantReadOnlyResource> readOnlyResource{};
  shared_ptr<string> series{};
  shared_ptr<string> status{};
  shared_ptr<vector<DescribeTenantResponseBodyTenantTenantConnections>> tenantConnections{};
  shared_ptr<string> tenantId{};
  shared_ptr<string> tenantMode{};
  shared_ptr<string> tenantName{};
  shared_ptr<DescribeTenantResponseBodyTenantTenantResource> tenantResource{};
  shared_ptr<vector<DescribeTenantResponseBodyTenantTenantZones>> tenantZones{};
  shared_ptr<string> timeZone{};
  shared_ptr<string> vpcId{};

  DescribeTenantResponseBodyTenant() {}

  explicit DescribeTenantResponseBodyTenant(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (availableZones) {
      res["AvailableZones"] = boost::any(*availableZones);
    }
    if (charset) {
      res["Charset"] = boost::any(*charset);
    }
    if (clogServiceStatus) {
      res["ClogServiceStatus"] = boost::any(*clogServiceStatus);
    }
    if (collation) {
      res["Collation"] = boost::any(*collation);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (dataMergeTime) {
      res["DataMergeTime"] = boost::any(*dataMergeTime);
    }
    if (deployMode) {
      res["DeployMode"] = boost::any(*deployMode);
    }
    if (deployType) {
      res["DeployType"] = boost::any(*deployType);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (diskType) {
      res["DiskType"] = boost::any(*diskType);
    }
    if (enableBinlogService) {
      res["EnableBinlogService"] = boost::any(*enableBinlogService);
    }
    if (enableClogService) {
      res["EnableClogService"] = boost::any(*enableClogService);
    }
    if (enableInternetAddressService) {
      res["EnableInternetAddressService"] = boost::any(*enableInternetAddressService);
    }
    if (enableParallelQuery) {
      res["EnableParallelQuery"] = boost::any(*enableParallelQuery);
    }
    if (enableReadOnlyReplica) {
      res["EnableReadOnlyReplica"] = boost::any(*enableReadOnlyReplica);
    }
    if (enableReadWriteSplit) {
      res["EnableReadWriteSplit"] = boost::any(*enableReadWriteSplit);
    }
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (masterIntranetAddressZone) {
      res["MasterIntranetAddressZone"] = boost::any(*masterIntranetAddressZone);
    }
    if (maxParallelQueryDegree) {
      res["MaxParallelQueryDegree"] = boost::any(*maxParallelQueryDegree);
    }
    if (payType) {
      res["PayType"] = boost::any(*payType);
    }
    if (primaryZone) {
      res["PrimaryZone"] = boost::any(*primaryZone);
    }
    if (primaryZoneDeployType) {
      res["PrimaryZoneDeployType"] = boost::any(*primaryZoneDeployType);
    }
    if (readOnlyResource) {
      res["ReadOnlyResource"] = readOnlyResource ? boost::any(readOnlyResource->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (series) {
      res["Series"] = boost::any(*series);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (tenantConnections) {
      vector<boost::any> temp1;
      for(auto item1:*tenantConnections){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TenantConnections"] = boost::any(temp1);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    if (tenantMode) {
      res["TenantMode"] = boost::any(*tenantMode);
    }
    if (tenantName) {
      res["TenantName"] = boost::any(*tenantName);
    }
    if (tenantResource) {
      res["TenantResource"] = tenantResource ? boost::any(tenantResource->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (tenantZones) {
      vector<boost::any> temp1;
      for(auto item1:*tenantZones){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TenantZones"] = boost::any(temp1);
    }
    if (timeZone) {
      res["TimeZone"] = boost::any(*timeZone);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AvailableZones") != m.end() && !m["AvailableZones"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["AvailableZones"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["AvailableZones"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      availableZones = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Charset") != m.end() && !m["Charset"].empty()) {
      charset = make_shared<string>(boost::any_cast<string>(m["Charset"]));
    }
    if (m.find("ClogServiceStatus") != m.end() && !m["ClogServiceStatus"].empty()) {
      clogServiceStatus = make_shared<string>(boost::any_cast<string>(m["ClogServiceStatus"]));
    }
    if (m.find("Collation") != m.end() && !m["Collation"].empty()) {
      collation = make_shared<string>(boost::any_cast<string>(m["Collation"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("DataMergeTime") != m.end() && !m["DataMergeTime"].empty()) {
      dataMergeTime = make_shared<string>(boost::any_cast<string>(m["DataMergeTime"]));
    }
    if (m.find("DeployMode") != m.end() && !m["DeployMode"].empty()) {
      deployMode = make_shared<string>(boost::any_cast<string>(m["DeployMode"]));
    }
    if (m.find("DeployType") != m.end() && !m["DeployType"].empty()) {
      deployType = make_shared<string>(boost::any_cast<string>(m["DeployType"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DiskType") != m.end() && !m["DiskType"].empty()) {
      diskType = make_shared<string>(boost::any_cast<string>(m["DiskType"]));
    }
    if (m.find("EnableBinlogService") != m.end() && !m["EnableBinlogService"].empty()) {
      enableBinlogService = make_shared<bool>(boost::any_cast<bool>(m["EnableBinlogService"]));
    }
    if (m.find("EnableClogService") != m.end() && !m["EnableClogService"].empty()) {
      enableClogService = make_shared<bool>(boost::any_cast<bool>(m["EnableClogService"]));
    }
    if (m.find("EnableInternetAddressService") != m.end() && !m["EnableInternetAddressService"].empty()) {
      enableInternetAddressService = make_shared<bool>(boost::any_cast<bool>(m["EnableInternetAddressService"]));
    }
    if (m.find("EnableParallelQuery") != m.end() && !m["EnableParallelQuery"].empty()) {
      enableParallelQuery = make_shared<bool>(boost::any_cast<bool>(m["EnableParallelQuery"]));
    }
    if (m.find("EnableReadOnlyReplica") != m.end() && !m["EnableReadOnlyReplica"].empty()) {
      enableReadOnlyReplica = make_shared<bool>(boost::any_cast<bool>(m["EnableReadOnlyReplica"]));
    }
    if (m.find("EnableReadWriteSplit") != m.end() && !m["EnableReadWriteSplit"].empty()) {
      enableReadWriteSplit = make_shared<bool>(boost::any_cast<bool>(m["EnableReadWriteSplit"]));
    }
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("MasterIntranetAddressZone") != m.end() && !m["MasterIntranetAddressZone"].empty()) {
      masterIntranetAddressZone = make_shared<string>(boost::any_cast<string>(m["MasterIntranetAddressZone"]));
    }
    if (m.find("MaxParallelQueryDegree") != m.end() && !m["MaxParallelQueryDegree"].empty()) {
      maxParallelQueryDegree = make_shared<long>(boost::any_cast<long>(m["MaxParallelQueryDegree"]));
    }
    if (m.find("PayType") != m.end() && !m["PayType"].empty()) {
      payType = make_shared<string>(boost::any_cast<string>(m["PayType"]));
    }
    if (m.find("PrimaryZone") != m.end() && !m["PrimaryZone"].empty()) {
      primaryZone = make_shared<string>(boost::any_cast<string>(m["PrimaryZone"]));
    }
    if (m.find("PrimaryZoneDeployType") != m.end() && !m["PrimaryZoneDeployType"].empty()) {
      primaryZoneDeployType = make_shared<string>(boost::any_cast<string>(m["PrimaryZoneDeployType"]));
    }
    if (m.find("ReadOnlyResource") != m.end() && !m["ReadOnlyResource"].empty()) {
      if (typeid(map<string, boost::any>) == m["ReadOnlyResource"].type()) {
        DescribeTenantResponseBodyTenantReadOnlyResource model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ReadOnlyResource"]));
        readOnlyResource = make_shared<DescribeTenantResponseBodyTenantReadOnlyResource>(model1);
      }
    }
    if (m.find("Series") != m.end() && !m["Series"].empty()) {
      series = make_shared<string>(boost::any_cast<string>(m["Series"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("TenantConnections") != m.end() && !m["TenantConnections"].empty()) {
      if (typeid(vector<boost::any>) == m["TenantConnections"].type()) {
        vector<DescribeTenantResponseBodyTenantTenantConnections> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TenantConnections"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeTenantResponseBodyTenantTenantConnections model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tenantConnections = make_shared<vector<DescribeTenantResponseBodyTenantTenantConnections>>(expect1);
      }
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["TenantId"]));
    }
    if (m.find("TenantMode") != m.end() && !m["TenantMode"].empty()) {
      tenantMode = make_shared<string>(boost::any_cast<string>(m["TenantMode"]));
    }
    if (m.find("TenantName") != m.end() && !m["TenantName"].empty()) {
      tenantName = make_shared<string>(boost::any_cast<string>(m["TenantName"]));
    }
    if (m.find("TenantResource") != m.end() && !m["TenantResource"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantResource"].type()) {
        DescribeTenantResponseBodyTenantTenantResource model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantResource"]));
        tenantResource = make_shared<DescribeTenantResponseBodyTenantTenantResource>(model1);
      }
    }
    if (m.find("TenantZones") != m.end() && !m["TenantZones"].empty()) {
      if (typeid(vector<boost::any>) == m["TenantZones"].type()) {
        vector<DescribeTenantResponseBodyTenantTenantZones> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TenantZones"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeTenantResponseBodyTenantTenantZones model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tenantZones = make_shared<vector<DescribeTenantResponseBodyTenantTenantZones>>(expect1);
      }
    }
    if (m.find("TimeZone") != m.end() && !m["TimeZone"].empty()) {
      timeZone = make_shared<string>(boost::any_cast<string>(m["TimeZone"]));
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
  }


  virtual ~DescribeTenantResponseBodyTenant() = default;
};
class DescribeTenantResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeTenantResponseBodyTenant> tenant{};

  DescribeTenantResponseBody() {}

  explicit DescribeTenantResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (tenant) {
      res["Tenant"] = tenant ? boost::any(tenant->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Tenant") != m.end() && !m["Tenant"].empty()) {
      if (typeid(map<string, boost::any>) == m["Tenant"].type()) {
        DescribeTenantResponseBodyTenant model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Tenant"]));
        tenant = make_shared<DescribeTenantResponseBodyTenant>(model1);
      }
    }
  }


  virtual ~DescribeTenantResponseBody() = default;
};
class DescribeTenantResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeTenantResponseBody> body{};

  DescribeTenantResponse() {}

  explicit DescribeTenantResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeTenantResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeTenantResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeTenantResponse() = default;
};
class DescribeTenantEncryptionRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> tenantId{};
  shared_ptr<string> tenantName{};

  DescribeTenantEncryptionRequest() {}

  explicit DescribeTenantEncryptionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    if (tenantName) {
      res["TenantName"] = boost::any(*tenantName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["TenantId"]));
    }
    if (m.find("TenantName") != m.end() && !m["TenantName"].empty()) {
      tenantName = make_shared<string>(boost::any_cast<string>(m["TenantName"]));
    }
  }


  virtual ~DescribeTenantEncryptionRequest() = default;
};
class DescribeTenantEncryptionResponseBodyTenantEncryptions : public Darabonba::Model {
public:
  shared_ptr<bool> enableEncryption{};
  shared_ptr<string> encryptionKeyId{};
  shared_ptr<string> encryptionType{};
  shared_ptr<string> status{};
  shared_ptr<string> tenantId{};
  shared_ptr<string> tenantMode{};
  shared_ptr<string> tenantName{};
  shared_ptr<string> tenantStatus{};

  DescribeTenantEncryptionResponseBodyTenantEncryptions() {}

  explicit DescribeTenantEncryptionResponseBodyTenantEncryptions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (enableEncryption) {
      res["EnableEncryption"] = boost::any(*enableEncryption);
    }
    if (encryptionKeyId) {
      res["EncryptionKeyId"] = boost::any(*encryptionKeyId);
    }
    if (encryptionType) {
      res["EncryptionType"] = boost::any(*encryptionType);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    if (tenantMode) {
      res["TenantMode"] = boost::any(*tenantMode);
    }
    if (tenantName) {
      res["TenantName"] = boost::any(*tenantName);
    }
    if (tenantStatus) {
      res["TenantStatus"] = boost::any(*tenantStatus);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EnableEncryption") != m.end() && !m["EnableEncryption"].empty()) {
      enableEncryption = make_shared<bool>(boost::any_cast<bool>(m["EnableEncryption"]));
    }
    if (m.find("EncryptionKeyId") != m.end() && !m["EncryptionKeyId"].empty()) {
      encryptionKeyId = make_shared<string>(boost::any_cast<string>(m["EncryptionKeyId"]));
    }
    if (m.find("EncryptionType") != m.end() && !m["EncryptionType"].empty()) {
      encryptionType = make_shared<string>(boost::any_cast<string>(m["EncryptionType"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["TenantId"]));
    }
    if (m.find("TenantMode") != m.end() && !m["TenantMode"].empty()) {
      tenantMode = make_shared<string>(boost::any_cast<string>(m["TenantMode"]));
    }
    if (m.find("TenantName") != m.end() && !m["TenantName"].empty()) {
      tenantName = make_shared<string>(boost::any_cast<string>(m["TenantName"]));
    }
    if (m.find("TenantStatus") != m.end() && !m["TenantStatus"].empty()) {
      tenantStatus = make_shared<string>(boost::any_cast<string>(m["TenantStatus"]));
    }
  }


  virtual ~DescribeTenantEncryptionResponseBodyTenantEncryptions() = default;
};
class DescribeTenantEncryptionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeTenantEncryptionResponseBodyTenantEncryptions>> tenantEncryptions{};
  shared_ptr<long> totalCount{};

  DescribeTenantEncryptionResponseBody() {}

  explicit DescribeTenantEncryptionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (tenantEncryptions) {
      vector<boost::any> temp1;
      for(auto item1:*tenantEncryptions){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TenantEncryptions"] = boost::any(temp1);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TenantEncryptions") != m.end() && !m["TenantEncryptions"].empty()) {
      if (typeid(vector<boost::any>) == m["TenantEncryptions"].type()) {
        vector<DescribeTenantEncryptionResponseBodyTenantEncryptions> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TenantEncryptions"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeTenantEncryptionResponseBodyTenantEncryptions model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tenantEncryptions = make_shared<vector<DescribeTenantEncryptionResponseBodyTenantEncryptions>>(expect1);
      }
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeTenantEncryptionResponseBody() = default;
};
class DescribeTenantEncryptionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeTenantEncryptionResponseBody> body{};

  DescribeTenantEncryptionResponse() {}

  explicit DescribeTenantEncryptionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeTenantEncryptionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeTenantEncryptionResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeTenantEncryptionResponse() = default;
};
class DescribeTenantMetricsRequest : public Darabonba::Model {
public:
  shared_ptr<string> endTime{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> metrics{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> startTime{};
  shared_ptr<string> tenantId{};
  shared_ptr<string> tenantIdList{};
  shared_ptr<string> tenantName{};

  DescribeTenantMetricsRequest() {}

  explicit DescribeTenantMetricsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (metrics) {
      res["Metrics"] = boost::any(*metrics);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    if (tenantIdList) {
      res["TenantIdList"] = boost::any(*tenantIdList);
    }
    if (tenantName) {
      res["TenantName"] = boost::any(*tenantName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Metrics") != m.end() && !m["Metrics"].empty()) {
      metrics = make_shared<string>(boost::any_cast<string>(m["Metrics"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["TenantId"]));
    }
    if (m.find("TenantIdList") != m.end() && !m["TenantIdList"].empty()) {
      tenantIdList = make_shared<string>(boost::any_cast<string>(m["TenantIdList"]));
    }
    if (m.find("TenantName") != m.end() && !m["TenantName"].empty()) {
      tenantName = make_shared<string>(boost::any_cast<string>(m["TenantName"]));
    }
  }


  virtual ~DescribeTenantMetricsRequest() = default;
};
class DescribeTenantMetricsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> tenantMetrics{};
  shared_ptr<long> totalCount{};

  DescribeTenantMetricsResponseBody() {}

  explicit DescribeTenantMetricsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (tenantMetrics) {
      res["TenantMetrics"] = boost::any(*tenantMetrics);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TenantMetrics") != m.end() && !m["TenantMetrics"].empty()) {
      tenantMetrics = make_shared<string>(boost::any_cast<string>(m["TenantMetrics"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeTenantMetricsResponseBody() = default;
};
class DescribeTenantMetricsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeTenantMetricsResponseBody> body{};

  DescribeTenantMetricsResponse() {}

  explicit DescribeTenantMetricsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeTenantMetricsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeTenantMetricsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeTenantMetricsResponse() = default;
};
class DescribeTenantSecurityConfigsRequest : public Darabonba::Model {
public:
  shared_ptr<string> checkId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> tenantId{};

  DescribeTenantSecurityConfigsRequest() {}

  explicit DescribeTenantSecurityConfigsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (checkId) {
      res["CheckId"] = boost::any(*checkId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CheckId") != m.end() && !m["CheckId"].empty()) {
      checkId = make_shared<string>(boost::any_cast<string>(m["CheckId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["TenantId"]));
    }
  }


  virtual ~DescribeTenantSecurityConfigsRequest() = default;
};
class DescribeTenantSecurityConfigsResponseBodyConfigsTenantSecurityConfigsSecurityConfigs : public Darabonba::Model {
public:
  shared_ptr<string> configDescription{};
  shared_ptr<string> configGroup{};
  shared_ptr<string> configName{};
  shared_ptr<bool> risk{};
  shared_ptr<string> riskDescription{};

  DescribeTenantSecurityConfigsResponseBodyConfigsTenantSecurityConfigsSecurityConfigs() {}

  explicit DescribeTenantSecurityConfigsResponseBodyConfigsTenantSecurityConfigsSecurityConfigs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configDescription) {
      res["ConfigDescription"] = boost::any(*configDescription);
    }
    if (configGroup) {
      res["ConfigGroup"] = boost::any(*configGroup);
    }
    if (configName) {
      res["ConfigName"] = boost::any(*configName);
    }
    if (risk) {
      res["Risk"] = boost::any(*risk);
    }
    if (riskDescription) {
      res["RiskDescription"] = boost::any(*riskDescription);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigDescription") != m.end() && !m["ConfigDescription"].empty()) {
      configDescription = make_shared<string>(boost::any_cast<string>(m["ConfigDescription"]));
    }
    if (m.find("ConfigGroup") != m.end() && !m["ConfigGroup"].empty()) {
      configGroup = make_shared<string>(boost::any_cast<string>(m["ConfigGroup"]));
    }
    if (m.find("ConfigName") != m.end() && !m["ConfigName"].empty()) {
      configName = make_shared<string>(boost::any_cast<string>(m["ConfigName"]));
    }
    if (m.find("Risk") != m.end() && !m["Risk"].empty()) {
      risk = make_shared<bool>(boost::any_cast<bool>(m["Risk"]));
    }
    if (m.find("RiskDescription") != m.end() && !m["RiskDescription"].empty()) {
      riskDescription = make_shared<string>(boost::any_cast<string>(m["RiskDescription"]));
    }
  }


  virtual ~DescribeTenantSecurityConfigsResponseBodyConfigsTenantSecurityConfigsSecurityConfigs() = default;
};
class DescribeTenantSecurityConfigsResponseBodyConfigsTenantSecurityConfigs : public Darabonba::Model {
public:
  shared_ptr<long> riskCount{};
  shared_ptr<vector<DescribeTenantSecurityConfigsResponseBodyConfigsTenantSecurityConfigsSecurityConfigs>> securityConfigs{};
  shared_ptr<string> tenantId{};
  shared_ptr<string> tenantName{};

  DescribeTenantSecurityConfigsResponseBodyConfigsTenantSecurityConfigs() {}

  explicit DescribeTenantSecurityConfigsResponseBodyConfigsTenantSecurityConfigs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (riskCount) {
      res["RiskCount"] = boost::any(*riskCount);
    }
    if (securityConfigs) {
      vector<boost::any> temp1;
      for(auto item1:*securityConfigs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SecurityConfigs"] = boost::any(temp1);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    if (tenantName) {
      res["TenantName"] = boost::any(*tenantName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RiskCount") != m.end() && !m["RiskCount"].empty()) {
      riskCount = make_shared<long>(boost::any_cast<long>(m["RiskCount"]));
    }
    if (m.find("SecurityConfigs") != m.end() && !m["SecurityConfigs"].empty()) {
      if (typeid(vector<boost::any>) == m["SecurityConfigs"].type()) {
        vector<DescribeTenantSecurityConfigsResponseBodyConfigsTenantSecurityConfigsSecurityConfigs> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SecurityConfigs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeTenantSecurityConfigsResponseBodyConfigsTenantSecurityConfigsSecurityConfigs model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        securityConfigs = make_shared<vector<DescribeTenantSecurityConfigsResponseBodyConfigsTenantSecurityConfigsSecurityConfigs>>(expect1);
      }
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["TenantId"]));
    }
    if (m.find("TenantName") != m.end() && !m["TenantName"].empty()) {
      tenantName = make_shared<string>(boost::any_cast<string>(m["TenantName"]));
    }
  }


  virtual ~DescribeTenantSecurityConfigsResponseBodyConfigsTenantSecurityConfigs() = default;
};
class DescribeTenantSecurityConfigsResponseBodyConfigs : public Darabonba::Model {
public:
  shared_ptr<string> checkId{};
  shared_ptr<string> checkTime{};
  shared_ptr<string> instanceId{};
  shared_ptr<vector<DescribeTenantSecurityConfigsResponseBodyConfigsTenantSecurityConfigs>> tenantSecurityConfigs{};
  shared_ptr<long> totalCheckCount{};
  shared_ptr<long> totalRiskCount{};

  DescribeTenantSecurityConfigsResponseBodyConfigs() {}

  explicit DescribeTenantSecurityConfigsResponseBodyConfigs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (checkId) {
      res["CheckId"] = boost::any(*checkId);
    }
    if (checkTime) {
      res["CheckTime"] = boost::any(*checkTime);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (tenantSecurityConfigs) {
      vector<boost::any> temp1;
      for(auto item1:*tenantSecurityConfigs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TenantSecurityConfigs"] = boost::any(temp1);
    }
    if (totalCheckCount) {
      res["TotalCheckCount"] = boost::any(*totalCheckCount);
    }
    if (totalRiskCount) {
      res["TotalRiskCount"] = boost::any(*totalRiskCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CheckId") != m.end() && !m["CheckId"].empty()) {
      checkId = make_shared<string>(boost::any_cast<string>(m["CheckId"]));
    }
    if (m.find("CheckTime") != m.end() && !m["CheckTime"].empty()) {
      checkTime = make_shared<string>(boost::any_cast<string>(m["CheckTime"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("TenantSecurityConfigs") != m.end() && !m["TenantSecurityConfigs"].empty()) {
      if (typeid(vector<boost::any>) == m["TenantSecurityConfigs"].type()) {
        vector<DescribeTenantSecurityConfigsResponseBodyConfigsTenantSecurityConfigs> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TenantSecurityConfigs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeTenantSecurityConfigsResponseBodyConfigsTenantSecurityConfigs model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tenantSecurityConfigs = make_shared<vector<DescribeTenantSecurityConfigsResponseBodyConfigsTenantSecurityConfigs>>(expect1);
      }
    }
    if (m.find("TotalCheckCount") != m.end() && !m["TotalCheckCount"].empty()) {
      totalCheckCount = make_shared<long>(boost::any_cast<long>(m["TotalCheckCount"]));
    }
    if (m.find("TotalRiskCount") != m.end() && !m["TotalRiskCount"].empty()) {
      totalRiskCount = make_shared<long>(boost::any_cast<long>(m["TotalRiskCount"]));
    }
  }


  virtual ~DescribeTenantSecurityConfigsResponseBodyConfigs() = default;
};
class DescribeTenantSecurityConfigsResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeTenantSecurityConfigsResponseBodyConfigs> configs{};
  shared_ptr<string> requestId{};

  DescribeTenantSecurityConfigsResponseBody() {}

  explicit DescribeTenantSecurityConfigsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configs) {
      res["Configs"] = configs ? boost::any(configs->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Configs") != m.end() && !m["Configs"].empty()) {
      if (typeid(map<string, boost::any>) == m["Configs"].type()) {
        DescribeTenantSecurityConfigsResponseBodyConfigs model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Configs"]));
        configs = make_shared<DescribeTenantSecurityConfigsResponseBodyConfigs>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeTenantSecurityConfigsResponseBody() = default;
};
class DescribeTenantSecurityConfigsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeTenantSecurityConfigsResponseBody> body{};

  DescribeTenantSecurityConfigsResponse() {}

  explicit DescribeTenantSecurityConfigsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeTenantSecurityConfigsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeTenantSecurityConfigsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeTenantSecurityConfigsResponse() = default;
};
class DescribeTenantSecurityIpGroupsRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> tenantId{};

  DescribeTenantSecurityIpGroupsRequest() {}

  explicit DescribeTenantSecurityIpGroupsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["TenantId"]));
    }
  }


  virtual ~DescribeTenantSecurityIpGroupsRequest() = default;
};
class DescribeTenantSecurityIpGroupsResponseBodySecurityIpGroups : public Darabonba::Model {
public:
  shared_ptr<string> securityIpGroupName{};
  shared_ptr<string> securityIpGroupType{};
  shared_ptr<string> securityIps{};
  shared_ptr<string> tenantId{};

  DescribeTenantSecurityIpGroupsResponseBodySecurityIpGroups() {}

  explicit DescribeTenantSecurityIpGroupsResponseBodySecurityIpGroups(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (securityIpGroupName) {
      res["SecurityIpGroupName"] = boost::any(*securityIpGroupName);
    }
    if (securityIpGroupType) {
      res["SecurityIpGroupType"] = boost::any(*securityIpGroupType);
    }
    if (securityIps) {
      res["SecurityIps"] = boost::any(*securityIps);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SecurityIpGroupName") != m.end() && !m["SecurityIpGroupName"].empty()) {
      securityIpGroupName = make_shared<string>(boost::any_cast<string>(m["SecurityIpGroupName"]));
    }
    if (m.find("SecurityIpGroupType") != m.end() && !m["SecurityIpGroupType"].empty()) {
      securityIpGroupType = make_shared<string>(boost::any_cast<string>(m["SecurityIpGroupType"]));
    }
    if (m.find("SecurityIps") != m.end() && !m["SecurityIps"].empty()) {
      securityIps = make_shared<string>(boost::any_cast<string>(m["SecurityIps"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["TenantId"]));
    }
  }


  virtual ~DescribeTenantSecurityIpGroupsResponseBodySecurityIpGroups() = default;
};
class DescribeTenantSecurityIpGroupsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeTenantSecurityIpGroupsResponseBodySecurityIpGroups>> securityIpGroups{};
  shared_ptr<long> totalCount{};

  DescribeTenantSecurityIpGroupsResponseBody() {}

  explicit DescribeTenantSecurityIpGroupsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (securityIpGroups) {
      vector<boost::any> temp1;
      for(auto item1:*securityIpGroups){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SecurityIpGroups"] = boost::any(temp1);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SecurityIpGroups") != m.end() && !m["SecurityIpGroups"].empty()) {
      if (typeid(vector<boost::any>) == m["SecurityIpGroups"].type()) {
        vector<DescribeTenantSecurityIpGroupsResponseBodySecurityIpGroups> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SecurityIpGroups"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeTenantSecurityIpGroupsResponseBodySecurityIpGroups model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        securityIpGroups = make_shared<vector<DescribeTenantSecurityIpGroupsResponseBodySecurityIpGroups>>(expect1);
      }
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeTenantSecurityIpGroupsResponseBody() = default;
};
class DescribeTenantSecurityIpGroupsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeTenantSecurityIpGroupsResponseBody> body{};

  DescribeTenantSecurityIpGroupsResponse() {}

  explicit DescribeTenantSecurityIpGroupsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeTenantSecurityIpGroupsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeTenantSecurityIpGroupsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeTenantSecurityIpGroupsResponse() = default;
};
class DescribeTenantTagsRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> tags{};
  shared_ptr<string> tenantIds{};

  DescribeTenantTagsRequest() {}

  explicit DescribeTenantTagsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (tags) {
      res["Tags"] = boost::any(*tags);
    }
    if (tenantIds) {
      res["TenantIds"] = boost::any(*tenantIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      tags = make_shared<string>(boost::any_cast<string>(m["Tags"]));
    }
    if (m.find("TenantIds") != m.end() && !m["TenantIds"].empty()) {
      tenantIds = make_shared<string>(boost::any_cast<string>(m["TenantIds"]));
    }
  }


  virtual ~DescribeTenantTagsRequest() = default;
};
class DescribeTenantTagsResponseBodyTagResources : public Darabonba::Model {
public:
  shared_ptr<string> resourceId{};
  shared_ptr<string> resourceType{};
  shared_ptr<string> tag{};

  DescribeTenantTagsResponseBodyTagResources() {}

  explicit DescribeTenantTagsResponseBodyTagResources(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (tag) {
      res["Tag"] = boost::any(*tag);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      resourceId = make_shared<string>(boost::any_cast<string>(m["ResourceId"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      tag = make_shared<string>(boost::any_cast<string>(m["Tag"]));
    }
  }


  virtual ~DescribeTenantTagsResponseBodyTagResources() = default;
};
class DescribeTenantTagsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeTenantTagsResponseBodyTagResources>> tagResources{};

  DescribeTenantTagsResponseBody() {}

  explicit DescribeTenantTagsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (tagResources) {
      vector<boost::any> temp1;
      for(auto item1:*tagResources){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TagResources"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TagResources") != m.end() && !m["TagResources"].empty()) {
      if (typeid(vector<boost::any>) == m["TagResources"].type()) {
        vector<DescribeTenantTagsResponseBodyTagResources> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TagResources"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeTenantTagsResponseBodyTagResources model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tagResources = make_shared<vector<DescribeTenantTagsResponseBodyTagResources>>(expect1);
      }
    }
  }


  virtual ~DescribeTenantTagsResponseBody() = default;
};
class DescribeTenantTagsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeTenantTagsResponseBody> body{};

  DescribeTenantTagsResponse() {}

  explicit DescribeTenantTagsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeTenantTagsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeTenantTagsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeTenantTagsResponse() = default;
};
class DescribeTenantUserRolesRequest : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};

  DescribeTenantUserRolesRequest() {}

  explicit DescribeTenantUserRolesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["TenantId"]));
    }
  }


  virtual ~DescribeTenantUserRolesRequest() = default;
};
class DescribeTenantUserRolesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<string>> role{};

  DescribeTenantUserRolesResponseBody() {}

  explicit DescribeTenantUserRolesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (role) {
      res["Role"] = boost::any(*role);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Role") != m.end() && !m["Role"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Role"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Role"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      role = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeTenantUserRolesResponseBody() = default;
};
class DescribeTenantUserRolesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeTenantUserRolesResponseBody> body{};

  DescribeTenantUserRolesResponse() {}

  explicit DescribeTenantUserRolesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeTenantUserRolesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeTenantUserRolesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeTenantUserRolesResponse() = default;
};
class DescribeTenantUsersRequest : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> searchKey{};
  shared_ptr<string> tenantId{};
  shared_ptr<string> userName{};

  DescribeTenantUsersRequest() {}

  explicit DescribeTenantUsersRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (searchKey) {
      res["SearchKey"] = boost::any(*searchKey);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    if (userName) {
      res["UserName"] = boost::any(*userName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SearchKey") != m.end() && !m["SearchKey"].empty()) {
      searchKey = make_shared<string>(boost::any_cast<string>(m["SearchKey"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["TenantId"]));
    }
    if (m.find("UserName") != m.end() && !m["UserName"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["UserName"]));
    }
  }


  virtual ~DescribeTenantUsersRequest() = default;
};
class DescribeTenantUsersResponseBodyTenantUsersDatabases : public Darabonba::Model {
public:
  shared_ptr<string> database{};
  shared_ptr<string> privileges{};
  shared_ptr<string> role{};
  shared_ptr<string> table{};

  DescribeTenantUsersResponseBodyTenantUsersDatabases() {}

  explicit DescribeTenantUsersResponseBodyTenantUsersDatabases(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (database) {
      res["Database"] = boost::any(*database);
    }
    if (privileges) {
      res["Privileges"] = boost::any(*privileges);
    }
    if (role) {
      res["Role"] = boost::any(*role);
    }
    if (table) {
      res["Table"] = boost::any(*table);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Database") != m.end() && !m["Database"].empty()) {
      database = make_shared<string>(boost::any_cast<string>(m["Database"]));
    }
    if (m.find("Privileges") != m.end() && !m["Privileges"].empty()) {
      privileges = make_shared<string>(boost::any_cast<string>(m["Privileges"]));
    }
    if (m.find("Role") != m.end() && !m["Role"].empty()) {
      role = make_shared<string>(boost::any_cast<string>(m["Role"]));
    }
    if (m.find("Table") != m.end() && !m["Table"].empty()) {
      table = make_shared<string>(boost::any_cast<string>(m["Table"]));
    }
  }


  virtual ~DescribeTenantUsersResponseBodyTenantUsersDatabases() = default;
};
class DescribeTenantUsersResponseBodyTenantUsers : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeTenantUsersResponseBodyTenantUsersDatabases>> databases{};
  shared_ptr<string> description{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> tenantId{};
  shared_ptr<string> userName{};
  shared_ptr<string> userStatus{};
  shared_ptr<string> userType{};

  DescribeTenantUsersResponseBodyTenantUsers() {}

  explicit DescribeTenantUsersResponseBodyTenantUsers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (databases) {
      vector<boost::any> temp1;
      for(auto item1:*databases){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Databases"] = boost::any(temp1);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    if (userName) {
      res["UserName"] = boost::any(*userName);
    }
    if (userStatus) {
      res["UserStatus"] = boost::any(*userStatus);
    }
    if (userType) {
      res["UserType"] = boost::any(*userType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Databases") != m.end() && !m["Databases"].empty()) {
      if (typeid(vector<boost::any>) == m["Databases"].type()) {
        vector<DescribeTenantUsersResponseBodyTenantUsersDatabases> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Databases"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeTenantUsersResponseBodyTenantUsersDatabases model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        databases = make_shared<vector<DescribeTenantUsersResponseBodyTenantUsersDatabases>>(expect1);
      }
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["TenantId"]));
    }
    if (m.find("UserName") != m.end() && !m["UserName"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["UserName"]));
    }
    if (m.find("UserStatus") != m.end() && !m["UserStatus"].empty()) {
      userStatus = make_shared<string>(boost::any_cast<string>(m["UserStatus"]));
    }
    if (m.find("UserType") != m.end() && !m["UserType"].empty()) {
      userType = make_shared<string>(boost::any_cast<string>(m["UserType"]));
    }
  }


  virtual ~DescribeTenantUsersResponseBodyTenantUsers() = default;
};
class DescribeTenantUsersResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeTenantUsersResponseBodyTenantUsers>> tenantUsers{};
  shared_ptr<long> totalCount{};

  DescribeTenantUsersResponseBody() {}

  explicit DescribeTenantUsersResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (tenantUsers) {
      vector<boost::any> temp1;
      for(auto item1:*tenantUsers){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TenantUsers"] = boost::any(temp1);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TenantUsers") != m.end() && !m["TenantUsers"].empty()) {
      if (typeid(vector<boost::any>) == m["TenantUsers"].type()) {
        vector<DescribeTenantUsersResponseBodyTenantUsers> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TenantUsers"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeTenantUsersResponseBodyTenantUsers model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tenantUsers = make_shared<vector<DescribeTenantUsersResponseBodyTenantUsers>>(expect1);
      }
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeTenantUsersResponseBody() = default;
};
class DescribeTenantUsersResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeTenantUsersResponseBody> body{};

  DescribeTenantUsersResponse() {}

  explicit DescribeTenantUsersResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeTenantUsersResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeTenantUsersResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeTenantUsersResponse() = default;
};
class DescribeTenantZonesReadRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> tenantId{};

  DescribeTenantZonesReadRequest() {}

  explicit DescribeTenantZonesReadRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["TenantId"]));
    }
  }


  virtual ~DescribeTenantZonesReadRequest() = default;
};
class DescribeTenantZonesReadResponseBodyTenantZones : public Darabonba::Model {
public:
  shared_ptr<bool> isElectable{};
  shared_ptr<bool> isPrimary{};
  shared_ptr<string> isReadable{};
  shared_ptr<string> zone{};

  DescribeTenantZonesReadResponseBodyTenantZones() {}

  explicit DescribeTenantZonesReadResponseBodyTenantZones(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (isElectable) {
      res["IsElectable"] = boost::any(*isElectable);
    }
    if (isPrimary) {
      res["IsPrimary"] = boost::any(*isPrimary);
    }
    if (isReadable) {
      res["IsReadable"] = boost::any(*isReadable);
    }
    if (zone) {
      res["Zone"] = boost::any(*zone);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IsElectable") != m.end() && !m["IsElectable"].empty()) {
      isElectable = make_shared<bool>(boost::any_cast<bool>(m["IsElectable"]));
    }
    if (m.find("IsPrimary") != m.end() && !m["IsPrimary"].empty()) {
      isPrimary = make_shared<bool>(boost::any_cast<bool>(m["IsPrimary"]));
    }
    if (m.find("IsReadable") != m.end() && !m["IsReadable"].empty()) {
      isReadable = make_shared<string>(boost::any_cast<string>(m["IsReadable"]));
    }
    if (m.find("Zone") != m.end() && !m["Zone"].empty()) {
      zone = make_shared<string>(boost::any_cast<string>(m["Zone"]));
    }
  }


  virtual ~DescribeTenantZonesReadResponseBodyTenantZones() = default;
};
class DescribeTenantZonesReadResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeTenantZonesReadResponseBodyTenantZones>> tenantZones{};

  DescribeTenantZonesReadResponseBody() {}

  explicit DescribeTenantZonesReadResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (tenantZones) {
      vector<boost::any> temp1;
      for(auto item1:*tenantZones){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TenantZones"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TenantZones") != m.end() && !m["TenantZones"].empty()) {
      if (typeid(vector<boost::any>) == m["TenantZones"].type()) {
        vector<DescribeTenantZonesReadResponseBodyTenantZones> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TenantZones"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeTenantZonesReadResponseBodyTenantZones model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tenantZones = make_shared<vector<DescribeTenantZonesReadResponseBodyTenantZones>>(expect1);
      }
    }
  }


  virtual ~DescribeTenantZonesReadResponseBody() = default;
};
class DescribeTenantZonesReadResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeTenantZonesReadResponseBody> body{};

  DescribeTenantZonesReadResponse() {}

  explicit DescribeTenantZonesReadResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeTenantZonesReadResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeTenantZonesReadResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeTenantZonesReadResponse() = default;
};
class DescribeTenantsRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> searchKey{};
  shared_ptr<string> tenantId{};
  shared_ptr<string> tenantName{};

  DescribeTenantsRequest() {}

  explicit DescribeTenantsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (searchKey) {
      res["SearchKey"] = boost::any(*searchKey);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    if (tenantName) {
      res["TenantName"] = boost::any(*tenantName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SearchKey") != m.end() && !m["SearchKey"].empty()) {
      searchKey = make_shared<string>(boost::any_cast<string>(m["SearchKey"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["TenantId"]));
    }
    if (m.find("TenantName") != m.end() && !m["TenantName"].empty()) {
      tenantName = make_shared<string>(boost::any_cast<string>(m["TenantName"]));
    }
  }


  virtual ~DescribeTenantsRequest() = default;
};
class DescribeTenantsResponseBodyTenants : public Darabonba::Model {
public:
  shared_ptr<string> charset{};
  shared_ptr<string> collation{};
  shared_ptr<long> cpu{};
  shared_ptr<string> createTime{};
  shared_ptr<string> deployMode{};
  shared_ptr<string> deployType{};
  shared_ptr<string> description{};
  shared_ptr<bool> enableReadOnlyReplica{};
  shared_ptr<long> mem{};
  shared_ptr<string> primaryZone{};
  shared_ptr<string> status{};
  shared_ptr<string> tenantId{};
  shared_ptr<string> tenantMode{};
  shared_ptr<string> tenantName{};
  shared_ptr<long> unitCpu{};
  shared_ptr<long> unitMem{};
  shared_ptr<long> unitNum{};
  shared_ptr<double> usedDiskSize{};
  shared_ptr<string> vpcId{};

  DescribeTenantsResponseBodyTenants() {}

  explicit DescribeTenantsResponseBodyTenants(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (charset) {
      res["Charset"] = boost::any(*charset);
    }
    if (collation) {
      res["Collation"] = boost::any(*collation);
    }
    if (cpu) {
      res["Cpu"] = boost::any(*cpu);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (deployMode) {
      res["DeployMode"] = boost::any(*deployMode);
    }
    if (deployType) {
      res["DeployType"] = boost::any(*deployType);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (enableReadOnlyReplica) {
      res["EnableReadOnlyReplica"] = boost::any(*enableReadOnlyReplica);
    }
    if (mem) {
      res["Mem"] = boost::any(*mem);
    }
    if (primaryZone) {
      res["PrimaryZone"] = boost::any(*primaryZone);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    if (tenantMode) {
      res["TenantMode"] = boost::any(*tenantMode);
    }
    if (tenantName) {
      res["TenantName"] = boost::any(*tenantName);
    }
    if (unitCpu) {
      res["UnitCpu"] = boost::any(*unitCpu);
    }
    if (unitMem) {
      res["UnitMem"] = boost::any(*unitMem);
    }
    if (unitNum) {
      res["UnitNum"] = boost::any(*unitNum);
    }
    if (usedDiskSize) {
      res["UsedDiskSize"] = boost::any(*usedDiskSize);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Charset") != m.end() && !m["Charset"].empty()) {
      charset = make_shared<string>(boost::any_cast<string>(m["Charset"]));
    }
    if (m.find("Collation") != m.end() && !m["Collation"].empty()) {
      collation = make_shared<string>(boost::any_cast<string>(m["Collation"]));
    }
    if (m.find("Cpu") != m.end() && !m["Cpu"].empty()) {
      cpu = make_shared<long>(boost::any_cast<long>(m["Cpu"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("DeployMode") != m.end() && !m["DeployMode"].empty()) {
      deployMode = make_shared<string>(boost::any_cast<string>(m["DeployMode"]));
    }
    if (m.find("DeployType") != m.end() && !m["DeployType"].empty()) {
      deployType = make_shared<string>(boost::any_cast<string>(m["DeployType"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("EnableReadOnlyReplica") != m.end() && !m["EnableReadOnlyReplica"].empty()) {
      enableReadOnlyReplica = make_shared<bool>(boost::any_cast<bool>(m["EnableReadOnlyReplica"]));
    }
    if (m.find("Mem") != m.end() && !m["Mem"].empty()) {
      mem = make_shared<long>(boost::any_cast<long>(m["Mem"]));
    }
    if (m.find("PrimaryZone") != m.end() && !m["PrimaryZone"].empty()) {
      primaryZone = make_shared<string>(boost::any_cast<string>(m["PrimaryZone"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["TenantId"]));
    }
    if (m.find("TenantMode") != m.end() && !m["TenantMode"].empty()) {
      tenantMode = make_shared<string>(boost::any_cast<string>(m["TenantMode"]));
    }
    if (m.find("TenantName") != m.end() && !m["TenantName"].empty()) {
      tenantName = make_shared<string>(boost::any_cast<string>(m["TenantName"]));
    }
    if (m.find("UnitCpu") != m.end() && !m["UnitCpu"].empty()) {
      unitCpu = make_shared<long>(boost::any_cast<long>(m["UnitCpu"]));
    }
    if (m.find("UnitMem") != m.end() && !m["UnitMem"].empty()) {
      unitMem = make_shared<long>(boost::any_cast<long>(m["UnitMem"]));
    }
    if (m.find("UnitNum") != m.end() && !m["UnitNum"].empty()) {
      unitNum = make_shared<long>(boost::any_cast<long>(m["UnitNum"]));
    }
    if (m.find("UsedDiskSize") != m.end() && !m["UsedDiskSize"].empty()) {
      usedDiskSize = make_shared<double>(boost::any_cast<double>(m["UsedDiskSize"]));
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
  }


  virtual ~DescribeTenantsResponseBodyTenants() = default;
};
class DescribeTenantsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeTenantsResponseBodyTenants>> tenants{};
  shared_ptr<long> totalCount{};

  DescribeTenantsResponseBody() {}

  explicit DescribeTenantsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (tenants) {
      vector<boost::any> temp1;
      for(auto item1:*tenants){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tenants"] = boost::any(temp1);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Tenants") != m.end() && !m["Tenants"].empty()) {
      if (typeid(vector<boost::any>) == m["Tenants"].type()) {
        vector<DescribeTenantsResponseBodyTenants> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tenants"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeTenantsResponseBodyTenants model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tenants = make_shared<vector<DescribeTenantsResponseBodyTenants>>(expect1);
      }
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeTenantsResponseBody() = default;
};
class DescribeTenantsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeTenantsResponseBody> body{};

  DescribeTenantsResponse() {}

  explicit DescribeTenantsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeTenantsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeTenantsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeTenantsResponse() = default;
};
class DescribeTimeZonesResponseBodyTimeZonesList : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> timeZone{};

  DescribeTimeZonesResponseBodyTimeZonesList() {}

  explicit DescribeTimeZonesResponseBodyTimeZonesList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (timeZone) {
      res["TimeZone"] = boost::any(*timeZone);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("TimeZone") != m.end() && !m["TimeZone"].empty()) {
      timeZone = make_shared<string>(boost::any_cast<string>(m["TimeZone"]));
    }
  }


  virtual ~DescribeTimeZonesResponseBodyTimeZonesList() = default;
};
class DescribeTimeZonesResponseBodyTimeZones : public Darabonba::Model {
public:
  shared_ptr<string> default_{};
  shared_ptr<vector<DescribeTimeZonesResponseBodyTimeZonesList>> list{};

  DescribeTimeZonesResponseBodyTimeZones() {}

  explicit DescribeTimeZonesResponseBodyTimeZones(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (default_) {
      res["Default"] = boost::any(*default_);
    }
    if (list) {
      vector<boost::any> temp1;
      for(auto item1:*list){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["List"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Default") != m.end() && !m["Default"].empty()) {
      default_ = make_shared<string>(boost::any_cast<string>(m["Default"]));
    }
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(vector<boost::any>) == m["List"].type()) {
        vector<DescribeTimeZonesResponseBodyTimeZonesList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["List"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeTimeZonesResponseBodyTimeZonesList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        list = make_shared<vector<DescribeTimeZonesResponseBodyTimeZonesList>>(expect1);
      }
    }
  }


  virtual ~DescribeTimeZonesResponseBodyTimeZones() = default;
};
class DescribeTimeZonesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeTimeZonesResponseBodyTimeZones> timeZones{};

  DescribeTimeZonesResponseBody() {}

  explicit DescribeTimeZonesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (timeZones) {
      res["TimeZones"] = timeZones ? boost::any(timeZones->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TimeZones") != m.end() && !m["TimeZones"].empty()) {
      if (typeid(map<string, boost::any>) == m["TimeZones"].type()) {
        DescribeTimeZonesResponseBodyTimeZones model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TimeZones"]));
        timeZones = make_shared<DescribeTimeZonesResponseBodyTimeZones>(model1);
      }
    }
  }


  virtual ~DescribeTimeZonesResponseBody() = default;
};
class DescribeTimeZonesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeTimeZonesResponseBody> body{};

  DescribeTimeZonesResponse() {}

  explicit DescribeTimeZonesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeTimeZonesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeTimeZonesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeTimeZonesResponse() = default;
};
class DescribeTopSQLListRequest : public Darabonba::Model {
public:
  shared_ptr<string> dbName{};
  shared_ptr<string> endTime{};
  shared_ptr<map<string, boost::any>> filterCondition{};
  shared_ptr<string> nodeIp{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> SQLId{};
  shared_ptr<string> searchKeyWord{};
  shared_ptr<string> searchParameter{};
  shared_ptr<string> searchRule{};
  shared_ptr<string> searchValue{};
  shared_ptr<string> sortColumn{};
  shared_ptr<string> sortOrder{};
  shared_ptr<string> startTime{};
  shared_ptr<string> tenantId{};

  DescribeTopSQLListRequest() {}

  explicit DescribeTopSQLListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dbName) {
      res["DbName"] = boost::any(*dbName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (filterCondition) {
      res["FilterCondition"] = boost::any(*filterCondition);
    }
    if (nodeIp) {
      res["NodeIp"] = boost::any(*nodeIp);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (SQLId) {
      res["SQLId"] = boost::any(*SQLId);
    }
    if (searchKeyWord) {
      res["SearchKeyWord"] = boost::any(*searchKeyWord);
    }
    if (searchParameter) {
      res["SearchParameter"] = boost::any(*searchParameter);
    }
    if (searchRule) {
      res["SearchRule"] = boost::any(*searchRule);
    }
    if (searchValue) {
      res["SearchValue"] = boost::any(*searchValue);
    }
    if (sortColumn) {
      res["SortColumn"] = boost::any(*sortColumn);
    }
    if (sortOrder) {
      res["SortOrder"] = boost::any(*sortOrder);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DbName") != m.end() && !m["DbName"].empty()) {
      dbName = make_shared<string>(boost::any_cast<string>(m["DbName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("FilterCondition") != m.end() && !m["FilterCondition"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["FilterCondition"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      filterCondition = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("NodeIp") != m.end() && !m["NodeIp"].empty()) {
      nodeIp = make_shared<string>(boost::any_cast<string>(m["NodeIp"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SQLId") != m.end() && !m["SQLId"].empty()) {
      SQLId = make_shared<string>(boost::any_cast<string>(m["SQLId"]));
    }
    if (m.find("SearchKeyWord") != m.end() && !m["SearchKeyWord"].empty()) {
      searchKeyWord = make_shared<string>(boost::any_cast<string>(m["SearchKeyWord"]));
    }
    if (m.find("SearchParameter") != m.end() && !m["SearchParameter"].empty()) {
      searchParameter = make_shared<string>(boost::any_cast<string>(m["SearchParameter"]));
    }
    if (m.find("SearchRule") != m.end() && !m["SearchRule"].empty()) {
      searchRule = make_shared<string>(boost::any_cast<string>(m["SearchRule"]));
    }
    if (m.find("SearchValue") != m.end() && !m["SearchValue"].empty()) {
      searchValue = make_shared<string>(boost::any_cast<string>(m["SearchValue"]));
    }
    if (m.find("SortColumn") != m.end() && !m["SortColumn"].empty()) {
      sortColumn = make_shared<string>(boost::any_cast<string>(m["SortColumn"]));
    }
    if (m.find("SortOrder") != m.end() && !m["SortOrder"].empty()) {
      sortOrder = make_shared<string>(boost::any_cast<string>(m["SortOrder"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["TenantId"]));
    }
  }


  virtual ~DescribeTopSQLListRequest() = default;
};
class DescribeTopSQLListShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> dbName{};
  shared_ptr<string> endTime{};
  shared_ptr<string> filterConditionShrink{};
  shared_ptr<string> nodeIp{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> SQLId{};
  shared_ptr<string> searchKeyWord{};
  shared_ptr<string> searchParameter{};
  shared_ptr<string> searchRule{};
  shared_ptr<string> searchValue{};
  shared_ptr<string> sortColumn{};
  shared_ptr<string> sortOrder{};
  shared_ptr<string> startTime{};
  shared_ptr<string> tenantId{};

  DescribeTopSQLListShrinkRequest() {}

  explicit DescribeTopSQLListShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dbName) {
      res["DbName"] = boost::any(*dbName);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (filterConditionShrink) {
      res["FilterCondition"] = boost::any(*filterConditionShrink);
    }
    if (nodeIp) {
      res["NodeIp"] = boost::any(*nodeIp);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (SQLId) {
      res["SQLId"] = boost::any(*SQLId);
    }
    if (searchKeyWord) {
      res["SearchKeyWord"] = boost::any(*searchKeyWord);
    }
    if (searchParameter) {
      res["SearchParameter"] = boost::any(*searchParameter);
    }
    if (searchRule) {
      res["SearchRule"] = boost::any(*searchRule);
    }
    if (searchValue) {
      res["SearchValue"] = boost::any(*searchValue);
    }
    if (sortColumn) {
      res["SortColumn"] = boost::any(*sortColumn);
    }
    if (sortOrder) {
      res["SortOrder"] = boost::any(*sortOrder);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DbName") != m.end() && !m["DbName"].empty()) {
      dbName = make_shared<string>(boost::any_cast<string>(m["DbName"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("FilterCondition") != m.end() && !m["FilterCondition"].empty()) {
      filterConditionShrink = make_shared<string>(boost::any_cast<string>(m["FilterCondition"]));
    }
    if (m.find("NodeIp") != m.end() && !m["NodeIp"].empty()) {
      nodeIp = make_shared<string>(boost::any_cast<string>(m["NodeIp"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SQLId") != m.end() && !m["SQLId"].empty()) {
      SQLId = make_shared<string>(boost::any_cast<string>(m["SQLId"]));
    }
    if (m.find("SearchKeyWord") != m.end() && !m["SearchKeyWord"].empty()) {
      searchKeyWord = make_shared<string>(boost::any_cast<string>(m["SearchKeyWord"]));
    }
    if (m.find("SearchParameter") != m.end() && !m["SearchParameter"].empty()) {
      searchParameter = make_shared<string>(boost::any_cast<string>(m["SearchParameter"]));
    }
    if (m.find("SearchRule") != m.end() && !m["SearchRule"].empty()) {
      searchRule = make_shared<string>(boost::any_cast<string>(m["SearchRule"]));
    }
    if (m.find("SearchValue") != m.end() && !m["SearchValue"].empty()) {
      searchValue = make_shared<string>(boost::any_cast<string>(m["SearchValue"]));
    }
    if (m.find("SortColumn") != m.end() && !m["SortColumn"].empty()) {
      sortColumn = make_shared<string>(boost::any_cast<string>(m["SortColumn"]));
    }
    if (m.find("SortOrder") != m.end() && !m["SortOrder"].empty()) {
      sortOrder = make_shared<string>(boost::any_cast<string>(m["SortOrder"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["TenantId"]));
    }
  }


  virtual ~DescribeTopSQLListShrinkRequest() = default;
};
class DescribeTopSQLListResponseBodyTopSQLList : public Darabonba::Model {
public:
  shared_ptr<long> affectedRows{};
  shared_ptr<double> appWaitTime{};
  shared_ptr<long> blockCacheHit{};
  shared_ptr<long> blockIndexCacheHit{};
  shared_ptr<long> bloomFilterCacheHit{};
  shared_ptr<string> clientIp{};
  shared_ptr<double> concurrencyWaitTime{};
  shared_ptr<double> cpuTime{};
  shared_ptr<string> dbName{};
  shared_ptr<double> decodeTime{};
  shared_ptr<long> diskRead{};
  shared_ptr<double> elapsedTime{};
  shared_ptr<string> event{};
  shared_ptr<double> execPerSecond{};
  shared_ptr<double> executeTime{};
  shared_ptr<long> executions{};
  shared_ptr<long> failTimes{};
  shared_ptr<double> getPlanTime{};
  shared_ptr<double> IOWaitTime{};
  shared_ptr<long> key{};
  shared_ptr<long> logicalRead{};
  shared_ptr<double> maxCpuTime{};
  shared_ptr<double> maxElapsedTime{};
  shared_ptr<long> memstoreReadRowCount{};
  shared_ptr<long> missPlans{};
  shared_ptr<double> netWaitTime{};
  shared_ptr<string> nodeIp{};
  shared_ptr<double> queueTime{};
  shared_ptr<long> RPCCount{};
  shared_ptr<long> remotePlans{};
  shared_ptr<long> retryCount{};
  shared_ptr<long> returnRows{};
  shared_ptr<long> rowCacheHit{};
  shared_ptr<string> SQLId{};
  shared_ptr<string> SQLText{};
  shared_ptr<long> SQLType{};
  shared_ptr<double> scheduleTime{};
  shared_ptr<long> ssstoreReadRowCount{};
  shared_ptr<double> totalWaitTime{};
  shared_ptr<string> userName{};

  DescribeTopSQLListResponseBodyTopSQLList() {}

  explicit DescribeTopSQLListResponseBodyTopSQLList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (affectedRows) {
      res["AffectedRows"] = boost::any(*affectedRows);
    }
    if (appWaitTime) {
      res["AppWaitTime"] = boost::any(*appWaitTime);
    }
    if (blockCacheHit) {
      res["BlockCacheHit"] = boost::any(*blockCacheHit);
    }
    if (blockIndexCacheHit) {
      res["BlockIndexCacheHit"] = boost::any(*blockIndexCacheHit);
    }
    if (bloomFilterCacheHit) {
      res["BloomFilterCacheHit"] = boost::any(*bloomFilterCacheHit);
    }
    if (clientIp) {
      res["ClientIp"] = boost::any(*clientIp);
    }
    if (concurrencyWaitTime) {
      res["ConcurrencyWaitTime"] = boost::any(*concurrencyWaitTime);
    }
    if (cpuTime) {
      res["CpuTime"] = boost::any(*cpuTime);
    }
    if (dbName) {
      res["DbName"] = boost::any(*dbName);
    }
    if (decodeTime) {
      res["DecodeTime"] = boost::any(*decodeTime);
    }
    if (diskRead) {
      res["DiskRead"] = boost::any(*diskRead);
    }
    if (elapsedTime) {
      res["ElapsedTime"] = boost::any(*elapsedTime);
    }
    if (event) {
      res["Event"] = boost::any(*event);
    }
    if (execPerSecond) {
      res["ExecPerSecond"] = boost::any(*execPerSecond);
    }
    if (executeTime) {
      res["ExecuteTime"] = boost::any(*executeTime);
    }
    if (executions) {
      res["Executions"] = boost::any(*executions);
    }
    if (failTimes) {
      res["FailTimes"] = boost::any(*failTimes);
    }
    if (getPlanTime) {
      res["GetPlanTime"] = boost::any(*getPlanTime);
    }
    if (IOWaitTime) {
      res["IOWaitTime"] = boost::any(*IOWaitTime);
    }
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (logicalRead) {
      res["LogicalRead"] = boost::any(*logicalRead);
    }
    if (maxCpuTime) {
      res["MaxCpuTime"] = boost::any(*maxCpuTime);
    }
    if (maxElapsedTime) {
      res["MaxElapsedTime"] = boost::any(*maxElapsedTime);
    }
    if (memstoreReadRowCount) {
      res["MemstoreReadRowCount"] = boost::any(*memstoreReadRowCount);
    }
    if (missPlans) {
      res["MissPlans"] = boost::any(*missPlans);
    }
    if (netWaitTime) {
      res["NetWaitTime"] = boost::any(*netWaitTime);
    }
    if (nodeIp) {
      res["NodeIp"] = boost::any(*nodeIp);
    }
    if (queueTime) {
      res["QueueTime"] = boost::any(*queueTime);
    }
    if (RPCCount) {
      res["RPCCount"] = boost::any(*RPCCount);
    }
    if (remotePlans) {
      res["RemotePlans"] = boost::any(*remotePlans);
    }
    if (retryCount) {
      res["RetryCount"] = boost::any(*retryCount);
    }
    if (returnRows) {
      res["ReturnRows"] = boost::any(*returnRows);
    }
    if (rowCacheHit) {
      res["RowCacheHit"] = boost::any(*rowCacheHit);
    }
    if (SQLId) {
      res["SQLId"] = boost::any(*SQLId);
    }
    if (SQLText) {
      res["SQLText"] = boost::any(*SQLText);
    }
    if (SQLType) {
      res["SQLType"] = boost::any(*SQLType);
    }
    if (scheduleTime) {
      res["ScheduleTime"] = boost::any(*scheduleTime);
    }
    if (ssstoreReadRowCount) {
      res["SsstoreReadRowCount"] = boost::any(*ssstoreReadRowCount);
    }
    if (totalWaitTime) {
      res["TotalWaitTime"] = boost::any(*totalWaitTime);
    }
    if (userName) {
      res["UserName"] = boost::any(*userName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AffectedRows") != m.end() && !m["AffectedRows"].empty()) {
      affectedRows = make_shared<long>(boost::any_cast<long>(m["AffectedRows"]));
    }
    if (m.find("AppWaitTime") != m.end() && !m["AppWaitTime"].empty()) {
      appWaitTime = make_shared<double>(boost::any_cast<double>(m["AppWaitTime"]));
    }
    if (m.find("BlockCacheHit") != m.end() && !m["BlockCacheHit"].empty()) {
      blockCacheHit = make_shared<long>(boost::any_cast<long>(m["BlockCacheHit"]));
    }
    if (m.find("BlockIndexCacheHit") != m.end() && !m["BlockIndexCacheHit"].empty()) {
      blockIndexCacheHit = make_shared<long>(boost::any_cast<long>(m["BlockIndexCacheHit"]));
    }
    if (m.find("BloomFilterCacheHit") != m.end() && !m["BloomFilterCacheHit"].empty()) {
      bloomFilterCacheHit = make_shared<long>(boost::any_cast<long>(m["BloomFilterCacheHit"]));
    }
    if (m.find("ClientIp") != m.end() && !m["ClientIp"].empty()) {
      clientIp = make_shared<string>(boost::any_cast<string>(m["ClientIp"]));
    }
    if (m.find("ConcurrencyWaitTime") != m.end() && !m["ConcurrencyWaitTime"].empty()) {
      concurrencyWaitTime = make_shared<double>(boost::any_cast<double>(m["ConcurrencyWaitTime"]));
    }
    if (m.find("CpuTime") != m.end() && !m["CpuTime"].empty()) {
      cpuTime = make_shared<double>(boost::any_cast<double>(m["CpuTime"]));
    }
    if (m.find("DbName") != m.end() && !m["DbName"].empty()) {
      dbName = make_shared<string>(boost::any_cast<string>(m["DbName"]));
    }
    if (m.find("DecodeTime") != m.end() && !m["DecodeTime"].empty()) {
      decodeTime = make_shared<double>(boost::any_cast<double>(m["DecodeTime"]));
    }
    if (m.find("DiskRead") != m.end() && !m["DiskRead"].empty()) {
      diskRead = make_shared<long>(boost::any_cast<long>(m["DiskRead"]));
    }
    if (m.find("ElapsedTime") != m.end() && !m["ElapsedTime"].empty()) {
      elapsedTime = make_shared<double>(boost::any_cast<double>(m["ElapsedTime"]));
    }
    if (m.find("Event") != m.end() && !m["Event"].empty()) {
      event = make_shared<string>(boost::any_cast<string>(m["Event"]));
    }
    if (m.find("ExecPerSecond") != m.end() && !m["ExecPerSecond"].empty()) {
      execPerSecond = make_shared<double>(boost::any_cast<double>(m["ExecPerSecond"]));
    }
    if (m.find("ExecuteTime") != m.end() && !m["ExecuteTime"].empty()) {
      executeTime = make_shared<double>(boost::any_cast<double>(m["ExecuteTime"]));
    }
    if (m.find("Executions") != m.end() && !m["Executions"].empty()) {
      executions = make_shared<long>(boost::any_cast<long>(m["Executions"]));
    }
    if (m.find("FailTimes") != m.end() && !m["FailTimes"].empty()) {
      failTimes = make_shared<long>(boost::any_cast<long>(m["FailTimes"]));
    }
    if (m.find("GetPlanTime") != m.end() && !m["GetPlanTime"].empty()) {
      getPlanTime = make_shared<double>(boost::any_cast<double>(m["GetPlanTime"]));
    }
    if (m.find("IOWaitTime") != m.end() && !m["IOWaitTime"].empty()) {
      IOWaitTime = make_shared<double>(boost::any_cast<double>(m["IOWaitTime"]));
    }
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<long>(boost::any_cast<long>(m["Key"]));
    }
    if (m.find("LogicalRead") != m.end() && !m["LogicalRead"].empty()) {
      logicalRead = make_shared<long>(boost::any_cast<long>(m["LogicalRead"]));
    }
    if (m.find("MaxCpuTime") != m.end() && !m["MaxCpuTime"].empty()) {
      maxCpuTime = make_shared<double>(boost::any_cast<double>(m["MaxCpuTime"]));
    }
    if (m.find("MaxElapsedTime") != m.end() && !m["MaxElapsedTime"].empty()) {
      maxElapsedTime = make_shared<double>(boost::any_cast<double>(m["MaxElapsedTime"]));
    }
    if (m.find("MemstoreReadRowCount") != m.end() && !m["MemstoreReadRowCount"].empty()) {
      memstoreReadRowCount = make_shared<long>(boost::any_cast<long>(m["MemstoreReadRowCount"]));
    }
    if (m.find("MissPlans") != m.end() && !m["MissPlans"].empty()) {
      missPlans = make_shared<long>(boost::any_cast<long>(m["MissPlans"]));
    }
    if (m.find("NetWaitTime") != m.end() && !m["NetWaitTime"].empty()) {
      netWaitTime = make_shared<double>(boost::any_cast<double>(m["NetWaitTime"]));
    }
    if (m.find("NodeIp") != m.end() && !m["NodeIp"].empty()) {
      nodeIp = make_shared<string>(boost::any_cast<string>(m["NodeIp"]));
    }
    if (m.find("QueueTime") != m.end() && !m["QueueTime"].empty()) {
      queueTime = make_shared<double>(boost::any_cast<double>(m["QueueTime"]));
    }
    if (m.find("RPCCount") != m.end() && !m["RPCCount"].empty()) {
      RPCCount = make_shared<long>(boost::any_cast<long>(m["RPCCount"]));
    }
    if (m.find("RemotePlans") != m.end() && !m["RemotePlans"].empty()) {
      remotePlans = make_shared<long>(boost::any_cast<long>(m["RemotePlans"]));
    }
    if (m.find("RetryCount") != m.end() && !m["RetryCount"].empty()) {
      retryCount = make_shared<long>(boost::any_cast<long>(m["RetryCount"]));
    }
    if (m.find("ReturnRows") != m.end() && !m["ReturnRows"].empty()) {
      returnRows = make_shared<long>(boost::any_cast<long>(m["ReturnRows"]));
    }
    if (m.find("RowCacheHit") != m.end() && !m["RowCacheHit"].empty()) {
      rowCacheHit = make_shared<long>(boost::any_cast<long>(m["RowCacheHit"]));
    }
    if (m.find("SQLId") != m.end() && !m["SQLId"].empty()) {
      SQLId = make_shared<string>(boost::any_cast<string>(m["SQLId"]));
    }
    if (m.find("SQLText") != m.end() && !m["SQLText"].empty()) {
      SQLText = make_shared<string>(boost::any_cast<string>(m["SQLText"]));
    }
    if (m.find("SQLType") != m.end() && !m["SQLType"].empty()) {
      SQLType = make_shared<long>(boost::any_cast<long>(m["SQLType"]));
    }
    if (m.find("ScheduleTime") != m.end() && !m["ScheduleTime"].empty()) {
      scheduleTime = make_shared<double>(boost::any_cast<double>(m["ScheduleTime"]));
    }
    if (m.find("SsstoreReadRowCount") != m.end() && !m["SsstoreReadRowCount"].empty()) {
      ssstoreReadRowCount = make_shared<long>(boost::any_cast<long>(m["SsstoreReadRowCount"]));
    }
    if (m.find("TotalWaitTime") != m.end() && !m["TotalWaitTime"].empty()) {
      totalWaitTime = make_shared<double>(boost::any_cast<double>(m["TotalWaitTime"]));
    }
    if (m.find("UserName") != m.end() && !m["UserName"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["UserName"]));
    }
  }


  virtual ~DescribeTopSQLListResponseBodyTopSQLList() = default;
};
class DescribeTopSQLListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeTopSQLListResponseBodyTopSQLList>> topSQLList{};
  shared_ptr<long> totalCount{};

  DescribeTopSQLListResponseBody() {}

  explicit DescribeTopSQLListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (topSQLList) {
      vector<boost::any> temp1;
      for(auto item1:*topSQLList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TopSQLList"] = boost::any(temp1);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TopSQLList") != m.end() && !m["TopSQLList"].empty()) {
      if (typeid(vector<boost::any>) == m["TopSQLList"].type()) {
        vector<DescribeTopSQLListResponseBodyTopSQLList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TopSQLList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeTopSQLListResponseBodyTopSQLList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        topSQLList = make_shared<vector<DescribeTopSQLListResponseBodyTopSQLList>>(expect1);
      }
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeTopSQLListResponseBody() = default;
};
class DescribeTopSQLListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeTopSQLListResponseBody> body{};

  DescribeTopSQLListResponse() {}

  explicit DescribeTopSQLListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeTopSQLListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeTopSQLListResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeTopSQLListResponse() = default;
};
class DescribeZonesRequest : public Darabonba::Model {
public:
  shared_ptr<string> deployType{};
  shared_ptr<string> series{};

  DescribeZonesRequest() {}

  explicit DescribeZonesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deployType) {
      res["DeployType"] = boost::any(*deployType);
    }
    if (series) {
      res["Series"] = boost::any(*series);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeployType") != m.end() && !m["DeployType"].empty()) {
      deployType = make_shared<string>(boost::any_cast<string>(m["DeployType"]));
    }
    if (m.find("Series") != m.end() && !m["Series"].empty()) {
      series = make_shared<string>(boost::any_cast<string>(m["Series"]));
    }
  }


  virtual ~DescribeZonesRequest() = default;
};
class DescribeZonesResponseBodyZones : public Darabonba::Model {
public:
  shared_ptr<string> deployType{};
  shared_ptr<string> series{};
  shared_ptr<string> zoneId{};
  shared_ptr<string> zoneName{};

  DescribeZonesResponseBodyZones() {}

  explicit DescribeZonesResponseBodyZones(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deployType) {
      res["DeployType"] = boost::any(*deployType);
    }
    if (series) {
      res["Series"] = boost::any(*series);
    }
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    if (zoneName) {
      res["ZoneName"] = boost::any(*zoneName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeployType") != m.end() && !m["DeployType"].empty()) {
      deployType = make_shared<string>(boost::any_cast<string>(m["DeployType"]));
    }
    if (m.find("Series") != m.end() && !m["Series"].empty()) {
      series = make_shared<string>(boost::any_cast<string>(m["Series"]));
    }
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["ZoneId"]));
    }
    if (m.find("ZoneName") != m.end() && !m["ZoneName"].empty()) {
      zoneName = make_shared<string>(boost::any_cast<string>(m["ZoneName"]));
    }
  }


  virtual ~DescribeZonesResponseBodyZones() = default;
};
class DescribeZonesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeZonesResponseBodyZones>> zones{};

  DescribeZonesResponseBody() {}

  explicit DescribeZonesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (zones) {
      vector<boost::any> temp1;
      for(auto item1:*zones){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Zones"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Zones") != m.end() && !m["Zones"].empty()) {
      if (typeid(vector<boost::any>) == m["Zones"].type()) {
        vector<DescribeZonesResponseBodyZones> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Zones"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeZonesResponseBodyZones model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        zones = make_shared<vector<DescribeZonesResponseBodyZones>>(expect1);
      }
    }
  }


  virtual ~DescribeZonesResponseBody() = default;
};
class DescribeZonesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeZonesResponseBody> body{};

  DescribeZonesResponse() {}

  explicit DescribeZonesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeZonesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeZonesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeZonesResponse() = default;
};
class GetUploadOssUrlRequest : public Darabonba::Model {
public:
  shared_ptr<long> effectiveTimeMinutes{};
  shared_ptr<string> type{};

  GetUploadOssUrlRequest() {}

  explicit GetUploadOssUrlRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (effectiveTimeMinutes) {
      res["EffectiveTimeMinutes"] = boost::any(*effectiveTimeMinutes);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EffectiveTimeMinutes") != m.end() && !m["EffectiveTimeMinutes"].empty()) {
      effectiveTimeMinutes = make_shared<long>(boost::any_cast<long>(m["EffectiveTimeMinutes"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~GetUploadOssUrlRequest() = default;
};
class GetUploadOssUrlResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> expectedExpirationTime{};
  shared_ptr<string> ossKey{};
  shared_ptr<string> ossUrl{};

  GetUploadOssUrlResponseBodyData() {}

  explicit GetUploadOssUrlResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (expectedExpirationTime) {
      res["ExpectedExpirationTime"] = boost::any(*expectedExpirationTime);
    }
    if (ossKey) {
      res["OssKey"] = boost::any(*ossKey);
    }
    if (ossUrl) {
      res["OssUrl"] = boost::any(*ossUrl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ExpectedExpirationTime") != m.end() && !m["ExpectedExpirationTime"].empty()) {
      expectedExpirationTime = make_shared<string>(boost::any_cast<string>(m["ExpectedExpirationTime"]));
    }
    if (m.find("OssKey") != m.end() && !m["OssKey"].empty()) {
      ossKey = make_shared<string>(boost::any_cast<string>(m["OssKey"]));
    }
    if (m.find("OssUrl") != m.end() && !m["OssUrl"].empty()) {
      ossUrl = make_shared<string>(boost::any_cast<string>(m["OssUrl"]));
    }
  }


  virtual ~GetUploadOssUrlResponseBodyData() = default;
};
class GetUploadOssUrlResponseBodyErrorDetail : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<map<string, boost::any>> extraContext{};
  shared_ptr<string> level{};
  shared_ptr<string> message{};
  shared_ptr<map<string, string>> messageMcmsContext{};
  shared_ptr<string> messageMcmsKey{};
  shared_ptr<string> proposal{};
  shared_ptr<map<string, string>> proposalMcmsContext{};
  shared_ptr<string> proposalMcmsKey{};
  shared_ptr<string> reason{};
  shared_ptr<map<string, string>> reasonMcmsContext{};
  shared_ptr<string> reasonMcmsKey{};
  shared_ptr<boost::any> upstreamErrorDetail{};

  GetUploadOssUrlResponseBodyErrorDetail() {}

  explicit GetUploadOssUrlResponseBodyErrorDetail(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (extraContext) {
      res["ExtraContext"] = boost::any(*extraContext);
    }
    if (level) {
      res["Level"] = boost::any(*level);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (messageMcmsContext) {
      res["MessageMcmsContext"] = boost::any(*messageMcmsContext);
    }
    if (messageMcmsKey) {
      res["MessageMcmsKey"] = boost::any(*messageMcmsKey);
    }
    if (proposal) {
      res["Proposal"] = boost::any(*proposal);
    }
    if (proposalMcmsContext) {
      res["ProposalMcmsContext"] = boost::any(*proposalMcmsContext);
    }
    if (proposalMcmsKey) {
      res["ProposalMcmsKey"] = boost::any(*proposalMcmsKey);
    }
    if (reason) {
      res["Reason"] = boost::any(*reason);
    }
    if (reasonMcmsContext) {
      res["ReasonMcmsContext"] = boost::any(*reasonMcmsContext);
    }
    if (reasonMcmsKey) {
      res["ReasonMcmsKey"] = boost::any(*reasonMcmsKey);
    }
    if (upstreamErrorDetail) {
      res["UpstreamErrorDetail"] = boost::any(*upstreamErrorDetail);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ExtraContext") != m.end() && !m["ExtraContext"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["ExtraContext"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      extraContext = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<string>(boost::any_cast<string>(m["Level"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("MessageMcmsContext") != m.end() && !m["MessageMcmsContext"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["MessageMcmsContext"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      messageMcmsContext = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("MessageMcmsKey") != m.end() && !m["MessageMcmsKey"].empty()) {
      messageMcmsKey = make_shared<string>(boost::any_cast<string>(m["MessageMcmsKey"]));
    }
    if (m.find("Proposal") != m.end() && !m["Proposal"].empty()) {
      proposal = make_shared<string>(boost::any_cast<string>(m["Proposal"]));
    }
    if (m.find("ProposalMcmsContext") != m.end() && !m["ProposalMcmsContext"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["ProposalMcmsContext"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      proposalMcmsContext = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("ProposalMcmsKey") != m.end() && !m["ProposalMcmsKey"].empty()) {
      proposalMcmsKey = make_shared<string>(boost::any_cast<string>(m["ProposalMcmsKey"]));
    }
    if (m.find("Reason") != m.end() && !m["Reason"].empty()) {
      reason = make_shared<string>(boost::any_cast<string>(m["Reason"]));
    }
    if (m.find("ReasonMcmsContext") != m.end() && !m["ReasonMcmsContext"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["ReasonMcmsContext"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      reasonMcmsContext = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("ReasonMcmsKey") != m.end() && !m["ReasonMcmsKey"].empty()) {
      reasonMcmsKey = make_shared<string>(boost::any_cast<string>(m["ReasonMcmsKey"]));
    }
    if (m.find("UpstreamErrorDetail") != m.end() && !m["UpstreamErrorDetail"].empty()) {
      upstreamErrorDetail = make_shared<boost::any>(boost::any_cast<boost::any>(m["UpstreamErrorDetail"]));
    }
  }


  virtual ~GetUploadOssUrlResponseBodyErrorDetail() = default;
};
class GetUploadOssUrlResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> advice{};
  shared_ptr<string> code{};
  shared_ptr<string> cost{};
  shared_ptr<GetUploadOssUrlResponseBodyData> data{};
  shared_ptr<GetUploadOssUrlResponseBodyErrorDetail> errorDetail{};
  shared_ptr<string> message{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<long> totalCount{};

  GetUploadOssUrlResponseBody() {}

  explicit GetUploadOssUrlResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (advice) {
      res["Advice"] = boost::any(*advice);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (cost) {
      res["Cost"] = boost::any(*cost);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorDetail) {
      res["ErrorDetail"] = errorDetail ? boost::any(errorDetail->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Advice") != m.end() && !m["Advice"].empty()) {
      advice = make_shared<string>(boost::any_cast<string>(m["Advice"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Cost") != m.end() && !m["Cost"].empty()) {
      cost = make_shared<string>(boost::any_cast<string>(m["Cost"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetUploadOssUrlResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetUploadOssUrlResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorDetail") != m.end() && !m["ErrorDetail"].empty()) {
      if (typeid(map<string, boost::any>) == m["ErrorDetail"].type()) {
        GetUploadOssUrlResponseBodyErrorDetail model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ErrorDetail"]));
        errorDetail = make_shared<GetUploadOssUrlResponseBodyErrorDetail>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~GetUploadOssUrlResponseBody() = default;
};
class GetUploadOssUrlResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetUploadOssUrlResponseBody> body{};

  GetUploadOssUrlResponse() {}

  explicit GetUploadOssUrlResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetUploadOssUrlResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetUploadOssUrlResponseBody>(model1);
      }
    }
  }


  virtual ~GetUploadOssUrlResponse() = default;
};
class KillProcessListRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> sessionList{};
  shared_ptr<string> tenantId{};

  KillProcessListRequest() {}

  explicit KillProcessListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (sessionList) {
      res["SessionList"] = boost::any(*sessionList);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("SessionList") != m.end() && !m["SessionList"].empty()) {
      sessionList = make_shared<string>(boost::any_cast<string>(m["SessionList"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["TenantId"]));
    }
  }


  virtual ~KillProcessListRequest() = default;
};
class KillProcessListResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> clientIp{};
  shared_ptr<string> command{};
  shared_ptr<string> database{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> executeTime{};
  shared_ptr<string> serverIp{};
  shared_ptr<long> sessionId{};
  shared_ptr<string> sqlText{};
  shared_ptr<string> status{};
  shared_ptr<string> tenantId{};
  shared_ptr<string> user{};

  KillProcessListResponseBodyData() {}

  explicit KillProcessListResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientIp) {
      res["ClientIp"] = boost::any(*clientIp);
    }
    if (command) {
      res["Command"] = boost::any(*command);
    }
    if (database) {
      res["Database"] = boost::any(*database);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (executeTime) {
      res["ExecuteTime"] = boost::any(*executeTime);
    }
    if (serverIp) {
      res["ServerIp"] = boost::any(*serverIp);
    }
    if (sessionId) {
      res["SessionId"] = boost::any(*sessionId);
    }
    if (sqlText) {
      res["SqlText"] = boost::any(*sqlText);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    if (user) {
      res["User"] = boost::any(*user);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientIp") != m.end() && !m["ClientIp"].empty()) {
      clientIp = make_shared<string>(boost::any_cast<string>(m["ClientIp"]));
    }
    if (m.find("Command") != m.end() && !m["Command"].empty()) {
      command = make_shared<string>(boost::any_cast<string>(m["Command"]));
    }
    if (m.find("Database") != m.end() && !m["Database"].empty()) {
      database = make_shared<string>(boost::any_cast<string>(m["Database"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("ExecuteTime") != m.end() && !m["ExecuteTime"].empty()) {
      executeTime = make_shared<string>(boost::any_cast<string>(m["ExecuteTime"]));
    }
    if (m.find("ServerIp") != m.end() && !m["ServerIp"].empty()) {
      serverIp = make_shared<string>(boost::any_cast<string>(m["ServerIp"]));
    }
    if (m.find("SessionId") != m.end() && !m["SessionId"].empty()) {
      sessionId = make_shared<long>(boost::any_cast<long>(m["SessionId"]));
    }
    if (m.find("SqlText") != m.end() && !m["SqlText"].empty()) {
      sqlText = make_shared<string>(boost::any_cast<string>(m["SqlText"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["TenantId"]));
    }
    if (m.find("User") != m.end() && !m["User"].empty()) {
      user = make_shared<string>(boost::any_cast<string>(m["User"]));
    }
  }


  virtual ~KillProcessListResponseBodyData() = default;
};
class KillProcessListResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<KillProcessListResponseBodyData>> data{};
  shared_ptr<string> requestId{};

  KillProcessListResponseBody() {}

  explicit KillProcessListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<KillProcessListResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            KillProcessListResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<KillProcessListResponseBodyData>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~KillProcessListResponseBody() = default;
};
class KillProcessListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<KillProcessListResponseBody> body{};

  KillProcessListResponse() {}

  explicit KillProcessListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        KillProcessListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<KillProcessListResponseBody>(model1);
      }
    }
  }


  virtual ~KillProcessListResponse() = default;
};
class ListAllLabelsResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<string> name{};

  ListAllLabelsResponseBodyData() {}

  explicit ListAllLabelsResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~ListAllLabelsResponseBodyData() = default;
};
class ListAllLabelsResponseBodyErrorDetail : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<map<string, boost::any>> extraContext{};
  shared_ptr<string> level{};
  shared_ptr<string> message{};
  shared_ptr<map<string, string>> messageMcmsContext{};
  shared_ptr<string> messageMcmsKey{};
  shared_ptr<string> proposal{};
  shared_ptr<map<string, string>> proposalMcmsContext{};
  shared_ptr<string> proposalMcmsKey{};
  shared_ptr<string> reason{};
  shared_ptr<map<string, string>> reasonMcmsContext{};
  shared_ptr<string> reasonMcmsKey{};
  shared_ptr<boost::any> upstreamErrorDetail{};

  ListAllLabelsResponseBodyErrorDetail() {}

  explicit ListAllLabelsResponseBodyErrorDetail(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (extraContext) {
      res["ExtraContext"] = boost::any(*extraContext);
    }
    if (level) {
      res["Level"] = boost::any(*level);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (messageMcmsContext) {
      res["MessageMcmsContext"] = boost::any(*messageMcmsContext);
    }
    if (messageMcmsKey) {
      res["MessageMcmsKey"] = boost::any(*messageMcmsKey);
    }
    if (proposal) {
      res["Proposal"] = boost::any(*proposal);
    }
    if (proposalMcmsContext) {
      res["ProposalMcmsContext"] = boost::any(*proposalMcmsContext);
    }
    if (proposalMcmsKey) {
      res["ProposalMcmsKey"] = boost::any(*proposalMcmsKey);
    }
    if (reason) {
      res["Reason"] = boost::any(*reason);
    }
    if (reasonMcmsContext) {
      res["ReasonMcmsContext"] = boost::any(*reasonMcmsContext);
    }
    if (reasonMcmsKey) {
      res["ReasonMcmsKey"] = boost::any(*reasonMcmsKey);
    }
    if (upstreamErrorDetail) {
      res["UpstreamErrorDetail"] = boost::any(*upstreamErrorDetail);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ExtraContext") != m.end() && !m["ExtraContext"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["ExtraContext"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      extraContext = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<string>(boost::any_cast<string>(m["Level"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("MessageMcmsContext") != m.end() && !m["MessageMcmsContext"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["MessageMcmsContext"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      messageMcmsContext = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("MessageMcmsKey") != m.end() && !m["MessageMcmsKey"].empty()) {
      messageMcmsKey = make_shared<string>(boost::any_cast<string>(m["MessageMcmsKey"]));
    }
    if (m.find("Proposal") != m.end() && !m["Proposal"].empty()) {
      proposal = make_shared<string>(boost::any_cast<string>(m["Proposal"]));
    }
    if (m.find("ProposalMcmsContext") != m.end() && !m["ProposalMcmsContext"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["ProposalMcmsContext"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      proposalMcmsContext = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("ProposalMcmsKey") != m.end() && !m["ProposalMcmsKey"].empty()) {
      proposalMcmsKey = make_shared<string>(boost::any_cast<string>(m["ProposalMcmsKey"]));
    }
    if (m.find("Reason") != m.end() && !m["Reason"].empty()) {
      reason = make_shared<string>(boost::any_cast<string>(m["Reason"]));
    }
    if (m.find("ReasonMcmsContext") != m.end() && !m["ReasonMcmsContext"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["ReasonMcmsContext"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      reasonMcmsContext = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("ReasonMcmsKey") != m.end() && !m["ReasonMcmsKey"].empty()) {
      reasonMcmsKey = make_shared<string>(boost::any_cast<string>(m["ReasonMcmsKey"]));
    }
    if (m.find("UpstreamErrorDetail") != m.end() && !m["UpstreamErrorDetail"].empty()) {
      upstreamErrorDetail = make_shared<boost::any>(boost::any_cast<boost::any>(m["UpstreamErrorDetail"]));
    }
  }


  virtual ~ListAllLabelsResponseBodyErrorDetail() = default;
};
class ListAllLabelsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> advice{};
  shared_ptr<string> code{};
  shared_ptr<string> cost{};
  shared_ptr<vector<ListAllLabelsResponseBodyData>> data{};
  shared_ptr<ListAllLabelsResponseBodyErrorDetail> errorDetail{};
  shared_ptr<string> message{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<long> totalCount{};

  ListAllLabelsResponseBody() {}

  explicit ListAllLabelsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (advice) {
      res["Advice"] = boost::any(*advice);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (cost) {
      res["Cost"] = boost::any(*cost);
    }
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (errorDetail) {
      res["ErrorDetail"] = errorDetail ? boost::any(errorDetail->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Advice") != m.end() && !m["Advice"].empty()) {
      advice = make_shared<string>(boost::any_cast<string>(m["Advice"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Cost") != m.end() && !m["Cost"].empty()) {
      cost = make_shared<string>(boost::any_cast<string>(m["Cost"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<ListAllLabelsResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListAllLabelsResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<ListAllLabelsResponseBodyData>>(expect1);
      }
    }
    if (m.find("ErrorDetail") != m.end() && !m["ErrorDetail"].empty()) {
      if (typeid(map<string, boost::any>) == m["ErrorDetail"].type()) {
        ListAllLabelsResponseBodyErrorDetail model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ErrorDetail"]));
        errorDetail = make_shared<ListAllLabelsResponseBodyErrorDetail>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListAllLabelsResponseBody() = default;
};
class ListAllLabelsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListAllLabelsResponseBody> body{};

  ListAllLabelsResponse() {}

  explicit ListAllLabelsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListAllLabelsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListAllLabelsResponseBody>(model1);
      }
    }
  }


  virtual ~ListAllLabelsResponse() = default;
};
class ListDataSourceRequest : public Darabonba::Model {
public:
  shared_ptr<string> order{};
  shared_ptr<string> pageNumber{};
  shared_ptr<string> pageSize{};
  shared_ptr<string> searchKey{};
  shared_ptr<string> sortField{};
  shared_ptr<vector<string>> types{};

  ListDataSourceRequest() {}

  explicit ListDataSourceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (order) {
      res["Order"] = boost::any(*order);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (searchKey) {
      res["SearchKey"] = boost::any(*searchKey);
    }
    if (sortField) {
      res["SortField"] = boost::any(*sortField);
    }
    if (types) {
      res["Types"] = boost::any(*types);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Order") != m.end() && !m["Order"].empty()) {
      order = make_shared<string>(boost::any_cast<string>(m["Order"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<string>(boost::any_cast<string>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<string>(boost::any_cast<string>(m["PageSize"]));
    }
    if (m.find("SearchKey") != m.end() && !m["SearchKey"].empty()) {
      searchKey = make_shared<string>(boost::any_cast<string>(m["SearchKey"]));
    }
    if (m.find("SortField") != m.end() && !m["SortField"].empty()) {
      sortField = make_shared<string>(boost::any_cast<string>(m["SortField"]));
    }
    if (m.find("Types") != m.end() && !m["Types"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Types"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Types"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      types = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ListDataSourceRequest() = default;
};
class ListDataSourceShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> order{};
  shared_ptr<string> pageNumber{};
  shared_ptr<string> pageSize{};
  shared_ptr<string> searchKey{};
  shared_ptr<string> sortField{};
  shared_ptr<string> typesShrink{};

  ListDataSourceShrinkRequest() {}

  explicit ListDataSourceShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (order) {
      res["Order"] = boost::any(*order);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (searchKey) {
      res["SearchKey"] = boost::any(*searchKey);
    }
    if (sortField) {
      res["SortField"] = boost::any(*sortField);
    }
    if (typesShrink) {
      res["Types"] = boost::any(*typesShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Order") != m.end() && !m["Order"].empty()) {
      order = make_shared<string>(boost::any_cast<string>(m["Order"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<string>(boost::any_cast<string>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<string>(boost::any_cast<string>(m["PageSize"]));
    }
    if (m.find("SearchKey") != m.end() && !m["SearchKey"].empty()) {
      searchKey = make_shared<string>(boost::any_cast<string>(m["SearchKey"]));
    }
    if (m.find("SortField") != m.end() && !m["SortField"].empty()) {
      sortField = make_shared<string>(boost::any_cast<string>(m["SortField"]));
    }
    if (m.find("Types") != m.end() && !m["Types"].empty()) {
      typesShrink = make_shared<string>(boost::any_cast<string>(m["Types"]));
    }
  }


  virtual ~ListDataSourceShrinkRequest() = default;
};
class ListDataSourceResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> charset{};
  shared_ptr<string> cluster{};
  shared_ptr<boost::any> connExtraAttributes{};
  shared_ptr<string> description{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> gmtModified{};
  shared_ptr<string> id{};
  shared_ptr<string> ip{};
  shared_ptr<string> name{};
  shared_ptr<string> operatingSystem{};
  shared_ptr<string> oracleNlsLengthSemantics{};
  shared_ptr<string> oracleSid{};
  shared_ptr<string> owner{};
  shared_ptr<string> partnerId{};
  shared_ptr<long> port{};
  shared_ptr<string> region{};
  shared_ptr<string> resourceOwner{};
  shared_ptr<string> role{};
  shared_ptr<string> schema{};
  shared_ptr<string> tenant{};
  shared_ptr<string> timezone{};
  shared_ptr<string> type{};
  shared_ptr<string> userName{};
  shared_ptr<string> version{};
  shared_ptr<string> vpcId{};

  ListDataSourceResponseBodyData() {}

  explicit ListDataSourceResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (charset) {
      res["Charset"] = boost::any(*charset);
    }
    if (cluster) {
      res["Cluster"] = boost::any(*cluster);
    }
    if (connExtraAttributes) {
      res["ConnExtraAttributes"] = boost::any(*connExtraAttributes);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (ip) {
      res["Ip"] = boost::any(*ip);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (operatingSystem) {
      res["OperatingSystem"] = boost::any(*operatingSystem);
    }
    if (oracleNlsLengthSemantics) {
      res["OracleNlsLengthSemantics"] = boost::any(*oracleNlsLengthSemantics);
    }
    if (oracleSid) {
      res["OracleSid"] = boost::any(*oracleSid);
    }
    if (owner) {
      res["Owner"] = boost::any(*owner);
    }
    if (partnerId) {
      res["PartnerId"] = boost::any(*partnerId);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (resourceOwner) {
      res["ResourceOwner"] = boost::any(*resourceOwner);
    }
    if (role) {
      res["Role"] = boost::any(*role);
    }
    if (schema) {
      res["Schema"] = boost::any(*schema);
    }
    if (tenant) {
      res["Tenant"] = boost::any(*tenant);
    }
    if (timezone) {
      res["Timezone"] = boost::any(*timezone);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (userName) {
      res["UserName"] = boost::any(*userName);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Charset") != m.end() && !m["Charset"].empty()) {
      charset = make_shared<string>(boost::any_cast<string>(m["Charset"]));
    }
    if (m.find("Cluster") != m.end() && !m["Cluster"].empty()) {
      cluster = make_shared<string>(boost::any_cast<string>(m["Cluster"]));
    }
    if (m.find("ConnExtraAttributes") != m.end() && !m["ConnExtraAttributes"].empty()) {
      connExtraAttributes = make_shared<boost::any>(boost::any_cast<boost::any>(m["ConnExtraAttributes"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["GmtCreate"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<string>(boost::any_cast<string>(m["GmtModified"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Ip") != m.end() && !m["Ip"].empty()) {
      ip = make_shared<string>(boost::any_cast<string>(m["Ip"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("OperatingSystem") != m.end() && !m["OperatingSystem"].empty()) {
      operatingSystem = make_shared<string>(boost::any_cast<string>(m["OperatingSystem"]));
    }
    if (m.find("OracleNlsLengthSemantics") != m.end() && !m["OracleNlsLengthSemantics"].empty()) {
      oracleNlsLengthSemantics = make_shared<string>(boost::any_cast<string>(m["OracleNlsLengthSemantics"]));
    }
    if (m.find("OracleSid") != m.end() && !m["OracleSid"].empty()) {
      oracleSid = make_shared<string>(boost::any_cast<string>(m["OracleSid"]));
    }
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      owner = make_shared<string>(boost::any_cast<string>(m["Owner"]));
    }
    if (m.find("PartnerId") != m.end() && !m["PartnerId"].empty()) {
      partnerId = make_shared<string>(boost::any_cast<string>(m["PartnerId"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<long>(boost::any_cast<long>(m["Port"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("ResourceOwner") != m.end() && !m["ResourceOwner"].empty()) {
      resourceOwner = make_shared<string>(boost::any_cast<string>(m["ResourceOwner"]));
    }
    if (m.find("Role") != m.end() && !m["Role"].empty()) {
      role = make_shared<string>(boost::any_cast<string>(m["Role"]));
    }
    if (m.find("Schema") != m.end() && !m["Schema"].empty()) {
      schema = make_shared<string>(boost::any_cast<string>(m["Schema"]));
    }
    if (m.find("Tenant") != m.end() && !m["Tenant"].empty()) {
      tenant = make_shared<string>(boost::any_cast<string>(m["Tenant"]));
    }
    if (m.find("Timezone") != m.end() && !m["Timezone"].empty()) {
      timezone = make_shared<string>(boost::any_cast<string>(m["Timezone"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("UserName") != m.end() && !m["UserName"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["UserName"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["Version"]));
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
  }


  virtual ~ListDataSourceResponseBodyData() = default;
};
class ListDataSourceResponseBodyErrorDetail : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<map<string, boost::any>> extraContext{};
  shared_ptr<string> level{};
  shared_ptr<string> message{};
  shared_ptr<map<string, string>> messageMcmsContext{};
  shared_ptr<string> messageMcmsKey{};
  shared_ptr<string> proposal{};
  shared_ptr<map<string, string>> proposalMcmsContext{};
  shared_ptr<string> proposalMcmsKey{};
  shared_ptr<string> reason{};
  shared_ptr<map<string, string>> reasonMcmsContext{};
  shared_ptr<string> reasonMcmsKey{};
  shared_ptr<boost::any> upstreamErrorDetail{};

  ListDataSourceResponseBodyErrorDetail() {}

  explicit ListDataSourceResponseBodyErrorDetail(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (extraContext) {
      res["ExtraContext"] = boost::any(*extraContext);
    }
    if (level) {
      res["Level"] = boost::any(*level);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (messageMcmsContext) {
      res["MessageMcmsContext"] = boost::any(*messageMcmsContext);
    }
    if (messageMcmsKey) {
      res["MessageMcmsKey"] = boost::any(*messageMcmsKey);
    }
    if (proposal) {
      res["Proposal"] = boost::any(*proposal);
    }
    if (proposalMcmsContext) {
      res["ProposalMcmsContext"] = boost::any(*proposalMcmsContext);
    }
    if (proposalMcmsKey) {
      res["ProposalMcmsKey"] = boost::any(*proposalMcmsKey);
    }
    if (reason) {
      res["Reason"] = boost::any(*reason);
    }
    if (reasonMcmsContext) {
      res["ReasonMcmsContext"] = boost::any(*reasonMcmsContext);
    }
    if (reasonMcmsKey) {
      res["ReasonMcmsKey"] = boost::any(*reasonMcmsKey);
    }
    if (upstreamErrorDetail) {
      res["UpstreamErrorDetail"] = boost::any(*upstreamErrorDetail);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ExtraContext") != m.end() && !m["ExtraContext"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["ExtraContext"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      extraContext = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<string>(boost::any_cast<string>(m["Level"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("MessageMcmsContext") != m.end() && !m["MessageMcmsContext"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["MessageMcmsContext"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      messageMcmsContext = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("MessageMcmsKey") != m.end() && !m["MessageMcmsKey"].empty()) {
      messageMcmsKey = make_shared<string>(boost::any_cast<string>(m["MessageMcmsKey"]));
    }
    if (m.find("Proposal") != m.end() && !m["Proposal"].empty()) {
      proposal = make_shared<string>(boost::any_cast<string>(m["Proposal"]));
    }
    if (m.find("ProposalMcmsContext") != m.end() && !m["ProposalMcmsContext"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["ProposalMcmsContext"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      proposalMcmsContext = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("ProposalMcmsKey") != m.end() && !m["ProposalMcmsKey"].empty()) {
      proposalMcmsKey = make_shared<string>(boost::any_cast<string>(m["ProposalMcmsKey"]));
    }
    if (m.find("Reason") != m.end() && !m["Reason"].empty()) {
      reason = make_shared<string>(boost::any_cast<string>(m["Reason"]));
    }
    if (m.find("ReasonMcmsContext") != m.end() && !m["ReasonMcmsContext"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["ReasonMcmsContext"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      reasonMcmsContext = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("ReasonMcmsKey") != m.end() && !m["ReasonMcmsKey"].empty()) {
      reasonMcmsKey = make_shared<string>(boost::any_cast<string>(m["ReasonMcmsKey"]));
    }
    if (m.find("UpstreamErrorDetail") != m.end() && !m["UpstreamErrorDetail"].empty()) {
      upstreamErrorDetail = make_shared<boost::any>(boost::any_cast<boost::any>(m["UpstreamErrorDetail"]));
    }
  }


  virtual ~ListDataSourceResponseBodyErrorDetail() = default;
};
class ListDataSourceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> advice{};
  shared_ptr<string> code{};
  shared_ptr<string> cost{};
  shared_ptr<vector<ListDataSourceResponseBodyData>> data{};
  shared_ptr<ListDataSourceResponseBodyErrorDetail> errorDetail{};
  shared_ptr<string> message{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<long> totalCount{};

  ListDataSourceResponseBody() {}

  explicit ListDataSourceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (advice) {
      res["Advice"] = boost::any(*advice);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (cost) {
      res["Cost"] = boost::any(*cost);
    }
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (errorDetail) {
      res["ErrorDetail"] = errorDetail ? boost::any(errorDetail->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Advice") != m.end() && !m["Advice"].empty()) {
      advice = make_shared<string>(boost::any_cast<string>(m["Advice"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Cost") != m.end() && !m["Cost"].empty()) {
      cost = make_shared<string>(boost::any_cast<string>(m["Cost"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<ListDataSourceResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDataSourceResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<ListDataSourceResponseBodyData>>(expect1);
      }
    }
    if (m.find("ErrorDetail") != m.end() && !m["ErrorDetail"].empty()) {
      if (typeid(map<string, boost::any>) == m["ErrorDetail"].type()) {
        ListDataSourceResponseBodyErrorDetail model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ErrorDetail"]));
        errorDetail = make_shared<ListDataSourceResponseBodyErrorDetail>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListDataSourceResponseBody() = default;
};
class ListDataSourceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListDataSourceResponseBody> body{};

  ListDataSourceResponse() {}

  explicit ListDataSourceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListDataSourceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListDataSourceResponseBody>(model1);
      }
    }
  }


  virtual ~ListDataSourceResponse() = default;
};
class ListProjectFullVerifyResultRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> destSchemas{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> projectId{};
  shared_ptr<vector<string>> sourceSchemas{};
  shared_ptr<string> status{};

  ListProjectFullVerifyResultRequest() {}

  explicit ListProjectFullVerifyResultRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (destSchemas) {
      res["DestSchemas"] = boost::any(*destSchemas);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (sourceSchemas) {
      res["SourceSchemas"] = boost::any(*sourceSchemas);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DestSchemas") != m.end() && !m["DestSchemas"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DestSchemas"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DestSchemas"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      destSchemas = make_shared<vector<string>>(toVec1);
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("SourceSchemas") != m.end() && !m["SourceSchemas"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SourceSchemas"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SourceSchemas"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      sourceSchemas = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~ListProjectFullVerifyResultRequest() = default;
};
class ListProjectFullVerifyResultShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> destSchemasShrink{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> projectId{};
  shared_ptr<string> sourceSchemasShrink{};
  shared_ptr<string> status{};

  ListProjectFullVerifyResultShrinkRequest() {}

  explicit ListProjectFullVerifyResultShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (destSchemasShrink) {
      res["DestSchemas"] = boost::any(*destSchemasShrink);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (sourceSchemasShrink) {
      res["SourceSchemas"] = boost::any(*sourceSchemasShrink);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DestSchemas") != m.end() && !m["DestSchemas"].empty()) {
      destSchemasShrink = make_shared<string>(boost::any_cast<string>(m["DestSchemas"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("SourceSchemas") != m.end() && !m["SourceSchemas"].empty()) {
      sourceSchemasShrink = make_shared<string>(boost::any_cast<string>(m["SourceSchemas"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~ListProjectFullVerifyResultShrinkRequest() = default;
};
class ListProjectFullVerifyResultResponseBodyDataFullVerifyTableStatisticsErrorDetails : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<map<string, boost::any>> extraContext{};
  shared_ptr<string> level{};
  shared_ptr<string> message{};
  shared_ptr<map<string, string>> messageMcmsContext{};
  shared_ptr<string> messageMcmsKey{};
  shared_ptr<string> proposal{};
  shared_ptr<map<string, string>> proposalMcmsContext{};
  shared_ptr<string> proposalMcmsKey{};
  shared_ptr<string> reason{};
  shared_ptr<map<string, string>> reasonMcmsContext{};
  shared_ptr<string> reasonMcmsKey{};
  shared_ptr<boost::any> upstreamErrorDetail{};

  ListProjectFullVerifyResultResponseBodyDataFullVerifyTableStatisticsErrorDetails() {}

  explicit ListProjectFullVerifyResultResponseBodyDataFullVerifyTableStatisticsErrorDetails(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (extraContext) {
      res["ExtraContext"] = boost::any(*extraContext);
    }
    if (level) {
      res["Level"] = boost::any(*level);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (messageMcmsContext) {
      res["MessageMcmsContext"] = boost::any(*messageMcmsContext);
    }
    if (messageMcmsKey) {
      res["MessageMcmsKey"] = boost::any(*messageMcmsKey);
    }
    if (proposal) {
      res["Proposal"] = boost::any(*proposal);
    }
    if (proposalMcmsContext) {
      res["ProposalMcmsContext"] = boost::any(*proposalMcmsContext);
    }
    if (proposalMcmsKey) {
      res["ProposalMcmsKey"] = boost::any(*proposalMcmsKey);
    }
    if (reason) {
      res["Reason"] = boost::any(*reason);
    }
    if (reasonMcmsContext) {
      res["ReasonMcmsContext"] = boost::any(*reasonMcmsContext);
    }
    if (reasonMcmsKey) {
      res["ReasonMcmsKey"] = boost::any(*reasonMcmsKey);
    }
    if (upstreamErrorDetail) {
      res["UpstreamErrorDetail"] = boost::any(*upstreamErrorDetail);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ExtraContext") != m.end() && !m["ExtraContext"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["ExtraContext"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      extraContext = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<string>(boost::any_cast<string>(m["Level"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("MessageMcmsContext") != m.end() && !m["MessageMcmsContext"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["MessageMcmsContext"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      messageMcmsContext = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("MessageMcmsKey") != m.end() && !m["MessageMcmsKey"].empty()) {
      messageMcmsKey = make_shared<string>(boost::any_cast<string>(m["MessageMcmsKey"]));
    }
    if (m.find("Proposal") != m.end() && !m["Proposal"].empty()) {
      proposal = make_shared<string>(boost::any_cast<string>(m["Proposal"]));
    }
    if (m.find("ProposalMcmsContext") != m.end() && !m["ProposalMcmsContext"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["ProposalMcmsContext"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      proposalMcmsContext = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("ProposalMcmsKey") != m.end() && !m["ProposalMcmsKey"].empty()) {
      proposalMcmsKey = make_shared<string>(boost::any_cast<string>(m["ProposalMcmsKey"]));
    }
    if (m.find("Reason") != m.end() && !m["Reason"].empty()) {
      reason = make_shared<string>(boost::any_cast<string>(m["Reason"]));
    }
    if (m.find("ReasonMcmsContext") != m.end() && !m["ReasonMcmsContext"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["ReasonMcmsContext"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      reasonMcmsContext = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("ReasonMcmsKey") != m.end() && !m["ReasonMcmsKey"].empty()) {
      reasonMcmsKey = make_shared<string>(boost::any_cast<string>(m["ReasonMcmsKey"]));
    }
    if (m.find("UpstreamErrorDetail") != m.end() && !m["UpstreamErrorDetail"].empty()) {
      upstreamErrorDetail = make_shared<boost::any>(boost::any_cast<boost::any>(m["UpstreamErrorDetail"]));
    }
  }


  virtual ~ListProjectFullVerifyResultResponseBodyDataFullVerifyTableStatisticsErrorDetails() = default;
};
class ListProjectFullVerifyResultResponseBodyDataFullVerifyTableStatistics : public Darabonba::Model {
public:
  shared_ptr<long> consistentCount{};
  shared_ptr<long> destOnlyCount{};
  shared_ptr<string> destSchemaName{};
  shared_ptr<vector<ListProjectFullVerifyResultResponseBodyDataFullVerifyTableStatisticsErrorDetails>> errorDetails{};
  shared_ptr<string> message{};
  shared_ptr<long> mismatchedCount{};
  shared_ptr<string> progress{};
  shared_ptr<string> resultDesc{};
  shared_ptr<string> resultType{};
  shared_ptr<long> sourceOnlyCount{};
  shared_ptr<string> sourceSchemaName{};
  shared_ptr<string> sourceTableName{};
  shared_ptr<string> status{};

  ListProjectFullVerifyResultResponseBodyDataFullVerifyTableStatistics() {}

  explicit ListProjectFullVerifyResultResponseBodyDataFullVerifyTableStatistics(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (consistentCount) {
      res["ConsistentCount"] = boost::any(*consistentCount);
    }
    if (destOnlyCount) {
      res["DestOnlyCount"] = boost::any(*destOnlyCount);
    }
    if (destSchemaName) {
      res["DestSchemaName"] = boost::any(*destSchemaName);
    }
    if (errorDetails) {
      vector<boost::any> temp1;
      for(auto item1:*errorDetails){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ErrorDetails"] = boost::any(temp1);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (mismatchedCount) {
      res["MismatchedCount"] = boost::any(*mismatchedCount);
    }
    if (progress) {
      res["Progress"] = boost::any(*progress);
    }
    if (resultDesc) {
      res["ResultDesc"] = boost::any(*resultDesc);
    }
    if (resultType) {
      res["ResultType"] = boost::any(*resultType);
    }
    if (sourceOnlyCount) {
      res["SourceOnlyCount"] = boost::any(*sourceOnlyCount);
    }
    if (sourceSchemaName) {
      res["SourceSchemaName"] = boost::any(*sourceSchemaName);
    }
    if (sourceTableName) {
      res["SourceTableName"] = boost::any(*sourceTableName);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConsistentCount") != m.end() && !m["ConsistentCount"].empty()) {
      consistentCount = make_shared<long>(boost::any_cast<long>(m["ConsistentCount"]));
    }
    if (m.find("DestOnlyCount") != m.end() && !m["DestOnlyCount"].empty()) {
      destOnlyCount = make_shared<long>(boost::any_cast<long>(m["DestOnlyCount"]));
    }
    if (m.find("DestSchemaName") != m.end() && !m["DestSchemaName"].empty()) {
      destSchemaName = make_shared<string>(boost::any_cast<string>(m["DestSchemaName"]));
    }
    if (m.find("ErrorDetails") != m.end() && !m["ErrorDetails"].empty()) {
      if (typeid(vector<boost::any>) == m["ErrorDetails"].type()) {
        vector<ListProjectFullVerifyResultResponseBodyDataFullVerifyTableStatisticsErrorDetails> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ErrorDetails"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListProjectFullVerifyResultResponseBodyDataFullVerifyTableStatisticsErrorDetails model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        errorDetails = make_shared<vector<ListProjectFullVerifyResultResponseBodyDataFullVerifyTableStatisticsErrorDetails>>(expect1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("MismatchedCount") != m.end() && !m["MismatchedCount"].empty()) {
      mismatchedCount = make_shared<long>(boost::any_cast<long>(m["MismatchedCount"]));
    }
    if (m.find("Progress") != m.end() && !m["Progress"].empty()) {
      progress = make_shared<string>(boost::any_cast<string>(m["Progress"]));
    }
    if (m.find("ResultDesc") != m.end() && !m["ResultDesc"].empty()) {
      resultDesc = make_shared<string>(boost::any_cast<string>(m["ResultDesc"]));
    }
    if (m.find("ResultType") != m.end() && !m["ResultType"].empty()) {
      resultType = make_shared<string>(boost::any_cast<string>(m["ResultType"]));
    }
    if (m.find("SourceOnlyCount") != m.end() && !m["SourceOnlyCount"].empty()) {
      sourceOnlyCount = make_shared<long>(boost::any_cast<long>(m["SourceOnlyCount"]));
    }
    if (m.find("SourceSchemaName") != m.end() && !m["SourceSchemaName"].empty()) {
      sourceSchemaName = make_shared<string>(boost::any_cast<string>(m["SourceSchemaName"]));
    }
    if (m.find("SourceTableName") != m.end() && !m["SourceTableName"].empty()) {
      sourceTableName = make_shared<string>(boost::any_cast<string>(m["SourceTableName"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~ListProjectFullVerifyResultResponseBodyDataFullVerifyTableStatistics() = default;
};
class ListProjectFullVerifyResultResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> differentNumber{};
  shared_ptr<vector<ListProjectFullVerifyResultResponseBodyDataFullVerifyTableStatistics>> fullVerifyTableStatistics{};

  ListProjectFullVerifyResultResponseBodyData() {}

  explicit ListProjectFullVerifyResultResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (differentNumber) {
      res["DifferentNumber"] = boost::any(*differentNumber);
    }
    if (fullVerifyTableStatistics) {
      vector<boost::any> temp1;
      for(auto item1:*fullVerifyTableStatistics){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["FullVerifyTableStatistics"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DifferentNumber") != m.end() && !m["DifferentNumber"].empty()) {
      differentNumber = make_shared<long>(boost::any_cast<long>(m["DifferentNumber"]));
    }
    if (m.find("FullVerifyTableStatistics") != m.end() && !m["FullVerifyTableStatistics"].empty()) {
      if (typeid(vector<boost::any>) == m["FullVerifyTableStatistics"].type()) {
        vector<ListProjectFullVerifyResultResponseBodyDataFullVerifyTableStatistics> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["FullVerifyTableStatistics"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListProjectFullVerifyResultResponseBodyDataFullVerifyTableStatistics model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        fullVerifyTableStatistics = make_shared<vector<ListProjectFullVerifyResultResponseBodyDataFullVerifyTableStatistics>>(expect1);
      }
    }
  }


  virtual ~ListProjectFullVerifyResultResponseBodyData() = default;
};
class ListProjectFullVerifyResultResponseBodyErrorDetail : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<map<string, boost::any>> extraContext{};
  shared_ptr<string> level{};
  shared_ptr<string> message{};
  shared_ptr<map<string, string>> messageMcmsContext{};
  shared_ptr<string> messageMcmsKey{};
  shared_ptr<string> proposal{};
  shared_ptr<map<string, string>> proposalMcmsContext{};
  shared_ptr<string> proposalMcmsKey{};
  shared_ptr<string> reason{};
  shared_ptr<map<string, string>> reasonMcmsContext{};
  shared_ptr<string> reasonMcmsKey{};
  shared_ptr<boost::any> upstreamErrorDetail{};

  ListProjectFullVerifyResultResponseBodyErrorDetail() {}

  explicit ListProjectFullVerifyResultResponseBodyErrorDetail(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (extraContext) {
      res["ExtraContext"] = boost::any(*extraContext);
    }
    if (level) {
      res["Level"] = boost::any(*level);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (messageMcmsContext) {
      res["MessageMcmsContext"] = boost::any(*messageMcmsContext);
    }
    if (messageMcmsKey) {
      res["MessageMcmsKey"] = boost::any(*messageMcmsKey);
    }
    if (proposal) {
      res["Proposal"] = boost::any(*proposal);
    }
    if (proposalMcmsContext) {
      res["ProposalMcmsContext"] = boost::any(*proposalMcmsContext);
    }
    if (proposalMcmsKey) {
      res["ProposalMcmsKey"] = boost::any(*proposalMcmsKey);
    }
    if (reason) {
      res["Reason"] = boost::any(*reason);
    }
    if (reasonMcmsContext) {
      res["ReasonMcmsContext"] = boost::any(*reasonMcmsContext);
    }
    if (reasonMcmsKey) {
      res["ReasonMcmsKey"] = boost::any(*reasonMcmsKey);
    }
    if (upstreamErrorDetail) {
      res["UpstreamErrorDetail"] = boost::any(*upstreamErrorDetail);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ExtraContext") != m.end() && !m["ExtraContext"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["ExtraContext"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      extraContext = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<string>(boost::any_cast<string>(m["Level"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("MessageMcmsContext") != m.end() && !m["MessageMcmsContext"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["MessageMcmsContext"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      messageMcmsContext = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("MessageMcmsKey") != m.end() && !m["MessageMcmsKey"].empty()) {
      messageMcmsKey = make_shared<string>(boost::any_cast<string>(m["MessageMcmsKey"]));
    }
    if (m.find("Proposal") != m.end() && !m["Proposal"].empty()) {
      proposal = make_shared<string>(boost::any_cast<string>(m["Proposal"]));
    }
    if (m.find("ProposalMcmsContext") != m.end() && !m["ProposalMcmsContext"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["ProposalMcmsContext"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      proposalMcmsContext = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("ProposalMcmsKey") != m.end() && !m["ProposalMcmsKey"].empty()) {
      proposalMcmsKey = make_shared<string>(boost::any_cast<string>(m["ProposalMcmsKey"]));
    }
    if (m.find("Reason") != m.end() && !m["Reason"].empty()) {
      reason = make_shared<string>(boost::any_cast<string>(m["Reason"]));
    }
    if (m.find("ReasonMcmsContext") != m.end() && !m["ReasonMcmsContext"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["ReasonMcmsContext"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      reasonMcmsContext = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("ReasonMcmsKey") != m.end() && !m["ReasonMcmsKey"].empty()) {
      reasonMcmsKey = make_shared<string>(boost::any_cast<string>(m["ReasonMcmsKey"]));
    }
    if (m.find("UpstreamErrorDetail") != m.end() && !m["UpstreamErrorDetail"].empty()) {
      upstreamErrorDetail = make_shared<boost::any>(boost::any_cast<boost::any>(m["UpstreamErrorDetail"]));
    }
  }


  virtual ~ListProjectFullVerifyResultResponseBodyErrorDetail() = default;
};
class ListProjectFullVerifyResultResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> advice{};
  shared_ptr<string> code{};
  shared_ptr<string> cost{};
  shared_ptr<ListProjectFullVerifyResultResponseBodyData> data{};
  shared_ptr<ListProjectFullVerifyResultResponseBodyErrorDetail> errorDetail{};
  shared_ptr<string> message{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<long> totalCount{};

  ListProjectFullVerifyResultResponseBody() {}

  explicit ListProjectFullVerifyResultResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (advice) {
      res["Advice"] = boost::any(*advice);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (cost) {
      res["Cost"] = boost::any(*cost);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorDetail) {
      res["ErrorDetail"] = errorDetail ? boost::any(errorDetail->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Advice") != m.end() && !m["Advice"].empty()) {
      advice = make_shared<string>(boost::any_cast<string>(m["Advice"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Cost") != m.end() && !m["Cost"].empty()) {
      cost = make_shared<string>(boost::any_cast<string>(m["Cost"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ListProjectFullVerifyResultResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ListProjectFullVerifyResultResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorDetail") != m.end() && !m["ErrorDetail"].empty()) {
      if (typeid(map<string, boost::any>) == m["ErrorDetail"].type()) {
        ListProjectFullVerifyResultResponseBodyErrorDetail model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ErrorDetail"]));
        errorDetail = make_shared<ListProjectFullVerifyResultResponseBodyErrorDetail>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListProjectFullVerifyResultResponseBody() = default;
};
class ListProjectFullVerifyResultResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListProjectFullVerifyResultResponseBody> body{};

  ListProjectFullVerifyResultResponse() {}

  explicit ListProjectFullVerifyResultResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListProjectFullVerifyResultResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListProjectFullVerifyResultResponseBody>(model1);
      }
    }
  }


  virtual ~ListProjectFullVerifyResultResponse() = default;
};
class ListProjectModifyRecordsRequest : public Darabonba::Model {
public:
  shared_ptr<string> id{};

  ListProjectModifyRecordsRequest() {}

  explicit ListProjectModifyRecordsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
  }


  virtual ~ListProjectModifyRecordsRequest() = default;
};
class ListProjectModifyRecordsResponseBodyDataDatabasesSpecificTablesAdbTableSchema : public Darabonba::Model {
public:
  shared_ptr<vector<string>> distributedKeys{};
  shared_ptr<long> partitionLifeCycle{};
  shared_ptr<string> partitionStatement{};
  shared_ptr<vector<string>> primaryKeys{};

  ListProjectModifyRecordsResponseBodyDataDatabasesSpecificTablesAdbTableSchema() {}

  explicit ListProjectModifyRecordsResponseBodyDataDatabasesSpecificTablesAdbTableSchema(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (distributedKeys) {
      res["DistributedKeys"] = boost::any(*distributedKeys);
    }
    if (partitionLifeCycle) {
      res["PartitionLifeCycle"] = boost::any(*partitionLifeCycle);
    }
    if (partitionStatement) {
      res["PartitionStatement"] = boost::any(*partitionStatement);
    }
    if (primaryKeys) {
      res["PrimaryKeys"] = boost::any(*primaryKeys);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DistributedKeys") != m.end() && !m["DistributedKeys"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DistributedKeys"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DistributedKeys"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      distributedKeys = make_shared<vector<string>>(toVec1);
    }
    if (m.find("PartitionLifeCycle") != m.end() && !m["PartitionLifeCycle"].empty()) {
      partitionLifeCycle = make_shared<long>(boost::any_cast<long>(m["PartitionLifeCycle"]));
    }
    if (m.find("PartitionStatement") != m.end() && !m["PartitionStatement"].empty()) {
      partitionStatement = make_shared<string>(boost::any_cast<string>(m["PartitionStatement"]));
    }
    if (m.find("PrimaryKeys") != m.end() && !m["PrimaryKeys"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["PrimaryKeys"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["PrimaryKeys"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      primaryKeys = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ListProjectModifyRecordsResponseBodyDataDatabasesSpecificTablesAdbTableSchema() = default;
};
class ListProjectModifyRecordsResponseBodyDataDatabasesSpecificTablesColumns : public Darabonba::Model {
public:
  shared_ptr<string> columnComment{};
  shared_ptr<string> columnKey{};
  shared_ptr<string> columnName{};
  shared_ptr<string> columnType{};
  shared_ptr<long> dataLength{};
  shared_ptr<long> dataPrecision{};
  shared_ptr<long> dataScale{};
  shared_ptr<string> defaultValue{};
  shared_ptr<string> encoding{};
  shared_ptr<bool> isGenerateField{};
  shared_ptr<string> mappedName{};
  shared_ptr<bool> nullable{};
  shared_ptr<long> position{};
  shared_ptr<string> rawColumnType{};
  shared_ptr<string> recordFieldType{};
  shared_ptr<string> type{};

  ListProjectModifyRecordsResponseBodyDataDatabasesSpecificTablesColumns() {}

  explicit ListProjectModifyRecordsResponseBodyDataDatabasesSpecificTablesColumns(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (columnComment) {
      res["ColumnComment"] = boost::any(*columnComment);
    }
    if (columnKey) {
      res["ColumnKey"] = boost::any(*columnKey);
    }
    if (columnName) {
      res["ColumnName"] = boost::any(*columnName);
    }
    if (columnType) {
      res["ColumnType"] = boost::any(*columnType);
    }
    if (dataLength) {
      res["DataLength"] = boost::any(*dataLength);
    }
    if (dataPrecision) {
      res["DataPrecision"] = boost::any(*dataPrecision);
    }
    if (dataScale) {
      res["DataScale"] = boost::any(*dataScale);
    }
    if (defaultValue) {
      res["DefaultValue"] = boost::any(*defaultValue);
    }
    if (encoding) {
      res["Encoding"] = boost::any(*encoding);
    }
    if (isGenerateField) {
      res["IsGenerateField"] = boost::any(*isGenerateField);
    }
    if (mappedName) {
      res["MappedName"] = boost::any(*mappedName);
    }
    if (nullable) {
      res["Nullable"] = boost::any(*nullable);
    }
    if (position) {
      res["Position"] = boost::any(*position);
    }
    if (rawColumnType) {
      res["RawColumnType"] = boost::any(*rawColumnType);
    }
    if (recordFieldType) {
      res["RecordFieldType"] = boost::any(*recordFieldType);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ColumnComment") != m.end() && !m["ColumnComment"].empty()) {
      columnComment = make_shared<string>(boost::any_cast<string>(m["ColumnComment"]));
    }
    if (m.find("ColumnKey") != m.end() && !m["ColumnKey"].empty()) {
      columnKey = make_shared<string>(boost::any_cast<string>(m["ColumnKey"]));
    }
    if (m.find("ColumnName") != m.end() && !m["ColumnName"].empty()) {
      columnName = make_shared<string>(boost::any_cast<string>(m["ColumnName"]));
    }
    if (m.find("ColumnType") != m.end() && !m["ColumnType"].empty()) {
      columnType = make_shared<string>(boost::any_cast<string>(m["ColumnType"]));
    }
    if (m.find("DataLength") != m.end() && !m["DataLength"].empty()) {
      dataLength = make_shared<long>(boost::any_cast<long>(m["DataLength"]));
    }
    if (m.find("DataPrecision") != m.end() && !m["DataPrecision"].empty()) {
      dataPrecision = make_shared<long>(boost::any_cast<long>(m["DataPrecision"]));
    }
    if (m.find("DataScale") != m.end() && !m["DataScale"].empty()) {
      dataScale = make_shared<long>(boost::any_cast<long>(m["DataScale"]));
    }
    if (m.find("DefaultValue") != m.end() && !m["DefaultValue"].empty()) {
      defaultValue = make_shared<string>(boost::any_cast<string>(m["DefaultValue"]));
    }
    if (m.find("Encoding") != m.end() && !m["Encoding"].empty()) {
      encoding = make_shared<string>(boost::any_cast<string>(m["Encoding"]));
    }
    if (m.find("IsGenerateField") != m.end() && !m["IsGenerateField"].empty()) {
      isGenerateField = make_shared<bool>(boost::any_cast<bool>(m["IsGenerateField"]));
    }
    if (m.find("MappedName") != m.end() && !m["MappedName"].empty()) {
      mappedName = make_shared<string>(boost::any_cast<string>(m["MappedName"]));
    }
    if (m.find("Nullable") != m.end() && !m["Nullable"].empty()) {
      nullable = make_shared<bool>(boost::any_cast<bool>(m["Nullable"]));
    }
    if (m.find("Position") != m.end() && !m["Position"].empty()) {
      position = make_shared<long>(boost::any_cast<long>(m["Position"]));
    }
    if (m.find("RawColumnType") != m.end() && !m["RawColumnType"].empty()) {
      rawColumnType = make_shared<string>(boost::any_cast<string>(m["RawColumnType"]));
    }
    if (m.find("RecordFieldType") != m.end() && !m["RecordFieldType"].empty()) {
      recordFieldType = make_shared<string>(boost::any_cast<string>(m["RecordFieldType"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListProjectModifyRecordsResponseBodyDataDatabasesSpecificTablesColumns() = default;
};
class ListProjectModifyRecordsResponseBodyDataDatabasesSpecificTables : public Darabonba::Model {
public:
  shared_ptr<ListProjectModifyRecordsResponseBodyDataDatabasesSpecificTablesAdbTableSchema> adbTableSchema{};
  shared_ptr<vector<ListProjectModifyRecordsResponseBodyDataDatabasesSpecificTablesColumns>> columns{};
  shared_ptr<vector<string>> filterColumns{};
  shared_ptr<string> id{};
  shared_ptr<string> mappedName{};
  shared_ptr<string> name{};
  shared_ptr<vector<string>> shardColumns{};
  shared_ptr<string> whereClause{};

  ListProjectModifyRecordsResponseBodyDataDatabasesSpecificTables() {}

  explicit ListProjectModifyRecordsResponseBodyDataDatabasesSpecificTables(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (adbTableSchema) {
      res["AdbTableSchema"] = adbTableSchema ? boost::any(adbTableSchema->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (columns) {
      vector<boost::any> temp1;
      for(auto item1:*columns){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Columns"] = boost::any(temp1);
    }
    if (filterColumns) {
      res["FilterColumns"] = boost::any(*filterColumns);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (mappedName) {
      res["MappedName"] = boost::any(*mappedName);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (shardColumns) {
      res["ShardColumns"] = boost::any(*shardColumns);
    }
    if (whereClause) {
      res["WhereClause"] = boost::any(*whereClause);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AdbTableSchema") != m.end() && !m["AdbTableSchema"].empty()) {
      if (typeid(map<string, boost::any>) == m["AdbTableSchema"].type()) {
        ListProjectModifyRecordsResponseBodyDataDatabasesSpecificTablesAdbTableSchema model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AdbTableSchema"]));
        adbTableSchema = make_shared<ListProjectModifyRecordsResponseBodyDataDatabasesSpecificTablesAdbTableSchema>(model1);
      }
    }
    if (m.find("Columns") != m.end() && !m["Columns"].empty()) {
      if (typeid(vector<boost::any>) == m["Columns"].type()) {
        vector<ListProjectModifyRecordsResponseBodyDataDatabasesSpecificTablesColumns> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Columns"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListProjectModifyRecordsResponseBodyDataDatabasesSpecificTablesColumns model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        columns = make_shared<vector<ListProjectModifyRecordsResponseBodyDataDatabasesSpecificTablesColumns>>(expect1);
      }
    }
    if (m.find("FilterColumns") != m.end() && !m["FilterColumns"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["FilterColumns"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["FilterColumns"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      filterColumns = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("MappedName") != m.end() && !m["MappedName"].empty()) {
      mappedName = make_shared<string>(boost::any_cast<string>(m["MappedName"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ShardColumns") != m.end() && !m["ShardColumns"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ShardColumns"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ShardColumns"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      shardColumns = make_shared<vector<string>>(toVec1);
    }
    if (m.find("WhereClause") != m.end() && !m["WhereClause"].empty()) {
      whereClause = make_shared<string>(boost::any_cast<string>(m["WhereClause"]));
    }
  }


  virtual ~ListProjectModifyRecordsResponseBodyDataDatabasesSpecificTables() = default;
};
class ListProjectModifyRecordsResponseBodyDataDatabasesSpecificViewsAdbTableSchema : public Darabonba::Model {
public:
  shared_ptr<vector<string>> distributedKeys{};
  shared_ptr<long> partitionLifeCycle{};
  shared_ptr<string> partitionStatement{};
  shared_ptr<vector<string>> primaryKeys{};

  ListProjectModifyRecordsResponseBodyDataDatabasesSpecificViewsAdbTableSchema() {}

  explicit ListProjectModifyRecordsResponseBodyDataDatabasesSpecificViewsAdbTableSchema(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (distributedKeys) {
      res["DistributedKeys"] = boost::any(*distributedKeys);
    }
    if (partitionLifeCycle) {
      res["PartitionLifeCycle"] = boost::any(*partitionLifeCycle);
    }
    if (partitionStatement) {
      res["PartitionStatement"] = boost::any(*partitionStatement);
    }
    if (primaryKeys) {
      res["PrimaryKeys"] = boost::any(*primaryKeys);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DistributedKeys") != m.end() && !m["DistributedKeys"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DistributedKeys"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DistributedKeys"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      distributedKeys = make_shared<vector<string>>(toVec1);
    }
    if (m.find("PartitionLifeCycle") != m.end() && !m["PartitionLifeCycle"].empty()) {
      partitionLifeCycle = make_shared<long>(boost::any_cast<long>(m["PartitionLifeCycle"]));
    }
    if (m.find("PartitionStatement") != m.end() && !m["PartitionStatement"].empty()) {
      partitionStatement = make_shared<string>(boost::any_cast<string>(m["PartitionStatement"]));
    }
    if (m.find("PrimaryKeys") != m.end() && !m["PrimaryKeys"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["PrimaryKeys"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["PrimaryKeys"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      primaryKeys = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ListProjectModifyRecordsResponseBodyDataDatabasesSpecificViewsAdbTableSchema() = default;
};
class ListProjectModifyRecordsResponseBodyDataDatabasesSpecificViewsColumns : public Darabonba::Model {
public:
  shared_ptr<string> columnComment{};
  shared_ptr<string> columnKey{};
  shared_ptr<string> columnName{};
  shared_ptr<string> columnType{};
  shared_ptr<long> dataLength{};
  shared_ptr<long> dataPrecision{};
  shared_ptr<long> dataScale{};
  shared_ptr<string> defaultValue{};
  shared_ptr<string> encoding{};
  shared_ptr<bool> isGenerateField{};
  shared_ptr<string> mappedName{};
  shared_ptr<bool> nullable{};
  shared_ptr<long> position{};
  shared_ptr<string> rawColumnType{};
  shared_ptr<string> recordFieldType{};
  shared_ptr<string> type{};

  ListProjectModifyRecordsResponseBodyDataDatabasesSpecificViewsColumns() {}

  explicit ListProjectModifyRecordsResponseBodyDataDatabasesSpecificViewsColumns(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (columnComment) {
      res["ColumnComment"] = boost::any(*columnComment);
    }
    if (columnKey) {
      res["ColumnKey"] = boost::any(*columnKey);
    }
    if (columnName) {
      res["ColumnName"] = boost::any(*columnName);
    }
    if (columnType) {
      res["ColumnType"] = boost::any(*columnType);
    }
    if (dataLength) {
      res["DataLength"] = boost::any(*dataLength);
    }
    if (dataPrecision) {
      res["DataPrecision"] = boost::any(*dataPrecision);
    }
    if (dataScale) {
      res["DataScale"] = boost::any(*dataScale);
    }
    if (defaultValue) {
      res["DefaultValue"] = boost::any(*defaultValue);
    }
    if (encoding) {
      res["Encoding"] = boost::any(*encoding);
    }
    if (isGenerateField) {
      res["IsGenerateField"] = boost::any(*isGenerateField);
    }
    if (mappedName) {
      res["MappedName"] = boost::any(*mappedName);
    }
    if (nullable) {
      res["Nullable"] = boost::any(*nullable);
    }
    if (position) {
      res["Position"] = boost::any(*position);
    }
    if (rawColumnType) {
      res["RawColumnType"] = boost::any(*rawColumnType);
    }
    if (recordFieldType) {
      res["RecordFieldType"] = boost::any(*recordFieldType);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ColumnComment") != m.end() && !m["ColumnComment"].empty()) {
      columnComment = make_shared<string>(boost::any_cast<string>(m["ColumnComment"]));
    }
    if (m.find("ColumnKey") != m.end() && !m["ColumnKey"].empty()) {
      columnKey = make_shared<string>(boost::any_cast<string>(m["ColumnKey"]));
    }
    if (m.find("ColumnName") != m.end() && !m["ColumnName"].empty()) {
      columnName = make_shared<string>(boost::any_cast<string>(m["ColumnName"]));
    }
    if (m.find("ColumnType") != m.end() && !m["ColumnType"].empty()) {
      columnType = make_shared<string>(boost::any_cast<string>(m["ColumnType"]));
    }
    if (m.find("DataLength") != m.end() && !m["DataLength"].empty()) {
      dataLength = make_shared<long>(boost::any_cast<long>(m["DataLength"]));
    }
    if (m.find("DataPrecision") != m.end() && !m["DataPrecision"].empty()) {
      dataPrecision = make_shared<long>(boost::any_cast<long>(m["DataPrecision"]));
    }
    if (m.find("DataScale") != m.end() && !m["DataScale"].empty()) {
      dataScale = make_shared<long>(boost::any_cast<long>(m["DataScale"]));
    }
    if (m.find("DefaultValue") != m.end() && !m["DefaultValue"].empty()) {
      defaultValue = make_shared<string>(boost::any_cast<string>(m["DefaultValue"]));
    }
    if (m.find("Encoding") != m.end() && !m["Encoding"].empty()) {
      encoding = make_shared<string>(boost::any_cast<string>(m["Encoding"]));
    }
    if (m.find("IsGenerateField") != m.end() && !m["IsGenerateField"].empty()) {
      isGenerateField = make_shared<bool>(boost::any_cast<bool>(m["IsGenerateField"]));
    }
    if (m.find("MappedName") != m.end() && !m["MappedName"].empty()) {
      mappedName = make_shared<string>(boost::any_cast<string>(m["MappedName"]));
    }
    if (m.find("Nullable") != m.end() && !m["Nullable"].empty()) {
      nullable = make_shared<bool>(boost::any_cast<bool>(m["Nullable"]));
    }
    if (m.find("Position") != m.end() && !m["Position"].empty()) {
      position = make_shared<long>(boost::any_cast<long>(m["Position"]));
    }
    if (m.find("RawColumnType") != m.end() && !m["RawColumnType"].empty()) {
      rawColumnType = make_shared<string>(boost::any_cast<string>(m["RawColumnType"]));
    }
    if (m.find("RecordFieldType") != m.end() && !m["RecordFieldType"].empty()) {
      recordFieldType = make_shared<string>(boost::any_cast<string>(m["RecordFieldType"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListProjectModifyRecordsResponseBodyDataDatabasesSpecificViewsColumns() = default;
};
class ListProjectModifyRecordsResponseBodyDataDatabasesSpecificViews : public Darabonba::Model {
public:
  shared_ptr<ListProjectModifyRecordsResponseBodyDataDatabasesSpecificViewsAdbTableSchema> adbTableSchema{};
  shared_ptr<vector<ListProjectModifyRecordsResponseBodyDataDatabasesSpecificViewsColumns>> columns{};
  shared_ptr<vector<string>> filterColumns{};
  shared_ptr<string> id{};
  shared_ptr<string> mappedName{};
  shared_ptr<string> name{};
  shared_ptr<vector<string>> shardColumns{};
  shared_ptr<string> whereClause{};

  ListProjectModifyRecordsResponseBodyDataDatabasesSpecificViews() {}

  explicit ListProjectModifyRecordsResponseBodyDataDatabasesSpecificViews(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (adbTableSchema) {
      res["AdbTableSchema"] = adbTableSchema ? boost::any(adbTableSchema->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (columns) {
      vector<boost::any> temp1;
      for(auto item1:*columns){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Columns"] = boost::any(temp1);
    }
    if (filterColumns) {
      res["FilterColumns"] = boost::any(*filterColumns);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (mappedName) {
      res["MappedName"] = boost::any(*mappedName);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (shardColumns) {
      res["ShardColumns"] = boost::any(*shardColumns);
    }
    if (whereClause) {
      res["WhereClause"] = boost::any(*whereClause);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AdbTableSchema") != m.end() && !m["AdbTableSchema"].empty()) {
      if (typeid(map<string, boost::any>) == m["AdbTableSchema"].type()) {
        ListProjectModifyRecordsResponseBodyDataDatabasesSpecificViewsAdbTableSchema model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AdbTableSchema"]));
        adbTableSchema = make_shared<ListProjectModifyRecordsResponseBodyDataDatabasesSpecificViewsAdbTableSchema>(model1);
      }
    }
    if (m.find("Columns") != m.end() && !m["Columns"].empty()) {
      if (typeid(vector<boost::any>) == m["Columns"].type()) {
        vector<ListProjectModifyRecordsResponseBodyDataDatabasesSpecificViewsColumns> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Columns"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListProjectModifyRecordsResponseBodyDataDatabasesSpecificViewsColumns model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        columns = make_shared<vector<ListProjectModifyRecordsResponseBodyDataDatabasesSpecificViewsColumns>>(expect1);
      }
    }
    if (m.find("FilterColumns") != m.end() && !m["FilterColumns"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["FilterColumns"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["FilterColumns"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      filterColumns = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("MappedName") != m.end() && !m["MappedName"].empty()) {
      mappedName = make_shared<string>(boost::any_cast<string>(m["MappedName"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ShardColumns") != m.end() && !m["ShardColumns"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ShardColumns"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ShardColumns"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      shardColumns = make_shared<vector<string>>(toVec1);
    }
    if (m.find("WhereClause") != m.end() && !m["WhereClause"].empty()) {
      whereClause = make_shared<string>(boost::any_cast<string>(m["WhereClause"]));
    }
  }


  virtual ~ListProjectModifyRecordsResponseBodyDataDatabasesSpecificViews() = default;
};
class ListProjectModifyRecordsResponseBodyDataDatabasesTablesAdbTableSchema : public Darabonba::Model {
public:
  shared_ptr<vector<string>> distributedKeys{};
  shared_ptr<long> partitionLifeCycle{};
  shared_ptr<string> partitionStatement{};
  shared_ptr<vector<string>> primaryKeys{};

  ListProjectModifyRecordsResponseBodyDataDatabasesTablesAdbTableSchema() {}

  explicit ListProjectModifyRecordsResponseBodyDataDatabasesTablesAdbTableSchema(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (distributedKeys) {
      res["DistributedKeys"] = boost::any(*distributedKeys);
    }
    if (partitionLifeCycle) {
      res["PartitionLifeCycle"] = boost::any(*partitionLifeCycle);
    }
    if (partitionStatement) {
      res["PartitionStatement"] = boost::any(*partitionStatement);
    }
    if (primaryKeys) {
      res["PrimaryKeys"] = boost::any(*primaryKeys);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DistributedKeys") != m.end() && !m["DistributedKeys"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DistributedKeys"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DistributedKeys"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      distributedKeys = make_shared<vector<string>>(toVec1);
    }
    if (m.find("PartitionLifeCycle") != m.end() && !m["PartitionLifeCycle"].empty()) {
      partitionLifeCycle = make_shared<long>(boost::any_cast<long>(m["PartitionLifeCycle"]));
    }
    if (m.find("PartitionStatement") != m.end() && !m["PartitionStatement"].empty()) {
      partitionStatement = make_shared<string>(boost::any_cast<string>(m["PartitionStatement"]));
    }
    if (m.find("PrimaryKeys") != m.end() && !m["PrimaryKeys"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["PrimaryKeys"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["PrimaryKeys"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      primaryKeys = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ListProjectModifyRecordsResponseBodyDataDatabasesTablesAdbTableSchema() = default;
};
class ListProjectModifyRecordsResponseBodyDataDatabasesTablesColumns : public Darabonba::Model {
public:
  shared_ptr<string> columnComment{};
  shared_ptr<string> columnKey{};
  shared_ptr<string> columnName{};
  shared_ptr<string> columnType{};
  shared_ptr<long> dataLength{};
  shared_ptr<long> dataPrecision{};
  shared_ptr<long> dataScale{};
  shared_ptr<string> defaultValue{};
  shared_ptr<string> encoding{};
  shared_ptr<bool> isGenerateField{};
  shared_ptr<string> mappedName{};
  shared_ptr<bool> nullable{};
  shared_ptr<long> position{};
  shared_ptr<string> rawColumnType{};
  shared_ptr<string> recordFieldType{};
  shared_ptr<string> type{};

  ListProjectModifyRecordsResponseBodyDataDatabasesTablesColumns() {}

  explicit ListProjectModifyRecordsResponseBodyDataDatabasesTablesColumns(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (columnComment) {
      res["ColumnComment"] = boost::any(*columnComment);
    }
    if (columnKey) {
      res["ColumnKey"] = boost::any(*columnKey);
    }
    if (columnName) {
      res["ColumnName"] = boost::any(*columnName);
    }
    if (columnType) {
      res["ColumnType"] = boost::any(*columnType);
    }
    if (dataLength) {
      res["DataLength"] = boost::any(*dataLength);
    }
    if (dataPrecision) {
      res["DataPrecision"] = boost::any(*dataPrecision);
    }
    if (dataScale) {
      res["DataScale"] = boost::any(*dataScale);
    }
    if (defaultValue) {
      res["DefaultValue"] = boost::any(*defaultValue);
    }
    if (encoding) {
      res["Encoding"] = boost::any(*encoding);
    }
    if (isGenerateField) {
      res["IsGenerateField"] = boost::any(*isGenerateField);
    }
    if (mappedName) {
      res["MappedName"] = boost::any(*mappedName);
    }
    if (nullable) {
      res["Nullable"] = boost::any(*nullable);
    }
    if (position) {
      res["Position"] = boost::any(*position);
    }
    if (rawColumnType) {
      res["RawColumnType"] = boost::any(*rawColumnType);
    }
    if (recordFieldType) {
      res["RecordFieldType"] = boost::any(*recordFieldType);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ColumnComment") != m.end() && !m["ColumnComment"].empty()) {
      columnComment = make_shared<string>(boost::any_cast<string>(m["ColumnComment"]));
    }
    if (m.find("ColumnKey") != m.end() && !m["ColumnKey"].empty()) {
      columnKey = make_shared<string>(boost::any_cast<string>(m["ColumnKey"]));
    }
    if (m.find("ColumnName") != m.end() && !m["ColumnName"].empty()) {
      columnName = make_shared<string>(boost::any_cast<string>(m["ColumnName"]));
    }
    if (m.find("ColumnType") != m.end() && !m["ColumnType"].empty()) {
      columnType = make_shared<string>(boost::any_cast<string>(m["ColumnType"]));
    }
    if (m.find("DataLength") != m.end() && !m["DataLength"].empty()) {
      dataLength = make_shared<long>(boost::any_cast<long>(m["DataLength"]));
    }
    if (m.find("DataPrecision") != m.end() && !m["DataPrecision"].empty()) {
      dataPrecision = make_shared<long>(boost::any_cast<long>(m["DataPrecision"]));
    }
    if (m.find("DataScale") != m.end() && !m["DataScale"].empty()) {
      dataScale = make_shared<long>(boost::any_cast<long>(m["DataScale"]));
    }
    if (m.find("DefaultValue") != m.end() && !m["DefaultValue"].empty()) {
      defaultValue = make_shared<string>(boost::any_cast<string>(m["DefaultValue"]));
    }
    if (m.find("Encoding") != m.end() && !m["Encoding"].empty()) {
      encoding = make_shared<string>(boost::any_cast<string>(m["Encoding"]));
    }
    if (m.find("IsGenerateField") != m.end() && !m["IsGenerateField"].empty()) {
      isGenerateField = make_shared<bool>(boost::any_cast<bool>(m["IsGenerateField"]));
    }
    if (m.find("MappedName") != m.end() && !m["MappedName"].empty()) {
      mappedName = make_shared<string>(boost::any_cast<string>(m["MappedName"]));
    }
    if (m.find("Nullable") != m.end() && !m["Nullable"].empty()) {
      nullable = make_shared<bool>(boost::any_cast<bool>(m["Nullable"]));
    }
    if (m.find("Position") != m.end() && !m["Position"].empty()) {
      position = make_shared<long>(boost::any_cast<long>(m["Position"]));
    }
    if (m.find("RawColumnType") != m.end() && !m["RawColumnType"].empty()) {
      rawColumnType = make_shared<string>(boost::any_cast<string>(m["RawColumnType"]));
    }
    if (m.find("RecordFieldType") != m.end() && !m["RecordFieldType"].empty()) {
      recordFieldType = make_shared<string>(boost::any_cast<string>(m["RecordFieldType"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListProjectModifyRecordsResponseBodyDataDatabasesTablesColumns() = default;
};
class ListProjectModifyRecordsResponseBodyDataDatabasesTables : public Darabonba::Model {
public:
  shared_ptr<ListProjectModifyRecordsResponseBodyDataDatabasesTablesAdbTableSchema> adbTableSchema{};
  shared_ptr<vector<ListProjectModifyRecordsResponseBodyDataDatabasesTablesColumns>> columns{};
  shared_ptr<vector<string>> filterColumns{};
  shared_ptr<string> id{};
  shared_ptr<string> mappedName{};
  shared_ptr<string> name{};
  shared_ptr<vector<string>> shardColumns{};
  shared_ptr<string> whereClause{};

  ListProjectModifyRecordsResponseBodyDataDatabasesTables() {}

  explicit ListProjectModifyRecordsResponseBodyDataDatabasesTables(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (adbTableSchema) {
      res["AdbTableSchema"] = adbTableSchema ? boost::any(adbTableSchema->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (columns) {
      vector<boost::any> temp1;
      for(auto item1:*columns){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Columns"] = boost::any(temp1);
    }
    if (filterColumns) {
      res["FilterColumns"] = boost::any(*filterColumns);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (mappedName) {
      res["MappedName"] = boost::any(*mappedName);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (shardColumns) {
      res["ShardColumns"] = boost::any(*shardColumns);
    }
    if (whereClause) {
      res["WhereClause"] = boost::any(*whereClause);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AdbTableSchema") != m.end() && !m["AdbTableSchema"].empty()) {
      if (typeid(map<string, boost::any>) == m["AdbTableSchema"].type()) {
        ListProjectModifyRecordsResponseBodyDataDatabasesTablesAdbTableSchema model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AdbTableSchema"]));
        adbTableSchema = make_shared<ListProjectModifyRecordsResponseBodyDataDatabasesTablesAdbTableSchema>(model1);
      }
    }
    if (m.find("Columns") != m.end() && !m["Columns"].empty()) {
      if (typeid(vector<boost::any>) == m["Columns"].type()) {
        vector<ListProjectModifyRecordsResponseBodyDataDatabasesTablesColumns> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Columns"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListProjectModifyRecordsResponseBodyDataDatabasesTablesColumns model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        columns = make_shared<vector<ListProjectModifyRecordsResponseBodyDataDatabasesTablesColumns>>(expect1);
      }
    }
    if (m.find("FilterColumns") != m.end() && !m["FilterColumns"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["FilterColumns"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["FilterColumns"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      filterColumns = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("MappedName") != m.end() && !m["MappedName"].empty()) {
      mappedName = make_shared<string>(boost::any_cast<string>(m["MappedName"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ShardColumns") != m.end() && !m["ShardColumns"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ShardColumns"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ShardColumns"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      shardColumns = make_shared<vector<string>>(toVec1);
    }
    if (m.find("WhereClause") != m.end() && !m["WhereClause"].empty()) {
      whereClause = make_shared<string>(boost::any_cast<string>(m["WhereClause"]));
    }
  }


  virtual ~ListProjectModifyRecordsResponseBodyDataDatabasesTables() = default;
};
class ListProjectModifyRecordsResponseBodyDataDatabasesViewsAdbTableSchema : public Darabonba::Model {
public:
  shared_ptr<vector<string>> distributedKeys{};
  shared_ptr<long> partitionLifeCycle{};
  shared_ptr<string> partitionStatement{};
  shared_ptr<vector<string>> primaryKeys{};

  ListProjectModifyRecordsResponseBodyDataDatabasesViewsAdbTableSchema() {}

  explicit ListProjectModifyRecordsResponseBodyDataDatabasesViewsAdbTableSchema(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (distributedKeys) {
      res["DistributedKeys"] = boost::any(*distributedKeys);
    }
    if (partitionLifeCycle) {
      res["PartitionLifeCycle"] = boost::any(*partitionLifeCycle);
    }
    if (partitionStatement) {
      res["PartitionStatement"] = boost::any(*partitionStatement);
    }
    if (primaryKeys) {
      res["PrimaryKeys"] = boost::any(*primaryKeys);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DistributedKeys") != m.end() && !m["DistributedKeys"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DistributedKeys"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DistributedKeys"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      distributedKeys = make_shared<vector<string>>(toVec1);
    }
    if (m.find("PartitionLifeCycle") != m.end() && !m["PartitionLifeCycle"].empty()) {
      partitionLifeCycle = make_shared<long>(boost::any_cast<long>(m["PartitionLifeCycle"]));
    }
    if (m.find("PartitionStatement") != m.end() && !m["PartitionStatement"].empty()) {
      partitionStatement = make_shared<string>(boost::any_cast<string>(m["PartitionStatement"]));
    }
    if (m.find("PrimaryKeys") != m.end() && !m["PrimaryKeys"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["PrimaryKeys"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["PrimaryKeys"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      primaryKeys = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ListProjectModifyRecordsResponseBodyDataDatabasesViewsAdbTableSchema() = default;
};
class ListProjectModifyRecordsResponseBodyDataDatabasesViewsColumns : public Darabonba::Model {
public:
  shared_ptr<string> columnComment{};
  shared_ptr<string> columnKey{};
  shared_ptr<string> columnName{};
  shared_ptr<string> columnType{};
  shared_ptr<long> dataLength{};
  shared_ptr<long> dataPrecision{};
  shared_ptr<long> dataScale{};
  shared_ptr<string> defaultValue{};
  shared_ptr<string> encoding{};
  shared_ptr<bool> isGenerateField{};
  shared_ptr<string> mappedName{};
  shared_ptr<bool> nullable{};
  shared_ptr<long> position{};
  shared_ptr<string> rawColumnType{};
  shared_ptr<string> recordFieldType{};
  shared_ptr<string> type{};

  ListProjectModifyRecordsResponseBodyDataDatabasesViewsColumns() {}

  explicit ListProjectModifyRecordsResponseBodyDataDatabasesViewsColumns(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (columnComment) {
      res["ColumnComment"] = boost::any(*columnComment);
    }
    if (columnKey) {
      res["ColumnKey"] = boost::any(*columnKey);
    }
    if (columnName) {
      res["ColumnName"] = boost::any(*columnName);
    }
    if (columnType) {
      res["ColumnType"] = boost::any(*columnType);
    }
    if (dataLength) {
      res["DataLength"] = boost::any(*dataLength);
    }
    if (dataPrecision) {
      res["DataPrecision"] = boost::any(*dataPrecision);
    }
    if (dataScale) {
      res["DataScale"] = boost::any(*dataScale);
    }
    if (defaultValue) {
      res["DefaultValue"] = boost::any(*defaultValue);
    }
    if (encoding) {
      res["Encoding"] = boost::any(*encoding);
    }
    if (isGenerateField) {
      res["IsGenerateField"] = boost::any(*isGenerateField);
    }
    if (mappedName) {
      res["MappedName"] = boost::any(*mappedName);
    }
    if (nullable) {
      res["Nullable"] = boost::any(*nullable);
    }
    if (position) {
      res["Position"] = boost::any(*position);
    }
    if (rawColumnType) {
      res["RawColumnType"] = boost::any(*rawColumnType);
    }
    if (recordFieldType) {
      res["RecordFieldType"] = boost::any(*recordFieldType);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ColumnComment") != m.end() && !m["ColumnComment"].empty()) {
      columnComment = make_shared<string>(boost::any_cast<string>(m["ColumnComment"]));
    }
    if (m.find("ColumnKey") != m.end() && !m["ColumnKey"].empty()) {
      columnKey = make_shared<string>(boost::any_cast<string>(m["ColumnKey"]));
    }
    if (m.find("ColumnName") != m.end() && !m["ColumnName"].empty()) {
      columnName = make_shared<string>(boost::any_cast<string>(m["ColumnName"]));
    }
    if (m.find("ColumnType") != m.end() && !m["ColumnType"].empty()) {
      columnType = make_shared<string>(boost::any_cast<string>(m["ColumnType"]));
    }
    if (m.find("DataLength") != m.end() && !m["DataLength"].empty()) {
      dataLength = make_shared<long>(boost::any_cast<long>(m["DataLength"]));
    }
    if (m.find("DataPrecision") != m.end() && !m["DataPrecision"].empty()) {
      dataPrecision = make_shared<long>(boost::any_cast<long>(m["DataPrecision"]));
    }
    if (m.find("DataScale") != m.end() && !m["DataScale"].empty()) {
      dataScale = make_shared<long>(boost::any_cast<long>(m["DataScale"]));
    }
    if (m.find("DefaultValue") != m.end() && !m["DefaultValue"].empty()) {
      defaultValue = make_shared<string>(boost::any_cast<string>(m["DefaultValue"]));
    }
    if (m.find("Encoding") != m.end() && !m["Encoding"].empty()) {
      encoding = make_shared<string>(boost::any_cast<string>(m["Encoding"]));
    }
    if (m.find("IsGenerateField") != m.end() && !m["IsGenerateField"].empty()) {
      isGenerateField = make_shared<bool>(boost::any_cast<bool>(m["IsGenerateField"]));
    }
    if (m.find("MappedName") != m.end() && !m["MappedName"].empty()) {
      mappedName = make_shared<string>(boost::any_cast<string>(m["MappedName"]));
    }
    if (m.find("Nullable") != m.end() && !m["Nullable"].empty()) {
      nullable = make_shared<bool>(boost::any_cast<bool>(m["Nullable"]));
    }
    if (m.find("Position") != m.end() && !m["Position"].empty()) {
      position = make_shared<long>(boost::any_cast<long>(m["Position"]));
    }
    if (m.find("RawColumnType") != m.end() && !m["RawColumnType"].empty()) {
      rawColumnType = make_shared<string>(boost::any_cast<string>(m["RawColumnType"]));
    }
    if (m.find("RecordFieldType") != m.end() && !m["RecordFieldType"].empty()) {
      recordFieldType = make_shared<string>(boost::any_cast<string>(m["RecordFieldType"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListProjectModifyRecordsResponseBodyDataDatabasesViewsColumns() = default;
};
class ListProjectModifyRecordsResponseBodyDataDatabasesViews : public Darabonba::Model {
public:
  shared_ptr<ListProjectModifyRecordsResponseBodyDataDatabasesViewsAdbTableSchema> adbTableSchema{};
  shared_ptr<vector<ListProjectModifyRecordsResponseBodyDataDatabasesViewsColumns>> columns{};
  shared_ptr<vector<string>> filterColumns{};
  shared_ptr<string> id{};
  shared_ptr<string> mappedName{};
  shared_ptr<string> name{};
  shared_ptr<vector<string>> shardColumns{};
  shared_ptr<string> whereClause{};

  ListProjectModifyRecordsResponseBodyDataDatabasesViews() {}

  explicit ListProjectModifyRecordsResponseBodyDataDatabasesViews(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (adbTableSchema) {
      res["AdbTableSchema"] = adbTableSchema ? boost::any(adbTableSchema->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (columns) {
      vector<boost::any> temp1;
      for(auto item1:*columns){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Columns"] = boost::any(temp1);
    }
    if (filterColumns) {
      res["FilterColumns"] = boost::any(*filterColumns);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (mappedName) {
      res["MappedName"] = boost::any(*mappedName);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (shardColumns) {
      res["ShardColumns"] = boost::any(*shardColumns);
    }
    if (whereClause) {
      res["WhereClause"] = boost::any(*whereClause);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AdbTableSchema") != m.end() && !m["AdbTableSchema"].empty()) {
      if (typeid(map<string, boost::any>) == m["AdbTableSchema"].type()) {
        ListProjectModifyRecordsResponseBodyDataDatabasesViewsAdbTableSchema model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AdbTableSchema"]));
        adbTableSchema = make_shared<ListProjectModifyRecordsResponseBodyDataDatabasesViewsAdbTableSchema>(model1);
      }
    }
    if (m.find("Columns") != m.end() && !m["Columns"].empty()) {
      if (typeid(vector<boost::any>) == m["Columns"].type()) {
        vector<ListProjectModifyRecordsResponseBodyDataDatabasesViewsColumns> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Columns"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListProjectModifyRecordsResponseBodyDataDatabasesViewsColumns model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        columns = make_shared<vector<ListProjectModifyRecordsResponseBodyDataDatabasesViewsColumns>>(expect1);
      }
    }
    if (m.find("FilterColumns") != m.end() && !m["FilterColumns"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["FilterColumns"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["FilterColumns"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      filterColumns = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("MappedName") != m.end() && !m["MappedName"].empty()) {
      mappedName = make_shared<string>(boost::any_cast<string>(m["MappedName"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ShardColumns") != m.end() && !m["ShardColumns"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ShardColumns"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ShardColumns"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      shardColumns = make_shared<vector<string>>(toVec1);
    }
    if (m.find("WhereClause") != m.end() && !m["WhereClause"].empty()) {
      whereClause = make_shared<string>(boost::any_cast<string>(m["WhereClause"]));
    }
  }


  virtual ~ListProjectModifyRecordsResponseBodyDataDatabasesViews() = default;
};
class ListProjectModifyRecordsResponseBodyDataDatabases : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<string> mappedName{};
  shared_ptr<string> name{};
  shared_ptr<vector<ListProjectModifyRecordsResponseBodyDataDatabasesSpecificTables>> specificTables{};
  shared_ptr<vector<ListProjectModifyRecordsResponseBodyDataDatabasesSpecificViews>> specificViews{};
  shared_ptr<vector<ListProjectModifyRecordsResponseBodyDataDatabasesTables>> tables{};
  shared_ptr<vector<ListProjectModifyRecordsResponseBodyDataDatabasesViews>> views{};

  ListProjectModifyRecordsResponseBodyDataDatabases() {}

  explicit ListProjectModifyRecordsResponseBodyDataDatabases(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (mappedName) {
      res["MappedName"] = boost::any(*mappedName);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (specificTables) {
      vector<boost::any> temp1;
      for(auto item1:*specificTables){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SpecificTables"] = boost::any(temp1);
    }
    if (specificViews) {
      vector<boost::any> temp1;
      for(auto item1:*specificViews){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SpecificViews"] = boost::any(temp1);
    }
    if (tables) {
      vector<boost::any> temp1;
      for(auto item1:*tables){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tables"] = boost::any(temp1);
    }
    if (views) {
      vector<boost::any> temp1;
      for(auto item1:*views){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Views"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("MappedName") != m.end() && !m["MappedName"].empty()) {
      mappedName = make_shared<string>(boost::any_cast<string>(m["MappedName"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("SpecificTables") != m.end() && !m["SpecificTables"].empty()) {
      if (typeid(vector<boost::any>) == m["SpecificTables"].type()) {
        vector<ListProjectModifyRecordsResponseBodyDataDatabasesSpecificTables> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SpecificTables"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListProjectModifyRecordsResponseBodyDataDatabasesSpecificTables model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        specificTables = make_shared<vector<ListProjectModifyRecordsResponseBodyDataDatabasesSpecificTables>>(expect1);
      }
    }
    if (m.find("SpecificViews") != m.end() && !m["SpecificViews"].empty()) {
      if (typeid(vector<boost::any>) == m["SpecificViews"].type()) {
        vector<ListProjectModifyRecordsResponseBodyDataDatabasesSpecificViews> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SpecificViews"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListProjectModifyRecordsResponseBodyDataDatabasesSpecificViews model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        specificViews = make_shared<vector<ListProjectModifyRecordsResponseBodyDataDatabasesSpecificViews>>(expect1);
      }
    }
    if (m.find("Tables") != m.end() && !m["Tables"].empty()) {
      if (typeid(vector<boost::any>) == m["Tables"].type()) {
        vector<ListProjectModifyRecordsResponseBodyDataDatabasesTables> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tables"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListProjectModifyRecordsResponseBodyDataDatabasesTables model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tables = make_shared<vector<ListProjectModifyRecordsResponseBodyDataDatabasesTables>>(expect1);
      }
    }
    if (m.find("Views") != m.end() && !m["Views"].empty()) {
      if (typeid(vector<boost::any>) == m["Views"].type()) {
        vector<ListProjectModifyRecordsResponseBodyDataDatabasesViews> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Views"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListProjectModifyRecordsResponseBodyDataDatabasesViews model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        views = make_shared<vector<ListProjectModifyRecordsResponseBodyDataDatabasesViews>>(expect1);
      }
    }
  }


  virtual ~ListProjectModifyRecordsResponseBodyDataDatabases() = default;
};
class ListProjectModifyRecordsResponseBodyDataErrorDetail : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<map<string, boost::any>> extraContext{};
  shared_ptr<string> level{};
  shared_ptr<string> message{};
  shared_ptr<map<string, string>> messageMcmsContext{};
  shared_ptr<string> messageMcmsKey{};
  shared_ptr<string> proposal{};
  shared_ptr<map<string, string>> proposalMcmsContext{};
  shared_ptr<string> proposalMcmsKey{};
  shared_ptr<string> reason{};
  shared_ptr<map<string, string>> reasonMcmsContext{};
  shared_ptr<string> reasonMcmsKey{};
  shared_ptr<boost::any> upstreamErrorDetail{};

  ListProjectModifyRecordsResponseBodyDataErrorDetail() {}

  explicit ListProjectModifyRecordsResponseBodyDataErrorDetail(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (extraContext) {
      res["ExtraContext"] = boost::any(*extraContext);
    }
    if (level) {
      res["Level"] = boost::any(*level);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (messageMcmsContext) {
      res["MessageMcmsContext"] = boost::any(*messageMcmsContext);
    }
    if (messageMcmsKey) {
      res["MessageMcmsKey"] = boost::any(*messageMcmsKey);
    }
    if (proposal) {
      res["Proposal"] = boost::any(*proposal);
    }
    if (proposalMcmsContext) {
      res["ProposalMcmsContext"] = boost::any(*proposalMcmsContext);
    }
    if (proposalMcmsKey) {
      res["ProposalMcmsKey"] = boost::any(*proposalMcmsKey);
    }
    if (reason) {
      res["Reason"] = boost::any(*reason);
    }
    if (reasonMcmsContext) {
      res["ReasonMcmsContext"] = boost::any(*reasonMcmsContext);
    }
    if (reasonMcmsKey) {
      res["ReasonMcmsKey"] = boost::any(*reasonMcmsKey);
    }
    if (upstreamErrorDetail) {
      res["UpstreamErrorDetail"] = boost::any(*upstreamErrorDetail);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ExtraContext") != m.end() && !m["ExtraContext"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["ExtraContext"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      extraContext = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<string>(boost::any_cast<string>(m["Level"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("MessageMcmsContext") != m.end() && !m["MessageMcmsContext"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["MessageMcmsContext"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      messageMcmsContext = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("MessageMcmsKey") != m.end() && !m["MessageMcmsKey"].empty()) {
      messageMcmsKey = make_shared<string>(boost::any_cast<string>(m["MessageMcmsKey"]));
    }
    if (m.find("Proposal") != m.end() && !m["Proposal"].empty()) {
      proposal = make_shared<string>(boost::any_cast<string>(m["Proposal"]));
    }
    if (m.find("ProposalMcmsContext") != m.end() && !m["ProposalMcmsContext"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["ProposalMcmsContext"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      proposalMcmsContext = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("ProposalMcmsKey") != m.end() && !m["ProposalMcmsKey"].empty()) {
      proposalMcmsKey = make_shared<string>(boost::any_cast<string>(m["ProposalMcmsKey"]));
    }
    if (m.find("Reason") != m.end() && !m["Reason"].empty()) {
      reason = make_shared<string>(boost::any_cast<string>(m["Reason"]));
    }
    if (m.find("ReasonMcmsContext") != m.end() && !m["ReasonMcmsContext"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["ReasonMcmsContext"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      reasonMcmsContext = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("ReasonMcmsKey") != m.end() && !m["ReasonMcmsKey"].empty()) {
      reasonMcmsKey = make_shared<string>(boost::any_cast<string>(m["ReasonMcmsKey"]));
    }
    if (m.find("UpstreamErrorDetail") != m.end() && !m["UpstreamErrorDetail"].empty()) {
      upstreamErrorDetail = make_shared<boost::any>(boost::any_cast<boost::any>(m["UpstreamErrorDetail"]));
    }
  }


  virtual ~ListProjectModifyRecordsResponseBodyDataErrorDetail() = default;
};
class ListProjectModifyRecordsResponseBodyDataMigrationObjectsInfoTables : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> schema{};

  ListProjectModifyRecordsResponseBodyDataMigrationObjectsInfoTables() {}

  explicit ListProjectModifyRecordsResponseBodyDataMigrationObjectsInfoTables(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (schema) {
      res["Schema"] = boost::any(*schema);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Schema") != m.end() && !m["Schema"].empty()) {
      schema = make_shared<string>(boost::any_cast<string>(m["Schema"]));
    }
  }


  virtual ~ListProjectModifyRecordsResponseBodyDataMigrationObjectsInfoTables() = default;
};
class ListProjectModifyRecordsResponseBodyDataMigrationObjectsInfoTablesBlack : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> schema{};

  ListProjectModifyRecordsResponseBodyDataMigrationObjectsInfoTablesBlack() {}

  explicit ListProjectModifyRecordsResponseBodyDataMigrationObjectsInfoTablesBlack(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (schema) {
      res["Schema"] = boost::any(*schema);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Schema") != m.end() && !m["Schema"].empty()) {
      schema = make_shared<string>(boost::any_cast<string>(m["Schema"]));
    }
  }


  virtual ~ListProjectModifyRecordsResponseBodyDataMigrationObjectsInfoTablesBlack() = default;
};
class ListProjectModifyRecordsResponseBodyDataMigrationObjectsInfoViews : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> schema{};

  ListProjectModifyRecordsResponseBodyDataMigrationObjectsInfoViews() {}

  explicit ListProjectModifyRecordsResponseBodyDataMigrationObjectsInfoViews(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (schema) {
      res["Schema"] = boost::any(*schema);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Schema") != m.end() && !m["Schema"].empty()) {
      schema = make_shared<string>(boost::any_cast<string>(m["Schema"]));
    }
  }


  virtual ~ListProjectModifyRecordsResponseBodyDataMigrationObjectsInfoViews() = default;
};
class ListProjectModifyRecordsResponseBodyDataMigrationObjectsInfoViewsBlack : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> schema{};

  ListProjectModifyRecordsResponseBodyDataMigrationObjectsInfoViewsBlack() {}

  explicit ListProjectModifyRecordsResponseBodyDataMigrationObjectsInfoViewsBlack(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (schema) {
      res["Schema"] = boost::any(*schema);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Schema") != m.end() && !m["Schema"].empty()) {
      schema = make_shared<string>(boost::any_cast<string>(m["Schema"]));
    }
  }


  virtual ~ListProjectModifyRecordsResponseBodyDataMigrationObjectsInfoViewsBlack() = default;
};
class ListProjectModifyRecordsResponseBodyDataMigrationObjectsInfo : public Darabonba::Model {
public:
  shared_ptr<vector<ListProjectModifyRecordsResponseBodyDataMigrationObjectsInfoTables>> tables{};
  shared_ptr<vector<ListProjectModifyRecordsResponseBodyDataMigrationObjectsInfoTablesBlack>> tablesBlack{};
  shared_ptr<vector<ListProjectModifyRecordsResponseBodyDataMigrationObjectsInfoViews>> views{};
  shared_ptr<vector<ListProjectModifyRecordsResponseBodyDataMigrationObjectsInfoViewsBlack>> viewsBlack{};
  shared_ptr<bool> wildcardMode{};

  ListProjectModifyRecordsResponseBodyDataMigrationObjectsInfo() {}

  explicit ListProjectModifyRecordsResponseBodyDataMigrationObjectsInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tables) {
      vector<boost::any> temp1;
      for(auto item1:*tables){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tables"] = boost::any(temp1);
    }
    if (tablesBlack) {
      vector<boost::any> temp1;
      for(auto item1:*tablesBlack){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TablesBlack"] = boost::any(temp1);
    }
    if (views) {
      vector<boost::any> temp1;
      for(auto item1:*views){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Views"] = boost::any(temp1);
    }
    if (viewsBlack) {
      vector<boost::any> temp1;
      for(auto item1:*viewsBlack){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ViewsBlack"] = boost::any(temp1);
    }
    if (wildcardMode) {
      res["WildcardMode"] = boost::any(*wildcardMode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Tables") != m.end() && !m["Tables"].empty()) {
      if (typeid(vector<boost::any>) == m["Tables"].type()) {
        vector<ListProjectModifyRecordsResponseBodyDataMigrationObjectsInfoTables> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tables"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListProjectModifyRecordsResponseBodyDataMigrationObjectsInfoTables model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tables = make_shared<vector<ListProjectModifyRecordsResponseBodyDataMigrationObjectsInfoTables>>(expect1);
      }
    }
    if (m.find("TablesBlack") != m.end() && !m["TablesBlack"].empty()) {
      if (typeid(vector<boost::any>) == m["TablesBlack"].type()) {
        vector<ListProjectModifyRecordsResponseBodyDataMigrationObjectsInfoTablesBlack> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TablesBlack"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListProjectModifyRecordsResponseBodyDataMigrationObjectsInfoTablesBlack model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tablesBlack = make_shared<vector<ListProjectModifyRecordsResponseBodyDataMigrationObjectsInfoTablesBlack>>(expect1);
      }
    }
    if (m.find("Views") != m.end() && !m["Views"].empty()) {
      if (typeid(vector<boost::any>) == m["Views"].type()) {
        vector<ListProjectModifyRecordsResponseBodyDataMigrationObjectsInfoViews> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Views"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListProjectModifyRecordsResponseBodyDataMigrationObjectsInfoViews model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        views = make_shared<vector<ListProjectModifyRecordsResponseBodyDataMigrationObjectsInfoViews>>(expect1);
      }
    }
    if (m.find("ViewsBlack") != m.end() && !m["ViewsBlack"].empty()) {
      if (typeid(vector<boost::any>) == m["ViewsBlack"].type()) {
        vector<ListProjectModifyRecordsResponseBodyDataMigrationObjectsInfoViewsBlack> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ViewsBlack"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListProjectModifyRecordsResponseBodyDataMigrationObjectsInfoViewsBlack model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        viewsBlack = make_shared<vector<ListProjectModifyRecordsResponseBodyDataMigrationObjectsInfoViewsBlack>>(expect1);
      }
    }
    if (m.find("WildcardMode") != m.end() && !m["WildcardMode"].empty()) {
      wildcardMode = make_shared<bool>(boost::any_cast<bool>(m["WildcardMode"]));
    }
  }


  virtual ~ListProjectModifyRecordsResponseBodyDataMigrationObjectsInfo() = default;
};
class ListProjectModifyRecordsResponseBodyDataOmsProjectMappingInfoColumnMappings : public Darabonba::Model {
public:
  shared_ptr<string> destName{};
  shared_ptr<string> sourceName{};
  shared_ptr<string> sourceSchema{};
  shared_ptr<string> sourceTable{};

  ListProjectModifyRecordsResponseBodyDataOmsProjectMappingInfoColumnMappings() {}

  explicit ListProjectModifyRecordsResponseBodyDataOmsProjectMappingInfoColumnMappings(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (destName) {
      res["DestName"] = boost::any(*destName);
    }
    if (sourceName) {
      res["SourceName"] = boost::any(*sourceName);
    }
    if (sourceSchema) {
      res["SourceSchema"] = boost::any(*sourceSchema);
    }
    if (sourceTable) {
      res["SourceTable"] = boost::any(*sourceTable);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DestName") != m.end() && !m["DestName"].empty()) {
      destName = make_shared<string>(boost::any_cast<string>(m["DestName"]));
    }
    if (m.find("SourceName") != m.end() && !m["SourceName"].empty()) {
      sourceName = make_shared<string>(boost::any_cast<string>(m["SourceName"]));
    }
    if (m.find("SourceSchema") != m.end() && !m["SourceSchema"].empty()) {
      sourceSchema = make_shared<string>(boost::any_cast<string>(m["SourceSchema"]));
    }
    if (m.find("SourceTable") != m.end() && !m["SourceTable"].empty()) {
      sourceTable = make_shared<string>(boost::any_cast<string>(m["SourceTable"]));
    }
  }


  virtual ~ListProjectModifyRecordsResponseBodyDataOmsProjectMappingInfoColumnMappings() = default;
};
class ListProjectModifyRecordsResponseBodyDataOmsProjectMappingInfoSchemaMappings : public Darabonba::Model {
public:
  shared_ptr<string> destName{};
  shared_ptr<string> sourceName{};

  ListProjectModifyRecordsResponseBodyDataOmsProjectMappingInfoSchemaMappings() {}

  explicit ListProjectModifyRecordsResponseBodyDataOmsProjectMappingInfoSchemaMappings(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (destName) {
      res["DestName"] = boost::any(*destName);
    }
    if (sourceName) {
      res["SourceName"] = boost::any(*sourceName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DestName") != m.end() && !m["DestName"].empty()) {
      destName = make_shared<string>(boost::any_cast<string>(m["DestName"]));
    }
    if (m.find("SourceName") != m.end() && !m["SourceName"].empty()) {
      sourceName = make_shared<string>(boost::any_cast<string>(m["SourceName"]));
    }
  }


  virtual ~ListProjectModifyRecordsResponseBodyDataOmsProjectMappingInfoSchemaMappings() = default;
};
class ListProjectModifyRecordsResponseBodyDataOmsProjectMappingInfoTableMappings : public Darabonba::Model {
public:
  shared_ptr<string> destName{};
  shared_ptr<string> sourceName{};
  shared_ptr<string> sourceSchema{};

  ListProjectModifyRecordsResponseBodyDataOmsProjectMappingInfoTableMappings() {}

  explicit ListProjectModifyRecordsResponseBodyDataOmsProjectMappingInfoTableMappings(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (destName) {
      res["DestName"] = boost::any(*destName);
    }
    if (sourceName) {
      res["SourceName"] = boost::any(*sourceName);
    }
    if (sourceSchema) {
      res["SourceSchema"] = boost::any(*sourceSchema);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DestName") != m.end() && !m["DestName"].empty()) {
      destName = make_shared<string>(boost::any_cast<string>(m["DestName"]));
    }
    if (m.find("SourceName") != m.end() && !m["SourceName"].empty()) {
      sourceName = make_shared<string>(boost::any_cast<string>(m["SourceName"]));
    }
    if (m.find("SourceSchema") != m.end() && !m["SourceSchema"].empty()) {
      sourceSchema = make_shared<string>(boost::any_cast<string>(m["SourceSchema"]));
    }
  }


  virtual ~ListProjectModifyRecordsResponseBodyDataOmsProjectMappingInfoTableMappings() = default;
};
class ListProjectModifyRecordsResponseBodyDataOmsProjectMappingInfoViewMappings : public Darabonba::Model {
public:
  shared_ptr<string> destName{};
  shared_ptr<string> sourceName{};
  shared_ptr<string> sourceSchema{};

  ListProjectModifyRecordsResponseBodyDataOmsProjectMappingInfoViewMappings() {}

  explicit ListProjectModifyRecordsResponseBodyDataOmsProjectMappingInfoViewMappings(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (destName) {
      res["DestName"] = boost::any(*destName);
    }
    if (sourceName) {
      res["SourceName"] = boost::any(*sourceName);
    }
    if (sourceSchema) {
      res["SourceSchema"] = boost::any(*sourceSchema);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DestName") != m.end() && !m["DestName"].empty()) {
      destName = make_shared<string>(boost::any_cast<string>(m["DestName"]));
    }
    if (m.find("SourceName") != m.end() && !m["SourceName"].empty()) {
      sourceName = make_shared<string>(boost::any_cast<string>(m["SourceName"]));
    }
    if (m.find("SourceSchema") != m.end() && !m["SourceSchema"].empty()) {
      sourceSchema = make_shared<string>(boost::any_cast<string>(m["SourceSchema"]));
    }
  }


  virtual ~ListProjectModifyRecordsResponseBodyDataOmsProjectMappingInfoViewMappings() = default;
};
class ListProjectModifyRecordsResponseBodyDataOmsProjectMappingInfo : public Darabonba::Model {
public:
  shared_ptr<vector<ListProjectModifyRecordsResponseBodyDataOmsProjectMappingInfoColumnMappings>> columnMappings{};
  shared_ptr<vector<ListProjectModifyRecordsResponseBodyDataOmsProjectMappingInfoSchemaMappings>> schemaMappings{};
  shared_ptr<vector<ListProjectModifyRecordsResponseBodyDataOmsProjectMappingInfoTableMappings>> tableMappings{};
  shared_ptr<vector<ListProjectModifyRecordsResponseBodyDataOmsProjectMappingInfoViewMappings>> viewMappings{};

  ListProjectModifyRecordsResponseBodyDataOmsProjectMappingInfo() {}

  explicit ListProjectModifyRecordsResponseBodyDataOmsProjectMappingInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (columnMappings) {
      vector<boost::any> temp1;
      for(auto item1:*columnMappings){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ColumnMappings"] = boost::any(temp1);
    }
    if (schemaMappings) {
      vector<boost::any> temp1;
      for(auto item1:*schemaMappings){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SchemaMappings"] = boost::any(temp1);
    }
    if (tableMappings) {
      vector<boost::any> temp1;
      for(auto item1:*tableMappings){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TableMappings"] = boost::any(temp1);
    }
    if (viewMappings) {
      vector<boost::any> temp1;
      for(auto item1:*viewMappings){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ViewMappings"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ColumnMappings") != m.end() && !m["ColumnMappings"].empty()) {
      if (typeid(vector<boost::any>) == m["ColumnMappings"].type()) {
        vector<ListProjectModifyRecordsResponseBodyDataOmsProjectMappingInfoColumnMappings> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ColumnMappings"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListProjectModifyRecordsResponseBodyDataOmsProjectMappingInfoColumnMappings model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        columnMappings = make_shared<vector<ListProjectModifyRecordsResponseBodyDataOmsProjectMappingInfoColumnMappings>>(expect1);
      }
    }
    if (m.find("SchemaMappings") != m.end() && !m["SchemaMappings"].empty()) {
      if (typeid(vector<boost::any>) == m["SchemaMappings"].type()) {
        vector<ListProjectModifyRecordsResponseBodyDataOmsProjectMappingInfoSchemaMappings> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SchemaMappings"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListProjectModifyRecordsResponseBodyDataOmsProjectMappingInfoSchemaMappings model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        schemaMappings = make_shared<vector<ListProjectModifyRecordsResponseBodyDataOmsProjectMappingInfoSchemaMappings>>(expect1);
      }
    }
    if (m.find("TableMappings") != m.end() && !m["TableMappings"].empty()) {
      if (typeid(vector<boost::any>) == m["TableMappings"].type()) {
        vector<ListProjectModifyRecordsResponseBodyDataOmsProjectMappingInfoTableMappings> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TableMappings"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListProjectModifyRecordsResponseBodyDataOmsProjectMappingInfoTableMappings model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tableMappings = make_shared<vector<ListProjectModifyRecordsResponseBodyDataOmsProjectMappingInfoTableMappings>>(expect1);
      }
    }
    if (m.find("ViewMappings") != m.end() && !m["ViewMappings"].empty()) {
      if (typeid(vector<boost::any>) == m["ViewMappings"].type()) {
        vector<ListProjectModifyRecordsResponseBodyDataOmsProjectMappingInfoViewMappings> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ViewMappings"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListProjectModifyRecordsResponseBodyDataOmsProjectMappingInfoViewMappings model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        viewMappings = make_shared<vector<ListProjectModifyRecordsResponseBodyDataOmsProjectMappingInfoViewMappings>>(expect1);
      }
    }
  }


  virtual ~ListProjectModifyRecordsResponseBodyDataOmsProjectMappingInfo() = default;
};
class ListProjectModifyRecordsResponseBodyDataTableEtlList : public Darabonba::Model {
public:
  shared_ptr<string> database{};
  shared_ptr<string> destDatabase{};
  shared_ptr<string> destName{};
  shared_ptr<vector<string>> filterColumns{};
  shared_ptr<string> logicTableId{};
  shared_ptr<vector<string>> shardColumns{};
  shared_ptr<string> sourceEndpointId{};
  shared_ptr<string> tableName{};
  shared_ptr<string> tenantName{};
  shared_ptr<string> whereClause{};

  ListProjectModifyRecordsResponseBodyDataTableEtlList() {}

  explicit ListProjectModifyRecordsResponseBodyDataTableEtlList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (database) {
      res["Database"] = boost::any(*database);
    }
    if (destDatabase) {
      res["DestDatabase"] = boost::any(*destDatabase);
    }
    if (destName) {
      res["DestName"] = boost::any(*destName);
    }
    if (filterColumns) {
      res["FilterColumns"] = boost::any(*filterColumns);
    }
    if (logicTableId) {
      res["LogicTableId"] = boost::any(*logicTableId);
    }
    if (shardColumns) {
      res["ShardColumns"] = boost::any(*shardColumns);
    }
    if (sourceEndpointId) {
      res["SourceEndpointId"] = boost::any(*sourceEndpointId);
    }
    if (tableName) {
      res["TableName"] = boost::any(*tableName);
    }
    if (tenantName) {
      res["TenantName"] = boost::any(*tenantName);
    }
    if (whereClause) {
      res["WhereClause"] = boost::any(*whereClause);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Database") != m.end() && !m["Database"].empty()) {
      database = make_shared<string>(boost::any_cast<string>(m["Database"]));
    }
    if (m.find("DestDatabase") != m.end() && !m["DestDatabase"].empty()) {
      destDatabase = make_shared<string>(boost::any_cast<string>(m["DestDatabase"]));
    }
    if (m.find("DestName") != m.end() && !m["DestName"].empty()) {
      destName = make_shared<string>(boost::any_cast<string>(m["DestName"]));
    }
    if (m.find("FilterColumns") != m.end() && !m["FilterColumns"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["FilterColumns"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["FilterColumns"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      filterColumns = make_shared<vector<string>>(toVec1);
    }
    if (m.find("LogicTableId") != m.end() && !m["LogicTableId"].empty()) {
      logicTableId = make_shared<string>(boost::any_cast<string>(m["LogicTableId"]));
    }
    if (m.find("ShardColumns") != m.end() && !m["ShardColumns"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ShardColumns"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ShardColumns"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      shardColumns = make_shared<vector<string>>(toVec1);
    }
    if (m.find("SourceEndpointId") != m.end() && !m["SourceEndpointId"].empty()) {
      sourceEndpointId = make_shared<string>(boost::any_cast<string>(m["SourceEndpointId"]));
    }
    if (m.find("TableName") != m.end() && !m["TableName"].empty()) {
      tableName = make_shared<string>(boost::any_cast<string>(m["TableName"]));
    }
    if (m.find("TenantName") != m.end() && !m["TenantName"].empty()) {
      tenantName = make_shared<string>(boost::any_cast<string>(m["TenantName"]));
    }
    if (m.find("WhereClause") != m.end() && !m["WhereClause"].empty()) {
      whereClause = make_shared<string>(boost::any_cast<string>(m["WhereClause"]));
    }
  }


  virtual ~ListProjectModifyRecordsResponseBodyDataTableEtlList() = default;
};
class ListProjectModifyRecordsResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<ListProjectModifyRecordsResponseBodyDataDatabases>> databases{};
  shared_ptr<ListProjectModifyRecordsResponseBodyDataErrorDetail> errorDetail{};
  shared_ptr<string> gmtModified{};
  shared_ptr<long> id{};
  shared_ptr<long> mergeRequestId{};
  shared_ptr<ListProjectModifyRecordsResponseBodyDataMigrationObjectsInfo> migrationObjectsInfo{};
  shared_ptr<ListProjectModifyRecordsResponseBodyDataOmsProjectMappingInfo> omsProjectMappingInfo{};
  shared_ptr<string> status{};
  shared_ptr<string> subProjectId{};
  shared_ptr<vector<ListProjectModifyRecordsResponseBodyDataTableEtlList>> tableEtlList{};
  shared_ptr<string> type{};
  shared_ptr<long> updateRequestId{};

  ListProjectModifyRecordsResponseBodyData() {}

  explicit ListProjectModifyRecordsResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (databases) {
      vector<boost::any> temp1;
      for(auto item1:*databases){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Databases"] = boost::any(temp1);
    }
    if (errorDetail) {
      res["ErrorDetail"] = errorDetail ? boost::any(errorDetail->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (mergeRequestId) {
      res["MergeRequestId"] = boost::any(*mergeRequestId);
    }
    if (migrationObjectsInfo) {
      res["MigrationObjectsInfo"] = migrationObjectsInfo ? boost::any(migrationObjectsInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (omsProjectMappingInfo) {
      res["OmsProjectMappingInfo"] = omsProjectMappingInfo ? boost::any(omsProjectMappingInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (subProjectId) {
      res["SubProjectId"] = boost::any(*subProjectId);
    }
    if (tableEtlList) {
      vector<boost::any> temp1;
      for(auto item1:*tableEtlList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TableEtlList"] = boost::any(temp1);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (updateRequestId) {
      res["UpdateRequestId"] = boost::any(*updateRequestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Databases") != m.end() && !m["Databases"].empty()) {
      if (typeid(vector<boost::any>) == m["Databases"].type()) {
        vector<ListProjectModifyRecordsResponseBodyDataDatabases> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Databases"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListProjectModifyRecordsResponseBodyDataDatabases model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        databases = make_shared<vector<ListProjectModifyRecordsResponseBodyDataDatabases>>(expect1);
      }
    }
    if (m.find("ErrorDetail") != m.end() && !m["ErrorDetail"].empty()) {
      if (typeid(map<string, boost::any>) == m["ErrorDetail"].type()) {
        ListProjectModifyRecordsResponseBodyDataErrorDetail model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ErrorDetail"]));
        errorDetail = make_shared<ListProjectModifyRecordsResponseBodyDataErrorDetail>(model1);
      }
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<string>(boost::any_cast<string>(m["GmtModified"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("MergeRequestId") != m.end() && !m["MergeRequestId"].empty()) {
      mergeRequestId = make_shared<long>(boost::any_cast<long>(m["MergeRequestId"]));
    }
    if (m.find("MigrationObjectsInfo") != m.end() && !m["MigrationObjectsInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["MigrationObjectsInfo"].type()) {
        ListProjectModifyRecordsResponseBodyDataMigrationObjectsInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MigrationObjectsInfo"]));
        migrationObjectsInfo = make_shared<ListProjectModifyRecordsResponseBodyDataMigrationObjectsInfo>(model1);
      }
    }
    if (m.find("OmsProjectMappingInfo") != m.end() && !m["OmsProjectMappingInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["OmsProjectMappingInfo"].type()) {
        ListProjectModifyRecordsResponseBodyDataOmsProjectMappingInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OmsProjectMappingInfo"]));
        omsProjectMappingInfo = make_shared<ListProjectModifyRecordsResponseBodyDataOmsProjectMappingInfo>(model1);
      }
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("SubProjectId") != m.end() && !m["SubProjectId"].empty()) {
      subProjectId = make_shared<string>(boost::any_cast<string>(m["SubProjectId"]));
    }
    if (m.find("TableEtlList") != m.end() && !m["TableEtlList"].empty()) {
      if (typeid(vector<boost::any>) == m["TableEtlList"].type()) {
        vector<ListProjectModifyRecordsResponseBodyDataTableEtlList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TableEtlList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListProjectModifyRecordsResponseBodyDataTableEtlList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tableEtlList = make_shared<vector<ListProjectModifyRecordsResponseBodyDataTableEtlList>>(expect1);
      }
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("UpdateRequestId") != m.end() && !m["UpdateRequestId"].empty()) {
      updateRequestId = make_shared<long>(boost::any_cast<long>(m["UpdateRequestId"]));
    }
  }


  virtual ~ListProjectModifyRecordsResponseBodyData() = default;
};
class ListProjectModifyRecordsResponseBodyErrorDetail : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<map<string, boost::any>> extraContext{};
  shared_ptr<string> level{};
  shared_ptr<string> message{};
  shared_ptr<map<string, string>> messageMcmsContext{};
  shared_ptr<string> messageMcmsKey{};
  shared_ptr<string> proposal{};
  shared_ptr<map<string, string>> proposalMcmsContext{};
  shared_ptr<string> proposalMcmsKey{};
  shared_ptr<string> reason{};
  shared_ptr<map<string, string>> reasonMcmsContext{};
  shared_ptr<string> reasonMcmsKey{};
  shared_ptr<boost::any> upstreamErrorDetail{};

  ListProjectModifyRecordsResponseBodyErrorDetail() {}

  explicit ListProjectModifyRecordsResponseBodyErrorDetail(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (extraContext) {
      res["ExtraContext"] = boost::any(*extraContext);
    }
    if (level) {
      res["Level"] = boost::any(*level);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (messageMcmsContext) {
      res["MessageMcmsContext"] = boost::any(*messageMcmsContext);
    }
    if (messageMcmsKey) {
      res["MessageMcmsKey"] = boost::any(*messageMcmsKey);
    }
    if (proposal) {
      res["Proposal"] = boost::any(*proposal);
    }
    if (proposalMcmsContext) {
      res["ProposalMcmsContext"] = boost::any(*proposalMcmsContext);
    }
    if (proposalMcmsKey) {
      res["ProposalMcmsKey"] = boost::any(*proposalMcmsKey);
    }
    if (reason) {
      res["Reason"] = boost::any(*reason);
    }
    if (reasonMcmsContext) {
      res["ReasonMcmsContext"] = boost::any(*reasonMcmsContext);
    }
    if (reasonMcmsKey) {
      res["ReasonMcmsKey"] = boost::any(*reasonMcmsKey);
    }
    if (upstreamErrorDetail) {
      res["UpstreamErrorDetail"] = boost::any(*upstreamErrorDetail);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ExtraContext") != m.end() && !m["ExtraContext"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["ExtraContext"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      extraContext = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<string>(boost::any_cast<string>(m["Level"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("MessageMcmsContext") != m.end() && !m["MessageMcmsContext"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["MessageMcmsContext"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      messageMcmsContext = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("MessageMcmsKey") != m.end() && !m["MessageMcmsKey"].empty()) {
      messageMcmsKey = make_shared<string>(boost::any_cast<string>(m["MessageMcmsKey"]));
    }
    if (m.find("Proposal") != m.end() && !m["Proposal"].empty()) {
      proposal = make_shared<string>(boost::any_cast<string>(m["Proposal"]));
    }
    if (m.find("ProposalMcmsContext") != m.end() && !m["ProposalMcmsContext"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["ProposalMcmsContext"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      proposalMcmsContext = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("ProposalMcmsKey") != m.end() && !m["ProposalMcmsKey"].empty()) {
      proposalMcmsKey = make_shared<string>(boost::any_cast<string>(m["ProposalMcmsKey"]));
    }
    if (m.find("Reason") != m.end() && !m["Reason"].empty()) {
      reason = make_shared<string>(boost::any_cast<string>(m["Reason"]));
    }
    if (m.find("ReasonMcmsContext") != m.end() && !m["ReasonMcmsContext"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["ReasonMcmsContext"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      reasonMcmsContext = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("ReasonMcmsKey") != m.end() && !m["ReasonMcmsKey"].empty()) {
      reasonMcmsKey = make_shared<string>(boost::any_cast<string>(m["ReasonMcmsKey"]));
    }
    if (m.find("UpstreamErrorDetail") != m.end() && !m["UpstreamErrorDetail"].empty()) {
      upstreamErrorDetail = make_shared<boost::any>(boost::any_cast<boost::any>(m["UpstreamErrorDetail"]));
    }
  }


  virtual ~ListProjectModifyRecordsResponseBodyErrorDetail() = default;
};
class ListProjectModifyRecordsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> advice{};
  shared_ptr<string> code{};
  shared_ptr<string> cost{};
  shared_ptr<vector<ListProjectModifyRecordsResponseBodyData>> data{};
  shared_ptr<ListProjectModifyRecordsResponseBodyErrorDetail> errorDetail{};
  shared_ptr<string> message{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<long> totalCount{};

  ListProjectModifyRecordsResponseBody() {}

  explicit ListProjectModifyRecordsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (advice) {
      res["Advice"] = boost::any(*advice);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (cost) {
      res["Cost"] = boost::any(*cost);
    }
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (errorDetail) {
      res["ErrorDetail"] = errorDetail ? boost::any(errorDetail->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Advice") != m.end() && !m["Advice"].empty()) {
      advice = make_shared<string>(boost::any_cast<string>(m["Advice"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Cost") != m.end() && !m["Cost"].empty()) {
      cost = make_shared<string>(boost::any_cast<string>(m["Cost"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<ListProjectModifyRecordsResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListProjectModifyRecordsResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<ListProjectModifyRecordsResponseBodyData>>(expect1);
      }
    }
    if (m.find("ErrorDetail") != m.end() && !m["ErrorDetail"].empty()) {
      if (typeid(map<string, boost::any>) == m["ErrorDetail"].type()) {
        ListProjectModifyRecordsResponseBodyErrorDetail model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ErrorDetail"]));
        errorDetail = make_shared<ListProjectModifyRecordsResponseBodyErrorDetail>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListProjectModifyRecordsResponseBody() = default;
};
class ListProjectModifyRecordsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListProjectModifyRecordsResponseBody> body{};

  ListProjectModifyRecordsResponse() {}

  explicit ListProjectModifyRecordsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListProjectModifyRecordsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListProjectModifyRecordsResponseBody>(model1);
      }
    }
  }


  virtual ~ListProjectModifyRecordsResponse() = default;
};
class ListProjectsRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> labelIds{};
  shared_ptr<bool> needRelatedInfo{};
  shared_ptr<string> order{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> searchKey{};
  shared_ptr<vector<string>> sinkEndpointTypes{};
  shared_ptr<string> sortField{};
  shared_ptr<vector<string>> sourceEndpointTypes{};
  shared_ptr<vector<string>> status{};
  shared_ptr<string> type{};
  shared_ptr<bool> visibleSubProject{};

  ListProjectsRequest() {}

  explicit ListProjectsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (labelIds) {
      res["LabelIds"] = boost::any(*labelIds);
    }
    if (needRelatedInfo) {
      res["NeedRelatedInfo"] = boost::any(*needRelatedInfo);
    }
    if (order) {
      res["Order"] = boost::any(*order);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (searchKey) {
      res["SearchKey"] = boost::any(*searchKey);
    }
    if (sinkEndpointTypes) {
      res["SinkEndpointTypes"] = boost::any(*sinkEndpointTypes);
    }
    if (sortField) {
      res["SortField"] = boost::any(*sortField);
    }
    if (sourceEndpointTypes) {
      res["SourceEndpointTypes"] = boost::any(*sourceEndpointTypes);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (visibleSubProject) {
      res["VisibleSubProject"] = boost::any(*visibleSubProject);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LabelIds") != m.end() && !m["LabelIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["LabelIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["LabelIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      labelIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("NeedRelatedInfo") != m.end() && !m["NeedRelatedInfo"].empty()) {
      needRelatedInfo = make_shared<bool>(boost::any_cast<bool>(m["NeedRelatedInfo"]));
    }
    if (m.find("Order") != m.end() && !m["Order"].empty()) {
      order = make_shared<string>(boost::any_cast<string>(m["Order"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SearchKey") != m.end() && !m["SearchKey"].empty()) {
      searchKey = make_shared<string>(boost::any_cast<string>(m["SearchKey"]));
    }
    if (m.find("SinkEndpointTypes") != m.end() && !m["SinkEndpointTypes"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SinkEndpointTypes"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SinkEndpointTypes"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      sinkEndpointTypes = make_shared<vector<string>>(toVec1);
    }
    if (m.find("SortField") != m.end() && !m["SortField"].empty()) {
      sortField = make_shared<string>(boost::any_cast<string>(m["SortField"]));
    }
    if (m.find("SourceEndpointTypes") != m.end() && !m["SourceEndpointTypes"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SourceEndpointTypes"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SourceEndpointTypes"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      sourceEndpointTypes = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Status"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Status"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      status = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("VisibleSubProject") != m.end() && !m["VisibleSubProject"].empty()) {
      visibleSubProject = make_shared<bool>(boost::any_cast<bool>(m["VisibleSubProject"]));
    }
  }


  virtual ~ListProjectsRequest() = default;
};
class ListProjectsShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> labelIdsShrink{};
  shared_ptr<bool> needRelatedInfo{};
  shared_ptr<string> order{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> searchKey{};
  shared_ptr<string> sinkEndpointTypesShrink{};
  shared_ptr<string> sortField{};
  shared_ptr<string> sourceEndpointTypesShrink{};
  shared_ptr<string> statusShrink{};
  shared_ptr<string> type{};
  shared_ptr<bool> visibleSubProject{};

  ListProjectsShrinkRequest() {}

  explicit ListProjectsShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (labelIdsShrink) {
      res["LabelIds"] = boost::any(*labelIdsShrink);
    }
    if (needRelatedInfo) {
      res["NeedRelatedInfo"] = boost::any(*needRelatedInfo);
    }
    if (order) {
      res["Order"] = boost::any(*order);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (searchKey) {
      res["SearchKey"] = boost::any(*searchKey);
    }
    if (sinkEndpointTypesShrink) {
      res["SinkEndpointTypes"] = boost::any(*sinkEndpointTypesShrink);
    }
    if (sortField) {
      res["SortField"] = boost::any(*sortField);
    }
    if (sourceEndpointTypesShrink) {
      res["SourceEndpointTypes"] = boost::any(*sourceEndpointTypesShrink);
    }
    if (statusShrink) {
      res["Status"] = boost::any(*statusShrink);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (visibleSubProject) {
      res["VisibleSubProject"] = boost::any(*visibleSubProject);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LabelIds") != m.end() && !m["LabelIds"].empty()) {
      labelIdsShrink = make_shared<string>(boost::any_cast<string>(m["LabelIds"]));
    }
    if (m.find("NeedRelatedInfo") != m.end() && !m["NeedRelatedInfo"].empty()) {
      needRelatedInfo = make_shared<bool>(boost::any_cast<bool>(m["NeedRelatedInfo"]));
    }
    if (m.find("Order") != m.end() && !m["Order"].empty()) {
      order = make_shared<string>(boost::any_cast<string>(m["Order"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SearchKey") != m.end() && !m["SearchKey"].empty()) {
      searchKey = make_shared<string>(boost::any_cast<string>(m["SearchKey"]));
    }
    if (m.find("SinkEndpointTypes") != m.end() && !m["SinkEndpointTypes"].empty()) {
      sinkEndpointTypesShrink = make_shared<string>(boost::any_cast<string>(m["SinkEndpointTypes"]));
    }
    if (m.find("SortField") != m.end() && !m["SortField"].empty()) {
      sortField = make_shared<string>(boost::any_cast<string>(m["SortField"]));
    }
    if (m.find("SourceEndpointTypes") != m.end() && !m["SourceEndpointTypes"].empty()) {
      sourceEndpointTypesShrink = make_shared<string>(boost::any_cast<string>(m["SourceEndpointTypes"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      statusShrink = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("VisibleSubProject") != m.end() && !m["VisibleSubProject"].empty()) {
      visibleSubProject = make_shared<bool>(boost::any_cast<bool>(m["VisibleSubProject"]));
    }
  }


  virtual ~ListProjectsShrinkRequest() = default;
};
class ListProjectsResponseBodyDataAlarmStats : public Darabonba::Model {
public:
  shared_ptr<string> alarmContent{};
  shared_ptr<bool> alarming{};
  shared_ptr<bool> openMonitor{};
  shared_ptr<long> recentlyTriggerCount{};
  shared_ptr<map<string, long>> ruleToRecentlyTriggerCount{};
  shared_ptr<string> target{};

  ListProjectsResponseBodyDataAlarmStats() {}

  explicit ListProjectsResponseBodyDataAlarmStats(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alarmContent) {
      res["AlarmContent"] = boost::any(*alarmContent);
    }
    if (alarming) {
      res["Alarming"] = boost::any(*alarming);
    }
    if (openMonitor) {
      res["OpenMonitor"] = boost::any(*openMonitor);
    }
    if (recentlyTriggerCount) {
      res["RecentlyTriggerCount"] = boost::any(*recentlyTriggerCount);
    }
    if (ruleToRecentlyTriggerCount) {
      res["RuleToRecentlyTriggerCount"] = boost::any(*ruleToRecentlyTriggerCount);
    }
    if (target) {
      res["Target"] = boost::any(*target);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlarmContent") != m.end() && !m["AlarmContent"].empty()) {
      alarmContent = make_shared<string>(boost::any_cast<string>(m["AlarmContent"]));
    }
    if (m.find("Alarming") != m.end() && !m["Alarming"].empty()) {
      alarming = make_shared<bool>(boost::any_cast<bool>(m["Alarming"]));
    }
    if (m.find("OpenMonitor") != m.end() && !m["OpenMonitor"].empty()) {
      openMonitor = make_shared<bool>(boost::any_cast<bool>(m["OpenMonitor"]));
    }
    if (m.find("RecentlyTriggerCount") != m.end() && !m["RecentlyTriggerCount"].empty()) {
      recentlyTriggerCount = make_shared<long>(boost::any_cast<long>(m["RecentlyTriggerCount"]));
    }
    if (m.find("RuleToRecentlyTriggerCount") != m.end() && !m["RuleToRecentlyTriggerCount"].empty()) {
      map<string, long> map1 = boost::any_cast<map<string, long>>(m["RuleToRecentlyTriggerCount"]);
      map<string, long> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      ruleToRecentlyTriggerCount = make_shared<map<string, long>>(toMap1);
    }
    if (m.find("Target") != m.end() && !m["Target"].empty()) {
      target = make_shared<string>(boost::any_cast<string>(m["Target"]));
    }
  }


  virtual ~ListProjectsResponseBodyDataAlarmStats() = default;
};
class ListProjectsResponseBodyDataCommonTransferConfig : public Darabonba::Model {
public:
  shared_ptr<bool> activeActive{};
  shared_ptr<string> dataWorksBusinessName{};
  shared_ptr<string> datahubTopicType{};
  shared_ptr<long> mqPartition{};
  shared_ptr<string> mqPartitionMode{};
  shared_ptr<string> mqSerializerType{};
  shared_ptr<bool> rocketMqEnableMsgTrace{};
  shared_ptr<string> rocketMqMsgTags{};
  shared_ptr<string> rocketMqProducerGroup{};
  shared_ptr<long> rocketMqSendMsgTimeout{};
  shared_ptr<string> tableCategory{};

  ListProjectsResponseBodyDataCommonTransferConfig() {}

  explicit ListProjectsResponseBodyDataCommonTransferConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (activeActive) {
      res["ActiveActive"] = boost::any(*activeActive);
    }
    if (dataWorksBusinessName) {
      res["DataWorksBusinessName"] = boost::any(*dataWorksBusinessName);
    }
    if (datahubTopicType) {
      res["DatahubTopicType"] = boost::any(*datahubTopicType);
    }
    if (mqPartition) {
      res["MqPartition"] = boost::any(*mqPartition);
    }
    if (mqPartitionMode) {
      res["MqPartitionMode"] = boost::any(*mqPartitionMode);
    }
    if (mqSerializerType) {
      res["MqSerializerType"] = boost::any(*mqSerializerType);
    }
    if (rocketMqEnableMsgTrace) {
      res["RocketMqEnableMsgTrace"] = boost::any(*rocketMqEnableMsgTrace);
    }
    if (rocketMqMsgTags) {
      res["RocketMqMsgTags"] = boost::any(*rocketMqMsgTags);
    }
    if (rocketMqProducerGroup) {
      res["RocketMqProducerGroup"] = boost::any(*rocketMqProducerGroup);
    }
    if (rocketMqSendMsgTimeout) {
      res["RocketMqSendMsgTimeout"] = boost::any(*rocketMqSendMsgTimeout);
    }
    if (tableCategory) {
      res["TableCategory"] = boost::any(*tableCategory);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ActiveActive") != m.end() && !m["ActiveActive"].empty()) {
      activeActive = make_shared<bool>(boost::any_cast<bool>(m["ActiveActive"]));
    }
    if (m.find("DataWorksBusinessName") != m.end() && !m["DataWorksBusinessName"].empty()) {
      dataWorksBusinessName = make_shared<string>(boost::any_cast<string>(m["DataWorksBusinessName"]));
    }
    if (m.find("DatahubTopicType") != m.end() && !m["DatahubTopicType"].empty()) {
      datahubTopicType = make_shared<string>(boost::any_cast<string>(m["DatahubTopicType"]));
    }
    if (m.find("MqPartition") != m.end() && !m["MqPartition"].empty()) {
      mqPartition = make_shared<long>(boost::any_cast<long>(m["MqPartition"]));
    }
    if (m.find("MqPartitionMode") != m.end() && !m["MqPartitionMode"].empty()) {
      mqPartitionMode = make_shared<string>(boost::any_cast<string>(m["MqPartitionMode"]));
    }
    if (m.find("MqSerializerType") != m.end() && !m["MqSerializerType"].empty()) {
      mqSerializerType = make_shared<string>(boost::any_cast<string>(m["MqSerializerType"]));
    }
    if (m.find("RocketMqEnableMsgTrace") != m.end() && !m["RocketMqEnableMsgTrace"].empty()) {
      rocketMqEnableMsgTrace = make_shared<bool>(boost::any_cast<bool>(m["RocketMqEnableMsgTrace"]));
    }
    if (m.find("RocketMqMsgTags") != m.end() && !m["RocketMqMsgTags"].empty()) {
      rocketMqMsgTags = make_shared<string>(boost::any_cast<string>(m["RocketMqMsgTags"]));
    }
    if (m.find("RocketMqProducerGroup") != m.end() && !m["RocketMqProducerGroup"].empty()) {
      rocketMqProducerGroup = make_shared<string>(boost::any_cast<string>(m["RocketMqProducerGroup"]));
    }
    if (m.find("RocketMqSendMsgTimeout") != m.end() && !m["RocketMqSendMsgTimeout"].empty()) {
      rocketMqSendMsgTimeout = make_shared<long>(boost::any_cast<long>(m["RocketMqSendMsgTimeout"]));
    }
    if (m.find("TableCategory") != m.end() && !m["TableCategory"].empty()) {
      tableCategory = make_shared<string>(boost::any_cast<string>(m["TableCategory"]));
    }
  }


  virtual ~ListProjectsResponseBodyDataCommonTransferConfig() = default;
};
class ListProjectsResponseBodyDataExtraInfo : public Darabonba::Model {
public:
  shared_ptr<bool> accessObSource{};
  shared_ptr<bool> ignoreUnsupportDdl{};
  shared_ptr<long> incrSyncTimestamp{};
  shared_ptr<long> logServiceStartCheckpoint{};
  shared_ptr<long> maxConnectorCount{};
  shared_ptr<bool> monitoringIncr{};
  shared_ptr<bool> overwriteConfig{};
  shared_ptr<vector<string>> reverseSubtopics{};
  shared_ptr<long> runningProgress{};
  shared_ptr<string> runningStep{};
  shared_ptr<long> sourceStoreKeptHour{};
  shared_ptr<bool> storeIncr{};
  shared_ptr<map<string, vector<DataExtraInfoSubCondsValue>>> subConds{};
  shared_ptr<map<string, vector<DataExtraInfoSubDbsValue>>> subDbs{};
  shared_ptr<map<string, string>> subIds{};
  shared_ptr<vector<string>> subtopics{};
  shared_ptr<long> syncDelay{};
  shared_ptr<long> syncDelaySampleTimestamp{};

  ListProjectsResponseBodyDataExtraInfo() {}

  explicit ListProjectsResponseBodyDataExtraInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessObSource) {
      res["AccessObSource"] = boost::any(*accessObSource);
    }
    if (ignoreUnsupportDdl) {
      res["IgnoreUnsupportDdl"] = boost::any(*ignoreUnsupportDdl);
    }
    if (incrSyncTimestamp) {
      res["IncrSyncTimestamp"] = boost::any(*incrSyncTimestamp);
    }
    if (logServiceStartCheckpoint) {
      res["LogServiceStartCheckpoint"] = boost::any(*logServiceStartCheckpoint);
    }
    if (maxConnectorCount) {
      res["MaxConnectorCount"] = boost::any(*maxConnectorCount);
    }
    if (monitoringIncr) {
      res["MonitoringIncr"] = boost::any(*monitoringIncr);
    }
    if (overwriteConfig) {
      res["OverwriteConfig"] = boost::any(*overwriteConfig);
    }
    if (reverseSubtopics) {
      res["ReverseSubtopics"] = boost::any(*reverseSubtopics);
    }
    if (runningProgress) {
      res["RunningProgress"] = boost::any(*runningProgress);
    }
    if (runningStep) {
      res["RunningStep"] = boost::any(*runningStep);
    }
    if (sourceStoreKeptHour) {
      res["SourceStoreKeptHour"] = boost::any(*sourceStoreKeptHour);
    }
    if (storeIncr) {
      res["StoreIncr"] = boost::any(*storeIncr);
    }
    if (subConds) {
      map<string, boost::any> temp1;
      for(auto item1:*subConds){
        vector<boost::any> temp2;
        for(auto item2:item1.second){
          temp2.push_back(boost::any(item2.toMap()));
        }
        temp1[item1.first] = boost::any(temp2);
      }
      res["SubConds"] = boost::any(temp1);
    }
    if (subDbs) {
      map<string, boost::any> temp1;
      for(auto item1:*subDbs){
        vector<boost::any> temp2;
        for(auto item2:item1.second){
          temp2.push_back(boost::any(item2.toMap()));
        }
        temp1[item1.first] = boost::any(temp2);
      }
      res["SubDbs"] = boost::any(temp1);
    }
    if (subIds) {
      res["SubIds"] = boost::any(*subIds);
    }
    if (subtopics) {
      res["Subtopics"] = boost::any(*subtopics);
    }
    if (syncDelay) {
      res["SyncDelay"] = boost::any(*syncDelay);
    }
    if (syncDelaySampleTimestamp) {
      res["SyncDelaySampleTimestamp"] = boost::any(*syncDelaySampleTimestamp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccessObSource") != m.end() && !m["AccessObSource"].empty()) {
      accessObSource = make_shared<bool>(boost::any_cast<bool>(m["AccessObSource"]));
    }
    if (m.find("IgnoreUnsupportDdl") != m.end() && !m["IgnoreUnsupportDdl"].empty()) {
      ignoreUnsupportDdl = make_shared<bool>(boost::any_cast<bool>(m["IgnoreUnsupportDdl"]));
    }
    if (m.find("IncrSyncTimestamp") != m.end() && !m["IncrSyncTimestamp"].empty()) {
      incrSyncTimestamp = make_shared<long>(boost::any_cast<long>(m["IncrSyncTimestamp"]));
    }
    if (m.find("LogServiceStartCheckpoint") != m.end() && !m["LogServiceStartCheckpoint"].empty()) {
      logServiceStartCheckpoint = make_shared<long>(boost::any_cast<long>(m["LogServiceStartCheckpoint"]));
    }
    if (m.find("MaxConnectorCount") != m.end() && !m["MaxConnectorCount"].empty()) {
      maxConnectorCount = make_shared<long>(boost::any_cast<long>(m["MaxConnectorCount"]));
    }
    if (m.find("MonitoringIncr") != m.end() && !m["MonitoringIncr"].empty()) {
      monitoringIncr = make_shared<bool>(boost::any_cast<bool>(m["MonitoringIncr"]));
    }
    if (m.find("OverwriteConfig") != m.end() && !m["OverwriteConfig"].empty()) {
      overwriteConfig = make_shared<bool>(boost::any_cast<bool>(m["OverwriteConfig"]));
    }
    if (m.find("ReverseSubtopics") != m.end() && !m["ReverseSubtopics"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ReverseSubtopics"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ReverseSubtopics"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      reverseSubtopics = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RunningProgress") != m.end() && !m["RunningProgress"].empty()) {
      runningProgress = make_shared<long>(boost::any_cast<long>(m["RunningProgress"]));
    }
    if (m.find("RunningStep") != m.end() && !m["RunningStep"].empty()) {
      runningStep = make_shared<string>(boost::any_cast<string>(m["RunningStep"]));
    }
    if (m.find("SourceStoreKeptHour") != m.end() && !m["SourceStoreKeptHour"].empty()) {
      sourceStoreKeptHour = make_shared<long>(boost::any_cast<long>(m["SourceStoreKeptHour"]));
    }
    if (m.find("StoreIncr") != m.end() && !m["StoreIncr"].empty()) {
      storeIncr = make_shared<bool>(boost::any_cast<bool>(m["StoreIncr"]));
    }
    if (m.find("SubConds") != m.end() && !m["SubConds"].empty()) {
      if (typeid(map<string, boost::any>) == m["SubConds"].type()) {
        map<string, vector<DataExtraInfoSubCondsValue>> expect1;
        for(auto item1:boost::any_cast<map<string, boost::any>>(m["SubConds"])){
          if (typeid(vector<boost::any>) == item1.second.type()) {
            vector<DataExtraInfoSubCondsValue> expect2;
            for(auto item2:boost::any_cast<vector<boost::any>>(item1.second)){
              if (typeid(map<string, boost::any>) == item2.type()) {
                DataExtraInfoSubCondsValue model3;
                model3.fromMap(boost::any_cast<map<string, boost::any>>(item2));
                expect2.push_back(model3);
              }
            }
            expect1[item1.first] = expect2;
          }
        }
        subConds = make_shared<map<string, vector<DataExtraInfoSubCondsValue>>>(expect1);
      }
    }
    if (m.find("SubDbs") != m.end() && !m["SubDbs"].empty()) {
      if (typeid(map<string, boost::any>) == m["SubDbs"].type()) {
        map<string, vector<DataExtraInfoSubDbsValue>> expect1;
        for(auto item1:boost::any_cast<map<string, boost::any>>(m["SubDbs"])){
          if (typeid(vector<boost::any>) == item1.second.type()) {
            vector<DataExtraInfoSubDbsValue> expect2;
            for(auto item2:boost::any_cast<vector<boost::any>>(item1.second)){
              if (typeid(map<string, boost::any>) == item2.type()) {
                DataExtraInfoSubDbsValue model3;
                model3.fromMap(boost::any_cast<map<string, boost::any>>(item2));
                expect2.push_back(model3);
              }
            }
            expect1[item1.first] = expect2;
          }
        }
        subDbs = make_shared<map<string, vector<DataExtraInfoSubDbsValue>>>(expect1);
      }
    }
    if (m.find("SubIds") != m.end() && !m["SubIds"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["SubIds"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      subIds = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("Subtopics") != m.end() && !m["Subtopics"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Subtopics"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Subtopics"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      subtopics = make_shared<vector<string>>(toVec1);
    }
    if (m.find("SyncDelay") != m.end() && !m["SyncDelay"].empty()) {
      syncDelay = make_shared<long>(boost::any_cast<long>(m["SyncDelay"]));
    }
    if (m.find("SyncDelaySampleTimestamp") != m.end() && !m["SyncDelaySampleTimestamp"].empty()) {
      syncDelaySampleTimestamp = make_shared<long>(boost::any_cast<long>(m["SyncDelaySampleTimestamp"]));
    }
  }


  virtual ~ListProjectsResponseBodyDataExtraInfo() = default;
};
class ListProjectsResponseBodyDataFullTransferConfig : public Darabonba::Model {
public:
  shared_ptr<bool> allowDestTableNotEmpty{};
  shared_ptr<string> fullTransferSpeedMode{};
  shared_ptr<string> fullVerifySpeedMode{};
  shared_ptr<bool> nonePkUkTruncateDstTable{};

  ListProjectsResponseBodyDataFullTransferConfig() {}

  explicit ListProjectsResponseBodyDataFullTransferConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (allowDestTableNotEmpty) {
      res["AllowDestTableNotEmpty"] = boost::any(*allowDestTableNotEmpty);
    }
    if (fullTransferSpeedMode) {
      res["FullTransferSpeedMode"] = boost::any(*fullTransferSpeedMode);
    }
    if (fullVerifySpeedMode) {
      res["FullVerifySpeedMode"] = boost::any(*fullVerifySpeedMode);
    }
    if (nonePkUkTruncateDstTable) {
      res["NonePkUkTruncateDstTable"] = boost::any(*nonePkUkTruncateDstTable);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AllowDestTableNotEmpty") != m.end() && !m["AllowDestTableNotEmpty"].empty()) {
      allowDestTableNotEmpty = make_shared<bool>(boost::any_cast<bool>(m["AllowDestTableNotEmpty"]));
    }
    if (m.find("FullTransferSpeedMode") != m.end() && !m["FullTransferSpeedMode"].empty()) {
      fullTransferSpeedMode = make_shared<string>(boost::any_cast<string>(m["FullTransferSpeedMode"]));
    }
    if (m.find("FullVerifySpeedMode") != m.end() && !m["FullVerifySpeedMode"].empty()) {
      fullVerifySpeedMode = make_shared<string>(boost::any_cast<string>(m["FullVerifySpeedMode"]));
    }
    if (m.find("NonePkUkTruncateDstTable") != m.end() && !m["NonePkUkTruncateDstTable"].empty()) {
      nonePkUkTruncateDstTable = make_shared<bool>(boost::any_cast<bool>(m["NonePkUkTruncateDstTable"]));
    }
  }


  virtual ~ListProjectsResponseBodyDataFullTransferConfig() = default;
};
class ListProjectsResponseBodyDataIncrTransferConfig : public Darabonba::Model {
public:
  shared_ptr<bool> enableIncrSyncStatistics{};
  shared_ptr<bool> enableSequencingWithinTxn{};
  shared_ptr<long> incrSyncConcurrency{};
  shared_ptr<vector<string>> recordTypeWhiteList{};
  shared_ptr<long> startTimestamp{};
  shared_ptr<long> storeLogKeptHour{};

  ListProjectsResponseBodyDataIncrTransferConfig() {}

  explicit ListProjectsResponseBodyDataIncrTransferConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (enableIncrSyncStatistics) {
      res["EnableIncrSyncStatistics"] = boost::any(*enableIncrSyncStatistics);
    }
    if (enableSequencingWithinTxn) {
      res["EnableSequencingWithinTxn"] = boost::any(*enableSequencingWithinTxn);
    }
    if (incrSyncConcurrency) {
      res["IncrSyncConcurrency"] = boost::any(*incrSyncConcurrency);
    }
    if (recordTypeWhiteList) {
      res["RecordTypeWhiteList"] = boost::any(*recordTypeWhiteList);
    }
    if (startTimestamp) {
      res["StartTimestamp"] = boost::any(*startTimestamp);
    }
    if (storeLogKeptHour) {
      res["StoreLogKeptHour"] = boost::any(*storeLogKeptHour);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EnableIncrSyncStatistics") != m.end() && !m["EnableIncrSyncStatistics"].empty()) {
      enableIncrSyncStatistics = make_shared<bool>(boost::any_cast<bool>(m["EnableIncrSyncStatistics"]));
    }
    if (m.find("EnableSequencingWithinTxn") != m.end() && !m["EnableSequencingWithinTxn"].empty()) {
      enableSequencingWithinTxn = make_shared<bool>(boost::any_cast<bool>(m["EnableSequencingWithinTxn"]));
    }
    if (m.find("IncrSyncConcurrency") != m.end() && !m["IncrSyncConcurrency"].empty()) {
      incrSyncConcurrency = make_shared<long>(boost::any_cast<long>(m["IncrSyncConcurrency"]));
    }
    if (m.find("RecordTypeWhiteList") != m.end() && !m["RecordTypeWhiteList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["RecordTypeWhiteList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["RecordTypeWhiteList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      recordTypeWhiteList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("StartTimestamp") != m.end() && !m["StartTimestamp"].empty()) {
      startTimestamp = make_shared<long>(boost::any_cast<long>(m["StartTimestamp"]));
    }
    if (m.find("StoreLogKeptHour") != m.end() && !m["StoreLogKeptHour"].empty()) {
      storeLogKeptHour = make_shared<long>(boost::any_cast<long>(m["StoreLogKeptHour"]));
    }
  }


  virtual ~ListProjectsResponseBodyDataIncrTransferConfig() = default;
};
class ListProjectsResponseBodyDataLabels : public Darabonba::Model {
public:
  shared_ptr<long> count{};
  shared_ptr<string> creator{};
  shared_ptr<string> id{};
  shared_ptr<string> name{};
  shared_ptr<long> type{};

  ListProjectsResponseBodyDataLabels() {}

  explicit ListProjectsResponseBodyDataLabels(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (creator) {
      res["Creator"] = boost::any(*creator);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("Creator") != m.end() && !m["Creator"].empty()) {
      creator = make_shared<string>(boost::any_cast<string>(m["Creator"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["Type"]));
    }
  }


  virtual ~ListProjectsResponseBodyDataLabels() = default;
};
class ListProjectsResponseBodyDataSinkConnectInfo : public Darabonba::Model {
public:
  shared_ptr<string> charset{};
  shared_ptr<boost::any> connExtraAttributes{};
  shared_ptr<string> connectionInfo{};
  shared_ptr<string> dbEngine{};
  shared_ptr<string> endpointId{};
  shared_ptr<string> endpointName{};
  shared_ptr<string> endpointSide{};
  shared_ptr<string> host{};
  shared_ptr<string> id{};
  shared_ptr<string> nlsLengthSemantics{};
  shared_ptr<string> ocpName{};
  shared_ptr<string> operatingSystem{};
  shared_ptr<string> owner{};
  shared_ptr<long> port{};
  shared_ptr<string> region{};
  shared_ptr<string> resourceOwner{};
  shared_ptr<string> timezone{};
  shared_ptr<string> username{};
  shared_ptr<string> version{};

  ListProjectsResponseBodyDataSinkConnectInfo() {}

  explicit ListProjectsResponseBodyDataSinkConnectInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (charset) {
      res["Charset"] = boost::any(*charset);
    }
    if (connExtraAttributes) {
      res["ConnExtraAttributes"] = boost::any(*connExtraAttributes);
    }
    if (connectionInfo) {
      res["ConnectionInfo"] = boost::any(*connectionInfo);
    }
    if (dbEngine) {
      res["DbEngine"] = boost::any(*dbEngine);
    }
    if (endpointId) {
      res["EndpointId"] = boost::any(*endpointId);
    }
    if (endpointName) {
      res["EndpointName"] = boost::any(*endpointName);
    }
    if (endpointSide) {
      res["EndpointSide"] = boost::any(*endpointSide);
    }
    if (host) {
      res["Host"] = boost::any(*host);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (nlsLengthSemantics) {
      res["NlsLengthSemantics"] = boost::any(*nlsLengthSemantics);
    }
    if (ocpName) {
      res["OcpName"] = boost::any(*ocpName);
    }
    if (operatingSystem) {
      res["OperatingSystem"] = boost::any(*operatingSystem);
    }
    if (owner) {
      res["Owner"] = boost::any(*owner);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (resourceOwner) {
      res["ResourceOwner"] = boost::any(*resourceOwner);
    }
    if (timezone) {
      res["Timezone"] = boost::any(*timezone);
    }
    if (username) {
      res["Username"] = boost::any(*username);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Charset") != m.end() && !m["Charset"].empty()) {
      charset = make_shared<string>(boost::any_cast<string>(m["Charset"]));
    }
    if (m.find("ConnExtraAttributes") != m.end() && !m["ConnExtraAttributes"].empty()) {
      connExtraAttributes = make_shared<boost::any>(boost::any_cast<boost::any>(m["ConnExtraAttributes"]));
    }
    if (m.find("ConnectionInfo") != m.end() && !m["ConnectionInfo"].empty()) {
      connectionInfo = make_shared<string>(boost::any_cast<string>(m["ConnectionInfo"]));
    }
    if (m.find("DbEngine") != m.end() && !m["DbEngine"].empty()) {
      dbEngine = make_shared<string>(boost::any_cast<string>(m["DbEngine"]));
    }
    if (m.find("EndpointId") != m.end() && !m["EndpointId"].empty()) {
      endpointId = make_shared<string>(boost::any_cast<string>(m["EndpointId"]));
    }
    if (m.find("EndpointName") != m.end() && !m["EndpointName"].empty()) {
      endpointName = make_shared<string>(boost::any_cast<string>(m["EndpointName"]));
    }
    if (m.find("EndpointSide") != m.end() && !m["EndpointSide"].empty()) {
      endpointSide = make_shared<string>(boost::any_cast<string>(m["EndpointSide"]));
    }
    if (m.find("Host") != m.end() && !m["Host"].empty()) {
      host = make_shared<string>(boost::any_cast<string>(m["Host"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("NlsLengthSemantics") != m.end() && !m["NlsLengthSemantics"].empty()) {
      nlsLengthSemantics = make_shared<string>(boost::any_cast<string>(m["NlsLengthSemantics"]));
    }
    if (m.find("OcpName") != m.end() && !m["OcpName"].empty()) {
      ocpName = make_shared<string>(boost::any_cast<string>(m["OcpName"]));
    }
    if (m.find("OperatingSystem") != m.end() && !m["OperatingSystem"].empty()) {
      operatingSystem = make_shared<string>(boost::any_cast<string>(m["OperatingSystem"]));
    }
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      owner = make_shared<string>(boost::any_cast<string>(m["Owner"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<long>(boost::any_cast<long>(m["Port"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("ResourceOwner") != m.end() && !m["ResourceOwner"].empty()) {
      resourceOwner = make_shared<string>(boost::any_cast<string>(m["ResourceOwner"]));
    }
    if (m.find("Timezone") != m.end() && !m["Timezone"].empty()) {
      timezone = make_shared<string>(boost::any_cast<string>(m["Timezone"]));
    }
    if (m.find("Username") != m.end() && !m["Username"].empty()) {
      username = make_shared<string>(boost::any_cast<string>(m["Username"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["Version"]));
    }
  }


  virtual ~ListProjectsResponseBodyDataSinkConnectInfo() = default;
};
class ListProjectsResponseBodyDataSourceConnectInfo : public Darabonba::Model {
public:
  shared_ptr<string> charset{};
  shared_ptr<boost::any> connExtraAttributes{};
  shared_ptr<string> connectionInfo{};
  shared_ptr<string> dbEngine{};
  shared_ptr<string> endpointId{};
  shared_ptr<string> endpointName{};
  shared_ptr<string> endpointSide{};
  shared_ptr<string> host{};
  shared_ptr<string> id{};
  shared_ptr<string> nlsLengthSemantics{};
  shared_ptr<string> ocpName{};
  shared_ptr<string> operatingSystem{};
  shared_ptr<string> owner{};
  shared_ptr<long> port{};
  shared_ptr<string> region{};
  shared_ptr<string> resourceOwner{};
  shared_ptr<string> timezone{};
  shared_ptr<string> username{};
  shared_ptr<string> version{};

  ListProjectsResponseBodyDataSourceConnectInfo() {}

  explicit ListProjectsResponseBodyDataSourceConnectInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (charset) {
      res["Charset"] = boost::any(*charset);
    }
    if (connExtraAttributes) {
      res["ConnExtraAttributes"] = boost::any(*connExtraAttributes);
    }
    if (connectionInfo) {
      res["ConnectionInfo"] = boost::any(*connectionInfo);
    }
    if (dbEngine) {
      res["DbEngine"] = boost::any(*dbEngine);
    }
    if (endpointId) {
      res["EndpointId"] = boost::any(*endpointId);
    }
    if (endpointName) {
      res["EndpointName"] = boost::any(*endpointName);
    }
    if (endpointSide) {
      res["EndpointSide"] = boost::any(*endpointSide);
    }
    if (host) {
      res["Host"] = boost::any(*host);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (nlsLengthSemantics) {
      res["NlsLengthSemantics"] = boost::any(*nlsLengthSemantics);
    }
    if (ocpName) {
      res["OcpName"] = boost::any(*ocpName);
    }
    if (operatingSystem) {
      res["OperatingSystem"] = boost::any(*operatingSystem);
    }
    if (owner) {
      res["Owner"] = boost::any(*owner);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (resourceOwner) {
      res["ResourceOwner"] = boost::any(*resourceOwner);
    }
    if (timezone) {
      res["Timezone"] = boost::any(*timezone);
    }
    if (username) {
      res["Username"] = boost::any(*username);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Charset") != m.end() && !m["Charset"].empty()) {
      charset = make_shared<string>(boost::any_cast<string>(m["Charset"]));
    }
    if (m.find("ConnExtraAttributes") != m.end() && !m["ConnExtraAttributes"].empty()) {
      connExtraAttributes = make_shared<boost::any>(boost::any_cast<boost::any>(m["ConnExtraAttributes"]));
    }
    if (m.find("ConnectionInfo") != m.end() && !m["ConnectionInfo"].empty()) {
      connectionInfo = make_shared<string>(boost::any_cast<string>(m["ConnectionInfo"]));
    }
    if (m.find("DbEngine") != m.end() && !m["DbEngine"].empty()) {
      dbEngine = make_shared<string>(boost::any_cast<string>(m["DbEngine"]));
    }
    if (m.find("EndpointId") != m.end() && !m["EndpointId"].empty()) {
      endpointId = make_shared<string>(boost::any_cast<string>(m["EndpointId"]));
    }
    if (m.find("EndpointName") != m.end() && !m["EndpointName"].empty()) {
      endpointName = make_shared<string>(boost::any_cast<string>(m["EndpointName"]));
    }
    if (m.find("EndpointSide") != m.end() && !m["EndpointSide"].empty()) {
      endpointSide = make_shared<string>(boost::any_cast<string>(m["EndpointSide"]));
    }
    if (m.find("Host") != m.end() && !m["Host"].empty()) {
      host = make_shared<string>(boost::any_cast<string>(m["Host"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("NlsLengthSemantics") != m.end() && !m["NlsLengthSemantics"].empty()) {
      nlsLengthSemantics = make_shared<string>(boost::any_cast<string>(m["NlsLengthSemantics"]));
    }
    if (m.find("OcpName") != m.end() && !m["OcpName"].empty()) {
      ocpName = make_shared<string>(boost::any_cast<string>(m["OcpName"]));
    }
    if (m.find("OperatingSystem") != m.end() && !m["OperatingSystem"].empty()) {
      operatingSystem = make_shared<string>(boost::any_cast<string>(m["OperatingSystem"]));
    }
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      owner = make_shared<string>(boost::any_cast<string>(m["Owner"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<long>(boost::any_cast<long>(m["Port"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("ResourceOwner") != m.end() && !m["ResourceOwner"].empty()) {
      resourceOwner = make_shared<string>(boost::any_cast<string>(m["ResourceOwner"]));
    }
    if (m.find("Timezone") != m.end() && !m["Timezone"].empty()) {
      timezone = make_shared<string>(boost::any_cast<string>(m["Timezone"]));
    }
    if (m.find("Username") != m.end() && !m["Username"].empty()) {
      username = make_shared<string>(boost::any_cast<string>(m["Username"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["Version"]));
    }
  }


  virtual ~ListProjectsResponseBodyDataSourceConnectInfo() = default;
};
class ListProjectsResponseBodyDataStepsExtraInfoErrorDetails : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<map<string, boost::any>> extraContext{};
  shared_ptr<string> level{};
  shared_ptr<string> message{};
  shared_ptr<map<string, string>> messageMcmsContext{};
  shared_ptr<string> messageMcmsKey{};
  shared_ptr<string> proposal{};
  shared_ptr<map<string, string>> proposalMcmsContext{};
  shared_ptr<string> proposalMcmsKey{};
  shared_ptr<string> reason{};
  shared_ptr<map<string, string>> reasonMcmsContext{};
  shared_ptr<string> reasonMcmsKey{};
  shared_ptr<boost::any> upstreamErrorDetail{};

  ListProjectsResponseBodyDataStepsExtraInfoErrorDetails() {}

  explicit ListProjectsResponseBodyDataStepsExtraInfoErrorDetails(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (extraContext) {
      res["ExtraContext"] = boost::any(*extraContext);
    }
    if (level) {
      res["Level"] = boost::any(*level);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (messageMcmsContext) {
      res["MessageMcmsContext"] = boost::any(*messageMcmsContext);
    }
    if (messageMcmsKey) {
      res["MessageMcmsKey"] = boost::any(*messageMcmsKey);
    }
    if (proposal) {
      res["Proposal"] = boost::any(*proposal);
    }
    if (proposalMcmsContext) {
      res["ProposalMcmsContext"] = boost::any(*proposalMcmsContext);
    }
    if (proposalMcmsKey) {
      res["ProposalMcmsKey"] = boost::any(*proposalMcmsKey);
    }
    if (reason) {
      res["Reason"] = boost::any(*reason);
    }
    if (reasonMcmsContext) {
      res["ReasonMcmsContext"] = boost::any(*reasonMcmsContext);
    }
    if (reasonMcmsKey) {
      res["ReasonMcmsKey"] = boost::any(*reasonMcmsKey);
    }
    if (upstreamErrorDetail) {
      res["UpstreamErrorDetail"] = boost::any(*upstreamErrorDetail);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ExtraContext") != m.end() && !m["ExtraContext"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["ExtraContext"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      extraContext = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<string>(boost::any_cast<string>(m["Level"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("MessageMcmsContext") != m.end() && !m["MessageMcmsContext"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["MessageMcmsContext"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      messageMcmsContext = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("MessageMcmsKey") != m.end() && !m["MessageMcmsKey"].empty()) {
      messageMcmsKey = make_shared<string>(boost::any_cast<string>(m["MessageMcmsKey"]));
    }
    if (m.find("Proposal") != m.end() && !m["Proposal"].empty()) {
      proposal = make_shared<string>(boost::any_cast<string>(m["Proposal"]));
    }
    if (m.find("ProposalMcmsContext") != m.end() && !m["ProposalMcmsContext"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["ProposalMcmsContext"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      proposalMcmsContext = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("ProposalMcmsKey") != m.end() && !m["ProposalMcmsKey"].empty()) {
      proposalMcmsKey = make_shared<string>(boost::any_cast<string>(m["ProposalMcmsKey"]));
    }
    if (m.find("Reason") != m.end() && !m["Reason"].empty()) {
      reason = make_shared<string>(boost::any_cast<string>(m["Reason"]));
    }
    if (m.find("ReasonMcmsContext") != m.end() && !m["ReasonMcmsContext"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["ReasonMcmsContext"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      reasonMcmsContext = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("ReasonMcmsKey") != m.end() && !m["ReasonMcmsKey"].empty()) {
      reasonMcmsKey = make_shared<string>(boost::any_cast<string>(m["ReasonMcmsKey"]));
    }
    if (m.find("UpstreamErrorDetail") != m.end() && !m["UpstreamErrorDetail"].empty()) {
      upstreamErrorDetail = make_shared<boost::any>(boost::any_cast<boost::any>(m["UpstreamErrorDetail"]));
    }
  }


  virtual ~ListProjectsResponseBodyDataStepsExtraInfoErrorDetails() = default;
};
class ListProjectsResponseBodyDataStepsExtraInfo : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<vector<ListProjectsResponseBodyDataStepsExtraInfoErrorDetails>> errorDetails{};
  shared_ptr<string> errorMsg{};
  shared_ptr<map<string, string>> errorParam{};
  shared_ptr<string> failedTime{};

  ListProjectsResponseBodyDataStepsExtraInfo() {}

  explicit ListProjectsResponseBodyDataStepsExtraInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorDetails) {
      vector<boost::any> temp1;
      for(auto item1:*errorDetails){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ErrorDetails"] = boost::any(temp1);
    }
    if (errorMsg) {
      res["ErrorMsg"] = boost::any(*errorMsg);
    }
    if (errorParam) {
      res["ErrorParam"] = boost::any(*errorParam);
    }
    if (failedTime) {
      res["FailedTime"] = boost::any(*failedTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorDetails") != m.end() && !m["ErrorDetails"].empty()) {
      if (typeid(vector<boost::any>) == m["ErrorDetails"].type()) {
        vector<ListProjectsResponseBodyDataStepsExtraInfoErrorDetails> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ErrorDetails"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListProjectsResponseBodyDataStepsExtraInfoErrorDetails model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        errorDetails = make_shared<vector<ListProjectsResponseBodyDataStepsExtraInfoErrorDetails>>(expect1);
      }
    }
    if (m.find("ErrorMsg") != m.end() && !m["ErrorMsg"].empty()) {
      errorMsg = make_shared<string>(boost::any_cast<string>(m["ErrorMsg"]));
    }
    if (m.find("ErrorParam") != m.end() && !m["ErrorParam"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["ErrorParam"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      errorParam = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("FailedTime") != m.end() && !m["FailedTime"].empty()) {
      failedTime = make_shared<string>(boost::any_cast<string>(m["FailedTime"]));
    }
  }


  virtual ~ListProjectsResponseBodyDataStepsExtraInfo() = default;
};
class ListProjectsResponseBodyDataSteps : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<ListProjectsResponseBodyDataStepsExtraInfo> extraInfo{};
  shared_ptr<string> finishTime{};
  shared_ptr<string> name{};
  shared_ptr<long> order{};
  shared_ptr<long> progress{};
  shared_ptr<string> startTime{};
  shared_ptr<string> status{};
  shared_ptr<map<string, boost::any>> stepInfo{};

  ListProjectsResponseBodyDataSteps() {}

  explicit ListProjectsResponseBodyDataSteps(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (extraInfo) {
      res["ExtraInfo"] = extraInfo ? boost::any(extraInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (finishTime) {
      res["FinishTime"] = boost::any(*finishTime);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (order) {
      res["Order"] = boost::any(*order);
    }
    if (progress) {
      res["Progress"] = boost::any(*progress);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (stepInfo) {
      res["StepInfo"] = boost::any(*stepInfo);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("ExtraInfo") != m.end() && !m["ExtraInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["ExtraInfo"].type()) {
        ListProjectsResponseBodyDataStepsExtraInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ExtraInfo"]));
        extraInfo = make_shared<ListProjectsResponseBodyDataStepsExtraInfo>(model1);
      }
    }
    if (m.find("FinishTime") != m.end() && !m["FinishTime"].empty()) {
      finishTime = make_shared<string>(boost::any_cast<string>(m["FinishTime"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Order") != m.end() && !m["Order"].empty()) {
      order = make_shared<long>(boost::any_cast<long>(m["Order"]));
    }
    if (m.find("Progress") != m.end() && !m["Progress"].empty()) {
      progress = make_shared<long>(boost::any_cast<long>(m["Progress"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("StepInfo") != m.end() && !m["StepInfo"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["StepInfo"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      stepInfo = make_shared<map<string, boost::any>>(toMap1);
    }
  }


  virtual ~ListProjectsResponseBodyDataSteps() = default;
};
class ListProjectsResponseBodyDataStructTransferConfig : public Darabonba::Model {
public:
  shared_ptr<string> byteCharConvertStrategy{};
  shared_ptr<bool> deferIndexCreation{};

  ListProjectsResponseBodyDataStructTransferConfig() {}

  explicit ListProjectsResponseBodyDataStructTransferConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (byteCharConvertStrategy) {
      res["ByteCharConvertStrategy"] = boost::any(*byteCharConvertStrategy);
    }
    if (deferIndexCreation) {
      res["DeferIndexCreation"] = boost::any(*deferIndexCreation);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ByteCharConvertStrategy") != m.end() && !m["ByteCharConvertStrategy"].empty()) {
      byteCharConvertStrategy = make_shared<string>(boost::any_cast<string>(m["ByteCharConvertStrategy"]));
    }
    if (m.find("DeferIndexCreation") != m.end() && !m["DeferIndexCreation"].empty()) {
      deferIndexCreation = make_shared<bool>(boost::any_cast<bool>(m["DeferIndexCreation"]));
    }
  }


  virtual ~ListProjectsResponseBodyDataStructTransferConfig() = default;
};
class ListProjectsResponseBodyDataTransferMapping : public Darabonba::Model {
public:
  shared_ptr<string> mode{};

  ListProjectsResponseBodyDataTransferMapping() {}

  explicit ListProjectsResponseBodyDataTransferMapping(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mode) {
      res["Mode"] = boost::any(*mode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Mode") != m.end() && !m["Mode"].empty()) {
      mode = make_shared<string>(boost::any_cast<string>(m["Mode"]));
    }
  }


  virtual ~ListProjectsResponseBodyDataTransferMapping() = default;
};
class ListProjectsResponseBodyDataWorkerGradeInfo : public Darabonba::Model {
public:
  shared_ptr<bool> autoRenewal{};
  shared_ptr<string> chargeType{};
  shared_ptr<string> destRegion{};
  shared_ptr<string> destType{};
  shared_ptr<string> endTime{};
  shared_ptr<bool> expired{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> grade{};
  shared_ptr<string> id{};
  shared_ptr<string> name{};
  shared_ptr<string> sourceRegion{};
  shared_ptr<string> sourceType{};
  shared_ptr<string> spec{};
  shared_ptr<string> specName{};

  ListProjectsResponseBodyDataWorkerGradeInfo() {}

  explicit ListProjectsResponseBodyDataWorkerGradeInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (autoRenewal) {
      res["AutoRenewal"] = boost::any(*autoRenewal);
    }
    if (chargeType) {
      res["ChargeType"] = boost::any(*chargeType);
    }
    if (destRegion) {
      res["DestRegion"] = boost::any(*destRegion);
    }
    if (destType) {
      res["DestType"] = boost::any(*destType);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (expired) {
      res["Expired"] = boost::any(*expired);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (grade) {
      res["Grade"] = boost::any(*grade);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (sourceRegion) {
      res["SourceRegion"] = boost::any(*sourceRegion);
    }
    if (sourceType) {
      res["SourceType"] = boost::any(*sourceType);
    }
    if (spec) {
      res["Spec"] = boost::any(*spec);
    }
    if (specName) {
      res["SpecName"] = boost::any(*specName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AutoRenewal") != m.end() && !m["AutoRenewal"].empty()) {
      autoRenewal = make_shared<bool>(boost::any_cast<bool>(m["AutoRenewal"]));
    }
    if (m.find("ChargeType") != m.end() && !m["ChargeType"].empty()) {
      chargeType = make_shared<string>(boost::any_cast<string>(m["ChargeType"]));
    }
    if (m.find("DestRegion") != m.end() && !m["DestRegion"].empty()) {
      destRegion = make_shared<string>(boost::any_cast<string>(m["DestRegion"]));
    }
    if (m.find("DestType") != m.end() && !m["DestType"].empty()) {
      destType = make_shared<string>(boost::any_cast<string>(m["DestType"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("Expired") != m.end() && !m["Expired"].empty()) {
      expired = make_shared<bool>(boost::any_cast<bool>(m["Expired"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["GmtCreate"]));
    }
    if (m.find("Grade") != m.end() && !m["Grade"].empty()) {
      grade = make_shared<string>(boost::any_cast<string>(m["Grade"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("SourceRegion") != m.end() && !m["SourceRegion"].empty()) {
      sourceRegion = make_shared<string>(boost::any_cast<string>(m["SourceRegion"]));
    }
    if (m.find("SourceType") != m.end() && !m["SourceType"].empty()) {
      sourceType = make_shared<string>(boost::any_cast<string>(m["SourceType"]));
    }
    if (m.find("Spec") != m.end() && !m["Spec"].empty()) {
      spec = make_shared<string>(boost::any_cast<string>(m["Spec"]));
    }
    if (m.find("SpecName") != m.end() && !m["SpecName"].empty()) {
      specName = make_shared<string>(boost::any_cast<string>(m["SpecName"]));
    }
  }


  virtual ~ListProjectsResponseBodyDataWorkerGradeInfo() = default;
};
class ListProjectsResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<ListProjectsResponseBodyDataAlarmStats> alarmStats{};
  shared_ptr<ListProjectsResponseBodyDataCommonTransferConfig> commonTransferConfig{};
  shared_ptr<string> destConnId{};
  shared_ptr<bool> enableFullTransfer{};
  shared_ptr<bool> enableFullVerify{};
  shared_ptr<bool> enableIncrTransfer{};
  shared_ptr<bool> enableIncrVerify{};
  shared_ptr<bool> enableReverseIncrTransfer{};
  shared_ptr<bool> enableStructTransfer{};
  shared_ptr<ListProjectsResponseBodyDataExtraInfo> extraInfo{};
  shared_ptr<ListProjectsResponseBodyDataFullTransferConfig> fullTransferConfig{};
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> gmtFinish{};
  shared_ptr<string> gmtModified{};
  shared_ptr<string> gmtStart{};
  shared_ptr<string> id{};
  shared_ptr<string> importance{};
  shared_ptr<ListProjectsResponseBodyDataIncrTransferConfig> incrTransferConfig{};
  shared_ptr<bool> isMerging{};
  shared_ptr<bool> isModifying{};
  shared_ptr<bool> isSubProject{};
  shared_ptr<vector<ListProjectsResponseBodyDataLabels>> labels{};
  shared_ptr<string> name{};
  shared_ptr<string> owner{};
  shared_ptr<ListProjectsResponseBodyDataSinkConnectInfo> sinkConnectInfo{};
  shared_ptr<string> sinkEndpointType{};
  shared_ptr<ListProjectsResponseBodyDataSourceConnectInfo> sourceConnectInfo{};
  shared_ptr<string> sourceEndpointType{};
  shared_ptr<string> status{};
  shared_ptr<vector<ListProjectsResponseBodyDataSteps>> steps{};
  shared_ptr<ListProjectsResponseBodyDataStructTransferConfig> structTransferConfig{};
  shared_ptr<ListProjectsResponseBodyDataTransferMapping> transferMapping{};
  shared_ptr<string> type{};
  shared_ptr<string> workerGradeId{};
  shared_ptr<ListProjectsResponseBodyDataWorkerGradeInfo> workerGradeInfo{};

  ListProjectsResponseBodyData() {}

  explicit ListProjectsResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alarmStats) {
      res["AlarmStats"] = alarmStats ? boost::any(alarmStats->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (commonTransferConfig) {
      res["CommonTransferConfig"] = commonTransferConfig ? boost::any(commonTransferConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (destConnId) {
      res["DestConnId"] = boost::any(*destConnId);
    }
    if (enableFullTransfer) {
      res["EnableFullTransfer"] = boost::any(*enableFullTransfer);
    }
    if (enableFullVerify) {
      res["EnableFullVerify"] = boost::any(*enableFullVerify);
    }
    if (enableIncrTransfer) {
      res["EnableIncrTransfer"] = boost::any(*enableIncrTransfer);
    }
    if (enableIncrVerify) {
      res["EnableIncrVerify"] = boost::any(*enableIncrVerify);
    }
    if (enableReverseIncrTransfer) {
      res["EnableReverseIncrTransfer"] = boost::any(*enableReverseIncrTransfer);
    }
    if (enableStructTransfer) {
      res["EnableStructTransfer"] = boost::any(*enableStructTransfer);
    }
    if (extraInfo) {
      res["ExtraInfo"] = extraInfo ? boost::any(extraInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (fullTransferConfig) {
      res["FullTransferConfig"] = fullTransferConfig ? boost::any(fullTransferConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtFinish) {
      res["GmtFinish"] = boost::any(*gmtFinish);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (gmtStart) {
      res["GmtStart"] = boost::any(*gmtStart);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (importance) {
      res["Importance"] = boost::any(*importance);
    }
    if (incrTransferConfig) {
      res["IncrTransferConfig"] = incrTransferConfig ? boost::any(incrTransferConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (isMerging) {
      res["IsMerging"] = boost::any(*isMerging);
    }
    if (isModifying) {
      res["IsModifying"] = boost::any(*isModifying);
    }
    if (isSubProject) {
      res["IsSubProject"] = boost::any(*isSubProject);
    }
    if (labels) {
      vector<boost::any> temp1;
      for(auto item1:*labels){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Labels"] = boost::any(temp1);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (owner) {
      res["Owner"] = boost::any(*owner);
    }
    if (sinkConnectInfo) {
      res["SinkConnectInfo"] = sinkConnectInfo ? boost::any(sinkConnectInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (sinkEndpointType) {
      res["SinkEndpointType"] = boost::any(*sinkEndpointType);
    }
    if (sourceConnectInfo) {
      res["SourceConnectInfo"] = sourceConnectInfo ? boost::any(sourceConnectInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (sourceEndpointType) {
      res["SourceEndpointType"] = boost::any(*sourceEndpointType);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (steps) {
      vector<boost::any> temp1;
      for(auto item1:*steps){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Steps"] = boost::any(temp1);
    }
    if (structTransferConfig) {
      res["StructTransferConfig"] = structTransferConfig ? boost::any(structTransferConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (transferMapping) {
      res["TransferMapping"] = transferMapping ? boost::any(transferMapping->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (workerGradeId) {
      res["WorkerGradeId"] = boost::any(*workerGradeId);
    }
    if (workerGradeInfo) {
      res["WorkerGradeInfo"] = workerGradeInfo ? boost::any(workerGradeInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlarmStats") != m.end() && !m["AlarmStats"].empty()) {
      if (typeid(map<string, boost::any>) == m["AlarmStats"].type()) {
        ListProjectsResponseBodyDataAlarmStats model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AlarmStats"]));
        alarmStats = make_shared<ListProjectsResponseBodyDataAlarmStats>(model1);
      }
    }
    if (m.find("CommonTransferConfig") != m.end() && !m["CommonTransferConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["CommonTransferConfig"].type()) {
        ListProjectsResponseBodyDataCommonTransferConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CommonTransferConfig"]));
        commonTransferConfig = make_shared<ListProjectsResponseBodyDataCommonTransferConfig>(model1);
      }
    }
    if (m.find("DestConnId") != m.end() && !m["DestConnId"].empty()) {
      destConnId = make_shared<string>(boost::any_cast<string>(m["DestConnId"]));
    }
    if (m.find("EnableFullTransfer") != m.end() && !m["EnableFullTransfer"].empty()) {
      enableFullTransfer = make_shared<bool>(boost::any_cast<bool>(m["EnableFullTransfer"]));
    }
    if (m.find("EnableFullVerify") != m.end() && !m["EnableFullVerify"].empty()) {
      enableFullVerify = make_shared<bool>(boost::any_cast<bool>(m["EnableFullVerify"]));
    }
    if (m.find("EnableIncrTransfer") != m.end() && !m["EnableIncrTransfer"].empty()) {
      enableIncrTransfer = make_shared<bool>(boost::any_cast<bool>(m["EnableIncrTransfer"]));
    }
    if (m.find("EnableIncrVerify") != m.end() && !m["EnableIncrVerify"].empty()) {
      enableIncrVerify = make_shared<bool>(boost::any_cast<bool>(m["EnableIncrVerify"]));
    }
    if (m.find("EnableReverseIncrTransfer") != m.end() && !m["EnableReverseIncrTransfer"].empty()) {
      enableReverseIncrTransfer = make_shared<bool>(boost::any_cast<bool>(m["EnableReverseIncrTransfer"]));
    }
    if (m.find("EnableStructTransfer") != m.end() && !m["EnableStructTransfer"].empty()) {
      enableStructTransfer = make_shared<bool>(boost::any_cast<bool>(m["EnableStructTransfer"]));
    }
    if (m.find("ExtraInfo") != m.end() && !m["ExtraInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["ExtraInfo"].type()) {
        ListProjectsResponseBodyDataExtraInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ExtraInfo"]));
        extraInfo = make_shared<ListProjectsResponseBodyDataExtraInfo>(model1);
      }
    }
    if (m.find("FullTransferConfig") != m.end() && !m["FullTransferConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["FullTransferConfig"].type()) {
        ListProjectsResponseBodyDataFullTransferConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FullTransferConfig"]));
        fullTransferConfig = make_shared<ListProjectsResponseBodyDataFullTransferConfig>(model1);
      }
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["GmtCreate"]));
    }
    if (m.find("GmtFinish") != m.end() && !m["GmtFinish"].empty()) {
      gmtFinish = make_shared<string>(boost::any_cast<string>(m["GmtFinish"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<string>(boost::any_cast<string>(m["GmtModified"]));
    }
    if (m.find("GmtStart") != m.end() && !m["GmtStart"].empty()) {
      gmtStart = make_shared<string>(boost::any_cast<string>(m["GmtStart"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Importance") != m.end() && !m["Importance"].empty()) {
      importance = make_shared<string>(boost::any_cast<string>(m["Importance"]));
    }
    if (m.find("IncrTransferConfig") != m.end() && !m["IncrTransferConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["IncrTransferConfig"].type()) {
        ListProjectsResponseBodyDataIncrTransferConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["IncrTransferConfig"]));
        incrTransferConfig = make_shared<ListProjectsResponseBodyDataIncrTransferConfig>(model1);
      }
    }
    if (m.find("IsMerging") != m.end() && !m["IsMerging"].empty()) {
      isMerging = make_shared<bool>(boost::any_cast<bool>(m["IsMerging"]));
    }
    if (m.find("IsModifying") != m.end() && !m["IsModifying"].empty()) {
      isModifying = make_shared<bool>(boost::any_cast<bool>(m["IsModifying"]));
    }
    if (m.find("IsSubProject") != m.end() && !m["IsSubProject"].empty()) {
      isSubProject = make_shared<bool>(boost::any_cast<bool>(m["IsSubProject"]));
    }
    if (m.find("Labels") != m.end() && !m["Labels"].empty()) {
      if (typeid(vector<boost::any>) == m["Labels"].type()) {
        vector<ListProjectsResponseBodyDataLabels> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Labels"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListProjectsResponseBodyDataLabels model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        labels = make_shared<vector<ListProjectsResponseBodyDataLabels>>(expect1);
      }
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Owner") != m.end() && !m["Owner"].empty()) {
      owner = make_shared<string>(boost::any_cast<string>(m["Owner"]));
    }
    if (m.find("SinkConnectInfo") != m.end() && !m["SinkConnectInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["SinkConnectInfo"].type()) {
        ListProjectsResponseBodyDataSinkConnectInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SinkConnectInfo"]));
        sinkConnectInfo = make_shared<ListProjectsResponseBodyDataSinkConnectInfo>(model1);
      }
    }
    if (m.find("SinkEndpointType") != m.end() && !m["SinkEndpointType"].empty()) {
      sinkEndpointType = make_shared<string>(boost::any_cast<string>(m["SinkEndpointType"]));
    }
    if (m.find("SourceConnectInfo") != m.end() && !m["SourceConnectInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["SourceConnectInfo"].type()) {
        ListProjectsResponseBodyDataSourceConnectInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SourceConnectInfo"]));
        sourceConnectInfo = make_shared<ListProjectsResponseBodyDataSourceConnectInfo>(model1);
      }
    }
    if (m.find("SourceEndpointType") != m.end() && !m["SourceEndpointType"].empty()) {
      sourceEndpointType = make_shared<string>(boost::any_cast<string>(m["SourceEndpointType"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Steps") != m.end() && !m["Steps"].empty()) {
      if (typeid(vector<boost::any>) == m["Steps"].type()) {
        vector<ListProjectsResponseBodyDataSteps> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Steps"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListProjectsResponseBodyDataSteps model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        steps = make_shared<vector<ListProjectsResponseBodyDataSteps>>(expect1);
      }
    }
    if (m.find("StructTransferConfig") != m.end() && !m["StructTransferConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["StructTransferConfig"].type()) {
        ListProjectsResponseBodyDataStructTransferConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["StructTransferConfig"]));
        structTransferConfig = make_shared<ListProjectsResponseBodyDataStructTransferConfig>(model1);
      }
    }
    if (m.find("TransferMapping") != m.end() && !m["TransferMapping"].empty()) {
      if (typeid(map<string, boost::any>) == m["TransferMapping"].type()) {
        ListProjectsResponseBodyDataTransferMapping model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TransferMapping"]));
        transferMapping = make_shared<ListProjectsResponseBodyDataTransferMapping>(model1);
      }
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("WorkerGradeId") != m.end() && !m["WorkerGradeId"].empty()) {
      workerGradeId = make_shared<string>(boost::any_cast<string>(m["WorkerGradeId"]));
    }
    if (m.find("WorkerGradeInfo") != m.end() && !m["WorkerGradeInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["WorkerGradeInfo"].type()) {
        ListProjectsResponseBodyDataWorkerGradeInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["WorkerGradeInfo"]));
        workerGradeInfo = make_shared<ListProjectsResponseBodyDataWorkerGradeInfo>(model1);
      }
    }
  }


  virtual ~ListProjectsResponseBodyData() = default;
};
class ListProjectsResponseBodyErrorDetail : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<map<string, boost::any>> extraContext{};
  shared_ptr<string> level{};
  shared_ptr<string> message{};
  shared_ptr<map<string, string>> messageMcmsContext{};
  shared_ptr<string> messageMcmsKey{};
  shared_ptr<string> proposal{};
  shared_ptr<map<string, string>> proposalMcmsContext{};
  shared_ptr<string> proposalMcmsKey{};
  shared_ptr<string> reason{};
  shared_ptr<map<string, string>> reasonMcmsContext{};
  shared_ptr<string> reasonMcmsKey{};
  shared_ptr<boost::any> upstreamErrorDetail{};

  ListProjectsResponseBodyErrorDetail() {}

  explicit ListProjectsResponseBodyErrorDetail(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (extraContext) {
      res["ExtraContext"] = boost::any(*extraContext);
    }
    if (level) {
      res["Level"] = boost::any(*level);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (messageMcmsContext) {
      res["MessageMcmsContext"] = boost::any(*messageMcmsContext);
    }
    if (messageMcmsKey) {
      res["MessageMcmsKey"] = boost::any(*messageMcmsKey);
    }
    if (proposal) {
      res["Proposal"] = boost::any(*proposal);
    }
    if (proposalMcmsContext) {
      res["ProposalMcmsContext"] = boost::any(*proposalMcmsContext);
    }
    if (proposalMcmsKey) {
      res["ProposalMcmsKey"] = boost::any(*proposalMcmsKey);
    }
    if (reason) {
      res["Reason"] = boost::any(*reason);
    }
    if (reasonMcmsContext) {
      res["ReasonMcmsContext"] = boost::any(*reasonMcmsContext);
    }
    if (reasonMcmsKey) {
      res["ReasonMcmsKey"] = boost::any(*reasonMcmsKey);
    }
    if (upstreamErrorDetail) {
      res["UpstreamErrorDetail"] = boost::any(*upstreamErrorDetail);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ExtraContext") != m.end() && !m["ExtraContext"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["ExtraContext"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      extraContext = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<string>(boost::any_cast<string>(m["Level"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("MessageMcmsContext") != m.end() && !m["MessageMcmsContext"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["MessageMcmsContext"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      messageMcmsContext = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("MessageMcmsKey") != m.end() && !m["MessageMcmsKey"].empty()) {
      messageMcmsKey = make_shared<string>(boost::any_cast<string>(m["MessageMcmsKey"]));
    }
    if (m.find("Proposal") != m.end() && !m["Proposal"].empty()) {
      proposal = make_shared<string>(boost::any_cast<string>(m["Proposal"]));
    }
    if (m.find("ProposalMcmsContext") != m.end() && !m["ProposalMcmsContext"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["ProposalMcmsContext"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      proposalMcmsContext = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("ProposalMcmsKey") != m.end() && !m["ProposalMcmsKey"].empty()) {
      proposalMcmsKey = make_shared<string>(boost::any_cast<string>(m["ProposalMcmsKey"]));
    }
    if (m.find("Reason") != m.end() && !m["Reason"].empty()) {
      reason = make_shared<string>(boost::any_cast<string>(m["Reason"]));
    }
    if (m.find("ReasonMcmsContext") != m.end() && !m["ReasonMcmsContext"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["ReasonMcmsContext"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      reasonMcmsContext = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("ReasonMcmsKey") != m.end() && !m["ReasonMcmsKey"].empty()) {
      reasonMcmsKey = make_shared<string>(boost::any_cast<string>(m["ReasonMcmsKey"]));
    }
    if (m.find("UpstreamErrorDetail") != m.end() && !m["UpstreamErrorDetail"].empty()) {
      upstreamErrorDetail = make_shared<boost::any>(boost::any_cast<boost::any>(m["UpstreamErrorDetail"]));
    }
  }


  virtual ~ListProjectsResponseBodyErrorDetail() = default;
};
class ListProjectsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> advice{};
  shared_ptr<string> code{};
  shared_ptr<string> cost{};
  shared_ptr<vector<ListProjectsResponseBodyData>> data{};
  shared_ptr<ListProjectsResponseBodyErrorDetail> errorDetail{};
  shared_ptr<string> message{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<long> totalCount{};

  ListProjectsResponseBody() {}

  explicit ListProjectsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (advice) {
      res["Advice"] = boost::any(*advice);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (cost) {
      res["Cost"] = boost::any(*cost);
    }
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (errorDetail) {
      res["ErrorDetail"] = errorDetail ? boost::any(errorDetail->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Advice") != m.end() && !m["Advice"].empty()) {
      advice = make_shared<string>(boost::any_cast<string>(m["Advice"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Cost") != m.end() && !m["Cost"].empty()) {
      cost = make_shared<string>(boost::any_cast<string>(m["Cost"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<ListProjectsResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListProjectsResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<ListProjectsResponseBodyData>>(expect1);
      }
    }
    if (m.find("ErrorDetail") != m.end() && !m["ErrorDetail"].empty()) {
      if (typeid(map<string, boost::any>) == m["ErrorDetail"].type()) {
        ListProjectsResponseBodyErrorDetail model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ErrorDetail"]));
        errorDetail = make_shared<ListProjectsResponseBodyErrorDetail>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListProjectsResponseBody() = default;
};
class ListProjectsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListProjectsResponseBody> body{};

  ListProjectsResponse() {}

  explicit ListProjectsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListProjectsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListProjectsResponseBody>(model1);
      }
    }
  }


  virtual ~ListProjectsResponse() = default;
};
class ListWorkerInstancesRequest : public Darabonba::Model {
public:
  shared_ptr<string> destType{};
  shared_ptr<string> instanceName{};
  shared_ptr<bool> onlyBindable{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> sourceType{};
  shared_ptr<vector<string>> specs{};

  ListWorkerInstancesRequest() {}

  explicit ListWorkerInstancesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (destType) {
      res["DestType"] = boost::any(*destType);
    }
    if (instanceName) {
      res["InstanceName"] = boost::any(*instanceName);
    }
    if (onlyBindable) {
      res["OnlyBindable"] = boost::any(*onlyBindable);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (sourceType) {
      res["SourceType"] = boost::any(*sourceType);
    }
    if (specs) {
      res["Specs"] = boost::any(*specs);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DestType") != m.end() && !m["DestType"].empty()) {
      destType = make_shared<string>(boost::any_cast<string>(m["DestType"]));
    }
    if (m.find("InstanceName") != m.end() && !m["InstanceName"].empty()) {
      instanceName = make_shared<string>(boost::any_cast<string>(m["InstanceName"]));
    }
    if (m.find("OnlyBindable") != m.end() && !m["OnlyBindable"].empty()) {
      onlyBindable = make_shared<bool>(boost::any_cast<bool>(m["OnlyBindable"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SourceType") != m.end() && !m["SourceType"].empty()) {
      sourceType = make_shared<string>(boost::any_cast<string>(m["SourceType"]));
    }
    if (m.find("Specs") != m.end() && !m["Specs"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Specs"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Specs"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      specs = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ListWorkerInstancesRequest() = default;
};
class ListWorkerInstancesShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> destType{};
  shared_ptr<string> instanceName{};
  shared_ptr<bool> onlyBindable{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> sourceType{};
  shared_ptr<string> specsShrink{};

  ListWorkerInstancesShrinkRequest() {}

  explicit ListWorkerInstancesShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (destType) {
      res["DestType"] = boost::any(*destType);
    }
    if (instanceName) {
      res["InstanceName"] = boost::any(*instanceName);
    }
    if (onlyBindable) {
      res["OnlyBindable"] = boost::any(*onlyBindable);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (sourceType) {
      res["SourceType"] = boost::any(*sourceType);
    }
    if (specsShrink) {
      res["Specs"] = boost::any(*specsShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DestType") != m.end() && !m["DestType"].empty()) {
      destType = make_shared<string>(boost::any_cast<string>(m["DestType"]));
    }
    if (m.find("InstanceName") != m.end() && !m["InstanceName"].empty()) {
      instanceName = make_shared<string>(boost::any_cast<string>(m["InstanceName"]));
    }
    if (m.find("OnlyBindable") != m.end() && !m["OnlyBindable"].empty()) {
      onlyBindable = make_shared<bool>(boost::any_cast<bool>(m["OnlyBindable"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SourceType") != m.end() && !m["SourceType"].empty()) {
      sourceType = make_shared<string>(boost::any_cast<string>(m["SourceType"]));
    }
    if (m.find("Specs") != m.end() && !m["Specs"].empty()) {
      specsShrink = make_shared<string>(boost::any_cast<string>(m["Specs"]));
    }
  }


  virtual ~ListWorkerInstancesShrinkRequest() = default;
};
class ListWorkerInstancesResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> gmtCreate{};
  shared_ptr<string> id{};
  shared_ptr<string> name{};
  shared_ptr<string> projectId{};
  shared_ptr<string> projectName{};
  shared_ptr<string> projectType{};
  shared_ptr<string> region{};
  shared_ptr<string> spec{};
  shared_ptr<string> status{};

  ListWorkerInstancesResponseBodyData() {}

  explicit ListWorkerInstancesResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (projectType) {
      res["ProjectType"] = boost::any(*projectType);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    if (spec) {
      res["Spec"] = boost::any(*spec);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<string>(boost::any_cast<string>(m["GmtCreate"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("ProjectType") != m.end() && !m["ProjectType"].empty()) {
      projectType = make_shared<string>(boost::any_cast<string>(m["ProjectType"]));
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
    if (m.find("Spec") != m.end() && !m["Spec"].empty()) {
      spec = make_shared<string>(boost::any_cast<string>(m["Spec"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~ListWorkerInstancesResponseBodyData() = default;
};
class ListWorkerInstancesResponseBodyErrorDetail : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<map<string, boost::any>> extraContext{};
  shared_ptr<string> level{};
  shared_ptr<string> message{};
  shared_ptr<map<string, string>> messageMcmsContext{};
  shared_ptr<string> messageMcmsKey{};
  shared_ptr<string> proposal{};
  shared_ptr<map<string, string>> proposalMcmsContext{};
  shared_ptr<string> proposalMcmsKey{};
  shared_ptr<string> reason{};
  shared_ptr<map<string, string>> reasonMcmsContext{};
  shared_ptr<string> reasonMcmsKey{};
  shared_ptr<boost::any> upstreamErrorDetail{};

  ListWorkerInstancesResponseBodyErrorDetail() {}

  explicit ListWorkerInstancesResponseBodyErrorDetail(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (extraContext) {
      res["ExtraContext"] = boost::any(*extraContext);
    }
    if (level) {
      res["Level"] = boost::any(*level);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (messageMcmsContext) {
      res["MessageMcmsContext"] = boost::any(*messageMcmsContext);
    }
    if (messageMcmsKey) {
      res["MessageMcmsKey"] = boost::any(*messageMcmsKey);
    }
    if (proposal) {
      res["Proposal"] = boost::any(*proposal);
    }
    if (proposalMcmsContext) {
      res["ProposalMcmsContext"] = boost::any(*proposalMcmsContext);
    }
    if (proposalMcmsKey) {
      res["ProposalMcmsKey"] = boost::any(*proposalMcmsKey);
    }
    if (reason) {
      res["Reason"] = boost::any(*reason);
    }
    if (reasonMcmsContext) {
      res["ReasonMcmsContext"] = boost::any(*reasonMcmsContext);
    }
    if (reasonMcmsKey) {
      res["ReasonMcmsKey"] = boost::any(*reasonMcmsKey);
    }
    if (upstreamErrorDetail) {
      res["UpstreamErrorDetail"] = boost::any(*upstreamErrorDetail);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ExtraContext") != m.end() && !m["ExtraContext"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["ExtraContext"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      extraContext = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<string>(boost::any_cast<string>(m["Level"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("MessageMcmsContext") != m.end() && !m["MessageMcmsContext"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["MessageMcmsContext"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      messageMcmsContext = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("MessageMcmsKey") != m.end() && !m["MessageMcmsKey"].empty()) {
      messageMcmsKey = make_shared<string>(boost::any_cast<string>(m["MessageMcmsKey"]));
    }
    if (m.find("Proposal") != m.end() && !m["Proposal"].empty()) {
      proposal = make_shared<string>(boost::any_cast<string>(m["Proposal"]));
    }
    if (m.find("ProposalMcmsContext") != m.end() && !m["ProposalMcmsContext"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["ProposalMcmsContext"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      proposalMcmsContext = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("ProposalMcmsKey") != m.end() && !m["ProposalMcmsKey"].empty()) {
      proposalMcmsKey = make_shared<string>(boost::any_cast<string>(m["ProposalMcmsKey"]));
    }
    if (m.find("Reason") != m.end() && !m["Reason"].empty()) {
      reason = make_shared<string>(boost::any_cast<string>(m["Reason"]));
    }
    if (m.find("ReasonMcmsContext") != m.end() && !m["ReasonMcmsContext"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["ReasonMcmsContext"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      reasonMcmsContext = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("ReasonMcmsKey") != m.end() && !m["ReasonMcmsKey"].empty()) {
      reasonMcmsKey = make_shared<string>(boost::any_cast<string>(m["ReasonMcmsKey"]));
    }
    if (m.find("UpstreamErrorDetail") != m.end() && !m["UpstreamErrorDetail"].empty()) {
      upstreamErrorDetail = make_shared<boost::any>(boost::any_cast<boost::any>(m["UpstreamErrorDetail"]));
    }
  }


  virtual ~ListWorkerInstancesResponseBodyErrorDetail() = default;
};
class ListWorkerInstancesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> advice{};
  shared_ptr<string> code{};
  shared_ptr<string> cost{};
  shared_ptr<vector<ListWorkerInstancesResponseBodyData>> data{};
  shared_ptr<ListWorkerInstancesResponseBodyErrorDetail> errorDetail{};
  shared_ptr<string> message{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<long> totalCount{};

  ListWorkerInstancesResponseBody() {}

  explicit ListWorkerInstancesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (advice) {
      res["Advice"] = boost::any(*advice);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (cost) {
      res["Cost"] = boost::any(*cost);
    }
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (errorDetail) {
      res["ErrorDetail"] = errorDetail ? boost::any(errorDetail->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Advice") != m.end() && !m["Advice"].empty()) {
      advice = make_shared<string>(boost::any_cast<string>(m["Advice"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Cost") != m.end() && !m["Cost"].empty()) {
      cost = make_shared<string>(boost::any_cast<string>(m["Cost"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<ListWorkerInstancesResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListWorkerInstancesResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<ListWorkerInstancesResponseBodyData>>(expect1);
      }
    }
    if (m.find("ErrorDetail") != m.end() && !m["ErrorDetail"].empty()) {
      if (typeid(map<string, boost::any>) == m["ErrorDetail"].type()) {
        ListWorkerInstancesResponseBodyErrorDetail model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ErrorDetail"]));
        errorDetail = make_shared<ListWorkerInstancesResponseBodyErrorDetail>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListWorkerInstancesResponseBody() = default;
};
class ListWorkerInstancesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListWorkerInstancesResponseBody> body{};

  ListWorkerInstancesResponse() {}

  explicit ListWorkerInstancesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListWorkerInstancesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListWorkerInstancesResponseBody>(model1);
      }
    }
  }


  virtual ~ListWorkerInstancesResponse() = default;
};
class ModifyDatabaseDescriptionRequest : public Darabonba::Model {
public:
  shared_ptr<string> databaseName{};
  shared_ptr<string> description{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> tenantId{};

  ModifyDatabaseDescriptionRequest() {}

  explicit ModifyDatabaseDescriptionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (databaseName) {
      res["DatabaseName"] = boost::any(*databaseName);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DatabaseName") != m.end() && !m["DatabaseName"].empty()) {
      databaseName = make_shared<string>(boost::any_cast<string>(m["DatabaseName"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["TenantId"]));
    }
  }


  virtual ~ModifyDatabaseDescriptionRequest() = default;
};
class ModifyDatabaseDescriptionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyDatabaseDescriptionResponseBody() {}

  explicit ModifyDatabaseDescriptionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyDatabaseDescriptionResponseBody() = default;
};
class ModifyDatabaseDescriptionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyDatabaseDescriptionResponseBody> body{};

  ModifyDatabaseDescriptionResponse() {}

  explicit ModifyDatabaseDescriptionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyDatabaseDescriptionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyDatabaseDescriptionResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyDatabaseDescriptionResponse() = default;
};
class ModifyDatabaseUserRolesRequest : public Darabonba::Model {
public:
  shared_ptr<string> databaseName{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> tenantId{};
  shared_ptr<string> users{};

  ModifyDatabaseUserRolesRequest() {}

  explicit ModifyDatabaseUserRolesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (databaseName) {
      res["DatabaseName"] = boost::any(*databaseName);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    if (users) {
      res["Users"] = boost::any(*users);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DatabaseName") != m.end() && !m["DatabaseName"].empty()) {
      databaseName = make_shared<string>(boost::any_cast<string>(m["DatabaseName"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["TenantId"]));
    }
    if (m.find("Users") != m.end() && !m["Users"].empty()) {
      users = make_shared<string>(boost::any_cast<string>(m["Users"]));
    }
  }


  virtual ~ModifyDatabaseUserRolesRequest() = default;
};
class ModifyDatabaseUserRolesResponseBodyTenantUserUsers : public Darabonba::Model {
public:
  shared_ptr<string> role{};
  shared_ptr<string> userName{};

  ModifyDatabaseUserRolesResponseBodyTenantUserUsers() {}

  explicit ModifyDatabaseUserRolesResponseBodyTenantUserUsers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (role) {
      res["Role"] = boost::any(*role);
    }
    if (userName) {
      res["UserName"] = boost::any(*userName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Role") != m.end() && !m["Role"].empty()) {
      role = make_shared<string>(boost::any_cast<string>(m["Role"]));
    }
    if (m.find("UserName") != m.end() && !m["UserName"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["UserName"]));
    }
  }


  virtual ~ModifyDatabaseUserRolesResponseBodyTenantUserUsers() = default;
};
class ModifyDatabaseUserRolesResponseBodyTenantUser : public Darabonba::Model {
public:
  shared_ptr<string> databaseName{};
  shared_ptr<string> tenantId{};
  shared_ptr<vector<ModifyDatabaseUserRolesResponseBodyTenantUserUsers>> users{};

  ModifyDatabaseUserRolesResponseBodyTenantUser() {}

  explicit ModifyDatabaseUserRolesResponseBodyTenantUser(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (databaseName) {
      res["DatabaseName"] = boost::any(*databaseName);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    if (users) {
      vector<boost::any> temp1;
      for(auto item1:*users){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Users"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DatabaseName") != m.end() && !m["DatabaseName"].empty()) {
      databaseName = make_shared<string>(boost::any_cast<string>(m["DatabaseName"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["TenantId"]));
    }
    if (m.find("Users") != m.end() && !m["Users"].empty()) {
      if (typeid(vector<boost::any>) == m["Users"].type()) {
        vector<ModifyDatabaseUserRolesResponseBodyTenantUserUsers> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Users"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ModifyDatabaseUserRolesResponseBodyTenantUserUsers model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        users = make_shared<vector<ModifyDatabaseUserRolesResponseBodyTenantUserUsers>>(expect1);
      }
    }
  }


  virtual ~ModifyDatabaseUserRolesResponseBodyTenantUser() = default;
};
class ModifyDatabaseUserRolesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<ModifyDatabaseUserRolesResponseBodyTenantUser> tenantUser{};

  ModifyDatabaseUserRolesResponseBody() {}

  explicit ModifyDatabaseUserRolesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (tenantUser) {
      res["TenantUser"] = tenantUser ? boost::any(tenantUser->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TenantUser") != m.end() && !m["TenantUser"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantUser"].type()) {
        ModifyDatabaseUserRolesResponseBodyTenantUser model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantUser"]));
        tenantUser = make_shared<ModifyDatabaseUserRolesResponseBodyTenantUser>(model1);
      }
    }
  }


  virtual ~ModifyDatabaseUserRolesResponseBody() = default;
};
class ModifyDatabaseUserRolesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyDatabaseUserRolesResponseBody> body{};

  ModifyDatabaseUserRolesResponse() {}

  explicit ModifyDatabaseUserRolesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyDatabaseUserRolesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyDatabaseUserRolesResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyDatabaseUserRolesResponse() = default;
};
class ModifyInstanceNameRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> instanceName{};

  ModifyInstanceNameRequest() {}

  explicit ModifyInstanceNameRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (instanceName) {
      res["InstanceName"] = boost::any(*instanceName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("InstanceName") != m.end() && !m["InstanceName"].empty()) {
      instanceName = make_shared<string>(boost::any_cast<string>(m["InstanceName"]));
    }
  }


  virtual ~ModifyInstanceNameRequest() = default;
};
class ModifyInstanceNameResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyInstanceNameResponseBody() {}

  explicit ModifyInstanceNameResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyInstanceNameResponseBody() = default;
};
class ModifyInstanceNameResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyInstanceNameResponseBody> body{};

  ModifyInstanceNameResponse() {}

  explicit ModifyInstanceNameResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyInstanceNameResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyInstanceNameResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyInstanceNameResponse() = default;
};
class ModifyInstanceNodeNumRequest : public Darabonba::Model {
public:
  shared_ptr<bool> dryRun{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> nodeNum{};

  ModifyInstanceNodeNumRequest() {}

  explicit ModifyInstanceNodeNumRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dryRun) {
      res["DryRun"] = boost::any(*dryRun);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (nodeNum) {
      res["NodeNum"] = boost::any(*nodeNum);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DryRun") != m.end() && !m["DryRun"].empty()) {
      dryRun = make_shared<bool>(boost::any_cast<bool>(m["DryRun"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("NodeNum") != m.end() && !m["NodeNum"].empty()) {
      nodeNum = make_shared<string>(boost::any_cast<string>(m["NodeNum"]));
    }
  }


  virtual ~ModifyInstanceNodeNumRequest() = default;
};
class ModifyInstanceNodeNumResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<bool> dryRunResult{};
  shared_ptr<string> orderId{};

  ModifyInstanceNodeNumResponseBodyData() {}

  explicit ModifyInstanceNodeNumResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dryRunResult) {
      res["DryRunResult"] = boost::any(*dryRunResult);
    }
    if (orderId) {
      res["OrderId"] = boost::any(*orderId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DryRunResult") != m.end() && !m["DryRunResult"].empty()) {
      dryRunResult = make_shared<bool>(boost::any_cast<bool>(m["DryRunResult"]));
    }
    if (m.find("OrderId") != m.end() && !m["OrderId"].empty()) {
      orderId = make_shared<string>(boost::any_cast<string>(m["OrderId"]));
    }
  }


  virtual ~ModifyInstanceNodeNumResponseBodyData() = default;
};
class ModifyInstanceNodeNumResponseBody : public Darabonba::Model {
public:
  shared_ptr<ModifyInstanceNodeNumResponseBodyData> data{};
  shared_ptr<string> requestId{};

  ModifyInstanceNodeNumResponseBody() {}

  explicit ModifyInstanceNodeNumResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ModifyInstanceNodeNumResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ModifyInstanceNodeNumResponseBodyData>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyInstanceNodeNumResponseBody() = default;
};
class ModifyInstanceNodeNumResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyInstanceNodeNumResponseBody> body{};

  ModifyInstanceNodeNumResponse() {}

  explicit ModifyInstanceNodeNumResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyInstanceNodeNumResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyInstanceNodeNumResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyInstanceNodeNumResponse() = default;
};
class ModifyInstanceSpecRequest : public Darabonba::Model {
public:
  shared_ptr<long> diskSize{};
  shared_ptr<string> diskType{};
  shared_ptr<bool> dryRun{};
  shared_ptr<string> instanceClass{};
  shared_ptr<string> instanceId{};

  ModifyInstanceSpecRequest() {}

  explicit ModifyInstanceSpecRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (diskSize) {
      res["DiskSize"] = boost::any(*diskSize);
    }
    if (diskType) {
      res["DiskType"] = boost::any(*diskType);
    }
    if (dryRun) {
      res["DryRun"] = boost::any(*dryRun);
    }
    if (instanceClass) {
      res["InstanceClass"] = boost::any(*instanceClass);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DiskSize") != m.end() && !m["DiskSize"].empty()) {
      diskSize = make_shared<long>(boost::any_cast<long>(m["DiskSize"]));
    }
    if (m.find("DiskType") != m.end() && !m["DiskType"].empty()) {
      diskType = make_shared<string>(boost::any_cast<string>(m["DiskType"]));
    }
    if (m.find("DryRun") != m.end() && !m["DryRun"].empty()) {
      dryRun = make_shared<bool>(boost::any_cast<bool>(m["DryRun"]));
    }
    if (m.find("InstanceClass") != m.end() && !m["InstanceClass"].empty()) {
      instanceClass = make_shared<string>(boost::any_cast<string>(m["InstanceClass"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~ModifyInstanceSpecRequest() = default;
};
class ModifyInstanceSpecResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<bool> dryRunResult{};
  shared_ptr<string> orderId{};

  ModifyInstanceSpecResponseBodyData() {}

  explicit ModifyInstanceSpecResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dryRunResult) {
      res["DryRunResult"] = boost::any(*dryRunResult);
    }
    if (orderId) {
      res["OrderId"] = boost::any(*orderId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DryRunResult") != m.end() && !m["DryRunResult"].empty()) {
      dryRunResult = make_shared<bool>(boost::any_cast<bool>(m["DryRunResult"]));
    }
    if (m.find("OrderId") != m.end() && !m["OrderId"].empty()) {
      orderId = make_shared<string>(boost::any_cast<string>(m["OrderId"]));
    }
  }


  virtual ~ModifyInstanceSpecResponseBodyData() = default;
};
class ModifyInstanceSpecResponseBody : public Darabonba::Model {
public:
  shared_ptr<ModifyInstanceSpecResponseBodyData> data{};
  shared_ptr<string> requestId{};

  ModifyInstanceSpecResponseBody() {}

  explicit ModifyInstanceSpecResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ModifyInstanceSpecResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ModifyInstanceSpecResponseBodyData>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyInstanceSpecResponseBody() = default;
};
class ModifyInstanceSpecResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyInstanceSpecResponseBody> body{};

  ModifyInstanceSpecResponse() {}

  explicit ModifyInstanceSpecResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyInstanceSpecResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyInstanceSpecResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyInstanceSpecResponse() = default;
};
class ModifyInstanceTagsRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> tags{};

  ModifyInstanceTagsRequest() {}

  explicit ModifyInstanceTagsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (tags) {
      res["Tags"] = boost::any(*tags);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      tags = make_shared<string>(boost::any_cast<string>(m["Tags"]));
    }
  }


  virtual ~ModifyInstanceTagsRequest() = default;
};
class ModifyInstanceTagsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  ModifyInstanceTagsResponseBody() {}

  explicit ModifyInstanceTagsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyInstanceTagsResponseBody() = default;
};
class ModifyInstanceTagsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyInstanceTagsResponseBody> body{};

  ModifyInstanceTagsResponse() {}

  explicit ModifyInstanceTagsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyInstanceTagsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyInstanceTagsResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyInstanceTagsResponse() = default;
};
class ModifyInstanceTemporaryCapacityRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<string> diskSize{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> spec{};

  ModifyInstanceTemporaryCapacityRequest() {}

  explicit ModifyInstanceTemporaryCapacityRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (diskSize) {
      res["DiskSize"] = boost::any(*diskSize);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (spec) {
      res["Spec"] = boost::any(*spec);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("DiskSize") != m.end() && !m["DiskSize"].empty()) {
      diskSize = make_shared<string>(boost::any_cast<string>(m["DiskSize"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Spec") != m.end() && !m["Spec"].empty()) {
      spec = make_shared<string>(boost::any_cast<string>(m["Spec"]));
    }
  }


  virtual ~ModifyInstanceTemporaryCapacityRequest() = default;
};
class ModifyInstanceTemporaryCapacityResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyInstanceTemporaryCapacityResponseBody() {}

  explicit ModifyInstanceTemporaryCapacityResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyInstanceTemporaryCapacityResponseBody() = default;
};
class ModifyInstanceTemporaryCapacityResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyInstanceTemporaryCapacityResponseBody> body{};

  ModifyInstanceTemporaryCapacityResponse() {}

  explicit ModifyInstanceTemporaryCapacityResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyInstanceTemporaryCapacityResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyInstanceTemporaryCapacityResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyInstanceTemporaryCapacityResponse() = default;
};
class ModifyParametersRequest : public Darabonba::Model {
public:
  shared_ptr<string> dimension{};
  shared_ptr<string> dimensionValue{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> parameters{};

  ModifyParametersRequest() {}

  explicit ModifyParametersRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dimension) {
      res["Dimension"] = boost::any(*dimension);
    }
    if (dimensionValue) {
      res["DimensionValue"] = boost::any(*dimensionValue);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (parameters) {
      res["Parameters"] = boost::any(*parameters);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Dimension") != m.end() && !m["Dimension"].empty()) {
      dimension = make_shared<string>(boost::any_cast<string>(m["Dimension"]));
    }
    if (m.find("DimensionValue") != m.end() && !m["DimensionValue"].empty()) {
      dimensionValue = make_shared<string>(boost::any_cast<string>(m["DimensionValue"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Parameters") != m.end() && !m["Parameters"].empty()) {
      parameters = make_shared<string>(boost::any_cast<string>(m["Parameters"]));
    }
  }


  virtual ~ModifyParametersRequest() = default;
};
class ModifyParametersResponseBodyResults : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<bool> success{};

  ModifyParametersResponseBodyResults() {}

  explicit ModifyParametersResponseBodyResults(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ModifyParametersResponseBodyResults() = default;
};
class ModifyParametersResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<ModifyParametersResponseBodyResults> results{};

  ModifyParametersResponseBody() {}

  explicit ModifyParametersResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (results) {
      res["Results"] = results ? boost::any(results->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Results") != m.end() && !m["Results"].empty()) {
      if (typeid(map<string, boost::any>) == m["Results"].type()) {
        ModifyParametersResponseBodyResults model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Results"]));
        results = make_shared<ModifyParametersResponseBodyResults>(model1);
      }
    }
  }


  virtual ~ModifyParametersResponseBody() = default;
};
class ModifyParametersResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyParametersResponseBody> body{};

  ModifyParametersResponse() {}

  explicit ModifyParametersResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyParametersResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyParametersResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyParametersResponse() = default;
};
class ModifySecurityIpsRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> securityIpGroupName{};
  shared_ptr<string> securityIps{};

  ModifySecurityIpsRequest() {}

  explicit ModifySecurityIpsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (securityIpGroupName) {
      res["SecurityIpGroupName"] = boost::any(*securityIpGroupName);
    }
    if (securityIps) {
      res["SecurityIps"] = boost::any(*securityIps);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("SecurityIpGroupName") != m.end() && !m["SecurityIpGroupName"].empty()) {
      securityIpGroupName = make_shared<string>(boost::any_cast<string>(m["SecurityIpGroupName"]));
    }
    if (m.find("SecurityIps") != m.end() && !m["SecurityIps"].empty()) {
      securityIps = make_shared<string>(boost::any_cast<string>(m["SecurityIps"]));
    }
  }


  virtual ~ModifySecurityIpsRequest() = default;
};
class ModifySecurityIpsResponseBodySecurityIpGroup : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> securityIpGroupName{};
  shared_ptr<string> securityIps{};

  ModifySecurityIpsResponseBodySecurityIpGroup() {}

  explicit ModifySecurityIpsResponseBodySecurityIpGroup(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (securityIpGroupName) {
      res["SecurityIpGroupName"] = boost::any(*securityIpGroupName);
    }
    if (securityIps) {
      res["SecurityIps"] = boost::any(*securityIps);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("SecurityIpGroupName") != m.end() && !m["SecurityIpGroupName"].empty()) {
      securityIpGroupName = make_shared<string>(boost::any_cast<string>(m["SecurityIpGroupName"]));
    }
    if (m.find("SecurityIps") != m.end() && !m["SecurityIps"].empty()) {
      securityIps = make_shared<string>(boost::any_cast<string>(m["SecurityIps"]));
    }
  }


  virtual ~ModifySecurityIpsResponseBodySecurityIpGroup() = default;
};
class ModifySecurityIpsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<ModifySecurityIpsResponseBodySecurityIpGroup> securityIpGroup{};

  ModifySecurityIpsResponseBody() {}

  explicit ModifySecurityIpsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (securityIpGroup) {
      res["SecurityIpGroup"] = securityIpGroup ? boost::any(securityIpGroup->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SecurityIpGroup") != m.end() && !m["SecurityIpGroup"].empty()) {
      if (typeid(map<string, boost::any>) == m["SecurityIpGroup"].type()) {
        ModifySecurityIpsResponseBodySecurityIpGroup model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SecurityIpGroup"]));
        securityIpGroup = make_shared<ModifySecurityIpsResponseBodySecurityIpGroup>(model1);
      }
    }
  }


  virtual ~ModifySecurityIpsResponseBody() = default;
};
class ModifySecurityIpsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifySecurityIpsResponseBody> body{};

  ModifySecurityIpsResponse() {}

  explicit ModifySecurityIpsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifySecurityIpsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifySecurityIpsResponseBody>(model1);
      }
    }
  }


  virtual ~ModifySecurityIpsResponse() = default;
};
class ModifyTenantEncryptionRequest : public Darabonba::Model {
public:
  shared_ptr<string> encryptionKeyId{};
  shared_ptr<string> encryptionType{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> tenantId{};

  ModifyTenantEncryptionRequest() {}

  explicit ModifyTenantEncryptionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (encryptionKeyId) {
      res["EncryptionKeyId"] = boost::any(*encryptionKeyId);
    }
    if (encryptionType) {
      res["EncryptionType"] = boost::any(*encryptionType);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EncryptionKeyId") != m.end() && !m["EncryptionKeyId"].empty()) {
      encryptionKeyId = make_shared<string>(boost::any_cast<string>(m["EncryptionKeyId"]));
    }
    if (m.find("EncryptionType") != m.end() && !m["EncryptionType"].empty()) {
      encryptionType = make_shared<string>(boost::any_cast<string>(m["EncryptionType"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["TenantId"]));
    }
  }


  virtual ~ModifyTenantEncryptionRequest() = default;
};
class ModifyTenantEncryptionResponseBodyTenantEncryption : public Darabonba::Model {
public:
  shared_ptr<string> encryptionType{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> tenantId{};

  ModifyTenantEncryptionResponseBodyTenantEncryption() {}

  explicit ModifyTenantEncryptionResponseBodyTenantEncryption(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (encryptionType) {
      res["EncryptionType"] = boost::any(*encryptionType);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EncryptionType") != m.end() && !m["EncryptionType"].empty()) {
      encryptionType = make_shared<string>(boost::any_cast<string>(m["EncryptionType"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["TenantId"]));
    }
  }


  virtual ~ModifyTenantEncryptionResponseBodyTenantEncryption() = default;
};
class ModifyTenantEncryptionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<ModifyTenantEncryptionResponseBodyTenantEncryption> tenantEncryption{};

  ModifyTenantEncryptionResponseBody() {}

  explicit ModifyTenantEncryptionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (tenantEncryption) {
      res["TenantEncryption"] = tenantEncryption ? boost::any(tenantEncryption->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TenantEncryption") != m.end() && !m["TenantEncryption"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantEncryption"].type()) {
        ModifyTenantEncryptionResponseBodyTenantEncryption model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantEncryption"]));
        tenantEncryption = make_shared<ModifyTenantEncryptionResponseBodyTenantEncryption>(model1);
      }
    }
  }


  virtual ~ModifyTenantEncryptionResponseBody() = default;
};
class ModifyTenantEncryptionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyTenantEncryptionResponseBody> body{};

  ModifyTenantEncryptionResponse() {}

  explicit ModifyTenantEncryptionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyTenantEncryptionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyTenantEncryptionResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyTenantEncryptionResponse() = default;
};
class ModifyTenantPrimaryZoneRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> masterIntranetAddressZone{};
  shared_ptr<string> primaryZone{};
  shared_ptr<string> tenantEndpointDirectId{};
  shared_ptr<string> tenantEndpointId{};
  shared_ptr<string> tenantId{};
  shared_ptr<string> userDirectVSwitchId{};
  shared_ptr<string> userVSwitchId{};
  shared_ptr<string> vpcId{};

  ModifyTenantPrimaryZoneRequest() {}

  explicit ModifyTenantPrimaryZoneRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (masterIntranetAddressZone) {
      res["MasterIntranetAddressZone"] = boost::any(*masterIntranetAddressZone);
    }
    if (primaryZone) {
      res["PrimaryZone"] = boost::any(*primaryZone);
    }
    if (tenantEndpointDirectId) {
      res["TenantEndpointDirectId"] = boost::any(*tenantEndpointDirectId);
    }
    if (tenantEndpointId) {
      res["TenantEndpointId"] = boost::any(*tenantEndpointId);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    if (userDirectVSwitchId) {
      res["UserDirectVSwitchId"] = boost::any(*userDirectVSwitchId);
    }
    if (userVSwitchId) {
      res["UserVSwitchId"] = boost::any(*userVSwitchId);
    }
    if (vpcId) {
      res["VpcId"] = boost::any(*vpcId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("MasterIntranetAddressZone") != m.end() && !m["MasterIntranetAddressZone"].empty()) {
      masterIntranetAddressZone = make_shared<string>(boost::any_cast<string>(m["MasterIntranetAddressZone"]));
    }
    if (m.find("PrimaryZone") != m.end() && !m["PrimaryZone"].empty()) {
      primaryZone = make_shared<string>(boost::any_cast<string>(m["PrimaryZone"]));
    }
    if (m.find("TenantEndpointDirectId") != m.end() && !m["TenantEndpointDirectId"].empty()) {
      tenantEndpointDirectId = make_shared<string>(boost::any_cast<string>(m["TenantEndpointDirectId"]));
    }
    if (m.find("TenantEndpointId") != m.end() && !m["TenantEndpointId"].empty()) {
      tenantEndpointId = make_shared<string>(boost::any_cast<string>(m["TenantEndpointId"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["TenantId"]));
    }
    if (m.find("UserDirectVSwitchId") != m.end() && !m["UserDirectVSwitchId"].empty()) {
      userDirectVSwitchId = make_shared<string>(boost::any_cast<string>(m["UserDirectVSwitchId"]));
    }
    if (m.find("UserVSwitchId") != m.end() && !m["UserVSwitchId"].empty()) {
      userVSwitchId = make_shared<string>(boost::any_cast<string>(m["UserVSwitchId"]));
    }
    if (m.find("VpcId") != m.end() && !m["VpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["VpcId"]));
    }
  }


  virtual ~ModifyTenantPrimaryZoneRequest() = default;
};
class ModifyTenantPrimaryZoneResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyTenantPrimaryZoneResponseBody() {}

  explicit ModifyTenantPrimaryZoneResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyTenantPrimaryZoneResponseBody() = default;
};
class ModifyTenantPrimaryZoneResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyTenantPrimaryZoneResponseBody> body{};

  ModifyTenantPrimaryZoneResponse() {}

  explicit ModifyTenantPrimaryZoneResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyTenantPrimaryZoneResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyTenantPrimaryZoneResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyTenantPrimaryZoneResponse() = default;
};
class ModifyTenantResourceRequest : public Darabonba::Model {
public:
  shared_ptr<long> cpu{};
  shared_ptr<string> instanceId{};
  shared_ptr<long> logDisk{};
  shared_ptr<long> memory{};
  shared_ptr<string> readOnlyZoneList{};
  shared_ptr<string> tenantId{};

  ModifyTenantResourceRequest() {}

  explicit ModifyTenantResourceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cpu) {
      res["Cpu"] = boost::any(*cpu);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (logDisk) {
      res["LogDisk"] = boost::any(*logDisk);
    }
    if (memory) {
      res["Memory"] = boost::any(*memory);
    }
    if (readOnlyZoneList) {
      res["ReadOnlyZoneList"] = boost::any(*readOnlyZoneList);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Cpu") != m.end() && !m["Cpu"].empty()) {
      cpu = make_shared<long>(boost::any_cast<long>(m["Cpu"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("LogDisk") != m.end() && !m["LogDisk"].empty()) {
      logDisk = make_shared<long>(boost::any_cast<long>(m["LogDisk"]));
    }
    if (m.find("Memory") != m.end() && !m["Memory"].empty()) {
      memory = make_shared<long>(boost::any_cast<long>(m["Memory"]));
    }
    if (m.find("ReadOnlyZoneList") != m.end() && !m["ReadOnlyZoneList"].empty()) {
      readOnlyZoneList = make_shared<string>(boost::any_cast<string>(m["ReadOnlyZoneList"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["TenantId"]));
    }
  }


  virtual ~ModifyTenantResourceRequest() = default;
};
class ModifyTenantResourceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> tenantId{};

  ModifyTenantResourceResponseBody() {}

  explicit ModifyTenantResourceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["TenantId"]));
    }
  }


  virtual ~ModifyTenantResourceResponseBody() = default;
};
class ModifyTenantResourceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyTenantResourceResponseBody> body{};

  ModifyTenantResourceResponse() {}

  explicit ModifyTenantResourceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyTenantResourceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyTenantResourceResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyTenantResourceResponse() = default;
};
class ModifyTenantSecurityIpGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> securityIpGroupName{};
  shared_ptr<string> securityIps{};
  shared_ptr<string> tenantId{};

  ModifyTenantSecurityIpGroupRequest() {}

  explicit ModifyTenantSecurityIpGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (securityIpGroupName) {
      res["SecurityIpGroupName"] = boost::any(*securityIpGroupName);
    }
    if (securityIps) {
      res["SecurityIps"] = boost::any(*securityIps);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("SecurityIpGroupName") != m.end() && !m["SecurityIpGroupName"].empty()) {
      securityIpGroupName = make_shared<string>(boost::any_cast<string>(m["SecurityIpGroupName"]));
    }
    if (m.find("SecurityIps") != m.end() && !m["SecurityIps"].empty()) {
      securityIps = make_shared<string>(boost::any_cast<string>(m["SecurityIps"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["TenantId"]));
    }
  }


  virtual ~ModifyTenantSecurityIpGroupRequest() = default;
};
class ModifyTenantSecurityIpGroupResponseBodySecurityIpGroup : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> securityIpGroupName{};
  shared_ptr<string> securityIps{};
  shared_ptr<string> tenantId{};

  ModifyTenantSecurityIpGroupResponseBodySecurityIpGroup() {}

  explicit ModifyTenantSecurityIpGroupResponseBodySecurityIpGroup(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (securityIpGroupName) {
      res["SecurityIpGroupName"] = boost::any(*securityIpGroupName);
    }
    if (securityIps) {
      res["SecurityIps"] = boost::any(*securityIps);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("SecurityIpGroupName") != m.end() && !m["SecurityIpGroupName"].empty()) {
      securityIpGroupName = make_shared<string>(boost::any_cast<string>(m["SecurityIpGroupName"]));
    }
    if (m.find("SecurityIps") != m.end() && !m["SecurityIps"].empty()) {
      securityIps = make_shared<string>(boost::any_cast<string>(m["SecurityIps"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["TenantId"]));
    }
  }


  virtual ~ModifyTenantSecurityIpGroupResponseBodySecurityIpGroup() = default;
};
class ModifyTenantSecurityIpGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<ModifyTenantSecurityIpGroupResponseBodySecurityIpGroup> securityIpGroup{};

  ModifyTenantSecurityIpGroupResponseBody() {}

  explicit ModifyTenantSecurityIpGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (securityIpGroup) {
      res["SecurityIpGroup"] = securityIpGroup ? boost::any(securityIpGroup->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SecurityIpGroup") != m.end() && !m["SecurityIpGroup"].empty()) {
      if (typeid(map<string, boost::any>) == m["SecurityIpGroup"].type()) {
        ModifyTenantSecurityIpGroupResponseBodySecurityIpGroup model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SecurityIpGroup"]));
        securityIpGroup = make_shared<ModifyTenantSecurityIpGroupResponseBodySecurityIpGroup>(model1);
      }
    }
  }


  virtual ~ModifyTenantSecurityIpGroupResponseBody() = default;
};
class ModifyTenantSecurityIpGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyTenantSecurityIpGroupResponseBody> body{};

  ModifyTenantSecurityIpGroupResponse() {}

  explicit ModifyTenantSecurityIpGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyTenantSecurityIpGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyTenantSecurityIpGroupResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyTenantSecurityIpGroupResponse() = default;
};
class ModifyTenantTagsRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> tags{};
  shared_ptr<string> tenantId{};

  ModifyTenantTagsRequest() {}

  explicit ModifyTenantTagsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (tags) {
      res["Tags"] = boost::any(*tags);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      tags = make_shared<string>(boost::any_cast<string>(m["Tags"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["TenantId"]));
    }
  }


  virtual ~ModifyTenantTagsRequest() = default;
};
class ModifyTenantTagsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  ModifyTenantTagsResponseBody() {}

  explicit ModifyTenantTagsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyTenantTagsResponseBody() = default;
};
class ModifyTenantTagsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyTenantTagsResponseBody> body{};

  ModifyTenantTagsResponse() {}

  explicit ModifyTenantTagsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyTenantTagsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyTenantTagsResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyTenantTagsResponse() = default;
};
class ModifyTenantUserDescriptionRequest : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> tenantId{};
  shared_ptr<string> userName{};

  ModifyTenantUserDescriptionRequest() {}

  explicit ModifyTenantUserDescriptionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    if (userName) {
      res["UserName"] = boost::any(*userName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["TenantId"]));
    }
    if (m.find("UserName") != m.end() && !m["UserName"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["UserName"]));
    }
  }


  virtual ~ModifyTenantUserDescriptionRequest() = default;
};
class ModifyTenantUserDescriptionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyTenantUserDescriptionResponseBody() {}

  explicit ModifyTenantUserDescriptionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyTenantUserDescriptionResponseBody() = default;
};
class ModifyTenantUserDescriptionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyTenantUserDescriptionResponseBody> body{};

  ModifyTenantUserDescriptionResponse() {}

  explicit ModifyTenantUserDescriptionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyTenantUserDescriptionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyTenantUserDescriptionResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyTenantUserDescriptionResponse() = default;
};
class ModifyTenantUserPasswordRequest : public Darabonba::Model {
public:
  shared_ptr<string> encryptionType{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> tenantId{};
  shared_ptr<string> userName{};
  shared_ptr<string> userPassword{};

  ModifyTenantUserPasswordRequest() {}

  explicit ModifyTenantUserPasswordRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (encryptionType) {
      res["EncryptionType"] = boost::any(*encryptionType);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    if (userName) {
      res["UserName"] = boost::any(*userName);
    }
    if (userPassword) {
      res["UserPassword"] = boost::any(*userPassword);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EncryptionType") != m.end() && !m["EncryptionType"].empty()) {
      encryptionType = make_shared<string>(boost::any_cast<string>(m["EncryptionType"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["TenantId"]));
    }
    if (m.find("UserName") != m.end() && !m["UserName"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["UserName"]));
    }
    if (m.find("UserPassword") != m.end() && !m["UserPassword"].empty()) {
      userPassword = make_shared<string>(boost::any_cast<string>(m["UserPassword"]));
    }
  }


  virtual ~ModifyTenantUserPasswordRequest() = default;
};
class ModifyTenantUserPasswordResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyTenantUserPasswordResponseBody() {}

  explicit ModifyTenantUserPasswordResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyTenantUserPasswordResponseBody() = default;
};
class ModifyTenantUserPasswordResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyTenantUserPasswordResponseBody> body{};

  ModifyTenantUserPasswordResponse() {}

  explicit ModifyTenantUserPasswordResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyTenantUserPasswordResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyTenantUserPasswordResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyTenantUserPasswordResponse() = default;
};
class ModifyTenantUserRolesRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> modifyType{};
  shared_ptr<string> tenantId{};
  shared_ptr<string> userName{};
  shared_ptr<string> userRole{};

  ModifyTenantUserRolesRequest() {}

  explicit ModifyTenantUserRolesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (modifyType) {
      res["ModifyType"] = boost::any(*modifyType);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    if (userName) {
      res["UserName"] = boost::any(*userName);
    }
    if (userRole) {
      res["UserRole"] = boost::any(*userRole);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("ModifyType") != m.end() && !m["ModifyType"].empty()) {
      modifyType = make_shared<string>(boost::any_cast<string>(m["ModifyType"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["TenantId"]));
    }
    if (m.find("UserName") != m.end() && !m["UserName"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["UserName"]));
    }
    if (m.find("UserRole") != m.end() && !m["UserRole"].empty()) {
      userRole = make_shared<string>(boost::any_cast<string>(m["UserRole"]));
    }
  }


  virtual ~ModifyTenantUserRolesRequest() = default;
};
class ModifyTenantUserRolesResponseBodyTenantUserUserRole : public Darabonba::Model {
public:
  shared_ptr<string> database{};
  shared_ptr<bool> isSuccess{};
  shared_ptr<string> role{};
  shared_ptr<string> table{};

  ModifyTenantUserRolesResponseBodyTenantUserUserRole() {}

  explicit ModifyTenantUserRolesResponseBodyTenantUserUserRole(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (database) {
      res["Database"] = boost::any(*database);
    }
    if (isSuccess) {
      res["IsSuccess"] = boost::any(*isSuccess);
    }
    if (role) {
      res["Role"] = boost::any(*role);
    }
    if (table) {
      res["Table"] = boost::any(*table);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Database") != m.end() && !m["Database"].empty()) {
      database = make_shared<string>(boost::any_cast<string>(m["Database"]));
    }
    if (m.find("IsSuccess") != m.end() && !m["IsSuccess"].empty()) {
      isSuccess = make_shared<bool>(boost::any_cast<bool>(m["IsSuccess"]));
    }
    if (m.find("Role") != m.end() && !m["Role"].empty()) {
      role = make_shared<string>(boost::any_cast<string>(m["Role"]));
    }
    if (m.find("Table") != m.end() && !m["Table"].empty()) {
      table = make_shared<string>(boost::any_cast<string>(m["Table"]));
    }
  }


  virtual ~ModifyTenantUserRolesResponseBodyTenantUserUserRole() = default;
};
class ModifyTenantUserRolesResponseBodyTenantUser : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};
  shared_ptr<string> userName{};
  shared_ptr<vector<ModifyTenantUserRolesResponseBodyTenantUserUserRole>> userRole{};

  ModifyTenantUserRolesResponseBodyTenantUser() {}

  explicit ModifyTenantUserRolesResponseBodyTenantUser(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    if (userName) {
      res["UserName"] = boost::any(*userName);
    }
    if (userRole) {
      vector<boost::any> temp1;
      for(auto item1:*userRole){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["UserRole"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["TenantId"]));
    }
    if (m.find("UserName") != m.end() && !m["UserName"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["UserName"]));
    }
    if (m.find("UserRole") != m.end() && !m["UserRole"].empty()) {
      if (typeid(vector<boost::any>) == m["UserRole"].type()) {
        vector<ModifyTenantUserRolesResponseBodyTenantUserUserRole> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["UserRole"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ModifyTenantUserRolesResponseBodyTenantUserUserRole model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        userRole = make_shared<vector<ModifyTenantUserRolesResponseBodyTenantUserUserRole>>(expect1);
      }
    }
  }


  virtual ~ModifyTenantUserRolesResponseBodyTenantUser() = default;
};
class ModifyTenantUserRolesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<ModifyTenantUserRolesResponseBodyTenantUser> tenantUser{};

  ModifyTenantUserRolesResponseBody() {}

  explicit ModifyTenantUserRolesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (tenantUser) {
      res["TenantUser"] = tenantUser ? boost::any(tenantUser->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TenantUser") != m.end() && !m["TenantUser"].empty()) {
      if (typeid(map<string, boost::any>) == m["TenantUser"].type()) {
        ModifyTenantUserRolesResponseBodyTenantUser model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TenantUser"]));
        tenantUser = make_shared<ModifyTenantUserRolesResponseBodyTenantUser>(model1);
      }
    }
  }


  virtual ~ModifyTenantUserRolesResponseBody() = default;
};
class ModifyTenantUserRolesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyTenantUserRolesResponseBody> body{};

  ModifyTenantUserRolesResponse() {}

  explicit ModifyTenantUserRolesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyTenantUserRolesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyTenantUserRolesResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyTenantUserRolesResponse() = default;
};
class ModifyTenantUserStatusRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> tenantId{};
  shared_ptr<string> userName{};
  shared_ptr<string> userStatus{};

  ModifyTenantUserStatusRequest() {}

  explicit ModifyTenantUserStatusRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    if (userName) {
      res["UserName"] = boost::any(*userName);
    }
    if (userStatus) {
      res["UserStatus"] = boost::any(*userStatus);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["TenantId"]));
    }
    if (m.find("UserName") != m.end() && !m["UserName"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["UserName"]));
    }
    if (m.find("UserStatus") != m.end() && !m["UserStatus"].empty()) {
      userStatus = make_shared<string>(boost::any_cast<string>(m["UserStatus"]));
    }
  }


  virtual ~ModifyTenantUserStatusRequest() = default;
};
class ModifyTenantUserStatusResponseBodyTenantUser : public Darabonba::Model {
public:
  shared_ptr<string> tenantId{};
  shared_ptr<string> userName{};
  shared_ptr<string> userStatus{};

  ModifyTenantUserStatusResponseBodyTenantUser() {}

  explicit ModifyTenantUserStatusResponseBodyTenantUser(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    if (userName) {
      res["UserName"] = boost::any(*userName);
    }
    if (userStatus) {
      res["UserStatus"] = boost::any(*userStatus);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["TenantId"]));
    }
    if (m.find("UserName") != m.end() && !m["UserName"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["UserName"]));
    }
    if (m.find("UserStatus") != m.end() && !m["UserStatus"].empty()) {
      userStatus = make_shared<string>(boost::any_cast<string>(m["UserStatus"]));
    }
  }


  virtual ~ModifyTenantUserStatusResponseBodyTenantUser() = default;
};
class ModifyTenantUserStatusResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<ModifyTenantUserStatusResponseBodyTenantUser>> tenantUser{};

  ModifyTenantUserStatusResponseBody() {}

  explicit ModifyTenantUserStatusResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (tenantUser) {
      vector<boost::any> temp1;
      for(auto item1:*tenantUser){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TenantUser"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TenantUser") != m.end() && !m["TenantUser"].empty()) {
      if (typeid(vector<boost::any>) == m["TenantUser"].type()) {
        vector<ModifyTenantUserStatusResponseBodyTenantUser> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TenantUser"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ModifyTenantUserStatusResponseBodyTenantUser model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tenantUser = make_shared<vector<ModifyTenantUserStatusResponseBodyTenantUser>>(expect1);
      }
    }
  }


  virtual ~ModifyTenantUserStatusResponseBody() = default;
};
class ModifyTenantUserStatusResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyTenantUserStatusResponseBody> body{};

  ModifyTenantUserStatusResponse() {}

  explicit ModifyTenantUserStatusResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyTenantUserStatusResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyTenantUserStatusResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyTenantUserStatusResponse() = default;
};
class ReleaseProjectRequest : public Darabonba::Model {
public:
  shared_ptr<string> id{};

  ReleaseProjectRequest() {}

  explicit ReleaseProjectRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
  }


  virtual ~ReleaseProjectRequest() = default;
};
class ReleaseProjectResponseBodyErrorDetail : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<map<string, boost::any>> extraContext{};
  shared_ptr<string> level{};
  shared_ptr<string> message{};
  shared_ptr<map<string, string>> messageMcmsContext{};
  shared_ptr<string> messageMcmsKey{};
  shared_ptr<string> proposal{};
  shared_ptr<map<string, string>> proposalMcmsContext{};
  shared_ptr<string> proposalMcmsKey{};
  shared_ptr<string> reason{};
  shared_ptr<map<string, string>> reasonMcmsContext{};
  shared_ptr<string> reasonMcmsKey{};
  shared_ptr<boost::any> upstreamErrorDetail{};

  ReleaseProjectResponseBodyErrorDetail() {}

  explicit ReleaseProjectResponseBodyErrorDetail(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (extraContext) {
      res["ExtraContext"] = boost::any(*extraContext);
    }
    if (level) {
      res["Level"] = boost::any(*level);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (messageMcmsContext) {
      res["MessageMcmsContext"] = boost::any(*messageMcmsContext);
    }
    if (messageMcmsKey) {
      res["MessageMcmsKey"] = boost::any(*messageMcmsKey);
    }
    if (proposal) {
      res["Proposal"] = boost::any(*proposal);
    }
    if (proposalMcmsContext) {
      res["ProposalMcmsContext"] = boost::any(*proposalMcmsContext);
    }
    if (proposalMcmsKey) {
      res["ProposalMcmsKey"] = boost::any(*proposalMcmsKey);
    }
    if (reason) {
      res["Reason"] = boost::any(*reason);
    }
    if (reasonMcmsContext) {
      res["ReasonMcmsContext"] = boost::any(*reasonMcmsContext);
    }
    if (reasonMcmsKey) {
      res["ReasonMcmsKey"] = boost::any(*reasonMcmsKey);
    }
    if (upstreamErrorDetail) {
      res["UpstreamErrorDetail"] = boost::any(*upstreamErrorDetail);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ExtraContext") != m.end() && !m["ExtraContext"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["ExtraContext"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      extraContext = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<string>(boost::any_cast<string>(m["Level"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("MessageMcmsContext") != m.end() && !m["MessageMcmsContext"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["MessageMcmsContext"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      messageMcmsContext = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("MessageMcmsKey") != m.end() && !m["MessageMcmsKey"].empty()) {
      messageMcmsKey = make_shared<string>(boost::any_cast<string>(m["MessageMcmsKey"]));
    }
    if (m.find("Proposal") != m.end() && !m["Proposal"].empty()) {
      proposal = make_shared<string>(boost::any_cast<string>(m["Proposal"]));
    }
    if (m.find("ProposalMcmsContext") != m.end() && !m["ProposalMcmsContext"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["ProposalMcmsContext"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      proposalMcmsContext = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("ProposalMcmsKey") != m.end() && !m["ProposalMcmsKey"].empty()) {
      proposalMcmsKey = make_shared<string>(boost::any_cast<string>(m["ProposalMcmsKey"]));
    }
    if (m.find("Reason") != m.end() && !m["Reason"].empty()) {
      reason = make_shared<string>(boost::any_cast<string>(m["Reason"]));
    }
    if (m.find("ReasonMcmsContext") != m.end() && !m["ReasonMcmsContext"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["ReasonMcmsContext"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      reasonMcmsContext = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("ReasonMcmsKey") != m.end() && !m["ReasonMcmsKey"].empty()) {
      reasonMcmsKey = make_shared<string>(boost::any_cast<string>(m["ReasonMcmsKey"]));
    }
    if (m.find("UpstreamErrorDetail") != m.end() && !m["UpstreamErrorDetail"].empty()) {
      upstreamErrorDetail = make_shared<boost::any>(boost::any_cast<boost::any>(m["UpstreamErrorDetail"]));
    }
  }


  virtual ~ReleaseProjectResponseBodyErrorDetail() = default;
};
class ReleaseProjectResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> advice{};
  shared_ptr<string> code{};
  shared_ptr<string> cost{};
  shared_ptr<boost::any> data{};
  shared_ptr<ReleaseProjectResponseBodyErrorDetail> errorDetail{};
  shared_ptr<string> message{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<long> totalCount{};

  ReleaseProjectResponseBody() {}

  explicit ReleaseProjectResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (advice) {
      res["Advice"] = boost::any(*advice);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (cost) {
      res["Cost"] = boost::any(*cost);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (errorDetail) {
      res["ErrorDetail"] = errorDetail ? boost::any(errorDetail->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Advice") != m.end() && !m["Advice"].empty()) {
      advice = make_shared<string>(boost::any_cast<string>(m["Advice"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Cost") != m.end() && !m["Cost"].empty()) {
      cost = make_shared<string>(boost::any_cast<string>(m["Cost"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<boost::any>(boost::any_cast<boost::any>(m["Data"]));
    }
    if (m.find("ErrorDetail") != m.end() && !m["ErrorDetail"].empty()) {
      if (typeid(map<string, boost::any>) == m["ErrorDetail"].type()) {
        ReleaseProjectResponseBodyErrorDetail model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ErrorDetail"]));
        errorDetail = make_shared<ReleaseProjectResponseBodyErrorDetail>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ReleaseProjectResponseBody() = default;
};
class ReleaseProjectResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ReleaseProjectResponseBody> body{};

  ReleaseProjectResponse() {}

  explicit ReleaseProjectResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ReleaseProjectResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ReleaseProjectResponseBody>(model1);
      }
    }
  }


  virtual ~ReleaseProjectResponse() = default;
};
class ReleaseWorkerInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<string> id{};

  ReleaseWorkerInstanceRequest() {}

  explicit ReleaseWorkerInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
  }


  virtual ~ReleaseWorkerInstanceRequest() = default;
};
class ReleaseWorkerInstanceResponseBodyErrorDetail : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<map<string, boost::any>> extraContext{};
  shared_ptr<string> level{};
  shared_ptr<string> message{};
  shared_ptr<map<string, string>> messageMcmsContext{};
  shared_ptr<string> messageMcmsKey{};
  shared_ptr<string> proposal{};
  shared_ptr<map<string, string>> proposalMcmsContext{};
  shared_ptr<string> proposalMcmsKey{};
  shared_ptr<string> reason{};
  shared_ptr<map<string, string>> reasonMcmsContext{};
  shared_ptr<string> reasonMcmsKey{};
  shared_ptr<boost::any> upstreamErrorDetail{};

  ReleaseWorkerInstanceResponseBodyErrorDetail() {}

  explicit ReleaseWorkerInstanceResponseBodyErrorDetail(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (extraContext) {
      res["ExtraContext"] = boost::any(*extraContext);
    }
    if (level) {
      res["Level"] = boost::any(*level);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (messageMcmsContext) {
      res["MessageMcmsContext"] = boost::any(*messageMcmsContext);
    }
    if (messageMcmsKey) {
      res["MessageMcmsKey"] = boost::any(*messageMcmsKey);
    }
    if (proposal) {
      res["Proposal"] = boost::any(*proposal);
    }
    if (proposalMcmsContext) {
      res["ProposalMcmsContext"] = boost::any(*proposalMcmsContext);
    }
    if (proposalMcmsKey) {
      res["ProposalMcmsKey"] = boost::any(*proposalMcmsKey);
    }
    if (reason) {
      res["Reason"] = boost::any(*reason);
    }
    if (reasonMcmsContext) {
      res["ReasonMcmsContext"] = boost::any(*reasonMcmsContext);
    }
    if (reasonMcmsKey) {
      res["ReasonMcmsKey"] = boost::any(*reasonMcmsKey);
    }
    if (upstreamErrorDetail) {
      res["UpstreamErrorDetail"] = boost::any(*upstreamErrorDetail);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ExtraContext") != m.end() && !m["ExtraContext"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["ExtraContext"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      extraContext = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<string>(boost::any_cast<string>(m["Level"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("MessageMcmsContext") != m.end() && !m["MessageMcmsContext"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["MessageMcmsContext"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      messageMcmsContext = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("MessageMcmsKey") != m.end() && !m["MessageMcmsKey"].empty()) {
      messageMcmsKey = make_shared<string>(boost::any_cast<string>(m["MessageMcmsKey"]));
    }
    if (m.find("Proposal") != m.end() && !m["Proposal"].empty()) {
      proposal = make_shared<string>(boost::any_cast<string>(m["Proposal"]));
    }
    if (m.find("ProposalMcmsContext") != m.end() && !m["ProposalMcmsContext"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["ProposalMcmsContext"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      proposalMcmsContext = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("ProposalMcmsKey") != m.end() && !m["ProposalMcmsKey"].empty()) {
      proposalMcmsKey = make_shared<string>(boost::any_cast<string>(m["ProposalMcmsKey"]));
    }
    if (m.find("Reason") != m.end() && !m["Reason"].empty()) {
      reason = make_shared<string>(boost::any_cast<string>(m["Reason"]));
    }
    if (m.find("ReasonMcmsContext") != m.end() && !m["ReasonMcmsContext"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["ReasonMcmsContext"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      reasonMcmsContext = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("ReasonMcmsKey") != m.end() && !m["ReasonMcmsKey"].empty()) {
      reasonMcmsKey = make_shared<string>(boost::any_cast<string>(m["ReasonMcmsKey"]));
    }
    if (m.find("UpstreamErrorDetail") != m.end() && !m["UpstreamErrorDetail"].empty()) {
      upstreamErrorDetail = make_shared<boost::any>(boost::any_cast<boost::any>(m["UpstreamErrorDetail"]));
    }
  }


  virtual ~ReleaseWorkerInstanceResponseBodyErrorDetail() = default;
};
class ReleaseWorkerInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> advice{};
  shared_ptr<string> code{};
  shared_ptr<string> cost{};
  shared_ptr<string> data{};
  shared_ptr<ReleaseWorkerInstanceResponseBodyErrorDetail> errorDetail{};
  shared_ptr<string> message{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<long> totalCount{};

  ReleaseWorkerInstanceResponseBody() {}

  explicit ReleaseWorkerInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (advice) {
      res["Advice"] = boost::any(*advice);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (cost) {
      res["Cost"] = boost::any(*cost);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (errorDetail) {
      res["ErrorDetail"] = errorDetail ? boost::any(errorDetail->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Advice") != m.end() && !m["Advice"].empty()) {
      advice = make_shared<string>(boost::any_cast<string>(m["Advice"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Cost") != m.end() && !m["Cost"].empty()) {
      cost = make_shared<string>(boost::any_cast<string>(m["Cost"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("ErrorDetail") != m.end() && !m["ErrorDetail"].empty()) {
      if (typeid(map<string, boost::any>) == m["ErrorDetail"].type()) {
        ReleaseWorkerInstanceResponseBodyErrorDetail model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ErrorDetail"]));
        errorDetail = make_shared<ReleaseWorkerInstanceResponseBodyErrorDetail>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ReleaseWorkerInstanceResponseBody() = default;
};
class ReleaseWorkerInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ReleaseWorkerInstanceResponseBody> body{};

  ReleaseWorkerInstanceResponse() {}

  explicit ReleaseWorkerInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ReleaseWorkerInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ReleaseWorkerInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~ReleaseWorkerInstanceResponse() = default;
};
class ResumeProjectRequest : public Darabonba::Model {
public:
  shared_ptr<string> id{};

  ResumeProjectRequest() {}

  explicit ResumeProjectRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
  }


  virtual ~ResumeProjectRequest() = default;
};
class ResumeProjectResponseBodyErrorDetail : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<map<string, boost::any>> extraContext{};
  shared_ptr<string> level{};
  shared_ptr<string> message{};
  shared_ptr<map<string, string>> messageMcmsContext{};
  shared_ptr<string> messageMcmsKey{};
  shared_ptr<string> proposal{};
  shared_ptr<map<string, string>> proposalMcmsContext{};
  shared_ptr<string> proposalMcmsKey{};
  shared_ptr<string> reason{};
  shared_ptr<map<string, string>> reasonMcmsContext{};
  shared_ptr<string> reasonMcmsKey{};
  shared_ptr<boost::any> upstreamErrorDetail{};

  ResumeProjectResponseBodyErrorDetail() {}

  explicit ResumeProjectResponseBodyErrorDetail(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (extraContext) {
      res["ExtraContext"] = boost::any(*extraContext);
    }
    if (level) {
      res["Level"] = boost::any(*level);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (messageMcmsContext) {
      res["MessageMcmsContext"] = boost::any(*messageMcmsContext);
    }
    if (messageMcmsKey) {
      res["MessageMcmsKey"] = boost::any(*messageMcmsKey);
    }
    if (proposal) {
      res["Proposal"] = boost::any(*proposal);
    }
    if (proposalMcmsContext) {
      res["ProposalMcmsContext"] = boost::any(*proposalMcmsContext);
    }
    if (proposalMcmsKey) {
      res["ProposalMcmsKey"] = boost::any(*proposalMcmsKey);
    }
    if (reason) {
      res["Reason"] = boost::any(*reason);
    }
    if (reasonMcmsContext) {
      res["ReasonMcmsContext"] = boost::any(*reasonMcmsContext);
    }
    if (reasonMcmsKey) {
      res["ReasonMcmsKey"] = boost::any(*reasonMcmsKey);
    }
    if (upstreamErrorDetail) {
      res["UpstreamErrorDetail"] = boost::any(*upstreamErrorDetail);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ExtraContext") != m.end() && !m["ExtraContext"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["ExtraContext"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      extraContext = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<string>(boost::any_cast<string>(m["Level"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("MessageMcmsContext") != m.end() && !m["MessageMcmsContext"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["MessageMcmsContext"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      messageMcmsContext = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("MessageMcmsKey") != m.end() && !m["MessageMcmsKey"].empty()) {
      messageMcmsKey = make_shared<string>(boost::any_cast<string>(m["MessageMcmsKey"]));
    }
    if (m.find("Proposal") != m.end() && !m["Proposal"].empty()) {
      proposal = make_shared<string>(boost::any_cast<string>(m["Proposal"]));
    }
    if (m.find("ProposalMcmsContext") != m.end() && !m["ProposalMcmsContext"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["ProposalMcmsContext"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      proposalMcmsContext = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("ProposalMcmsKey") != m.end() && !m["ProposalMcmsKey"].empty()) {
      proposalMcmsKey = make_shared<string>(boost::any_cast<string>(m["ProposalMcmsKey"]));
    }
    if (m.find("Reason") != m.end() && !m["Reason"].empty()) {
      reason = make_shared<string>(boost::any_cast<string>(m["Reason"]));
    }
    if (m.find("ReasonMcmsContext") != m.end() && !m["ReasonMcmsContext"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["ReasonMcmsContext"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      reasonMcmsContext = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("ReasonMcmsKey") != m.end() && !m["ReasonMcmsKey"].empty()) {
      reasonMcmsKey = make_shared<string>(boost::any_cast<string>(m["ReasonMcmsKey"]));
    }
    if (m.find("UpstreamErrorDetail") != m.end() && !m["UpstreamErrorDetail"].empty()) {
      upstreamErrorDetail = make_shared<boost::any>(boost::any_cast<boost::any>(m["UpstreamErrorDetail"]));
    }
  }


  virtual ~ResumeProjectResponseBodyErrorDetail() = default;
};
class ResumeProjectResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> advice{};
  shared_ptr<string> code{};
  shared_ptr<string> cost{};
  shared_ptr<boost::any> data{};
  shared_ptr<ResumeProjectResponseBodyErrorDetail> errorDetail{};
  shared_ptr<string> message{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<long> totalCount{};

  ResumeProjectResponseBody() {}

  explicit ResumeProjectResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (advice) {
      res["Advice"] = boost::any(*advice);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (cost) {
      res["Cost"] = boost::any(*cost);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (errorDetail) {
      res["ErrorDetail"] = errorDetail ? boost::any(errorDetail->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Advice") != m.end() && !m["Advice"].empty()) {
      advice = make_shared<string>(boost::any_cast<string>(m["Advice"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Cost") != m.end() && !m["Cost"].empty()) {
      cost = make_shared<string>(boost::any_cast<string>(m["Cost"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<boost::any>(boost::any_cast<boost::any>(m["Data"]));
    }
    if (m.find("ErrorDetail") != m.end() && !m["ErrorDetail"].empty()) {
      if (typeid(map<string, boost::any>) == m["ErrorDetail"].type()) {
        ResumeProjectResponseBodyErrorDetail model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ErrorDetail"]));
        errorDetail = make_shared<ResumeProjectResponseBodyErrorDetail>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ResumeProjectResponseBody() = default;
};
class ResumeProjectResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ResumeProjectResponseBody> body{};

  ResumeProjectResponse() {}

  explicit ResumeProjectResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ResumeProjectResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ResumeProjectResponseBody>(model1);
      }
    }
  }


  virtual ~ResumeProjectResponse() = default;
};
class RetryProjectModifyRecordsRequest : public Darabonba::Model {
public:
  shared_ptr<string> id{};

  RetryProjectModifyRecordsRequest() {}

  explicit RetryProjectModifyRecordsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
  }


  virtual ~RetryProjectModifyRecordsRequest() = default;
};
class RetryProjectModifyRecordsResponseBodyErrorDetail : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<map<string, boost::any>> extraContext{};
  shared_ptr<string> level{};
  shared_ptr<string> message{};
  shared_ptr<map<string, string>> messageMcmsContext{};
  shared_ptr<string> messageMcmsKey{};
  shared_ptr<string> proposal{};
  shared_ptr<map<string, string>> proposalMcmsContext{};
  shared_ptr<string> proposalMcmsKey{};
  shared_ptr<string> reason{};
  shared_ptr<map<string, string>> reasonMcmsContext{};
  shared_ptr<string> reasonMcmsKey{};
  shared_ptr<boost::any> upstreamErrorDetail{};

  RetryProjectModifyRecordsResponseBodyErrorDetail() {}

  explicit RetryProjectModifyRecordsResponseBodyErrorDetail(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (extraContext) {
      res["ExtraContext"] = boost::any(*extraContext);
    }
    if (level) {
      res["Level"] = boost::any(*level);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (messageMcmsContext) {
      res["MessageMcmsContext"] = boost::any(*messageMcmsContext);
    }
    if (messageMcmsKey) {
      res["MessageMcmsKey"] = boost::any(*messageMcmsKey);
    }
    if (proposal) {
      res["Proposal"] = boost::any(*proposal);
    }
    if (proposalMcmsContext) {
      res["ProposalMcmsContext"] = boost::any(*proposalMcmsContext);
    }
    if (proposalMcmsKey) {
      res["ProposalMcmsKey"] = boost::any(*proposalMcmsKey);
    }
    if (reason) {
      res["Reason"] = boost::any(*reason);
    }
    if (reasonMcmsContext) {
      res["ReasonMcmsContext"] = boost::any(*reasonMcmsContext);
    }
    if (reasonMcmsKey) {
      res["ReasonMcmsKey"] = boost::any(*reasonMcmsKey);
    }
    if (upstreamErrorDetail) {
      res["UpstreamErrorDetail"] = boost::any(*upstreamErrorDetail);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ExtraContext") != m.end() && !m["ExtraContext"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["ExtraContext"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      extraContext = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<string>(boost::any_cast<string>(m["Level"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("MessageMcmsContext") != m.end() && !m["MessageMcmsContext"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["MessageMcmsContext"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      messageMcmsContext = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("MessageMcmsKey") != m.end() && !m["MessageMcmsKey"].empty()) {
      messageMcmsKey = make_shared<string>(boost::any_cast<string>(m["MessageMcmsKey"]));
    }
    if (m.find("Proposal") != m.end() && !m["Proposal"].empty()) {
      proposal = make_shared<string>(boost::any_cast<string>(m["Proposal"]));
    }
    if (m.find("ProposalMcmsContext") != m.end() && !m["ProposalMcmsContext"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["ProposalMcmsContext"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      proposalMcmsContext = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("ProposalMcmsKey") != m.end() && !m["ProposalMcmsKey"].empty()) {
      proposalMcmsKey = make_shared<string>(boost::any_cast<string>(m["ProposalMcmsKey"]));
    }
    if (m.find("Reason") != m.end() && !m["Reason"].empty()) {
      reason = make_shared<string>(boost::any_cast<string>(m["Reason"]));
    }
    if (m.find("ReasonMcmsContext") != m.end() && !m["ReasonMcmsContext"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["ReasonMcmsContext"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      reasonMcmsContext = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("ReasonMcmsKey") != m.end() && !m["ReasonMcmsKey"].empty()) {
      reasonMcmsKey = make_shared<string>(boost::any_cast<string>(m["ReasonMcmsKey"]));
    }
    if (m.find("UpstreamErrorDetail") != m.end() && !m["UpstreamErrorDetail"].empty()) {
      upstreamErrorDetail = make_shared<boost::any>(boost::any_cast<boost::any>(m["UpstreamErrorDetail"]));
    }
  }


  virtual ~RetryProjectModifyRecordsResponseBodyErrorDetail() = default;
};
class RetryProjectModifyRecordsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> advice{};
  shared_ptr<string> code{};
  shared_ptr<string> cost{};
  shared_ptr<boost::any> data{};
  shared_ptr<RetryProjectModifyRecordsResponseBodyErrorDetail> errorDetail{};
  shared_ptr<string> message{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<long> totalCount{};

  RetryProjectModifyRecordsResponseBody() {}

  explicit RetryProjectModifyRecordsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (advice) {
      res["Advice"] = boost::any(*advice);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (cost) {
      res["Cost"] = boost::any(*cost);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (errorDetail) {
      res["ErrorDetail"] = errorDetail ? boost::any(errorDetail->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Advice") != m.end() && !m["Advice"].empty()) {
      advice = make_shared<string>(boost::any_cast<string>(m["Advice"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Cost") != m.end() && !m["Cost"].empty()) {
      cost = make_shared<string>(boost::any_cast<string>(m["Cost"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<boost::any>(boost::any_cast<boost::any>(m["Data"]));
    }
    if (m.find("ErrorDetail") != m.end() && !m["ErrorDetail"].empty()) {
      if (typeid(map<string, boost::any>) == m["ErrorDetail"].type()) {
        RetryProjectModifyRecordsResponseBodyErrorDetail model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ErrorDetail"]));
        errorDetail = make_shared<RetryProjectModifyRecordsResponseBodyErrorDetail>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~RetryProjectModifyRecordsResponseBody() = default;
};
class RetryProjectModifyRecordsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RetryProjectModifyRecordsResponseBody> body{};

  RetryProjectModifyRecordsResponse() {}

  explicit RetryProjectModifyRecordsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RetryProjectModifyRecordsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RetryProjectModifyRecordsResponseBody>(model1);
      }
    }
  }


  virtual ~RetryProjectModifyRecordsResponse() = default;
};
class StartProjectRequest : public Darabonba::Model {
public:
  shared_ptr<string> id{};

  StartProjectRequest() {}

  explicit StartProjectRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
  }


  virtual ~StartProjectRequest() = default;
};
class StartProjectResponseBodyErrorDetail : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<map<string, boost::any>> extraContext{};
  shared_ptr<string> level{};
  shared_ptr<string> message{};
  shared_ptr<map<string, string>> messageMcmsContext{};
  shared_ptr<string> messageMcmsKey{};
  shared_ptr<string> proposal{};
  shared_ptr<map<string, string>> proposalMcmsContext{};
  shared_ptr<string> proposalMcmsKey{};
  shared_ptr<string> reason{};
  shared_ptr<map<string, string>> reasonMcmsContext{};
  shared_ptr<string> reasonMcmsKey{};
  shared_ptr<boost::any> upstreamErrorDetail{};

  StartProjectResponseBodyErrorDetail() {}

  explicit StartProjectResponseBodyErrorDetail(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (extraContext) {
      res["ExtraContext"] = boost::any(*extraContext);
    }
    if (level) {
      res["Level"] = boost::any(*level);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (messageMcmsContext) {
      res["MessageMcmsContext"] = boost::any(*messageMcmsContext);
    }
    if (messageMcmsKey) {
      res["MessageMcmsKey"] = boost::any(*messageMcmsKey);
    }
    if (proposal) {
      res["Proposal"] = boost::any(*proposal);
    }
    if (proposalMcmsContext) {
      res["ProposalMcmsContext"] = boost::any(*proposalMcmsContext);
    }
    if (proposalMcmsKey) {
      res["ProposalMcmsKey"] = boost::any(*proposalMcmsKey);
    }
    if (reason) {
      res["Reason"] = boost::any(*reason);
    }
    if (reasonMcmsContext) {
      res["ReasonMcmsContext"] = boost::any(*reasonMcmsContext);
    }
    if (reasonMcmsKey) {
      res["ReasonMcmsKey"] = boost::any(*reasonMcmsKey);
    }
    if (upstreamErrorDetail) {
      res["UpstreamErrorDetail"] = boost::any(*upstreamErrorDetail);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ExtraContext") != m.end() && !m["ExtraContext"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["ExtraContext"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      extraContext = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<string>(boost::any_cast<string>(m["Level"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("MessageMcmsContext") != m.end() && !m["MessageMcmsContext"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["MessageMcmsContext"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      messageMcmsContext = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("MessageMcmsKey") != m.end() && !m["MessageMcmsKey"].empty()) {
      messageMcmsKey = make_shared<string>(boost::any_cast<string>(m["MessageMcmsKey"]));
    }
    if (m.find("Proposal") != m.end() && !m["Proposal"].empty()) {
      proposal = make_shared<string>(boost::any_cast<string>(m["Proposal"]));
    }
    if (m.find("ProposalMcmsContext") != m.end() && !m["ProposalMcmsContext"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["ProposalMcmsContext"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      proposalMcmsContext = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("ProposalMcmsKey") != m.end() && !m["ProposalMcmsKey"].empty()) {
      proposalMcmsKey = make_shared<string>(boost::any_cast<string>(m["ProposalMcmsKey"]));
    }
    if (m.find("Reason") != m.end() && !m["Reason"].empty()) {
      reason = make_shared<string>(boost::any_cast<string>(m["Reason"]));
    }
    if (m.find("ReasonMcmsContext") != m.end() && !m["ReasonMcmsContext"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["ReasonMcmsContext"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      reasonMcmsContext = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("ReasonMcmsKey") != m.end() && !m["ReasonMcmsKey"].empty()) {
      reasonMcmsKey = make_shared<string>(boost::any_cast<string>(m["ReasonMcmsKey"]));
    }
    if (m.find("UpstreamErrorDetail") != m.end() && !m["UpstreamErrorDetail"].empty()) {
      upstreamErrorDetail = make_shared<boost::any>(boost::any_cast<boost::any>(m["UpstreamErrorDetail"]));
    }
  }


  virtual ~StartProjectResponseBodyErrorDetail() = default;
};
class StartProjectResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> advice{};
  shared_ptr<string> code{};
  shared_ptr<string> cost{};
  shared_ptr<string> data{};
  shared_ptr<StartProjectResponseBodyErrorDetail> errorDetail{};
  shared_ptr<string> message{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<long> totalCount{};

  StartProjectResponseBody() {}

  explicit StartProjectResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (advice) {
      res["Advice"] = boost::any(*advice);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (cost) {
      res["Cost"] = boost::any(*cost);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (errorDetail) {
      res["ErrorDetail"] = errorDetail ? boost::any(errorDetail->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Advice") != m.end() && !m["Advice"].empty()) {
      advice = make_shared<string>(boost::any_cast<string>(m["Advice"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Cost") != m.end() && !m["Cost"].empty()) {
      cost = make_shared<string>(boost::any_cast<string>(m["Cost"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("ErrorDetail") != m.end() && !m["ErrorDetail"].empty()) {
      if (typeid(map<string, boost::any>) == m["ErrorDetail"].type()) {
        StartProjectResponseBodyErrorDetail model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ErrorDetail"]));
        errorDetail = make_shared<StartProjectResponseBodyErrorDetail>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~StartProjectResponseBody() = default;
};
class StartProjectResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<StartProjectResponseBody> body{};

  StartProjectResponse() {}

  explicit StartProjectResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        StartProjectResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<StartProjectResponseBody>(model1);
      }
    }
  }


  virtual ~StartProjectResponse() = default;
};
class StartProjectsByLabelRequest : public Darabonba::Model {
public:
  shared_ptr<string> id{};

  StartProjectsByLabelRequest() {}

  explicit StartProjectsByLabelRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
  }


  virtual ~StartProjectsByLabelRequest() = default;
};
class StartProjectsByLabelResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<string>> failedProjectIds{};
  shared_ptr<vector<string>> succeedProjectIds{};
  shared_ptr<long> total{};

  StartProjectsByLabelResponseBodyData() {}

  explicit StartProjectsByLabelResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (failedProjectIds) {
      res["FailedProjectIds"] = boost::any(*failedProjectIds);
    }
    if (succeedProjectIds) {
      res["SucceedProjectIds"] = boost::any(*succeedProjectIds);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FailedProjectIds") != m.end() && !m["FailedProjectIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["FailedProjectIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["FailedProjectIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      failedProjectIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("SucceedProjectIds") != m.end() && !m["SucceedProjectIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SucceedProjectIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SucceedProjectIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      succeedProjectIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~StartProjectsByLabelResponseBodyData() = default;
};
class StartProjectsByLabelResponseBodyErrorDetail : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<map<string, boost::any>> extraContext{};
  shared_ptr<string> level{};
  shared_ptr<string> message{};
  shared_ptr<map<string, string>> messageMcmsContext{};
  shared_ptr<string> messageMcmsKey{};
  shared_ptr<string> proposal{};
  shared_ptr<map<string, string>> proposalMcmsContext{};
  shared_ptr<string> proposalMcmsKey{};
  shared_ptr<string> reason{};
  shared_ptr<map<string, string>> reasonMcmsContext{};
  shared_ptr<string> reasonMcmsKey{};
  shared_ptr<boost::any> upstreamErrorDetail{};

  StartProjectsByLabelResponseBodyErrorDetail() {}

  explicit StartProjectsByLabelResponseBodyErrorDetail(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (extraContext) {
      res["ExtraContext"] = boost::any(*extraContext);
    }
    if (level) {
      res["Level"] = boost::any(*level);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (messageMcmsContext) {
      res["MessageMcmsContext"] = boost::any(*messageMcmsContext);
    }
    if (messageMcmsKey) {
      res["MessageMcmsKey"] = boost::any(*messageMcmsKey);
    }
    if (proposal) {
      res["Proposal"] = boost::any(*proposal);
    }
    if (proposalMcmsContext) {
      res["ProposalMcmsContext"] = boost::any(*proposalMcmsContext);
    }
    if (proposalMcmsKey) {
      res["ProposalMcmsKey"] = boost::any(*proposalMcmsKey);
    }
    if (reason) {
      res["Reason"] = boost::any(*reason);
    }
    if (reasonMcmsContext) {
      res["ReasonMcmsContext"] = boost::any(*reasonMcmsContext);
    }
    if (reasonMcmsKey) {
      res["ReasonMcmsKey"] = boost::any(*reasonMcmsKey);
    }
    if (upstreamErrorDetail) {
      res["UpstreamErrorDetail"] = boost::any(*upstreamErrorDetail);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ExtraContext") != m.end() && !m["ExtraContext"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["ExtraContext"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      extraContext = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<string>(boost::any_cast<string>(m["Level"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("MessageMcmsContext") != m.end() && !m["MessageMcmsContext"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["MessageMcmsContext"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      messageMcmsContext = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("MessageMcmsKey") != m.end() && !m["MessageMcmsKey"].empty()) {
      messageMcmsKey = make_shared<string>(boost::any_cast<string>(m["MessageMcmsKey"]));
    }
    if (m.find("Proposal") != m.end() && !m["Proposal"].empty()) {
      proposal = make_shared<string>(boost::any_cast<string>(m["Proposal"]));
    }
    if (m.find("ProposalMcmsContext") != m.end() && !m["ProposalMcmsContext"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["ProposalMcmsContext"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      proposalMcmsContext = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("ProposalMcmsKey") != m.end() && !m["ProposalMcmsKey"].empty()) {
      proposalMcmsKey = make_shared<string>(boost::any_cast<string>(m["ProposalMcmsKey"]));
    }
    if (m.find("Reason") != m.end() && !m["Reason"].empty()) {
      reason = make_shared<string>(boost::any_cast<string>(m["Reason"]));
    }
    if (m.find("ReasonMcmsContext") != m.end() && !m["ReasonMcmsContext"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["ReasonMcmsContext"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      reasonMcmsContext = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("ReasonMcmsKey") != m.end() && !m["ReasonMcmsKey"].empty()) {
      reasonMcmsKey = make_shared<string>(boost::any_cast<string>(m["ReasonMcmsKey"]));
    }
    if (m.find("UpstreamErrorDetail") != m.end() && !m["UpstreamErrorDetail"].empty()) {
      upstreamErrorDetail = make_shared<boost::any>(boost::any_cast<boost::any>(m["UpstreamErrorDetail"]));
    }
  }


  virtual ~StartProjectsByLabelResponseBodyErrorDetail() = default;
};
class StartProjectsByLabelResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> advice{};
  shared_ptr<string> code{};
  shared_ptr<string> cost{};
  shared_ptr<StartProjectsByLabelResponseBodyData> data{};
  shared_ptr<StartProjectsByLabelResponseBodyErrorDetail> errorDetail{};
  shared_ptr<string> message{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<long> totalCount{};

  StartProjectsByLabelResponseBody() {}

  explicit StartProjectsByLabelResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (advice) {
      res["Advice"] = boost::any(*advice);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (cost) {
      res["Cost"] = boost::any(*cost);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorDetail) {
      res["ErrorDetail"] = errorDetail ? boost::any(errorDetail->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Advice") != m.end() && !m["Advice"].empty()) {
      advice = make_shared<string>(boost::any_cast<string>(m["Advice"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Cost") != m.end() && !m["Cost"].empty()) {
      cost = make_shared<string>(boost::any_cast<string>(m["Cost"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        StartProjectsByLabelResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<StartProjectsByLabelResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorDetail") != m.end() && !m["ErrorDetail"].empty()) {
      if (typeid(map<string, boost::any>) == m["ErrorDetail"].type()) {
        StartProjectsByLabelResponseBodyErrorDetail model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ErrorDetail"]));
        errorDetail = make_shared<StartProjectsByLabelResponseBodyErrorDetail>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~StartProjectsByLabelResponseBody() = default;
};
class StartProjectsByLabelResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<StartProjectsByLabelResponseBody> body{};

  StartProjectsByLabelResponse() {}

  explicit StartProjectsByLabelResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        StartProjectsByLabelResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<StartProjectsByLabelResponseBody>(model1);
      }
    }
  }


  virtual ~StartProjectsByLabelResponse() = default;
};
class StopProjectRequest : public Darabonba::Model {
public:
  shared_ptr<string> id{};

  StopProjectRequest() {}

  explicit StopProjectRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
  }


  virtual ~StopProjectRequest() = default;
};
class StopProjectResponseBodyErrorDetail : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<map<string, boost::any>> extraContext{};
  shared_ptr<string> level{};
  shared_ptr<string> message{};
  shared_ptr<map<string, string>> messageMcmsContext{};
  shared_ptr<string> messageMcmsKey{};
  shared_ptr<string> proposal{};
  shared_ptr<map<string, string>> proposalMcmsContext{};
  shared_ptr<string> proposalMcmsKey{};
  shared_ptr<string> reason{};
  shared_ptr<map<string, string>> reasonMcmsContext{};
  shared_ptr<string> reasonMcmsKey{};
  shared_ptr<boost::any> upstreamErrorDetail{};

  StopProjectResponseBodyErrorDetail() {}

  explicit StopProjectResponseBodyErrorDetail(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (extraContext) {
      res["ExtraContext"] = boost::any(*extraContext);
    }
    if (level) {
      res["Level"] = boost::any(*level);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (messageMcmsContext) {
      res["MessageMcmsContext"] = boost::any(*messageMcmsContext);
    }
    if (messageMcmsKey) {
      res["MessageMcmsKey"] = boost::any(*messageMcmsKey);
    }
    if (proposal) {
      res["Proposal"] = boost::any(*proposal);
    }
    if (proposalMcmsContext) {
      res["ProposalMcmsContext"] = boost::any(*proposalMcmsContext);
    }
    if (proposalMcmsKey) {
      res["ProposalMcmsKey"] = boost::any(*proposalMcmsKey);
    }
    if (reason) {
      res["Reason"] = boost::any(*reason);
    }
    if (reasonMcmsContext) {
      res["ReasonMcmsContext"] = boost::any(*reasonMcmsContext);
    }
    if (reasonMcmsKey) {
      res["ReasonMcmsKey"] = boost::any(*reasonMcmsKey);
    }
    if (upstreamErrorDetail) {
      res["UpstreamErrorDetail"] = boost::any(*upstreamErrorDetail);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ExtraContext") != m.end() && !m["ExtraContext"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["ExtraContext"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      extraContext = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<string>(boost::any_cast<string>(m["Level"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("MessageMcmsContext") != m.end() && !m["MessageMcmsContext"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["MessageMcmsContext"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      messageMcmsContext = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("MessageMcmsKey") != m.end() && !m["MessageMcmsKey"].empty()) {
      messageMcmsKey = make_shared<string>(boost::any_cast<string>(m["MessageMcmsKey"]));
    }
    if (m.find("Proposal") != m.end() && !m["Proposal"].empty()) {
      proposal = make_shared<string>(boost::any_cast<string>(m["Proposal"]));
    }
    if (m.find("ProposalMcmsContext") != m.end() && !m["ProposalMcmsContext"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["ProposalMcmsContext"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      proposalMcmsContext = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("ProposalMcmsKey") != m.end() && !m["ProposalMcmsKey"].empty()) {
      proposalMcmsKey = make_shared<string>(boost::any_cast<string>(m["ProposalMcmsKey"]));
    }
    if (m.find("Reason") != m.end() && !m["Reason"].empty()) {
      reason = make_shared<string>(boost::any_cast<string>(m["Reason"]));
    }
    if (m.find("ReasonMcmsContext") != m.end() && !m["ReasonMcmsContext"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["ReasonMcmsContext"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      reasonMcmsContext = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("ReasonMcmsKey") != m.end() && !m["ReasonMcmsKey"].empty()) {
      reasonMcmsKey = make_shared<string>(boost::any_cast<string>(m["ReasonMcmsKey"]));
    }
    if (m.find("UpstreamErrorDetail") != m.end() && !m["UpstreamErrorDetail"].empty()) {
      upstreamErrorDetail = make_shared<boost::any>(boost::any_cast<boost::any>(m["UpstreamErrorDetail"]));
    }
  }


  virtual ~StopProjectResponseBodyErrorDetail() = default;
};
class StopProjectResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> advice{};
  shared_ptr<string> code{};
  shared_ptr<string> cost{};
  shared_ptr<string> data{};
  shared_ptr<StopProjectResponseBodyErrorDetail> errorDetail{};
  shared_ptr<string> message{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<long> totalCount{};

  StopProjectResponseBody() {}

  explicit StopProjectResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (advice) {
      res["Advice"] = boost::any(*advice);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (cost) {
      res["Cost"] = boost::any(*cost);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (errorDetail) {
      res["ErrorDetail"] = errorDetail ? boost::any(errorDetail->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Advice") != m.end() && !m["Advice"].empty()) {
      advice = make_shared<string>(boost::any_cast<string>(m["Advice"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Cost") != m.end() && !m["Cost"].empty()) {
      cost = make_shared<string>(boost::any_cast<string>(m["Cost"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("ErrorDetail") != m.end() && !m["ErrorDetail"].empty()) {
      if (typeid(map<string, boost::any>) == m["ErrorDetail"].type()) {
        StopProjectResponseBodyErrorDetail model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ErrorDetail"]));
        errorDetail = make_shared<StopProjectResponseBodyErrorDetail>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~StopProjectResponseBody() = default;
};
class StopProjectResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<StopProjectResponseBody> body{};

  StopProjectResponse() {}

  explicit StopProjectResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        StopProjectResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<StopProjectResponseBody>(model1);
      }
    }
  }


  virtual ~StopProjectResponse() = default;
};
class StopProjectModifyRecordsRequest : public Darabonba::Model {
public:
  shared_ptr<string> id{};

  StopProjectModifyRecordsRequest() {}

  explicit StopProjectModifyRecordsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
  }


  virtual ~StopProjectModifyRecordsRequest() = default;
};
class StopProjectModifyRecordsResponseBodyErrorDetail : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<map<string, boost::any>> extraContext{};
  shared_ptr<string> level{};
  shared_ptr<string> message{};
  shared_ptr<map<string, string>> messageMcmsContext{};
  shared_ptr<string> messageMcmsKey{};
  shared_ptr<string> proposal{};
  shared_ptr<map<string, string>> proposalMcmsContext{};
  shared_ptr<string> proposalMcmsKey{};
  shared_ptr<string> reason{};
  shared_ptr<map<string, string>> reasonMcmsContext{};
  shared_ptr<string> reasonMcmsKey{};
  shared_ptr<boost::any> upstreamErrorDetail{};

  StopProjectModifyRecordsResponseBodyErrorDetail() {}

  explicit StopProjectModifyRecordsResponseBodyErrorDetail(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (extraContext) {
      res["ExtraContext"] = boost::any(*extraContext);
    }
    if (level) {
      res["Level"] = boost::any(*level);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (messageMcmsContext) {
      res["MessageMcmsContext"] = boost::any(*messageMcmsContext);
    }
    if (messageMcmsKey) {
      res["MessageMcmsKey"] = boost::any(*messageMcmsKey);
    }
    if (proposal) {
      res["Proposal"] = boost::any(*proposal);
    }
    if (proposalMcmsContext) {
      res["ProposalMcmsContext"] = boost::any(*proposalMcmsContext);
    }
    if (proposalMcmsKey) {
      res["ProposalMcmsKey"] = boost::any(*proposalMcmsKey);
    }
    if (reason) {
      res["Reason"] = boost::any(*reason);
    }
    if (reasonMcmsContext) {
      res["ReasonMcmsContext"] = boost::any(*reasonMcmsContext);
    }
    if (reasonMcmsKey) {
      res["ReasonMcmsKey"] = boost::any(*reasonMcmsKey);
    }
    if (upstreamErrorDetail) {
      res["UpstreamErrorDetail"] = boost::any(*upstreamErrorDetail);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ExtraContext") != m.end() && !m["ExtraContext"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["ExtraContext"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      extraContext = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<string>(boost::any_cast<string>(m["Level"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("MessageMcmsContext") != m.end() && !m["MessageMcmsContext"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["MessageMcmsContext"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      messageMcmsContext = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("MessageMcmsKey") != m.end() && !m["MessageMcmsKey"].empty()) {
      messageMcmsKey = make_shared<string>(boost::any_cast<string>(m["MessageMcmsKey"]));
    }
    if (m.find("Proposal") != m.end() && !m["Proposal"].empty()) {
      proposal = make_shared<string>(boost::any_cast<string>(m["Proposal"]));
    }
    if (m.find("ProposalMcmsContext") != m.end() && !m["ProposalMcmsContext"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["ProposalMcmsContext"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      proposalMcmsContext = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("ProposalMcmsKey") != m.end() && !m["ProposalMcmsKey"].empty()) {
      proposalMcmsKey = make_shared<string>(boost::any_cast<string>(m["ProposalMcmsKey"]));
    }
    if (m.find("Reason") != m.end() && !m["Reason"].empty()) {
      reason = make_shared<string>(boost::any_cast<string>(m["Reason"]));
    }
    if (m.find("ReasonMcmsContext") != m.end() && !m["ReasonMcmsContext"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["ReasonMcmsContext"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      reasonMcmsContext = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("ReasonMcmsKey") != m.end() && !m["ReasonMcmsKey"].empty()) {
      reasonMcmsKey = make_shared<string>(boost::any_cast<string>(m["ReasonMcmsKey"]));
    }
    if (m.find("UpstreamErrorDetail") != m.end() && !m["UpstreamErrorDetail"].empty()) {
      upstreamErrorDetail = make_shared<boost::any>(boost::any_cast<boost::any>(m["UpstreamErrorDetail"]));
    }
  }


  virtual ~StopProjectModifyRecordsResponseBodyErrorDetail() = default;
};
class StopProjectModifyRecordsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> advice{};
  shared_ptr<string> code{};
  shared_ptr<string> cost{};
  shared_ptr<boost::any> data{};
  shared_ptr<StopProjectModifyRecordsResponseBodyErrorDetail> errorDetail{};
  shared_ptr<string> message{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<long> totalCount{};

  StopProjectModifyRecordsResponseBody() {}

  explicit StopProjectModifyRecordsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (advice) {
      res["Advice"] = boost::any(*advice);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (cost) {
      res["Cost"] = boost::any(*cost);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (errorDetail) {
      res["ErrorDetail"] = errorDetail ? boost::any(errorDetail->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Advice") != m.end() && !m["Advice"].empty()) {
      advice = make_shared<string>(boost::any_cast<string>(m["Advice"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Cost") != m.end() && !m["Cost"].empty()) {
      cost = make_shared<string>(boost::any_cast<string>(m["Cost"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<boost::any>(boost::any_cast<boost::any>(m["Data"]));
    }
    if (m.find("ErrorDetail") != m.end() && !m["ErrorDetail"].empty()) {
      if (typeid(map<string, boost::any>) == m["ErrorDetail"].type()) {
        StopProjectModifyRecordsResponseBodyErrorDetail model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ErrorDetail"]));
        errorDetail = make_shared<StopProjectModifyRecordsResponseBodyErrorDetail>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~StopProjectModifyRecordsResponseBody() = default;
};
class StopProjectModifyRecordsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<StopProjectModifyRecordsResponseBody> body{};

  StopProjectModifyRecordsResponse() {}

  explicit StopProjectModifyRecordsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        StopProjectModifyRecordsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<StopProjectModifyRecordsResponseBody>(model1);
      }
    }
  }


  virtual ~StopProjectModifyRecordsResponse() = default;
};
class StopProjectsByLabelRequest : public Darabonba::Model {
public:
  shared_ptr<string> id{};

  StopProjectsByLabelRequest() {}

  explicit StopProjectsByLabelRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
  }


  virtual ~StopProjectsByLabelRequest() = default;
};
class StopProjectsByLabelResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<string>> failedProjectIds{};
  shared_ptr<vector<string>> succeedProjectIds{};
  shared_ptr<long> total{};

  StopProjectsByLabelResponseBodyData() {}

  explicit StopProjectsByLabelResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (failedProjectIds) {
      res["FailedProjectIds"] = boost::any(*failedProjectIds);
    }
    if (succeedProjectIds) {
      res["SucceedProjectIds"] = boost::any(*succeedProjectIds);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FailedProjectIds") != m.end() && !m["FailedProjectIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["FailedProjectIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["FailedProjectIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      failedProjectIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("SucceedProjectIds") != m.end() && !m["SucceedProjectIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SucceedProjectIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SucceedProjectIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      succeedProjectIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~StopProjectsByLabelResponseBodyData() = default;
};
class StopProjectsByLabelResponseBodyErrorDetail : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<map<string, boost::any>> extraContext{};
  shared_ptr<string> level{};
  shared_ptr<string> message{};
  shared_ptr<map<string, string>> messageMcmsContext{};
  shared_ptr<string> messageMcmsKey{};
  shared_ptr<string> proposal{};
  shared_ptr<map<string, string>> proposalMcmsContext{};
  shared_ptr<string> proposalMcmsKey{};
  shared_ptr<string> reason{};
  shared_ptr<map<string, string>> reasonMcmsContext{};
  shared_ptr<string> reasonMcmsKey{};
  shared_ptr<boost::any> upstreamErrorDetail{};

  StopProjectsByLabelResponseBodyErrorDetail() {}

  explicit StopProjectsByLabelResponseBodyErrorDetail(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (extraContext) {
      res["ExtraContext"] = boost::any(*extraContext);
    }
    if (level) {
      res["Level"] = boost::any(*level);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (messageMcmsContext) {
      res["MessageMcmsContext"] = boost::any(*messageMcmsContext);
    }
    if (messageMcmsKey) {
      res["MessageMcmsKey"] = boost::any(*messageMcmsKey);
    }
    if (proposal) {
      res["Proposal"] = boost::any(*proposal);
    }
    if (proposalMcmsContext) {
      res["ProposalMcmsContext"] = boost::any(*proposalMcmsContext);
    }
    if (proposalMcmsKey) {
      res["ProposalMcmsKey"] = boost::any(*proposalMcmsKey);
    }
    if (reason) {
      res["Reason"] = boost::any(*reason);
    }
    if (reasonMcmsContext) {
      res["ReasonMcmsContext"] = boost::any(*reasonMcmsContext);
    }
    if (reasonMcmsKey) {
      res["ReasonMcmsKey"] = boost::any(*reasonMcmsKey);
    }
    if (upstreamErrorDetail) {
      res["UpstreamErrorDetail"] = boost::any(*upstreamErrorDetail);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ExtraContext") != m.end() && !m["ExtraContext"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["ExtraContext"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      extraContext = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<string>(boost::any_cast<string>(m["Level"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("MessageMcmsContext") != m.end() && !m["MessageMcmsContext"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["MessageMcmsContext"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      messageMcmsContext = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("MessageMcmsKey") != m.end() && !m["MessageMcmsKey"].empty()) {
      messageMcmsKey = make_shared<string>(boost::any_cast<string>(m["MessageMcmsKey"]));
    }
    if (m.find("Proposal") != m.end() && !m["Proposal"].empty()) {
      proposal = make_shared<string>(boost::any_cast<string>(m["Proposal"]));
    }
    if (m.find("ProposalMcmsContext") != m.end() && !m["ProposalMcmsContext"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["ProposalMcmsContext"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      proposalMcmsContext = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("ProposalMcmsKey") != m.end() && !m["ProposalMcmsKey"].empty()) {
      proposalMcmsKey = make_shared<string>(boost::any_cast<string>(m["ProposalMcmsKey"]));
    }
    if (m.find("Reason") != m.end() && !m["Reason"].empty()) {
      reason = make_shared<string>(boost::any_cast<string>(m["Reason"]));
    }
    if (m.find("ReasonMcmsContext") != m.end() && !m["ReasonMcmsContext"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["ReasonMcmsContext"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      reasonMcmsContext = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("ReasonMcmsKey") != m.end() && !m["ReasonMcmsKey"].empty()) {
      reasonMcmsKey = make_shared<string>(boost::any_cast<string>(m["ReasonMcmsKey"]));
    }
    if (m.find("UpstreamErrorDetail") != m.end() && !m["UpstreamErrorDetail"].empty()) {
      upstreamErrorDetail = make_shared<boost::any>(boost::any_cast<boost::any>(m["UpstreamErrorDetail"]));
    }
  }


  virtual ~StopProjectsByLabelResponseBodyErrorDetail() = default;
};
class StopProjectsByLabelResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> advice{};
  shared_ptr<string> code{};
  shared_ptr<string> cost{};
  shared_ptr<StopProjectsByLabelResponseBodyData> data{};
  shared_ptr<StopProjectsByLabelResponseBodyErrorDetail> errorDetail{};
  shared_ptr<string> message{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<long> totalCount{};

  StopProjectsByLabelResponseBody() {}

  explicit StopProjectsByLabelResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (advice) {
      res["Advice"] = boost::any(*advice);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (cost) {
      res["Cost"] = boost::any(*cost);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (errorDetail) {
      res["ErrorDetail"] = errorDetail ? boost::any(errorDetail->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Advice") != m.end() && !m["Advice"].empty()) {
      advice = make_shared<string>(boost::any_cast<string>(m["Advice"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Cost") != m.end() && !m["Cost"].empty()) {
      cost = make_shared<string>(boost::any_cast<string>(m["Cost"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        StopProjectsByLabelResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<StopProjectsByLabelResponseBodyData>(model1);
      }
    }
    if (m.find("ErrorDetail") != m.end() && !m["ErrorDetail"].empty()) {
      if (typeid(map<string, boost::any>) == m["ErrorDetail"].type()) {
        StopProjectsByLabelResponseBodyErrorDetail model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ErrorDetail"]));
        errorDetail = make_shared<StopProjectsByLabelResponseBodyErrorDetail>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~StopProjectsByLabelResponseBody() = default;
};
class StopProjectsByLabelResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<StopProjectsByLabelResponseBody> body{};

  StopProjectsByLabelResponse() {}

  explicit StopProjectsByLabelResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        StopProjectsByLabelResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<StopProjectsByLabelResponseBody>(model1);
      }
    }
  }


  virtual ~StopProjectsByLabelResponse() = default;
};
class SwitchoverInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<bool> forced{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> targetInstanceId{};

  SwitchoverInstanceRequest() {}

  explicit SwitchoverInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (forced) {
      res["Forced"] = boost::any(*forced);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (targetInstanceId) {
      res["TargetInstanceId"] = boost::any(*targetInstanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Forced") != m.end() && !m["Forced"].empty()) {
      forced = make_shared<bool>(boost::any_cast<bool>(m["Forced"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("TargetInstanceId") != m.end() && !m["TargetInstanceId"].empty()) {
      targetInstanceId = make_shared<string>(boost::any_cast<string>(m["TargetInstanceId"]));
    }
  }


  virtual ~SwitchoverInstanceRequest() = default;
};
class SwitchoverInstanceResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<bool> success{};

  SwitchoverInstanceResponseBodyData() {}

  explicit SwitchoverInstanceResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~SwitchoverInstanceResponseBodyData() = default;
};
class SwitchoverInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<SwitchoverInstanceResponseBodyData> data{};
  shared_ptr<string> requestId{};

  SwitchoverInstanceResponseBody() {}

  explicit SwitchoverInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        SwitchoverInstanceResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<SwitchoverInstanceResponseBodyData>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SwitchoverInstanceResponseBody() = default;
};
class SwitchoverInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SwitchoverInstanceResponseBody> body{};

  SwitchoverInstanceResponse() {}

  explicit SwitchoverInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SwitchoverInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SwitchoverInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~SwitchoverInstanceResponse() = default;
};
class Client : Alibabacloud_OpenApi::Client {
public:
  explicit Client(const shared_ptr<Alibabacloud_OpenApi::Config>& config);
  string getEndpoint(shared_ptr<string> productId,
                     shared_ptr<string> regionId,
                     shared_ptr<string> endpointRule,
                     shared_ptr<string> network,
                     shared_ptr<string> suffix,
                     shared_ptr<map<string, string>> endpointMap,
                     shared_ptr<string> endpoint);
  CancelProjectModifyRecordResponse cancelProjectModifyRecordWithOptions(shared_ptr<CancelProjectModifyRecordRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CancelProjectModifyRecordResponse cancelProjectModifyRecord(shared_ptr<CancelProjectModifyRecordRequest> request);
  CreateBackupSetDownloadLinkResponse createBackupSetDownloadLinkWithOptions(shared_ptr<CreateBackupSetDownloadLinkRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateBackupSetDownloadLinkResponse createBackupSetDownloadLink(shared_ptr<CreateBackupSetDownloadLinkRequest> request);
  CreateDatabaseResponse createDatabaseWithOptions(shared_ptr<CreateDatabaseRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateDatabaseResponse createDatabase(shared_ptr<CreateDatabaseRequest> request);
  CreateInstanceResponse createInstanceWithOptions(shared_ptr<CreateInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateInstanceResponse createInstance(shared_ptr<CreateInstanceRequest> request);
  CreateLabelResponse createLabelWithOptions(shared_ptr<CreateLabelRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateLabelResponse createLabel(shared_ptr<CreateLabelRequest> request);
  CreateMySqlDataSourceResponse createMySqlDataSourceWithOptions(shared_ptr<CreateMySqlDataSourceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateMySqlDataSourceResponse createMySqlDataSource(shared_ptr<CreateMySqlDataSourceRequest> request);
  CreateOceanBaseDataSourceResponse createOceanBaseDataSourceWithOptions(shared_ptr<CreateOceanBaseDataSourceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateOceanBaseDataSourceResponse createOceanBaseDataSource(shared_ptr<CreateOceanBaseDataSourceRequest> request);
  CreateOmsMysqlDataSourceResponse createOmsMysqlDataSourceWithOptions(shared_ptr<CreateOmsMysqlDataSourceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateOmsMysqlDataSourceResponse createOmsMysqlDataSource(shared_ptr<CreateOmsMysqlDataSourceRequest> request);
  CreateProjectResponse createProjectWithOptions(shared_ptr<CreateProjectRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateProjectResponse createProject(shared_ptr<CreateProjectRequest> request);
  CreateProjectModifyRecordsResponse createProjectModifyRecordsWithOptions(shared_ptr<CreateProjectModifyRecordsRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateProjectModifyRecordsResponse createProjectModifyRecords(shared_ptr<CreateProjectModifyRecordsRequest> request);
  CreateRdsPostgreSQLDataSourceResponse createRdsPostgreSQLDataSourceWithOptions(shared_ptr<CreateRdsPostgreSQLDataSourceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateRdsPostgreSQLDataSourceResponse createRdsPostgreSQLDataSource(shared_ptr<CreateRdsPostgreSQLDataSourceRequest> request);
  CreateSecurityIpGroupResponse createSecurityIpGroupWithOptions(shared_ptr<CreateSecurityIpGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateSecurityIpGroupResponse createSecurityIpGroup(shared_ptr<CreateSecurityIpGroupRequest> request);
  CreateTenantResponse createTenantWithOptions(shared_ptr<CreateTenantRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateTenantResponse createTenant(shared_ptr<CreateTenantRequest> request);
  CreateTenantReadOnlyConnectionResponse createTenantReadOnlyConnectionWithOptions(shared_ptr<CreateTenantReadOnlyConnectionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateTenantReadOnlyConnectionResponse createTenantReadOnlyConnection(shared_ptr<CreateTenantReadOnlyConnectionRequest> request);
  CreateTenantSecurityIpGroupResponse createTenantSecurityIpGroupWithOptions(shared_ptr<CreateTenantSecurityIpGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateTenantSecurityIpGroupResponse createTenantSecurityIpGroup(shared_ptr<CreateTenantSecurityIpGroupRequest> request);
  CreateTenantUserResponse createTenantUserWithOptions(shared_ptr<CreateTenantUserRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateTenantUserResponse createTenantUser(shared_ptr<CreateTenantUserRequest> request);
  DeleteDataSourceResponse deleteDataSourceWithOptions(shared_ptr<DeleteDataSourceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteDataSourceResponse deleteDataSource(shared_ptr<DeleteDataSourceRequest> request);
  DeleteDatabasesResponse deleteDatabasesWithOptions(shared_ptr<DeleteDatabasesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteDatabasesResponse deleteDatabases(shared_ptr<DeleteDatabasesRequest> request);
  DeleteInstancesResponse deleteInstancesWithOptions(shared_ptr<DeleteInstancesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteInstancesResponse deleteInstances(shared_ptr<DeleteInstancesRequest> request);
  DeleteProjectResponse deleteProjectWithOptions(shared_ptr<DeleteProjectRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteProjectResponse deleteProject(shared_ptr<DeleteProjectRequest> request);
  DeleteSecurityIpGroupResponse deleteSecurityIpGroupWithOptions(shared_ptr<DeleteSecurityIpGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteSecurityIpGroupResponse deleteSecurityIpGroup(shared_ptr<DeleteSecurityIpGroupRequest> request);
  DeleteTenantSecurityIpGroupResponse deleteTenantSecurityIpGroupWithOptions(shared_ptr<DeleteTenantSecurityIpGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteTenantSecurityIpGroupResponse deleteTenantSecurityIpGroup(shared_ptr<DeleteTenantSecurityIpGroupRequest> request);
  DeleteTenantUsersResponse deleteTenantUsersWithOptions(shared_ptr<DeleteTenantUsersRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteTenantUsersResponse deleteTenantUsers(shared_ptr<DeleteTenantUsersRequest> request);
  DeleteTenantsResponse deleteTenantsWithOptions(shared_ptr<DeleteTenantsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteTenantsResponse deleteTenants(shared_ptr<DeleteTenantsRequest> request);
  DescribeAnomalySQLListResponse describeAnomalySQLListWithOptions(shared_ptr<DescribeAnomalySQLListRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeAnomalySQLListResponse describeAnomalySQLList(shared_ptr<DescribeAnomalySQLListRequest> request);
  DescribeAvailableCpuResourceResponse describeAvailableCpuResourceWithOptions(shared_ptr<DescribeAvailableCpuResourceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeAvailableCpuResourceResponse describeAvailableCpuResource(shared_ptr<DescribeAvailableCpuResourceRequest> request);
  DescribeAvailableMemResourceResponse describeAvailableMemResourceWithOptions(shared_ptr<DescribeAvailableMemResourceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeAvailableMemResourceResponse describeAvailableMemResource(shared_ptr<DescribeAvailableMemResourceRequest> request);
  DescribeAvailableSpecResponse describeAvailableSpecWithOptions(shared_ptr<DescribeAvailableSpecRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeAvailableSpecResponse describeAvailableSpec(shared_ptr<DescribeAvailableSpecRequest> request);
  DescribeAvailableZoneResponse describeAvailableZoneWithOptions(shared_ptr<DescribeAvailableZoneRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeAvailableZoneResponse describeAvailableZone(shared_ptr<DescribeAvailableZoneRequest> request);
  DescribeBackupSetDownloadLinkResponse describeBackupSetDownloadLinkWithOptions(shared_ptr<DescribeBackupSetDownloadLinkRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeBackupSetDownloadLinkResponse describeBackupSetDownloadLink(shared_ptr<DescribeBackupSetDownloadLinkRequest> request);
  DescribeCharsetResponse describeCharsetWithOptions(shared_ptr<DescribeCharsetRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeCharsetResponse describeCharset(shared_ptr<DescribeCharsetRequest> request);
  DescribeDataBackupSetResponse describeDataBackupSetWithOptions(shared_ptr<DescribeDataBackupSetRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDataBackupSetResponse describeDataBackupSet(shared_ptr<DescribeDataBackupSetRequest> request);
  DescribeDatabasesResponse describeDatabasesWithOptions(shared_ptr<DescribeDatabasesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDatabasesResponse describeDatabases(shared_ptr<DescribeDatabasesRequest> request);
  DescribeInstanceResponse describeInstanceWithOptions(shared_ptr<DescribeInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeInstanceResponse describeInstance(shared_ptr<DescribeInstanceRequest> request);
  DescribeInstanceCreatableZoneResponse describeInstanceCreatableZoneWithOptions(shared_ptr<DescribeInstanceCreatableZoneRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeInstanceCreatableZoneResponse describeInstanceCreatableZone(shared_ptr<DescribeInstanceCreatableZoneRequest> request);
  DescribeInstanceSSLResponse describeInstanceSSLWithOptions(shared_ptr<DescribeInstanceSSLRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeInstanceSSLResponse describeInstanceSSL(shared_ptr<DescribeInstanceSSLRequest> request);
  DescribeInstanceSecurityConfigsResponse describeInstanceSecurityConfigsWithOptions(shared_ptr<DescribeInstanceSecurityConfigsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeInstanceSecurityConfigsResponse describeInstanceSecurityConfigs(shared_ptr<DescribeInstanceSecurityConfigsRequest> request);
  DescribeInstanceTagsResponse describeInstanceTagsWithOptions(shared_ptr<DescribeInstanceTagsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeInstanceTagsResponse describeInstanceTags(shared_ptr<DescribeInstanceTagsRequest> request);
  DescribeInstanceTenantModesResponse describeInstanceTenantModesWithOptions(shared_ptr<DescribeInstanceTenantModesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeInstanceTenantModesResponse describeInstanceTenantModes(shared_ptr<DescribeInstanceTenantModesRequest> request);
  DescribeInstanceTopologyResponse describeInstanceTopologyWithOptions(shared_ptr<DescribeInstanceTopologyRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeInstanceTopologyResponse describeInstanceTopology(shared_ptr<DescribeInstanceTopologyRequest> request);
  DescribeInstancesResponse describeInstancesWithOptions(shared_ptr<DescribeInstancesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeInstancesResponse describeInstances(shared_ptr<DescribeInstancesRequest> request);
  DescribeMetricsDataResponse describeMetricsDataWithOptions(shared_ptr<DescribeMetricsDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeMetricsDataResponse describeMetricsData(shared_ptr<DescribeMetricsDataRequest> request);
  DescribeNodeMetricsResponse describeNodeMetricsWithOptions(shared_ptr<DescribeNodeMetricsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeNodeMetricsResponse describeNodeMetrics(shared_ptr<DescribeNodeMetricsRequest> request);
  DescribeOasAnomalySQLListResponse describeOasAnomalySQLListWithOptions(shared_ptr<DescribeOasAnomalySQLListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeOasAnomalySQLListResponse describeOasAnomalySQLList(shared_ptr<DescribeOasAnomalySQLListRequest> request);
  DescribeOasSQLDetailsResponse describeOasSQLDetailsWithOptions(shared_ptr<DescribeOasSQLDetailsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeOasSQLDetailsResponse describeOasSQLDetails(shared_ptr<DescribeOasSQLDetailsRequest> request);
  DescribeOasSQLHistoryListResponse describeOasSQLHistoryListWithOptions(shared_ptr<DescribeOasSQLHistoryListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeOasSQLHistoryListResponse describeOasSQLHistoryList(shared_ptr<DescribeOasSQLHistoryListRequest> request);
  DescribeOasSQLPlansResponse describeOasSQLPlansWithOptions(shared_ptr<DescribeOasSQLPlansRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeOasSQLPlansResponse describeOasSQLPlans(shared_ptr<DescribeOasSQLPlansRequest> request);
  DescribeOasSlowSQLListResponse describeOasSlowSQLListWithOptions(shared_ptr<DescribeOasSlowSQLListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeOasSlowSQLListResponse describeOasSlowSQLList(shared_ptr<DescribeOasSlowSQLListRequest> request);
  DescribeOasTopSQLListResponse describeOasTopSQLListWithOptions(shared_ptr<DescribeOasTopSQLListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeOasTopSQLListResponse describeOasTopSQLList(shared_ptr<DescribeOasTopSQLListRequest> request);
  DescribeOutlineBindingResponse describeOutlineBindingWithOptions(shared_ptr<DescribeOutlineBindingRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeOutlineBindingResponse describeOutlineBinding(shared_ptr<DescribeOutlineBindingRequest> request);
  DescribeParametersResponse describeParametersWithOptions(shared_ptr<DescribeParametersRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeParametersResponse describeParameters(shared_ptr<DescribeParametersRequest> request);
  DescribeParametersHistoryResponse describeParametersHistoryWithOptions(shared_ptr<DescribeParametersHistoryRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeParametersHistoryResponse describeParametersHistory(shared_ptr<DescribeParametersHistoryRequest> request);
  DescribeProjectResponse describeProjectWithOptions(shared_ptr<DescribeProjectRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeProjectResponse describeProject(shared_ptr<DescribeProjectRequest> request);
  DescribeProjectComponentsResponse describeProjectComponentsWithOptions(shared_ptr<DescribeProjectComponentsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeProjectComponentsResponse describeProjectComponents(shared_ptr<DescribeProjectComponentsRequest> request);
  DescribeProjectProgressResponse describeProjectProgressWithOptions(shared_ptr<DescribeProjectProgressRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeProjectProgressResponse describeProjectProgress(shared_ptr<DescribeProjectProgressRequest> request);
  DescribeProjectStepMetricResponse describeProjectStepMetricWithOptions(shared_ptr<DescribeProjectStepMetricRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeProjectStepMetricResponse describeProjectStepMetric(shared_ptr<DescribeProjectStepMetricRequest> request);
  DescribeProjectStepsResponse describeProjectStepsWithOptions(shared_ptr<DescribeProjectStepsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeProjectStepsResponse describeProjectSteps(shared_ptr<DescribeProjectStepsRequest> request);
  DescribeRecommendIndexResponse describeRecommendIndexWithOptions(shared_ptr<DescribeRecommendIndexRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeRecommendIndexResponse describeRecommendIndex(shared_ptr<DescribeRecommendIndexRequest> request);
  DescribeSQLDetailsResponse describeSQLDetailsWithOptions(shared_ptr<DescribeSQLDetailsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeSQLDetailsResponse describeSQLDetails(shared_ptr<DescribeSQLDetailsRequest> request);
  DescribeSQLHistoryListResponse describeSQLHistoryListWithOptions(shared_ptr<DescribeSQLHistoryListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeSQLHistoryListResponse describeSQLHistoryList(shared_ptr<DescribeSQLHistoryListRequest> request);
  DescribeSQLPlansResponse describeSQLPlansWithOptions(shared_ptr<DescribeSQLPlansRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeSQLPlansResponse describeSQLPlans(shared_ptr<DescribeSQLPlansRequest> request);
  DescribeSQLSamplesResponse describeSQLSamplesWithOptions(shared_ptr<DescribeSQLSamplesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeSQLSamplesResponse describeSQLSamples(shared_ptr<DescribeSQLSamplesRequest> request);
  DescribeSampleSqlRawTextsResponse describeSampleSqlRawTextsWithOptions(shared_ptr<DescribeSampleSqlRawTextsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeSampleSqlRawTextsResponse describeSampleSqlRawTexts(shared_ptr<DescribeSampleSqlRawTextsRequest> request);
  DescribeSecurityIpGroupsResponse describeSecurityIpGroupsWithOptions(shared_ptr<DescribeSecurityIpGroupsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeSecurityIpGroupsResponse describeSecurityIpGroups(shared_ptr<DescribeSecurityIpGroupsRequest> request);
  DescribeSlowSQLHistoryListResponse describeSlowSQLHistoryListWithOptions(shared_ptr<DescribeSlowSQLHistoryListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeSlowSQLHistoryListResponse describeSlowSQLHistoryList(shared_ptr<DescribeSlowSQLHistoryListRequest> request);
  DescribeSlowSQLListResponse describeSlowSQLListWithOptions(shared_ptr<DescribeSlowSQLListRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeSlowSQLListResponse describeSlowSQLList(shared_ptr<DescribeSlowSQLListRequest> request);
  DescribeTenantResponse describeTenantWithOptions(shared_ptr<DescribeTenantRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeTenantResponse describeTenant(shared_ptr<DescribeTenantRequest> request);
  DescribeTenantEncryptionResponse describeTenantEncryptionWithOptions(shared_ptr<DescribeTenantEncryptionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeTenantEncryptionResponse describeTenantEncryption(shared_ptr<DescribeTenantEncryptionRequest> request);
  DescribeTenantMetricsResponse describeTenantMetricsWithOptions(shared_ptr<DescribeTenantMetricsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeTenantMetricsResponse describeTenantMetrics(shared_ptr<DescribeTenantMetricsRequest> request);
  DescribeTenantSecurityConfigsResponse describeTenantSecurityConfigsWithOptions(shared_ptr<DescribeTenantSecurityConfigsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeTenantSecurityConfigsResponse describeTenantSecurityConfigs(shared_ptr<DescribeTenantSecurityConfigsRequest> request);
  DescribeTenantSecurityIpGroupsResponse describeTenantSecurityIpGroupsWithOptions(shared_ptr<DescribeTenantSecurityIpGroupsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeTenantSecurityIpGroupsResponse describeTenantSecurityIpGroups(shared_ptr<DescribeTenantSecurityIpGroupsRequest> request);
  DescribeTenantTagsResponse describeTenantTagsWithOptions(shared_ptr<DescribeTenantTagsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeTenantTagsResponse describeTenantTags(shared_ptr<DescribeTenantTagsRequest> request);
  DescribeTenantUserRolesResponse describeTenantUserRolesWithOptions(shared_ptr<DescribeTenantUserRolesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeTenantUserRolesResponse describeTenantUserRoles(shared_ptr<DescribeTenantUserRolesRequest> request);
  DescribeTenantUsersResponse describeTenantUsersWithOptions(shared_ptr<DescribeTenantUsersRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeTenantUsersResponse describeTenantUsers(shared_ptr<DescribeTenantUsersRequest> request);
  DescribeTenantZonesReadResponse describeTenantZonesReadWithOptions(shared_ptr<DescribeTenantZonesReadRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeTenantZonesReadResponse describeTenantZonesRead(shared_ptr<DescribeTenantZonesReadRequest> request);
  DescribeTenantsResponse describeTenantsWithOptions(shared_ptr<DescribeTenantsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeTenantsResponse describeTenants(shared_ptr<DescribeTenantsRequest> request);
  DescribeTimeZonesResponse describeTimeZonesWithOptions(shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeTimeZonesResponse describeTimeZones();
  DescribeTopSQLListResponse describeTopSQLListWithOptions(shared_ptr<DescribeTopSQLListRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeTopSQLListResponse describeTopSQLList(shared_ptr<DescribeTopSQLListRequest> request);
  DescribeZonesResponse describeZonesWithOptions(shared_ptr<DescribeZonesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeZonesResponse describeZones(shared_ptr<DescribeZonesRequest> request);
  GetUploadOssUrlResponse getUploadOssUrlWithOptions(shared_ptr<GetUploadOssUrlRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetUploadOssUrlResponse getUploadOssUrl(shared_ptr<GetUploadOssUrlRequest> request);
  KillProcessListResponse killProcessListWithOptions(shared_ptr<KillProcessListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  KillProcessListResponse killProcessList(shared_ptr<KillProcessListRequest> request);
  ListAllLabelsResponse listAllLabelsWithOptions(shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListAllLabelsResponse listAllLabels();
  ListDataSourceResponse listDataSourceWithOptions(shared_ptr<ListDataSourceRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListDataSourceResponse listDataSource(shared_ptr<ListDataSourceRequest> request);
  ListProjectFullVerifyResultResponse listProjectFullVerifyResultWithOptions(shared_ptr<ListProjectFullVerifyResultRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListProjectFullVerifyResultResponse listProjectFullVerifyResult(shared_ptr<ListProjectFullVerifyResultRequest> request);
  ListProjectModifyRecordsResponse listProjectModifyRecordsWithOptions(shared_ptr<ListProjectModifyRecordsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListProjectModifyRecordsResponse listProjectModifyRecords(shared_ptr<ListProjectModifyRecordsRequest> request);
  ListProjectsResponse listProjectsWithOptions(shared_ptr<ListProjectsRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListProjectsResponse listProjects(shared_ptr<ListProjectsRequest> request);
  ListWorkerInstancesResponse listWorkerInstancesWithOptions(shared_ptr<ListWorkerInstancesRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListWorkerInstancesResponse listWorkerInstances(shared_ptr<ListWorkerInstancesRequest> request);
  ModifyDatabaseDescriptionResponse modifyDatabaseDescriptionWithOptions(shared_ptr<ModifyDatabaseDescriptionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyDatabaseDescriptionResponse modifyDatabaseDescription(shared_ptr<ModifyDatabaseDescriptionRequest> request);
  ModifyDatabaseUserRolesResponse modifyDatabaseUserRolesWithOptions(shared_ptr<ModifyDatabaseUserRolesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyDatabaseUserRolesResponse modifyDatabaseUserRoles(shared_ptr<ModifyDatabaseUserRolesRequest> request);
  ModifyInstanceNameResponse modifyInstanceNameWithOptions(shared_ptr<ModifyInstanceNameRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyInstanceNameResponse modifyInstanceName(shared_ptr<ModifyInstanceNameRequest> request);
  ModifyInstanceNodeNumResponse modifyInstanceNodeNumWithOptions(shared_ptr<ModifyInstanceNodeNumRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyInstanceNodeNumResponse modifyInstanceNodeNum(shared_ptr<ModifyInstanceNodeNumRequest> request);
  ModifyInstanceSpecResponse modifyInstanceSpecWithOptions(shared_ptr<ModifyInstanceSpecRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyInstanceSpecResponse modifyInstanceSpec(shared_ptr<ModifyInstanceSpecRequest> request);
  ModifyInstanceTagsResponse modifyInstanceTagsWithOptions(shared_ptr<ModifyInstanceTagsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyInstanceTagsResponse modifyInstanceTags(shared_ptr<ModifyInstanceTagsRequest> request);
  ModifyInstanceTemporaryCapacityResponse modifyInstanceTemporaryCapacityWithOptions(shared_ptr<ModifyInstanceTemporaryCapacityRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyInstanceTemporaryCapacityResponse modifyInstanceTemporaryCapacity(shared_ptr<ModifyInstanceTemporaryCapacityRequest> request);
  ModifyParametersResponse modifyParametersWithOptions(shared_ptr<ModifyParametersRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyParametersResponse modifyParameters(shared_ptr<ModifyParametersRequest> request);
  ModifySecurityIpsResponse modifySecurityIpsWithOptions(shared_ptr<ModifySecurityIpsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifySecurityIpsResponse modifySecurityIps(shared_ptr<ModifySecurityIpsRequest> request);
  ModifyTenantEncryptionResponse modifyTenantEncryptionWithOptions(shared_ptr<ModifyTenantEncryptionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyTenantEncryptionResponse modifyTenantEncryption(shared_ptr<ModifyTenantEncryptionRequest> request);
  ModifyTenantPrimaryZoneResponse modifyTenantPrimaryZoneWithOptions(shared_ptr<ModifyTenantPrimaryZoneRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyTenantPrimaryZoneResponse modifyTenantPrimaryZone(shared_ptr<ModifyTenantPrimaryZoneRequest> request);
  ModifyTenantResourceResponse modifyTenantResourceWithOptions(shared_ptr<ModifyTenantResourceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyTenantResourceResponse modifyTenantResource(shared_ptr<ModifyTenantResourceRequest> request);
  ModifyTenantSecurityIpGroupResponse modifyTenantSecurityIpGroupWithOptions(shared_ptr<ModifyTenantSecurityIpGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyTenantSecurityIpGroupResponse modifyTenantSecurityIpGroup(shared_ptr<ModifyTenantSecurityIpGroupRequest> request);
  ModifyTenantTagsResponse modifyTenantTagsWithOptions(shared_ptr<ModifyTenantTagsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyTenantTagsResponse modifyTenantTags(shared_ptr<ModifyTenantTagsRequest> request);
  ModifyTenantUserDescriptionResponse modifyTenantUserDescriptionWithOptions(shared_ptr<ModifyTenantUserDescriptionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyTenantUserDescriptionResponse modifyTenantUserDescription(shared_ptr<ModifyTenantUserDescriptionRequest> request);
  ModifyTenantUserPasswordResponse modifyTenantUserPasswordWithOptions(shared_ptr<ModifyTenantUserPasswordRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyTenantUserPasswordResponse modifyTenantUserPassword(shared_ptr<ModifyTenantUserPasswordRequest> request);
  ModifyTenantUserRolesResponse modifyTenantUserRolesWithOptions(shared_ptr<ModifyTenantUserRolesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyTenantUserRolesResponse modifyTenantUserRoles(shared_ptr<ModifyTenantUserRolesRequest> request);
  ModifyTenantUserStatusResponse modifyTenantUserStatusWithOptions(shared_ptr<ModifyTenantUserStatusRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyTenantUserStatusResponse modifyTenantUserStatus(shared_ptr<ModifyTenantUserStatusRequest> request);
  ReleaseProjectResponse releaseProjectWithOptions(shared_ptr<ReleaseProjectRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ReleaseProjectResponse releaseProject(shared_ptr<ReleaseProjectRequest> request);
  ReleaseWorkerInstanceResponse releaseWorkerInstanceWithOptions(shared_ptr<ReleaseWorkerInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ReleaseWorkerInstanceResponse releaseWorkerInstance(shared_ptr<ReleaseWorkerInstanceRequest> request);
  ResumeProjectResponse resumeProjectWithOptions(shared_ptr<ResumeProjectRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ResumeProjectResponse resumeProject(shared_ptr<ResumeProjectRequest> request);
  RetryProjectModifyRecordsResponse retryProjectModifyRecordsWithOptions(shared_ptr<RetryProjectModifyRecordsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RetryProjectModifyRecordsResponse retryProjectModifyRecords(shared_ptr<RetryProjectModifyRecordsRequest> request);
  StartProjectResponse startProjectWithOptions(shared_ptr<StartProjectRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  StartProjectResponse startProject(shared_ptr<StartProjectRequest> request);
  StartProjectsByLabelResponse startProjectsByLabelWithOptions(shared_ptr<StartProjectsByLabelRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  StartProjectsByLabelResponse startProjectsByLabel(shared_ptr<StartProjectsByLabelRequest> request);
  StopProjectResponse stopProjectWithOptions(shared_ptr<StopProjectRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  StopProjectResponse stopProject(shared_ptr<StopProjectRequest> request);
  StopProjectModifyRecordsResponse stopProjectModifyRecordsWithOptions(shared_ptr<StopProjectModifyRecordsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  StopProjectModifyRecordsResponse stopProjectModifyRecords(shared_ptr<StopProjectModifyRecordsRequest> request);
  StopProjectsByLabelResponse stopProjectsByLabelWithOptions(shared_ptr<StopProjectsByLabelRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  StopProjectsByLabelResponse stopProjectsByLabel(shared_ptr<StopProjectsByLabelRequest> request);
  SwitchoverInstanceResponse switchoverInstanceWithOptions(shared_ptr<SwitchoverInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SwitchoverInstanceResponse switchoverInstance(shared_ptr<SwitchoverInstanceRequest> request);

  virtual ~Client() = default;
};
} // namespace Alibabacloud_OceanBasePro20190901

#endif
