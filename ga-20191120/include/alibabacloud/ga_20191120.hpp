// This file is auto-generated, don't edit it. Thanks.

#ifndef ALIBABACLOUD_GA20191120_H_
#define ALIBABACLOUD_GA20191120_H_

#include <alibabacloud/open_api.hpp>
#include <boost/throw_exception.hpp>
#include <darabonba/core.hpp>
#include <darabonba/util.hpp>
#include <iostream>
#include <map>
#include <vector>

using namespace std;

namespace Alibabacloud_Ga20191120 {
class AddEntriesToAclRequestAclEntries : public Darabonba::Model {
public:
  shared_ptr<string> entry{};
  shared_ptr<string> entryDescription{};

  AddEntriesToAclRequestAclEntries() {}

  explicit AddEntriesToAclRequestAclEntries(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (entry) {
      res["Entry"] = boost::any(*entry);
    }
    if (entryDescription) {
      res["EntryDescription"] = boost::any(*entryDescription);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Entry") != m.end() && !m["Entry"].empty()) {
      entry = make_shared<string>(boost::any_cast<string>(m["Entry"]));
    }
    if (m.find("EntryDescription") != m.end() && !m["EntryDescription"].empty()) {
      entryDescription = make_shared<string>(boost::any_cast<string>(m["EntryDescription"]));
    }
  }


  virtual ~AddEntriesToAclRequestAclEntries() = default;
};
class AddEntriesToAclRequest : public Darabonba::Model {
public:
  shared_ptr<vector<AddEntriesToAclRequestAclEntries>> aclEntries{};
  shared_ptr<string> aclId{};
  shared_ptr<string> clientToken{};
  shared_ptr<bool> dryRun{};
  shared_ptr<string> regionId{};

  AddEntriesToAclRequest() {}

  explicit AddEntriesToAclRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aclEntries) {
      vector<boost::any> temp1;
      for(auto item1:*aclEntries){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AclEntries"] = boost::any(temp1);
    }
    if (aclId) {
      res["AclId"] = boost::any(*aclId);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (dryRun) {
      res["DryRun"] = boost::any(*dryRun);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AclEntries") != m.end() && !m["AclEntries"].empty()) {
      if (typeid(vector<boost::any>) == m["AclEntries"].type()) {
        vector<AddEntriesToAclRequestAclEntries> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AclEntries"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            AddEntriesToAclRequestAclEntries model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        aclEntries = make_shared<vector<AddEntriesToAclRequestAclEntries>>(expect1);
      }
    }
    if (m.find("AclId") != m.end() && !m["AclId"].empty()) {
      aclId = make_shared<string>(boost::any_cast<string>(m["AclId"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("DryRun") != m.end() && !m["DryRun"].empty()) {
      dryRun = make_shared<bool>(boost::any_cast<bool>(m["DryRun"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~AddEntriesToAclRequest() = default;
};
class AddEntriesToAclResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> aclId{};
  shared_ptr<string> requestId{};

  AddEntriesToAclResponseBody() {}

  explicit AddEntriesToAclResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aclId) {
      res["AclId"] = boost::any(*aclId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AclId") != m.end() && !m["AclId"].empty()) {
      aclId = make_shared<string>(boost::any_cast<string>(m["AclId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AddEntriesToAclResponseBody() = default;
};
class AddEntriesToAclResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddEntriesToAclResponseBody> body{};

  AddEntriesToAclResponse() {}

  explicit AddEntriesToAclResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddEntriesToAclResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddEntriesToAclResponseBody>(model1);
      }
    }
  }


  virtual ~AddEntriesToAclResponse() = default;
};
class AssociateAclsWithListenerRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> aclIds{};
  shared_ptr<string> aclType{};
  shared_ptr<string> clientToken{};
  shared_ptr<bool> dryRun{};
  shared_ptr<string> listenerId{};
  shared_ptr<string> regionId{};

  AssociateAclsWithListenerRequest() {}

  explicit AssociateAclsWithListenerRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aclIds) {
      res["AclIds"] = boost::any(*aclIds);
    }
    if (aclType) {
      res["AclType"] = boost::any(*aclType);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (dryRun) {
      res["DryRun"] = boost::any(*dryRun);
    }
    if (listenerId) {
      res["ListenerId"] = boost::any(*listenerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AclIds") != m.end() && !m["AclIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["AclIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["AclIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      aclIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("AclType") != m.end() && !m["AclType"].empty()) {
      aclType = make_shared<string>(boost::any_cast<string>(m["AclType"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("DryRun") != m.end() && !m["DryRun"].empty()) {
      dryRun = make_shared<bool>(boost::any_cast<bool>(m["DryRun"]));
    }
    if (m.find("ListenerId") != m.end() && !m["ListenerId"].empty()) {
      listenerId = make_shared<string>(boost::any_cast<string>(m["ListenerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~AssociateAclsWithListenerRequest() = default;
};
class AssociateAclsWithListenerResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<string>> aclIds{};
  shared_ptr<string> listenerId{};
  shared_ptr<string> requestId{};

  AssociateAclsWithListenerResponseBody() {}

  explicit AssociateAclsWithListenerResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aclIds) {
      res["AclIds"] = boost::any(*aclIds);
    }
    if (listenerId) {
      res["ListenerId"] = boost::any(*listenerId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AclIds") != m.end() && !m["AclIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["AclIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["AclIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      aclIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ListenerId") != m.end() && !m["ListenerId"].empty()) {
      listenerId = make_shared<string>(boost::any_cast<string>(m["ListenerId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AssociateAclsWithListenerResponseBody() = default;
};
class AssociateAclsWithListenerResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AssociateAclsWithListenerResponseBody> body{};

  AssociateAclsWithListenerResponse() {}

  explicit AssociateAclsWithListenerResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AssociateAclsWithListenerResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AssociateAclsWithListenerResponseBody>(model1);
      }
    }
  }


  virtual ~AssociateAclsWithListenerResponse() = default;
};
class AssociateAdditionalCertificatesWithListenerRequestCertificates : public Darabonba::Model {
public:
  shared_ptr<string> domain{};
  shared_ptr<string> id{};

  AssociateAdditionalCertificatesWithListenerRequestCertificates() {}

  explicit AssociateAdditionalCertificatesWithListenerRequestCertificates(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
  }


  virtual ~AssociateAdditionalCertificatesWithListenerRequestCertificates() = default;
};
class AssociateAdditionalCertificatesWithListenerRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceleratorId{};
  shared_ptr<vector<AssociateAdditionalCertificatesWithListenerRequestCertificates>> certificates{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> listenerId{};
  shared_ptr<string> regionId{};

  AssociateAdditionalCertificatesWithListenerRequest() {}

  explicit AssociateAdditionalCertificatesWithListenerRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceleratorId) {
      res["AcceleratorId"] = boost::any(*acceleratorId);
    }
    if (certificates) {
      vector<boost::any> temp1;
      for(auto item1:*certificates){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Certificates"] = boost::any(temp1);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (listenerId) {
      res["ListenerId"] = boost::any(*listenerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceleratorId") != m.end() && !m["AcceleratorId"].empty()) {
      acceleratorId = make_shared<string>(boost::any_cast<string>(m["AcceleratorId"]));
    }
    if (m.find("Certificates") != m.end() && !m["Certificates"].empty()) {
      if (typeid(vector<boost::any>) == m["Certificates"].type()) {
        vector<AssociateAdditionalCertificatesWithListenerRequestCertificates> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Certificates"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            AssociateAdditionalCertificatesWithListenerRequestCertificates model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        certificates = make_shared<vector<AssociateAdditionalCertificatesWithListenerRequestCertificates>>(expect1);
      }
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("ListenerId") != m.end() && !m["ListenerId"].empty()) {
      listenerId = make_shared<string>(boost::any_cast<string>(m["ListenerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~AssociateAdditionalCertificatesWithListenerRequest() = default;
};
class AssociateAdditionalCertificatesWithListenerResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> listenerId{};
  shared_ptr<string> requestId{};

  AssociateAdditionalCertificatesWithListenerResponseBody() {}

  explicit AssociateAdditionalCertificatesWithListenerResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (listenerId) {
      res["ListenerId"] = boost::any(*listenerId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ListenerId") != m.end() && !m["ListenerId"].empty()) {
      listenerId = make_shared<string>(boost::any_cast<string>(m["ListenerId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AssociateAdditionalCertificatesWithListenerResponseBody() = default;
};
class AssociateAdditionalCertificatesWithListenerResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AssociateAdditionalCertificatesWithListenerResponseBody> body{};

  AssociateAdditionalCertificatesWithListenerResponse() {}

  explicit AssociateAdditionalCertificatesWithListenerResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AssociateAdditionalCertificatesWithListenerResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AssociateAdditionalCertificatesWithListenerResponseBody>(model1);
      }
    }
  }


  virtual ~AssociateAdditionalCertificatesWithListenerResponse() = default;
};
class AttachDdosToAcceleratorRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceleratorId{};
  shared_ptr<string> ddosId{};
  shared_ptr<string> ddosRegionId{};
  shared_ptr<string> regionId{};

  AttachDdosToAcceleratorRequest() {}

  explicit AttachDdosToAcceleratorRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceleratorId) {
      res["AcceleratorId"] = boost::any(*acceleratorId);
    }
    if (ddosId) {
      res["DdosId"] = boost::any(*ddosId);
    }
    if (ddosRegionId) {
      res["DdosRegionId"] = boost::any(*ddosRegionId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceleratorId") != m.end() && !m["AcceleratorId"].empty()) {
      acceleratorId = make_shared<string>(boost::any_cast<string>(m["AcceleratorId"]));
    }
    if (m.find("DdosId") != m.end() && !m["DdosId"].empty()) {
      ddosId = make_shared<string>(boost::any_cast<string>(m["DdosId"]));
    }
    if (m.find("DdosRegionId") != m.end() && !m["DdosRegionId"].empty()) {
      ddosRegionId = make_shared<string>(boost::any_cast<string>(m["DdosRegionId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~AttachDdosToAcceleratorRequest() = default;
};
class AttachDdosToAcceleratorResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> ddosId{};
  shared_ptr<string> gaId{};
  shared_ptr<string> requestId{};

  AttachDdosToAcceleratorResponseBody() {}

  explicit AttachDdosToAcceleratorResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ddosId) {
      res["DdosId"] = boost::any(*ddosId);
    }
    if (gaId) {
      res["GaId"] = boost::any(*gaId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DdosId") != m.end() && !m["DdosId"].empty()) {
      ddosId = make_shared<string>(boost::any_cast<string>(m["DdosId"]));
    }
    if (m.find("GaId") != m.end() && !m["GaId"].empty()) {
      gaId = make_shared<string>(boost::any_cast<string>(m["GaId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AttachDdosToAcceleratorResponseBody() = default;
};
class AttachDdosToAcceleratorResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AttachDdosToAcceleratorResponseBody> body{};

  AttachDdosToAcceleratorResponse() {}

  explicit AttachDdosToAcceleratorResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AttachDdosToAcceleratorResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AttachDdosToAcceleratorResponseBody>(model1);
      }
    }
  }


  virtual ~AttachDdosToAcceleratorResponse() = default;
};
class AttachLogStoreToEndpointGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceleratorId{};
  shared_ptr<string> clientToken{};
  shared_ptr<vector<string>> endpointGroupIds{};
  shared_ptr<string> listenerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> slsLogStoreName{};
  shared_ptr<string> slsProjectName{};
  shared_ptr<string> slsRegionId{};

  AttachLogStoreToEndpointGroupRequest() {}

  explicit AttachLogStoreToEndpointGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceleratorId) {
      res["AcceleratorId"] = boost::any(*acceleratorId);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (endpointGroupIds) {
      res["EndpointGroupIds"] = boost::any(*endpointGroupIds);
    }
    if (listenerId) {
      res["ListenerId"] = boost::any(*listenerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (slsLogStoreName) {
      res["SlsLogStoreName"] = boost::any(*slsLogStoreName);
    }
    if (slsProjectName) {
      res["SlsProjectName"] = boost::any(*slsProjectName);
    }
    if (slsRegionId) {
      res["SlsRegionId"] = boost::any(*slsRegionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceleratorId") != m.end() && !m["AcceleratorId"].empty()) {
      acceleratorId = make_shared<string>(boost::any_cast<string>(m["AcceleratorId"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("EndpointGroupIds") != m.end() && !m["EndpointGroupIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["EndpointGroupIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["EndpointGroupIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      endpointGroupIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ListenerId") != m.end() && !m["ListenerId"].empty()) {
      listenerId = make_shared<string>(boost::any_cast<string>(m["ListenerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SlsLogStoreName") != m.end() && !m["SlsLogStoreName"].empty()) {
      slsLogStoreName = make_shared<string>(boost::any_cast<string>(m["SlsLogStoreName"]));
    }
    if (m.find("SlsProjectName") != m.end() && !m["SlsProjectName"].empty()) {
      slsProjectName = make_shared<string>(boost::any_cast<string>(m["SlsProjectName"]));
    }
    if (m.find("SlsRegionId") != m.end() && !m["SlsRegionId"].empty()) {
      slsRegionId = make_shared<string>(boost::any_cast<string>(m["SlsRegionId"]));
    }
  }


  virtual ~AttachLogStoreToEndpointGroupRequest() = default;
};
class AttachLogStoreToEndpointGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  AttachLogStoreToEndpointGroupResponseBody() {}

  explicit AttachLogStoreToEndpointGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AttachLogStoreToEndpointGroupResponseBody() = default;
};
class AttachLogStoreToEndpointGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AttachLogStoreToEndpointGroupResponseBody> body{};

  AttachLogStoreToEndpointGroupResponse() {}

  explicit AttachLogStoreToEndpointGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AttachLogStoreToEndpointGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AttachLogStoreToEndpointGroupResponseBody>(model1);
      }
    }
  }


  virtual ~AttachLogStoreToEndpointGroupResponse() = default;
};
class BandwidthPackageAddAcceleratorRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceleratorId{};
  shared_ptr<string> bandwidthPackageId{};
  shared_ptr<string> regionId{};

  BandwidthPackageAddAcceleratorRequest() {}

  explicit BandwidthPackageAddAcceleratorRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceleratorId) {
      res["AcceleratorId"] = boost::any(*acceleratorId);
    }
    if (bandwidthPackageId) {
      res["BandwidthPackageId"] = boost::any(*bandwidthPackageId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceleratorId") != m.end() && !m["AcceleratorId"].empty()) {
      acceleratorId = make_shared<string>(boost::any_cast<string>(m["AcceleratorId"]));
    }
    if (m.find("BandwidthPackageId") != m.end() && !m["BandwidthPackageId"].empty()) {
      bandwidthPackageId = make_shared<string>(boost::any_cast<string>(m["BandwidthPackageId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~BandwidthPackageAddAcceleratorRequest() = default;
};
class BandwidthPackageAddAcceleratorResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<string>> accelerators{};
  shared_ptr<string> bandwidthPackageId{};
  shared_ptr<string> requestId{};

  BandwidthPackageAddAcceleratorResponseBody() {}

  explicit BandwidthPackageAddAcceleratorResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accelerators) {
      res["Accelerators"] = boost::any(*accelerators);
    }
    if (bandwidthPackageId) {
      res["BandwidthPackageId"] = boost::any(*bandwidthPackageId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Accelerators") != m.end() && !m["Accelerators"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Accelerators"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Accelerators"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      accelerators = make_shared<vector<string>>(toVec1);
    }
    if (m.find("BandwidthPackageId") != m.end() && !m["BandwidthPackageId"].empty()) {
      bandwidthPackageId = make_shared<string>(boost::any_cast<string>(m["BandwidthPackageId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~BandwidthPackageAddAcceleratorResponseBody() = default;
};
class BandwidthPackageAddAcceleratorResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<BandwidthPackageAddAcceleratorResponseBody> body{};

  BandwidthPackageAddAcceleratorResponse() {}

  explicit BandwidthPackageAddAcceleratorResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        BandwidthPackageAddAcceleratorResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<BandwidthPackageAddAcceleratorResponseBody>(model1);
      }
    }
  }


  virtual ~BandwidthPackageAddAcceleratorResponse() = default;
};
class BandwidthPackageRemoveAcceleratorRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceleratorId{};
  shared_ptr<string> bandwidthPackageId{};
  shared_ptr<string> regionId{};

  BandwidthPackageRemoveAcceleratorRequest() {}

  explicit BandwidthPackageRemoveAcceleratorRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceleratorId) {
      res["AcceleratorId"] = boost::any(*acceleratorId);
    }
    if (bandwidthPackageId) {
      res["BandwidthPackageId"] = boost::any(*bandwidthPackageId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceleratorId") != m.end() && !m["AcceleratorId"].empty()) {
      acceleratorId = make_shared<string>(boost::any_cast<string>(m["AcceleratorId"]));
    }
    if (m.find("BandwidthPackageId") != m.end() && !m["BandwidthPackageId"].empty()) {
      bandwidthPackageId = make_shared<string>(boost::any_cast<string>(m["BandwidthPackageId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~BandwidthPackageRemoveAcceleratorRequest() = default;
};
class BandwidthPackageRemoveAcceleratorResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<string>> accelerators{};
  shared_ptr<string> bandwidthPackageId{};
  shared_ptr<string> requestId{};

  BandwidthPackageRemoveAcceleratorResponseBody() {}

  explicit BandwidthPackageRemoveAcceleratorResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accelerators) {
      res["Accelerators"] = boost::any(*accelerators);
    }
    if (bandwidthPackageId) {
      res["BandwidthPackageId"] = boost::any(*bandwidthPackageId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Accelerators") != m.end() && !m["Accelerators"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Accelerators"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Accelerators"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      accelerators = make_shared<vector<string>>(toVec1);
    }
    if (m.find("BandwidthPackageId") != m.end() && !m["BandwidthPackageId"].empty()) {
      bandwidthPackageId = make_shared<string>(boost::any_cast<string>(m["BandwidthPackageId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~BandwidthPackageRemoveAcceleratorResponseBody() = default;
};
class BandwidthPackageRemoveAcceleratorResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<BandwidthPackageRemoveAcceleratorResponseBody> body{};

  BandwidthPackageRemoveAcceleratorResponse() {}

  explicit BandwidthPackageRemoveAcceleratorResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        BandwidthPackageRemoveAcceleratorResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<BandwidthPackageRemoveAcceleratorResponseBody>(model1);
      }
    }
  }


  virtual ~BandwidthPackageRemoveAcceleratorResponse() = default;
};
class ChangeResourceGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> newResourceGroupId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceId{};
  shared_ptr<string> resourceType{};

  ChangeResourceGroupRequest() {}

  explicit ChangeResourceGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (newResourceGroupId) {
      res["NewResourceGroupId"] = boost::any(*newResourceGroupId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("NewResourceGroupId") != m.end() && !m["NewResourceGroupId"].empty()) {
      newResourceGroupId = make_shared<string>(boost::any_cast<string>(m["NewResourceGroupId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      resourceId = make_shared<string>(boost::any_cast<string>(m["ResourceId"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
  }


  virtual ~ChangeResourceGroupRequest() = default;
};
class ChangeResourceGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ChangeResourceGroupResponseBody() {}

  explicit ChangeResourceGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ChangeResourceGroupResponseBody() = default;
};
class ChangeResourceGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ChangeResourceGroupResponseBody> body{};

  ChangeResourceGroupResponse() {}

  explicit ChangeResourceGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ChangeResourceGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ChangeResourceGroupResponseBody>(model1);
      }
    }
  }


  virtual ~ChangeResourceGroupResponse() = default;
};
class ConfigEndpointProbeRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> enable{};
  shared_ptr<string> endpoint{};
  shared_ptr<string> endpointGroupId{};
  shared_ptr<string> endpointType{};
  shared_ptr<string> probePort{};
  shared_ptr<string> probeProtocol{};
  shared_ptr<string> regionId{};

  ConfigEndpointProbeRequest() {}

  explicit ConfigEndpointProbeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (enable) {
      res["Enable"] = boost::any(*enable);
    }
    if (endpoint) {
      res["Endpoint"] = boost::any(*endpoint);
    }
    if (endpointGroupId) {
      res["EndpointGroupId"] = boost::any(*endpointGroupId);
    }
    if (endpointType) {
      res["EndpointType"] = boost::any(*endpointType);
    }
    if (probePort) {
      res["ProbePort"] = boost::any(*probePort);
    }
    if (probeProtocol) {
      res["ProbeProtocol"] = boost::any(*probeProtocol);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("Enable") != m.end() && !m["Enable"].empty()) {
      enable = make_shared<string>(boost::any_cast<string>(m["Enable"]));
    }
    if (m.find("Endpoint") != m.end() && !m["Endpoint"].empty()) {
      endpoint = make_shared<string>(boost::any_cast<string>(m["Endpoint"]));
    }
    if (m.find("EndpointGroupId") != m.end() && !m["EndpointGroupId"].empty()) {
      endpointGroupId = make_shared<string>(boost::any_cast<string>(m["EndpointGroupId"]));
    }
    if (m.find("EndpointType") != m.end() && !m["EndpointType"].empty()) {
      endpointType = make_shared<string>(boost::any_cast<string>(m["EndpointType"]));
    }
    if (m.find("ProbePort") != m.end() && !m["ProbePort"].empty()) {
      probePort = make_shared<string>(boost::any_cast<string>(m["ProbePort"]));
    }
    if (m.find("ProbeProtocol") != m.end() && !m["ProbeProtocol"].empty()) {
      probeProtocol = make_shared<string>(boost::any_cast<string>(m["ProbeProtocol"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~ConfigEndpointProbeRequest() = default;
};
class ConfigEndpointProbeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ConfigEndpointProbeResponseBody() {}

  explicit ConfigEndpointProbeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ConfigEndpointProbeResponseBody() = default;
};
class ConfigEndpointProbeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ConfigEndpointProbeResponseBody> body{};

  ConfigEndpointProbeResponse() {}

  explicit ConfigEndpointProbeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ConfigEndpointProbeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ConfigEndpointProbeResponseBody>(model1);
      }
    }
  }


  virtual ~ConfigEndpointProbeResponse() = default;
};
class CreateAcceleratorRequestIpSetConfig : public Darabonba::Model {
public:
  shared_ptr<string> accessMode{};

  CreateAcceleratorRequestIpSetConfig() {}

  explicit CreateAcceleratorRequestIpSetConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessMode) {
      res["AccessMode"] = boost::any(*accessMode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccessMode") != m.end() && !m["AccessMode"].empty()) {
      accessMode = make_shared<string>(boost::any_cast<string>(m["AccessMode"]));
    }
  }


  virtual ~CreateAcceleratorRequestIpSetConfig() = default;
};
class CreateAcceleratorRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  CreateAcceleratorRequestTag() {}

  explicit CreateAcceleratorRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~CreateAcceleratorRequestTag() = default;
};
class CreateAcceleratorRequest : public Darabonba::Model {
public:
  shared_ptr<bool> autoPay{};
  shared_ptr<bool> autoRenew{};
  shared_ptr<long> autoRenewDuration{};
  shared_ptr<string> autoUseCoupon{};
  shared_ptr<string> bandwidthBillingType{};
  shared_ptr<string> clientToken{};
  shared_ptr<long> duration{};
  shared_ptr<CreateAcceleratorRequestIpSetConfig> ipSetConfig{};
  shared_ptr<string> name{};
  shared_ptr<string> pricingCycle{};
  shared_ptr<string> promotionOptionNo{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> spec{};
  shared_ptr<vector<CreateAcceleratorRequestTag>> tag{};

  CreateAcceleratorRequest() {}

  explicit CreateAcceleratorRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (autoPay) {
      res["AutoPay"] = boost::any(*autoPay);
    }
    if (autoRenew) {
      res["AutoRenew"] = boost::any(*autoRenew);
    }
    if (autoRenewDuration) {
      res["AutoRenewDuration"] = boost::any(*autoRenewDuration);
    }
    if (autoUseCoupon) {
      res["AutoUseCoupon"] = boost::any(*autoUseCoupon);
    }
    if (bandwidthBillingType) {
      res["BandwidthBillingType"] = boost::any(*bandwidthBillingType);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (ipSetConfig) {
      res["IpSetConfig"] = ipSetConfig ? boost::any(ipSetConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (pricingCycle) {
      res["PricingCycle"] = boost::any(*pricingCycle);
    }
    if (promotionOptionNo) {
      res["PromotionOptionNo"] = boost::any(*promotionOptionNo);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (spec) {
      res["Spec"] = boost::any(*spec);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AutoPay") != m.end() && !m["AutoPay"].empty()) {
      autoPay = make_shared<bool>(boost::any_cast<bool>(m["AutoPay"]));
    }
    if (m.find("AutoRenew") != m.end() && !m["AutoRenew"].empty()) {
      autoRenew = make_shared<bool>(boost::any_cast<bool>(m["AutoRenew"]));
    }
    if (m.find("AutoRenewDuration") != m.end() && !m["AutoRenewDuration"].empty()) {
      autoRenewDuration = make_shared<long>(boost::any_cast<long>(m["AutoRenewDuration"]));
    }
    if (m.find("AutoUseCoupon") != m.end() && !m["AutoUseCoupon"].empty()) {
      autoUseCoupon = make_shared<string>(boost::any_cast<string>(m["AutoUseCoupon"]));
    }
    if (m.find("BandwidthBillingType") != m.end() && !m["BandwidthBillingType"].empty()) {
      bandwidthBillingType = make_shared<string>(boost::any_cast<string>(m["BandwidthBillingType"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<long>(boost::any_cast<long>(m["Duration"]));
    }
    if (m.find("IpSetConfig") != m.end() && !m["IpSetConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["IpSetConfig"].type()) {
        CreateAcceleratorRequestIpSetConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["IpSetConfig"]));
        ipSetConfig = make_shared<CreateAcceleratorRequestIpSetConfig>(model1);
      }
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("PricingCycle") != m.end() && !m["PricingCycle"].empty()) {
      pricingCycle = make_shared<string>(boost::any_cast<string>(m["PricingCycle"]));
    }
    if (m.find("PromotionOptionNo") != m.end() && !m["PromotionOptionNo"].empty()) {
      promotionOptionNo = make_shared<string>(boost::any_cast<string>(m["PromotionOptionNo"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("Spec") != m.end() && !m["Spec"].empty()) {
      spec = make_shared<string>(boost::any_cast<string>(m["Spec"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<CreateAcceleratorRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateAcceleratorRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<CreateAcceleratorRequestTag>>(expect1);
      }
    }
  }


  virtual ~CreateAcceleratorRequest() = default;
};
class CreateAcceleratorResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> acceleratorId{};
  shared_ptr<string> orderId{};
  shared_ptr<string> requestId{};

  CreateAcceleratorResponseBody() {}

  explicit CreateAcceleratorResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceleratorId) {
      res["AcceleratorId"] = boost::any(*acceleratorId);
    }
    if (orderId) {
      res["OrderId"] = boost::any(*orderId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceleratorId") != m.end() && !m["AcceleratorId"].empty()) {
      acceleratorId = make_shared<string>(boost::any_cast<string>(m["AcceleratorId"]));
    }
    if (m.find("OrderId") != m.end() && !m["OrderId"].empty()) {
      orderId = make_shared<string>(boost::any_cast<string>(m["OrderId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateAcceleratorResponseBody() = default;
};
class CreateAcceleratorResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateAcceleratorResponseBody> body{};

  CreateAcceleratorResponse() {}

  explicit CreateAcceleratorResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateAcceleratorResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateAcceleratorResponseBody>(model1);
      }
    }
  }


  virtual ~CreateAcceleratorResponse() = default;
};
class CreateAclRequestAclEntries : public Darabonba::Model {
public:
  shared_ptr<string> entry{};
  shared_ptr<string> entryDescription{};

  CreateAclRequestAclEntries() {}

  explicit CreateAclRequestAclEntries(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (entry) {
      res["Entry"] = boost::any(*entry);
    }
    if (entryDescription) {
      res["EntryDescription"] = boost::any(*entryDescription);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Entry") != m.end() && !m["Entry"].empty()) {
      entry = make_shared<string>(boost::any_cast<string>(m["Entry"]));
    }
    if (m.find("EntryDescription") != m.end() && !m["EntryDescription"].empty()) {
      entryDescription = make_shared<string>(boost::any_cast<string>(m["EntryDescription"]));
    }
  }


  virtual ~CreateAclRequestAclEntries() = default;
};
class CreateAclRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  CreateAclRequestTag() {}

  explicit CreateAclRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~CreateAclRequestTag() = default;
};
class CreateAclRequest : public Darabonba::Model {
public:
  shared_ptr<vector<CreateAclRequestAclEntries>> aclEntries{};
  shared_ptr<string> aclName{};
  shared_ptr<string> addressIPVersion{};
  shared_ptr<string> clientToken{};
  shared_ptr<bool> dryRun{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<vector<CreateAclRequestTag>> tag{};

  CreateAclRequest() {}

  explicit CreateAclRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aclEntries) {
      vector<boost::any> temp1;
      for(auto item1:*aclEntries){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AclEntries"] = boost::any(temp1);
    }
    if (aclName) {
      res["AclName"] = boost::any(*aclName);
    }
    if (addressIPVersion) {
      res["AddressIPVersion"] = boost::any(*addressIPVersion);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (dryRun) {
      res["DryRun"] = boost::any(*dryRun);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AclEntries") != m.end() && !m["AclEntries"].empty()) {
      if (typeid(vector<boost::any>) == m["AclEntries"].type()) {
        vector<CreateAclRequestAclEntries> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AclEntries"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateAclRequestAclEntries model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        aclEntries = make_shared<vector<CreateAclRequestAclEntries>>(expect1);
      }
    }
    if (m.find("AclName") != m.end() && !m["AclName"].empty()) {
      aclName = make_shared<string>(boost::any_cast<string>(m["AclName"]));
    }
    if (m.find("AddressIPVersion") != m.end() && !m["AddressIPVersion"].empty()) {
      addressIPVersion = make_shared<string>(boost::any_cast<string>(m["AddressIPVersion"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("DryRun") != m.end() && !m["DryRun"].empty()) {
      dryRun = make_shared<bool>(boost::any_cast<bool>(m["DryRun"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<CreateAclRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateAclRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<CreateAclRequestTag>>(expect1);
      }
    }
  }


  virtual ~CreateAclRequest() = default;
};
class CreateAclResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> aclId{};
  shared_ptr<string> requestId{};

  CreateAclResponseBody() {}

  explicit CreateAclResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aclId) {
      res["AclId"] = boost::any(*aclId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AclId") != m.end() && !m["AclId"].empty()) {
      aclId = make_shared<string>(boost::any_cast<string>(m["AclId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateAclResponseBody() = default;
};
class CreateAclResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateAclResponseBody> body{};

  CreateAclResponse() {}

  explicit CreateAclResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateAclResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateAclResponseBody>(model1);
      }
    }
  }


  virtual ~CreateAclResponse() = default;
};
class CreateApplicationMonitorRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceleratorId{};
  shared_ptr<string> address{};
  shared_ptr<string> clientToken{};
  shared_ptr<bool> detectEnable{};
  shared_ptr<long> detectThreshold{};
  shared_ptr<long> detectTimes{};
  shared_ptr<string> listenerId{};
  shared_ptr<string> optionsJson{};
  shared_ptr<string> regionId{};
  shared_ptr<long> silenceTime{};
  shared_ptr<string> taskName{};

  CreateApplicationMonitorRequest() {}

  explicit CreateApplicationMonitorRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceleratorId) {
      res["AcceleratorId"] = boost::any(*acceleratorId);
    }
    if (address) {
      res["Address"] = boost::any(*address);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (detectEnable) {
      res["DetectEnable"] = boost::any(*detectEnable);
    }
    if (detectThreshold) {
      res["DetectThreshold"] = boost::any(*detectThreshold);
    }
    if (detectTimes) {
      res["DetectTimes"] = boost::any(*detectTimes);
    }
    if (listenerId) {
      res["ListenerId"] = boost::any(*listenerId);
    }
    if (optionsJson) {
      res["OptionsJson"] = boost::any(*optionsJson);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (silenceTime) {
      res["SilenceTime"] = boost::any(*silenceTime);
    }
    if (taskName) {
      res["TaskName"] = boost::any(*taskName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceleratorId") != m.end() && !m["AcceleratorId"].empty()) {
      acceleratorId = make_shared<string>(boost::any_cast<string>(m["AcceleratorId"]));
    }
    if (m.find("Address") != m.end() && !m["Address"].empty()) {
      address = make_shared<string>(boost::any_cast<string>(m["Address"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("DetectEnable") != m.end() && !m["DetectEnable"].empty()) {
      detectEnable = make_shared<bool>(boost::any_cast<bool>(m["DetectEnable"]));
    }
    if (m.find("DetectThreshold") != m.end() && !m["DetectThreshold"].empty()) {
      detectThreshold = make_shared<long>(boost::any_cast<long>(m["DetectThreshold"]));
    }
    if (m.find("DetectTimes") != m.end() && !m["DetectTimes"].empty()) {
      detectTimes = make_shared<long>(boost::any_cast<long>(m["DetectTimes"]));
    }
    if (m.find("ListenerId") != m.end() && !m["ListenerId"].empty()) {
      listenerId = make_shared<string>(boost::any_cast<string>(m["ListenerId"]));
    }
    if (m.find("OptionsJson") != m.end() && !m["OptionsJson"].empty()) {
      optionsJson = make_shared<string>(boost::any_cast<string>(m["OptionsJson"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SilenceTime") != m.end() && !m["SilenceTime"].empty()) {
      silenceTime = make_shared<long>(boost::any_cast<long>(m["SilenceTime"]));
    }
    if (m.find("TaskName") != m.end() && !m["TaskName"].empty()) {
      taskName = make_shared<string>(boost::any_cast<string>(m["TaskName"]));
    }
  }


  virtual ~CreateApplicationMonitorRequest() = default;
};
class CreateApplicationMonitorResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> taskId{};

  CreateApplicationMonitorResponseBody() {}

  explicit CreateApplicationMonitorResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
  }


  virtual ~CreateApplicationMonitorResponseBody() = default;
};
class CreateApplicationMonitorResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateApplicationMonitorResponseBody> body{};

  CreateApplicationMonitorResponse() {}

  explicit CreateApplicationMonitorResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateApplicationMonitorResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateApplicationMonitorResponseBody>(model1);
      }
    }
  }


  virtual ~CreateApplicationMonitorResponse() = default;
};
class CreateBandwidthPackageRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  CreateBandwidthPackageRequestTag() {}

  explicit CreateBandwidthPackageRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~CreateBandwidthPackageRequestTag() = default;
};
class CreateBandwidthPackageRequest : public Darabonba::Model {
public:
  shared_ptr<bool> autoPay{};
  shared_ptr<bool> autoRenew{};
  shared_ptr<long> autoRenewDuration{};
  shared_ptr<string> autoUseCoupon{};
  shared_ptr<long> bandwidth{};
  shared_ptr<string> bandwidthType{};
  shared_ptr<string> billingType{};
  shared_ptr<string> cbnGeographicRegionIdA{};
  shared_ptr<string> cbnGeographicRegionIdB{};
  shared_ptr<string> chargeType{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> duration{};
  shared_ptr<string> pricingCycle{};
  shared_ptr<string> promotionOptionNo{};
  shared_ptr<long> ratio{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<vector<CreateBandwidthPackageRequestTag>> tag{};
  shared_ptr<string> type{};

  CreateBandwidthPackageRequest() {}

  explicit CreateBandwidthPackageRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (autoPay) {
      res["AutoPay"] = boost::any(*autoPay);
    }
    if (autoRenew) {
      res["AutoRenew"] = boost::any(*autoRenew);
    }
    if (autoRenewDuration) {
      res["AutoRenewDuration"] = boost::any(*autoRenewDuration);
    }
    if (autoUseCoupon) {
      res["AutoUseCoupon"] = boost::any(*autoUseCoupon);
    }
    if (bandwidth) {
      res["Bandwidth"] = boost::any(*bandwidth);
    }
    if (bandwidthType) {
      res["BandwidthType"] = boost::any(*bandwidthType);
    }
    if (billingType) {
      res["BillingType"] = boost::any(*billingType);
    }
    if (cbnGeographicRegionIdA) {
      res["CbnGeographicRegionIdA"] = boost::any(*cbnGeographicRegionIdA);
    }
    if (cbnGeographicRegionIdB) {
      res["CbnGeographicRegionIdB"] = boost::any(*cbnGeographicRegionIdB);
    }
    if (chargeType) {
      res["ChargeType"] = boost::any(*chargeType);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (pricingCycle) {
      res["PricingCycle"] = boost::any(*pricingCycle);
    }
    if (promotionOptionNo) {
      res["PromotionOptionNo"] = boost::any(*promotionOptionNo);
    }
    if (ratio) {
      res["Ratio"] = boost::any(*ratio);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AutoPay") != m.end() && !m["AutoPay"].empty()) {
      autoPay = make_shared<bool>(boost::any_cast<bool>(m["AutoPay"]));
    }
    if (m.find("AutoRenew") != m.end() && !m["AutoRenew"].empty()) {
      autoRenew = make_shared<bool>(boost::any_cast<bool>(m["AutoRenew"]));
    }
    if (m.find("AutoRenewDuration") != m.end() && !m["AutoRenewDuration"].empty()) {
      autoRenewDuration = make_shared<long>(boost::any_cast<long>(m["AutoRenewDuration"]));
    }
    if (m.find("AutoUseCoupon") != m.end() && !m["AutoUseCoupon"].empty()) {
      autoUseCoupon = make_shared<string>(boost::any_cast<string>(m["AutoUseCoupon"]));
    }
    if (m.find("Bandwidth") != m.end() && !m["Bandwidth"].empty()) {
      bandwidth = make_shared<long>(boost::any_cast<long>(m["Bandwidth"]));
    }
    if (m.find("BandwidthType") != m.end() && !m["BandwidthType"].empty()) {
      bandwidthType = make_shared<string>(boost::any_cast<string>(m["BandwidthType"]));
    }
    if (m.find("BillingType") != m.end() && !m["BillingType"].empty()) {
      billingType = make_shared<string>(boost::any_cast<string>(m["BillingType"]));
    }
    if (m.find("CbnGeographicRegionIdA") != m.end() && !m["CbnGeographicRegionIdA"].empty()) {
      cbnGeographicRegionIdA = make_shared<string>(boost::any_cast<string>(m["CbnGeographicRegionIdA"]));
    }
    if (m.find("CbnGeographicRegionIdB") != m.end() && !m["CbnGeographicRegionIdB"].empty()) {
      cbnGeographicRegionIdB = make_shared<string>(boost::any_cast<string>(m["CbnGeographicRegionIdB"]));
    }
    if (m.find("ChargeType") != m.end() && !m["ChargeType"].empty()) {
      chargeType = make_shared<string>(boost::any_cast<string>(m["ChargeType"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("PricingCycle") != m.end() && !m["PricingCycle"].empty()) {
      pricingCycle = make_shared<string>(boost::any_cast<string>(m["PricingCycle"]));
    }
    if (m.find("PromotionOptionNo") != m.end() && !m["PromotionOptionNo"].empty()) {
      promotionOptionNo = make_shared<string>(boost::any_cast<string>(m["PromotionOptionNo"]));
    }
    if (m.find("Ratio") != m.end() && !m["Ratio"].empty()) {
      ratio = make_shared<long>(boost::any_cast<long>(m["Ratio"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<CreateBandwidthPackageRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateBandwidthPackageRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<CreateBandwidthPackageRequestTag>>(expect1);
      }
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~CreateBandwidthPackageRequest() = default;
};
class CreateBandwidthPackageResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> bandwidthPackageId{};
  shared_ptr<string> orderId{};
  shared_ptr<string> requestId{};

  CreateBandwidthPackageResponseBody() {}

  explicit CreateBandwidthPackageResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bandwidthPackageId) {
      res["BandwidthPackageId"] = boost::any(*bandwidthPackageId);
    }
    if (orderId) {
      res["OrderId"] = boost::any(*orderId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BandwidthPackageId") != m.end() && !m["BandwidthPackageId"].empty()) {
      bandwidthPackageId = make_shared<string>(boost::any_cast<string>(m["BandwidthPackageId"]));
    }
    if (m.find("OrderId") != m.end() && !m["OrderId"].empty()) {
      orderId = make_shared<string>(boost::any_cast<string>(m["OrderId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateBandwidthPackageResponseBody() = default;
};
class CreateBandwidthPackageResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateBandwidthPackageResponseBody> body{};

  CreateBandwidthPackageResponse() {}

  explicit CreateBandwidthPackageResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateBandwidthPackageResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateBandwidthPackageResponseBody>(model1);
      }
    }
  }


  virtual ~CreateBandwidthPackageResponse() = default;
};
class CreateBasicAccelerateIpRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceleratorId{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> ipSetId{};
  shared_ptr<string> regionId{};

  CreateBasicAccelerateIpRequest() {}

  explicit CreateBasicAccelerateIpRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceleratorId) {
      res["AcceleratorId"] = boost::any(*acceleratorId);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (ipSetId) {
      res["IpSetId"] = boost::any(*ipSetId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceleratorId") != m.end() && !m["AcceleratorId"].empty()) {
      acceleratorId = make_shared<string>(boost::any_cast<string>(m["AcceleratorId"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("IpSetId") != m.end() && !m["IpSetId"].empty()) {
      ipSetId = make_shared<string>(boost::any_cast<string>(m["IpSetId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~CreateBasicAccelerateIpRequest() = default;
};
class CreateBasicAccelerateIpResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> accelerateIpAddress{};
  shared_ptr<string> accelerateIpId{};
  shared_ptr<string> acceleratorId{};
  shared_ptr<string> ipSetId{};
  shared_ptr<string> requestId{};
  shared_ptr<string> state{};

  CreateBasicAccelerateIpResponseBody() {}

  explicit CreateBasicAccelerateIpResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accelerateIpAddress) {
      res["AccelerateIpAddress"] = boost::any(*accelerateIpAddress);
    }
    if (accelerateIpId) {
      res["AccelerateIpId"] = boost::any(*accelerateIpId);
    }
    if (acceleratorId) {
      res["AcceleratorId"] = boost::any(*acceleratorId);
    }
    if (ipSetId) {
      res["IpSetId"] = boost::any(*ipSetId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccelerateIpAddress") != m.end() && !m["AccelerateIpAddress"].empty()) {
      accelerateIpAddress = make_shared<string>(boost::any_cast<string>(m["AccelerateIpAddress"]));
    }
    if (m.find("AccelerateIpId") != m.end() && !m["AccelerateIpId"].empty()) {
      accelerateIpId = make_shared<string>(boost::any_cast<string>(m["AccelerateIpId"]));
    }
    if (m.find("AcceleratorId") != m.end() && !m["AcceleratorId"].empty()) {
      acceleratorId = make_shared<string>(boost::any_cast<string>(m["AcceleratorId"]));
    }
    if (m.find("IpSetId") != m.end() && !m["IpSetId"].empty()) {
      ipSetId = make_shared<string>(boost::any_cast<string>(m["IpSetId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
  }


  virtual ~CreateBasicAccelerateIpResponseBody() = default;
};
class CreateBasicAccelerateIpResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateBasicAccelerateIpResponseBody> body{};

  CreateBasicAccelerateIpResponse() {}

  explicit CreateBasicAccelerateIpResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateBasicAccelerateIpResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateBasicAccelerateIpResponseBody>(model1);
      }
    }
  }


  virtual ~CreateBasicAccelerateIpResponse() = default;
};
class CreateBasicAccelerateIpEndpointRelationRequest : public Darabonba::Model {
public:
  shared_ptr<string> accelerateIpId{};
  shared_ptr<string> acceleratorId{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> endpointId{};
  shared_ptr<string> regionId{};

  CreateBasicAccelerateIpEndpointRelationRequest() {}

  explicit CreateBasicAccelerateIpEndpointRelationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accelerateIpId) {
      res["AccelerateIpId"] = boost::any(*accelerateIpId);
    }
    if (acceleratorId) {
      res["AcceleratorId"] = boost::any(*acceleratorId);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (endpointId) {
      res["EndpointId"] = boost::any(*endpointId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccelerateIpId") != m.end() && !m["AccelerateIpId"].empty()) {
      accelerateIpId = make_shared<string>(boost::any_cast<string>(m["AccelerateIpId"]));
    }
    if (m.find("AcceleratorId") != m.end() && !m["AcceleratorId"].empty()) {
      acceleratorId = make_shared<string>(boost::any_cast<string>(m["AcceleratorId"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("EndpointId") != m.end() && !m["EndpointId"].empty()) {
      endpointId = make_shared<string>(boost::any_cast<string>(m["EndpointId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~CreateBasicAccelerateIpEndpointRelationRequest() = default;
};
class CreateBasicAccelerateIpEndpointRelationResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> accelerateIpId{};
  shared_ptr<string> acceleratorId{};
  shared_ptr<string> endpointId{};
  shared_ptr<string> requestId{};
  shared_ptr<string> state{};

  CreateBasicAccelerateIpEndpointRelationResponseBody() {}

  explicit CreateBasicAccelerateIpEndpointRelationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accelerateIpId) {
      res["AccelerateIpId"] = boost::any(*accelerateIpId);
    }
    if (acceleratorId) {
      res["AcceleratorId"] = boost::any(*acceleratorId);
    }
    if (endpointId) {
      res["EndpointId"] = boost::any(*endpointId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccelerateIpId") != m.end() && !m["AccelerateIpId"].empty()) {
      accelerateIpId = make_shared<string>(boost::any_cast<string>(m["AccelerateIpId"]));
    }
    if (m.find("AcceleratorId") != m.end() && !m["AcceleratorId"].empty()) {
      acceleratorId = make_shared<string>(boost::any_cast<string>(m["AcceleratorId"]));
    }
    if (m.find("EndpointId") != m.end() && !m["EndpointId"].empty()) {
      endpointId = make_shared<string>(boost::any_cast<string>(m["EndpointId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
  }


  virtual ~CreateBasicAccelerateIpEndpointRelationResponseBody() = default;
};
class CreateBasicAccelerateIpEndpointRelationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateBasicAccelerateIpEndpointRelationResponseBody> body{};

  CreateBasicAccelerateIpEndpointRelationResponse() {}

  explicit CreateBasicAccelerateIpEndpointRelationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateBasicAccelerateIpEndpointRelationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateBasicAccelerateIpEndpointRelationResponseBody>(model1);
      }
    }
  }


  virtual ~CreateBasicAccelerateIpEndpointRelationResponse() = default;
};
class CreateBasicAccelerateIpEndpointRelationsRequestAccelerateIpEndpointRelations : public Darabonba::Model {
public:
  shared_ptr<string> accelerateIpId{};
  shared_ptr<string> endpointId{};

  CreateBasicAccelerateIpEndpointRelationsRequestAccelerateIpEndpointRelations() {}

  explicit CreateBasicAccelerateIpEndpointRelationsRequestAccelerateIpEndpointRelations(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accelerateIpId) {
      res["AccelerateIpId"] = boost::any(*accelerateIpId);
    }
    if (endpointId) {
      res["EndpointId"] = boost::any(*endpointId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccelerateIpId") != m.end() && !m["AccelerateIpId"].empty()) {
      accelerateIpId = make_shared<string>(boost::any_cast<string>(m["AccelerateIpId"]));
    }
    if (m.find("EndpointId") != m.end() && !m["EndpointId"].empty()) {
      endpointId = make_shared<string>(boost::any_cast<string>(m["EndpointId"]));
    }
  }


  virtual ~CreateBasicAccelerateIpEndpointRelationsRequestAccelerateIpEndpointRelations() = default;
};
class CreateBasicAccelerateIpEndpointRelationsRequest : public Darabonba::Model {
public:
  shared_ptr<vector<CreateBasicAccelerateIpEndpointRelationsRequestAccelerateIpEndpointRelations>> accelerateIpEndpointRelations{};
  shared_ptr<string> acceleratorId{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> regionId{};

  CreateBasicAccelerateIpEndpointRelationsRequest() {}

  explicit CreateBasicAccelerateIpEndpointRelationsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accelerateIpEndpointRelations) {
      vector<boost::any> temp1;
      for(auto item1:*accelerateIpEndpointRelations){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AccelerateIpEndpointRelations"] = boost::any(temp1);
    }
    if (acceleratorId) {
      res["AcceleratorId"] = boost::any(*acceleratorId);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccelerateIpEndpointRelations") != m.end() && !m["AccelerateIpEndpointRelations"].empty()) {
      if (typeid(vector<boost::any>) == m["AccelerateIpEndpointRelations"].type()) {
        vector<CreateBasicAccelerateIpEndpointRelationsRequestAccelerateIpEndpointRelations> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AccelerateIpEndpointRelations"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateBasicAccelerateIpEndpointRelationsRequestAccelerateIpEndpointRelations model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        accelerateIpEndpointRelations = make_shared<vector<CreateBasicAccelerateIpEndpointRelationsRequestAccelerateIpEndpointRelations>>(expect1);
      }
    }
    if (m.find("AcceleratorId") != m.end() && !m["AcceleratorId"].empty()) {
      acceleratorId = make_shared<string>(boost::any_cast<string>(m["AcceleratorId"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~CreateBasicAccelerateIpEndpointRelationsRequest() = default;
};
class CreateBasicAccelerateIpEndpointRelationsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> acceleratorId{};
  shared_ptr<string> requestId{};

  CreateBasicAccelerateIpEndpointRelationsResponseBody() {}

  explicit CreateBasicAccelerateIpEndpointRelationsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceleratorId) {
      res["AcceleratorId"] = boost::any(*acceleratorId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceleratorId") != m.end() && !m["AcceleratorId"].empty()) {
      acceleratorId = make_shared<string>(boost::any_cast<string>(m["AcceleratorId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateBasicAccelerateIpEndpointRelationsResponseBody() = default;
};
class CreateBasicAccelerateIpEndpointRelationsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateBasicAccelerateIpEndpointRelationsResponseBody> body{};

  CreateBasicAccelerateIpEndpointRelationsResponse() {}

  explicit CreateBasicAccelerateIpEndpointRelationsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateBasicAccelerateIpEndpointRelationsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateBasicAccelerateIpEndpointRelationsResponseBody>(model1);
      }
    }
  }


  virtual ~CreateBasicAccelerateIpEndpointRelationsResponse() = default;
};
class CreateBasicAcceleratorRequest : public Darabonba::Model {
public:
  shared_ptr<bool> autoPay{};
  shared_ptr<bool> autoRenew{};
  shared_ptr<long> autoRenewDuration{};
  shared_ptr<string> autoUseCoupon{};
  shared_ptr<string> bandwidthBillingType{};
  shared_ptr<string> chargeType{};
  shared_ptr<string> clientToken{};
  shared_ptr<bool> dryRun{};
  shared_ptr<long> duration{};
  shared_ptr<string> pricingCycle{};
  shared_ptr<string> promotionOptionNo{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};

  CreateBasicAcceleratorRequest() {}

  explicit CreateBasicAcceleratorRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (autoPay) {
      res["AutoPay"] = boost::any(*autoPay);
    }
    if (autoRenew) {
      res["AutoRenew"] = boost::any(*autoRenew);
    }
    if (autoRenewDuration) {
      res["AutoRenewDuration"] = boost::any(*autoRenewDuration);
    }
    if (autoUseCoupon) {
      res["AutoUseCoupon"] = boost::any(*autoUseCoupon);
    }
    if (bandwidthBillingType) {
      res["BandwidthBillingType"] = boost::any(*bandwidthBillingType);
    }
    if (chargeType) {
      res["ChargeType"] = boost::any(*chargeType);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (dryRun) {
      res["DryRun"] = boost::any(*dryRun);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (pricingCycle) {
      res["PricingCycle"] = boost::any(*pricingCycle);
    }
    if (promotionOptionNo) {
      res["PromotionOptionNo"] = boost::any(*promotionOptionNo);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AutoPay") != m.end() && !m["AutoPay"].empty()) {
      autoPay = make_shared<bool>(boost::any_cast<bool>(m["AutoPay"]));
    }
    if (m.find("AutoRenew") != m.end() && !m["AutoRenew"].empty()) {
      autoRenew = make_shared<bool>(boost::any_cast<bool>(m["AutoRenew"]));
    }
    if (m.find("AutoRenewDuration") != m.end() && !m["AutoRenewDuration"].empty()) {
      autoRenewDuration = make_shared<long>(boost::any_cast<long>(m["AutoRenewDuration"]));
    }
    if (m.find("AutoUseCoupon") != m.end() && !m["AutoUseCoupon"].empty()) {
      autoUseCoupon = make_shared<string>(boost::any_cast<string>(m["AutoUseCoupon"]));
    }
    if (m.find("BandwidthBillingType") != m.end() && !m["BandwidthBillingType"].empty()) {
      bandwidthBillingType = make_shared<string>(boost::any_cast<string>(m["BandwidthBillingType"]));
    }
    if (m.find("ChargeType") != m.end() && !m["ChargeType"].empty()) {
      chargeType = make_shared<string>(boost::any_cast<string>(m["ChargeType"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("DryRun") != m.end() && !m["DryRun"].empty()) {
      dryRun = make_shared<bool>(boost::any_cast<bool>(m["DryRun"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<long>(boost::any_cast<long>(m["Duration"]));
    }
    if (m.find("PricingCycle") != m.end() && !m["PricingCycle"].empty()) {
      pricingCycle = make_shared<string>(boost::any_cast<string>(m["PricingCycle"]));
    }
    if (m.find("PromotionOptionNo") != m.end() && !m["PromotionOptionNo"].empty()) {
      promotionOptionNo = make_shared<string>(boost::any_cast<string>(m["PromotionOptionNo"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
  }


  virtual ~CreateBasicAcceleratorRequest() = default;
};
class CreateBasicAcceleratorResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> acceleratorId{};
  shared_ptr<string> orderId{};
  shared_ptr<string> requestId{};

  CreateBasicAcceleratorResponseBody() {}

  explicit CreateBasicAcceleratorResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceleratorId) {
      res["AcceleratorId"] = boost::any(*acceleratorId);
    }
    if (orderId) {
      res["OrderId"] = boost::any(*orderId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceleratorId") != m.end() && !m["AcceleratorId"].empty()) {
      acceleratorId = make_shared<string>(boost::any_cast<string>(m["AcceleratorId"]));
    }
    if (m.find("OrderId") != m.end() && !m["OrderId"].empty()) {
      orderId = make_shared<string>(boost::any_cast<string>(m["OrderId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateBasicAcceleratorResponseBody() = default;
};
class CreateBasicAcceleratorResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateBasicAcceleratorResponseBody> body{};

  CreateBasicAcceleratorResponse() {}

  explicit CreateBasicAcceleratorResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateBasicAcceleratorResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateBasicAcceleratorResponseBody>(model1);
      }
    }
  }


  virtual ~CreateBasicAcceleratorResponse() = default;
};
class CreateBasicEndpointRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceleratorId{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> endpointAddress{};
  shared_ptr<string> endpointGroupId{};
  shared_ptr<string> endpointSubAddress{};
  shared_ptr<string> endpointSubAddressType{};
  shared_ptr<string> endpointType{};
  shared_ptr<string> endpointZoneId{};
  shared_ptr<string> name{};
  shared_ptr<string> regionId{};

  CreateBasicEndpointRequest() {}

  explicit CreateBasicEndpointRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceleratorId) {
      res["AcceleratorId"] = boost::any(*acceleratorId);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (endpointAddress) {
      res["EndpointAddress"] = boost::any(*endpointAddress);
    }
    if (endpointGroupId) {
      res["EndpointGroupId"] = boost::any(*endpointGroupId);
    }
    if (endpointSubAddress) {
      res["EndpointSubAddress"] = boost::any(*endpointSubAddress);
    }
    if (endpointSubAddressType) {
      res["EndpointSubAddressType"] = boost::any(*endpointSubAddressType);
    }
    if (endpointType) {
      res["EndpointType"] = boost::any(*endpointType);
    }
    if (endpointZoneId) {
      res["EndpointZoneId"] = boost::any(*endpointZoneId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceleratorId") != m.end() && !m["AcceleratorId"].empty()) {
      acceleratorId = make_shared<string>(boost::any_cast<string>(m["AcceleratorId"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("EndpointAddress") != m.end() && !m["EndpointAddress"].empty()) {
      endpointAddress = make_shared<string>(boost::any_cast<string>(m["EndpointAddress"]));
    }
    if (m.find("EndpointGroupId") != m.end() && !m["EndpointGroupId"].empty()) {
      endpointGroupId = make_shared<string>(boost::any_cast<string>(m["EndpointGroupId"]));
    }
    if (m.find("EndpointSubAddress") != m.end() && !m["EndpointSubAddress"].empty()) {
      endpointSubAddress = make_shared<string>(boost::any_cast<string>(m["EndpointSubAddress"]));
    }
    if (m.find("EndpointSubAddressType") != m.end() && !m["EndpointSubAddressType"].empty()) {
      endpointSubAddressType = make_shared<string>(boost::any_cast<string>(m["EndpointSubAddressType"]));
    }
    if (m.find("EndpointType") != m.end() && !m["EndpointType"].empty()) {
      endpointType = make_shared<string>(boost::any_cast<string>(m["EndpointType"]));
    }
    if (m.find("EndpointZoneId") != m.end() && !m["EndpointZoneId"].empty()) {
      endpointZoneId = make_shared<string>(boost::any_cast<string>(m["EndpointZoneId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~CreateBasicEndpointRequest() = default;
};
class CreateBasicEndpointResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> endpointGroupId{};
  shared_ptr<string> endpointId{};
  shared_ptr<string> requestId{};

  CreateBasicEndpointResponseBody() {}

  explicit CreateBasicEndpointResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endpointGroupId) {
      res["EndpointGroupId"] = boost::any(*endpointGroupId);
    }
    if (endpointId) {
      res["EndpointId"] = boost::any(*endpointId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndpointGroupId") != m.end() && !m["EndpointGroupId"].empty()) {
      endpointGroupId = make_shared<string>(boost::any_cast<string>(m["EndpointGroupId"]));
    }
    if (m.find("EndpointId") != m.end() && !m["EndpointId"].empty()) {
      endpointId = make_shared<string>(boost::any_cast<string>(m["EndpointId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateBasicEndpointResponseBody() = default;
};
class CreateBasicEndpointResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateBasicEndpointResponseBody> body{};

  CreateBasicEndpointResponse() {}

  explicit CreateBasicEndpointResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateBasicEndpointResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateBasicEndpointResponseBody>(model1);
      }
    }
  }


  virtual ~CreateBasicEndpointResponse() = default;
};
class CreateBasicEndpointGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceleratorId{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> description{};
  shared_ptr<string> endpointAddress{};
  shared_ptr<string> endpointGroupRegion{};
  shared_ptr<string> endpointSubAddress{};
  shared_ptr<string> endpointType{};
  shared_ptr<string> name{};
  shared_ptr<string> regionId{};

  CreateBasicEndpointGroupRequest() {}

  explicit CreateBasicEndpointGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceleratorId) {
      res["AcceleratorId"] = boost::any(*acceleratorId);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (endpointAddress) {
      res["EndpointAddress"] = boost::any(*endpointAddress);
    }
    if (endpointGroupRegion) {
      res["EndpointGroupRegion"] = boost::any(*endpointGroupRegion);
    }
    if (endpointSubAddress) {
      res["EndpointSubAddress"] = boost::any(*endpointSubAddress);
    }
    if (endpointType) {
      res["EndpointType"] = boost::any(*endpointType);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceleratorId") != m.end() && !m["AcceleratorId"].empty()) {
      acceleratorId = make_shared<string>(boost::any_cast<string>(m["AcceleratorId"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("EndpointAddress") != m.end() && !m["EndpointAddress"].empty()) {
      endpointAddress = make_shared<string>(boost::any_cast<string>(m["EndpointAddress"]));
    }
    if (m.find("EndpointGroupRegion") != m.end() && !m["EndpointGroupRegion"].empty()) {
      endpointGroupRegion = make_shared<string>(boost::any_cast<string>(m["EndpointGroupRegion"]));
    }
    if (m.find("EndpointSubAddress") != m.end() && !m["EndpointSubAddress"].empty()) {
      endpointSubAddress = make_shared<string>(boost::any_cast<string>(m["EndpointSubAddress"]));
    }
    if (m.find("EndpointType") != m.end() && !m["EndpointType"].empty()) {
      endpointType = make_shared<string>(boost::any_cast<string>(m["EndpointType"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~CreateBasicEndpointGroupRequest() = default;
};
class CreateBasicEndpointGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> endpointGroupId{};
  shared_ptr<string> requestId{};

  CreateBasicEndpointGroupResponseBody() {}

  explicit CreateBasicEndpointGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endpointGroupId) {
      res["EndpointGroupId"] = boost::any(*endpointGroupId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndpointGroupId") != m.end() && !m["EndpointGroupId"].empty()) {
      endpointGroupId = make_shared<string>(boost::any_cast<string>(m["EndpointGroupId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateBasicEndpointGroupResponseBody() = default;
};
class CreateBasicEndpointGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateBasicEndpointGroupResponseBody> body{};

  CreateBasicEndpointGroupResponse() {}

  explicit CreateBasicEndpointGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateBasicEndpointGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateBasicEndpointGroupResponseBody>(model1);
      }
    }
  }


  virtual ~CreateBasicEndpointGroupResponse() = default;
};
class CreateBasicEndpointsRequestEndpoints : public Darabonba::Model {
public:
  shared_ptr<string> endpointAddress{};
  shared_ptr<string> endpointSubAddress{};
  shared_ptr<string> endpointSubAddressType{};
  shared_ptr<string> endpointType{};
  shared_ptr<string> endpointZoneId{};
  shared_ptr<string> name{};

  CreateBasicEndpointsRequestEndpoints() {}

  explicit CreateBasicEndpointsRequestEndpoints(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endpointAddress) {
      res["EndpointAddress"] = boost::any(*endpointAddress);
    }
    if (endpointSubAddress) {
      res["EndpointSubAddress"] = boost::any(*endpointSubAddress);
    }
    if (endpointSubAddressType) {
      res["EndpointSubAddressType"] = boost::any(*endpointSubAddressType);
    }
    if (endpointType) {
      res["EndpointType"] = boost::any(*endpointType);
    }
    if (endpointZoneId) {
      res["EndpointZoneId"] = boost::any(*endpointZoneId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndpointAddress") != m.end() && !m["EndpointAddress"].empty()) {
      endpointAddress = make_shared<string>(boost::any_cast<string>(m["EndpointAddress"]));
    }
    if (m.find("EndpointSubAddress") != m.end() && !m["EndpointSubAddress"].empty()) {
      endpointSubAddress = make_shared<string>(boost::any_cast<string>(m["EndpointSubAddress"]));
    }
    if (m.find("EndpointSubAddressType") != m.end() && !m["EndpointSubAddressType"].empty()) {
      endpointSubAddressType = make_shared<string>(boost::any_cast<string>(m["EndpointSubAddressType"]));
    }
    if (m.find("EndpointType") != m.end() && !m["EndpointType"].empty()) {
      endpointType = make_shared<string>(boost::any_cast<string>(m["EndpointType"]));
    }
    if (m.find("EndpointZoneId") != m.end() && !m["EndpointZoneId"].empty()) {
      endpointZoneId = make_shared<string>(boost::any_cast<string>(m["EndpointZoneId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~CreateBasicEndpointsRequestEndpoints() = default;
};
class CreateBasicEndpointsRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceleratorId{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> endpointGroupId{};
  shared_ptr<vector<CreateBasicEndpointsRequestEndpoints>> endpoints{};
  shared_ptr<string> regionId{};

  CreateBasicEndpointsRequest() {}

  explicit CreateBasicEndpointsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceleratorId) {
      res["AcceleratorId"] = boost::any(*acceleratorId);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (endpointGroupId) {
      res["EndpointGroupId"] = boost::any(*endpointGroupId);
    }
    if (endpoints) {
      vector<boost::any> temp1;
      for(auto item1:*endpoints){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Endpoints"] = boost::any(temp1);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceleratorId") != m.end() && !m["AcceleratorId"].empty()) {
      acceleratorId = make_shared<string>(boost::any_cast<string>(m["AcceleratorId"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("EndpointGroupId") != m.end() && !m["EndpointGroupId"].empty()) {
      endpointGroupId = make_shared<string>(boost::any_cast<string>(m["EndpointGroupId"]));
    }
    if (m.find("Endpoints") != m.end() && !m["Endpoints"].empty()) {
      if (typeid(vector<boost::any>) == m["Endpoints"].type()) {
        vector<CreateBasicEndpointsRequestEndpoints> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Endpoints"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateBasicEndpointsRequestEndpoints model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        endpoints = make_shared<vector<CreateBasicEndpointsRequestEndpoints>>(expect1);
      }
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~CreateBasicEndpointsRequest() = default;
};
class CreateBasicEndpointsResponseBodyEndpoints : public Darabonba::Model {
public:
  shared_ptr<string> endpointAddress{};
  shared_ptr<string> endpointId{};
  shared_ptr<string> endpointSubAddress{};
  shared_ptr<string> endpointType{};

  CreateBasicEndpointsResponseBodyEndpoints() {}

  explicit CreateBasicEndpointsResponseBodyEndpoints(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endpointAddress) {
      res["EndpointAddress"] = boost::any(*endpointAddress);
    }
    if (endpointId) {
      res["EndpointId"] = boost::any(*endpointId);
    }
    if (endpointSubAddress) {
      res["EndpointSubAddress"] = boost::any(*endpointSubAddress);
    }
    if (endpointType) {
      res["EndpointType"] = boost::any(*endpointType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndpointAddress") != m.end() && !m["EndpointAddress"].empty()) {
      endpointAddress = make_shared<string>(boost::any_cast<string>(m["EndpointAddress"]));
    }
    if (m.find("EndpointId") != m.end() && !m["EndpointId"].empty()) {
      endpointId = make_shared<string>(boost::any_cast<string>(m["EndpointId"]));
    }
    if (m.find("EndpointSubAddress") != m.end() && !m["EndpointSubAddress"].empty()) {
      endpointSubAddress = make_shared<string>(boost::any_cast<string>(m["EndpointSubAddress"]));
    }
    if (m.find("EndpointType") != m.end() && !m["EndpointType"].empty()) {
      endpointType = make_shared<string>(boost::any_cast<string>(m["EndpointType"]));
    }
  }


  virtual ~CreateBasicEndpointsResponseBodyEndpoints() = default;
};
class CreateBasicEndpointsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> endpointGroupId{};
  shared_ptr<vector<CreateBasicEndpointsResponseBodyEndpoints>> endpoints{};
  shared_ptr<string> requestId{};

  CreateBasicEndpointsResponseBody() {}

  explicit CreateBasicEndpointsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endpointGroupId) {
      res["EndpointGroupId"] = boost::any(*endpointGroupId);
    }
    if (endpoints) {
      vector<boost::any> temp1;
      for(auto item1:*endpoints){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Endpoints"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndpointGroupId") != m.end() && !m["EndpointGroupId"].empty()) {
      endpointGroupId = make_shared<string>(boost::any_cast<string>(m["EndpointGroupId"]));
    }
    if (m.find("Endpoints") != m.end() && !m["Endpoints"].empty()) {
      if (typeid(vector<boost::any>) == m["Endpoints"].type()) {
        vector<CreateBasicEndpointsResponseBodyEndpoints> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Endpoints"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateBasicEndpointsResponseBodyEndpoints model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        endpoints = make_shared<vector<CreateBasicEndpointsResponseBodyEndpoints>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateBasicEndpointsResponseBody() = default;
};
class CreateBasicEndpointsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateBasicEndpointsResponseBody> body{};

  CreateBasicEndpointsResponse() {}

  explicit CreateBasicEndpointsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateBasicEndpointsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateBasicEndpointsResponseBody>(model1);
      }
    }
  }


  virtual ~CreateBasicEndpointsResponse() = default;
};
class CreateBasicIpSetRequest : public Darabonba::Model {
public:
  shared_ptr<string> accelerateRegionId{};
  shared_ptr<string> acceleratorId{};
  shared_ptr<long> bandwidth{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> ispType{};
  shared_ptr<string> regionId{};

  CreateBasicIpSetRequest() {}

  explicit CreateBasicIpSetRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accelerateRegionId) {
      res["AccelerateRegionId"] = boost::any(*accelerateRegionId);
    }
    if (acceleratorId) {
      res["AcceleratorId"] = boost::any(*acceleratorId);
    }
    if (bandwidth) {
      res["Bandwidth"] = boost::any(*bandwidth);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (ispType) {
      res["IspType"] = boost::any(*ispType);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccelerateRegionId") != m.end() && !m["AccelerateRegionId"].empty()) {
      accelerateRegionId = make_shared<string>(boost::any_cast<string>(m["AccelerateRegionId"]));
    }
    if (m.find("AcceleratorId") != m.end() && !m["AcceleratorId"].empty()) {
      acceleratorId = make_shared<string>(boost::any_cast<string>(m["AcceleratorId"]));
    }
    if (m.find("Bandwidth") != m.end() && !m["Bandwidth"].empty()) {
      bandwidth = make_shared<long>(boost::any_cast<long>(m["Bandwidth"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("IspType") != m.end() && !m["IspType"].empty()) {
      ispType = make_shared<string>(boost::any_cast<string>(m["IspType"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~CreateBasicIpSetRequest() = default;
};
class CreateBasicIpSetResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> ipSetId{};
  shared_ptr<string> requestId{};

  CreateBasicIpSetResponseBody() {}

  explicit CreateBasicIpSetResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ipSetId) {
      res["IpSetId"] = boost::any(*ipSetId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IpSetId") != m.end() && !m["IpSetId"].empty()) {
      ipSetId = make_shared<string>(boost::any_cast<string>(m["IpSetId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateBasicIpSetResponseBody() = default;
};
class CreateBasicIpSetResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateBasicIpSetResponseBody> body{};

  CreateBasicIpSetResponse() {}

  explicit CreateBasicIpSetResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateBasicIpSetResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateBasicIpSetResponseBody>(model1);
      }
    }
  }


  virtual ~CreateBasicIpSetResponse() = default;
};
class CreateCustomRoutingEndpointGroupDestinationsRequestDestinationConfigurations : public Darabonba::Model {
public:
  shared_ptr<long> fromPort{};
  shared_ptr<vector<string>> protocols{};
  shared_ptr<long> toPort{};

  CreateCustomRoutingEndpointGroupDestinationsRequestDestinationConfigurations() {}

  explicit CreateCustomRoutingEndpointGroupDestinationsRequestDestinationConfigurations(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fromPort) {
      res["FromPort"] = boost::any(*fromPort);
    }
    if (protocols) {
      res["Protocols"] = boost::any(*protocols);
    }
    if (toPort) {
      res["ToPort"] = boost::any(*toPort);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FromPort") != m.end() && !m["FromPort"].empty()) {
      fromPort = make_shared<long>(boost::any_cast<long>(m["FromPort"]));
    }
    if (m.find("Protocols") != m.end() && !m["Protocols"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Protocols"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Protocols"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      protocols = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ToPort") != m.end() && !m["ToPort"].empty()) {
      toPort = make_shared<long>(boost::any_cast<long>(m["ToPort"]));
    }
  }


  virtual ~CreateCustomRoutingEndpointGroupDestinationsRequestDestinationConfigurations() = default;
};
class CreateCustomRoutingEndpointGroupDestinationsRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<vector<CreateCustomRoutingEndpointGroupDestinationsRequestDestinationConfigurations>> destinationConfigurations{};
  shared_ptr<bool> dryRun{};
  shared_ptr<string> endpointGroupId{};
  shared_ptr<string> regionId{};

  CreateCustomRoutingEndpointGroupDestinationsRequest() {}

  explicit CreateCustomRoutingEndpointGroupDestinationsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (destinationConfigurations) {
      vector<boost::any> temp1;
      for(auto item1:*destinationConfigurations){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DestinationConfigurations"] = boost::any(temp1);
    }
    if (dryRun) {
      res["DryRun"] = boost::any(*dryRun);
    }
    if (endpointGroupId) {
      res["EndpointGroupId"] = boost::any(*endpointGroupId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("DestinationConfigurations") != m.end() && !m["DestinationConfigurations"].empty()) {
      if (typeid(vector<boost::any>) == m["DestinationConfigurations"].type()) {
        vector<CreateCustomRoutingEndpointGroupDestinationsRequestDestinationConfigurations> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DestinationConfigurations"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateCustomRoutingEndpointGroupDestinationsRequestDestinationConfigurations model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        destinationConfigurations = make_shared<vector<CreateCustomRoutingEndpointGroupDestinationsRequestDestinationConfigurations>>(expect1);
      }
    }
    if (m.find("DryRun") != m.end() && !m["DryRun"].empty()) {
      dryRun = make_shared<bool>(boost::any_cast<bool>(m["DryRun"]));
    }
    if (m.find("EndpointGroupId") != m.end() && !m["EndpointGroupId"].empty()) {
      endpointGroupId = make_shared<string>(boost::any_cast<string>(m["EndpointGroupId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~CreateCustomRoutingEndpointGroupDestinationsRequest() = default;
};
class CreateCustomRoutingEndpointGroupDestinationsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<string>> destinationIds{};
  shared_ptr<string> requestId{};

  CreateCustomRoutingEndpointGroupDestinationsResponseBody() {}

  explicit CreateCustomRoutingEndpointGroupDestinationsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (destinationIds) {
      res["DestinationIds"] = boost::any(*destinationIds);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DestinationIds") != m.end() && !m["DestinationIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DestinationIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DestinationIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      destinationIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateCustomRoutingEndpointGroupDestinationsResponseBody() = default;
};
class CreateCustomRoutingEndpointGroupDestinationsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateCustomRoutingEndpointGroupDestinationsResponseBody> body{};

  CreateCustomRoutingEndpointGroupDestinationsResponse() {}

  explicit CreateCustomRoutingEndpointGroupDestinationsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateCustomRoutingEndpointGroupDestinationsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateCustomRoutingEndpointGroupDestinationsResponseBody>(model1);
      }
    }
  }


  virtual ~CreateCustomRoutingEndpointGroupDestinationsResponse() = default;
};
class CreateCustomRoutingEndpointGroupsRequestEndpointGroupConfigurationsDestinationConfigurations : public Darabonba::Model {
public:
  shared_ptr<long> fromPort{};
  shared_ptr<vector<string>> protocols{};
  shared_ptr<long> toPort{};

  CreateCustomRoutingEndpointGroupsRequestEndpointGroupConfigurationsDestinationConfigurations() {}

  explicit CreateCustomRoutingEndpointGroupsRequestEndpointGroupConfigurationsDestinationConfigurations(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fromPort) {
      res["FromPort"] = boost::any(*fromPort);
    }
    if (protocols) {
      res["Protocols"] = boost::any(*protocols);
    }
    if (toPort) {
      res["ToPort"] = boost::any(*toPort);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FromPort") != m.end() && !m["FromPort"].empty()) {
      fromPort = make_shared<long>(boost::any_cast<long>(m["FromPort"]));
    }
    if (m.find("Protocols") != m.end() && !m["Protocols"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Protocols"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Protocols"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      protocols = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ToPort") != m.end() && !m["ToPort"].empty()) {
      toPort = make_shared<long>(boost::any_cast<long>(m["ToPort"]));
    }
  }


  virtual ~CreateCustomRoutingEndpointGroupsRequestEndpointGroupConfigurationsDestinationConfigurations() = default;
};
class CreateCustomRoutingEndpointGroupsRequestEndpointGroupConfigurationsEndpointConfigurationsPolicyConfigurationsPortRanges : public Darabonba::Model {
public:
  shared_ptr<long> fromPort{};
  shared_ptr<long> toPort{};

  CreateCustomRoutingEndpointGroupsRequestEndpointGroupConfigurationsEndpointConfigurationsPolicyConfigurationsPortRanges() {}

  explicit CreateCustomRoutingEndpointGroupsRequestEndpointGroupConfigurationsEndpointConfigurationsPolicyConfigurationsPortRanges(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fromPort) {
      res["FromPort"] = boost::any(*fromPort);
    }
    if (toPort) {
      res["ToPort"] = boost::any(*toPort);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FromPort") != m.end() && !m["FromPort"].empty()) {
      fromPort = make_shared<long>(boost::any_cast<long>(m["FromPort"]));
    }
    if (m.find("ToPort") != m.end() && !m["ToPort"].empty()) {
      toPort = make_shared<long>(boost::any_cast<long>(m["ToPort"]));
    }
  }


  virtual ~CreateCustomRoutingEndpointGroupsRequestEndpointGroupConfigurationsEndpointConfigurationsPolicyConfigurationsPortRanges() = default;
};
class CreateCustomRoutingEndpointGroupsRequestEndpointGroupConfigurationsEndpointConfigurationsPolicyConfigurations : public Darabonba::Model {
public:
  shared_ptr<string> address{};
  shared_ptr<vector<CreateCustomRoutingEndpointGroupsRequestEndpointGroupConfigurationsEndpointConfigurationsPolicyConfigurationsPortRanges>> portRanges{};

  CreateCustomRoutingEndpointGroupsRequestEndpointGroupConfigurationsEndpointConfigurationsPolicyConfigurations() {}

  explicit CreateCustomRoutingEndpointGroupsRequestEndpointGroupConfigurationsEndpointConfigurationsPolicyConfigurations(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (address) {
      res["Address"] = boost::any(*address);
    }
    if (portRanges) {
      vector<boost::any> temp1;
      for(auto item1:*portRanges){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PortRanges"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Address") != m.end() && !m["Address"].empty()) {
      address = make_shared<string>(boost::any_cast<string>(m["Address"]));
    }
    if (m.find("PortRanges") != m.end() && !m["PortRanges"].empty()) {
      if (typeid(vector<boost::any>) == m["PortRanges"].type()) {
        vector<CreateCustomRoutingEndpointGroupsRequestEndpointGroupConfigurationsEndpointConfigurationsPolicyConfigurationsPortRanges> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PortRanges"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateCustomRoutingEndpointGroupsRequestEndpointGroupConfigurationsEndpointConfigurationsPolicyConfigurationsPortRanges model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        portRanges = make_shared<vector<CreateCustomRoutingEndpointGroupsRequestEndpointGroupConfigurationsEndpointConfigurationsPolicyConfigurationsPortRanges>>(expect1);
      }
    }
  }


  virtual ~CreateCustomRoutingEndpointGroupsRequestEndpointGroupConfigurationsEndpointConfigurationsPolicyConfigurations() = default;
};
class CreateCustomRoutingEndpointGroupsRequestEndpointGroupConfigurationsEndpointConfigurations : public Darabonba::Model {
public:
  shared_ptr<string> endpoint{};
  shared_ptr<vector<CreateCustomRoutingEndpointGroupsRequestEndpointGroupConfigurationsEndpointConfigurationsPolicyConfigurations>> policyConfigurations{};
  shared_ptr<string> trafficToEndpointPolicy{};
  shared_ptr<string> type{};

  CreateCustomRoutingEndpointGroupsRequestEndpointGroupConfigurationsEndpointConfigurations() {}

  explicit CreateCustomRoutingEndpointGroupsRequestEndpointGroupConfigurationsEndpointConfigurations(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endpoint) {
      res["Endpoint"] = boost::any(*endpoint);
    }
    if (policyConfigurations) {
      vector<boost::any> temp1;
      for(auto item1:*policyConfigurations){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PolicyConfigurations"] = boost::any(temp1);
    }
    if (trafficToEndpointPolicy) {
      res["TrafficToEndpointPolicy"] = boost::any(*trafficToEndpointPolicy);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Endpoint") != m.end() && !m["Endpoint"].empty()) {
      endpoint = make_shared<string>(boost::any_cast<string>(m["Endpoint"]));
    }
    if (m.find("PolicyConfigurations") != m.end() && !m["PolicyConfigurations"].empty()) {
      if (typeid(vector<boost::any>) == m["PolicyConfigurations"].type()) {
        vector<CreateCustomRoutingEndpointGroupsRequestEndpointGroupConfigurationsEndpointConfigurationsPolicyConfigurations> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PolicyConfigurations"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateCustomRoutingEndpointGroupsRequestEndpointGroupConfigurationsEndpointConfigurationsPolicyConfigurations model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        policyConfigurations = make_shared<vector<CreateCustomRoutingEndpointGroupsRequestEndpointGroupConfigurationsEndpointConfigurationsPolicyConfigurations>>(expect1);
      }
    }
    if (m.find("TrafficToEndpointPolicy") != m.end() && !m["TrafficToEndpointPolicy"].empty()) {
      trafficToEndpointPolicy = make_shared<string>(boost::any_cast<string>(m["TrafficToEndpointPolicy"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~CreateCustomRoutingEndpointGroupsRequestEndpointGroupConfigurationsEndpointConfigurations() = default;
};
class CreateCustomRoutingEndpointGroupsRequestEndpointGroupConfigurations : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<vector<CreateCustomRoutingEndpointGroupsRequestEndpointGroupConfigurationsDestinationConfigurations>> destinationConfigurations{};
  shared_ptr<vector<CreateCustomRoutingEndpointGroupsRequestEndpointGroupConfigurationsEndpointConfigurations>> endpointConfigurations{};
  shared_ptr<string> endpointGroupRegion{};
  shared_ptr<string> name{};

  CreateCustomRoutingEndpointGroupsRequestEndpointGroupConfigurations() {}

  explicit CreateCustomRoutingEndpointGroupsRequestEndpointGroupConfigurations(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (destinationConfigurations) {
      vector<boost::any> temp1;
      for(auto item1:*destinationConfigurations){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DestinationConfigurations"] = boost::any(temp1);
    }
    if (endpointConfigurations) {
      vector<boost::any> temp1;
      for(auto item1:*endpointConfigurations){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["EndpointConfigurations"] = boost::any(temp1);
    }
    if (endpointGroupRegion) {
      res["EndpointGroupRegion"] = boost::any(*endpointGroupRegion);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DestinationConfigurations") != m.end() && !m["DestinationConfigurations"].empty()) {
      if (typeid(vector<boost::any>) == m["DestinationConfigurations"].type()) {
        vector<CreateCustomRoutingEndpointGroupsRequestEndpointGroupConfigurationsDestinationConfigurations> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DestinationConfigurations"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateCustomRoutingEndpointGroupsRequestEndpointGroupConfigurationsDestinationConfigurations model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        destinationConfigurations = make_shared<vector<CreateCustomRoutingEndpointGroupsRequestEndpointGroupConfigurationsDestinationConfigurations>>(expect1);
      }
    }
    if (m.find("EndpointConfigurations") != m.end() && !m["EndpointConfigurations"].empty()) {
      if (typeid(vector<boost::any>) == m["EndpointConfigurations"].type()) {
        vector<CreateCustomRoutingEndpointGroupsRequestEndpointGroupConfigurationsEndpointConfigurations> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["EndpointConfigurations"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateCustomRoutingEndpointGroupsRequestEndpointGroupConfigurationsEndpointConfigurations model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        endpointConfigurations = make_shared<vector<CreateCustomRoutingEndpointGroupsRequestEndpointGroupConfigurationsEndpointConfigurations>>(expect1);
      }
    }
    if (m.find("EndpointGroupRegion") != m.end() && !m["EndpointGroupRegion"].empty()) {
      endpointGroupRegion = make_shared<string>(boost::any_cast<string>(m["EndpointGroupRegion"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~CreateCustomRoutingEndpointGroupsRequestEndpointGroupConfigurations() = default;
};
class CreateCustomRoutingEndpointGroupsRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceleratorId{};
  shared_ptr<string> clientToken{};
  shared_ptr<bool> dryRun{};
  shared_ptr<vector<CreateCustomRoutingEndpointGroupsRequestEndpointGroupConfigurations>> endpointGroupConfigurations{};
  shared_ptr<string> listenerId{};
  shared_ptr<string> regionId{};

  CreateCustomRoutingEndpointGroupsRequest() {}

  explicit CreateCustomRoutingEndpointGroupsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceleratorId) {
      res["AcceleratorId"] = boost::any(*acceleratorId);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (dryRun) {
      res["DryRun"] = boost::any(*dryRun);
    }
    if (endpointGroupConfigurations) {
      vector<boost::any> temp1;
      for(auto item1:*endpointGroupConfigurations){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["EndpointGroupConfigurations"] = boost::any(temp1);
    }
    if (listenerId) {
      res["ListenerId"] = boost::any(*listenerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceleratorId") != m.end() && !m["AcceleratorId"].empty()) {
      acceleratorId = make_shared<string>(boost::any_cast<string>(m["AcceleratorId"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("DryRun") != m.end() && !m["DryRun"].empty()) {
      dryRun = make_shared<bool>(boost::any_cast<bool>(m["DryRun"]));
    }
    if (m.find("EndpointGroupConfigurations") != m.end() && !m["EndpointGroupConfigurations"].empty()) {
      if (typeid(vector<boost::any>) == m["EndpointGroupConfigurations"].type()) {
        vector<CreateCustomRoutingEndpointGroupsRequestEndpointGroupConfigurations> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["EndpointGroupConfigurations"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateCustomRoutingEndpointGroupsRequestEndpointGroupConfigurations model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        endpointGroupConfigurations = make_shared<vector<CreateCustomRoutingEndpointGroupsRequestEndpointGroupConfigurations>>(expect1);
      }
    }
    if (m.find("ListenerId") != m.end() && !m["ListenerId"].empty()) {
      listenerId = make_shared<string>(boost::any_cast<string>(m["ListenerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~CreateCustomRoutingEndpointGroupsRequest() = default;
};
class CreateCustomRoutingEndpointGroupsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<string>> endpointGroupIds{};
  shared_ptr<string> requestId{};

  CreateCustomRoutingEndpointGroupsResponseBody() {}

  explicit CreateCustomRoutingEndpointGroupsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endpointGroupIds) {
      res["EndpointGroupIds"] = boost::any(*endpointGroupIds);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndpointGroupIds") != m.end() && !m["EndpointGroupIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["EndpointGroupIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["EndpointGroupIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      endpointGroupIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateCustomRoutingEndpointGroupsResponseBody() = default;
};
class CreateCustomRoutingEndpointGroupsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateCustomRoutingEndpointGroupsResponseBody> body{};

  CreateCustomRoutingEndpointGroupsResponse() {}

  explicit CreateCustomRoutingEndpointGroupsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateCustomRoutingEndpointGroupsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateCustomRoutingEndpointGroupsResponseBody>(model1);
      }
    }
  }


  virtual ~CreateCustomRoutingEndpointGroupsResponse() = default;
};
class CreateCustomRoutingEndpointTrafficPoliciesRequestPolicyConfigurationsPortRanges : public Darabonba::Model {
public:
  shared_ptr<long> fromPort{};
  shared_ptr<long> toPort{};

  CreateCustomRoutingEndpointTrafficPoliciesRequestPolicyConfigurationsPortRanges() {}

  explicit CreateCustomRoutingEndpointTrafficPoliciesRequestPolicyConfigurationsPortRanges(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fromPort) {
      res["FromPort"] = boost::any(*fromPort);
    }
    if (toPort) {
      res["ToPort"] = boost::any(*toPort);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FromPort") != m.end() && !m["FromPort"].empty()) {
      fromPort = make_shared<long>(boost::any_cast<long>(m["FromPort"]));
    }
    if (m.find("ToPort") != m.end() && !m["ToPort"].empty()) {
      toPort = make_shared<long>(boost::any_cast<long>(m["ToPort"]));
    }
  }


  virtual ~CreateCustomRoutingEndpointTrafficPoliciesRequestPolicyConfigurationsPortRanges() = default;
};
class CreateCustomRoutingEndpointTrafficPoliciesRequestPolicyConfigurations : public Darabonba::Model {
public:
  shared_ptr<string> address{};
  shared_ptr<vector<CreateCustomRoutingEndpointTrafficPoliciesRequestPolicyConfigurationsPortRanges>> portRanges{};

  CreateCustomRoutingEndpointTrafficPoliciesRequestPolicyConfigurations() {}

  explicit CreateCustomRoutingEndpointTrafficPoliciesRequestPolicyConfigurations(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (address) {
      res["Address"] = boost::any(*address);
    }
    if (portRanges) {
      vector<boost::any> temp1;
      for(auto item1:*portRanges){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PortRanges"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Address") != m.end() && !m["Address"].empty()) {
      address = make_shared<string>(boost::any_cast<string>(m["Address"]));
    }
    if (m.find("PortRanges") != m.end() && !m["PortRanges"].empty()) {
      if (typeid(vector<boost::any>) == m["PortRanges"].type()) {
        vector<CreateCustomRoutingEndpointTrafficPoliciesRequestPolicyConfigurationsPortRanges> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PortRanges"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateCustomRoutingEndpointTrafficPoliciesRequestPolicyConfigurationsPortRanges model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        portRanges = make_shared<vector<CreateCustomRoutingEndpointTrafficPoliciesRequestPolicyConfigurationsPortRanges>>(expect1);
      }
    }
  }


  virtual ~CreateCustomRoutingEndpointTrafficPoliciesRequestPolicyConfigurations() = default;
};
class CreateCustomRoutingEndpointTrafficPoliciesRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> endpointId{};
  shared_ptr<vector<CreateCustomRoutingEndpointTrafficPoliciesRequestPolicyConfigurations>> policyConfigurations{};
  shared_ptr<string> regionId{};

  CreateCustomRoutingEndpointTrafficPoliciesRequest() {}

  explicit CreateCustomRoutingEndpointTrafficPoliciesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (endpointId) {
      res["EndpointId"] = boost::any(*endpointId);
    }
    if (policyConfigurations) {
      vector<boost::any> temp1;
      for(auto item1:*policyConfigurations){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PolicyConfigurations"] = boost::any(temp1);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("EndpointId") != m.end() && !m["EndpointId"].empty()) {
      endpointId = make_shared<string>(boost::any_cast<string>(m["EndpointId"]));
    }
    if (m.find("PolicyConfigurations") != m.end() && !m["PolicyConfigurations"].empty()) {
      if (typeid(vector<boost::any>) == m["PolicyConfigurations"].type()) {
        vector<CreateCustomRoutingEndpointTrafficPoliciesRequestPolicyConfigurations> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PolicyConfigurations"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateCustomRoutingEndpointTrafficPoliciesRequestPolicyConfigurations model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        policyConfigurations = make_shared<vector<CreateCustomRoutingEndpointTrafficPoliciesRequestPolicyConfigurations>>(expect1);
      }
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~CreateCustomRoutingEndpointTrafficPoliciesRequest() = default;
};
class CreateCustomRoutingEndpointTrafficPoliciesResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<string>> policyIds{};
  shared_ptr<string> requestId{};

  CreateCustomRoutingEndpointTrafficPoliciesResponseBody() {}

  explicit CreateCustomRoutingEndpointTrafficPoliciesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (policyIds) {
      res["PolicyIds"] = boost::any(*policyIds);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PolicyIds") != m.end() && !m["PolicyIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["PolicyIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["PolicyIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      policyIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateCustomRoutingEndpointTrafficPoliciesResponseBody() = default;
};
class CreateCustomRoutingEndpointTrafficPoliciesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateCustomRoutingEndpointTrafficPoliciesResponseBody> body{};

  CreateCustomRoutingEndpointTrafficPoliciesResponse() {}

  explicit CreateCustomRoutingEndpointTrafficPoliciesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateCustomRoutingEndpointTrafficPoliciesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateCustomRoutingEndpointTrafficPoliciesResponseBody>(model1);
      }
    }
  }


  virtual ~CreateCustomRoutingEndpointTrafficPoliciesResponse() = default;
};
class CreateCustomRoutingEndpointsRequestEndpointConfigurationsPolicyConfigurationsPortRanges : public Darabonba::Model {
public:
  shared_ptr<long> fromPort{};
  shared_ptr<long> toPort{};

  CreateCustomRoutingEndpointsRequestEndpointConfigurationsPolicyConfigurationsPortRanges() {}

  explicit CreateCustomRoutingEndpointsRequestEndpointConfigurationsPolicyConfigurationsPortRanges(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fromPort) {
      res["FromPort"] = boost::any(*fromPort);
    }
    if (toPort) {
      res["ToPort"] = boost::any(*toPort);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FromPort") != m.end() && !m["FromPort"].empty()) {
      fromPort = make_shared<long>(boost::any_cast<long>(m["FromPort"]));
    }
    if (m.find("ToPort") != m.end() && !m["ToPort"].empty()) {
      toPort = make_shared<long>(boost::any_cast<long>(m["ToPort"]));
    }
  }


  virtual ~CreateCustomRoutingEndpointsRequestEndpointConfigurationsPolicyConfigurationsPortRanges() = default;
};
class CreateCustomRoutingEndpointsRequestEndpointConfigurationsPolicyConfigurations : public Darabonba::Model {
public:
  shared_ptr<string> address{};
  shared_ptr<vector<CreateCustomRoutingEndpointsRequestEndpointConfigurationsPolicyConfigurationsPortRanges>> portRanges{};

  CreateCustomRoutingEndpointsRequestEndpointConfigurationsPolicyConfigurations() {}

  explicit CreateCustomRoutingEndpointsRequestEndpointConfigurationsPolicyConfigurations(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (address) {
      res["Address"] = boost::any(*address);
    }
    if (portRanges) {
      vector<boost::any> temp1;
      for(auto item1:*portRanges){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PortRanges"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Address") != m.end() && !m["Address"].empty()) {
      address = make_shared<string>(boost::any_cast<string>(m["Address"]));
    }
    if (m.find("PortRanges") != m.end() && !m["PortRanges"].empty()) {
      if (typeid(vector<boost::any>) == m["PortRanges"].type()) {
        vector<CreateCustomRoutingEndpointsRequestEndpointConfigurationsPolicyConfigurationsPortRanges> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PortRanges"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateCustomRoutingEndpointsRequestEndpointConfigurationsPolicyConfigurationsPortRanges model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        portRanges = make_shared<vector<CreateCustomRoutingEndpointsRequestEndpointConfigurationsPolicyConfigurationsPortRanges>>(expect1);
      }
    }
  }


  virtual ~CreateCustomRoutingEndpointsRequestEndpointConfigurationsPolicyConfigurations() = default;
};
class CreateCustomRoutingEndpointsRequestEndpointConfigurations : public Darabonba::Model {
public:
  shared_ptr<string> endpoint{};
  shared_ptr<vector<CreateCustomRoutingEndpointsRequestEndpointConfigurationsPolicyConfigurations>> policyConfigurations{};
  shared_ptr<string> trafficToEndpointPolicy{};
  shared_ptr<string> type{};

  CreateCustomRoutingEndpointsRequestEndpointConfigurations() {}

  explicit CreateCustomRoutingEndpointsRequestEndpointConfigurations(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endpoint) {
      res["Endpoint"] = boost::any(*endpoint);
    }
    if (policyConfigurations) {
      vector<boost::any> temp1;
      for(auto item1:*policyConfigurations){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PolicyConfigurations"] = boost::any(temp1);
    }
    if (trafficToEndpointPolicy) {
      res["TrafficToEndpointPolicy"] = boost::any(*trafficToEndpointPolicy);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Endpoint") != m.end() && !m["Endpoint"].empty()) {
      endpoint = make_shared<string>(boost::any_cast<string>(m["Endpoint"]));
    }
    if (m.find("PolicyConfigurations") != m.end() && !m["PolicyConfigurations"].empty()) {
      if (typeid(vector<boost::any>) == m["PolicyConfigurations"].type()) {
        vector<CreateCustomRoutingEndpointsRequestEndpointConfigurationsPolicyConfigurations> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PolicyConfigurations"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateCustomRoutingEndpointsRequestEndpointConfigurationsPolicyConfigurations model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        policyConfigurations = make_shared<vector<CreateCustomRoutingEndpointsRequestEndpointConfigurationsPolicyConfigurations>>(expect1);
      }
    }
    if (m.find("TrafficToEndpointPolicy") != m.end() && !m["TrafficToEndpointPolicy"].empty()) {
      trafficToEndpointPolicy = make_shared<string>(boost::any_cast<string>(m["TrafficToEndpointPolicy"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~CreateCustomRoutingEndpointsRequestEndpointConfigurations() = default;
};
class CreateCustomRoutingEndpointsRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<vector<CreateCustomRoutingEndpointsRequestEndpointConfigurations>> endpointConfigurations{};
  shared_ptr<string> endpointGroupId{};
  shared_ptr<string> regionId{};

  CreateCustomRoutingEndpointsRequest() {}

  explicit CreateCustomRoutingEndpointsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (endpointConfigurations) {
      vector<boost::any> temp1;
      for(auto item1:*endpointConfigurations){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["EndpointConfigurations"] = boost::any(temp1);
    }
    if (endpointGroupId) {
      res["EndpointGroupId"] = boost::any(*endpointGroupId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("EndpointConfigurations") != m.end() && !m["EndpointConfigurations"].empty()) {
      if (typeid(vector<boost::any>) == m["EndpointConfigurations"].type()) {
        vector<CreateCustomRoutingEndpointsRequestEndpointConfigurations> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["EndpointConfigurations"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateCustomRoutingEndpointsRequestEndpointConfigurations model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        endpointConfigurations = make_shared<vector<CreateCustomRoutingEndpointsRequestEndpointConfigurations>>(expect1);
      }
    }
    if (m.find("EndpointGroupId") != m.end() && !m["EndpointGroupId"].empty()) {
      endpointGroupId = make_shared<string>(boost::any_cast<string>(m["EndpointGroupId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~CreateCustomRoutingEndpointsRequest() = default;
};
class CreateCustomRoutingEndpointsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<string>> endpointIds{};
  shared_ptr<string> requestId{};

  CreateCustomRoutingEndpointsResponseBody() {}

  explicit CreateCustomRoutingEndpointsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endpointIds) {
      res["EndpointIds"] = boost::any(*endpointIds);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndpointIds") != m.end() && !m["EndpointIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["EndpointIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["EndpointIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      endpointIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateCustomRoutingEndpointsResponseBody() = default;
};
class CreateCustomRoutingEndpointsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateCustomRoutingEndpointsResponseBody> body{};

  CreateCustomRoutingEndpointsResponse() {}

  explicit CreateCustomRoutingEndpointsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateCustomRoutingEndpointsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateCustomRoutingEndpointsResponseBody>(model1);
      }
    }
  }


  virtual ~CreateCustomRoutingEndpointsResponse() = default;
};
class CreateDomainRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> acceleratorIds{};
  shared_ptr<string> domain{};
  shared_ptr<string> regionId{};

  CreateDomainRequest() {}

  explicit CreateDomainRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceleratorIds) {
      res["AcceleratorIds"] = boost::any(*acceleratorIds);
    }
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceleratorIds") != m.end() && !m["AcceleratorIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["AcceleratorIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["AcceleratorIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      acceleratorIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~CreateDomainRequest() = default;
};
class CreateDomainResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  CreateDomainResponseBody() {}

  explicit CreateDomainResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateDomainResponseBody() = default;
};
class CreateDomainResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateDomainResponseBody> body{};

  CreateDomainResponse() {}

  explicit CreateDomainResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateDomainResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateDomainResponseBody>(model1);
      }
    }
  }


  virtual ~CreateDomainResponse() = default;
};
class CreateEndpointGroupRequestEndpointConfigurations : public Darabonba::Model {
public:
  shared_ptr<bool> enableClientIPPreservation{};
  shared_ptr<string> endpoint{};
  shared_ptr<string> type{};
  shared_ptr<long> weight{};

  CreateEndpointGroupRequestEndpointConfigurations() {}

  explicit CreateEndpointGroupRequestEndpointConfigurations(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (enableClientIPPreservation) {
      res["EnableClientIPPreservation"] = boost::any(*enableClientIPPreservation);
    }
    if (endpoint) {
      res["Endpoint"] = boost::any(*endpoint);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (weight) {
      res["Weight"] = boost::any(*weight);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EnableClientIPPreservation") != m.end() && !m["EnableClientIPPreservation"].empty()) {
      enableClientIPPreservation = make_shared<bool>(boost::any_cast<bool>(m["EnableClientIPPreservation"]));
    }
    if (m.find("Endpoint") != m.end() && !m["Endpoint"].empty()) {
      endpoint = make_shared<string>(boost::any_cast<string>(m["Endpoint"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Weight") != m.end() && !m["Weight"].empty()) {
      weight = make_shared<long>(boost::any_cast<long>(m["Weight"]));
    }
  }


  virtual ~CreateEndpointGroupRequestEndpointConfigurations() = default;
};
class CreateEndpointGroupRequestPortOverrides : public Darabonba::Model {
public:
  shared_ptr<long> endpointPort{};
  shared_ptr<long> listenerPort{};

  CreateEndpointGroupRequestPortOverrides() {}

  explicit CreateEndpointGroupRequestPortOverrides(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endpointPort) {
      res["EndpointPort"] = boost::any(*endpointPort);
    }
    if (listenerPort) {
      res["ListenerPort"] = boost::any(*listenerPort);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndpointPort") != m.end() && !m["EndpointPort"].empty()) {
      endpointPort = make_shared<long>(boost::any_cast<long>(m["EndpointPort"]));
    }
    if (m.find("ListenerPort") != m.end() && !m["ListenerPort"].empty()) {
      listenerPort = make_shared<long>(boost::any_cast<long>(m["ListenerPort"]));
    }
  }


  virtual ~CreateEndpointGroupRequestPortOverrides() = default;
};
class CreateEndpointGroupRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  CreateEndpointGroupRequestTag() {}

  explicit CreateEndpointGroupRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~CreateEndpointGroupRequestTag() = default;
};
class CreateEndpointGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceleratorId{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> description{};
  shared_ptr<vector<CreateEndpointGroupRequestEndpointConfigurations>> endpointConfigurations{};
  shared_ptr<string> endpointGroupRegion{};
  shared_ptr<string> endpointGroupType{};
  shared_ptr<string> endpointRequestProtocol{};
  shared_ptr<bool> healthCheckEnabled{};
  shared_ptr<long> healthCheckIntervalSeconds{};
  shared_ptr<string> healthCheckPath{};
  shared_ptr<long> healthCheckPort{};
  shared_ptr<string> healthCheckProtocol{};
  shared_ptr<string> listenerId{};
  shared_ptr<string> name{};
  shared_ptr<vector<CreateEndpointGroupRequestPortOverrides>> portOverrides{};
  shared_ptr<string> regionId{};
  shared_ptr<vector<CreateEndpointGroupRequestTag>> tag{};
  shared_ptr<long> thresholdCount{};
  shared_ptr<long> trafficPercentage{};

  CreateEndpointGroupRequest() {}

  explicit CreateEndpointGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceleratorId) {
      res["AcceleratorId"] = boost::any(*acceleratorId);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (endpointConfigurations) {
      vector<boost::any> temp1;
      for(auto item1:*endpointConfigurations){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["EndpointConfigurations"] = boost::any(temp1);
    }
    if (endpointGroupRegion) {
      res["EndpointGroupRegion"] = boost::any(*endpointGroupRegion);
    }
    if (endpointGroupType) {
      res["EndpointGroupType"] = boost::any(*endpointGroupType);
    }
    if (endpointRequestProtocol) {
      res["EndpointRequestProtocol"] = boost::any(*endpointRequestProtocol);
    }
    if (healthCheckEnabled) {
      res["HealthCheckEnabled"] = boost::any(*healthCheckEnabled);
    }
    if (healthCheckIntervalSeconds) {
      res["HealthCheckIntervalSeconds"] = boost::any(*healthCheckIntervalSeconds);
    }
    if (healthCheckPath) {
      res["HealthCheckPath"] = boost::any(*healthCheckPath);
    }
    if (healthCheckPort) {
      res["HealthCheckPort"] = boost::any(*healthCheckPort);
    }
    if (healthCheckProtocol) {
      res["HealthCheckProtocol"] = boost::any(*healthCheckProtocol);
    }
    if (listenerId) {
      res["ListenerId"] = boost::any(*listenerId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (portOverrides) {
      vector<boost::any> temp1;
      for(auto item1:*portOverrides){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PortOverrides"] = boost::any(temp1);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    if (thresholdCount) {
      res["ThresholdCount"] = boost::any(*thresholdCount);
    }
    if (trafficPercentage) {
      res["TrafficPercentage"] = boost::any(*trafficPercentage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceleratorId") != m.end() && !m["AcceleratorId"].empty()) {
      acceleratorId = make_shared<string>(boost::any_cast<string>(m["AcceleratorId"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("EndpointConfigurations") != m.end() && !m["EndpointConfigurations"].empty()) {
      if (typeid(vector<boost::any>) == m["EndpointConfigurations"].type()) {
        vector<CreateEndpointGroupRequestEndpointConfigurations> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["EndpointConfigurations"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateEndpointGroupRequestEndpointConfigurations model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        endpointConfigurations = make_shared<vector<CreateEndpointGroupRequestEndpointConfigurations>>(expect1);
      }
    }
    if (m.find("EndpointGroupRegion") != m.end() && !m["EndpointGroupRegion"].empty()) {
      endpointGroupRegion = make_shared<string>(boost::any_cast<string>(m["EndpointGroupRegion"]));
    }
    if (m.find("EndpointGroupType") != m.end() && !m["EndpointGroupType"].empty()) {
      endpointGroupType = make_shared<string>(boost::any_cast<string>(m["EndpointGroupType"]));
    }
    if (m.find("EndpointRequestProtocol") != m.end() && !m["EndpointRequestProtocol"].empty()) {
      endpointRequestProtocol = make_shared<string>(boost::any_cast<string>(m["EndpointRequestProtocol"]));
    }
    if (m.find("HealthCheckEnabled") != m.end() && !m["HealthCheckEnabled"].empty()) {
      healthCheckEnabled = make_shared<bool>(boost::any_cast<bool>(m["HealthCheckEnabled"]));
    }
    if (m.find("HealthCheckIntervalSeconds") != m.end() && !m["HealthCheckIntervalSeconds"].empty()) {
      healthCheckIntervalSeconds = make_shared<long>(boost::any_cast<long>(m["HealthCheckIntervalSeconds"]));
    }
    if (m.find("HealthCheckPath") != m.end() && !m["HealthCheckPath"].empty()) {
      healthCheckPath = make_shared<string>(boost::any_cast<string>(m["HealthCheckPath"]));
    }
    if (m.find("HealthCheckPort") != m.end() && !m["HealthCheckPort"].empty()) {
      healthCheckPort = make_shared<long>(boost::any_cast<long>(m["HealthCheckPort"]));
    }
    if (m.find("HealthCheckProtocol") != m.end() && !m["HealthCheckProtocol"].empty()) {
      healthCheckProtocol = make_shared<string>(boost::any_cast<string>(m["HealthCheckProtocol"]));
    }
    if (m.find("ListenerId") != m.end() && !m["ListenerId"].empty()) {
      listenerId = make_shared<string>(boost::any_cast<string>(m["ListenerId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("PortOverrides") != m.end() && !m["PortOverrides"].empty()) {
      if (typeid(vector<boost::any>) == m["PortOverrides"].type()) {
        vector<CreateEndpointGroupRequestPortOverrides> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PortOverrides"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateEndpointGroupRequestPortOverrides model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        portOverrides = make_shared<vector<CreateEndpointGroupRequestPortOverrides>>(expect1);
      }
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<CreateEndpointGroupRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateEndpointGroupRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<CreateEndpointGroupRequestTag>>(expect1);
      }
    }
    if (m.find("ThresholdCount") != m.end() && !m["ThresholdCount"].empty()) {
      thresholdCount = make_shared<long>(boost::any_cast<long>(m["ThresholdCount"]));
    }
    if (m.find("TrafficPercentage") != m.end() && !m["TrafficPercentage"].empty()) {
      trafficPercentage = make_shared<long>(boost::any_cast<long>(m["TrafficPercentage"]));
    }
  }


  virtual ~CreateEndpointGroupRequest() = default;
};
class CreateEndpointGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> endpointGroupId{};
  shared_ptr<string> requestId{};

  CreateEndpointGroupResponseBody() {}

  explicit CreateEndpointGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endpointGroupId) {
      res["EndpointGroupId"] = boost::any(*endpointGroupId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndpointGroupId") != m.end() && !m["EndpointGroupId"].empty()) {
      endpointGroupId = make_shared<string>(boost::any_cast<string>(m["EndpointGroupId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateEndpointGroupResponseBody() = default;
};
class CreateEndpointGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateEndpointGroupResponseBody> body{};

  CreateEndpointGroupResponse() {}

  explicit CreateEndpointGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateEndpointGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateEndpointGroupResponseBody>(model1);
      }
    }
  }


  virtual ~CreateEndpointGroupResponse() = default;
};
class CreateEndpointGroupsRequestEndpointGroupConfigurationsEndpointConfigurations : public Darabonba::Model {
public:
  shared_ptr<string> endpoint{};
  shared_ptr<string> type{};
  shared_ptr<long> weight{};

  CreateEndpointGroupsRequestEndpointGroupConfigurationsEndpointConfigurations() {}

  explicit CreateEndpointGroupsRequestEndpointGroupConfigurationsEndpointConfigurations(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endpoint) {
      res["Endpoint"] = boost::any(*endpoint);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (weight) {
      res["Weight"] = boost::any(*weight);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Endpoint") != m.end() && !m["Endpoint"].empty()) {
      endpoint = make_shared<string>(boost::any_cast<string>(m["Endpoint"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Weight") != m.end() && !m["Weight"].empty()) {
      weight = make_shared<long>(boost::any_cast<long>(m["Weight"]));
    }
  }


  virtual ~CreateEndpointGroupsRequestEndpointGroupConfigurationsEndpointConfigurations() = default;
};
class CreateEndpointGroupsRequestEndpointGroupConfigurationsPortOverrides : public Darabonba::Model {
public:
  shared_ptr<long> endpointPort{};
  shared_ptr<long> listenerPort{};

  CreateEndpointGroupsRequestEndpointGroupConfigurationsPortOverrides() {}

  explicit CreateEndpointGroupsRequestEndpointGroupConfigurationsPortOverrides(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endpointPort) {
      res["EndpointPort"] = boost::any(*endpointPort);
    }
    if (listenerPort) {
      res["ListenerPort"] = boost::any(*listenerPort);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndpointPort") != m.end() && !m["EndpointPort"].empty()) {
      endpointPort = make_shared<long>(boost::any_cast<long>(m["EndpointPort"]));
    }
    if (m.find("ListenerPort") != m.end() && !m["ListenerPort"].empty()) {
      listenerPort = make_shared<long>(boost::any_cast<long>(m["ListenerPort"]));
    }
  }


  virtual ~CreateEndpointGroupsRequestEndpointGroupConfigurationsPortOverrides() = default;
};
class CreateEndpointGroupsRequestEndpointGroupConfigurations : public Darabonba::Model {
public:
  shared_ptr<bool> enableClientIPPreservationProxyProtocol{};
  shared_ptr<bool> enableClientIPPreservationToa{};
  shared_ptr<vector<CreateEndpointGroupsRequestEndpointGroupConfigurationsEndpointConfigurations>> endpointConfigurations{};
  shared_ptr<string> endpointGroupDescription{};
  shared_ptr<string> endpointGroupName{};
  shared_ptr<string> endpointGroupRegion{};
  shared_ptr<string> endpointGroupType{};
  shared_ptr<string> endpointRequestProtocol{};
  shared_ptr<bool> healthCheckEnabled{};
  shared_ptr<long> healthCheckIntervalSeconds{};
  shared_ptr<string> healthCheckPath{};
  shared_ptr<long> healthCheckPort{};
  shared_ptr<string> healthCheckProtocol{};
  shared_ptr<vector<CreateEndpointGroupsRequestEndpointGroupConfigurationsPortOverrides>> portOverrides{};
  shared_ptr<long> thresholdCount{};
  shared_ptr<long> trafficPercentage{};

  CreateEndpointGroupsRequestEndpointGroupConfigurations() {}

  explicit CreateEndpointGroupsRequestEndpointGroupConfigurations(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (enableClientIPPreservationProxyProtocol) {
      res["EnableClientIPPreservationProxyProtocol"] = boost::any(*enableClientIPPreservationProxyProtocol);
    }
    if (enableClientIPPreservationToa) {
      res["EnableClientIPPreservationToa"] = boost::any(*enableClientIPPreservationToa);
    }
    if (endpointConfigurations) {
      vector<boost::any> temp1;
      for(auto item1:*endpointConfigurations){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["EndpointConfigurations"] = boost::any(temp1);
    }
    if (endpointGroupDescription) {
      res["EndpointGroupDescription"] = boost::any(*endpointGroupDescription);
    }
    if (endpointGroupName) {
      res["EndpointGroupName"] = boost::any(*endpointGroupName);
    }
    if (endpointGroupRegion) {
      res["EndpointGroupRegion"] = boost::any(*endpointGroupRegion);
    }
    if (endpointGroupType) {
      res["EndpointGroupType"] = boost::any(*endpointGroupType);
    }
    if (endpointRequestProtocol) {
      res["EndpointRequestProtocol"] = boost::any(*endpointRequestProtocol);
    }
    if (healthCheckEnabled) {
      res["HealthCheckEnabled"] = boost::any(*healthCheckEnabled);
    }
    if (healthCheckIntervalSeconds) {
      res["HealthCheckIntervalSeconds"] = boost::any(*healthCheckIntervalSeconds);
    }
    if (healthCheckPath) {
      res["HealthCheckPath"] = boost::any(*healthCheckPath);
    }
    if (healthCheckPort) {
      res["HealthCheckPort"] = boost::any(*healthCheckPort);
    }
    if (healthCheckProtocol) {
      res["HealthCheckProtocol"] = boost::any(*healthCheckProtocol);
    }
    if (portOverrides) {
      vector<boost::any> temp1;
      for(auto item1:*portOverrides){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PortOverrides"] = boost::any(temp1);
    }
    if (thresholdCount) {
      res["ThresholdCount"] = boost::any(*thresholdCount);
    }
    if (trafficPercentage) {
      res["TrafficPercentage"] = boost::any(*trafficPercentage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EnableClientIPPreservationProxyProtocol") != m.end() && !m["EnableClientIPPreservationProxyProtocol"].empty()) {
      enableClientIPPreservationProxyProtocol = make_shared<bool>(boost::any_cast<bool>(m["EnableClientIPPreservationProxyProtocol"]));
    }
    if (m.find("EnableClientIPPreservationToa") != m.end() && !m["EnableClientIPPreservationToa"].empty()) {
      enableClientIPPreservationToa = make_shared<bool>(boost::any_cast<bool>(m["EnableClientIPPreservationToa"]));
    }
    if (m.find("EndpointConfigurations") != m.end() && !m["EndpointConfigurations"].empty()) {
      if (typeid(vector<boost::any>) == m["EndpointConfigurations"].type()) {
        vector<CreateEndpointGroupsRequestEndpointGroupConfigurationsEndpointConfigurations> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["EndpointConfigurations"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateEndpointGroupsRequestEndpointGroupConfigurationsEndpointConfigurations model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        endpointConfigurations = make_shared<vector<CreateEndpointGroupsRequestEndpointGroupConfigurationsEndpointConfigurations>>(expect1);
      }
    }
    if (m.find("EndpointGroupDescription") != m.end() && !m["EndpointGroupDescription"].empty()) {
      endpointGroupDescription = make_shared<string>(boost::any_cast<string>(m["EndpointGroupDescription"]));
    }
    if (m.find("EndpointGroupName") != m.end() && !m["EndpointGroupName"].empty()) {
      endpointGroupName = make_shared<string>(boost::any_cast<string>(m["EndpointGroupName"]));
    }
    if (m.find("EndpointGroupRegion") != m.end() && !m["EndpointGroupRegion"].empty()) {
      endpointGroupRegion = make_shared<string>(boost::any_cast<string>(m["EndpointGroupRegion"]));
    }
    if (m.find("EndpointGroupType") != m.end() && !m["EndpointGroupType"].empty()) {
      endpointGroupType = make_shared<string>(boost::any_cast<string>(m["EndpointGroupType"]));
    }
    if (m.find("EndpointRequestProtocol") != m.end() && !m["EndpointRequestProtocol"].empty()) {
      endpointRequestProtocol = make_shared<string>(boost::any_cast<string>(m["EndpointRequestProtocol"]));
    }
    if (m.find("HealthCheckEnabled") != m.end() && !m["HealthCheckEnabled"].empty()) {
      healthCheckEnabled = make_shared<bool>(boost::any_cast<bool>(m["HealthCheckEnabled"]));
    }
    if (m.find("HealthCheckIntervalSeconds") != m.end() && !m["HealthCheckIntervalSeconds"].empty()) {
      healthCheckIntervalSeconds = make_shared<long>(boost::any_cast<long>(m["HealthCheckIntervalSeconds"]));
    }
    if (m.find("HealthCheckPath") != m.end() && !m["HealthCheckPath"].empty()) {
      healthCheckPath = make_shared<string>(boost::any_cast<string>(m["HealthCheckPath"]));
    }
    if (m.find("HealthCheckPort") != m.end() && !m["HealthCheckPort"].empty()) {
      healthCheckPort = make_shared<long>(boost::any_cast<long>(m["HealthCheckPort"]));
    }
    if (m.find("HealthCheckProtocol") != m.end() && !m["HealthCheckProtocol"].empty()) {
      healthCheckProtocol = make_shared<string>(boost::any_cast<string>(m["HealthCheckProtocol"]));
    }
    if (m.find("PortOverrides") != m.end() && !m["PortOverrides"].empty()) {
      if (typeid(vector<boost::any>) == m["PortOverrides"].type()) {
        vector<CreateEndpointGroupsRequestEndpointGroupConfigurationsPortOverrides> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PortOverrides"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateEndpointGroupsRequestEndpointGroupConfigurationsPortOverrides model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        portOverrides = make_shared<vector<CreateEndpointGroupsRequestEndpointGroupConfigurationsPortOverrides>>(expect1);
      }
    }
    if (m.find("ThresholdCount") != m.end() && !m["ThresholdCount"].empty()) {
      thresholdCount = make_shared<long>(boost::any_cast<long>(m["ThresholdCount"]));
    }
    if (m.find("TrafficPercentage") != m.end() && !m["TrafficPercentage"].empty()) {
      trafficPercentage = make_shared<long>(boost::any_cast<long>(m["TrafficPercentage"]));
    }
  }


  virtual ~CreateEndpointGroupsRequestEndpointGroupConfigurations() = default;
};
class CreateEndpointGroupsRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceleratorId{};
  shared_ptr<string> clientToken{};
  shared_ptr<bool> dryRun{};
  shared_ptr<vector<CreateEndpointGroupsRequestEndpointGroupConfigurations>> endpointGroupConfigurations{};
  shared_ptr<string> listenerId{};
  shared_ptr<string> regionId{};

  CreateEndpointGroupsRequest() {}

  explicit CreateEndpointGroupsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceleratorId) {
      res["AcceleratorId"] = boost::any(*acceleratorId);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (dryRun) {
      res["DryRun"] = boost::any(*dryRun);
    }
    if (endpointGroupConfigurations) {
      vector<boost::any> temp1;
      for(auto item1:*endpointGroupConfigurations){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["EndpointGroupConfigurations"] = boost::any(temp1);
    }
    if (listenerId) {
      res["ListenerId"] = boost::any(*listenerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceleratorId") != m.end() && !m["AcceleratorId"].empty()) {
      acceleratorId = make_shared<string>(boost::any_cast<string>(m["AcceleratorId"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("DryRun") != m.end() && !m["DryRun"].empty()) {
      dryRun = make_shared<bool>(boost::any_cast<bool>(m["DryRun"]));
    }
    if (m.find("EndpointGroupConfigurations") != m.end() && !m["EndpointGroupConfigurations"].empty()) {
      if (typeid(vector<boost::any>) == m["EndpointGroupConfigurations"].type()) {
        vector<CreateEndpointGroupsRequestEndpointGroupConfigurations> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["EndpointGroupConfigurations"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateEndpointGroupsRequestEndpointGroupConfigurations model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        endpointGroupConfigurations = make_shared<vector<CreateEndpointGroupsRequestEndpointGroupConfigurations>>(expect1);
      }
    }
    if (m.find("ListenerId") != m.end() && !m["ListenerId"].empty()) {
      listenerId = make_shared<string>(boost::any_cast<string>(m["ListenerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~CreateEndpointGroupsRequest() = default;
};
class CreateEndpointGroupsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<string>> endpointGroupIds{};
  shared_ptr<string> requestId{};

  CreateEndpointGroupsResponseBody() {}

  explicit CreateEndpointGroupsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endpointGroupIds) {
      res["EndpointGroupIds"] = boost::any(*endpointGroupIds);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndpointGroupIds") != m.end() && !m["EndpointGroupIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["EndpointGroupIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["EndpointGroupIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      endpointGroupIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateEndpointGroupsResponseBody() = default;
};
class CreateEndpointGroupsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateEndpointGroupsResponseBody> body{};

  CreateEndpointGroupsResponse() {}

  explicit CreateEndpointGroupsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateEndpointGroupsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateEndpointGroupsResponseBody>(model1);
      }
    }
  }


  virtual ~CreateEndpointGroupsResponse() = default;
};
class CreateForwardingRulesRequestForwardingRulesRuleActionsForwardGroupConfigServerGroupTuples : public Darabonba::Model {
public:
  shared_ptr<string> endpointGroupId{};

  CreateForwardingRulesRequestForwardingRulesRuleActionsForwardGroupConfigServerGroupTuples() {}

  explicit CreateForwardingRulesRequestForwardingRulesRuleActionsForwardGroupConfigServerGroupTuples(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endpointGroupId) {
      res["EndpointGroupId"] = boost::any(*endpointGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndpointGroupId") != m.end() && !m["EndpointGroupId"].empty()) {
      endpointGroupId = make_shared<string>(boost::any_cast<string>(m["EndpointGroupId"]));
    }
  }


  virtual ~CreateForwardingRulesRequestForwardingRulesRuleActionsForwardGroupConfigServerGroupTuples() = default;
};
class CreateForwardingRulesRequestForwardingRulesRuleActionsForwardGroupConfig : public Darabonba::Model {
public:
  shared_ptr<vector<CreateForwardingRulesRequestForwardingRulesRuleActionsForwardGroupConfigServerGroupTuples>> serverGroupTuples{};

  CreateForwardingRulesRequestForwardingRulesRuleActionsForwardGroupConfig() {}

  explicit CreateForwardingRulesRequestForwardingRulesRuleActionsForwardGroupConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (serverGroupTuples) {
      vector<boost::any> temp1;
      for(auto item1:*serverGroupTuples){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ServerGroupTuples"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ServerGroupTuples") != m.end() && !m["ServerGroupTuples"].empty()) {
      if (typeid(vector<boost::any>) == m["ServerGroupTuples"].type()) {
        vector<CreateForwardingRulesRequestForwardingRulesRuleActionsForwardGroupConfigServerGroupTuples> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ServerGroupTuples"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateForwardingRulesRequestForwardingRulesRuleActionsForwardGroupConfigServerGroupTuples model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        serverGroupTuples = make_shared<vector<CreateForwardingRulesRequestForwardingRulesRuleActionsForwardGroupConfigServerGroupTuples>>(expect1);
      }
    }
  }


  virtual ~CreateForwardingRulesRequestForwardingRulesRuleActionsForwardGroupConfig() = default;
};
class CreateForwardingRulesRequestForwardingRulesRuleActions : public Darabonba::Model {
public:
  shared_ptr<CreateForwardingRulesRequestForwardingRulesRuleActionsForwardGroupConfig> forwardGroupConfig{};
  shared_ptr<long> order{};
  shared_ptr<string> ruleActionType{};
  shared_ptr<string> ruleActionValue{};

  CreateForwardingRulesRequestForwardingRulesRuleActions() {}

  explicit CreateForwardingRulesRequestForwardingRulesRuleActions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (forwardGroupConfig) {
      res["ForwardGroupConfig"] = forwardGroupConfig ? boost::any(forwardGroupConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (order) {
      res["Order"] = boost::any(*order);
    }
    if (ruleActionType) {
      res["RuleActionType"] = boost::any(*ruleActionType);
    }
    if (ruleActionValue) {
      res["RuleActionValue"] = boost::any(*ruleActionValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ForwardGroupConfig") != m.end() && !m["ForwardGroupConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["ForwardGroupConfig"].type()) {
        CreateForwardingRulesRequestForwardingRulesRuleActionsForwardGroupConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ForwardGroupConfig"]));
        forwardGroupConfig = make_shared<CreateForwardingRulesRequestForwardingRulesRuleActionsForwardGroupConfig>(model1);
      }
    }
    if (m.find("Order") != m.end() && !m["Order"].empty()) {
      order = make_shared<long>(boost::any_cast<long>(m["Order"]));
    }
    if (m.find("RuleActionType") != m.end() && !m["RuleActionType"].empty()) {
      ruleActionType = make_shared<string>(boost::any_cast<string>(m["RuleActionType"]));
    }
    if (m.find("RuleActionValue") != m.end() && !m["RuleActionValue"].empty()) {
      ruleActionValue = make_shared<string>(boost::any_cast<string>(m["RuleActionValue"]));
    }
  }


  virtual ~CreateForwardingRulesRequestForwardingRulesRuleActions() = default;
};
class CreateForwardingRulesRequestForwardingRulesRuleConditionsHostConfig : public Darabonba::Model {
public:
  shared_ptr<vector<string>> values{};

  CreateForwardingRulesRequestForwardingRulesRuleConditionsHostConfig() {}

  explicit CreateForwardingRulesRequestForwardingRulesRuleConditionsHostConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (values) {
      res["Values"] = boost::any(*values);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Values") != m.end() && !m["Values"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Values"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Values"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      values = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~CreateForwardingRulesRequestForwardingRulesRuleConditionsHostConfig() = default;
};
class CreateForwardingRulesRequestForwardingRulesRuleConditionsPathConfig : public Darabonba::Model {
public:
  shared_ptr<vector<string>> values{};

  CreateForwardingRulesRequestForwardingRulesRuleConditionsPathConfig() {}

  explicit CreateForwardingRulesRequestForwardingRulesRuleConditionsPathConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (values) {
      res["Values"] = boost::any(*values);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Values") != m.end() && !m["Values"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Values"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Values"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      values = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~CreateForwardingRulesRequestForwardingRulesRuleConditionsPathConfig() = default;
};
class CreateForwardingRulesRequestForwardingRulesRuleConditions : public Darabonba::Model {
public:
  shared_ptr<CreateForwardingRulesRequestForwardingRulesRuleConditionsHostConfig> hostConfig{};
  shared_ptr<CreateForwardingRulesRequestForwardingRulesRuleConditionsPathConfig> pathConfig{};
  shared_ptr<string> ruleConditionType{};
  shared_ptr<string> ruleConditionValue{};

  CreateForwardingRulesRequestForwardingRulesRuleConditions() {}

  explicit CreateForwardingRulesRequestForwardingRulesRuleConditions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (hostConfig) {
      res["HostConfig"] = hostConfig ? boost::any(hostConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pathConfig) {
      res["PathConfig"] = pathConfig ? boost::any(pathConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (ruleConditionType) {
      res["RuleConditionType"] = boost::any(*ruleConditionType);
    }
    if (ruleConditionValue) {
      res["RuleConditionValue"] = boost::any(*ruleConditionValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HostConfig") != m.end() && !m["HostConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["HostConfig"].type()) {
        CreateForwardingRulesRequestForwardingRulesRuleConditionsHostConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["HostConfig"]));
        hostConfig = make_shared<CreateForwardingRulesRequestForwardingRulesRuleConditionsHostConfig>(model1);
      }
    }
    if (m.find("PathConfig") != m.end() && !m["PathConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["PathConfig"].type()) {
        CreateForwardingRulesRequestForwardingRulesRuleConditionsPathConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PathConfig"]));
        pathConfig = make_shared<CreateForwardingRulesRequestForwardingRulesRuleConditionsPathConfig>(model1);
      }
    }
    if (m.find("RuleConditionType") != m.end() && !m["RuleConditionType"].empty()) {
      ruleConditionType = make_shared<string>(boost::any_cast<string>(m["RuleConditionType"]));
    }
    if (m.find("RuleConditionValue") != m.end() && !m["RuleConditionValue"].empty()) {
      ruleConditionValue = make_shared<string>(boost::any_cast<string>(m["RuleConditionValue"]));
    }
  }


  virtual ~CreateForwardingRulesRequestForwardingRulesRuleConditions() = default;
};
class CreateForwardingRulesRequestForwardingRules : public Darabonba::Model {
public:
  shared_ptr<string> forwardingRuleName{};
  shared_ptr<long> priority{};
  shared_ptr<vector<CreateForwardingRulesRequestForwardingRulesRuleActions>> ruleActions{};
  shared_ptr<vector<CreateForwardingRulesRequestForwardingRulesRuleConditions>> ruleConditions{};
  shared_ptr<string> ruleDirection{};

  CreateForwardingRulesRequestForwardingRules() {}

  explicit CreateForwardingRulesRequestForwardingRules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (forwardingRuleName) {
      res["ForwardingRuleName"] = boost::any(*forwardingRuleName);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (ruleActions) {
      vector<boost::any> temp1;
      for(auto item1:*ruleActions){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RuleActions"] = boost::any(temp1);
    }
    if (ruleConditions) {
      vector<boost::any> temp1;
      for(auto item1:*ruleConditions){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RuleConditions"] = boost::any(temp1);
    }
    if (ruleDirection) {
      res["RuleDirection"] = boost::any(*ruleDirection);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ForwardingRuleName") != m.end() && !m["ForwardingRuleName"].empty()) {
      forwardingRuleName = make_shared<string>(boost::any_cast<string>(m["ForwardingRuleName"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<long>(boost::any_cast<long>(m["Priority"]));
    }
    if (m.find("RuleActions") != m.end() && !m["RuleActions"].empty()) {
      if (typeid(vector<boost::any>) == m["RuleActions"].type()) {
        vector<CreateForwardingRulesRequestForwardingRulesRuleActions> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RuleActions"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateForwardingRulesRequestForwardingRulesRuleActions model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ruleActions = make_shared<vector<CreateForwardingRulesRequestForwardingRulesRuleActions>>(expect1);
      }
    }
    if (m.find("RuleConditions") != m.end() && !m["RuleConditions"].empty()) {
      if (typeid(vector<boost::any>) == m["RuleConditions"].type()) {
        vector<CreateForwardingRulesRequestForwardingRulesRuleConditions> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RuleConditions"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateForwardingRulesRequestForwardingRulesRuleConditions model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ruleConditions = make_shared<vector<CreateForwardingRulesRequestForwardingRulesRuleConditions>>(expect1);
      }
    }
    if (m.find("RuleDirection") != m.end() && !m["RuleDirection"].empty()) {
      ruleDirection = make_shared<string>(boost::any_cast<string>(m["RuleDirection"]));
    }
  }


  virtual ~CreateForwardingRulesRequestForwardingRules() = default;
};
class CreateForwardingRulesRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceleratorId{};
  shared_ptr<string> clientToken{};
  shared_ptr<vector<CreateForwardingRulesRequestForwardingRules>> forwardingRules{};
  shared_ptr<string> listenerId{};
  shared_ptr<string> regionId{};

  CreateForwardingRulesRequest() {}

  explicit CreateForwardingRulesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceleratorId) {
      res["AcceleratorId"] = boost::any(*acceleratorId);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (forwardingRules) {
      vector<boost::any> temp1;
      for(auto item1:*forwardingRules){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ForwardingRules"] = boost::any(temp1);
    }
    if (listenerId) {
      res["ListenerId"] = boost::any(*listenerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceleratorId") != m.end() && !m["AcceleratorId"].empty()) {
      acceleratorId = make_shared<string>(boost::any_cast<string>(m["AcceleratorId"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("ForwardingRules") != m.end() && !m["ForwardingRules"].empty()) {
      if (typeid(vector<boost::any>) == m["ForwardingRules"].type()) {
        vector<CreateForwardingRulesRequestForwardingRules> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ForwardingRules"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateForwardingRulesRequestForwardingRules model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        forwardingRules = make_shared<vector<CreateForwardingRulesRequestForwardingRules>>(expect1);
      }
    }
    if (m.find("ListenerId") != m.end() && !m["ListenerId"].empty()) {
      listenerId = make_shared<string>(boost::any_cast<string>(m["ListenerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~CreateForwardingRulesRequest() = default;
};
class CreateForwardingRulesResponseBodyForwardingRules : public Darabonba::Model {
public:
  shared_ptr<string> forwardingRuleId{};

  CreateForwardingRulesResponseBodyForwardingRules() {}

  explicit CreateForwardingRulesResponseBodyForwardingRules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (forwardingRuleId) {
      res["ForwardingRuleId"] = boost::any(*forwardingRuleId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ForwardingRuleId") != m.end() && !m["ForwardingRuleId"].empty()) {
      forwardingRuleId = make_shared<string>(boost::any_cast<string>(m["ForwardingRuleId"]));
    }
  }


  virtual ~CreateForwardingRulesResponseBodyForwardingRules() = default;
};
class CreateForwardingRulesResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<CreateForwardingRulesResponseBodyForwardingRules>> forwardingRules{};
  shared_ptr<string> requestId{};

  CreateForwardingRulesResponseBody() {}

  explicit CreateForwardingRulesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (forwardingRules) {
      vector<boost::any> temp1;
      for(auto item1:*forwardingRules){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ForwardingRules"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ForwardingRules") != m.end() && !m["ForwardingRules"].empty()) {
      if (typeid(vector<boost::any>) == m["ForwardingRules"].type()) {
        vector<CreateForwardingRulesResponseBodyForwardingRules> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ForwardingRules"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateForwardingRulesResponseBodyForwardingRules model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        forwardingRules = make_shared<vector<CreateForwardingRulesResponseBodyForwardingRules>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateForwardingRulesResponseBody() = default;
};
class CreateForwardingRulesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateForwardingRulesResponseBody> body{};

  CreateForwardingRulesResponse() {}

  explicit CreateForwardingRulesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateForwardingRulesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateForwardingRulesResponseBody>(model1);
      }
    }
  }


  virtual ~CreateForwardingRulesResponse() = default;
};
class CreateIpSetsRequestAccelerateRegion : public Darabonba::Model {
public:
  shared_ptr<string> accelerateRegionId{};
  shared_ptr<long> bandwidth{};
  shared_ptr<string> ipVersion{};
  shared_ptr<string> ispType{};

  CreateIpSetsRequestAccelerateRegion() {}

  explicit CreateIpSetsRequestAccelerateRegion(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accelerateRegionId) {
      res["AccelerateRegionId"] = boost::any(*accelerateRegionId);
    }
    if (bandwidth) {
      res["Bandwidth"] = boost::any(*bandwidth);
    }
    if (ipVersion) {
      res["IpVersion"] = boost::any(*ipVersion);
    }
    if (ispType) {
      res["IspType"] = boost::any(*ispType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccelerateRegionId") != m.end() && !m["AccelerateRegionId"].empty()) {
      accelerateRegionId = make_shared<string>(boost::any_cast<string>(m["AccelerateRegionId"]));
    }
    if (m.find("Bandwidth") != m.end() && !m["Bandwidth"].empty()) {
      bandwidth = make_shared<long>(boost::any_cast<long>(m["Bandwidth"]));
    }
    if (m.find("IpVersion") != m.end() && !m["IpVersion"].empty()) {
      ipVersion = make_shared<string>(boost::any_cast<string>(m["IpVersion"]));
    }
    if (m.find("IspType") != m.end() && !m["IspType"].empty()) {
      ispType = make_shared<string>(boost::any_cast<string>(m["IspType"]));
    }
  }


  virtual ~CreateIpSetsRequestAccelerateRegion() = default;
};
class CreateIpSetsRequest : public Darabonba::Model {
public:
  shared_ptr<vector<CreateIpSetsRequestAccelerateRegion>> accelerateRegion{};
  shared_ptr<string> acceleratorId{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> regionId{};

  CreateIpSetsRequest() {}

  explicit CreateIpSetsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accelerateRegion) {
      vector<boost::any> temp1;
      for(auto item1:*accelerateRegion){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AccelerateRegion"] = boost::any(temp1);
    }
    if (acceleratorId) {
      res["AcceleratorId"] = boost::any(*acceleratorId);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccelerateRegion") != m.end() && !m["AccelerateRegion"].empty()) {
      if (typeid(vector<boost::any>) == m["AccelerateRegion"].type()) {
        vector<CreateIpSetsRequestAccelerateRegion> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AccelerateRegion"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateIpSetsRequestAccelerateRegion model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        accelerateRegion = make_shared<vector<CreateIpSetsRequestAccelerateRegion>>(expect1);
      }
    }
    if (m.find("AcceleratorId") != m.end() && !m["AcceleratorId"].empty()) {
      acceleratorId = make_shared<string>(boost::any_cast<string>(m["AcceleratorId"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~CreateIpSetsRequest() = default;
};
class CreateIpSetsResponseBodyIpSets : public Darabonba::Model {
public:
  shared_ptr<string> accelerateRegionId{};
  shared_ptr<long> bandwidth{};
  shared_ptr<string> ipSetId{};
  shared_ptr<string> ispType{};

  CreateIpSetsResponseBodyIpSets() {}

  explicit CreateIpSetsResponseBodyIpSets(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accelerateRegionId) {
      res["AccelerateRegionId"] = boost::any(*accelerateRegionId);
    }
    if (bandwidth) {
      res["Bandwidth"] = boost::any(*bandwidth);
    }
    if (ipSetId) {
      res["IpSetId"] = boost::any(*ipSetId);
    }
    if (ispType) {
      res["IspType"] = boost::any(*ispType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccelerateRegionId") != m.end() && !m["AccelerateRegionId"].empty()) {
      accelerateRegionId = make_shared<string>(boost::any_cast<string>(m["AccelerateRegionId"]));
    }
    if (m.find("Bandwidth") != m.end() && !m["Bandwidth"].empty()) {
      bandwidth = make_shared<long>(boost::any_cast<long>(m["Bandwidth"]));
    }
    if (m.find("IpSetId") != m.end() && !m["IpSetId"].empty()) {
      ipSetId = make_shared<string>(boost::any_cast<string>(m["IpSetId"]));
    }
    if (m.find("IspType") != m.end() && !m["IspType"].empty()) {
      ispType = make_shared<string>(boost::any_cast<string>(m["IspType"]));
    }
  }


  virtual ~CreateIpSetsResponseBodyIpSets() = default;
};
class CreateIpSetsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> acceleratorId{};
  shared_ptr<vector<CreateIpSetsResponseBodyIpSets>> ipSets{};
  shared_ptr<string> requestId{};

  CreateIpSetsResponseBody() {}

  explicit CreateIpSetsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceleratorId) {
      res["AcceleratorId"] = boost::any(*acceleratorId);
    }
    if (ipSets) {
      vector<boost::any> temp1;
      for(auto item1:*ipSets){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["IpSets"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceleratorId") != m.end() && !m["AcceleratorId"].empty()) {
      acceleratorId = make_shared<string>(boost::any_cast<string>(m["AcceleratorId"]));
    }
    if (m.find("IpSets") != m.end() && !m["IpSets"].empty()) {
      if (typeid(vector<boost::any>) == m["IpSets"].type()) {
        vector<CreateIpSetsResponseBodyIpSets> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["IpSets"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateIpSetsResponseBodyIpSets model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ipSets = make_shared<vector<CreateIpSetsResponseBodyIpSets>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateIpSetsResponseBody() = default;
};
class CreateIpSetsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateIpSetsResponseBody> body{};

  CreateIpSetsResponse() {}

  explicit CreateIpSetsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateIpSetsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateIpSetsResponseBody>(model1);
      }
    }
  }


  virtual ~CreateIpSetsResponse() = default;
};
class CreateListenerRequestCertificates : public Darabonba::Model {
public:
  shared_ptr<string> id{};

  CreateListenerRequestCertificates() {}

  explicit CreateListenerRequestCertificates(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
  }


  virtual ~CreateListenerRequestCertificates() = default;
};
class CreateListenerRequestCustomRoutingEndpointGroupConfigurationsDestinationConfigurations : public Darabonba::Model {
public:
  shared_ptr<long> fromPort{};
  shared_ptr<vector<string>> protocols{};
  shared_ptr<long> toPort{};

  CreateListenerRequestCustomRoutingEndpointGroupConfigurationsDestinationConfigurations() {}

  explicit CreateListenerRequestCustomRoutingEndpointGroupConfigurationsDestinationConfigurations(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fromPort) {
      res["FromPort"] = boost::any(*fromPort);
    }
    if (protocols) {
      res["Protocols"] = boost::any(*protocols);
    }
    if (toPort) {
      res["ToPort"] = boost::any(*toPort);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FromPort") != m.end() && !m["FromPort"].empty()) {
      fromPort = make_shared<long>(boost::any_cast<long>(m["FromPort"]));
    }
    if (m.find("Protocols") != m.end() && !m["Protocols"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Protocols"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Protocols"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      protocols = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ToPort") != m.end() && !m["ToPort"].empty()) {
      toPort = make_shared<long>(boost::any_cast<long>(m["ToPort"]));
    }
  }


  virtual ~CreateListenerRequestCustomRoutingEndpointGroupConfigurationsDestinationConfigurations() = default;
};
class CreateListenerRequestCustomRoutingEndpointGroupConfigurationsEndpointConfigurationsPolicyConfigurationsPortRanges : public Darabonba::Model {
public:
  shared_ptr<long> fromPort{};
  shared_ptr<long> toPort{};

  CreateListenerRequestCustomRoutingEndpointGroupConfigurationsEndpointConfigurationsPolicyConfigurationsPortRanges() {}

  explicit CreateListenerRequestCustomRoutingEndpointGroupConfigurationsEndpointConfigurationsPolicyConfigurationsPortRanges(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fromPort) {
      res["FromPort"] = boost::any(*fromPort);
    }
    if (toPort) {
      res["ToPort"] = boost::any(*toPort);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FromPort") != m.end() && !m["FromPort"].empty()) {
      fromPort = make_shared<long>(boost::any_cast<long>(m["FromPort"]));
    }
    if (m.find("ToPort") != m.end() && !m["ToPort"].empty()) {
      toPort = make_shared<long>(boost::any_cast<long>(m["ToPort"]));
    }
  }


  virtual ~CreateListenerRequestCustomRoutingEndpointGroupConfigurationsEndpointConfigurationsPolicyConfigurationsPortRanges() = default;
};
class CreateListenerRequestCustomRoutingEndpointGroupConfigurationsEndpointConfigurationsPolicyConfigurations : public Darabonba::Model {
public:
  shared_ptr<string> address{};
  shared_ptr<vector<CreateListenerRequestCustomRoutingEndpointGroupConfigurationsEndpointConfigurationsPolicyConfigurationsPortRanges>> portRanges{};

  CreateListenerRequestCustomRoutingEndpointGroupConfigurationsEndpointConfigurationsPolicyConfigurations() {}

  explicit CreateListenerRequestCustomRoutingEndpointGroupConfigurationsEndpointConfigurationsPolicyConfigurations(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (address) {
      res["Address"] = boost::any(*address);
    }
    if (portRanges) {
      vector<boost::any> temp1;
      for(auto item1:*portRanges){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PortRanges"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Address") != m.end() && !m["Address"].empty()) {
      address = make_shared<string>(boost::any_cast<string>(m["Address"]));
    }
    if (m.find("PortRanges") != m.end() && !m["PortRanges"].empty()) {
      if (typeid(vector<boost::any>) == m["PortRanges"].type()) {
        vector<CreateListenerRequestCustomRoutingEndpointGroupConfigurationsEndpointConfigurationsPolicyConfigurationsPortRanges> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PortRanges"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateListenerRequestCustomRoutingEndpointGroupConfigurationsEndpointConfigurationsPolicyConfigurationsPortRanges model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        portRanges = make_shared<vector<CreateListenerRequestCustomRoutingEndpointGroupConfigurationsEndpointConfigurationsPolicyConfigurationsPortRanges>>(expect1);
      }
    }
  }


  virtual ~CreateListenerRequestCustomRoutingEndpointGroupConfigurationsEndpointConfigurationsPolicyConfigurations() = default;
};
class CreateListenerRequestCustomRoutingEndpointGroupConfigurationsEndpointConfigurations : public Darabonba::Model {
public:
  shared_ptr<string> endpoint{};
  shared_ptr<vector<CreateListenerRequestCustomRoutingEndpointGroupConfigurationsEndpointConfigurationsPolicyConfigurations>> policyConfigurations{};
  shared_ptr<string> trafficToEndpointPolicy{};
  shared_ptr<string> type{};

  CreateListenerRequestCustomRoutingEndpointGroupConfigurationsEndpointConfigurations() {}

  explicit CreateListenerRequestCustomRoutingEndpointGroupConfigurationsEndpointConfigurations(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endpoint) {
      res["Endpoint"] = boost::any(*endpoint);
    }
    if (policyConfigurations) {
      vector<boost::any> temp1;
      for(auto item1:*policyConfigurations){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PolicyConfigurations"] = boost::any(temp1);
    }
    if (trafficToEndpointPolicy) {
      res["TrafficToEndpointPolicy"] = boost::any(*trafficToEndpointPolicy);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Endpoint") != m.end() && !m["Endpoint"].empty()) {
      endpoint = make_shared<string>(boost::any_cast<string>(m["Endpoint"]));
    }
    if (m.find("PolicyConfigurations") != m.end() && !m["PolicyConfigurations"].empty()) {
      if (typeid(vector<boost::any>) == m["PolicyConfigurations"].type()) {
        vector<CreateListenerRequestCustomRoutingEndpointGroupConfigurationsEndpointConfigurationsPolicyConfigurations> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PolicyConfigurations"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateListenerRequestCustomRoutingEndpointGroupConfigurationsEndpointConfigurationsPolicyConfigurations model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        policyConfigurations = make_shared<vector<CreateListenerRequestCustomRoutingEndpointGroupConfigurationsEndpointConfigurationsPolicyConfigurations>>(expect1);
      }
    }
    if (m.find("TrafficToEndpointPolicy") != m.end() && !m["TrafficToEndpointPolicy"].empty()) {
      trafficToEndpointPolicy = make_shared<string>(boost::any_cast<string>(m["TrafficToEndpointPolicy"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~CreateListenerRequestCustomRoutingEndpointGroupConfigurationsEndpointConfigurations() = default;
};
class CreateListenerRequestCustomRoutingEndpointGroupConfigurations : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<vector<CreateListenerRequestCustomRoutingEndpointGroupConfigurationsDestinationConfigurations>> destinationConfigurations{};
  shared_ptr<vector<CreateListenerRequestCustomRoutingEndpointGroupConfigurationsEndpointConfigurations>> endpointConfigurations{};
  shared_ptr<string> endpointGroupRegion{};
  shared_ptr<string> name{};

  CreateListenerRequestCustomRoutingEndpointGroupConfigurations() {}

  explicit CreateListenerRequestCustomRoutingEndpointGroupConfigurations(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (destinationConfigurations) {
      vector<boost::any> temp1;
      for(auto item1:*destinationConfigurations){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DestinationConfigurations"] = boost::any(temp1);
    }
    if (endpointConfigurations) {
      vector<boost::any> temp1;
      for(auto item1:*endpointConfigurations){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["EndpointConfigurations"] = boost::any(temp1);
    }
    if (endpointGroupRegion) {
      res["EndpointGroupRegion"] = boost::any(*endpointGroupRegion);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DestinationConfigurations") != m.end() && !m["DestinationConfigurations"].empty()) {
      if (typeid(vector<boost::any>) == m["DestinationConfigurations"].type()) {
        vector<CreateListenerRequestCustomRoutingEndpointGroupConfigurationsDestinationConfigurations> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DestinationConfigurations"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateListenerRequestCustomRoutingEndpointGroupConfigurationsDestinationConfigurations model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        destinationConfigurations = make_shared<vector<CreateListenerRequestCustomRoutingEndpointGroupConfigurationsDestinationConfigurations>>(expect1);
      }
    }
    if (m.find("EndpointConfigurations") != m.end() && !m["EndpointConfigurations"].empty()) {
      if (typeid(vector<boost::any>) == m["EndpointConfigurations"].type()) {
        vector<CreateListenerRequestCustomRoutingEndpointGroupConfigurationsEndpointConfigurations> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["EndpointConfigurations"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateListenerRequestCustomRoutingEndpointGroupConfigurationsEndpointConfigurations model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        endpointConfigurations = make_shared<vector<CreateListenerRequestCustomRoutingEndpointGroupConfigurationsEndpointConfigurations>>(expect1);
      }
    }
    if (m.find("EndpointGroupRegion") != m.end() && !m["EndpointGroupRegion"].empty()) {
      endpointGroupRegion = make_shared<string>(boost::any_cast<string>(m["EndpointGroupRegion"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~CreateListenerRequestCustomRoutingEndpointGroupConfigurations() = default;
};
class CreateListenerRequestEndpointGroupConfigurationsEndpointConfigurations : public Darabonba::Model {
public:
  shared_ptr<string> endpoint{};
  shared_ptr<string> type{};
  shared_ptr<long> weight{};

  CreateListenerRequestEndpointGroupConfigurationsEndpointConfigurations() {}

  explicit CreateListenerRequestEndpointGroupConfigurationsEndpointConfigurations(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endpoint) {
      res["Endpoint"] = boost::any(*endpoint);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (weight) {
      res["Weight"] = boost::any(*weight);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Endpoint") != m.end() && !m["Endpoint"].empty()) {
      endpoint = make_shared<string>(boost::any_cast<string>(m["Endpoint"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Weight") != m.end() && !m["Weight"].empty()) {
      weight = make_shared<long>(boost::any_cast<long>(m["Weight"]));
    }
  }


  virtual ~CreateListenerRequestEndpointGroupConfigurationsEndpointConfigurations() = default;
};
class CreateListenerRequestEndpointGroupConfigurationsPortOverrides : public Darabonba::Model {
public:
  shared_ptr<long> endpointPort{};
  shared_ptr<long> listenerPort{};

  CreateListenerRequestEndpointGroupConfigurationsPortOverrides() {}

  explicit CreateListenerRequestEndpointGroupConfigurationsPortOverrides(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endpointPort) {
      res["EndpointPort"] = boost::any(*endpointPort);
    }
    if (listenerPort) {
      res["ListenerPort"] = boost::any(*listenerPort);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndpointPort") != m.end() && !m["EndpointPort"].empty()) {
      endpointPort = make_shared<long>(boost::any_cast<long>(m["EndpointPort"]));
    }
    if (m.find("ListenerPort") != m.end() && !m["ListenerPort"].empty()) {
      listenerPort = make_shared<long>(boost::any_cast<long>(m["ListenerPort"]));
    }
  }


  virtual ~CreateListenerRequestEndpointGroupConfigurationsPortOverrides() = default;
};
class CreateListenerRequestEndpointGroupConfigurations : public Darabonba::Model {
public:
  shared_ptr<bool> enableClientIPPreservationProxyProtocol{};
  shared_ptr<bool> enableClientIPPreservationToa{};
  shared_ptr<vector<CreateListenerRequestEndpointGroupConfigurationsEndpointConfigurations>> endpointConfigurations{};
  shared_ptr<string> endpointGroupDescription{};
  shared_ptr<string> endpointGroupName{};
  shared_ptr<string> endpointGroupRegion{};
  shared_ptr<string> endpointGroupType{};
  shared_ptr<string> endpointRequestProtocol{};
  shared_ptr<bool> healthCheckEnabled{};
  shared_ptr<long> healthCheckIntervalSeconds{};
  shared_ptr<string> healthCheckPath{};
  shared_ptr<long> healthCheckPort{};
  shared_ptr<string> healthCheckProtocol{};
  shared_ptr<vector<CreateListenerRequestEndpointGroupConfigurationsPortOverrides>> portOverrides{};
  shared_ptr<long> thresholdCount{};
  shared_ptr<long> trafficPercentage{};

  CreateListenerRequestEndpointGroupConfigurations() {}

  explicit CreateListenerRequestEndpointGroupConfigurations(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (enableClientIPPreservationProxyProtocol) {
      res["EnableClientIPPreservationProxyProtocol"] = boost::any(*enableClientIPPreservationProxyProtocol);
    }
    if (enableClientIPPreservationToa) {
      res["EnableClientIPPreservationToa"] = boost::any(*enableClientIPPreservationToa);
    }
    if (endpointConfigurations) {
      vector<boost::any> temp1;
      for(auto item1:*endpointConfigurations){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["EndpointConfigurations"] = boost::any(temp1);
    }
    if (endpointGroupDescription) {
      res["EndpointGroupDescription"] = boost::any(*endpointGroupDescription);
    }
    if (endpointGroupName) {
      res["EndpointGroupName"] = boost::any(*endpointGroupName);
    }
    if (endpointGroupRegion) {
      res["EndpointGroupRegion"] = boost::any(*endpointGroupRegion);
    }
    if (endpointGroupType) {
      res["EndpointGroupType"] = boost::any(*endpointGroupType);
    }
    if (endpointRequestProtocol) {
      res["EndpointRequestProtocol"] = boost::any(*endpointRequestProtocol);
    }
    if (healthCheckEnabled) {
      res["HealthCheckEnabled"] = boost::any(*healthCheckEnabled);
    }
    if (healthCheckIntervalSeconds) {
      res["HealthCheckIntervalSeconds"] = boost::any(*healthCheckIntervalSeconds);
    }
    if (healthCheckPath) {
      res["HealthCheckPath"] = boost::any(*healthCheckPath);
    }
    if (healthCheckPort) {
      res["HealthCheckPort"] = boost::any(*healthCheckPort);
    }
    if (healthCheckProtocol) {
      res["HealthCheckProtocol"] = boost::any(*healthCheckProtocol);
    }
    if (portOverrides) {
      vector<boost::any> temp1;
      for(auto item1:*portOverrides){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PortOverrides"] = boost::any(temp1);
    }
    if (thresholdCount) {
      res["ThresholdCount"] = boost::any(*thresholdCount);
    }
    if (trafficPercentage) {
      res["TrafficPercentage"] = boost::any(*trafficPercentage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EnableClientIPPreservationProxyProtocol") != m.end() && !m["EnableClientIPPreservationProxyProtocol"].empty()) {
      enableClientIPPreservationProxyProtocol = make_shared<bool>(boost::any_cast<bool>(m["EnableClientIPPreservationProxyProtocol"]));
    }
    if (m.find("EnableClientIPPreservationToa") != m.end() && !m["EnableClientIPPreservationToa"].empty()) {
      enableClientIPPreservationToa = make_shared<bool>(boost::any_cast<bool>(m["EnableClientIPPreservationToa"]));
    }
    if (m.find("EndpointConfigurations") != m.end() && !m["EndpointConfigurations"].empty()) {
      if (typeid(vector<boost::any>) == m["EndpointConfigurations"].type()) {
        vector<CreateListenerRequestEndpointGroupConfigurationsEndpointConfigurations> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["EndpointConfigurations"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateListenerRequestEndpointGroupConfigurationsEndpointConfigurations model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        endpointConfigurations = make_shared<vector<CreateListenerRequestEndpointGroupConfigurationsEndpointConfigurations>>(expect1);
      }
    }
    if (m.find("EndpointGroupDescription") != m.end() && !m["EndpointGroupDescription"].empty()) {
      endpointGroupDescription = make_shared<string>(boost::any_cast<string>(m["EndpointGroupDescription"]));
    }
    if (m.find("EndpointGroupName") != m.end() && !m["EndpointGroupName"].empty()) {
      endpointGroupName = make_shared<string>(boost::any_cast<string>(m["EndpointGroupName"]));
    }
    if (m.find("EndpointGroupRegion") != m.end() && !m["EndpointGroupRegion"].empty()) {
      endpointGroupRegion = make_shared<string>(boost::any_cast<string>(m["EndpointGroupRegion"]));
    }
    if (m.find("EndpointGroupType") != m.end() && !m["EndpointGroupType"].empty()) {
      endpointGroupType = make_shared<string>(boost::any_cast<string>(m["EndpointGroupType"]));
    }
    if (m.find("EndpointRequestProtocol") != m.end() && !m["EndpointRequestProtocol"].empty()) {
      endpointRequestProtocol = make_shared<string>(boost::any_cast<string>(m["EndpointRequestProtocol"]));
    }
    if (m.find("HealthCheckEnabled") != m.end() && !m["HealthCheckEnabled"].empty()) {
      healthCheckEnabled = make_shared<bool>(boost::any_cast<bool>(m["HealthCheckEnabled"]));
    }
    if (m.find("HealthCheckIntervalSeconds") != m.end() && !m["HealthCheckIntervalSeconds"].empty()) {
      healthCheckIntervalSeconds = make_shared<long>(boost::any_cast<long>(m["HealthCheckIntervalSeconds"]));
    }
    if (m.find("HealthCheckPath") != m.end() && !m["HealthCheckPath"].empty()) {
      healthCheckPath = make_shared<string>(boost::any_cast<string>(m["HealthCheckPath"]));
    }
    if (m.find("HealthCheckPort") != m.end() && !m["HealthCheckPort"].empty()) {
      healthCheckPort = make_shared<long>(boost::any_cast<long>(m["HealthCheckPort"]));
    }
    if (m.find("HealthCheckProtocol") != m.end() && !m["HealthCheckProtocol"].empty()) {
      healthCheckProtocol = make_shared<string>(boost::any_cast<string>(m["HealthCheckProtocol"]));
    }
    if (m.find("PortOverrides") != m.end() && !m["PortOverrides"].empty()) {
      if (typeid(vector<boost::any>) == m["PortOverrides"].type()) {
        vector<CreateListenerRequestEndpointGroupConfigurationsPortOverrides> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PortOverrides"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateListenerRequestEndpointGroupConfigurationsPortOverrides model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        portOverrides = make_shared<vector<CreateListenerRequestEndpointGroupConfigurationsPortOverrides>>(expect1);
      }
    }
    if (m.find("ThresholdCount") != m.end() && !m["ThresholdCount"].empty()) {
      thresholdCount = make_shared<long>(boost::any_cast<long>(m["ThresholdCount"]));
    }
    if (m.find("TrafficPercentage") != m.end() && !m["TrafficPercentage"].empty()) {
      trafficPercentage = make_shared<long>(boost::any_cast<long>(m["TrafficPercentage"]));
    }
  }


  virtual ~CreateListenerRequestEndpointGroupConfigurations() = default;
};
class CreateListenerRequestPortRanges : public Darabonba::Model {
public:
  shared_ptr<long> fromPort{};
  shared_ptr<long> toPort{};

  CreateListenerRequestPortRanges() {}

  explicit CreateListenerRequestPortRanges(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fromPort) {
      res["FromPort"] = boost::any(*fromPort);
    }
    if (toPort) {
      res["ToPort"] = boost::any(*toPort);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FromPort") != m.end() && !m["FromPort"].empty()) {
      fromPort = make_shared<long>(boost::any_cast<long>(m["FromPort"]));
    }
    if (m.find("ToPort") != m.end() && !m["ToPort"].empty()) {
      toPort = make_shared<long>(boost::any_cast<long>(m["ToPort"]));
    }
  }


  virtual ~CreateListenerRequestPortRanges() = default;
};
class CreateListenerRequestXForwardedForConfig : public Darabonba::Model {
public:
  shared_ptr<bool> XForwardedForGaApEnabled{};
  shared_ptr<bool> XForwardedForGaIdEnabled{};
  shared_ptr<bool> XForwardedForPortEnabled{};
  shared_ptr<bool> XForwardedForProtoEnabled{};
  shared_ptr<bool> XRealIpEnabled{};

  CreateListenerRequestXForwardedForConfig() {}

  explicit CreateListenerRequestXForwardedForConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (XForwardedForGaApEnabled) {
      res["XForwardedForGaApEnabled"] = boost::any(*XForwardedForGaApEnabled);
    }
    if (XForwardedForGaIdEnabled) {
      res["XForwardedForGaIdEnabled"] = boost::any(*XForwardedForGaIdEnabled);
    }
    if (XForwardedForPortEnabled) {
      res["XForwardedForPortEnabled"] = boost::any(*XForwardedForPortEnabled);
    }
    if (XForwardedForProtoEnabled) {
      res["XForwardedForProtoEnabled"] = boost::any(*XForwardedForProtoEnabled);
    }
    if (XRealIpEnabled) {
      res["XRealIpEnabled"] = boost::any(*XRealIpEnabled);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("XForwardedForGaApEnabled") != m.end() && !m["XForwardedForGaApEnabled"].empty()) {
      XForwardedForGaApEnabled = make_shared<bool>(boost::any_cast<bool>(m["XForwardedForGaApEnabled"]));
    }
    if (m.find("XForwardedForGaIdEnabled") != m.end() && !m["XForwardedForGaIdEnabled"].empty()) {
      XForwardedForGaIdEnabled = make_shared<bool>(boost::any_cast<bool>(m["XForwardedForGaIdEnabled"]));
    }
    if (m.find("XForwardedForPortEnabled") != m.end() && !m["XForwardedForPortEnabled"].empty()) {
      XForwardedForPortEnabled = make_shared<bool>(boost::any_cast<bool>(m["XForwardedForPortEnabled"]));
    }
    if (m.find("XForwardedForProtoEnabled") != m.end() && !m["XForwardedForProtoEnabled"].empty()) {
      XForwardedForProtoEnabled = make_shared<bool>(boost::any_cast<bool>(m["XForwardedForProtoEnabled"]));
    }
    if (m.find("XRealIpEnabled") != m.end() && !m["XRealIpEnabled"].empty()) {
      XRealIpEnabled = make_shared<bool>(boost::any_cast<bool>(m["XRealIpEnabled"]));
    }
  }


  virtual ~CreateListenerRequestXForwardedForConfig() = default;
};
class CreateListenerRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceleratorId{};
  shared_ptr<vector<CreateListenerRequestCertificates>> certificates{};
  shared_ptr<string> clientAffinity{};
  shared_ptr<string> clientToken{};
  shared_ptr<vector<CreateListenerRequestCustomRoutingEndpointGroupConfigurations>> customRoutingEndpointGroupConfigurations{};
  shared_ptr<string> description{};
  shared_ptr<vector<CreateListenerRequestEndpointGroupConfigurations>> endpointGroupConfigurations{};
  shared_ptr<string> name{};
  shared_ptr<vector<CreateListenerRequestPortRanges>> portRanges{};
  shared_ptr<string> protocol{};
  shared_ptr<bool> proxyProtocol{};
  shared_ptr<string> regionId{};
  shared_ptr<string> securityPolicyId{};
  shared_ptr<string> type{};
  shared_ptr<CreateListenerRequestXForwardedForConfig> XForwardedForConfig{};

  CreateListenerRequest() {}

  explicit CreateListenerRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceleratorId) {
      res["AcceleratorId"] = boost::any(*acceleratorId);
    }
    if (certificates) {
      vector<boost::any> temp1;
      for(auto item1:*certificates){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Certificates"] = boost::any(temp1);
    }
    if (clientAffinity) {
      res["ClientAffinity"] = boost::any(*clientAffinity);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (customRoutingEndpointGroupConfigurations) {
      vector<boost::any> temp1;
      for(auto item1:*customRoutingEndpointGroupConfigurations){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CustomRoutingEndpointGroupConfigurations"] = boost::any(temp1);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (endpointGroupConfigurations) {
      vector<boost::any> temp1;
      for(auto item1:*endpointGroupConfigurations){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["EndpointGroupConfigurations"] = boost::any(temp1);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (portRanges) {
      vector<boost::any> temp1;
      for(auto item1:*portRanges){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PortRanges"] = boost::any(temp1);
    }
    if (protocol) {
      res["Protocol"] = boost::any(*protocol);
    }
    if (proxyProtocol) {
      res["ProxyProtocol"] = boost::any(*proxyProtocol);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (securityPolicyId) {
      res["SecurityPolicyId"] = boost::any(*securityPolicyId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (XForwardedForConfig) {
      res["XForwardedForConfig"] = XForwardedForConfig ? boost::any(XForwardedForConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceleratorId") != m.end() && !m["AcceleratorId"].empty()) {
      acceleratorId = make_shared<string>(boost::any_cast<string>(m["AcceleratorId"]));
    }
    if (m.find("Certificates") != m.end() && !m["Certificates"].empty()) {
      if (typeid(vector<boost::any>) == m["Certificates"].type()) {
        vector<CreateListenerRequestCertificates> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Certificates"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateListenerRequestCertificates model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        certificates = make_shared<vector<CreateListenerRequestCertificates>>(expect1);
      }
    }
    if (m.find("ClientAffinity") != m.end() && !m["ClientAffinity"].empty()) {
      clientAffinity = make_shared<string>(boost::any_cast<string>(m["ClientAffinity"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("CustomRoutingEndpointGroupConfigurations") != m.end() && !m["CustomRoutingEndpointGroupConfigurations"].empty()) {
      if (typeid(vector<boost::any>) == m["CustomRoutingEndpointGroupConfigurations"].type()) {
        vector<CreateListenerRequestCustomRoutingEndpointGroupConfigurations> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CustomRoutingEndpointGroupConfigurations"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateListenerRequestCustomRoutingEndpointGroupConfigurations model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        customRoutingEndpointGroupConfigurations = make_shared<vector<CreateListenerRequestCustomRoutingEndpointGroupConfigurations>>(expect1);
      }
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("EndpointGroupConfigurations") != m.end() && !m["EndpointGroupConfigurations"].empty()) {
      if (typeid(vector<boost::any>) == m["EndpointGroupConfigurations"].type()) {
        vector<CreateListenerRequestEndpointGroupConfigurations> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["EndpointGroupConfigurations"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateListenerRequestEndpointGroupConfigurations model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        endpointGroupConfigurations = make_shared<vector<CreateListenerRequestEndpointGroupConfigurations>>(expect1);
      }
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("PortRanges") != m.end() && !m["PortRanges"].empty()) {
      if (typeid(vector<boost::any>) == m["PortRanges"].type()) {
        vector<CreateListenerRequestPortRanges> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PortRanges"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateListenerRequestPortRanges model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        portRanges = make_shared<vector<CreateListenerRequestPortRanges>>(expect1);
      }
    }
    if (m.find("Protocol") != m.end() && !m["Protocol"].empty()) {
      protocol = make_shared<string>(boost::any_cast<string>(m["Protocol"]));
    }
    if (m.find("ProxyProtocol") != m.end() && !m["ProxyProtocol"].empty()) {
      proxyProtocol = make_shared<bool>(boost::any_cast<bool>(m["ProxyProtocol"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SecurityPolicyId") != m.end() && !m["SecurityPolicyId"].empty()) {
      securityPolicyId = make_shared<string>(boost::any_cast<string>(m["SecurityPolicyId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("XForwardedForConfig") != m.end() && !m["XForwardedForConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["XForwardedForConfig"].type()) {
        CreateListenerRequestXForwardedForConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["XForwardedForConfig"]));
        XForwardedForConfig = make_shared<CreateListenerRequestXForwardedForConfig>(model1);
      }
    }
  }


  virtual ~CreateListenerRequest() = default;
};
class CreateListenerResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> listenerId{};
  shared_ptr<string> requestId{};

  CreateListenerResponseBody() {}

  explicit CreateListenerResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (listenerId) {
      res["ListenerId"] = boost::any(*listenerId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ListenerId") != m.end() && !m["ListenerId"].empty()) {
      listenerId = make_shared<string>(boost::any_cast<string>(m["ListenerId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateListenerResponseBody() = default;
};
class CreateListenerResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateListenerResponseBody> body{};

  CreateListenerResponse() {}

  explicit CreateListenerResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateListenerResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateListenerResponseBody>(model1);
      }
    }
  }


  virtual ~CreateListenerResponse() = default;
};
class CreateSpareIpsRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceleratorId{};
  shared_ptr<string> clientToken{};
  shared_ptr<bool> dryRun{};
  shared_ptr<string> regionId{};
  shared_ptr<vector<string>> spareIps{};

  CreateSpareIpsRequest() {}

  explicit CreateSpareIpsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceleratorId) {
      res["AcceleratorId"] = boost::any(*acceleratorId);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (dryRun) {
      res["DryRun"] = boost::any(*dryRun);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (spareIps) {
      res["SpareIps"] = boost::any(*spareIps);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceleratorId") != m.end() && !m["AcceleratorId"].empty()) {
      acceleratorId = make_shared<string>(boost::any_cast<string>(m["AcceleratorId"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("DryRun") != m.end() && !m["DryRun"].empty()) {
      dryRun = make_shared<bool>(boost::any_cast<bool>(m["DryRun"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SpareIps") != m.end() && !m["SpareIps"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SpareIps"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SpareIps"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      spareIps = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~CreateSpareIpsRequest() = default;
};
class CreateSpareIpsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  CreateSpareIpsResponseBody() {}

  explicit CreateSpareIpsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateSpareIpsResponseBody() = default;
};
class CreateSpareIpsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateSpareIpsResponseBody> body{};

  CreateSpareIpsResponse() {}

  explicit CreateSpareIpsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateSpareIpsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateSpareIpsResponseBody>(model1);
      }
    }
  }


  virtual ~CreateSpareIpsResponse() = default;
};
class DeleteAcceleratorRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceleratorId{};
  shared_ptr<string> regionId{};

  DeleteAcceleratorRequest() {}

  explicit DeleteAcceleratorRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceleratorId) {
      res["AcceleratorId"] = boost::any(*acceleratorId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceleratorId") != m.end() && !m["AcceleratorId"].empty()) {
      acceleratorId = make_shared<string>(boost::any_cast<string>(m["AcceleratorId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DeleteAcceleratorRequest() = default;
};
class DeleteAcceleratorResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> acceleratorId{};
  shared_ptr<string> requestId{};

  DeleteAcceleratorResponseBody() {}

  explicit DeleteAcceleratorResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceleratorId) {
      res["AcceleratorId"] = boost::any(*acceleratorId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceleratorId") != m.end() && !m["AcceleratorId"].empty()) {
      acceleratorId = make_shared<string>(boost::any_cast<string>(m["AcceleratorId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteAcceleratorResponseBody() = default;
};
class DeleteAcceleratorResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteAcceleratorResponseBody> body{};

  DeleteAcceleratorResponse() {}

  explicit DeleteAcceleratorResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteAcceleratorResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteAcceleratorResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteAcceleratorResponse() = default;
};
class DeleteAclRequest : public Darabonba::Model {
public:
  shared_ptr<string> aclId{};
  shared_ptr<string> clientToken{};
  shared_ptr<bool> dryRun{};
  shared_ptr<string> regionId{};

  DeleteAclRequest() {}

  explicit DeleteAclRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aclId) {
      res["AclId"] = boost::any(*aclId);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (dryRun) {
      res["DryRun"] = boost::any(*dryRun);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AclId") != m.end() && !m["AclId"].empty()) {
      aclId = make_shared<string>(boost::any_cast<string>(m["AclId"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("DryRun") != m.end() && !m["DryRun"].empty()) {
      dryRun = make_shared<bool>(boost::any_cast<bool>(m["DryRun"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DeleteAclRequest() = default;
};
class DeleteAclResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> aclId{};
  shared_ptr<string> requestId{};

  DeleteAclResponseBody() {}

  explicit DeleteAclResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aclId) {
      res["AclId"] = boost::any(*aclId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AclId") != m.end() && !m["AclId"].empty()) {
      aclId = make_shared<string>(boost::any_cast<string>(m["AclId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteAclResponseBody() = default;
};
class DeleteAclResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteAclResponseBody> body{};

  DeleteAclResponse() {}

  explicit DeleteAclResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteAclResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteAclResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteAclResponse() = default;
};
class DeleteApplicationMonitorRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> regionId{};
  shared_ptr<string> taskId{};

  DeleteApplicationMonitorRequest() {}

  explicit DeleteApplicationMonitorRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
  }


  virtual ~DeleteApplicationMonitorRequest() = default;
};
class DeleteApplicationMonitorResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteApplicationMonitorResponseBody() {}

  explicit DeleteApplicationMonitorResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteApplicationMonitorResponseBody() = default;
};
class DeleteApplicationMonitorResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteApplicationMonitorResponseBody> body{};

  DeleteApplicationMonitorResponse() {}

  explicit DeleteApplicationMonitorResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteApplicationMonitorResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteApplicationMonitorResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteApplicationMonitorResponse() = default;
};
class DeleteBandwidthPackageRequest : public Darabonba::Model {
public:
  shared_ptr<string> bandwidthPackageId{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> regionId{};

  DeleteBandwidthPackageRequest() {}

  explicit DeleteBandwidthPackageRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bandwidthPackageId) {
      res["BandwidthPackageId"] = boost::any(*bandwidthPackageId);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BandwidthPackageId") != m.end() && !m["BandwidthPackageId"].empty()) {
      bandwidthPackageId = make_shared<string>(boost::any_cast<string>(m["BandwidthPackageId"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DeleteBandwidthPackageRequest() = default;
};
class DeleteBandwidthPackageResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> bandwidthPackageId{};
  shared_ptr<string> requestId{};

  DeleteBandwidthPackageResponseBody() {}

  explicit DeleteBandwidthPackageResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bandwidthPackageId) {
      res["BandwidthPackageId"] = boost::any(*bandwidthPackageId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BandwidthPackageId") != m.end() && !m["BandwidthPackageId"].empty()) {
      bandwidthPackageId = make_shared<string>(boost::any_cast<string>(m["BandwidthPackageId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteBandwidthPackageResponseBody() = default;
};
class DeleteBandwidthPackageResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteBandwidthPackageResponseBody> body{};

  DeleteBandwidthPackageResponse() {}

  explicit DeleteBandwidthPackageResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteBandwidthPackageResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteBandwidthPackageResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteBandwidthPackageResponse() = default;
};
class DeleteBasicAccelerateIpRequest : public Darabonba::Model {
public:
  shared_ptr<string> accelerateIpId{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> regionId{};

  DeleteBasicAccelerateIpRequest() {}

  explicit DeleteBasicAccelerateIpRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accelerateIpId) {
      res["AccelerateIpId"] = boost::any(*accelerateIpId);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccelerateIpId") != m.end() && !m["AccelerateIpId"].empty()) {
      accelerateIpId = make_shared<string>(boost::any_cast<string>(m["AccelerateIpId"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DeleteBasicAccelerateIpRequest() = default;
};
class DeleteBasicAccelerateIpResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> accelerateIpId{};
  shared_ptr<string> requestId{};

  DeleteBasicAccelerateIpResponseBody() {}

  explicit DeleteBasicAccelerateIpResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accelerateIpId) {
      res["AccelerateIpId"] = boost::any(*accelerateIpId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccelerateIpId") != m.end() && !m["AccelerateIpId"].empty()) {
      accelerateIpId = make_shared<string>(boost::any_cast<string>(m["AccelerateIpId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteBasicAccelerateIpResponseBody() = default;
};
class DeleteBasicAccelerateIpResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteBasicAccelerateIpResponseBody> body{};

  DeleteBasicAccelerateIpResponse() {}

  explicit DeleteBasicAccelerateIpResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteBasicAccelerateIpResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteBasicAccelerateIpResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteBasicAccelerateIpResponse() = default;
};
class DeleteBasicAccelerateIpEndpointRelationRequest : public Darabonba::Model {
public:
  shared_ptr<string> accelerateIpId{};
  shared_ptr<string> acceleratorId{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> endpointId{};
  shared_ptr<string> regionId{};

  DeleteBasicAccelerateIpEndpointRelationRequest() {}

  explicit DeleteBasicAccelerateIpEndpointRelationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accelerateIpId) {
      res["AccelerateIpId"] = boost::any(*accelerateIpId);
    }
    if (acceleratorId) {
      res["AcceleratorId"] = boost::any(*acceleratorId);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (endpointId) {
      res["EndpointId"] = boost::any(*endpointId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccelerateIpId") != m.end() && !m["AccelerateIpId"].empty()) {
      accelerateIpId = make_shared<string>(boost::any_cast<string>(m["AccelerateIpId"]));
    }
    if (m.find("AcceleratorId") != m.end() && !m["AcceleratorId"].empty()) {
      acceleratorId = make_shared<string>(boost::any_cast<string>(m["AcceleratorId"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("EndpointId") != m.end() && !m["EndpointId"].empty()) {
      endpointId = make_shared<string>(boost::any_cast<string>(m["EndpointId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DeleteBasicAccelerateIpEndpointRelationRequest() = default;
};
class DeleteBasicAccelerateIpEndpointRelationResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> accelerateIpId{};
  shared_ptr<string> acceleratorId{};
  shared_ptr<string> endpointId{};
  shared_ptr<string> requestId{};
  shared_ptr<string> state{};

  DeleteBasicAccelerateIpEndpointRelationResponseBody() {}

  explicit DeleteBasicAccelerateIpEndpointRelationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accelerateIpId) {
      res["AccelerateIpId"] = boost::any(*accelerateIpId);
    }
    if (acceleratorId) {
      res["AcceleratorId"] = boost::any(*acceleratorId);
    }
    if (endpointId) {
      res["EndpointId"] = boost::any(*endpointId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccelerateIpId") != m.end() && !m["AccelerateIpId"].empty()) {
      accelerateIpId = make_shared<string>(boost::any_cast<string>(m["AccelerateIpId"]));
    }
    if (m.find("AcceleratorId") != m.end() && !m["AcceleratorId"].empty()) {
      acceleratorId = make_shared<string>(boost::any_cast<string>(m["AcceleratorId"]));
    }
    if (m.find("EndpointId") != m.end() && !m["EndpointId"].empty()) {
      endpointId = make_shared<string>(boost::any_cast<string>(m["EndpointId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
  }


  virtual ~DeleteBasicAccelerateIpEndpointRelationResponseBody() = default;
};
class DeleteBasicAccelerateIpEndpointRelationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteBasicAccelerateIpEndpointRelationResponseBody> body{};

  DeleteBasicAccelerateIpEndpointRelationResponse() {}

  explicit DeleteBasicAccelerateIpEndpointRelationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteBasicAccelerateIpEndpointRelationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteBasicAccelerateIpEndpointRelationResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteBasicAccelerateIpEndpointRelationResponse() = default;
};
class DeleteBasicAcceleratorRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceleratorId{};
  shared_ptr<string> regionId{};

  DeleteBasicAcceleratorRequest() {}

  explicit DeleteBasicAcceleratorRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceleratorId) {
      res["AcceleratorId"] = boost::any(*acceleratorId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceleratorId") != m.end() && !m["AcceleratorId"].empty()) {
      acceleratorId = make_shared<string>(boost::any_cast<string>(m["AcceleratorId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DeleteBasicAcceleratorRequest() = default;
};
class DeleteBasicAcceleratorResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> acceleratorId{};
  shared_ptr<string> requestId{};

  DeleteBasicAcceleratorResponseBody() {}

  explicit DeleteBasicAcceleratorResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceleratorId) {
      res["AcceleratorId"] = boost::any(*acceleratorId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceleratorId") != m.end() && !m["AcceleratorId"].empty()) {
      acceleratorId = make_shared<string>(boost::any_cast<string>(m["AcceleratorId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteBasicAcceleratorResponseBody() = default;
};
class DeleteBasicAcceleratorResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteBasicAcceleratorResponseBody> body{};

  DeleteBasicAcceleratorResponse() {}

  explicit DeleteBasicAcceleratorResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteBasicAcceleratorResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteBasicAcceleratorResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteBasicAcceleratorResponse() = default;
};
class DeleteBasicEndpointRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> endpointGroupId{};
  shared_ptr<string> endpointId{};
  shared_ptr<string> regionId{};

  DeleteBasicEndpointRequest() {}

  explicit DeleteBasicEndpointRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (endpointGroupId) {
      res["EndpointGroupId"] = boost::any(*endpointGroupId);
    }
    if (endpointId) {
      res["EndpointId"] = boost::any(*endpointId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("EndpointGroupId") != m.end() && !m["EndpointGroupId"].empty()) {
      endpointGroupId = make_shared<string>(boost::any_cast<string>(m["EndpointGroupId"]));
    }
    if (m.find("EndpointId") != m.end() && !m["EndpointId"].empty()) {
      endpointId = make_shared<string>(boost::any_cast<string>(m["EndpointId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DeleteBasicEndpointRequest() = default;
};
class DeleteBasicEndpointResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> endpointId{};
  shared_ptr<string> requestId{};

  DeleteBasicEndpointResponseBody() {}

  explicit DeleteBasicEndpointResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endpointId) {
      res["EndpointId"] = boost::any(*endpointId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndpointId") != m.end() && !m["EndpointId"].empty()) {
      endpointId = make_shared<string>(boost::any_cast<string>(m["EndpointId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteBasicEndpointResponseBody() = default;
};
class DeleteBasicEndpointResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteBasicEndpointResponseBody> body{};

  DeleteBasicEndpointResponse() {}

  explicit DeleteBasicEndpointResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteBasicEndpointResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteBasicEndpointResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteBasicEndpointResponse() = default;
};
class DeleteBasicEndpointGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> endpointGroupId{};

  DeleteBasicEndpointGroupRequest() {}

  explicit DeleteBasicEndpointGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (endpointGroupId) {
      res["EndpointGroupId"] = boost::any(*endpointGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("EndpointGroupId") != m.end() && !m["EndpointGroupId"].empty()) {
      endpointGroupId = make_shared<string>(boost::any_cast<string>(m["EndpointGroupId"]));
    }
  }


  virtual ~DeleteBasicEndpointGroupRequest() = default;
};
class DeleteBasicEndpointGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteBasicEndpointGroupResponseBody() {}

  explicit DeleteBasicEndpointGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteBasicEndpointGroupResponseBody() = default;
};
class DeleteBasicEndpointGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteBasicEndpointGroupResponseBody> body{};

  DeleteBasicEndpointGroupResponse() {}

  explicit DeleteBasicEndpointGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteBasicEndpointGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteBasicEndpointGroupResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteBasicEndpointGroupResponse() = default;
};
class DeleteBasicIpSetRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> ipSetId{};
  shared_ptr<string> regionId{};

  DeleteBasicIpSetRequest() {}

  explicit DeleteBasicIpSetRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (ipSetId) {
      res["IpSetId"] = boost::any(*ipSetId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("IpSetId") != m.end() && !m["IpSetId"].empty()) {
      ipSetId = make_shared<string>(boost::any_cast<string>(m["IpSetId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DeleteBasicIpSetRequest() = default;
};
class DeleteBasicIpSetResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteBasicIpSetResponseBody() {}

  explicit DeleteBasicIpSetResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteBasicIpSetResponseBody() = default;
};
class DeleteBasicIpSetResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteBasicIpSetResponseBody> body{};

  DeleteBasicIpSetResponse() {}

  explicit DeleteBasicIpSetResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteBasicIpSetResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteBasicIpSetResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteBasicIpSetResponse() = default;
};
class DeleteCustomRoutingEndpointGroupDestinationsRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<vector<string>> destinationIds{};
  shared_ptr<bool> dryRun{};
  shared_ptr<string> endpointGroupId{};
  shared_ptr<string> regionId{};

  DeleteCustomRoutingEndpointGroupDestinationsRequest() {}

  explicit DeleteCustomRoutingEndpointGroupDestinationsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (destinationIds) {
      res["DestinationIds"] = boost::any(*destinationIds);
    }
    if (dryRun) {
      res["DryRun"] = boost::any(*dryRun);
    }
    if (endpointGroupId) {
      res["EndpointGroupId"] = boost::any(*endpointGroupId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("DestinationIds") != m.end() && !m["DestinationIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DestinationIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DestinationIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      destinationIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("DryRun") != m.end() && !m["DryRun"].empty()) {
      dryRun = make_shared<bool>(boost::any_cast<bool>(m["DryRun"]));
    }
    if (m.find("EndpointGroupId") != m.end() && !m["EndpointGroupId"].empty()) {
      endpointGroupId = make_shared<string>(boost::any_cast<string>(m["EndpointGroupId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DeleteCustomRoutingEndpointGroupDestinationsRequest() = default;
};
class DeleteCustomRoutingEndpointGroupDestinationsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteCustomRoutingEndpointGroupDestinationsResponseBody() {}

  explicit DeleteCustomRoutingEndpointGroupDestinationsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteCustomRoutingEndpointGroupDestinationsResponseBody() = default;
};
class DeleteCustomRoutingEndpointGroupDestinationsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteCustomRoutingEndpointGroupDestinationsResponseBody> body{};

  DeleteCustomRoutingEndpointGroupDestinationsResponse() {}

  explicit DeleteCustomRoutingEndpointGroupDestinationsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteCustomRoutingEndpointGroupDestinationsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteCustomRoutingEndpointGroupDestinationsResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteCustomRoutingEndpointGroupDestinationsResponse() = default;
};
class DeleteCustomRoutingEndpointGroupsRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceleratorId{};
  shared_ptr<string> clientToken{};
  shared_ptr<bool> dryRun{};
  shared_ptr<vector<string>> endpointGroupIds{};
  shared_ptr<string> regionId{};

  DeleteCustomRoutingEndpointGroupsRequest() {}

  explicit DeleteCustomRoutingEndpointGroupsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceleratorId) {
      res["AcceleratorId"] = boost::any(*acceleratorId);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (dryRun) {
      res["DryRun"] = boost::any(*dryRun);
    }
    if (endpointGroupIds) {
      res["EndpointGroupIds"] = boost::any(*endpointGroupIds);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceleratorId") != m.end() && !m["AcceleratorId"].empty()) {
      acceleratorId = make_shared<string>(boost::any_cast<string>(m["AcceleratorId"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("DryRun") != m.end() && !m["DryRun"].empty()) {
      dryRun = make_shared<bool>(boost::any_cast<bool>(m["DryRun"]));
    }
    if (m.find("EndpointGroupIds") != m.end() && !m["EndpointGroupIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["EndpointGroupIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["EndpointGroupIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      endpointGroupIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DeleteCustomRoutingEndpointGroupsRequest() = default;
};
class DeleteCustomRoutingEndpointGroupsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteCustomRoutingEndpointGroupsResponseBody() {}

  explicit DeleteCustomRoutingEndpointGroupsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteCustomRoutingEndpointGroupsResponseBody() = default;
};
class DeleteCustomRoutingEndpointGroupsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteCustomRoutingEndpointGroupsResponseBody> body{};

  DeleteCustomRoutingEndpointGroupsResponse() {}

  explicit DeleteCustomRoutingEndpointGroupsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteCustomRoutingEndpointGroupsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteCustomRoutingEndpointGroupsResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteCustomRoutingEndpointGroupsResponse() = default;
};
class DeleteCustomRoutingEndpointTrafficPoliciesRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> endpointId{};
  shared_ptr<vector<string>> policyIds{};
  shared_ptr<string> regionId{};

  DeleteCustomRoutingEndpointTrafficPoliciesRequest() {}

  explicit DeleteCustomRoutingEndpointTrafficPoliciesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (endpointId) {
      res["EndpointId"] = boost::any(*endpointId);
    }
    if (policyIds) {
      res["PolicyIds"] = boost::any(*policyIds);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("EndpointId") != m.end() && !m["EndpointId"].empty()) {
      endpointId = make_shared<string>(boost::any_cast<string>(m["EndpointId"]));
    }
    if (m.find("PolicyIds") != m.end() && !m["PolicyIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["PolicyIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["PolicyIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      policyIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DeleteCustomRoutingEndpointTrafficPoliciesRequest() = default;
};
class DeleteCustomRoutingEndpointTrafficPoliciesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteCustomRoutingEndpointTrafficPoliciesResponseBody() {}

  explicit DeleteCustomRoutingEndpointTrafficPoliciesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteCustomRoutingEndpointTrafficPoliciesResponseBody() = default;
};
class DeleteCustomRoutingEndpointTrafficPoliciesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteCustomRoutingEndpointTrafficPoliciesResponseBody> body{};

  DeleteCustomRoutingEndpointTrafficPoliciesResponse() {}

  explicit DeleteCustomRoutingEndpointTrafficPoliciesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteCustomRoutingEndpointTrafficPoliciesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteCustomRoutingEndpointTrafficPoliciesResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteCustomRoutingEndpointTrafficPoliciesResponse() = default;
};
class DeleteCustomRoutingEndpointsRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> endpointGroupId{};
  shared_ptr<vector<string>> endpointIds{};
  shared_ptr<string> regionId{};

  DeleteCustomRoutingEndpointsRequest() {}

  explicit DeleteCustomRoutingEndpointsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (endpointGroupId) {
      res["EndpointGroupId"] = boost::any(*endpointGroupId);
    }
    if (endpointIds) {
      res["EndpointIds"] = boost::any(*endpointIds);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("EndpointGroupId") != m.end() && !m["EndpointGroupId"].empty()) {
      endpointGroupId = make_shared<string>(boost::any_cast<string>(m["EndpointGroupId"]));
    }
    if (m.find("EndpointIds") != m.end() && !m["EndpointIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["EndpointIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["EndpointIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      endpointIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DeleteCustomRoutingEndpointsRequest() = default;
};
class DeleteCustomRoutingEndpointsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteCustomRoutingEndpointsResponseBody() {}

  explicit DeleteCustomRoutingEndpointsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteCustomRoutingEndpointsResponseBody() = default;
};
class DeleteCustomRoutingEndpointsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteCustomRoutingEndpointsResponseBody> body{};

  DeleteCustomRoutingEndpointsResponse() {}

  explicit DeleteCustomRoutingEndpointsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteCustomRoutingEndpointsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteCustomRoutingEndpointsResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteCustomRoutingEndpointsResponse() = default;
};
class DeleteDomainAcceleratorRelationRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> acceleratorIds{};
  shared_ptr<string> domain{};
  shared_ptr<string> regionId{};

  DeleteDomainAcceleratorRelationRequest() {}

  explicit DeleteDomainAcceleratorRelationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceleratorIds) {
      res["AcceleratorIds"] = boost::any(*acceleratorIds);
    }
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceleratorIds") != m.end() && !m["AcceleratorIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["AcceleratorIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["AcceleratorIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      acceleratorIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DeleteDomainAcceleratorRelationRequest() = default;
};
class DeleteDomainAcceleratorRelationResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteDomainAcceleratorRelationResponseBody() {}

  explicit DeleteDomainAcceleratorRelationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteDomainAcceleratorRelationResponseBody() = default;
};
class DeleteDomainAcceleratorRelationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteDomainAcceleratorRelationResponseBody> body{};

  DeleteDomainAcceleratorRelationResponse() {}

  explicit DeleteDomainAcceleratorRelationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteDomainAcceleratorRelationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteDomainAcceleratorRelationResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteDomainAcceleratorRelationResponse() = default;
};
class DeleteEndpointGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceleratorId{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> endpointGroupId{};

  DeleteEndpointGroupRequest() {}

  explicit DeleteEndpointGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceleratorId) {
      res["AcceleratorId"] = boost::any(*acceleratorId);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (endpointGroupId) {
      res["EndpointGroupId"] = boost::any(*endpointGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceleratorId") != m.end() && !m["AcceleratorId"].empty()) {
      acceleratorId = make_shared<string>(boost::any_cast<string>(m["AcceleratorId"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("EndpointGroupId") != m.end() && !m["EndpointGroupId"].empty()) {
      endpointGroupId = make_shared<string>(boost::any_cast<string>(m["EndpointGroupId"]));
    }
  }


  virtual ~DeleteEndpointGroupRequest() = default;
};
class DeleteEndpointGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteEndpointGroupResponseBody() {}

  explicit DeleteEndpointGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteEndpointGroupResponseBody() = default;
};
class DeleteEndpointGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteEndpointGroupResponseBody> body{};

  DeleteEndpointGroupResponse() {}

  explicit DeleteEndpointGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteEndpointGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteEndpointGroupResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteEndpointGroupResponse() = default;
};
class DeleteEndpointGroupsRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<bool> dryRun{};
  shared_ptr<vector<string>> endpointGroupIds{};
  shared_ptr<string> regionId{};

  DeleteEndpointGroupsRequest() {}

  explicit DeleteEndpointGroupsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (dryRun) {
      res["DryRun"] = boost::any(*dryRun);
    }
    if (endpointGroupIds) {
      res["EndpointGroupIds"] = boost::any(*endpointGroupIds);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("DryRun") != m.end() && !m["DryRun"].empty()) {
      dryRun = make_shared<bool>(boost::any_cast<bool>(m["DryRun"]));
    }
    if (m.find("EndpointGroupIds") != m.end() && !m["EndpointGroupIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["EndpointGroupIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["EndpointGroupIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      endpointGroupIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DeleteEndpointGroupsRequest() = default;
};
class DeleteEndpointGroupsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteEndpointGroupsResponseBody() {}

  explicit DeleteEndpointGroupsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteEndpointGroupsResponseBody() = default;
};
class DeleteEndpointGroupsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteEndpointGroupsResponseBody> body{};

  DeleteEndpointGroupsResponse() {}

  explicit DeleteEndpointGroupsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteEndpointGroupsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteEndpointGroupsResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteEndpointGroupsResponse() = default;
};
class DeleteForwardingRulesRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceleratorId{};
  shared_ptr<string> clientToken{};
  shared_ptr<vector<string>> forwardingRuleIds{};
  shared_ptr<string> listenerId{};
  shared_ptr<string> regionId{};

  DeleteForwardingRulesRequest() {}

  explicit DeleteForwardingRulesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceleratorId) {
      res["AcceleratorId"] = boost::any(*acceleratorId);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (forwardingRuleIds) {
      res["ForwardingRuleIds"] = boost::any(*forwardingRuleIds);
    }
    if (listenerId) {
      res["ListenerId"] = boost::any(*listenerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceleratorId") != m.end() && !m["AcceleratorId"].empty()) {
      acceleratorId = make_shared<string>(boost::any_cast<string>(m["AcceleratorId"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("ForwardingRuleIds") != m.end() && !m["ForwardingRuleIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ForwardingRuleIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ForwardingRuleIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      forwardingRuleIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ListenerId") != m.end() && !m["ListenerId"].empty()) {
      listenerId = make_shared<string>(boost::any_cast<string>(m["ListenerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DeleteForwardingRulesRequest() = default;
};
class DeleteForwardingRulesResponseBodyForwardingRules : public Darabonba::Model {
public:
  shared_ptr<string> forwardingRuleId{};

  DeleteForwardingRulesResponseBodyForwardingRules() {}

  explicit DeleteForwardingRulesResponseBodyForwardingRules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (forwardingRuleId) {
      res["ForwardingRuleId"] = boost::any(*forwardingRuleId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ForwardingRuleId") != m.end() && !m["ForwardingRuleId"].empty()) {
      forwardingRuleId = make_shared<string>(boost::any_cast<string>(m["ForwardingRuleId"]));
    }
  }


  virtual ~DeleteForwardingRulesResponseBodyForwardingRules() = default;
};
class DeleteForwardingRulesResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DeleteForwardingRulesResponseBodyForwardingRules>> forwardingRules{};
  shared_ptr<string> requestId{};

  DeleteForwardingRulesResponseBody() {}

  explicit DeleteForwardingRulesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (forwardingRules) {
      vector<boost::any> temp1;
      for(auto item1:*forwardingRules){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ForwardingRules"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ForwardingRules") != m.end() && !m["ForwardingRules"].empty()) {
      if (typeid(vector<boost::any>) == m["ForwardingRules"].type()) {
        vector<DeleteForwardingRulesResponseBodyForwardingRules> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ForwardingRules"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DeleteForwardingRulesResponseBodyForwardingRules model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        forwardingRules = make_shared<vector<DeleteForwardingRulesResponseBodyForwardingRules>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteForwardingRulesResponseBody() = default;
};
class DeleteForwardingRulesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteForwardingRulesResponseBody> body{};

  DeleteForwardingRulesResponse() {}

  explicit DeleteForwardingRulesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteForwardingRulesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteForwardingRulesResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteForwardingRulesResponse() = default;
};
class DeleteIpSetRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceleratorId{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> ipSetId{};
  shared_ptr<string> regionId{};

  DeleteIpSetRequest() {}

  explicit DeleteIpSetRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceleratorId) {
      res["AcceleratorId"] = boost::any(*acceleratorId);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (ipSetId) {
      res["IpSetId"] = boost::any(*ipSetId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceleratorId") != m.end() && !m["AcceleratorId"].empty()) {
      acceleratorId = make_shared<string>(boost::any_cast<string>(m["AcceleratorId"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("IpSetId") != m.end() && !m["IpSetId"].empty()) {
      ipSetId = make_shared<string>(boost::any_cast<string>(m["IpSetId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DeleteIpSetRequest() = default;
};
class DeleteIpSetResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteIpSetResponseBody() {}

  explicit DeleteIpSetResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteIpSetResponseBody() = default;
};
class DeleteIpSetResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteIpSetResponseBody> body{};

  DeleteIpSetResponse() {}

  explicit DeleteIpSetResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteIpSetResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteIpSetResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteIpSetResponse() = default;
};
class DeleteIpSetsRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> ipSetIds{};
  shared_ptr<string> regionId{};

  DeleteIpSetsRequest() {}

  explicit DeleteIpSetsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ipSetIds) {
      res["IpSetIds"] = boost::any(*ipSetIds);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IpSetIds") != m.end() && !m["IpSetIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["IpSetIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["IpSetIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      ipSetIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DeleteIpSetsRequest() = default;
};
class DeleteIpSetsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteIpSetsResponseBody() {}

  explicit DeleteIpSetsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteIpSetsResponseBody() = default;
};
class DeleteIpSetsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteIpSetsResponseBody> body{};

  DeleteIpSetsResponse() {}

  explicit DeleteIpSetsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteIpSetsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteIpSetsResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteIpSetsResponse() = default;
};
class DeleteListenerRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceleratorId{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> listenerId{};

  DeleteListenerRequest() {}

  explicit DeleteListenerRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceleratorId) {
      res["AcceleratorId"] = boost::any(*acceleratorId);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (listenerId) {
      res["ListenerId"] = boost::any(*listenerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceleratorId") != m.end() && !m["AcceleratorId"].empty()) {
      acceleratorId = make_shared<string>(boost::any_cast<string>(m["AcceleratorId"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("ListenerId") != m.end() && !m["ListenerId"].empty()) {
      listenerId = make_shared<string>(boost::any_cast<string>(m["ListenerId"]));
    }
  }


  virtual ~DeleteListenerRequest() = default;
};
class DeleteListenerResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteListenerResponseBody() {}

  explicit DeleteListenerResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteListenerResponseBody() = default;
};
class DeleteListenerResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteListenerResponseBody> body{};

  DeleteListenerResponse() {}

  explicit DeleteListenerResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteListenerResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteListenerResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteListenerResponse() = default;
};
class DeleteSpareIpsRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceleratorId{};
  shared_ptr<string> clientToken{};
  shared_ptr<bool> dryRun{};
  shared_ptr<string> regionId{};
  shared_ptr<vector<string>> spareIps{};

  DeleteSpareIpsRequest() {}

  explicit DeleteSpareIpsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceleratorId) {
      res["AcceleratorId"] = boost::any(*acceleratorId);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (dryRun) {
      res["DryRun"] = boost::any(*dryRun);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (spareIps) {
      res["SpareIps"] = boost::any(*spareIps);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceleratorId") != m.end() && !m["AcceleratorId"].empty()) {
      acceleratorId = make_shared<string>(boost::any_cast<string>(m["AcceleratorId"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("DryRun") != m.end() && !m["DryRun"].empty()) {
      dryRun = make_shared<bool>(boost::any_cast<bool>(m["DryRun"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SpareIps") != m.end() && !m["SpareIps"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SpareIps"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SpareIps"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      spareIps = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DeleteSpareIpsRequest() = default;
};
class DeleteSpareIpsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteSpareIpsResponseBody() {}

  explicit DeleteSpareIpsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteSpareIpsResponseBody() = default;
};
class DeleteSpareIpsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteSpareIpsResponseBody> body{};

  DeleteSpareIpsResponse() {}

  explicit DeleteSpareIpsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteSpareIpsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteSpareIpsResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteSpareIpsResponse() = default;
};
class DescribeAcceleratorRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceleratorId{};
  shared_ptr<string> regionId{};

  DescribeAcceleratorRequest() {}

  explicit DescribeAcceleratorRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceleratorId) {
      res["AcceleratorId"] = boost::any(*acceleratorId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceleratorId") != m.end() && !m["AcceleratorId"].empty()) {
      acceleratorId = make_shared<string>(boost::any_cast<string>(m["AcceleratorId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DescribeAcceleratorRequest() = default;
};
class DescribeAcceleratorResponseBodyBasicBandwidthPackage : public Darabonba::Model {
public:
  shared_ptr<long> bandwidth{};
  shared_ptr<string> bandwidthType{};
  shared_ptr<string> instanceId{};

  DescribeAcceleratorResponseBodyBasicBandwidthPackage() {}

  explicit DescribeAcceleratorResponseBodyBasicBandwidthPackage(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bandwidth) {
      res["Bandwidth"] = boost::any(*bandwidth);
    }
    if (bandwidthType) {
      res["BandwidthType"] = boost::any(*bandwidthType);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bandwidth") != m.end() && !m["Bandwidth"].empty()) {
      bandwidth = make_shared<long>(boost::any_cast<long>(m["Bandwidth"]));
    }
    if (m.find("BandwidthType") != m.end() && !m["BandwidthType"].empty()) {
      bandwidthType = make_shared<string>(boost::any_cast<string>(m["BandwidthType"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~DescribeAcceleratorResponseBodyBasicBandwidthPackage() = default;
};
class DescribeAcceleratorResponseBodyCrossDomainBandwidthPackage : public Darabonba::Model {
public:
  shared_ptr<long> bandwidth{};
  shared_ptr<string> instanceId{};

  DescribeAcceleratorResponseBodyCrossDomainBandwidthPackage() {}

  explicit DescribeAcceleratorResponseBodyCrossDomainBandwidthPackage(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bandwidth) {
      res["Bandwidth"] = boost::any(*bandwidth);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bandwidth") != m.end() && !m["Bandwidth"].empty()) {
      bandwidth = make_shared<long>(boost::any_cast<long>(m["Bandwidth"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~DescribeAcceleratorResponseBodyCrossDomainBandwidthPackage() = default;
};
class DescribeAcceleratorResponseBodyIpSetConfig : public Darabonba::Model {
public:
  shared_ptr<string> accessMode{};

  DescribeAcceleratorResponseBodyIpSetConfig() {}

  explicit DescribeAcceleratorResponseBodyIpSetConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessMode) {
      res["AccessMode"] = boost::any(*accessMode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccessMode") != m.end() && !m["AccessMode"].empty()) {
      accessMode = make_shared<string>(boost::any_cast<string>(m["AccessMode"]));
    }
  }


  virtual ~DescribeAcceleratorResponseBodyIpSetConfig() = default;
};
class DescribeAcceleratorResponseBodyTags : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  DescribeAcceleratorResponseBodyTags() {}

  explicit DescribeAcceleratorResponseBodyTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeAcceleratorResponseBodyTags() = default;
};
class DescribeAcceleratorResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> acceleratorId{};
  shared_ptr<string> bandwidthBillingType{};
  shared_ptr<DescribeAcceleratorResponseBodyBasicBandwidthPackage> basicBandwidthPackage{};
  shared_ptr<string> cenId{};
  shared_ptr<long> createTime{};
  shared_ptr<string> crossBorderMode{};
  shared_ptr<bool> crossBorderStatus{};
  shared_ptr<DescribeAcceleratorResponseBodyCrossDomainBandwidthPackage> crossDomainBandwidthPackage{};
  shared_ptr<string> crossPrivateState{};
  shared_ptr<string> ddosId{};
  shared_ptr<string> description{};
  shared_ptr<string> dnsName{};
  shared_ptr<long> expiredTime{};
  shared_ptr<string> instanceChargeType{};
  shared_ptr<DescribeAcceleratorResponseBodyIpSetConfig> ipSetConfig{};
  shared_ptr<string> name{};
  shared_ptr<string> regionId{};
  shared_ptr<string> requestId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> secondDnsName{};
  shared_ptr<string> spec{};
  shared_ptr<string> state{};
  shared_ptr<vector<DescribeAcceleratorResponseBodyTags>> tags{};

  DescribeAcceleratorResponseBody() {}

  explicit DescribeAcceleratorResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceleratorId) {
      res["AcceleratorId"] = boost::any(*acceleratorId);
    }
    if (bandwidthBillingType) {
      res["BandwidthBillingType"] = boost::any(*bandwidthBillingType);
    }
    if (basicBandwidthPackage) {
      res["BasicBandwidthPackage"] = basicBandwidthPackage ? boost::any(basicBandwidthPackage->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (cenId) {
      res["CenId"] = boost::any(*cenId);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (crossBorderMode) {
      res["CrossBorderMode"] = boost::any(*crossBorderMode);
    }
    if (crossBorderStatus) {
      res["CrossBorderStatus"] = boost::any(*crossBorderStatus);
    }
    if (crossDomainBandwidthPackage) {
      res["CrossDomainBandwidthPackage"] = crossDomainBandwidthPackage ? boost::any(crossDomainBandwidthPackage->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (crossPrivateState) {
      res["CrossPrivateState"] = boost::any(*crossPrivateState);
    }
    if (ddosId) {
      res["DdosId"] = boost::any(*ddosId);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (dnsName) {
      res["DnsName"] = boost::any(*dnsName);
    }
    if (expiredTime) {
      res["ExpiredTime"] = boost::any(*expiredTime);
    }
    if (instanceChargeType) {
      res["InstanceChargeType"] = boost::any(*instanceChargeType);
    }
    if (ipSetConfig) {
      res["IpSetConfig"] = ipSetConfig ? boost::any(ipSetConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (secondDnsName) {
      res["SecondDnsName"] = boost::any(*secondDnsName);
    }
    if (spec) {
      res["Spec"] = boost::any(*spec);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tags"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceleratorId") != m.end() && !m["AcceleratorId"].empty()) {
      acceleratorId = make_shared<string>(boost::any_cast<string>(m["AcceleratorId"]));
    }
    if (m.find("BandwidthBillingType") != m.end() && !m["BandwidthBillingType"].empty()) {
      bandwidthBillingType = make_shared<string>(boost::any_cast<string>(m["BandwidthBillingType"]));
    }
    if (m.find("BasicBandwidthPackage") != m.end() && !m["BasicBandwidthPackage"].empty()) {
      if (typeid(map<string, boost::any>) == m["BasicBandwidthPackage"].type()) {
        DescribeAcceleratorResponseBodyBasicBandwidthPackage model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["BasicBandwidthPackage"]));
        basicBandwidthPackage = make_shared<DescribeAcceleratorResponseBodyBasicBandwidthPackage>(model1);
      }
    }
    if (m.find("CenId") != m.end() && !m["CenId"].empty()) {
      cenId = make_shared<string>(boost::any_cast<string>(m["CenId"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("CrossBorderMode") != m.end() && !m["CrossBorderMode"].empty()) {
      crossBorderMode = make_shared<string>(boost::any_cast<string>(m["CrossBorderMode"]));
    }
    if (m.find("CrossBorderStatus") != m.end() && !m["CrossBorderStatus"].empty()) {
      crossBorderStatus = make_shared<bool>(boost::any_cast<bool>(m["CrossBorderStatus"]));
    }
    if (m.find("CrossDomainBandwidthPackage") != m.end() && !m["CrossDomainBandwidthPackage"].empty()) {
      if (typeid(map<string, boost::any>) == m["CrossDomainBandwidthPackage"].type()) {
        DescribeAcceleratorResponseBodyCrossDomainBandwidthPackage model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CrossDomainBandwidthPackage"]));
        crossDomainBandwidthPackage = make_shared<DescribeAcceleratorResponseBodyCrossDomainBandwidthPackage>(model1);
      }
    }
    if (m.find("CrossPrivateState") != m.end() && !m["CrossPrivateState"].empty()) {
      crossPrivateState = make_shared<string>(boost::any_cast<string>(m["CrossPrivateState"]));
    }
    if (m.find("DdosId") != m.end() && !m["DdosId"].empty()) {
      ddosId = make_shared<string>(boost::any_cast<string>(m["DdosId"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DnsName") != m.end() && !m["DnsName"].empty()) {
      dnsName = make_shared<string>(boost::any_cast<string>(m["DnsName"]));
    }
    if (m.find("ExpiredTime") != m.end() && !m["ExpiredTime"].empty()) {
      expiredTime = make_shared<long>(boost::any_cast<long>(m["ExpiredTime"]));
    }
    if (m.find("InstanceChargeType") != m.end() && !m["InstanceChargeType"].empty()) {
      instanceChargeType = make_shared<string>(boost::any_cast<string>(m["InstanceChargeType"]));
    }
    if (m.find("IpSetConfig") != m.end() && !m["IpSetConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["IpSetConfig"].type()) {
        DescribeAcceleratorResponseBodyIpSetConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["IpSetConfig"]));
        ipSetConfig = make_shared<DescribeAcceleratorResponseBodyIpSetConfig>(model1);
      }
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("SecondDnsName") != m.end() && !m["SecondDnsName"].empty()) {
      secondDnsName = make_shared<string>(boost::any_cast<string>(m["SecondDnsName"]));
    }
    if (m.find("Spec") != m.end() && !m["Spec"].empty()) {
      spec = make_shared<string>(boost::any_cast<string>(m["Spec"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(vector<boost::any>) == m["Tags"].type()) {
        vector<DescribeAcceleratorResponseBodyTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeAcceleratorResponseBodyTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<DescribeAcceleratorResponseBodyTags>>(expect1);
      }
    }
  }


  virtual ~DescribeAcceleratorResponseBody() = default;
};
class DescribeAcceleratorResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeAcceleratorResponseBody> body{};

  DescribeAcceleratorResponse() {}

  explicit DescribeAcceleratorResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeAcceleratorResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeAcceleratorResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeAcceleratorResponse() = default;
};
class DescribeAcceleratorAutoRenewAttributeRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceleratorId{};
  shared_ptr<string> regionId{};

  DescribeAcceleratorAutoRenewAttributeRequest() {}

  explicit DescribeAcceleratorAutoRenewAttributeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceleratorId) {
      res["AcceleratorId"] = boost::any(*acceleratorId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceleratorId") != m.end() && !m["AcceleratorId"].empty()) {
      acceleratorId = make_shared<string>(boost::any_cast<string>(m["AcceleratorId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DescribeAcceleratorAutoRenewAttributeRequest() = default;
};
class DescribeAcceleratorAutoRenewAttributeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> acceleratorId{};
  shared_ptr<bool> autoRenew{};
  shared_ptr<long> autoRenewDuration{};
  shared_ptr<string> renewalStatus{};
  shared_ptr<string> requestId{};

  DescribeAcceleratorAutoRenewAttributeResponseBody() {}

  explicit DescribeAcceleratorAutoRenewAttributeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceleratorId) {
      res["AcceleratorId"] = boost::any(*acceleratorId);
    }
    if (autoRenew) {
      res["AutoRenew"] = boost::any(*autoRenew);
    }
    if (autoRenewDuration) {
      res["AutoRenewDuration"] = boost::any(*autoRenewDuration);
    }
    if (renewalStatus) {
      res["RenewalStatus"] = boost::any(*renewalStatus);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceleratorId") != m.end() && !m["AcceleratorId"].empty()) {
      acceleratorId = make_shared<string>(boost::any_cast<string>(m["AcceleratorId"]));
    }
    if (m.find("AutoRenew") != m.end() && !m["AutoRenew"].empty()) {
      autoRenew = make_shared<bool>(boost::any_cast<bool>(m["AutoRenew"]));
    }
    if (m.find("AutoRenewDuration") != m.end() && !m["AutoRenewDuration"].empty()) {
      autoRenewDuration = make_shared<long>(boost::any_cast<long>(m["AutoRenewDuration"]));
    }
    if (m.find("RenewalStatus") != m.end() && !m["RenewalStatus"].empty()) {
      renewalStatus = make_shared<string>(boost::any_cast<string>(m["RenewalStatus"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeAcceleratorAutoRenewAttributeResponseBody() = default;
};
class DescribeAcceleratorAutoRenewAttributeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeAcceleratorAutoRenewAttributeResponseBody> body{};

  DescribeAcceleratorAutoRenewAttributeResponse() {}

  explicit DescribeAcceleratorAutoRenewAttributeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeAcceleratorAutoRenewAttributeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeAcceleratorAutoRenewAttributeResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeAcceleratorAutoRenewAttributeResponse() = default;
};
class DescribeApplicationMonitorRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> regionId{};
  shared_ptr<string> taskId{};

  DescribeApplicationMonitorRequest() {}

  explicit DescribeApplicationMonitorRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
  }


  virtual ~DescribeApplicationMonitorRequest() = default;
};
class DescribeApplicationMonitorResponseBodyIspCityList : public Darabonba::Model {
public:
  shared_ptr<string> city{};
  shared_ptr<string> cityName{};
  shared_ptr<string> isp{};
  shared_ptr<string> ispName{};

  DescribeApplicationMonitorResponseBodyIspCityList() {}

  explicit DescribeApplicationMonitorResponseBodyIspCityList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (city) {
      res["City"] = boost::any(*city);
    }
    if (cityName) {
      res["CityName"] = boost::any(*cityName);
    }
    if (isp) {
      res["Isp"] = boost::any(*isp);
    }
    if (ispName) {
      res["IspName"] = boost::any(*ispName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("City") != m.end() && !m["City"].empty()) {
      city = make_shared<string>(boost::any_cast<string>(m["City"]));
    }
    if (m.find("CityName") != m.end() && !m["CityName"].empty()) {
      cityName = make_shared<string>(boost::any_cast<string>(m["CityName"]));
    }
    if (m.find("Isp") != m.end() && !m["Isp"].empty()) {
      isp = make_shared<string>(boost::any_cast<string>(m["Isp"]));
    }
    if (m.find("IspName") != m.end() && !m["IspName"].empty()) {
      ispName = make_shared<string>(boost::any_cast<string>(m["IspName"]));
    }
  }


  virtual ~DescribeApplicationMonitorResponseBodyIspCityList() = default;
};
class DescribeApplicationMonitorResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> acceleratorId{};
  shared_ptr<string> address{};
  shared_ptr<bool> detectEnable{};
  shared_ptr<long> detectThreshold{};
  shared_ptr<long> detectTimes{};
  shared_ptr<vector<DescribeApplicationMonitorResponseBodyIspCityList>> ispCityList{};
  shared_ptr<string> listenerId{};
  shared_ptr<string> optionsJson{};
  shared_ptr<string> regionId{};
  shared_ptr<string> requestId{};
  shared_ptr<long> silenceTime{};
  shared_ptr<string> taskId{};
  shared_ptr<string> taskName{};

  DescribeApplicationMonitorResponseBody() {}

  explicit DescribeApplicationMonitorResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceleratorId) {
      res["AcceleratorId"] = boost::any(*acceleratorId);
    }
    if (address) {
      res["Address"] = boost::any(*address);
    }
    if (detectEnable) {
      res["DetectEnable"] = boost::any(*detectEnable);
    }
    if (detectThreshold) {
      res["DetectThreshold"] = boost::any(*detectThreshold);
    }
    if (detectTimes) {
      res["DetectTimes"] = boost::any(*detectTimes);
    }
    if (ispCityList) {
      vector<boost::any> temp1;
      for(auto item1:*ispCityList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["IspCityList"] = boost::any(temp1);
    }
    if (listenerId) {
      res["ListenerId"] = boost::any(*listenerId);
    }
    if (optionsJson) {
      res["OptionsJson"] = boost::any(*optionsJson);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (silenceTime) {
      res["SilenceTime"] = boost::any(*silenceTime);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (taskName) {
      res["TaskName"] = boost::any(*taskName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceleratorId") != m.end() && !m["AcceleratorId"].empty()) {
      acceleratorId = make_shared<string>(boost::any_cast<string>(m["AcceleratorId"]));
    }
    if (m.find("Address") != m.end() && !m["Address"].empty()) {
      address = make_shared<string>(boost::any_cast<string>(m["Address"]));
    }
    if (m.find("DetectEnable") != m.end() && !m["DetectEnable"].empty()) {
      detectEnable = make_shared<bool>(boost::any_cast<bool>(m["DetectEnable"]));
    }
    if (m.find("DetectThreshold") != m.end() && !m["DetectThreshold"].empty()) {
      detectThreshold = make_shared<long>(boost::any_cast<long>(m["DetectThreshold"]));
    }
    if (m.find("DetectTimes") != m.end() && !m["DetectTimes"].empty()) {
      detectTimes = make_shared<long>(boost::any_cast<long>(m["DetectTimes"]));
    }
    if (m.find("IspCityList") != m.end() && !m["IspCityList"].empty()) {
      if (typeid(vector<boost::any>) == m["IspCityList"].type()) {
        vector<DescribeApplicationMonitorResponseBodyIspCityList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["IspCityList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeApplicationMonitorResponseBodyIspCityList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ispCityList = make_shared<vector<DescribeApplicationMonitorResponseBodyIspCityList>>(expect1);
      }
    }
    if (m.find("ListenerId") != m.end() && !m["ListenerId"].empty()) {
      listenerId = make_shared<string>(boost::any_cast<string>(m["ListenerId"]));
    }
    if (m.find("OptionsJson") != m.end() && !m["OptionsJson"].empty()) {
      optionsJson = make_shared<string>(boost::any_cast<string>(m["OptionsJson"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SilenceTime") != m.end() && !m["SilenceTime"].empty()) {
      silenceTime = make_shared<long>(boost::any_cast<long>(m["SilenceTime"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("TaskName") != m.end() && !m["TaskName"].empty()) {
      taskName = make_shared<string>(boost::any_cast<string>(m["TaskName"]));
    }
  }


  virtual ~DescribeApplicationMonitorResponseBody() = default;
};
class DescribeApplicationMonitorResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeApplicationMonitorResponseBody> body{};

  DescribeApplicationMonitorResponse() {}

  explicit DescribeApplicationMonitorResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeApplicationMonitorResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeApplicationMonitorResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeApplicationMonitorResponse() = default;
};
class DescribeBandwidthPackageRequest : public Darabonba::Model {
public:
  shared_ptr<string> bandwidthPackageId{};
  shared_ptr<string> regionId{};

  DescribeBandwidthPackageRequest() {}

  explicit DescribeBandwidthPackageRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bandwidthPackageId) {
      res["BandwidthPackageId"] = boost::any(*bandwidthPackageId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BandwidthPackageId") != m.end() && !m["BandwidthPackageId"].empty()) {
      bandwidthPackageId = make_shared<string>(boost::any_cast<string>(m["BandwidthPackageId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DescribeBandwidthPackageRequest() = default;
};
class DescribeBandwidthPackageResponseBodyTags : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  DescribeBandwidthPackageResponseBodyTags() {}

  explicit DescribeBandwidthPackageResponseBodyTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeBandwidthPackageResponseBodyTags() = default;
};
class DescribeBandwidthPackageResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<string>> accelerators{};
  shared_ptr<long> bandwidth{};
  shared_ptr<string> bandwidthPackageId{};
  shared_ptr<string> bandwidthType{};
  shared_ptr<string> billingType{};
  shared_ptr<string> cbnGeographicRegionIdA{};
  shared_ptr<string> cbnGeographicRegionIdB{};
  shared_ptr<string> chargeType{};
  shared_ptr<string> createTime{};
  shared_ptr<string> description{};
  shared_ptr<string> expiredTime{};
  shared_ptr<string> name{};
  shared_ptr<long> ratio{};
  shared_ptr<string> regionId{};
  shared_ptr<string> requestId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> state{};
  shared_ptr<vector<DescribeBandwidthPackageResponseBodyTags>> tags{};
  shared_ptr<string> type{};

  DescribeBandwidthPackageResponseBody() {}

  explicit DescribeBandwidthPackageResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accelerators) {
      res["Accelerators"] = boost::any(*accelerators);
    }
    if (bandwidth) {
      res["Bandwidth"] = boost::any(*bandwidth);
    }
    if (bandwidthPackageId) {
      res["BandwidthPackageId"] = boost::any(*bandwidthPackageId);
    }
    if (bandwidthType) {
      res["BandwidthType"] = boost::any(*bandwidthType);
    }
    if (billingType) {
      res["BillingType"] = boost::any(*billingType);
    }
    if (cbnGeographicRegionIdA) {
      res["CbnGeographicRegionIdA"] = boost::any(*cbnGeographicRegionIdA);
    }
    if (cbnGeographicRegionIdB) {
      res["CbnGeographicRegionIdB"] = boost::any(*cbnGeographicRegionIdB);
    }
    if (chargeType) {
      res["ChargeType"] = boost::any(*chargeType);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (expiredTime) {
      res["ExpiredTime"] = boost::any(*expiredTime);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (ratio) {
      res["Ratio"] = boost::any(*ratio);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tags"] = boost::any(temp1);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Accelerators") != m.end() && !m["Accelerators"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Accelerators"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Accelerators"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      accelerators = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Bandwidth") != m.end() && !m["Bandwidth"].empty()) {
      bandwidth = make_shared<long>(boost::any_cast<long>(m["Bandwidth"]));
    }
    if (m.find("BandwidthPackageId") != m.end() && !m["BandwidthPackageId"].empty()) {
      bandwidthPackageId = make_shared<string>(boost::any_cast<string>(m["BandwidthPackageId"]));
    }
    if (m.find("BandwidthType") != m.end() && !m["BandwidthType"].empty()) {
      bandwidthType = make_shared<string>(boost::any_cast<string>(m["BandwidthType"]));
    }
    if (m.find("BillingType") != m.end() && !m["BillingType"].empty()) {
      billingType = make_shared<string>(boost::any_cast<string>(m["BillingType"]));
    }
    if (m.find("CbnGeographicRegionIdA") != m.end() && !m["CbnGeographicRegionIdA"].empty()) {
      cbnGeographicRegionIdA = make_shared<string>(boost::any_cast<string>(m["CbnGeographicRegionIdA"]));
    }
    if (m.find("CbnGeographicRegionIdB") != m.end() && !m["CbnGeographicRegionIdB"].empty()) {
      cbnGeographicRegionIdB = make_shared<string>(boost::any_cast<string>(m["CbnGeographicRegionIdB"]));
    }
    if (m.find("ChargeType") != m.end() && !m["ChargeType"].empty()) {
      chargeType = make_shared<string>(boost::any_cast<string>(m["ChargeType"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("ExpiredTime") != m.end() && !m["ExpiredTime"].empty()) {
      expiredTime = make_shared<string>(boost::any_cast<string>(m["ExpiredTime"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Ratio") != m.end() && !m["Ratio"].empty()) {
      ratio = make_shared<long>(boost::any_cast<long>(m["Ratio"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(vector<boost::any>) == m["Tags"].type()) {
        vector<DescribeBandwidthPackageResponseBodyTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeBandwidthPackageResponseBodyTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<DescribeBandwidthPackageResponseBodyTags>>(expect1);
      }
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DescribeBandwidthPackageResponseBody() = default;
};
class DescribeBandwidthPackageResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeBandwidthPackageResponseBody> body{};

  DescribeBandwidthPackageResponse() {}

  explicit DescribeBandwidthPackageResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeBandwidthPackageResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeBandwidthPackageResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeBandwidthPackageResponse() = default;
};
class DescribeBandwidthPackageAutoRenewAttributeRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> regionId{};

  DescribeBandwidthPackageAutoRenewAttributeRequest() {}

  explicit DescribeBandwidthPackageAutoRenewAttributeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DescribeBandwidthPackageAutoRenewAttributeRequest() = default;
};
class DescribeBandwidthPackageAutoRenewAttributeResponseBody : public Darabonba::Model {
public:
  shared_ptr<bool> autoRenew{};
  shared_ptr<long> autoRenewDuration{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> renewalStatus{};
  shared_ptr<string> requestId{};

  DescribeBandwidthPackageAutoRenewAttributeResponseBody() {}

  explicit DescribeBandwidthPackageAutoRenewAttributeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (autoRenew) {
      res["AutoRenew"] = boost::any(*autoRenew);
    }
    if (autoRenewDuration) {
      res["AutoRenewDuration"] = boost::any(*autoRenewDuration);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (renewalStatus) {
      res["RenewalStatus"] = boost::any(*renewalStatus);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AutoRenew") != m.end() && !m["AutoRenew"].empty()) {
      autoRenew = make_shared<bool>(boost::any_cast<bool>(m["AutoRenew"]));
    }
    if (m.find("AutoRenewDuration") != m.end() && !m["AutoRenewDuration"].empty()) {
      autoRenewDuration = make_shared<long>(boost::any_cast<long>(m["AutoRenewDuration"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RenewalStatus") != m.end() && !m["RenewalStatus"].empty()) {
      renewalStatus = make_shared<string>(boost::any_cast<string>(m["RenewalStatus"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeBandwidthPackageAutoRenewAttributeResponseBody() = default;
};
class DescribeBandwidthPackageAutoRenewAttributeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeBandwidthPackageAutoRenewAttributeResponseBody> body{};

  DescribeBandwidthPackageAutoRenewAttributeResponse() {}

  explicit DescribeBandwidthPackageAutoRenewAttributeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeBandwidthPackageAutoRenewAttributeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeBandwidthPackageAutoRenewAttributeResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeBandwidthPackageAutoRenewAttributeResponse() = default;
};
class DescribeCommodityRequest : public Darabonba::Model {
public:
  shared_ptr<string> commodityCode{};
  shared_ptr<string> orderType{};
  shared_ptr<string> regionId{};

  DescribeCommodityRequest() {}

  explicit DescribeCommodityRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commodityCode) {
      res["CommodityCode"] = boost::any(*commodityCode);
    }
    if (orderType) {
      res["OrderType"] = boost::any(*orderType);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CommodityCode") != m.end() && !m["CommodityCode"].empty()) {
      commodityCode = make_shared<string>(boost::any_cast<string>(m["CommodityCode"]));
    }
    if (m.find("OrderType") != m.end() && !m["OrderType"].empty()) {
      orderType = make_shared<string>(boost::any_cast<string>(m["OrderType"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DescribeCommodityRequest() = default;
};
class DescribeCommodityResponseBodyComponentsPropertiesPropertyValueList : public Darabonba::Model {
public:
  shared_ptr<long> orderIndex{};
  shared_ptr<string> text{};
  shared_ptr<string> tips{};
  shared_ptr<string> value{};

  DescribeCommodityResponseBodyComponentsPropertiesPropertyValueList() {}

  explicit DescribeCommodityResponseBodyComponentsPropertiesPropertyValueList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (orderIndex) {
      res["OrderIndex"] = boost::any(*orderIndex);
    }
    if (text) {
      res["Text"] = boost::any(*text);
    }
    if (tips) {
      res["Tips"] = boost::any(*tips);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OrderIndex") != m.end() && !m["OrderIndex"].empty()) {
      orderIndex = make_shared<long>(boost::any_cast<long>(m["OrderIndex"]));
    }
    if (m.find("Text") != m.end() && !m["Text"].empty()) {
      text = make_shared<string>(boost::any_cast<string>(m["Text"]));
    }
    if (m.find("Tips") != m.end() && !m["Tips"].empty()) {
      tips = make_shared<string>(boost::any_cast<string>(m["Tips"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeCommodityResponseBodyComponentsPropertiesPropertyValueList() = default;
};
class DescribeCommodityResponseBodyComponentsProperties : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> name{};
  shared_ptr<vector<DescribeCommodityResponseBodyComponentsPropertiesPropertyValueList>> propertyValueList{};

  DescribeCommodityResponseBodyComponentsProperties() {}

  explicit DescribeCommodityResponseBodyComponentsProperties(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (propertyValueList) {
      vector<boost::any> temp1;
      for(auto item1:*propertyValueList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PropertyValueList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("PropertyValueList") != m.end() && !m["PropertyValueList"].empty()) {
      if (typeid(vector<boost::any>) == m["PropertyValueList"].type()) {
        vector<DescribeCommodityResponseBodyComponentsPropertiesPropertyValueList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PropertyValueList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeCommodityResponseBodyComponentsPropertiesPropertyValueList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        propertyValueList = make_shared<vector<DescribeCommodityResponseBodyComponentsPropertiesPropertyValueList>>(expect1);
      }
    }
  }


  virtual ~DescribeCommodityResponseBodyComponentsProperties() = default;
};
class DescribeCommodityResponseBodyComponents : public Darabonba::Model {
public:
  shared_ptr<string> componentCode{};
  shared_ptr<string> componentName{};
  shared_ptr<vector<DescribeCommodityResponseBodyComponentsProperties>> properties{};

  DescribeCommodityResponseBodyComponents() {}

  explicit DescribeCommodityResponseBodyComponents(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (componentCode) {
      res["ComponentCode"] = boost::any(*componentCode);
    }
    if (componentName) {
      res["ComponentName"] = boost::any(*componentName);
    }
    if (properties) {
      vector<boost::any> temp1;
      for(auto item1:*properties){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Properties"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ComponentCode") != m.end() && !m["ComponentCode"].empty()) {
      componentCode = make_shared<string>(boost::any_cast<string>(m["ComponentCode"]));
    }
    if (m.find("ComponentName") != m.end() && !m["ComponentName"].empty()) {
      componentName = make_shared<string>(boost::any_cast<string>(m["ComponentName"]));
    }
    if (m.find("Properties") != m.end() && !m["Properties"].empty()) {
      if (typeid(vector<boost::any>) == m["Properties"].type()) {
        vector<DescribeCommodityResponseBodyComponentsProperties> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Properties"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeCommodityResponseBodyComponentsProperties model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        properties = make_shared<vector<DescribeCommodityResponseBodyComponentsProperties>>(expect1);
      }
    }
  }


  virtual ~DescribeCommodityResponseBodyComponents() = default;
};
class DescribeCommodityResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> commodityCode{};
  shared_ptr<string> commodityName{};
  shared_ptr<vector<DescribeCommodityResponseBodyComponents>> components{};
  shared_ptr<string> requestId{};

  DescribeCommodityResponseBody() {}

  explicit DescribeCommodityResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commodityCode) {
      res["CommodityCode"] = boost::any(*commodityCode);
    }
    if (commodityName) {
      res["CommodityName"] = boost::any(*commodityName);
    }
    if (components) {
      vector<boost::any> temp1;
      for(auto item1:*components){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Components"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CommodityCode") != m.end() && !m["CommodityCode"].empty()) {
      commodityCode = make_shared<string>(boost::any_cast<string>(m["CommodityCode"]));
    }
    if (m.find("CommodityName") != m.end() && !m["CommodityName"].empty()) {
      commodityName = make_shared<string>(boost::any_cast<string>(m["CommodityName"]));
    }
    if (m.find("Components") != m.end() && !m["Components"].empty()) {
      if (typeid(vector<boost::any>) == m["Components"].type()) {
        vector<DescribeCommodityResponseBodyComponents> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Components"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeCommodityResponseBodyComponents model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        components = make_shared<vector<DescribeCommodityResponseBodyComponents>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeCommodityResponseBody() = default;
};
class DescribeCommodityResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeCommodityResponseBody> body{};

  DescribeCommodityResponse() {}

  explicit DescribeCommodityResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeCommodityResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeCommodityResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeCommodityResponse() = default;
};
class DescribeCommodityPriceRequestOrdersComponentsProperties : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> value{};

  DescribeCommodityPriceRequestOrdersComponentsProperties() {}

  explicit DescribeCommodityPriceRequestOrdersComponentsProperties(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeCommodityPriceRequestOrdersComponentsProperties() = default;
};
class DescribeCommodityPriceRequestOrdersComponents : public Darabonba::Model {
public:
  shared_ptr<string> componentCode{};
  shared_ptr<vector<DescribeCommodityPriceRequestOrdersComponentsProperties>> properties{};

  DescribeCommodityPriceRequestOrdersComponents() {}

  explicit DescribeCommodityPriceRequestOrdersComponents(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (componentCode) {
      res["ComponentCode"] = boost::any(*componentCode);
    }
    if (properties) {
      vector<boost::any> temp1;
      for(auto item1:*properties){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Properties"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ComponentCode") != m.end() && !m["ComponentCode"].empty()) {
      componentCode = make_shared<string>(boost::any_cast<string>(m["ComponentCode"]));
    }
    if (m.find("Properties") != m.end() && !m["Properties"].empty()) {
      if (typeid(vector<boost::any>) == m["Properties"].type()) {
        vector<DescribeCommodityPriceRequestOrdersComponentsProperties> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Properties"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeCommodityPriceRequestOrdersComponentsProperties model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        properties = make_shared<vector<DescribeCommodityPriceRequestOrdersComponentsProperties>>(expect1);
      }
    }
  }


  virtual ~DescribeCommodityPriceRequestOrdersComponents() = default;
};
class DescribeCommodityPriceRequestOrders : public Darabonba::Model {
public:
  shared_ptr<string> chargeType{};
  shared_ptr<string> commodityCode{};
  shared_ptr<vector<DescribeCommodityPriceRequestOrdersComponents>> components{};
  shared_ptr<long> duration{};
  shared_ptr<string> orderType{};
  shared_ptr<string> pricingCycle{};
  shared_ptr<long> quantity{};

  DescribeCommodityPriceRequestOrders() {}

  explicit DescribeCommodityPriceRequestOrders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (chargeType) {
      res["ChargeType"] = boost::any(*chargeType);
    }
    if (commodityCode) {
      res["CommodityCode"] = boost::any(*commodityCode);
    }
    if (components) {
      vector<boost::any> temp1;
      for(auto item1:*components){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Components"] = boost::any(temp1);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (orderType) {
      res["OrderType"] = boost::any(*orderType);
    }
    if (pricingCycle) {
      res["PricingCycle"] = boost::any(*pricingCycle);
    }
    if (quantity) {
      res["Quantity"] = boost::any(*quantity);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChargeType") != m.end() && !m["ChargeType"].empty()) {
      chargeType = make_shared<string>(boost::any_cast<string>(m["ChargeType"]));
    }
    if (m.find("CommodityCode") != m.end() && !m["CommodityCode"].empty()) {
      commodityCode = make_shared<string>(boost::any_cast<string>(m["CommodityCode"]));
    }
    if (m.find("Components") != m.end() && !m["Components"].empty()) {
      if (typeid(vector<boost::any>) == m["Components"].type()) {
        vector<DescribeCommodityPriceRequestOrdersComponents> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Components"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeCommodityPriceRequestOrdersComponents model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        components = make_shared<vector<DescribeCommodityPriceRequestOrdersComponents>>(expect1);
      }
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<long>(boost::any_cast<long>(m["Duration"]));
    }
    if (m.find("OrderType") != m.end() && !m["OrderType"].empty()) {
      orderType = make_shared<string>(boost::any_cast<string>(m["OrderType"]));
    }
    if (m.find("PricingCycle") != m.end() && !m["PricingCycle"].empty()) {
      pricingCycle = make_shared<string>(boost::any_cast<string>(m["PricingCycle"]));
    }
    if (m.find("Quantity") != m.end() && !m["Quantity"].empty()) {
      quantity = make_shared<long>(boost::any_cast<long>(m["Quantity"]));
    }
  }


  virtual ~DescribeCommodityPriceRequestOrders() = default;
};
class DescribeCommodityPriceRequest : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeCommodityPriceRequestOrders>> orders{};
  shared_ptr<string> promotionOptionNo{};
  shared_ptr<string> regionId{};

  DescribeCommodityPriceRequest() {}

  explicit DescribeCommodityPriceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (orders) {
      vector<boost::any> temp1;
      for(auto item1:*orders){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Orders"] = boost::any(temp1);
    }
    if (promotionOptionNo) {
      res["PromotionOptionNo"] = boost::any(*promotionOptionNo);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Orders") != m.end() && !m["Orders"].empty()) {
      if (typeid(vector<boost::any>) == m["Orders"].type()) {
        vector<DescribeCommodityPriceRequestOrders> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Orders"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeCommodityPriceRequestOrders model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        orders = make_shared<vector<DescribeCommodityPriceRequestOrders>>(expect1);
      }
    }
    if (m.find("PromotionOptionNo") != m.end() && !m["PromotionOptionNo"].empty()) {
      promotionOptionNo = make_shared<string>(boost::any_cast<string>(m["PromotionOptionNo"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DescribeCommodityPriceRequest() = default;
};
class DescribeCommodityPriceResponseBodyOrderDetailsModuleDetails : public Darabonba::Model {
public:
  shared_ptr<double> discountPrice{};
  shared_ptr<string> moduleCode{};
  shared_ptr<string> moduleName{};
  shared_ptr<double> originalPrice{};
  shared_ptr<double> tradePrice{};

  DescribeCommodityPriceResponseBodyOrderDetailsModuleDetails() {}

  explicit DescribeCommodityPriceResponseBodyOrderDetailsModuleDetails(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (discountPrice) {
      res["DiscountPrice"] = boost::any(*discountPrice);
    }
    if (moduleCode) {
      res["ModuleCode"] = boost::any(*moduleCode);
    }
    if (moduleName) {
      res["ModuleName"] = boost::any(*moduleName);
    }
    if (originalPrice) {
      res["OriginalPrice"] = boost::any(*originalPrice);
    }
    if (tradePrice) {
      res["TradePrice"] = boost::any(*tradePrice);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DiscountPrice") != m.end() && !m["DiscountPrice"].empty()) {
      discountPrice = make_shared<double>(boost::any_cast<double>(m["DiscountPrice"]));
    }
    if (m.find("ModuleCode") != m.end() && !m["ModuleCode"].empty()) {
      moduleCode = make_shared<string>(boost::any_cast<string>(m["ModuleCode"]));
    }
    if (m.find("ModuleName") != m.end() && !m["ModuleName"].empty()) {
      moduleName = make_shared<string>(boost::any_cast<string>(m["ModuleName"]));
    }
    if (m.find("OriginalPrice") != m.end() && !m["OriginalPrice"].empty()) {
      originalPrice = make_shared<double>(boost::any_cast<double>(m["OriginalPrice"]));
    }
    if (m.find("TradePrice") != m.end() && !m["TradePrice"].empty()) {
      tradePrice = make_shared<double>(boost::any_cast<double>(m["TradePrice"]));
    }
  }


  virtual ~DescribeCommodityPriceResponseBodyOrderDetailsModuleDetails() = default;
};
class DescribeCommodityPriceResponseBodyOrderDetailsPromDetails : public Darabonba::Model {
public:
  shared_ptr<double> finalPromFee{};
  shared_ptr<string> optionCode{};
  shared_ptr<string> promType{};
  shared_ptr<string> promotionId{};
  shared_ptr<string> promotionName{};

  DescribeCommodityPriceResponseBodyOrderDetailsPromDetails() {}

  explicit DescribeCommodityPriceResponseBodyOrderDetailsPromDetails(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (finalPromFee) {
      res["FinalPromFee"] = boost::any(*finalPromFee);
    }
    if (optionCode) {
      res["OptionCode"] = boost::any(*optionCode);
    }
    if (promType) {
      res["PromType"] = boost::any(*promType);
    }
    if (promotionId) {
      res["PromotionId"] = boost::any(*promotionId);
    }
    if (promotionName) {
      res["PromotionName"] = boost::any(*promotionName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FinalPromFee") != m.end() && !m["FinalPromFee"].empty()) {
      finalPromFee = make_shared<double>(boost::any_cast<double>(m["FinalPromFee"]));
    }
    if (m.find("OptionCode") != m.end() && !m["OptionCode"].empty()) {
      optionCode = make_shared<string>(boost::any_cast<string>(m["OptionCode"]));
    }
    if (m.find("PromType") != m.end() && !m["PromType"].empty()) {
      promType = make_shared<string>(boost::any_cast<string>(m["PromType"]));
    }
    if (m.find("PromotionId") != m.end() && !m["PromotionId"].empty()) {
      promotionId = make_shared<string>(boost::any_cast<string>(m["PromotionId"]));
    }
    if (m.find("PromotionName") != m.end() && !m["PromotionName"].empty()) {
      promotionName = make_shared<string>(boost::any_cast<string>(m["PromotionName"]));
    }
  }


  virtual ~DescribeCommodityPriceResponseBodyOrderDetailsPromDetails() = default;
};
class DescribeCommodityPriceResponseBodyOrderDetails : public Darabonba::Model {
public:
  shared_ptr<string> commodityCode{};
  shared_ptr<string> commodityName{};
  shared_ptr<double> discountPrice{};
  shared_ptr<vector<DescribeCommodityPriceResponseBodyOrderDetailsModuleDetails>> moduleDetails{};
  shared_ptr<double> originalPrice{};
  shared_ptr<vector<DescribeCommodityPriceResponseBodyOrderDetailsPromDetails>> promDetails{};
  shared_ptr<long> quantity{};
  shared_ptr<vector<long>> ruleIds{};
  shared_ptr<double> tradePrice{};

  DescribeCommodityPriceResponseBodyOrderDetails() {}

  explicit DescribeCommodityPriceResponseBodyOrderDetails(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commodityCode) {
      res["CommodityCode"] = boost::any(*commodityCode);
    }
    if (commodityName) {
      res["CommodityName"] = boost::any(*commodityName);
    }
    if (discountPrice) {
      res["DiscountPrice"] = boost::any(*discountPrice);
    }
    if (moduleDetails) {
      vector<boost::any> temp1;
      for(auto item1:*moduleDetails){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ModuleDetails"] = boost::any(temp1);
    }
    if (originalPrice) {
      res["OriginalPrice"] = boost::any(*originalPrice);
    }
    if (promDetails) {
      vector<boost::any> temp1;
      for(auto item1:*promDetails){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PromDetails"] = boost::any(temp1);
    }
    if (quantity) {
      res["Quantity"] = boost::any(*quantity);
    }
    if (ruleIds) {
      res["RuleIds"] = boost::any(*ruleIds);
    }
    if (tradePrice) {
      res["TradePrice"] = boost::any(*tradePrice);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CommodityCode") != m.end() && !m["CommodityCode"].empty()) {
      commodityCode = make_shared<string>(boost::any_cast<string>(m["CommodityCode"]));
    }
    if (m.find("CommodityName") != m.end() && !m["CommodityName"].empty()) {
      commodityName = make_shared<string>(boost::any_cast<string>(m["CommodityName"]));
    }
    if (m.find("DiscountPrice") != m.end() && !m["DiscountPrice"].empty()) {
      discountPrice = make_shared<double>(boost::any_cast<double>(m["DiscountPrice"]));
    }
    if (m.find("ModuleDetails") != m.end() && !m["ModuleDetails"].empty()) {
      if (typeid(vector<boost::any>) == m["ModuleDetails"].type()) {
        vector<DescribeCommodityPriceResponseBodyOrderDetailsModuleDetails> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ModuleDetails"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeCommodityPriceResponseBodyOrderDetailsModuleDetails model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        moduleDetails = make_shared<vector<DescribeCommodityPriceResponseBodyOrderDetailsModuleDetails>>(expect1);
      }
    }
    if (m.find("OriginalPrice") != m.end() && !m["OriginalPrice"].empty()) {
      originalPrice = make_shared<double>(boost::any_cast<double>(m["OriginalPrice"]));
    }
    if (m.find("PromDetails") != m.end() && !m["PromDetails"].empty()) {
      if (typeid(vector<boost::any>) == m["PromDetails"].type()) {
        vector<DescribeCommodityPriceResponseBodyOrderDetailsPromDetails> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PromDetails"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeCommodityPriceResponseBodyOrderDetailsPromDetails model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        promDetails = make_shared<vector<DescribeCommodityPriceResponseBodyOrderDetailsPromDetails>>(expect1);
      }
    }
    if (m.find("Quantity") != m.end() && !m["Quantity"].empty()) {
      quantity = make_shared<long>(boost::any_cast<long>(m["Quantity"]));
    }
    if (m.find("RuleIds") != m.end() && !m["RuleIds"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["RuleIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["RuleIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      ruleIds = make_shared<vector<long>>(toVec1);
    }
    if (m.find("TradePrice") != m.end() && !m["TradePrice"].empty()) {
      tradePrice = make_shared<double>(boost::any_cast<double>(m["TradePrice"]));
    }
  }


  virtual ~DescribeCommodityPriceResponseBodyOrderDetails() = default;
};
class DescribeCommodityPriceResponseBodyPromotions : public Darabonba::Model {
public:
  shared_ptr<double> canPromFee{};
  shared_ptr<string> optionCode{};
  shared_ptr<string> promotionName{};
  shared_ptr<string> promotionOptionNo{};
  shared_ptr<bool> selected{};

  DescribeCommodityPriceResponseBodyPromotions() {}

  explicit DescribeCommodityPriceResponseBodyPromotions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (canPromFee) {
      res["CanPromFee"] = boost::any(*canPromFee);
    }
    if (optionCode) {
      res["OptionCode"] = boost::any(*optionCode);
    }
    if (promotionName) {
      res["PromotionName"] = boost::any(*promotionName);
    }
    if (promotionOptionNo) {
      res["PromotionOptionNo"] = boost::any(*promotionOptionNo);
    }
    if (selected) {
      res["Selected"] = boost::any(*selected);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CanPromFee") != m.end() && !m["CanPromFee"].empty()) {
      canPromFee = make_shared<double>(boost::any_cast<double>(m["CanPromFee"]));
    }
    if (m.find("OptionCode") != m.end() && !m["OptionCode"].empty()) {
      optionCode = make_shared<string>(boost::any_cast<string>(m["OptionCode"]));
    }
    if (m.find("PromotionName") != m.end() && !m["PromotionName"].empty()) {
      promotionName = make_shared<string>(boost::any_cast<string>(m["PromotionName"]));
    }
    if (m.find("PromotionOptionNo") != m.end() && !m["PromotionOptionNo"].empty()) {
      promotionOptionNo = make_shared<string>(boost::any_cast<string>(m["PromotionOptionNo"]));
    }
    if (m.find("Selected") != m.end() && !m["Selected"].empty()) {
      selected = make_shared<bool>(boost::any_cast<bool>(m["Selected"]));
    }
  }


  virtual ~DescribeCommodityPriceResponseBodyPromotions() = default;
};
class DescribeCommodityPriceResponseBodyRuleDetails : public Darabonba::Model {
public:
  shared_ptr<string> ruleId{};
  shared_ptr<string> ruleName{};

  DescribeCommodityPriceResponseBodyRuleDetails() {}

  explicit DescribeCommodityPriceResponseBodyRuleDetails(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    if (ruleName) {
      res["RuleName"] = boost::any(*ruleName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<string>(boost::any_cast<string>(m["RuleId"]));
    }
    if (m.find("RuleName") != m.end() && !m["RuleName"].empty()) {
      ruleName = make_shared<string>(boost::any_cast<string>(m["RuleName"]));
    }
  }


  virtual ~DescribeCommodityPriceResponseBodyRuleDetails() = default;
};
class DescribeCommodityPriceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> currency{};
  shared_ptr<double> discountPrice{};
  shared_ptr<vector<DescribeCommodityPriceResponseBodyOrderDetails>> orderDetails{};
  shared_ptr<double> originalPrice{};
  shared_ptr<vector<DescribeCommodityPriceResponseBodyPromotions>> promotions{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeCommodityPriceResponseBodyRuleDetails>> ruleDetails{};
  shared_ptr<double> tradePrice{};

  DescribeCommodityPriceResponseBody() {}

  explicit DescribeCommodityPriceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currency) {
      res["Currency"] = boost::any(*currency);
    }
    if (discountPrice) {
      res["DiscountPrice"] = boost::any(*discountPrice);
    }
    if (orderDetails) {
      vector<boost::any> temp1;
      for(auto item1:*orderDetails){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["OrderDetails"] = boost::any(temp1);
    }
    if (originalPrice) {
      res["OriginalPrice"] = boost::any(*originalPrice);
    }
    if (promotions) {
      vector<boost::any> temp1;
      for(auto item1:*promotions){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Promotions"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (ruleDetails) {
      vector<boost::any> temp1;
      for(auto item1:*ruleDetails){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RuleDetails"] = boost::any(temp1);
    }
    if (tradePrice) {
      res["TradePrice"] = boost::any(*tradePrice);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Currency") != m.end() && !m["Currency"].empty()) {
      currency = make_shared<string>(boost::any_cast<string>(m["Currency"]));
    }
    if (m.find("DiscountPrice") != m.end() && !m["DiscountPrice"].empty()) {
      discountPrice = make_shared<double>(boost::any_cast<double>(m["DiscountPrice"]));
    }
    if (m.find("OrderDetails") != m.end() && !m["OrderDetails"].empty()) {
      if (typeid(vector<boost::any>) == m["OrderDetails"].type()) {
        vector<DescribeCommodityPriceResponseBodyOrderDetails> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["OrderDetails"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeCommodityPriceResponseBodyOrderDetails model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        orderDetails = make_shared<vector<DescribeCommodityPriceResponseBodyOrderDetails>>(expect1);
      }
    }
    if (m.find("OriginalPrice") != m.end() && !m["OriginalPrice"].empty()) {
      originalPrice = make_shared<double>(boost::any_cast<double>(m["OriginalPrice"]));
    }
    if (m.find("Promotions") != m.end() && !m["Promotions"].empty()) {
      if (typeid(vector<boost::any>) == m["Promotions"].type()) {
        vector<DescribeCommodityPriceResponseBodyPromotions> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Promotions"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeCommodityPriceResponseBodyPromotions model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        promotions = make_shared<vector<DescribeCommodityPriceResponseBodyPromotions>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("RuleDetails") != m.end() && !m["RuleDetails"].empty()) {
      if (typeid(vector<boost::any>) == m["RuleDetails"].type()) {
        vector<DescribeCommodityPriceResponseBodyRuleDetails> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RuleDetails"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeCommodityPriceResponseBodyRuleDetails model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ruleDetails = make_shared<vector<DescribeCommodityPriceResponseBodyRuleDetails>>(expect1);
      }
    }
    if (m.find("TradePrice") != m.end() && !m["TradePrice"].empty()) {
      tradePrice = make_shared<double>(boost::any_cast<double>(m["TradePrice"]));
    }
  }


  virtual ~DescribeCommodityPriceResponseBody() = default;
};
class DescribeCommodityPriceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeCommodityPriceResponseBody> body{};

  DescribeCommodityPriceResponse() {}

  explicit DescribeCommodityPriceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeCommodityPriceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeCommodityPriceResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeCommodityPriceResponse() = default;
};
class DescribeCustomRoutingEndPointTrafficPolicyRequest : public Darabonba::Model {
public:
  shared_ptr<string> endpointId{};
  shared_ptr<string> policyId{};
  shared_ptr<string> regionId{};

  DescribeCustomRoutingEndPointTrafficPolicyRequest() {}

  explicit DescribeCustomRoutingEndPointTrafficPolicyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endpointId) {
      res["EndpointId"] = boost::any(*endpointId);
    }
    if (policyId) {
      res["PolicyId"] = boost::any(*policyId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndpointId") != m.end() && !m["EndpointId"].empty()) {
      endpointId = make_shared<string>(boost::any_cast<string>(m["EndpointId"]));
    }
    if (m.find("PolicyId") != m.end() && !m["PolicyId"].empty()) {
      policyId = make_shared<string>(boost::any_cast<string>(m["PolicyId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DescribeCustomRoutingEndPointTrafficPolicyRequest() = default;
};
class DescribeCustomRoutingEndPointTrafficPolicyResponseBodyPortRanges : public Darabonba::Model {
public:
  shared_ptr<long> fromPort{};
  shared_ptr<long> toPort{};

  DescribeCustomRoutingEndPointTrafficPolicyResponseBodyPortRanges() {}

  explicit DescribeCustomRoutingEndPointTrafficPolicyResponseBodyPortRanges(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fromPort) {
      res["FromPort"] = boost::any(*fromPort);
    }
    if (toPort) {
      res["ToPort"] = boost::any(*toPort);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FromPort") != m.end() && !m["FromPort"].empty()) {
      fromPort = make_shared<long>(boost::any_cast<long>(m["FromPort"]));
    }
    if (m.find("ToPort") != m.end() && !m["ToPort"].empty()) {
      toPort = make_shared<long>(boost::any_cast<long>(m["ToPort"]));
    }
  }


  virtual ~DescribeCustomRoutingEndPointTrafficPolicyResponseBodyPortRanges() = default;
};
class DescribeCustomRoutingEndPointTrafficPolicyResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> acceleratorId{};
  shared_ptr<string> address{};
  shared_ptr<string> endpoint{};
  shared_ptr<string> endpointGroupId{};
  shared_ptr<string> endpointId{};
  shared_ptr<string> listenerId{};
  shared_ptr<string> policyId{};
  shared_ptr<vector<DescribeCustomRoutingEndPointTrafficPolicyResponseBodyPortRanges>> portRanges{};
  shared_ptr<string> requestId{};
  shared_ptr<string> state{};

  DescribeCustomRoutingEndPointTrafficPolicyResponseBody() {}

  explicit DescribeCustomRoutingEndPointTrafficPolicyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceleratorId) {
      res["AcceleratorId"] = boost::any(*acceleratorId);
    }
    if (address) {
      res["Address"] = boost::any(*address);
    }
    if (endpoint) {
      res["Endpoint"] = boost::any(*endpoint);
    }
    if (endpointGroupId) {
      res["EndpointGroupId"] = boost::any(*endpointGroupId);
    }
    if (endpointId) {
      res["EndpointId"] = boost::any(*endpointId);
    }
    if (listenerId) {
      res["ListenerId"] = boost::any(*listenerId);
    }
    if (policyId) {
      res["PolicyId"] = boost::any(*policyId);
    }
    if (portRanges) {
      vector<boost::any> temp1;
      for(auto item1:*portRanges){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PortRanges"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceleratorId") != m.end() && !m["AcceleratorId"].empty()) {
      acceleratorId = make_shared<string>(boost::any_cast<string>(m["AcceleratorId"]));
    }
    if (m.find("Address") != m.end() && !m["Address"].empty()) {
      address = make_shared<string>(boost::any_cast<string>(m["Address"]));
    }
    if (m.find("Endpoint") != m.end() && !m["Endpoint"].empty()) {
      endpoint = make_shared<string>(boost::any_cast<string>(m["Endpoint"]));
    }
    if (m.find("EndpointGroupId") != m.end() && !m["EndpointGroupId"].empty()) {
      endpointGroupId = make_shared<string>(boost::any_cast<string>(m["EndpointGroupId"]));
    }
    if (m.find("EndpointId") != m.end() && !m["EndpointId"].empty()) {
      endpointId = make_shared<string>(boost::any_cast<string>(m["EndpointId"]));
    }
    if (m.find("ListenerId") != m.end() && !m["ListenerId"].empty()) {
      listenerId = make_shared<string>(boost::any_cast<string>(m["ListenerId"]));
    }
    if (m.find("PolicyId") != m.end() && !m["PolicyId"].empty()) {
      policyId = make_shared<string>(boost::any_cast<string>(m["PolicyId"]));
    }
    if (m.find("PortRanges") != m.end() && !m["PortRanges"].empty()) {
      if (typeid(vector<boost::any>) == m["PortRanges"].type()) {
        vector<DescribeCustomRoutingEndPointTrafficPolicyResponseBodyPortRanges> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PortRanges"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeCustomRoutingEndPointTrafficPolicyResponseBodyPortRanges model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        portRanges = make_shared<vector<DescribeCustomRoutingEndPointTrafficPolicyResponseBodyPortRanges>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
  }


  virtual ~DescribeCustomRoutingEndPointTrafficPolicyResponseBody() = default;
};
class DescribeCustomRoutingEndPointTrafficPolicyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeCustomRoutingEndPointTrafficPolicyResponseBody> body{};

  DescribeCustomRoutingEndPointTrafficPolicyResponse() {}

  explicit DescribeCustomRoutingEndPointTrafficPolicyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeCustomRoutingEndPointTrafficPolicyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeCustomRoutingEndPointTrafficPolicyResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeCustomRoutingEndPointTrafficPolicyResponse() = default;
};
class DescribeCustomRoutingEndpointRequest : public Darabonba::Model {
public:
  shared_ptr<string> endpointGroup{};
  shared_ptr<string> endpointId{};
  shared_ptr<string> regionId{};

  DescribeCustomRoutingEndpointRequest() {}

  explicit DescribeCustomRoutingEndpointRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endpointGroup) {
      res["EndpointGroup"] = boost::any(*endpointGroup);
    }
    if (endpointId) {
      res["EndpointId"] = boost::any(*endpointId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndpointGroup") != m.end() && !m["EndpointGroup"].empty()) {
      endpointGroup = make_shared<string>(boost::any_cast<string>(m["EndpointGroup"]));
    }
    if (m.find("EndpointId") != m.end() && !m["EndpointId"].empty()) {
      endpointId = make_shared<string>(boost::any_cast<string>(m["EndpointId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DescribeCustomRoutingEndpointRequest() = default;
};
class DescribeCustomRoutingEndpointResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> acceleratorId{};
  shared_ptr<string> endpoint{};
  shared_ptr<string> endpointGroupId{};
  shared_ptr<string> endpointId{};
  shared_ptr<string> listenerId{};
  shared_ptr<string> requestId{};
  shared_ptr<string> state{};
  shared_ptr<string> trafficToEndpointPolicy{};
  shared_ptr<string> type{};

  DescribeCustomRoutingEndpointResponseBody() {}

  explicit DescribeCustomRoutingEndpointResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceleratorId) {
      res["AcceleratorId"] = boost::any(*acceleratorId);
    }
    if (endpoint) {
      res["Endpoint"] = boost::any(*endpoint);
    }
    if (endpointGroupId) {
      res["EndpointGroupId"] = boost::any(*endpointGroupId);
    }
    if (endpointId) {
      res["EndpointId"] = boost::any(*endpointId);
    }
    if (listenerId) {
      res["ListenerId"] = boost::any(*listenerId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (trafficToEndpointPolicy) {
      res["TrafficToEndpointPolicy"] = boost::any(*trafficToEndpointPolicy);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceleratorId") != m.end() && !m["AcceleratorId"].empty()) {
      acceleratorId = make_shared<string>(boost::any_cast<string>(m["AcceleratorId"]));
    }
    if (m.find("Endpoint") != m.end() && !m["Endpoint"].empty()) {
      endpoint = make_shared<string>(boost::any_cast<string>(m["Endpoint"]));
    }
    if (m.find("EndpointGroupId") != m.end() && !m["EndpointGroupId"].empty()) {
      endpointGroupId = make_shared<string>(boost::any_cast<string>(m["EndpointGroupId"]));
    }
    if (m.find("EndpointId") != m.end() && !m["EndpointId"].empty()) {
      endpointId = make_shared<string>(boost::any_cast<string>(m["EndpointId"]));
    }
    if (m.find("ListenerId") != m.end() && !m["ListenerId"].empty()) {
      listenerId = make_shared<string>(boost::any_cast<string>(m["ListenerId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("TrafficToEndpointPolicy") != m.end() && !m["TrafficToEndpointPolicy"].empty()) {
      trafficToEndpointPolicy = make_shared<string>(boost::any_cast<string>(m["TrafficToEndpointPolicy"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DescribeCustomRoutingEndpointResponseBody() = default;
};
class DescribeCustomRoutingEndpointResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeCustomRoutingEndpointResponseBody> body{};

  DescribeCustomRoutingEndpointResponse() {}

  explicit DescribeCustomRoutingEndpointResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeCustomRoutingEndpointResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeCustomRoutingEndpointResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeCustomRoutingEndpointResponse() = default;
};
class DescribeCustomRoutingEndpointGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> endpointGroupId{};
  shared_ptr<string> regionId{};

  DescribeCustomRoutingEndpointGroupRequest() {}

  explicit DescribeCustomRoutingEndpointGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endpointGroupId) {
      res["EndpointGroupId"] = boost::any(*endpointGroupId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndpointGroupId") != m.end() && !m["EndpointGroupId"].empty()) {
      endpointGroupId = make_shared<string>(boost::any_cast<string>(m["EndpointGroupId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DescribeCustomRoutingEndpointGroupRequest() = default;
};
class DescribeCustomRoutingEndpointGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> acceleratorId{};
  shared_ptr<string> accessLogSwitch{};
  shared_ptr<string> description{};
  shared_ptr<bool> enableAccessLog{};
  shared_ptr<string> endpointGroupId{};
  shared_ptr<vector<string>> endpointGroupIpList{};
  shared_ptr<string> endpointGroupRegion{};
  shared_ptr<vector<string>> endpointGroupUnconfirmedIpList{};
  shared_ptr<string> listenerId{};
  shared_ptr<string> name{};
  shared_ptr<string> requestId{};
  shared_ptr<string> slsLogStoreName{};
  shared_ptr<string> slsProjectName{};
  shared_ptr<string> slsRegion{};
  shared_ptr<string> state{};

  DescribeCustomRoutingEndpointGroupResponseBody() {}

  explicit DescribeCustomRoutingEndpointGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceleratorId) {
      res["AcceleratorId"] = boost::any(*acceleratorId);
    }
    if (accessLogSwitch) {
      res["AccessLogSwitch"] = boost::any(*accessLogSwitch);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (enableAccessLog) {
      res["EnableAccessLog"] = boost::any(*enableAccessLog);
    }
    if (endpointGroupId) {
      res["EndpointGroupId"] = boost::any(*endpointGroupId);
    }
    if (endpointGroupIpList) {
      res["EndpointGroupIpList"] = boost::any(*endpointGroupIpList);
    }
    if (endpointGroupRegion) {
      res["EndpointGroupRegion"] = boost::any(*endpointGroupRegion);
    }
    if (endpointGroupUnconfirmedIpList) {
      res["EndpointGroupUnconfirmedIpList"] = boost::any(*endpointGroupUnconfirmedIpList);
    }
    if (listenerId) {
      res["ListenerId"] = boost::any(*listenerId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (slsLogStoreName) {
      res["SlsLogStoreName"] = boost::any(*slsLogStoreName);
    }
    if (slsProjectName) {
      res["SlsProjectName"] = boost::any(*slsProjectName);
    }
    if (slsRegion) {
      res["SlsRegion"] = boost::any(*slsRegion);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceleratorId") != m.end() && !m["AcceleratorId"].empty()) {
      acceleratorId = make_shared<string>(boost::any_cast<string>(m["AcceleratorId"]));
    }
    if (m.find("AccessLogSwitch") != m.end() && !m["AccessLogSwitch"].empty()) {
      accessLogSwitch = make_shared<string>(boost::any_cast<string>(m["AccessLogSwitch"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("EnableAccessLog") != m.end() && !m["EnableAccessLog"].empty()) {
      enableAccessLog = make_shared<bool>(boost::any_cast<bool>(m["EnableAccessLog"]));
    }
    if (m.find("EndpointGroupId") != m.end() && !m["EndpointGroupId"].empty()) {
      endpointGroupId = make_shared<string>(boost::any_cast<string>(m["EndpointGroupId"]));
    }
    if (m.find("EndpointGroupIpList") != m.end() && !m["EndpointGroupIpList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["EndpointGroupIpList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["EndpointGroupIpList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      endpointGroupIpList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("EndpointGroupRegion") != m.end() && !m["EndpointGroupRegion"].empty()) {
      endpointGroupRegion = make_shared<string>(boost::any_cast<string>(m["EndpointGroupRegion"]));
    }
    if (m.find("EndpointGroupUnconfirmedIpList") != m.end() && !m["EndpointGroupUnconfirmedIpList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["EndpointGroupUnconfirmedIpList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["EndpointGroupUnconfirmedIpList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      endpointGroupUnconfirmedIpList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ListenerId") != m.end() && !m["ListenerId"].empty()) {
      listenerId = make_shared<string>(boost::any_cast<string>(m["ListenerId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SlsLogStoreName") != m.end() && !m["SlsLogStoreName"].empty()) {
      slsLogStoreName = make_shared<string>(boost::any_cast<string>(m["SlsLogStoreName"]));
    }
    if (m.find("SlsProjectName") != m.end() && !m["SlsProjectName"].empty()) {
      slsProjectName = make_shared<string>(boost::any_cast<string>(m["SlsProjectName"]));
    }
    if (m.find("SlsRegion") != m.end() && !m["SlsRegion"].empty()) {
      slsRegion = make_shared<string>(boost::any_cast<string>(m["SlsRegion"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
  }


  virtual ~DescribeCustomRoutingEndpointGroupResponseBody() = default;
};
class DescribeCustomRoutingEndpointGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeCustomRoutingEndpointGroupResponseBody> body{};

  DescribeCustomRoutingEndpointGroupResponse() {}

  explicit DescribeCustomRoutingEndpointGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeCustomRoutingEndpointGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeCustomRoutingEndpointGroupResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeCustomRoutingEndpointGroupResponse() = default;
};
class DescribeCustomRoutingEndpointGroupDestinationsRequest : public Darabonba::Model {
public:
  shared_ptr<string> destinationId{};
  shared_ptr<string> endpointGroupId{};
  shared_ptr<string> regionId{};

  DescribeCustomRoutingEndpointGroupDestinationsRequest() {}

  explicit DescribeCustomRoutingEndpointGroupDestinationsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (destinationId) {
      res["DestinationId"] = boost::any(*destinationId);
    }
    if (endpointGroupId) {
      res["EndpointGroupId"] = boost::any(*endpointGroupId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DestinationId") != m.end() && !m["DestinationId"].empty()) {
      destinationId = make_shared<string>(boost::any_cast<string>(m["DestinationId"]));
    }
    if (m.find("EndpointGroupId") != m.end() && !m["EndpointGroupId"].empty()) {
      endpointGroupId = make_shared<string>(boost::any_cast<string>(m["EndpointGroupId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DescribeCustomRoutingEndpointGroupDestinationsRequest() = default;
};
class DescribeCustomRoutingEndpointGroupDestinationsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> acceleratorId{};
  shared_ptr<string> destinationId{};
  shared_ptr<string> endpointGroupId{};
  shared_ptr<long> fromPort{};
  shared_ptr<string> listenerId{};
  shared_ptr<vector<string>> protocols{};
  shared_ptr<string> requestId{};
  shared_ptr<string> state{};
  shared_ptr<long> toPort{};

  DescribeCustomRoutingEndpointGroupDestinationsResponseBody() {}

  explicit DescribeCustomRoutingEndpointGroupDestinationsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceleratorId) {
      res["AcceleratorId"] = boost::any(*acceleratorId);
    }
    if (destinationId) {
      res["DestinationId"] = boost::any(*destinationId);
    }
    if (endpointGroupId) {
      res["EndpointGroupId"] = boost::any(*endpointGroupId);
    }
    if (fromPort) {
      res["FromPort"] = boost::any(*fromPort);
    }
    if (listenerId) {
      res["ListenerId"] = boost::any(*listenerId);
    }
    if (protocols) {
      res["Protocols"] = boost::any(*protocols);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (toPort) {
      res["ToPort"] = boost::any(*toPort);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceleratorId") != m.end() && !m["AcceleratorId"].empty()) {
      acceleratorId = make_shared<string>(boost::any_cast<string>(m["AcceleratorId"]));
    }
    if (m.find("DestinationId") != m.end() && !m["DestinationId"].empty()) {
      destinationId = make_shared<string>(boost::any_cast<string>(m["DestinationId"]));
    }
    if (m.find("EndpointGroupId") != m.end() && !m["EndpointGroupId"].empty()) {
      endpointGroupId = make_shared<string>(boost::any_cast<string>(m["EndpointGroupId"]));
    }
    if (m.find("FromPort") != m.end() && !m["FromPort"].empty()) {
      fromPort = make_shared<long>(boost::any_cast<long>(m["FromPort"]));
    }
    if (m.find("ListenerId") != m.end() && !m["ListenerId"].empty()) {
      listenerId = make_shared<string>(boost::any_cast<string>(m["ListenerId"]));
    }
    if (m.find("Protocols") != m.end() && !m["Protocols"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Protocols"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Protocols"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      protocols = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("ToPort") != m.end() && !m["ToPort"].empty()) {
      toPort = make_shared<long>(boost::any_cast<long>(m["ToPort"]));
    }
  }


  virtual ~DescribeCustomRoutingEndpointGroupDestinationsResponseBody() = default;
};
class DescribeCustomRoutingEndpointGroupDestinationsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeCustomRoutingEndpointGroupDestinationsResponseBody> body{};

  DescribeCustomRoutingEndpointGroupDestinationsResponse() {}

  explicit DescribeCustomRoutingEndpointGroupDestinationsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeCustomRoutingEndpointGroupDestinationsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeCustomRoutingEndpointGroupDestinationsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeCustomRoutingEndpointGroupDestinationsResponse() = default;
};
class DescribeEndpointGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> endpointGroupId{};
  shared_ptr<string> regionId{};

  DescribeEndpointGroupRequest() {}

  explicit DescribeEndpointGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endpointGroupId) {
      res["EndpointGroupId"] = boost::any(*endpointGroupId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndpointGroupId") != m.end() && !m["EndpointGroupId"].empty()) {
      endpointGroupId = make_shared<string>(boost::any_cast<string>(m["EndpointGroupId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DescribeEndpointGroupRequest() = default;
};
class DescribeEndpointGroupResponseBodyEndpointConfigurations : public Darabonba::Model {
public:
  shared_ptr<bool> enableClientIPPreservation{};
  shared_ptr<bool> enableProxyProtocol{};
  shared_ptr<string> endpoint{};
  shared_ptr<long> probePort{};
  shared_ptr<string> probeProtocol{};
  shared_ptr<string> type{};
  shared_ptr<long> weight{};

  DescribeEndpointGroupResponseBodyEndpointConfigurations() {}

  explicit DescribeEndpointGroupResponseBodyEndpointConfigurations(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (enableClientIPPreservation) {
      res["EnableClientIPPreservation"] = boost::any(*enableClientIPPreservation);
    }
    if (enableProxyProtocol) {
      res["EnableProxyProtocol"] = boost::any(*enableProxyProtocol);
    }
    if (endpoint) {
      res["Endpoint"] = boost::any(*endpoint);
    }
    if (probePort) {
      res["ProbePort"] = boost::any(*probePort);
    }
    if (probeProtocol) {
      res["ProbeProtocol"] = boost::any(*probeProtocol);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (weight) {
      res["Weight"] = boost::any(*weight);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EnableClientIPPreservation") != m.end() && !m["EnableClientIPPreservation"].empty()) {
      enableClientIPPreservation = make_shared<bool>(boost::any_cast<bool>(m["EnableClientIPPreservation"]));
    }
    if (m.find("EnableProxyProtocol") != m.end() && !m["EnableProxyProtocol"].empty()) {
      enableProxyProtocol = make_shared<bool>(boost::any_cast<bool>(m["EnableProxyProtocol"]));
    }
    if (m.find("Endpoint") != m.end() && !m["Endpoint"].empty()) {
      endpoint = make_shared<string>(boost::any_cast<string>(m["Endpoint"]));
    }
    if (m.find("ProbePort") != m.end() && !m["ProbePort"].empty()) {
      probePort = make_shared<long>(boost::any_cast<long>(m["ProbePort"]));
    }
    if (m.find("ProbeProtocol") != m.end() && !m["ProbeProtocol"].empty()) {
      probeProtocol = make_shared<string>(boost::any_cast<string>(m["ProbeProtocol"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Weight") != m.end() && !m["Weight"].empty()) {
      weight = make_shared<long>(boost::any_cast<long>(m["Weight"]));
    }
  }


  virtual ~DescribeEndpointGroupResponseBodyEndpointConfigurations() = default;
};
class DescribeEndpointGroupResponseBodyPortOverrides : public Darabonba::Model {
public:
  shared_ptr<long> endpointPort{};
  shared_ptr<long> listenerPort{};

  DescribeEndpointGroupResponseBodyPortOverrides() {}

  explicit DescribeEndpointGroupResponseBodyPortOverrides(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endpointPort) {
      res["EndpointPort"] = boost::any(*endpointPort);
    }
    if (listenerPort) {
      res["ListenerPort"] = boost::any(*listenerPort);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndpointPort") != m.end() && !m["EndpointPort"].empty()) {
      endpointPort = make_shared<long>(boost::any_cast<long>(m["EndpointPort"]));
    }
    if (m.find("ListenerPort") != m.end() && !m["ListenerPort"].empty()) {
      listenerPort = make_shared<long>(boost::any_cast<long>(m["ListenerPort"]));
    }
  }


  virtual ~DescribeEndpointGroupResponseBodyPortOverrides() = default;
};
class DescribeEndpointGroupResponseBodyTags : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  DescribeEndpointGroupResponseBodyTags() {}

  explicit DescribeEndpointGroupResponseBodyTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeEndpointGroupResponseBodyTags() = default;
};
class DescribeEndpointGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> acceleratorId{};
  shared_ptr<string> accessLogSwitch{};
  shared_ptr<string> description{};
  shared_ptr<bool> enableAccessLog{};
  shared_ptr<vector<DescribeEndpointGroupResponseBodyEndpointConfigurations>> endpointConfigurations{};
  shared_ptr<string> endpointGroupId{};
  shared_ptr<vector<string>> endpointGroupIpList{};
  shared_ptr<string> endpointGroupRegion{};
  shared_ptr<string> endpointGroupType{};
  shared_ptr<vector<string>> endpointGroupUnconfirmedIpList{};
  shared_ptr<string> endpointRequestProtocol{};
  shared_ptr<vector<string>> forwardingRuleIds{};
  shared_ptr<bool> healthCheckEnabled{};
  shared_ptr<long> healthCheckIntervalSeconds{};
  shared_ptr<string> healthCheckPath{};
  shared_ptr<long> healthCheckPort{};
  shared_ptr<string> healthCheckProtocol{};
  shared_ptr<string> listenerId{};
  shared_ptr<string> name{};
  shared_ptr<vector<DescribeEndpointGroupResponseBodyPortOverrides>> portOverrides{};
  shared_ptr<string> requestId{};
  shared_ptr<string> slsLogStoreName{};
  shared_ptr<string> slsProjectName{};
  shared_ptr<string> slsRegion{};
  shared_ptr<string> state{};
  shared_ptr<vector<DescribeEndpointGroupResponseBodyTags>> tags{};
  shared_ptr<long> thresholdCount{};
  shared_ptr<long> trafficPercentage{};

  DescribeEndpointGroupResponseBody() {}

  explicit DescribeEndpointGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceleratorId) {
      res["AcceleratorId"] = boost::any(*acceleratorId);
    }
    if (accessLogSwitch) {
      res["AccessLogSwitch"] = boost::any(*accessLogSwitch);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (enableAccessLog) {
      res["EnableAccessLog"] = boost::any(*enableAccessLog);
    }
    if (endpointConfigurations) {
      vector<boost::any> temp1;
      for(auto item1:*endpointConfigurations){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["EndpointConfigurations"] = boost::any(temp1);
    }
    if (endpointGroupId) {
      res["EndpointGroupId"] = boost::any(*endpointGroupId);
    }
    if (endpointGroupIpList) {
      res["EndpointGroupIpList"] = boost::any(*endpointGroupIpList);
    }
    if (endpointGroupRegion) {
      res["EndpointGroupRegion"] = boost::any(*endpointGroupRegion);
    }
    if (endpointGroupType) {
      res["EndpointGroupType"] = boost::any(*endpointGroupType);
    }
    if (endpointGroupUnconfirmedIpList) {
      res["EndpointGroupUnconfirmedIpList"] = boost::any(*endpointGroupUnconfirmedIpList);
    }
    if (endpointRequestProtocol) {
      res["EndpointRequestProtocol"] = boost::any(*endpointRequestProtocol);
    }
    if (forwardingRuleIds) {
      res["ForwardingRuleIds"] = boost::any(*forwardingRuleIds);
    }
    if (healthCheckEnabled) {
      res["HealthCheckEnabled"] = boost::any(*healthCheckEnabled);
    }
    if (healthCheckIntervalSeconds) {
      res["HealthCheckIntervalSeconds"] = boost::any(*healthCheckIntervalSeconds);
    }
    if (healthCheckPath) {
      res["HealthCheckPath"] = boost::any(*healthCheckPath);
    }
    if (healthCheckPort) {
      res["HealthCheckPort"] = boost::any(*healthCheckPort);
    }
    if (healthCheckProtocol) {
      res["HealthCheckProtocol"] = boost::any(*healthCheckProtocol);
    }
    if (listenerId) {
      res["ListenerId"] = boost::any(*listenerId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (portOverrides) {
      vector<boost::any> temp1;
      for(auto item1:*portOverrides){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PortOverrides"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (slsLogStoreName) {
      res["SlsLogStoreName"] = boost::any(*slsLogStoreName);
    }
    if (slsProjectName) {
      res["SlsProjectName"] = boost::any(*slsProjectName);
    }
    if (slsRegion) {
      res["SlsRegion"] = boost::any(*slsRegion);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tags"] = boost::any(temp1);
    }
    if (thresholdCount) {
      res["ThresholdCount"] = boost::any(*thresholdCount);
    }
    if (trafficPercentage) {
      res["TrafficPercentage"] = boost::any(*trafficPercentage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceleratorId") != m.end() && !m["AcceleratorId"].empty()) {
      acceleratorId = make_shared<string>(boost::any_cast<string>(m["AcceleratorId"]));
    }
    if (m.find("AccessLogSwitch") != m.end() && !m["AccessLogSwitch"].empty()) {
      accessLogSwitch = make_shared<string>(boost::any_cast<string>(m["AccessLogSwitch"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("EnableAccessLog") != m.end() && !m["EnableAccessLog"].empty()) {
      enableAccessLog = make_shared<bool>(boost::any_cast<bool>(m["EnableAccessLog"]));
    }
    if (m.find("EndpointConfigurations") != m.end() && !m["EndpointConfigurations"].empty()) {
      if (typeid(vector<boost::any>) == m["EndpointConfigurations"].type()) {
        vector<DescribeEndpointGroupResponseBodyEndpointConfigurations> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["EndpointConfigurations"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeEndpointGroupResponseBodyEndpointConfigurations model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        endpointConfigurations = make_shared<vector<DescribeEndpointGroupResponseBodyEndpointConfigurations>>(expect1);
      }
    }
    if (m.find("EndpointGroupId") != m.end() && !m["EndpointGroupId"].empty()) {
      endpointGroupId = make_shared<string>(boost::any_cast<string>(m["EndpointGroupId"]));
    }
    if (m.find("EndpointGroupIpList") != m.end() && !m["EndpointGroupIpList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["EndpointGroupIpList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["EndpointGroupIpList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      endpointGroupIpList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("EndpointGroupRegion") != m.end() && !m["EndpointGroupRegion"].empty()) {
      endpointGroupRegion = make_shared<string>(boost::any_cast<string>(m["EndpointGroupRegion"]));
    }
    if (m.find("EndpointGroupType") != m.end() && !m["EndpointGroupType"].empty()) {
      endpointGroupType = make_shared<string>(boost::any_cast<string>(m["EndpointGroupType"]));
    }
    if (m.find("EndpointGroupUnconfirmedIpList") != m.end() && !m["EndpointGroupUnconfirmedIpList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["EndpointGroupUnconfirmedIpList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["EndpointGroupUnconfirmedIpList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      endpointGroupUnconfirmedIpList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("EndpointRequestProtocol") != m.end() && !m["EndpointRequestProtocol"].empty()) {
      endpointRequestProtocol = make_shared<string>(boost::any_cast<string>(m["EndpointRequestProtocol"]));
    }
    if (m.find("ForwardingRuleIds") != m.end() && !m["ForwardingRuleIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ForwardingRuleIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ForwardingRuleIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      forwardingRuleIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("HealthCheckEnabled") != m.end() && !m["HealthCheckEnabled"].empty()) {
      healthCheckEnabled = make_shared<bool>(boost::any_cast<bool>(m["HealthCheckEnabled"]));
    }
    if (m.find("HealthCheckIntervalSeconds") != m.end() && !m["HealthCheckIntervalSeconds"].empty()) {
      healthCheckIntervalSeconds = make_shared<long>(boost::any_cast<long>(m["HealthCheckIntervalSeconds"]));
    }
    if (m.find("HealthCheckPath") != m.end() && !m["HealthCheckPath"].empty()) {
      healthCheckPath = make_shared<string>(boost::any_cast<string>(m["HealthCheckPath"]));
    }
    if (m.find("HealthCheckPort") != m.end() && !m["HealthCheckPort"].empty()) {
      healthCheckPort = make_shared<long>(boost::any_cast<long>(m["HealthCheckPort"]));
    }
    if (m.find("HealthCheckProtocol") != m.end() && !m["HealthCheckProtocol"].empty()) {
      healthCheckProtocol = make_shared<string>(boost::any_cast<string>(m["HealthCheckProtocol"]));
    }
    if (m.find("ListenerId") != m.end() && !m["ListenerId"].empty()) {
      listenerId = make_shared<string>(boost::any_cast<string>(m["ListenerId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("PortOverrides") != m.end() && !m["PortOverrides"].empty()) {
      if (typeid(vector<boost::any>) == m["PortOverrides"].type()) {
        vector<DescribeEndpointGroupResponseBodyPortOverrides> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PortOverrides"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeEndpointGroupResponseBodyPortOverrides model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        portOverrides = make_shared<vector<DescribeEndpointGroupResponseBodyPortOverrides>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SlsLogStoreName") != m.end() && !m["SlsLogStoreName"].empty()) {
      slsLogStoreName = make_shared<string>(boost::any_cast<string>(m["SlsLogStoreName"]));
    }
    if (m.find("SlsProjectName") != m.end() && !m["SlsProjectName"].empty()) {
      slsProjectName = make_shared<string>(boost::any_cast<string>(m["SlsProjectName"]));
    }
    if (m.find("SlsRegion") != m.end() && !m["SlsRegion"].empty()) {
      slsRegion = make_shared<string>(boost::any_cast<string>(m["SlsRegion"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(vector<boost::any>) == m["Tags"].type()) {
        vector<DescribeEndpointGroupResponseBodyTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeEndpointGroupResponseBodyTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<DescribeEndpointGroupResponseBodyTags>>(expect1);
      }
    }
    if (m.find("ThresholdCount") != m.end() && !m["ThresholdCount"].empty()) {
      thresholdCount = make_shared<long>(boost::any_cast<long>(m["ThresholdCount"]));
    }
    if (m.find("TrafficPercentage") != m.end() && !m["TrafficPercentage"].empty()) {
      trafficPercentage = make_shared<long>(boost::any_cast<long>(m["TrafficPercentage"]));
    }
  }


  virtual ~DescribeEndpointGroupResponseBody() = default;
};
class DescribeEndpointGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeEndpointGroupResponseBody> body{};

  DescribeEndpointGroupResponse() {}

  explicit DescribeEndpointGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeEndpointGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeEndpointGroupResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeEndpointGroupResponse() = default;
};
class DescribeIpSetRequest : public Darabonba::Model {
public:
  shared_ptr<string> ipSetId{};
  shared_ptr<string> regionId{};

  DescribeIpSetRequest() {}

  explicit DescribeIpSetRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ipSetId) {
      res["IpSetId"] = boost::any(*ipSetId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IpSetId") != m.end() && !m["IpSetId"].empty()) {
      ipSetId = make_shared<string>(boost::any_cast<string>(m["IpSetId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DescribeIpSetRequest() = default;
};
class DescribeIpSetResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> accelerateRegionId{};
  shared_ptr<string> acceleratorId{};
  shared_ptr<long> bandwidth{};
  shared_ptr<vector<string>> ipAddressList{};
  shared_ptr<string> ipSetId{};
  shared_ptr<string> ipVersion{};
  shared_ptr<string> ispType{};
  shared_ptr<string> requestId{};
  shared_ptr<string> state{};

  DescribeIpSetResponseBody() {}

  explicit DescribeIpSetResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accelerateRegionId) {
      res["AccelerateRegionId"] = boost::any(*accelerateRegionId);
    }
    if (acceleratorId) {
      res["AcceleratorId"] = boost::any(*acceleratorId);
    }
    if (bandwidth) {
      res["Bandwidth"] = boost::any(*bandwidth);
    }
    if (ipAddressList) {
      res["IpAddressList"] = boost::any(*ipAddressList);
    }
    if (ipSetId) {
      res["IpSetId"] = boost::any(*ipSetId);
    }
    if (ipVersion) {
      res["IpVersion"] = boost::any(*ipVersion);
    }
    if (ispType) {
      res["IspType"] = boost::any(*ispType);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccelerateRegionId") != m.end() && !m["AccelerateRegionId"].empty()) {
      accelerateRegionId = make_shared<string>(boost::any_cast<string>(m["AccelerateRegionId"]));
    }
    if (m.find("AcceleratorId") != m.end() && !m["AcceleratorId"].empty()) {
      acceleratorId = make_shared<string>(boost::any_cast<string>(m["AcceleratorId"]));
    }
    if (m.find("Bandwidth") != m.end() && !m["Bandwidth"].empty()) {
      bandwidth = make_shared<long>(boost::any_cast<long>(m["Bandwidth"]));
    }
    if (m.find("IpAddressList") != m.end() && !m["IpAddressList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["IpAddressList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["IpAddressList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      ipAddressList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("IpSetId") != m.end() && !m["IpSetId"].empty()) {
      ipSetId = make_shared<string>(boost::any_cast<string>(m["IpSetId"]));
    }
    if (m.find("IpVersion") != m.end() && !m["IpVersion"].empty()) {
      ipVersion = make_shared<string>(boost::any_cast<string>(m["IpVersion"]));
    }
    if (m.find("IspType") != m.end() && !m["IspType"].empty()) {
      ispType = make_shared<string>(boost::any_cast<string>(m["IspType"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
  }


  virtual ~DescribeIpSetResponseBody() = default;
};
class DescribeIpSetResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeIpSetResponseBody> body{};

  DescribeIpSetResponse() {}

  explicit DescribeIpSetResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeIpSetResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeIpSetResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeIpSetResponse() = default;
};
class DescribeListenerRequest : public Darabonba::Model {
public:
  shared_ptr<string> listenerId{};
  shared_ptr<string> regionId{};

  DescribeListenerRequest() {}

  explicit DescribeListenerRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (listenerId) {
      res["ListenerId"] = boost::any(*listenerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ListenerId") != m.end() && !m["ListenerId"].empty()) {
      listenerId = make_shared<string>(boost::any_cast<string>(m["ListenerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DescribeListenerRequest() = default;
};
class DescribeListenerResponseBodyBackendPorts : public Darabonba::Model {
public:
  shared_ptr<string> fromPort{};
  shared_ptr<string> toPort{};

  DescribeListenerResponseBodyBackendPorts() {}

  explicit DescribeListenerResponseBodyBackendPorts(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fromPort) {
      res["FromPort"] = boost::any(*fromPort);
    }
    if (toPort) {
      res["ToPort"] = boost::any(*toPort);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FromPort") != m.end() && !m["FromPort"].empty()) {
      fromPort = make_shared<string>(boost::any_cast<string>(m["FromPort"]));
    }
    if (m.find("ToPort") != m.end() && !m["ToPort"].empty()) {
      toPort = make_shared<string>(boost::any_cast<string>(m["ToPort"]));
    }
  }


  virtual ~DescribeListenerResponseBodyBackendPorts() = default;
};
class DescribeListenerResponseBodyCertificates : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<string> type{};

  DescribeListenerResponseBodyCertificates() {}

  explicit DescribeListenerResponseBodyCertificates(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DescribeListenerResponseBodyCertificates() = default;
};
class DescribeListenerResponseBodyPortRanges : public Darabonba::Model {
public:
  shared_ptr<long> fromPort{};
  shared_ptr<long> toPort{};

  DescribeListenerResponseBodyPortRanges() {}

  explicit DescribeListenerResponseBodyPortRanges(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fromPort) {
      res["FromPort"] = boost::any(*fromPort);
    }
    if (toPort) {
      res["ToPort"] = boost::any(*toPort);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FromPort") != m.end() && !m["FromPort"].empty()) {
      fromPort = make_shared<long>(boost::any_cast<long>(m["FromPort"]));
    }
    if (m.find("ToPort") != m.end() && !m["ToPort"].empty()) {
      toPort = make_shared<long>(boost::any_cast<long>(m["ToPort"]));
    }
  }


  virtual ~DescribeListenerResponseBodyPortRanges() = default;
};
class DescribeListenerResponseBodyRelatedAcls : public Darabonba::Model {
public:
  shared_ptr<string> aclId{};
  shared_ptr<string> status{};

  DescribeListenerResponseBodyRelatedAcls() {}

  explicit DescribeListenerResponseBodyRelatedAcls(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aclId) {
      res["AclId"] = boost::any(*aclId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AclId") != m.end() && !m["AclId"].empty()) {
      aclId = make_shared<string>(boost::any_cast<string>(m["AclId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeListenerResponseBodyRelatedAcls() = default;
};
class DescribeListenerResponseBodyXForwardedForConfig : public Darabonba::Model {
public:
  shared_ptr<bool> XForwardedForGaApEnabled{};
  shared_ptr<bool> XForwardedForGaIdEnabled{};
  shared_ptr<bool> XForwardedForPortEnabled{};
  shared_ptr<bool> XForwardedForProtoEnabled{};
  shared_ptr<bool> XRealIpEnabled{};

  DescribeListenerResponseBodyXForwardedForConfig() {}

  explicit DescribeListenerResponseBodyXForwardedForConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (XForwardedForGaApEnabled) {
      res["XForwardedForGaApEnabled"] = boost::any(*XForwardedForGaApEnabled);
    }
    if (XForwardedForGaIdEnabled) {
      res["XForwardedForGaIdEnabled"] = boost::any(*XForwardedForGaIdEnabled);
    }
    if (XForwardedForPortEnabled) {
      res["XForwardedForPortEnabled"] = boost::any(*XForwardedForPortEnabled);
    }
    if (XForwardedForProtoEnabled) {
      res["XForwardedForProtoEnabled"] = boost::any(*XForwardedForProtoEnabled);
    }
    if (XRealIpEnabled) {
      res["XRealIpEnabled"] = boost::any(*XRealIpEnabled);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("XForwardedForGaApEnabled") != m.end() && !m["XForwardedForGaApEnabled"].empty()) {
      XForwardedForGaApEnabled = make_shared<bool>(boost::any_cast<bool>(m["XForwardedForGaApEnabled"]));
    }
    if (m.find("XForwardedForGaIdEnabled") != m.end() && !m["XForwardedForGaIdEnabled"].empty()) {
      XForwardedForGaIdEnabled = make_shared<bool>(boost::any_cast<bool>(m["XForwardedForGaIdEnabled"]));
    }
    if (m.find("XForwardedForPortEnabled") != m.end() && !m["XForwardedForPortEnabled"].empty()) {
      XForwardedForPortEnabled = make_shared<bool>(boost::any_cast<bool>(m["XForwardedForPortEnabled"]));
    }
    if (m.find("XForwardedForProtoEnabled") != m.end() && !m["XForwardedForProtoEnabled"].empty()) {
      XForwardedForProtoEnabled = make_shared<bool>(boost::any_cast<bool>(m["XForwardedForProtoEnabled"]));
    }
    if (m.find("XRealIpEnabled") != m.end() && !m["XRealIpEnabled"].empty()) {
      XRealIpEnabled = make_shared<bool>(boost::any_cast<bool>(m["XRealIpEnabled"]));
    }
  }


  virtual ~DescribeListenerResponseBodyXForwardedForConfig() = default;
};
class DescribeListenerResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> acceleratorId{};
  shared_ptr<string> aclType{};
  shared_ptr<vector<DescribeListenerResponseBodyBackendPorts>> backendPorts{};
  shared_ptr<vector<DescribeListenerResponseBodyCertificates>> certificates{};
  shared_ptr<string> clientAffinity{};
  shared_ptr<string> createTime{};
  shared_ptr<string> description{};
  shared_ptr<string> listenerId{};
  shared_ptr<string> name{};
  shared_ptr<vector<DescribeListenerResponseBodyPortRanges>> portRanges{};
  shared_ptr<string> protocol{};
  shared_ptr<bool> proxyProtocol{};
  shared_ptr<vector<DescribeListenerResponseBodyRelatedAcls>> relatedAcls{};
  shared_ptr<string> requestId{};
  shared_ptr<string> securityPolicyId{};
  shared_ptr<string> state{};
  shared_ptr<string> type{};
  shared_ptr<DescribeListenerResponseBodyXForwardedForConfig> XForwardedForConfig{};

  DescribeListenerResponseBody() {}

  explicit DescribeListenerResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceleratorId) {
      res["AcceleratorId"] = boost::any(*acceleratorId);
    }
    if (aclType) {
      res["AclType"] = boost::any(*aclType);
    }
    if (backendPorts) {
      vector<boost::any> temp1;
      for(auto item1:*backendPorts){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["BackendPorts"] = boost::any(temp1);
    }
    if (certificates) {
      vector<boost::any> temp1;
      for(auto item1:*certificates){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Certificates"] = boost::any(temp1);
    }
    if (clientAffinity) {
      res["ClientAffinity"] = boost::any(*clientAffinity);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (listenerId) {
      res["ListenerId"] = boost::any(*listenerId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (portRanges) {
      vector<boost::any> temp1;
      for(auto item1:*portRanges){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PortRanges"] = boost::any(temp1);
    }
    if (protocol) {
      res["Protocol"] = boost::any(*protocol);
    }
    if (proxyProtocol) {
      res["ProxyProtocol"] = boost::any(*proxyProtocol);
    }
    if (relatedAcls) {
      vector<boost::any> temp1;
      for(auto item1:*relatedAcls){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RelatedAcls"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (securityPolicyId) {
      res["SecurityPolicyId"] = boost::any(*securityPolicyId);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (XForwardedForConfig) {
      res["XForwardedForConfig"] = XForwardedForConfig ? boost::any(XForwardedForConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceleratorId") != m.end() && !m["AcceleratorId"].empty()) {
      acceleratorId = make_shared<string>(boost::any_cast<string>(m["AcceleratorId"]));
    }
    if (m.find("AclType") != m.end() && !m["AclType"].empty()) {
      aclType = make_shared<string>(boost::any_cast<string>(m["AclType"]));
    }
    if (m.find("BackendPorts") != m.end() && !m["BackendPorts"].empty()) {
      if (typeid(vector<boost::any>) == m["BackendPorts"].type()) {
        vector<DescribeListenerResponseBodyBackendPorts> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["BackendPorts"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeListenerResponseBodyBackendPorts model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        backendPorts = make_shared<vector<DescribeListenerResponseBodyBackendPorts>>(expect1);
      }
    }
    if (m.find("Certificates") != m.end() && !m["Certificates"].empty()) {
      if (typeid(vector<boost::any>) == m["Certificates"].type()) {
        vector<DescribeListenerResponseBodyCertificates> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Certificates"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeListenerResponseBodyCertificates model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        certificates = make_shared<vector<DescribeListenerResponseBodyCertificates>>(expect1);
      }
    }
    if (m.find("ClientAffinity") != m.end() && !m["ClientAffinity"].empty()) {
      clientAffinity = make_shared<string>(boost::any_cast<string>(m["ClientAffinity"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("ListenerId") != m.end() && !m["ListenerId"].empty()) {
      listenerId = make_shared<string>(boost::any_cast<string>(m["ListenerId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("PortRanges") != m.end() && !m["PortRanges"].empty()) {
      if (typeid(vector<boost::any>) == m["PortRanges"].type()) {
        vector<DescribeListenerResponseBodyPortRanges> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PortRanges"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeListenerResponseBodyPortRanges model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        portRanges = make_shared<vector<DescribeListenerResponseBodyPortRanges>>(expect1);
      }
    }
    if (m.find("Protocol") != m.end() && !m["Protocol"].empty()) {
      protocol = make_shared<string>(boost::any_cast<string>(m["Protocol"]));
    }
    if (m.find("ProxyProtocol") != m.end() && !m["ProxyProtocol"].empty()) {
      proxyProtocol = make_shared<bool>(boost::any_cast<bool>(m["ProxyProtocol"]));
    }
    if (m.find("RelatedAcls") != m.end() && !m["RelatedAcls"].empty()) {
      if (typeid(vector<boost::any>) == m["RelatedAcls"].type()) {
        vector<DescribeListenerResponseBodyRelatedAcls> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RelatedAcls"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeListenerResponseBodyRelatedAcls model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        relatedAcls = make_shared<vector<DescribeListenerResponseBodyRelatedAcls>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SecurityPolicyId") != m.end() && !m["SecurityPolicyId"].empty()) {
      securityPolicyId = make_shared<string>(boost::any_cast<string>(m["SecurityPolicyId"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("XForwardedForConfig") != m.end() && !m["XForwardedForConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["XForwardedForConfig"].type()) {
        DescribeListenerResponseBodyXForwardedForConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["XForwardedForConfig"]));
        XForwardedForConfig = make_shared<DescribeListenerResponseBodyXForwardedForConfig>(model1);
      }
    }
  }


  virtual ~DescribeListenerResponseBody() = default;
};
class DescribeListenerResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeListenerResponseBody> body{};

  DescribeListenerResponse() {}

  explicit DescribeListenerResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeListenerResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeListenerResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeListenerResponse() = default;
};
class DescribeRegionsRequest : public Darabonba::Model {
public:
  shared_ptr<string> regionId{};

  DescribeRegionsRequest() {}

  explicit DescribeRegionsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DescribeRegionsRequest() = default;
};
class DescribeRegionsResponseBodyRegions : public Darabonba::Model {
public:
  shared_ptr<string> localName{};
  shared_ptr<string> regionId{};

  DescribeRegionsResponseBodyRegions() {}

  explicit DescribeRegionsResponseBodyRegions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (localName) {
      res["LocalName"] = boost::any(*localName);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LocalName") != m.end() && !m["LocalName"].empty()) {
      localName = make_shared<string>(boost::any_cast<string>(m["LocalName"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DescribeRegionsResponseBodyRegions() = default;
};
class DescribeRegionsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeRegionsResponseBodyRegions>> regions{};
  shared_ptr<string> requestId{};

  DescribeRegionsResponseBody() {}

  explicit DescribeRegionsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (regions) {
      vector<boost::any> temp1;
      for(auto item1:*regions){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Regions"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Regions") != m.end() && !m["Regions"].empty()) {
      if (typeid(vector<boost::any>) == m["Regions"].type()) {
        vector<DescribeRegionsResponseBodyRegions> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Regions"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeRegionsResponseBodyRegions model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        regions = make_shared<vector<DescribeRegionsResponseBodyRegions>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeRegionsResponseBody() = default;
};
class DescribeRegionsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeRegionsResponseBody> body{};

  DescribeRegionsResponse() {}

  explicit DescribeRegionsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeRegionsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeRegionsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeRegionsResponse() = default;
};
class DetachDdosFromAcceleratorRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceleratorId{};
  shared_ptr<string> regionId{};

  DetachDdosFromAcceleratorRequest() {}

  explicit DetachDdosFromAcceleratorRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceleratorId) {
      res["AcceleratorId"] = boost::any(*acceleratorId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceleratorId") != m.end() && !m["AcceleratorId"].empty()) {
      acceleratorId = make_shared<string>(boost::any_cast<string>(m["AcceleratorId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DetachDdosFromAcceleratorRequest() = default;
};
class DetachDdosFromAcceleratorResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> ddosId{};
  shared_ptr<string> requestId{};

  DetachDdosFromAcceleratorResponseBody() {}

  explicit DetachDdosFromAcceleratorResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ddosId) {
      res["DdosId"] = boost::any(*ddosId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DdosId") != m.end() && !m["DdosId"].empty()) {
      ddosId = make_shared<string>(boost::any_cast<string>(m["DdosId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DetachDdosFromAcceleratorResponseBody() = default;
};
class DetachDdosFromAcceleratorResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DetachDdosFromAcceleratorResponseBody> body{};

  DetachDdosFromAcceleratorResponse() {}

  explicit DetachDdosFromAcceleratorResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DetachDdosFromAcceleratorResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DetachDdosFromAcceleratorResponseBody>(model1);
      }
    }
  }


  virtual ~DetachDdosFromAcceleratorResponse() = default;
};
class DetachLogStoreFromEndpointGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceleratorId{};
  shared_ptr<string> clientToken{};
  shared_ptr<vector<string>> endpointGroupIds{};
  shared_ptr<string> listenerId{};
  shared_ptr<string> regionId{};

  DetachLogStoreFromEndpointGroupRequest() {}

  explicit DetachLogStoreFromEndpointGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceleratorId) {
      res["AcceleratorId"] = boost::any(*acceleratorId);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (endpointGroupIds) {
      res["EndpointGroupIds"] = boost::any(*endpointGroupIds);
    }
    if (listenerId) {
      res["ListenerId"] = boost::any(*listenerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceleratorId") != m.end() && !m["AcceleratorId"].empty()) {
      acceleratorId = make_shared<string>(boost::any_cast<string>(m["AcceleratorId"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("EndpointGroupIds") != m.end() && !m["EndpointGroupIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["EndpointGroupIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["EndpointGroupIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      endpointGroupIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ListenerId") != m.end() && !m["ListenerId"].empty()) {
      listenerId = make_shared<string>(boost::any_cast<string>(m["ListenerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DetachLogStoreFromEndpointGroupRequest() = default;
};
class DetachLogStoreFromEndpointGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DetachLogStoreFromEndpointGroupResponseBody() {}

  explicit DetachLogStoreFromEndpointGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DetachLogStoreFromEndpointGroupResponseBody() = default;
};
class DetachLogStoreFromEndpointGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DetachLogStoreFromEndpointGroupResponseBody> body{};

  DetachLogStoreFromEndpointGroupResponse() {}

  explicit DetachLogStoreFromEndpointGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DetachLogStoreFromEndpointGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DetachLogStoreFromEndpointGroupResponseBody>(model1);
      }
    }
  }


  virtual ~DetachLogStoreFromEndpointGroupResponse() = default;
};
class DetectApplicationMonitorRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> regionId{};
  shared_ptr<string> taskId{};

  DetectApplicationMonitorRequest() {}

  explicit DetectApplicationMonitorRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
  }


  virtual ~DetectApplicationMonitorRequest() = default;
};
class DetectApplicationMonitorResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DetectApplicationMonitorResponseBody() {}

  explicit DetectApplicationMonitorResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DetectApplicationMonitorResponseBody() = default;
};
class DetectApplicationMonitorResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DetectApplicationMonitorResponseBody> body{};

  DetectApplicationMonitorResponse() {}

  explicit DetectApplicationMonitorResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DetectApplicationMonitorResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DetectApplicationMonitorResponseBody>(model1);
      }
    }
  }


  virtual ~DetectApplicationMonitorResponse() = default;
};
class DisableApplicationMonitorRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> regionId{};
  shared_ptr<string> taskId{};

  DisableApplicationMonitorRequest() {}

  explicit DisableApplicationMonitorRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
  }


  virtual ~DisableApplicationMonitorRequest() = default;
};
class DisableApplicationMonitorResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DisableApplicationMonitorResponseBody() {}

  explicit DisableApplicationMonitorResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DisableApplicationMonitorResponseBody() = default;
};
class DisableApplicationMonitorResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DisableApplicationMonitorResponseBody> body{};

  DisableApplicationMonitorResponse() {}

  explicit DisableApplicationMonitorResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DisableApplicationMonitorResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DisableApplicationMonitorResponseBody>(model1);
      }
    }
  }


  virtual ~DisableApplicationMonitorResponse() = default;
};
class DissociateAclsFromListenerRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> aclIds{};
  shared_ptr<string> clientToken{};
  shared_ptr<bool> dryRun{};
  shared_ptr<string> listenerId{};
  shared_ptr<string> regionId{};

  DissociateAclsFromListenerRequest() {}

  explicit DissociateAclsFromListenerRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aclIds) {
      res["AclIds"] = boost::any(*aclIds);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (dryRun) {
      res["DryRun"] = boost::any(*dryRun);
    }
    if (listenerId) {
      res["ListenerId"] = boost::any(*listenerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AclIds") != m.end() && !m["AclIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["AclIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["AclIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      aclIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("DryRun") != m.end() && !m["DryRun"].empty()) {
      dryRun = make_shared<bool>(boost::any_cast<bool>(m["DryRun"]));
    }
    if (m.find("ListenerId") != m.end() && !m["ListenerId"].empty()) {
      listenerId = make_shared<string>(boost::any_cast<string>(m["ListenerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DissociateAclsFromListenerRequest() = default;
};
class DissociateAclsFromListenerResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<string>> aclIds{};
  shared_ptr<string> listenerId{};
  shared_ptr<string> requestId{};

  DissociateAclsFromListenerResponseBody() {}

  explicit DissociateAclsFromListenerResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aclIds) {
      res["AclIds"] = boost::any(*aclIds);
    }
    if (listenerId) {
      res["ListenerId"] = boost::any(*listenerId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AclIds") != m.end() && !m["AclIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["AclIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["AclIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      aclIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ListenerId") != m.end() && !m["ListenerId"].empty()) {
      listenerId = make_shared<string>(boost::any_cast<string>(m["ListenerId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DissociateAclsFromListenerResponseBody() = default;
};
class DissociateAclsFromListenerResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DissociateAclsFromListenerResponseBody> body{};

  DissociateAclsFromListenerResponse() {}

  explicit DissociateAclsFromListenerResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DissociateAclsFromListenerResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DissociateAclsFromListenerResponseBody>(model1);
      }
    }
  }


  virtual ~DissociateAclsFromListenerResponse() = default;
};
class DissociateAdditionalCertificatesFromListenerRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceleratorId{};
  shared_ptr<string> clientToken{};
  shared_ptr<vector<string>> domains{};
  shared_ptr<string> listenerId{};
  shared_ptr<string> regionId{};

  DissociateAdditionalCertificatesFromListenerRequest() {}

  explicit DissociateAdditionalCertificatesFromListenerRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceleratorId) {
      res["AcceleratorId"] = boost::any(*acceleratorId);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (domains) {
      res["Domains"] = boost::any(*domains);
    }
    if (listenerId) {
      res["ListenerId"] = boost::any(*listenerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceleratorId") != m.end() && !m["AcceleratorId"].empty()) {
      acceleratorId = make_shared<string>(boost::any_cast<string>(m["AcceleratorId"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("Domains") != m.end() && !m["Domains"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Domains"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Domains"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      domains = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ListenerId") != m.end() && !m["ListenerId"].empty()) {
      listenerId = make_shared<string>(boost::any_cast<string>(m["ListenerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DissociateAdditionalCertificatesFromListenerRequest() = default;
};
class DissociateAdditionalCertificatesFromListenerResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DissociateAdditionalCertificatesFromListenerResponseBody() {}

  explicit DissociateAdditionalCertificatesFromListenerResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DissociateAdditionalCertificatesFromListenerResponseBody() = default;
};
class DissociateAdditionalCertificatesFromListenerResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DissociateAdditionalCertificatesFromListenerResponseBody> body{};

  DissociateAdditionalCertificatesFromListenerResponse() {}

  explicit DissociateAdditionalCertificatesFromListenerResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DissociateAdditionalCertificatesFromListenerResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DissociateAdditionalCertificatesFromListenerResponseBody>(model1);
      }
    }
  }


  virtual ~DissociateAdditionalCertificatesFromListenerResponse() = default;
};
class EnableApplicationMonitorRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> regionId{};
  shared_ptr<string> taskId{};

  EnableApplicationMonitorRequest() {}

  explicit EnableApplicationMonitorRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
  }


  virtual ~EnableApplicationMonitorRequest() = default;
};
class EnableApplicationMonitorResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  EnableApplicationMonitorResponseBody() {}

  explicit EnableApplicationMonitorResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~EnableApplicationMonitorResponseBody() = default;
};
class EnableApplicationMonitorResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<EnableApplicationMonitorResponseBody> body{};

  EnableApplicationMonitorResponse() {}

  explicit EnableApplicationMonitorResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        EnableApplicationMonitorResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<EnableApplicationMonitorResponseBody>(model1);
      }
    }
  }


  virtual ~EnableApplicationMonitorResponse() = default;
};
class GetAclRequest : public Darabonba::Model {
public:
  shared_ptr<string> aclId{};
  shared_ptr<string> regionId{};

  GetAclRequest() {}

  explicit GetAclRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aclId) {
      res["AclId"] = boost::any(*aclId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AclId") != m.end() && !m["AclId"].empty()) {
      aclId = make_shared<string>(boost::any_cast<string>(m["AclId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~GetAclRequest() = default;
};
class GetAclResponseBodyAclEntries : public Darabonba::Model {
public:
  shared_ptr<string> entry{};
  shared_ptr<string> entryDescription{};

  GetAclResponseBodyAclEntries() {}

  explicit GetAclResponseBodyAclEntries(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (entry) {
      res["Entry"] = boost::any(*entry);
    }
    if (entryDescription) {
      res["EntryDescription"] = boost::any(*entryDescription);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Entry") != m.end() && !m["Entry"].empty()) {
      entry = make_shared<string>(boost::any_cast<string>(m["Entry"]));
    }
    if (m.find("EntryDescription") != m.end() && !m["EntryDescription"].empty()) {
      entryDescription = make_shared<string>(boost::any_cast<string>(m["EntryDescription"]));
    }
  }


  virtual ~GetAclResponseBodyAclEntries() = default;
};
class GetAclResponseBodyRelatedListeners : public Darabonba::Model {
public:
  shared_ptr<string> acceleratorId{};
  shared_ptr<string> aclType{};
  shared_ptr<string> listenerId{};

  GetAclResponseBodyRelatedListeners() {}

  explicit GetAclResponseBodyRelatedListeners(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceleratorId) {
      res["AcceleratorId"] = boost::any(*acceleratorId);
    }
    if (aclType) {
      res["AclType"] = boost::any(*aclType);
    }
    if (listenerId) {
      res["ListenerId"] = boost::any(*listenerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceleratorId") != m.end() && !m["AcceleratorId"].empty()) {
      acceleratorId = make_shared<string>(boost::any_cast<string>(m["AcceleratorId"]));
    }
    if (m.find("AclType") != m.end() && !m["AclType"].empty()) {
      aclType = make_shared<string>(boost::any_cast<string>(m["AclType"]));
    }
    if (m.find("ListenerId") != m.end() && !m["ListenerId"].empty()) {
      listenerId = make_shared<string>(boost::any_cast<string>(m["ListenerId"]));
    }
  }


  virtual ~GetAclResponseBodyRelatedListeners() = default;
};
class GetAclResponseBodyTags : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  GetAclResponseBodyTags() {}

  explicit GetAclResponseBodyTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~GetAclResponseBodyTags() = default;
};
class GetAclResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<GetAclResponseBodyAclEntries>> aclEntries{};
  shared_ptr<string> aclId{};
  shared_ptr<string> aclName{};
  shared_ptr<string> aclStatus{};
  shared_ptr<string> addressIPVersion{};
  shared_ptr<vector<GetAclResponseBodyRelatedListeners>> relatedListeners{};
  shared_ptr<string> requestId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<vector<GetAclResponseBodyTags>> tags{};

  GetAclResponseBody() {}

  explicit GetAclResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aclEntries) {
      vector<boost::any> temp1;
      for(auto item1:*aclEntries){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AclEntries"] = boost::any(temp1);
    }
    if (aclId) {
      res["AclId"] = boost::any(*aclId);
    }
    if (aclName) {
      res["AclName"] = boost::any(*aclName);
    }
    if (aclStatus) {
      res["AclStatus"] = boost::any(*aclStatus);
    }
    if (addressIPVersion) {
      res["AddressIPVersion"] = boost::any(*addressIPVersion);
    }
    if (relatedListeners) {
      vector<boost::any> temp1;
      for(auto item1:*relatedListeners){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RelatedListeners"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tags"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AclEntries") != m.end() && !m["AclEntries"].empty()) {
      if (typeid(vector<boost::any>) == m["AclEntries"].type()) {
        vector<GetAclResponseBodyAclEntries> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AclEntries"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetAclResponseBodyAclEntries model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        aclEntries = make_shared<vector<GetAclResponseBodyAclEntries>>(expect1);
      }
    }
    if (m.find("AclId") != m.end() && !m["AclId"].empty()) {
      aclId = make_shared<string>(boost::any_cast<string>(m["AclId"]));
    }
    if (m.find("AclName") != m.end() && !m["AclName"].empty()) {
      aclName = make_shared<string>(boost::any_cast<string>(m["AclName"]));
    }
    if (m.find("AclStatus") != m.end() && !m["AclStatus"].empty()) {
      aclStatus = make_shared<string>(boost::any_cast<string>(m["AclStatus"]));
    }
    if (m.find("AddressIPVersion") != m.end() && !m["AddressIPVersion"].empty()) {
      addressIPVersion = make_shared<string>(boost::any_cast<string>(m["AddressIPVersion"]));
    }
    if (m.find("RelatedListeners") != m.end() && !m["RelatedListeners"].empty()) {
      if (typeid(vector<boost::any>) == m["RelatedListeners"].type()) {
        vector<GetAclResponseBodyRelatedListeners> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RelatedListeners"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetAclResponseBodyRelatedListeners model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        relatedListeners = make_shared<vector<GetAclResponseBodyRelatedListeners>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(vector<boost::any>) == m["Tags"].type()) {
        vector<GetAclResponseBodyTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetAclResponseBodyTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<GetAclResponseBodyTags>>(expect1);
      }
    }
  }


  virtual ~GetAclResponseBody() = default;
};
class GetAclResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetAclResponseBody> body{};

  GetAclResponse() {}

  explicit GetAclResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetAclResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetAclResponseBody>(model1);
      }
    }
  }


  virtual ~GetAclResponse() = default;
};
class GetBasicAccelerateIpRequest : public Darabonba::Model {
public:
  shared_ptr<string> accelerateIpId{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> regionId{};

  GetBasicAccelerateIpRequest() {}

  explicit GetBasicAccelerateIpRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accelerateIpId) {
      res["AccelerateIpId"] = boost::any(*accelerateIpId);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccelerateIpId") != m.end() && !m["AccelerateIpId"].empty()) {
      accelerateIpId = make_shared<string>(boost::any_cast<string>(m["AccelerateIpId"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~GetBasicAccelerateIpRequest() = default;
};
class GetBasicAccelerateIpResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> accelerateIpAddress{};
  shared_ptr<string> accelerateIpId{};
  shared_ptr<string> acceleratorId{};
  shared_ptr<string> ipSetId{};
  shared_ptr<string> requestId{};
  shared_ptr<string> state{};

  GetBasicAccelerateIpResponseBody() {}

  explicit GetBasicAccelerateIpResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accelerateIpAddress) {
      res["AccelerateIpAddress"] = boost::any(*accelerateIpAddress);
    }
    if (accelerateIpId) {
      res["AccelerateIpId"] = boost::any(*accelerateIpId);
    }
    if (acceleratorId) {
      res["AcceleratorId"] = boost::any(*acceleratorId);
    }
    if (ipSetId) {
      res["IpSetId"] = boost::any(*ipSetId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccelerateIpAddress") != m.end() && !m["AccelerateIpAddress"].empty()) {
      accelerateIpAddress = make_shared<string>(boost::any_cast<string>(m["AccelerateIpAddress"]));
    }
    if (m.find("AccelerateIpId") != m.end() && !m["AccelerateIpId"].empty()) {
      accelerateIpId = make_shared<string>(boost::any_cast<string>(m["AccelerateIpId"]));
    }
    if (m.find("AcceleratorId") != m.end() && !m["AcceleratorId"].empty()) {
      acceleratorId = make_shared<string>(boost::any_cast<string>(m["AcceleratorId"]));
    }
    if (m.find("IpSetId") != m.end() && !m["IpSetId"].empty()) {
      ipSetId = make_shared<string>(boost::any_cast<string>(m["IpSetId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
  }


  virtual ~GetBasicAccelerateIpResponseBody() = default;
};
class GetBasicAccelerateIpResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetBasicAccelerateIpResponseBody> body{};

  GetBasicAccelerateIpResponse() {}

  explicit GetBasicAccelerateIpResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetBasicAccelerateIpResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetBasicAccelerateIpResponseBody>(model1);
      }
    }
  }


  virtual ~GetBasicAccelerateIpResponse() = default;
};
class GetBasicAccelerateIpEndpointRelationRequest : public Darabonba::Model {
public:
  shared_ptr<string> accelerateIpId{};
  shared_ptr<string> acceleratorId{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> endpointId{};
  shared_ptr<string> regionId{};

  GetBasicAccelerateIpEndpointRelationRequest() {}

  explicit GetBasicAccelerateIpEndpointRelationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accelerateIpId) {
      res["AccelerateIpId"] = boost::any(*accelerateIpId);
    }
    if (acceleratorId) {
      res["AcceleratorId"] = boost::any(*acceleratorId);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (endpointId) {
      res["EndpointId"] = boost::any(*endpointId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccelerateIpId") != m.end() && !m["AccelerateIpId"].empty()) {
      accelerateIpId = make_shared<string>(boost::any_cast<string>(m["AccelerateIpId"]));
    }
    if (m.find("AcceleratorId") != m.end() && !m["AcceleratorId"].empty()) {
      acceleratorId = make_shared<string>(boost::any_cast<string>(m["AcceleratorId"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("EndpointId") != m.end() && !m["EndpointId"].empty()) {
      endpointId = make_shared<string>(boost::any_cast<string>(m["EndpointId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~GetBasicAccelerateIpEndpointRelationRequest() = default;
};
class GetBasicAccelerateIpEndpointRelationResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> accelerateIpId{};
  shared_ptr<string> acceleratorId{};
  shared_ptr<string> endpointAddress{};
  shared_ptr<string> endpointId{};
  shared_ptr<string> endpointName{};
  shared_ptr<string> endpointSubAddress{};
  shared_ptr<string> endpointSubAddressType{};
  shared_ptr<string> endpointType{};
  shared_ptr<string> endpointZoneId{};
  shared_ptr<string> ipAddress{};
  shared_ptr<string> requestId{};
  shared_ptr<string> state{};

  GetBasicAccelerateIpEndpointRelationResponseBody() {}

  explicit GetBasicAccelerateIpEndpointRelationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accelerateIpId) {
      res["AccelerateIpId"] = boost::any(*accelerateIpId);
    }
    if (acceleratorId) {
      res["AcceleratorId"] = boost::any(*acceleratorId);
    }
    if (endpointAddress) {
      res["EndpointAddress"] = boost::any(*endpointAddress);
    }
    if (endpointId) {
      res["EndpointId"] = boost::any(*endpointId);
    }
    if (endpointName) {
      res["EndpointName"] = boost::any(*endpointName);
    }
    if (endpointSubAddress) {
      res["EndpointSubAddress"] = boost::any(*endpointSubAddress);
    }
    if (endpointSubAddressType) {
      res["EndpointSubAddressType"] = boost::any(*endpointSubAddressType);
    }
    if (endpointType) {
      res["EndpointType"] = boost::any(*endpointType);
    }
    if (endpointZoneId) {
      res["EndpointZoneId"] = boost::any(*endpointZoneId);
    }
    if (ipAddress) {
      res["IpAddress"] = boost::any(*ipAddress);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccelerateIpId") != m.end() && !m["AccelerateIpId"].empty()) {
      accelerateIpId = make_shared<string>(boost::any_cast<string>(m["AccelerateIpId"]));
    }
    if (m.find("AcceleratorId") != m.end() && !m["AcceleratorId"].empty()) {
      acceleratorId = make_shared<string>(boost::any_cast<string>(m["AcceleratorId"]));
    }
    if (m.find("EndpointAddress") != m.end() && !m["EndpointAddress"].empty()) {
      endpointAddress = make_shared<string>(boost::any_cast<string>(m["EndpointAddress"]));
    }
    if (m.find("EndpointId") != m.end() && !m["EndpointId"].empty()) {
      endpointId = make_shared<string>(boost::any_cast<string>(m["EndpointId"]));
    }
    if (m.find("EndpointName") != m.end() && !m["EndpointName"].empty()) {
      endpointName = make_shared<string>(boost::any_cast<string>(m["EndpointName"]));
    }
    if (m.find("EndpointSubAddress") != m.end() && !m["EndpointSubAddress"].empty()) {
      endpointSubAddress = make_shared<string>(boost::any_cast<string>(m["EndpointSubAddress"]));
    }
    if (m.find("EndpointSubAddressType") != m.end() && !m["EndpointSubAddressType"].empty()) {
      endpointSubAddressType = make_shared<string>(boost::any_cast<string>(m["EndpointSubAddressType"]));
    }
    if (m.find("EndpointType") != m.end() && !m["EndpointType"].empty()) {
      endpointType = make_shared<string>(boost::any_cast<string>(m["EndpointType"]));
    }
    if (m.find("EndpointZoneId") != m.end() && !m["EndpointZoneId"].empty()) {
      endpointZoneId = make_shared<string>(boost::any_cast<string>(m["EndpointZoneId"]));
    }
    if (m.find("IpAddress") != m.end() && !m["IpAddress"].empty()) {
      ipAddress = make_shared<string>(boost::any_cast<string>(m["IpAddress"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
  }


  virtual ~GetBasicAccelerateIpEndpointRelationResponseBody() = default;
};
class GetBasicAccelerateIpEndpointRelationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetBasicAccelerateIpEndpointRelationResponseBody> body{};

  GetBasicAccelerateIpEndpointRelationResponse() {}

  explicit GetBasicAccelerateIpEndpointRelationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetBasicAccelerateIpEndpointRelationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetBasicAccelerateIpEndpointRelationResponseBody>(model1);
      }
    }
  }


  virtual ~GetBasicAccelerateIpEndpointRelationResponse() = default;
};
class GetBasicAccelerateIpIdleCountRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> ipSetId{};
  shared_ptr<string> regionId{};

  GetBasicAccelerateIpIdleCountRequest() {}

  explicit GetBasicAccelerateIpIdleCountRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (ipSetId) {
      res["IpSetId"] = boost::any(*ipSetId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("IpSetId") != m.end() && !m["IpSetId"].empty()) {
      ipSetId = make_shared<string>(boost::any_cast<string>(m["IpSetId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~GetBasicAccelerateIpIdleCountRequest() = default;
};
class GetBasicAccelerateIpIdleCountResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  GetBasicAccelerateIpIdleCountResponseBody() {}

  explicit GetBasicAccelerateIpIdleCountResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~GetBasicAccelerateIpIdleCountResponseBody() = default;
};
class GetBasicAccelerateIpIdleCountResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetBasicAccelerateIpIdleCountResponseBody> body{};

  GetBasicAccelerateIpIdleCountResponse() {}

  explicit GetBasicAccelerateIpIdleCountResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetBasicAccelerateIpIdleCountResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetBasicAccelerateIpIdleCountResponseBody>(model1);
      }
    }
  }


  virtual ~GetBasicAccelerateIpIdleCountResponse() = default;
};
class GetBasicAcceleratorRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceleratorId{};
  shared_ptr<string> regionId{};

  GetBasicAcceleratorRequest() {}

  explicit GetBasicAcceleratorRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceleratorId) {
      res["AcceleratorId"] = boost::any(*acceleratorId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceleratorId") != m.end() && !m["AcceleratorId"].empty()) {
      acceleratorId = make_shared<string>(boost::any_cast<string>(m["AcceleratorId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~GetBasicAcceleratorRequest() = default;
};
class GetBasicAcceleratorResponseBodyBasicBandwidthPackage : public Darabonba::Model {
public:
  shared_ptr<long> bandwidth{};
  shared_ptr<string> bandwidthType{};
  shared_ptr<string> instanceId{};

  GetBasicAcceleratorResponseBodyBasicBandwidthPackage() {}

  explicit GetBasicAcceleratorResponseBodyBasicBandwidthPackage(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bandwidth) {
      res["Bandwidth"] = boost::any(*bandwidth);
    }
    if (bandwidthType) {
      res["BandwidthType"] = boost::any(*bandwidthType);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bandwidth") != m.end() && !m["Bandwidth"].empty()) {
      bandwidth = make_shared<long>(boost::any_cast<long>(m["Bandwidth"]));
    }
    if (m.find("BandwidthType") != m.end() && !m["BandwidthType"].empty()) {
      bandwidthType = make_shared<string>(boost::any_cast<string>(m["BandwidthType"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~GetBasicAcceleratorResponseBodyBasicBandwidthPackage() = default;
};
class GetBasicAcceleratorResponseBodyCrossDomainBandwidthPackage : public Darabonba::Model {
public:
  shared_ptr<long> bandwidth{};
  shared_ptr<string> instanceId{};

  GetBasicAcceleratorResponseBodyCrossDomainBandwidthPackage() {}

  explicit GetBasicAcceleratorResponseBodyCrossDomainBandwidthPackage(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bandwidth) {
      res["Bandwidth"] = boost::any(*bandwidth);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bandwidth") != m.end() && !m["Bandwidth"].empty()) {
      bandwidth = make_shared<long>(boost::any_cast<long>(m["Bandwidth"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~GetBasicAcceleratorResponseBodyCrossDomainBandwidthPackage() = default;
};
class GetBasicAcceleratorResponseBodyTags : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  GetBasicAcceleratorResponseBodyTags() {}

  explicit GetBasicAcceleratorResponseBodyTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~GetBasicAcceleratorResponseBodyTags() = default;
};
class GetBasicAcceleratorResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> acceleratorId{};
  shared_ptr<string> bandwidthBillingType{};
  shared_ptr<GetBasicAcceleratorResponseBodyBasicBandwidthPackage> basicBandwidthPackage{};
  shared_ptr<string> basicEndpointGroupId{};
  shared_ptr<string> basicIpSetId{};
  shared_ptr<string> cenId{};
  shared_ptr<long> createTime{};
  shared_ptr<bool> crossBorderStatus{};
  shared_ptr<GetBasicAcceleratorResponseBodyCrossDomainBandwidthPackage> crossDomainBandwidthPackage{};
  shared_ptr<string> crossPrivateState{};
  shared_ptr<string> description{};
  shared_ptr<long> expiredTime{};
  shared_ptr<string> instanceChargeType{};
  shared_ptr<string> name{};
  shared_ptr<string> regionId{};
  shared_ptr<string> requestId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> state{};
  shared_ptr<vector<GetBasicAcceleratorResponseBodyTags>> tags{};

  GetBasicAcceleratorResponseBody() {}

  explicit GetBasicAcceleratorResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceleratorId) {
      res["AcceleratorId"] = boost::any(*acceleratorId);
    }
    if (bandwidthBillingType) {
      res["BandwidthBillingType"] = boost::any(*bandwidthBillingType);
    }
    if (basicBandwidthPackage) {
      res["BasicBandwidthPackage"] = basicBandwidthPackage ? boost::any(basicBandwidthPackage->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (basicEndpointGroupId) {
      res["BasicEndpointGroupId"] = boost::any(*basicEndpointGroupId);
    }
    if (basicIpSetId) {
      res["BasicIpSetId"] = boost::any(*basicIpSetId);
    }
    if (cenId) {
      res["CenId"] = boost::any(*cenId);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (crossBorderStatus) {
      res["CrossBorderStatus"] = boost::any(*crossBorderStatus);
    }
    if (crossDomainBandwidthPackage) {
      res["CrossDomainBandwidthPackage"] = crossDomainBandwidthPackage ? boost::any(crossDomainBandwidthPackage->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (crossPrivateState) {
      res["CrossPrivateState"] = boost::any(*crossPrivateState);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (expiredTime) {
      res["ExpiredTime"] = boost::any(*expiredTime);
    }
    if (instanceChargeType) {
      res["InstanceChargeType"] = boost::any(*instanceChargeType);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tags"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceleratorId") != m.end() && !m["AcceleratorId"].empty()) {
      acceleratorId = make_shared<string>(boost::any_cast<string>(m["AcceleratorId"]));
    }
    if (m.find("BandwidthBillingType") != m.end() && !m["BandwidthBillingType"].empty()) {
      bandwidthBillingType = make_shared<string>(boost::any_cast<string>(m["BandwidthBillingType"]));
    }
    if (m.find("BasicBandwidthPackage") != m.end() && !m["BasicBandwidthPackage"].empty()) {
      if (typeid(map<string, boost::any>) == m["BasicBandwidthPackage"].type()) {
        GetBasicAcceleratorResponseBodyBasicBandwidthPackage model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["BasicBandwidthPackage"]));
        basicBandwidthPackage = make_shared<GetBasicAcceleratorResponseBodyBasicBandwidthPackage>(model1);
      }
    }
    if (m.find("BasicEndpointGroupId") != m.end() && !m["BasicEndpointGroupId"].empty()) {
      basicEndpointGroupId = make_shared<string>(boost::any_cast<string>(m["BasicEndpointGroupId"]));
    }
    if (m.find("BasicIpSetId") != m.end() && !m["BasicIpSetId"].empty()) {
      basicIpSetId = make_shared<string>(boost::any_cast<string>(m["BasicIpSetId"]));
    }
    if (m.find("CenId") != m.end() && !m["CenId"].empty()) {
      cenId = make_shared<string>(boost::any_cast<string>(m["CenId"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("CrossBorderStatus") != m.end() && !m["CrossBorderStatus"].empty()) {
      crossBorderStatus = make_shared<bool>(boost::any_cast<bool>(m["CrossBorderStatus"]));
    }
    if (m.find("CrossDomainBandwidthPackage") != m.end() && !m["CrossDomainBandwidthPackage"].empty()) {
      if (typeid(map<string, boost::any>) == m["CrossDomainBandwidthPackage"].type()) {
        GetBasicAcceleratorResponseBodyCrossDomainBandwidthPackage model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CrossDomainBandwidthPackage"]));
        crossDomainBandwidthPackage = make_shared<GetBasicAcceleratorResponseBodyCrossDomainBandwidthPackage>(model1);
      }
    }
    if (m.find("CrossPrivateState") != m.end() && !m["CrossPrivateState"].empty()) {
      crossPrivateState = make_shared<string>(boost::any_cast<string>(m["CrossPrivateState"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("ExpiredTime") != m.end() && !m["ExpiredTime"].empty()) {
      expiredTime = make_shared<long>(boost::any_cast<long>(m["ExpiredTime"]));
    }
    if (m.find("InstanceChargeType") != m.end() && !m["InstanceChargeType"].empty()) {
      instanceChargeType = make_shared<string>(boost::any_cast<string>(m["InstanceChargeType"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(vector<boost::any>) == m["Tags"].type()) {
        vector<GetBasicAcceleratorResponseBodyTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetBasicAcceleratorResponseBodyTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<GetBasicAcceleratorResponseBodyTags>>(expect1);
      }
    }
  }


  virtual ~GetBasicAcceleratorResponseBody() = default;
};
class GetBasicAcceleratorResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetBasicAcceleratorResponseBody> body{};

  GetBasicAcceleratorResponse() {}

  explicit GetBasicAcceleratorResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetBasicAcceleratorResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetBasicAcceleratorResponseBody>(model1);
      }
    }
  }


  virtual ~GetBasicAcceleratorResponse() = default;
};
class GetBasicEndpointRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> endpointId{};
  shared_ptr<string> regionId{};

  GetBasicEndpointRequest() {}

  explicit GetBasicEndpointRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (endpointId) {
      res["EndpointId"] = boost::any(*endpointId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("EndpointId") != m.end() && !m["EndpointId"].empty()) {
      endpointId = make_shared<string>(boost::any_cast<string>(m["EndpointId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~GetBasicEndpointRequest() = default;
};
class GetBasicEndpointResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> acceleratorId{};
  shared_ptr<string> endPointId{};
  shared_ptr<string> endpointAddress{};
  shared_ptr<string> endpointGroupId{};
  shared_ptr<string> endpointSubAddress{};
  shared_ptr<string> endpointSubAddressType{};
  shared_ptr<string> endpointType{};
  shared_ptr<string> endpointZoneId{};
  shared_ptr<string> name{};
  shared_ptr<string> requestId{};
  shared_ptr<string> state{};

  GetBasicEndpointResponseBody() {}

  explicit GetBasicEndpointResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceleratorId) {
      res["AcceleratorId"] = boost::any(*acceleratorId);
    }
    if (endPointId) {
      res["EndPointId"] = boost::any(*endPointId);
    }
    if (endpointAddress) {
      res["EndpointAddress"] = boost::any(*endpointAddress);
    }
    if (endpointGroupId) {
      res["EndpointGroupId"] = boost::any(*endpointGroupId);
    }
    if (endpointSubAddress) {
      res["EndpointSubAddress"] = boost::any(*endpointSubAddress);
    }
    if (endpointSubAddressType) {
      res["EndpointSubAddressType"] = boost::any(*endpointSubAddressType);
    }
    if (endpointType) {
      res["EndpointType"] = boost::any(*endpointType);
    }
    if (endpointZoneId) {
      res["EndpointZoneId"] = boost::any(*endpointZoneId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceleratorId") != m.end() && !m["AcceleratorId"].empty()) {
      acceleratorId = make_shared<string>(boost::any_cast<string>(m["AcceleratorId"]));
    }
    if (m.find("EndPointId") != m.end() && !m["EndPointId"].empty()) {
      endPointId = make_shared<string>(boost::any_cast<string>(m["EndPointId"]));
    }
    if (m.find("EndpointAddress") != m.end() && !m["EndpointAddress"].empty()) {
      endpointAddress = make_shared<string>(boost::any_cast<string>(m["EndpointAddress"]));
    }
    if (m.find("EndpointGroupId") != m.end() && !m["EndpointGroupId"].empty()) {
      endpointGroupId = make_shared<string>(boost::any_cast<string>(m["EndpointGroupId"]));
    }
    if (m.find("EndpointSubAddress") != m.end() && !m["EndpointSubAddress"].empty()) {
      endpointSubAddress = make_shared<string>(boost::any_cast<string>(m["EndpointSubAddress"]));
    }
    if (m.find("EndpointSubAddressType") != m.end() && !m["EndpointSubAddressType"].empty()) {
      endpointSubAddressType = make_shared<string>(boost::any_cast<string>(m["EndpointSubAddressType"]));
    }
    if (m.find("EndpointType") != m.end() && !m["EndpointType"].empty()) {
      endpointType = make_shared<string>(boost::any_cast<string>(m["EndpointType"]));
    }
    if (m.find("EndpointZoneId") != m.end() && !m["EndpointZoneId"].empty()) {
      endpointZoneId = make_shared<string>(boost::any_cast<string>(m["EndpointZoneId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
  }


  virtual ~GetBasicEndpointResponseBody() = default;
};
class GetBasicEndpointResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetBasicEndpointResponseBody> body{};

  GetBasicEndpointResponse() {}

  explicit GetBasicEndpointResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetBasicEndpointResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetBasicEndpointResponseBody>(model1);
      }
    }
  }


  virtual ~GetBasicEndpointResponse() = default;
};
class GetBasicEndpointGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> endpointGroupId{};
  shared_ptr<string> regionId{};

  GetBasicEndpointGroupRequest() {}

  explicit GetBasicEndpointGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (endpointGroupId) {
      res["EndpointGroupId"] = boost::any(*endpointGroupId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("EndpointGroupId") != m.end() && !m["EndpointGroupId"].empty()) {
      endpointGroupId = make_shared<string>(boost::any_cast<string>(m["EndpointGroupId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~GetBasicEndpointGroupRequest() = default;
};
class GetBasicEndpointGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> acceleratorId{};
  shared_ptr<string> description{};
  shared_ptr<string> endpointAddress{};
  shared_ptr<string> endpointGroupId{};
  shared_ptr<string> endpointGroupRegion{};
  shared_ptr<string> endpointSubAddress{};
  shared_ptr<string> endpointType{};
  shared_ptr<string> name{};
  shared_ptr<string> requestId{};
  shared_ptr<string> state{};

  GetBasicEndpointGroupResponseBody() {}

  explicit GetBasicEndpointGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceleratorId) {
      res["AcceleratorId"] = boost::any(*acceleratorId);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (endpointAddress) {
      res["EndpointAddress"] = boost::any(*endpointAddress);
    }
    if (endpointGroupId) {
      res["EndpointGroupId"] = boost::any(*endpointGroupId);
    }
    if (endpointGroupRegion) {
      res["EndpointGroupRegion"] = boost::any(*endpointGroupRegion);
    }
    if (endpointSubAddress) {
      res["EndpointSubAddress"] = boost::any(*endpointSubAddress);
    }
    if (endpointType) {
      res["EndpointType"] = boost::any(*endpointType);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceleratorId") != m.end() && !m["AcceleratorId"].empty()) {
      acceleratorId = make_shared<string>(boost::any_cast<string>(m["AcceleratorId"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("EndpointAddress") != m.end() && !m["EndpointAddress"].empty()) {
      endpointAddress = make_shared<string>(boost::any_cast<string>(m["EndpointAddress"]));
    }
    if (m.find("EndpointGroupId") != m.end() && !m["EndpointGroupId"].empty()) {
      endpointGroupId = make_shared<string>(boost::any_cast<string>(m["EndpointGroupId"]));
    }
    if (m.find("EndpointGroupRegion") != m.end() && !m["EndpointGroupRegion"].empty()) {
      endpointGroupRegion = make_shared<string>(boost::any_cast<string>(m["EndpointGroupRegion"]));
    }
    if (m.find("EndpointSubAddress") != m.end() && !m["EndpointSubAddress"].empty()) {
      endpointSubAddress = make_shared<string>(boost::any_cast<string>(m["EndpointSubAddress"]));
    }
    if (m.find("EndpointType") != m.end() && !m["EndpointType"].empty()) {
      endpointType = make_shared<string>(boost::any_cast<string>(m["EndpointType"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
  }


  virtual ~GetBasicEndpointGroupResponseBody() = default;
};
class GetBasicEndpointGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetBasicEndpointGroupResponseBody> body{};

  GetBasicEndpointGroupResponse() {}

  explicit GetBasicEndpointGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetBasicEndpointGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetBasicEndpointGroupResponseBody>(model1);
      }
    }
  }


  virtual ~GetBasicEndpointGroupResponse() = default;
};
class GetBasicIpSetRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> ipSetId{};
  shared_ptr<string> regionId{};

  GetBasicIpSetRequest() {}

  explicit GetBasicIpSetRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (ipSetId) {
      res["IpSetId"] = boost::any(*ipSetId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("IpSetId") != m.end() && !m["IpSetId"].empty()) {
      ipSetId = make_shared<string>(boost::any_cast<string>(m["IpSetId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~GetBasicIpSetRequest() = default;
};
class GetBasicIpSetResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> accelerateRegionId{};
  shared_ptr<string> acceleratorId{};
  shared_ptr<long> bandwidth{};
  shared_ptr<string> ipAddress{};
  shared_ptr<string> ipSetId{};
  shared_ptr<string> ipVersion{};
  shared_ptr<string> ispType{};
  shared_ptr<string> requestId{};
  shared_ptr<string> state{};

  GetBasicIpSetResponseBody() {}

  explicit GetBasicIpSetResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accelerateRegionId) {
      res["AccelerateRegionId"] = boost::any(*accelerateRegionId);
    }
    if (acceleratorId) {
      res["AcceleratorId"] = boost::any(*acceleratorId);
    }
    if (bandwidth) {
      res["Bandwidth"] = boost::any(*bandwidth);
    }
    if (ipAddress) {
      res["IpAddress"] = boost::any(*ipAddress);
    }
    if (ipSetId) {
      res["IpSetId"] = boost::any(*ipSetId);
    }
    if (ipVersion) {
      res["IpVersion"] = boost::any(*ipVersion);
    }
    if (ispType) {
      res["IspType"] = boost::any(*ispType);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccelerateRegionId") != m.end() && !m["AccelerateRegionId"].empty()) {
      accelerateRegionId = make_shared<string>(boost::any_cast<string>(m["AccelerateRegionId"]));
    }
    if (m.find("AcceleratorId") != m.end() && !m["AcceleratorId"].empty()) {
      acceleratorId = make_shared<string>(boost::any_cast<string>(m["AcceleratorId"]));
    }
    if (m.find("Bandwidth") != m.end() && !m["Bandwidth"].empty()) {
      bandwidth = make_shared<long>(boost::any_cast<long>(m["Bandwidth"]));
    }
    if (m.find("IpAddress") != m.end() && !m["IpAddress"].empty()) {
      ipAddress = make_shared<string>(boost::any_cast<string>(m["IpAddress"]));
    }
    if (m.find("IpSetId") != m.end() && !m["IpSetId"].empty()) {
      ipSetId = make_shared<string>(boost::any_cast<string>(m["IpSetId"]));
    }
    if (m.find("IpVersion") != m.end() && !m["IpVersion"].empty()) {
      ipVersion = make_shared<string>(boost::any_cast<string>(m["IpVersion"]));
    }
    if (m.find("IspType") != m.end() && !m["IspType"].empty()) {
      ispType = make_shared<string>(boost::any_cast<string>(m["IspType"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
  }


  virtual ~GetBasicIpSetResponseBody() = default;
};
class GetBasicIpSetResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetBasicIpSetResponseBody> body{};

  GetBasicIpSetResponse() {}

  explicit GetBasicIpSetResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetBasicIpSetResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetBasicIpSetResponseBody>(model1);
      }
    }
  }


  virtual ~GetBasicIpSetResponse() = default;
};
class GetHealthStatusRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceleratorId{};
  shared_ptr<string> clientToken{};
  shared_ptr<bool> dryRun{};
  shared_ptr<string> listenerId{};
  shared_ptr<string> regionId{};

  GetHealthStatusRequest() {}

  explicit GetHealthStatusRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceleratorId) {
      res["AcceleratorId"] = boost::any(*acceleratorId);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (dryRun) {
      res["DryRun"] = boost::any(*dryRun);
    }
    if (listenerId) {
      res["ListenerId"] = boost::any(*listenerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceleratorId") != m.end() && !m["AcceleratorId"].empty()) {
      acceleratorId = make_shared<string>(boost::any_cast<string>(m["AcceleratorId"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("DryRun") != m.end() && !m["DryRun"].empty()) {
      dryRun = make_shared<bool>(boost::any_cast<bool>(m["DryRun"]));
    }
    if (m.find("ListenerId") != m.end() && !m["ListenerId"].empty()) {
      listenerId = make_shared<string>(boost::any_cast<string>(m["ListenerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~GetHealthStatusRequest() = default;
};
class GetHealthStatusResponseBodyEndpointGroupsEndpoints : public Darabonba::Model {
public:
  shared_ptr<string> address{};
  shared_ptr<string> endpointId{};
  shared_ptr<string> healthDetail{};
  shared_ptr<string> healthStatus{};
  shared_ptr<long> port{};
  shared_ptr<string> type{};

  GetHealthStatusResponseBodyEndpointGroupsEndpoints() {}

  explicit GetHealthStatusResponseBodyEndpointGroupsEndpoints(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (address) {
      res["Address"] = boost::any(*address);
    }
    if (endpointId) {
      res["EndpointId"] = boost::any(*endpointId);
    }
    if (healthDetail) {
      res["HealthDetail"] = boost::any(*healthDetail);
    }
    if (healthStatus) {
      res["HealthStatus"] = boost::any(*healthStatus);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Address") != m.end() && !m["Address"].empty()) {
      address = make_shared<string>(boost::any_cast<string>(m["Address"]));
    }
    if (m.find("EndpointId") != m.end() && !m["EndpointId"].empty()) {
      endpointId = make_shared<string>(boost::any_cast<string>(m["EndpointId"]));
    }
    if (m.find("HealthDetail") != m.end() && !m["HealthDetail"].empty()) {
      healthDetail = make_shared<string>(boost::any_cast<string>(m["HealthDetail"]));
    }
    if (m.find("HealthStatus") != m.end() && !m["HealthStatus"].empty()) {
      healthStatus = make_shared<string>(boost::any_cast<string>(m["HealthStatus"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<long>(boost::any_cast<long>(m["Port"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~GetHealthStatusResponseBodyEndpointGroupsEndpoints() = default;
};
class GetHealthStatusResponseBodyEndpointGroups : public Darabonba::Model {
public:
  shared_ptr<string> endpointGroupId{};
  shared_ptr<string> endpointGroupType{};
  shared_ptr<vector<GetHealthStatusResponseBodyEndpointGroupsEndpoints>> endpoints{};
  shared_ptr<vector<string>> forwardingRuleIds{};
  shared_ptr<string> healthStatus{};

  GetHealthStatusResponseBodyEndpointGroups() {}

  explicit GetHealthStatusResponseBodyEndpointGroups(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endpointGroupId) {
      res["EndpointGroupId"] = boost::any(*endpointGroupId);
    }
    if (endpointGroupType) {
      res["EndpointGroupType"] = boost::any(*endpointGroupType);
    }
    if (endpoints) {
      vector<boost::any> temp1;
      for(auto item1:*endpoints){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Endpoints"] = boost::any(temp1);
    }
    if (forwardingRuleIds) {
      res["ForwardingRuleIds"] = boost::any(*forwardingRuleIds);
    }
    if (healthStatus) {
      res["HealthStatus"] = boost::any(*healthStatus);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndpointGroupId") != m.end() && !m["EndpointGroupId"].empty()) {
      endpointGroupId = make_shared<string>(boost::any_cast<string>(m["EndpointGroupId"]));
    }
    if (m.find("EndpointGroupType") != m.end() && !m["EndpointGroupType"].empty()) {
      endpointGroupType = make_shared<string>(boost::any_cast<string>(m["EndpointGroupType"]));
    }
    if (m.find("Endpoints") != m.end() && !m["Endpoints"].empty()) {
      if (typeid(vector<boost::any>) == m["Endpoints"].type()) {
        vector<GetHealthStatusResponseBodyEndpointGroupsEndpoints> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Endpoints"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetHealthStatusResponseBodyEndpointGroupsEndpoints model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        endpoints = make_shared<vector<GetHealthStatusResponseBodyEndpointGroupsEndpoints>>(expect1);
      }
    }
    if (m.find("ForwardingRuleIds") != m.end() && !m["ForwardingRuleIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ForwardingRuleIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ForwardingRuleIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      forwardingRuleIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("HealthStatus") != m.end() && !m["HealthStatus"].empty()) {
      healthStatus = make_shared<string>(boost::any_cast<string>(m["HealthStatus"]));
    }
  }


  virtual ~GetHealthStatusResponseBodyEndpointGroups() = default;
};
class GetHealthStatusResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<GetHealthStatusResponseBodyEndpointGroups>> endpointGroups{};
  shared_ptr<string> healthStatus{};
  shared_ptr<string> listenerId{};
  shared_ptr<string> requestId{};

  GetHealthStatusResponseBody() {}

  explicit GetHealthStatusResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endpointGroups) {
      vector<boost::any> temp1;
      for(auto item1:*endpointGroups){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["EndpointGroups"] = boost::any(temp1);
    }
    if (healthStatus) {
      res["HealthStatus"] = boost::any(*healthStatus);
    }
    if (listenerId) {
      res["ListenerId"] = boost::any(*listenerId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndpointGroups") != m.end() && !m["EndpointGroups"].empty()) {
      if (typeid(vector<boost::any>) == m["EndpointGroups"].type()) {
        vector<GetHealthStatusResponseBodyEndpointGroups> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["EndpointGroups"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetHealthStatusResponseBodyEndpointGroups model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        endpointGroups = make_shared<vector<GetHealthStatusResponseBodyEndpointGroups>>(expect1);
      }
    }
    if (m.find("HealthStatus") != m.end() && !m["HealthStatus"].empty()) {
      healthStatus = make_shared<string>(boost::any_cast<string>(m["HealthStatus"]));
    }
    if (m.find("ListenerId") != m.end() && !m["ListenerId"].empty()) {
      listenerId = make_shared<string>(boost::any_cast<string>(m["ListenerId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetHealthStatusResponseBody() = default;
};
class GetHealthStatusResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetHealthStatusResponseBody> body{};

  GetHealthStatusResponse() {}

  explicit GetHealthStatusResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetHealthStatusResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetHealthStatusResponseBody>(model1);
      }
    }
  }


  virtual ~GetHealthStatusResponse() = default;
};
class GetInvalidDomainCountRequest : public Darabonba::Model {
public:
  shared_ptr<string> regionId{};

  GetInvalidDomainCountRequest() {}

  explicit GetInvalidDomainCountRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~GetInvalidDomainCountRequest() = default;
};
class GetInvalidDomainCountResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> invalidDomainCount{};
  shared_ptr<string> requestId{};

  GetInvalidDomainCountResponseBody() {}

  explicit GetInvalidDomainCountResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (invalidDomainCount) {
      res["InvalidDomainCount"] = boost::any(*invalidDomainCount);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InvalidDomainCount") != m.end() && !m["InvalidDomainCount"].empty()) {
      invalidDomainCount = make_shared<string>(boost::any_cast<string>(m["InvalidDomainCount"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetInvalidDomainCountResponseBody() = default;
};
class GetInvalidDomainCountResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetInvalidDomainCountResponseBody> body{};

  GetInvalidDomainCountResponse() {}

  explicit GetInvalidDomainCountResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetInvalidDomainCountResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetInvalidDomainCountResponseBody>(model1);
      }
    }
  }


  virtual ~GetInvalidDomainCountResponse() = default;
};
class GetIpsetsBandwidthLimitRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceleratorId{};
  shared_ptr<string> regionId{};

  GetIpsetsBandwidthLimitRequest() {}

  explicit GetIpsetsBandwidthLimitRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceleratorId) {
      res["AcceleratorId"] = boost::any(*acceleratorId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceleratorId") != m.end() && !m["AcceleratorId"].empty()) {
      acceleratorId = make_shared<string>(boost::any_cast<string>(m["AcceleratorId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~GetIpsetsBandwidthLimitRequest() = default;
};
class GetIpsetsBandwidthLimitResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> bandwidthAllocationType{};
  shared_ptr<long> bandwidthLimit{};
  shared_ptr<string> requestId{};

  GetIpsetsBandwidthLimitResponseBody() {}

  explicit GetIpsetsBandwidthLimitResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bandwidthAllocationType) {
      res["BandwidthAllocationType"] = boost::any(*bandwidthAllocationType);
    }
    if (bandwidthLimit) {
      res["BandwidthLimit"] = boost::any(*bandwidthLimit);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BandwidthAllocationType") != m.end() && !m["BandwidthAllocationType"].empty()) {
      bandwidthAllocationType = make_shared<string>(boost::any_cast<string>(m["BandwidthAllocationType"]));
    }
    if (m.find("BandwidthLimit") != m.end() && !m["BandwidthLimit"].empty()) {
      bandwidthLimit = make_shared<long>(boost::any_cast<long>(m["BandwidthLimit"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetIpsetsBandwidthLimitResponseBody() = default;
};
class GetIpsetsBandwidthLimitResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetIpsetsBandwidthLimitResponseBody> body{};

  GetIpsetsBandwidthLimitResponse() {}

  explicit GetIpsetsBandwidthLimitResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetIpsetsBandwidthLimitResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetIpsetsBandwidthLimitResponseBody>(model1);
      }
    }
  }


  virtual ~GetIpsetsBandwidthLimitResponse() = default;
};
class GetSpareIpRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceleratorId{};
  shared_ptr<string> clientToken{};
  shared_ptr<bool> dryRun{};
  shared_ptr<string> regionId{};
  shared_ptr<string> spareIp{};

  GetSpareIpRequest() {}

  explicit GetSpareIpRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceleratorId) {
      res["AcceleratorId"] = boost::any(*acceleratorId);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (dryRun) {
      res["DryRun"] = boost::any(*dryRun);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (spareIp) {
      res["SpareIp"] = boost::any(*spareIp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceleratorId") != m.end() && !m["AcceleratorId"].empty()) {
      acceleratorId = make_shared<string>(boost::any_cast<string>(m["AcceleratorId"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("DryRun") != m.end() && !m["DryRun"].empty()) {
      dryRun = make_shared<bool>(boost::any_cast<bool>(m["DryRun"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SpareIp") != m.end() && !m["SpareIp"].empty()) {
      spareIp = make_shared<string>(boost::any_cast<string>(m["SpareIp"]));
    }
  }


  virtual ~GetSpareIpRequest() = default;
};
class GetSpareIpResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> state{};

  GetSpareIpResponseBody() {}

  explicit GetSpareIpResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
  }


  virtual ~GetSpareIpResponseBody() = default;
};
class GetSpareIpResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetSpareIpResponseBody> body{};

  GetSpareIpResponse() {}

  explicit GetSpareIpResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetSpareIpResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetSpareIpResponseBody>(model1);
      }
    }
  }


  virtual ~GetSpareIpResponse() = default;
};
class ListAccelerateAreasRequest : public Darabonba::Model {
public:
  shared_ptr<string> regionId{};

  ListAccelerateAreasRequest() {}

  explicit ListAccelerateAreasRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~ListAccelerateAreasRequest() = default;
};
class ListAccelerateAreasResponseBodyAreasRegionList : public Darabonba::Model {
public:
  shared_ptr<string> localName{};
  shared_ptr<string> regionId{};

  ListAccelerateAreasResponseBodyAreasRegionList() {}

  explicit ListAccelerateAreasResponseBodyAreasRegionList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (localName) {
      res["LocalName"] = boost::any(*localName);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LocalName") != m.end() && !m["LocalName"].empty()) {
      localName = make_shared<string>(boost::any_cast<string>(m["LocalName"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~ListAccelerateAreasResponseBodyAreasRegionList() = default;
};
class ListAccelerateAreasResponseBodyAreas : public Darabonba::Model {
public:
  shared_ptr<string> areaId{};
  shared_ptr<string> localName{};
  shared_ptr<vector<ListAccelerateAreasResponseBodyAreasRegionList>> regionList{};

  ListAccelerateAreasResponseBodyAreas() {}

  explicit ListAccelerateAreasResponseBodyAreas(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (areaId) {
      res["AreaId"] = boost::any(*areaId);
    }
    if (localName) {
      res["LocalName"] = boost::any(*localName);
    }
    if (regionList) {
      vector<boost::any> temp1;
      for(auto item1:*regionList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RegionList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AreaId") != m.end() && !m["AreaId"].empty()) {
      areaId = make_shared<string>(boost::any_cast<string>(m["AreaId"]));
    }
    if (m.find("LocalName") != m.end() && !m["LocalName"].empty()) {
      localName = make_shared<string>(boost::any_cast<string>(m["LocalName"]));
    }
    if (m.find("RegionList") != m.end() && !m["RegionList"].empty()) {
      if (typeid(vector<boost::any>) == m["RegionList"].type()) {
        vector<ListAccelerateAreasResponseBodyAreasRegionList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RegionList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListAccelerateAreasResponseBodyAreasRegionList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        regionList = make_shared<vector<ListAccelerateAreasResponseBodyAreasRegionList>>(expect1);
      }
    }
  }


  virtual ~ListAccelerateAreasResponseBodyAreas() = default;
};
class ListAccelerateAreasResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListAccelerateAreasResponseBodyAreas>> areas{};
  shared_ptr<string> requestId{};

  ListAccelerateAreasResponseBody() {}

  explicit ListAccelerateAreasResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (areas) {
      vector<boost::any> temp1;
      for(auto item1:*areas){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Areas"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Areas") != m.end() && !m["Areas"].empty()) {
      if (typeid(vector<boost::any>) == m["Areas"].type()) {
        vector<ListAccelerateAreasResponseBodyAreas> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Areas"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListAccelerateAreasResponseBodyAreas model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        areas = make_shared<vector<ListAccelerateAreasResponseBodyAreas>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListAccelerateAreasResponseBody() = default;
};
class ListAccelerateAreasResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListAccelerateAreasResponseBody> body{};

  ListAccelerateAreasResponse() {}

  explicit ListAccelerateAreasResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListAccelerateAreasResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListAccelerateAreasResponseBody>(model1);
      }
    }
  }


  virtual ~ListAccelerateAreasResponse() = default;
};
class ListAcceleratorsRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  ListAcceleratorsRequestTag() {}

  explicit ListAcceleratorsRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~ListAcceleratorsRequestTag() = default;
};
class ListAcceleratorsRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceleratorId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> state{};
  shared_ptr<vector<ListAcceleratorsRequestTag>> tag{};

  ListAcceleratorsRequest() {}

  explicit ListAcceleratorsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceleratorId) {
      res["AcceleratorId"] = boost::any(*acceleratorId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceleratorId") != m.end() && !m["AcceleratorId"].empty()) {
      acceleratorId = make_shared<string>(boost::any_cast<string>(m["AcceleratorId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<ListAcceleratorsRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListAcceleratorsRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<ListAcceleratorsRequestTag>>(expect1);
      }
    }
  }


  virtual ~ListAcceleratorsRequest() = default;
};
class ListAcceleratorsResponseBodyAcceleratorsBasicBandwidthPackage : public Darabonba::Model {
public:
  shared_ptr<long> bandwidth{};
  shared_ptr<string> bandwidthType{};
  shared_ptr<string> instanceId{};

  ListAcceleratorsResponseBodyAcceleratorsBasicBandwidthPackage() {}

  explicit ListAcceleratorsResponseBodyAcceleratorsBasicBandwidthPackage(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bandwidth) {
      res["Bandwidth"] = boost::any(*bandwidth);
    }
    if (bandwidthType) {
      res["BandwidthType"] = boost::any(*bandwidthType);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bandwidth") != m.end() && !m["Bandwidth"].empty()) {
      bandwidth = make_shared<long>(boost::any_cast<long>(m["Bandwidth"]));
    }
    if (m.find("BandwidthType") != m.end() && !m["BandwidthType"].empty()) {
      bandwidthType = make_shared<string>(boost::any_cast<string>(m["BandwidthType"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~ListAcceleratorsResponseBodyAcceleratorsBasicBandwidthPackage() = default;
};
class ListAcceleratorsResponseBodyAcceleratorsCrossDomainBandwidthPackage : public Darabonba::Model {
public:
  shared_ptr<long> bandwidth{};
  shared_ptr<string> instanceId{};

  ListAcceleratorsResponseBodyAcceleratorsCrossDomainBandwidthPackage() {}

  explicit ListAcceleratorsResponseBodyAcceleratorsCrossDomainBandwidthPackage(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bandwidth) {
      res["Bandwidth"] = boost::any(*bandwidth);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bandwidth") != m.end() && !m["Bandwidth"].empty()) {
      bandwidth = make_shared<long>(boost::any_cast<long>(m["Bandwidth"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~ListAcceleratorsResponseBodyAcceleratorsCrossDomainBandwidthPackage() = default;
};
class ListAcceleratorsResponseBodyAcceleratorsIpSetConfig : public Darabonba::Model {
public:
  shared_ptr<string> accessMode{};

  ListAcceleratorsResponseBodyAcceleratorsIpSetConfig() {}

  explicit ListAcceleratorsResponseBodyAcceleratorsIpSetConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessMode) {
      res["AccessMode"] = boost::any(*accessMode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccessMode") != m.end() && !m["AccessMode"].empty()) {
      accessMode = make_shared<string>(boost::any_cast<string>(m["AccessMode"]));
    }
  }


  virtual ~ListAcceleratorsResponseBodyAcceleratorsIpSetConfig() = default;
};
class ListAcceleratorsResponseBodyAcceleratorsTags : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  ListAcceleratorsResponseBodyAcceleratorsTags() {}

  explicit ListAcceleratorsResponseBodyAcceleratorsTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~ListAcceleratorsResponseBodyAcceleratorsTags() = default;
};
class ListAcceleratorsResponseBodyAccelerators : public Darabonba::Model {
public:
  shared_ptr<string> acceleratorId{};
  shared_ptr<long> bandwidth{};
  shared_ptr<string> bandwidthBillingType{};
  shared_ptr<ListAcceleratorsResponseBodyAcceleratorsBasicBandwidthPackage> basicBandwidthPackage{};
  shared_ptr<string> cenId{};
  shared_ptr<long> createTime{};
  shared_ptr<string> crossBorderMode{};
  shared_ptr<bool> crossBorderStatus{};
  shared_ptr<ListAcceleratorsResponseBodyAcceleratorsCrossDomainBandwidthPackage> crossDomainBandwidthPackage{};
  shared_ptr<string> ddosId{};
  shared_ptr<string> description{};
  shared_ptr<string> dnsName{};
  shared_ptr<long> expiredTime{};
  shared_ptr<string> instanceChargeType{};
  shared_ptr<ListAcceleratorsResponseBodyAcceleratorsIpSetConfig> ipSetConfig{};
  shared_ptr<string> name{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> secondDnsName{};
  shared_ptr<string> spec{};
  shared_ptr<string> state{};
  shared_ptr<vector<ListAcceleratorsResponseBodyAcceleratorsTags>> tags{};
  shared_ptr<string> type{};

  ListAcceleratorsResponseBodyAccelerators() {}

  explicit ListAcceleratorsResponseBodyAccelerators(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceleratorId) {
      res["AcceleratorId"] = boost::any(*acceleratorId);
    }
    if (bandwidth) {
      res["Bandwidth"] = boost::any(*bandwidth);
    }
    if (bandwidthBillingType) {
      res["BandwidthBillingType"] = boost::any(*bandwidthBillingType);
    }
    if (basicBandwidthPackage) {
      res["BasicBandwidthPackage"] = basicBandwidthPackage ? boost::any(basicBandwidthPackage->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (cenId) {
      res["CenId"] = boost::any(*cenId);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (crossBorderMode) {
      res["CrossBorderMode"] = boost::any(*crossBorderMode);
    }
    if (crossBorderStatus) {
      res["CrossBorderStatus"] = boost::any(*crossBorderStatus);
    }
    if (crossDomainBandwidthPackage) {
      res["CrossDomainBandwidthPackage"] = crossDomainBandwidthPackage ? boost::any(crossDomainBandwidthPackage->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (ddosId) {
      res["DdosId"] = boost::any(*ddosId);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (dnsName) {
      res["DnsName"] = boost::any(*dnsName);
    }
    if (expiredTime) {
      res["ExpiredTime"] = boost::any(*expiredTime);
    }
    if (instanceChargeType) {
      res["InstanceChargeType"] = boost::any(*instanceChargeType);
    }
    if (ipSetConfig) {
      res["IpSetConfig"] = ipSetConfig ? boost::any(ipSetConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (secondDnsName) {
      res["SecondDnsName"] = boost::any(*secondDnsName);
    }
    if (spec) {
      res["Spec"] = boost::any(*spec);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tags"] = boost::any(temp1);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceleratorId") != m.end() && !m["AcceleratorId"].empty()) {
      acceleratorId = make_shared<string>(boost::any_cast<string>(m["AcceleratorId"]));
    }
    if (m.find("Bandwidth") != m.end() && !m["Bandwidth"].empty()) {
      bandwidth = make_shared<long>(boost::any_cast<long>(m["Bandwidth"]));
    }
    if (m.find("BandwidthBillingType") != m.end() && !m["BandwidthBillingType"].empty()) {
      bandwidthBillingType = make_shared<string>(boost::any_cast<string>(m["BandwidthBillingType"]));
    }
    if (m.find("BasicBandwidthPackage") != m.end() && !m["BasicBandwidthPackage"].empty()) {
      if (typeid(map<string, boost::any>) == m["BasicBandwidthPackage"].type()) {
        ListAcceleratorsResponseBodyAcceleratorsBasicBandwidthPackage model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["BasicBandwidthPackage"]));
        basicBandwidthPackage = make_shared<ListAcceleratorsResponseBodyAcceleratorsBasicBandwidthPackage>(model1);
      }
    }
    if (m.find("CenId") != m.end() && !m["CenId"].empty()) {
      cenId = make_shared<string>(boost::any_cast<string>(m["CenId"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("CrossBorderMode") != m.end() && !m["CrossBorderMode"].empty()) {
      crossBorderMode = make_shared<string>(boost::any_cast<string>(m["CrossBorderMode"]));
    }
    if (m.find("CrossBorderStatus") != m.end() && !m["CrossBorderStatus"].empty()) {
      crossBorderStatus = make_shared<bool>(boost::any_cast<bool>(m["CrossBorderStatus"]));
    }
    if (m.find("CrossDomainBandwidthPackage") != m.end() && !m["CrossDomainBandwidthPackage"].empty()) {
      if (typeid(map<string, boost::any>) == m["CrossDomainBandwidthPackage"].type()) {
        ListAcceleratorsResponseBodyAcceleratorsCrossDomainBandwidthPackage model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CrossDomainBandwidthPackage"]));
        crossDomainBandwidthPackage = make_shared<ListAcceleratorsResponseBodyAcceleratorsCrossDomainBandwidthPackage>(model1);
      }
    }
    if (m.find("DdosId") != m.end() && !m["DdosId"].empty()) {
      ddosId = make_shared<string>(boost::any_cast<string>(m["DdosId"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DnsName") != m.end() && !m["DnsName"].empty()) {
      dnsName = make_shared<string>(boost::any_cast<string>(m["DnsName"]));
    }
    if (m.find("ExpiredTime") != m.end() && !m["ExpiredTime"].empty()) {
      expiredTime = make_shared<long>(boost::any_cast<long>(m["ExpiredTime"]));
    }
    if (m.find("InstanceChargeType") != m.end() && !m["InstanceChargeType"].empty()) {
      instanceChargeType = make_shared<string>(boost::any_cast<string>(m["InstanceChargeType"]));
    }
    if (m.find("IpSetConfig") != m.end() && !m["IpSetConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["IpSetConfig"].type()) {
        ListAcceleratorsResponseBodyAcceleratorsIpSetConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["IpSetConfig"]));
        ipSetConfig = make_shared<ListAcceleratorsResponseBodyAcceleratorsIpSetConfig>(model1);
      }
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("SecondDnsName") != m.end() && !m["SecondDnsName"].empty()) {
      secondDnsName = make_shared<string>(boost::any_cast<string>(m["SecondDnsName"]));
    }
    if (m.find("Spec") != m.end() && !m["Spec"].empty()) {
      spec = make_shared<string>(boost::any_cast<string>(m["Spec"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(vector<boost::any>) == m["Tags"].type()) {
        vector<ListAcceleratorsResponseBodyAcceleratorsTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListAcceleratorsResponseBodyAcceleratorsTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<ListAcceleratorsResponseBodyAcceleratorsTags>>(expect1);
      }
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListAcceleratorsResponseBodyAccelerators() = default;
};
class ListAcceleratorsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListAcceleratorsResponseBodyAccelerators>> accelerators{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  ListAcceleratorsResponseBody() {}

  explicit ListAcceleratorsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accelerators) {
      vector<boost::any> temp1;
      for(auto item1:*accelerators){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Accelerators"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Accelerators") != m.end() && !m["Accelerators"].empty()) {
      if (typeid(vector<boost::any>) == m["Accelerators"].type()) {
        vector<ListAcceleratorsResponseBodyAccelerators> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Accelerators"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListAcceleratorsResponseBodyAccelerators model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        accelerators = make_shared<vector<ListAcceleratorsResponseBodyAccelerators>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListAcceleratorsResponseBody() = default;
};
class ListAcceleratorsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListAcceleratorsResponseBody> body{};

  ListAcceleratorsResponse() {}

  explicit ListAcceleratorsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListAcceleratorsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListAcceleratorsResponseBody>(model1);
      }
    }
  }


  virtual ~ListAcceleratorsResponse() = default;
};
class ListAclsRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  ListAclsRequestTag() {}

  explicit ListAclsRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~ListAclsRequestTag() = default;
};
class ListAclsRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> aclIds{};
  shared_ptr<string> aclName{};
  shared_ptr<string> clientToken{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<vector<ListAclsRequestTag>> tag{};

  ListAclsRequest() {}

  explicit ListAclsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aclIds) {
      res["AclIds"] = boost::any(*aclIds);
    }
    if (aclName) {
      res["AclName"] = boost::any(*aclName);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AclIds") != m.end() && !m["AclIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["AclIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["AclIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      aclIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("AclName") != m.end() && !m["AclName"].empty()) {
      aclName = make_shared<string>(boost::any_cast<string>(m["AclName"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<ListAclsRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListAclsRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<ListAclsRequestTag>>(expect1);
      }
    }
  }


  virtual ~ListAclsRequest() = default;
};
class ListAclsResponseBodyAclsTags : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  ListAclsResponseBodyAclsTags() {}

  explicit ListAclsResponseBodyAclsTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~ListAclsResponseBodyAclsTags() = default;
};
class ListAclsResponseBodyAcls : public Darabonba::Model {
public:
  shared_ptr<string> aclId{};
  shared_ptr<string> aclName{};
  shared_ptr<string> aclStatus{};
  shared_ptr<string> addressIPVersion{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<vector<ListAclsResponseBodyAclsTags>> tags{};

  ListAclsResponseBodyAcls() {}

  explicit ListAclsResponseBodyAcls(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aclId) {
      res["AclId"] = boost::any(*aclId);
    }
    if (aclName) {
      res["AclName"] = boost::any(*aclName);
    }
    if (aclStatus) {
      res["AclStatus"] = boost::any(*aclStatus);
    }
    if (addressIPVersion) {
      res["AddressIPVersion"] = boost::any(*addressIPVersion);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tags"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AclId") != m.end() && !m["AclId"].empty()) {
      aclId = make_shared<string>(boost::any_cast<string>(m["AclId"]));
    }
    if (m.find("AclName") != m.end() && !m["AclName"].empty()) {
      aclName = make_shared<string>(boost::any_cast<string>(m["AclName"]));
    }
    if (m.find("AclStatus") != m.end() && !m["AclStatus"].empty()) {
      aclStatus = make_shared<string>(boost::any_cast<string>(m["AclStatus"]));
    }
    if (m.find("AddressIPVersion") != m.end() && !m["AddressIPVersion"].empty()) {
      addressIPVersion = make_shared<string>(boost::any_cast<string>(m["AddressIPVersion"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(vector<boost::any>) == m["Tags"].type()) {
        vector<ListAclsResponseBodyAclsTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListAclsResponseBodyAclsTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<ListAclsResponseBodyAclsTags>>(expect1);
      }
    }
  }


  virtual ~ListAclsResponseBodyAcls() = default;
};
class ListAclsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListAclsResponseBodyAcls>> acls{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  ListAclsResponseBody() {}

  explicit ListAclsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acls) {
      vector<boost::any> temp1;
      for(auto item1:*acls){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Acls"] = boost::any(temp1);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Acls") != m.end() && !m["Acls"].empty()) {
      if (typeid(vector<boost::any>) == m["Acls"].type()) {
        vector<ListAclsResponseBodyAcls> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Acls"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListAclsResponseBodyAcls model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        acls = make_shared<vector<ListAclsResponseBodyAcls>>(expect1);
      }
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListAclsResponseBody() = default;
};
class ListAclsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListAclsResponseBody> body{};

  ListAclsResponse() {}

  explicit ListAclsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListAclsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListAclsResponseBody>(model1);
      }
    }
  }


  virtual ~ListAclsResponse() = default;
};
class ListApplicationMonitorRequest : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regionId{};
  shared_ptr<string> searchValue{};

  ListApplicationMonitorRequest() {}

  explicit ListApplicationMonitorRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (searchValue) {
      res["SearchValue"] = boost::any(*searchValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SearchValue") != m.end() && !m["SearchValue"].empty()) {
      searchValue = make_shared<string>(boost::any_cast<string>(m["SearchValue"]));
    }
  }


  virtual ~ListApplicationMonitorRequest() = default;
};
class ListApplicationMonitorResponseBodyApplicationMonitors : public Darabonba::Model {
public:
  shared_ptr<string> acceleratorId{};
  shared_ptr<string> address{};
  shared_ptr<bool> detectEnable{};
  shared_ptr<long> detectThreshold{};
  shared_ptr<long> detectTimes{};
  shared_ptr<string> listenerId{};
  shared_ptr<string> optionsJson{};
  shared_ptr<long> silenceTime{};
  shared_ptr<string> state{};
  shared_ptr<string> taskId{};
  shared_ptr<string> taskName{};

  ListApplicationMonitorResponseBodyApplicationMonitors() {}

  explicit ListApplicationMonitorResponseBodyApplicationMonitors(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceleratorId) {
      res["AcceleratorId"] = boost::any(*acceleratorId);
    }
    if (address) {
      res["Address"] = boost::any(*address);
    }
    if (detectEnable) {
      res["DetectEnable"] = boost::any(*detectEnable);
    }
    if (detectThreshold) {
      res["DetectThreshold"] = boost::any(*detectThreshold);
    }
    if (detectTimes) {
      res["DetectTimes"] = boost::any(*detectTimes);
    }
    if (listenerId) {
      res["ListenerId"] = boost::any(*listenerId);
    }
    if (optionsJson) {
      res["OptionsJson"] = boost::any(*optionsJson);
    }
    if (silenceTime) {
      res["SilenceTime"] = boost::any(*silenceTime);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (taskName) {
      res["TaskName"] = boost::any(*taskName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceleratorId") != m.end() && !m["AcceleratorId"].empty()) {
      acceleratorId = make_shared<string>(boost::any_cast<string>(m["AcceleratorId"]));
    }
    if (m.find("Address") != m.end() && !m["Address"].empty()) {
      address = make_shared<string>(boost::any_cast<string>(m["Address"]));
    }
    if (m.find("DetectEnable") != m.end() && !m["DetectEnable"].empty()) {
      detectEnable = make_shared<bool>(boost::any_cast<bool>(m["DetectEnable"]));
    }
    if (m.find("DetectThreshold") != m.end() && !m["DetectThreshold"].empty()) {
      detectThreshold = make_shared<long>(boost::any_cast<long>(m["DetectThreshold"]));
    }
    if (m.find("DetectTimes") != m.end() && !m["DetectTimes"].empty()) {
      detectTimes = make_shared<long>(boost::any_cast<long>(m["DetectTimes"]));
    }
    if (m.find("ListenerId") != m.end() && !m["ListenerId"].empty()) {
      listenerId = make_shared<string>(boost::any_cast<string>(m["ListenerId"]));
    }
    if (m.find("OptionsJson") != m.end() && !m["OptionsJson"].empty()) {
      optionsJson = make_shared<string>(boost::any_cast<string>(m["OptionsJson"]));
    }
    if (m.find("SilenceTime") != m.end() && !m["SilenceTime"].empty()) {
      silenceTime = make_shared<long>(boost::any_cast<long>(m["SilenceTime"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("TaskName") != m.end() && !m["TaskName"].empty()) {
      taskName = make_shared<string>(boost::any_cast<string>(m["TaskName"]));
    }
  }


  virtual ~ListApplicationMonitorResponseBodyApplicationMonitors() = default;
};
class ListApplicationMonitorResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListApplicationMonitorResponseBodyApplicationMonitors>> applicationMonitors{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  ListApplicationMonitorResponseBody() {}

  explicit ListApplicationMonitorResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applicationMonitors) {
      vector<boost::any> temp1;
      for(auto item1:*applicationMonitors){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ApplicationMonitors"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApplicationMonitors") != m.end() && !m["ApplicationMonitors"].empty()) {
      if (typeid(vector<boost::any>) == m["ApplicationMonitors"].type()) {
        vector<ListApplicationMonitorResponseBodyApplicationMonitors> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ApplicationMonitors"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListApplicationMonitorResponseBodyApplicationMonitors model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        applicationMonitors = make_shared<vector<ListApplicationMonitorResponseBodyApplicationMonitors>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListApplicationMonitorResponseBody() = default;
};
class ListApplicationMonitorResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListApplicationMonitorResponseBody> body{};

  ListApplicationMonitorResponse() {}

  explicit ListApplicationMonitorResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListApplicationMonitorResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListApplicationMonitorResponseBody>(model1);
      }
    }
  }


  virtual ~ListApplicationMonitorResponse() = default;
};
class ListApplicationMonitorDetectResultRequest : public Darabonba::Model {
public:
  shared_ptr<long> beginTime{};
  shared_ptr<long> endTime{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regionId{};
  shared_ptr<string> taskId{};

  ListApplicationMonitorDetectResultRequest() {}

  explicit ListApplicationMonitorDetectResultRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (beginTime) {
      res["BeginTime"] = boost::any(*beginTime);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BeginTime") != m.end() && !m["BeginTime"].empty()) {
      beginTime = make_shared<long>(boost::any_cast<long>(m["BeginTime"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
  }


  virtual ~ListApplicationMonitorDetectResultRequest() = default;
};
class ListApplicationMonitorDetectResultResponseBodyApplicationMonitorDetectResultList : public Darabonba::Model {
public:
  shared_ptr<string> acceleratorId{};
  shared_ptr<string> content{};
  shared_ptr<string> detail{};
  shared_ptr<string> detectTime{};
  shared_ptr<string> diagStatus{};
  shared_ptr<string> listenerId{};
  shared_ptr<string> port{};
  shared_ptr<string> protocol{};
  shared_ptr<string> statusCode{};
  shared_ptr<string> taskId{};

  ListApplicationMonitorDetectResultResponseBodyApplicationMonitorDetectResultList() {}

  explicit ListApplicationMonitorDetectResultResponseBodyApplicationMonitorDetectResultList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceleratorId) {
      res["AcceleratorId"] = boost::any(*acceleratorId);
    }
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (detail) {
      res["Detail"] = boost::any(*detail);
    }
    if (detectTime) {
      res["DetectTime"] = boost::any(*detectTime);
    }
    if (diagStatus) {
      res["DiagStatus"] = boost::any(*diagStatus);
    }
    if (listenerId) {
      res["ListenerId"] = boost::any(*listenerId);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (protocol) {
      res["Protocol"] = boost::any(*protocol);
    }
    if (statusCode) {
      res["StatusCode"] = boost::any(*statusCode);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceleratorId") != m.end() && !m["AcceleratorId"].empty()) {
      acceleratorId = make_shared<string>(boost::any_cast<string>(m["AcceleratorId"]));
    }
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("Detail") != m.end() && !m["Detail"].empty()) {
      detail = make_shared<string>(boost::any_cast<string>(m["Detail"]));
    }
    if (m.find("DetectTime") != m.end() && !m["DetectTime"].empty()) {
      detectTime = make_shared<string>(boost::any_cast<string>(m["DetectTime"]));
    }
    if (m.find("DiagStatus") != m.end() && !m["DiagStatus"].empty()) {
      diagStatus = make_shared<string>(boost::any_cast<string>(m["DiagStatus"]));
    }
    if (m.find("ListenerId") != m.end() && !m["ListenerId"].empty()) {
      listenerId = make_shared<string>(boost::any_cast<string>(m["ListenerId"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<string>(boost::any_cast<string>(m["Port"]));
    }
    if (m.find("Protocol") != m.end() && !m["Protocol"].empty()) {
      protocol = make_shared<string>(boost::any_cast<string>(m["Protocol"]));
    }
    if (m.find("StatusCode") != m.end() && !m["StatusCode"].empty()) {
      statusCode = make_shared<string>(boost::any_cast<string>(m["StatusCode"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
  }


  virtual ~ListApplicationMonitorDetectResultResponseBodyApplicationMonitorDetectResultList() = default;
};
class ListApplicationMonitorDetectResultResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListApplicationMonitorDetectResultResponseBodyApplicationMonitorDetectResultList>> applicationMonitorDetectResultList{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  ListApplicationMonitorDetectResultResponseBody() {}

  explicit ListApplicationMonitorDetectResultResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applicationMonitorDetectResultList) {
      vector<boost::any> temp1;
      for(auto item1:*applicationMonitorDetectResultList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ApplicationMonitorDetectResultList"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApplicationMonitorDetectResultList") != m.end() && !m["ApplicationMonitorDetectResultList"].empty()) {
      if (typeid(vector<boost::any>) == m["ApplicationMonitorDetectResultList"].type()) {
        vector<ListApplicationMonitorDetectResultResponseBodyApplicationMonitorDetectResultList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ApplicationMonitorDetectResultList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListApplicationMonitorDetectResultResponseBodyApplicationMonitorDetectResultList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        applicationMonitorDetectResultList = make_shared<vector<ListApplicationMonitorDetectResultResponseBodyApplicationMonitorDetectResultList>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListApplicationMonitorDetectResultResponseBody() = default;
};
class ListApplicationMonitorDetectResultResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListApplicationMonitorDetectResultResponseBody> body{};

  ListApplicationMonitorDetectResultResponse() {}

  explicit ListApplicationMonitorDetectResultResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListApplicationMonitorDetectResultResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListApplicationMonitorDetectResultResponseBody>(model1);
      }
    }
  }


  virtual ~ListApplicationMonitorDetectResultResponse() = default;
};
class ListAvailableAccelerateAreasRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceleratorId{};
  shared_ptr<string> regionId{};

  ListAvailableAccelerateAreasRequest() {}

  explicit ListAvailableAccelerateAreasRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceleratorId) {
      res["AcceleratorId"] = boost::any(*acceleratorId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceleratorId") != m.end() && !m["AcceleratorId"].empty()) {
      acceleratorId = make_shared<string>(boost::any_cast<string>(m["AcceleratorId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~ListAvailableAccelerateAreasRequest() = default;
};
class ListAvailableAccelerateAreasResponseBodyAreasRegionList : public Darabonba::Model {
public:
  shared_ptr<string> localName{};
  shared_ptr<string> regionId{};

  ListAvailableAccelerateAreasResponseBodyAreasRegionList() {}

  explicit ListAvailableAccelerateAreasResponseBodyAreasRegionList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (localName) {
      res["LocalName"] = boost::any(*localName);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LocalName") != m.end() && !m["LocalName"].empty()) {
      localName = make_shared<string>(boost::any_cast<string>(m["LocalName"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~ListAvailableAccelerateAreasResponseBodyAreasRegionList() = default;
};
class ListAvailableAccelerateAreasResponseBodyAreas : public Darabonba::Model {
public:
  shared_ptr<string> areaId{};
  shared_ptr<string> localName{};
  shared_ptr<vector<ListAvailableAccelerateAreasResponseBodyAreasRegionList>> regionList{};

  ListAvailableAccelerateAreasResponseBodyAreas() {}

  explicit ListAvailableAccelerateAreasResponseBodyAreas(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (areaId) {
      res["AreaId"] = boost::any(*areaId);
    }
    if (localName) {
      res["LocalName"] = boost::any(*localName);
    }
    if (regionList) {
      vector<boost::any> temp1;
      for(auto item1:*regionList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RegionList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AreaId") != m.end() && !m["AreaId"].empty()) {
      areaId = make_shared<string>(boost::any_cast<string>(m["AreaId"]));
    }
    if (m.find("LocalName") != m.end() && !m["LocalName"].empty()) {
      localName = make_shared<string>(boost::any_cast<string>(m["LocalName"]));
    }
    if (m.find("RegionList") != m.end() && !m["RegionList"].empty()) {
      if (typeid(vector<boost::any>) == m["RegionList"].type()) {
        vector<ListAvailableAccelerateAreasResponseBodyAreasRegionList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RegionList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListAvailableAccelerateAreasResponseBodyAreasRegionList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        regionList = make_shared<vector<ListAvailableAccelerateAreasResponseBodyAreasRegionList>>(expect1);
      }
    }
  }


  virtual ~ListAvailableAccelerateAreasResponseBodyAreas() = default;
};
class ListAvailableAccelerateAreasResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListAvailableAccelerateAreasResponseBodyAreas>> areas{};
  shared_ptr<string> requestId{};

  ListAvailableAccelerateAreasResponseBody() {}

  explicit ListAvailableAccelerateAreasResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (areas) {
      vector<boost::any> temp1;
      for(auto item1:*areas){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Areas"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Areas") != m.end() && !m["Areas"].empty()) {
      if (typeid(vector<boost::any>) == m["Areas"].type()) {
        vector<ListAvailableAccelerateAreasResponseBodyAreas> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Areas"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListAvailableAccelerateAreasResponseBodyAreas model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        areas = make_shared<vector<ListAvailableAccelerateAreasResponseBodyAreas>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListAvailableAccelerateAreasResponseBody() = default;
};
class ListAvailableAccelerateAreasResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListAvailableAccelerateAreasResponseBody> body{};

  ListAvailableAccelerateAreasResponse() {}

  explicit ListAvailableAccelerateAreasResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListAvailableAccelerateAreasResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListAvailableAccelerateAreasResponseBody>(model1);
      }
    }
  }


  virtual ~ListAvailableAccelerateAreasResponse() = default;
};
class ListAvailableBusiRegionsRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceleratorId{};
  shared_ptr<string> regionId{};

  ListAvailableBusiRegionsRequest() {}

  explicit ListAvailableBusiRegionsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceleratorId) {
      res["AcceleratorId"] = boost::any(*acceleratorId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceleratorId") != m.end() && !m["AcceleratorId"].empty()) {
      acceleratorId = make_shared<string>(boost::any_cast<string>(m["AcceleratorId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~ListAvailableBusiRegionsRequest() = default;
};
class ListAvailableBusiRegionsResponseBodyRegions : public Darabonba::Model {
public:
  shared_ptr<string> localName{};
  shared_ptr<bool> pop{};
  shared_ptr<string> regionId{};

  ListAvailableBusiRegionsResponseBodyRegions() {}

  explicit ListAvailableBusiRegionsResponseBodyRegions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (localName) {
      res["LocalName"] = boost::any(*localName);
    }
    if (pop) {
      res["Pop"] = boost::any(*pop);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LocalName") != m.end() && !m["LocalName"].empty()) {
      localName = make_shared<string>(boost::any_cast<string>(m["LocalName"]));
    }
    if (m.find("Pop") != m.end() && !m["Pop"].empty()) {
      pop = make_shared<bool>(boost::any_cast<bool>(m["Pop"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~ListAvailableBusiRegionsResponseBodyRegions() = default;
};
class ListAvailableBusiRegionsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListAvailableBusiRegionsResponseBodyRegions>> regions{};
  shared_ptr<string> requestId{};

  ListAvailableBusiRegionsResponseBody() {}

  explicit ListAvailableBusiRegionsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (regions) {
      vector<boost::any> temp1;
      for(auto item1:*regions){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Regions"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Regions") != m.end() && !m["Regions"].empty()) {
      if (typeid(vector<boost::any>) == m["Regions"].type()) {
        vector<ListAvailableBusiRegionsResponseBodyRegions> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Regions"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListAvailableBusiRegionsResponseBodyRegions model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        regions = make_shared<vector<ListAvailableBusiRegionsResponseBodyRegions>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListAvailableBusiRegionsResponseBody() = default;
};
class ListAvailableBusiRegionsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListAvailableBusiRegionsResponseBody> body{};

  ListAvailableBusiRegionsResponse() {}

  explicit ListAvailableBusiRegionsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListAvailableBusiRegionsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListAvailableBusiRegionsResponseBody>(model1);
      }
    }
  }


  virtual ~ListAvailableBusiRegionsResponse() = default;
};
class ListBandwidthPackagesRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  ListBandwidthPackagesRequestTag() {}

  explicit ListBandwidthPackagesRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~ListBandwidthPackagesRequestTag() = default;
};
class ListBandwidthPackagesRequest : public Darabonba::Model {
public:
  shared_ptr<string> bandwidthPackageId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> state{};
  shared_ptr<vector<ListBandwidthPackagesRequestTag>> tag{};
  shared_ptr<string> type{};

  ListBandwidthPackagesRequest() {}

  explicit ListBandwidthPackagesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bandwidthPackageId) {
      res["BandwidthPackageId"] = boost::any(*bandwidthPackageId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BandwidthPackageId") != m.end() && !m["BandwidthPackageId"].empty()) {
      bandwidthPackageId = make_shared<string>(boost::any_cast<string>(m["BandwidthPackageId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<ListBandwidthPackagesRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListBandwidthPackagesRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<ListBandwidthPackagesRequestTag>>(expect1);
      }
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListBandwidthPackagesRequest() = default;
};
class ListBandwidthPackagesResponseBodyBandwidthPackagesTags : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  ListBandwidthPackagesResponseBodyBandwidthPackagesTags() {}

  explicit ListBandwidthPackagesResponseBodyBandwidthPackagesTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~ListBandwidthPackagesResponseBodyBandwidthPackagesTags() = default;
};
class ListBandwidthPackagesResponseBodyBandwidthPackages : public Darabonba::Model {
public:
  shared_ptr<vector<string>> accelerators{};
  shared_ptr<long> bandwidth{};
  shared_ptr<string> bandwidthPackageId{};
  shared_ptr<string> bandwidthType{};
  shared_ptr<string> billingType{};
  shared_ptr<string> cbnGeographicRegionIdA{};
  shared_ptr<string> cbnGeographicRegionIdB{};
  shared_ptr<string> chargeType{};
  shared_ptr<string> createTime{};
  shared_ptr<string> description{};
  shared_ptr<string> expiredTime{};
  shared_ptr<string> name{};
  shared_ptr<long> ratio{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> state{};
  shared_ptr<vector<ListBandwidthPackagesResponseBodyBandwidthPackagesTags>> tags{};
  shared_ptr<string> type{};

  ListBandwidthPackagesResponseBodyBandwidthPackages() {}

  explicit ListBandwidthPackagesResponseBodyBandwidthPackages(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accelerators) {
      res["Accelerators"] = boost::any(*accelerators);
    }
    if (bandwidth) {
      res["Bandwidth"] = boost::any(*bandwidth);
    }
    if (bandwidthPackageId) {
      res["BandwidthPackageId"] = boost::any(*bandwidthPackageId);
    }
    if (bandwidthType) {
      res["BandwidthType"] = boost::any(*bandwidthType);
    }
    if (billingType) {
      res["BillingType"] = boost::any(*billingType);
    }
    if (cbnGeographicRegionIdA) {
      res["CbnGeographicRegionIdA"] = boost::any(*cbnGeographicRegionIdA);
    }
    if (cbnGeographicRegionIdB) {
      res["CbnGeographicRegionIdB"] = boost::any(*cbnGeographicRegionIdB);
    }
    if (chargeType) {
      res["ChargeType"] = boost::any(*chargeType);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (expiredTime) {
      res["ExpiredTime"] = boost::any(*expiredTime);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (ratio) {
      res["Ratio"] = boost::any(*ratio);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tags"] = boost::any(temp1);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Accelerators") != m.end() && !m["Accelerators"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Accelerators"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Accelerators"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      accelerators = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Bandwidth") != m.end() && !m["Bandwidth"].empty()) {
      bandwidth = make_shared<long>(boost::any_cast<long>(m["Bandwidth"]));
    }
    if (m.find("BandwidthPackageId") != m.end() && !m["BandwidthPackageId"].empty()) {
      bandwidthPackageId = make_shared<string>(boost::any_cast<string>(m["BandwidthPackageId"]));
    }
    if (m.find("BandwidthType") != m.end() && !m["BandwidthType"].empty()) {
      bandwidthType = make_shared<string>(boost::any_cast<string>(m["BandwidthType"]));
    }
    if (m.find("BillingType") != m.end() && !m["BillingType"].empty()) {
      billingType = make_shared<string>(boost::any_cast<string>(m["BillingType"]));
    }
    if (m.find("CbnGeographicRegionIdA") != m.end() && !m["CbnGeographicRegionIdA"].empty()) {
      cbnGeographicRegionIdA = make_shared<string>(boost::any_cast<string>(m["CbnGeographicRegionIdA"]));
    }
    if (m.find("CbnGeographicRegionIdB") != m.end() && !m["CbnGeographicRegionIdB"].empty()) {
      cbnGeographicRegionIdB = make_shared<string>(boost::any_cast<string>(m["CbnGeographicRegionIdB"]));
    }
    if (m.find("ChargeType") != m.end() && !m["ChargeType"].empty()) {
      chargeType = make_shared<string>(boost::any_cast<string>(m["ChargeType"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("ExpiredTime") != m.end() && !m["ExpiredTime"].empty()) {
      expiredTime = make_shared<string>(boost::any_cast<string>(m["ExpiredTime"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Ratio") != m.end() && !m["Ratio"].empty()) {
      ratio = make_shared<long>(boost::any_cast<long>(m["Ratio"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(vector<boost::any>) == m["Tags"].type()) {
        vector<ListBandwidthPackagesResponseBodyBandwidthPackagesTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListBandwidthPackagesResponseBodyBandwidthPackagesTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<ListBandwidthPackagesResponseBodyBandwidthPackagesTags>>(expect1);
      }
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListBandwidthPackagesResponseBodyBandwidthPackages() = default;
};
class ListBandwidthPackagesResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListBandwidthPackagesResponseBodyBandwidthPackages>> bandwidthPackages{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  ListBandwidthPackagesResponseBody() {}

  explicit ListBandwidthPackagesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bandwidthPackages) {
      vector<boost::any> temp1;
      for(auto item1:*bandwidthPackages){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["BandwidthPackages"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BandwidthPackages") != m.end() && !m["BandwidthPackages"].empty()) {
      if (typeid(vector<boost::any>) == m["BandwidthPackages"].type()) {
        vector<ListBandwidthPackagesResponseBodyBandwidthPackages> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["BandwidthPackages"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListBandwidthPackagesResponseBodyBandwidthPackages model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        bandwidthPackages = make_shared<vector<ListBandwidthPackagesResponseBodyBandwidthPackages>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListBandwidthPackagesResponseBody() = default;
};
class ListBandwidthPackagesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListBandwidthPackagesResponseBody> body{};

  ListBandwidthPackagesResponse() {}

  explicit ListBandwidthPackagesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListBandwidthPackagesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListBandwidthPackagesResponseBody>(model1);
      }
    }
  }


  virtual ~ListBandwidthPackagesResponse() = default;
};
class ListBandwidthackagesRequest : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regionId{};

  ListBandwidthackagesRequest() {}

  explicit ListBandwidthackagesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~ListBandwidthackagesRequest() = default;
};
class ListBandwidthackagesResponseBodyBandwidthPackagesTags : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  ListBandwidthackagesResponseBodyBandwidthPackagesTags() {}

  explicit ListBandwidthackagesResponseBodyBandwidthPackagesTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~ListBandwidthackagesResponseBodyBandwidthPackagesTags() = default;
};
class ListBandwidthackagesResponseBodyBandwidthPackages : public Darabonba::Model {
public:
  shared_ptr<vector<string>> accelerators{};
  shared_ptr<long> bandwidth{};
  shared_ptr<string> bandwidthPackageId{};
  shared_ptr<string> chargeType{};
  shared_ptr<string> createTime{};
  shared_ptr<string> description{};
  shared_ptr<string> expiredTime{};
  shared_ptr<string> name{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> state{};
  shared_ptr<vector<ListBandwidthackagesResponseBodyBandwidthPackagesTags>> tags{};

  ListBandwidthackagesResponseBodyBandwidthPackages() {}

  explicit ListBandwidthackagesResponseBodyBandwidthPackages(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accelerators) {
      res["Accelerators"] = boost::any(*accelerators);
    }
    if (bandwidth) {
      res["Bandwidth"] = boost::any(*bandwidth);
    }
    if (bandwidthPackageId) {
      res["BandwidthPackageId"] = boost::any(*bandwidthPackageId);
    }
    if (chargeType) {
      res["ChargeType"] = boost::any(*chargeType);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (expiredTime) {
      res["ExpiredTime"] = boost::any(*expiredTime);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tags"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Accelerators") != m.end() && !m["Accelerators"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Accelerators"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Accelerators"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      accelerators = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Bandwidth") != m.end() && !m["Bandwidth"].empty()) {
      bandwidth = make_shared<long>(boost::any_cast<long>(m["Bandwidth"]));
    }
    if (m.find("BandwidthPackageId") != m.end() && !m["BandwidthPackageId"].empty()) {
      bandwidthPackageId = make_shared<string>(boost::any_cast<string>(m["BandwidthPackageId"]));
    }
    if (m.find("ChargeType") != m.end() && !m["ChargeType"].empty()) {
      chargeType = make_shared<string>(boost::any_cast<string>(m["ChargeType"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("ExpiredTime") != m.end() && !m["ExpiredTime"].empty()) {
      expiredTime = make_shared<string>(boost::any_cast<string>(m["ExpiredTime"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(vector<boost::any>) == m["Tags"].type()) {
        vector<ListBandwidthackagesResponseBodyBandwidthPackagesTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListBandwidthackagesResponseBodyBandwidthPackagesTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<ListBandwidthackagesResponseBodyBandwidthPackagesTags>>(expect1);
      }
    }
  }


  virtual ~ListBandwidthackagesResponseBodyBandwidthPackages() = default;
};
class ListBandwidthackagesResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListBandwidthackagesResponseBodyBandwidthPackages>> bandwidthPackages{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  ListBandwidthackagesResponseBody() {}

  explicit ListBandwidthackagesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bandwidthPackages) {
      vector<boost::any> temp1;
      for(auto item1:*bandwidthPackages){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["BandwidthPackages"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BandwidthPackages") != m.end() && !m["BandwidthPackages"].empty()) {
      if (typeid(vector<boost::any>) == m["BandwidthPackages"].type()) {
        vector<ListBandwidthackagesResponseBodyBandwidthPackages> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["BandwidthPackages"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListBandwidthackagesResponseBodyBandwidthPackages model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        bandwidthPackages = make_shared<vector<ListBandwidthackagesResponseBodyBandwidthPackages>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListBandwidthackagesResponseBody() = default;
};
class ListBandwidthackagesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListBandwidthackagesResponseBody> body{};

  ListBandwidthackagesResponse() {}

  explicit ListBandwidthackagesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListBandwidthackagesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListBandwidthackagesResponseBody>(model1);
      }
    }
  }


  virtual ~ListBandwidthackagesResponse() = default;
};
class ListBasicAccelerateIpEndpointRelationsRequest : public Darabonba::Model {
public:
  shared_ptr<string> accelerateIpId{};
  shared_ptr<string> acceleratorId{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> endpointId{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> regionId{};

  ListBasicAccelerateIpEndpointRelationsRequest() {}

  explicit ListBasicAccelerateIpEndpointRelationsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accelerateIpId) {
      res["AccelerateIpId"] = boost::any(*accelerateIpId);
    }
    if (acceleratorId) {
      res["AcceleratorId"] = boost::any(*acceleratorId);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (endpointId) {
      res["EndpointId"] = boost::any(*endpointId);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccelerateIpId") != m.end() && !m["AccelerateIpId"].empty()) {
      accelerateIpId = make_shared<string>(boost::any_cast<string>(m["AccelerateIpId"]));
    }
    if (m.find("AcceleratorId") != m.end() && !m["AcceleratorId"].empty()) {
      acceleratorId = make_shared<string>(boost::any_cast<string>(m["AcceleratorId"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("EndpointId") != m.end() && !m["EndpointId"].empty()) {
      endpointId = make_shared<string>(boost::any_cast<string>(m["EndpointId"]));
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~ListBasicAccelerateIpEndpointRelationsRequest() = default;
};
class ListBasicAccelerateIpEndpointRelationsResponseBodyAccelerateIpEndpointRelations : public Darabonba::Model {
public:
  shared_ptr<string> accelerateIpId{};
  shared_ptr<string> acceleratorId{};
  shared_ptr<string> endpointAddress{};
  shared_ptr<string> endpointId{};
  shared_ptr<string> endpointName{};
  shared_ptr<string> endpointSubAddress{};
  shared_ptr<string> endpointSubAddressType{};
  shared_ptr<string> endpointType{};
  shared_ptr<string> endpointZoneId{};
  shared_ptr<string> ipAddress{};
  shared_ptr<string> state{};

  ListBasicAccelerateIpEndpointRelationsResponseBodyAccelerateIpEndpointRelations() {}

  explicit ListBasicAccelerateIpEndpointRelationsResponseBodyAccelerateIpEndpointRelations(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accelerateIpId) {
      res["AccelerateIpId"] = boost::any(*accelerateIpId);
    }
    if (acceleratorId) {
      res["AcceleratorId"] = boost::any(*acceleratorId);
    }
    if (endpointAddress) {
      res["EndpointAddress"] = boost::any(*endpointAddress);
    }
    if (endpointId) {
      res["EndpointId"] = boost::any(*endpointId);
    }
    if (endpointName) {
      res["EndpointName"] = boost::any(*endpointName);
    }
    if (endpointSubAddress) {
      res["EndpointSubAddress"] = boost::any(*endpointSubAddress);
    }
    if (endpointSubAddressType) {
      res["EndpointSubAddressType"] = boost::any(*endpointSubAddressType);
    }
    if (endpointType) {
      res["EndpointType"] = boost::any(*endpointType);
    }
    if (endpointZoneId) {
      res["EndpointZoneId"] = boost::any(*endpointZoneId);
    }
    if (ipAddress) {
      res["IpAddress"] = boost::any(*ipAddress);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccelerateIpId") != m.end() && !m["AccelerateIpId"].empty()) {
      accelerateIpId = make_shared<string>(boost::any_cast<string>(m["AccelerateIpId"]));
    }
    if (m.find("AcceleratorId") != m.end() && !m["AcceleratorId"].empty()) {
      acceleratorId = make_shared<string>(boost::any_cast<string>(m["AcceleratorId"]));
    }
    if (m.find("EndpointAddress") != m.end() && !m["EndpointAddress"].empty()) {
      endpointAddress = make_shared<string>(boost::any_cast<string>(m["EndpointAddress"]));
    }
    if (m.find("EndpointId") != m.end() && !m["EndpointId"].empty()) {
      endpointId = make_shared<string>(boost::any_cast<string>(m["EndpointId"]));
    }
    if (m.find("EndpointName") != m.end() && !m["EndpointName"].empty()) {
      endpointName = make_shared<string>(boost::any_cast<string>(m["EndpointName"]));
    }
    if (m.find("EndpointSubAddress") != m.end() && !m["EndpointSubAddress"].empty()) {
      endpointSubAddress = make_shared<string>(boost::any_cast<string>(m["EndpointSubAddress"]));
    }
    if (m.find("EndpointSubAddressType") != m.end() && !m["EndpointSubAddressType"].empty()) {
      endpointSubAddressType = make_shared<string>(boost::any_cast<string>(m["EndpointSubAddressType"]));
    }
    if (m.find("EndpointType") != m.end() && !m["EndpointType"].empty()) {
      endpointType = make_shared<string>(boost::any_cast<string>(m["EndpointType"]));
    }
    if (m.find("EndpointZoneId") != m.end() && !m["EndpointZoneId"].empty()) {
      endpointZoneId = make_shared<string>(boost::any_cast<string>(m["EndpointZoneId"]));
    }
    if (m.find("IpAddress") != m.end() && !m["IpAddress"].empty()) {
      ipAddress = make_shared<string>(boost::any_cast<string>(m["IpAddress"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
  }


  virtual ~ListBasicAccelerateIpEndpointRelationsResponseBodyAccelerateIpEndpointRelations() = default;
};
class ListBasicAccelerateIpEndpointRelationsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListBasicAccelerateIpEndpointRelationsResponseBodyAccelerateIpEndpointRelations>> accelerateIpEndpointRelations{};
  shared_ptr<string> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> requestId{};
  shared_ptr<string> totalCount{};

  ListBasicAccelerateIpEndpointRelationsResponseBody() {}

  explicit ListBasicAccelerateIpEndpointRelationsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accelerateIpEndpointRelations) {
      vector<boost::any> temp1;
      for(auto item1:*accelerateIpEndpointRelations){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AccelerateIpEndpointRelations"] = boost::any(temp1);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccelerateIpEndpointRelations") != m.end() && !m["AccelerateIpEndpointRelations"].empty()) {
      if (typeid(vector<boost::any>) == m["AccelerateIpEndpointRelations"].type()) {
        vector<ListBasicAccelerateIpEndpointRelationsResponseBodyAccelerateIpEndpointRelations> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AccelerateIpEndpointRelations"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListBasicAccelerateIpEndpointRelationsResponseBodyAccelerateIpEndpointRelations model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        accelerateIpEndpointRelations = make_shared<vector<ListBasicAccelerateIpEndpointRelationsResponseBodyAccelerateIpEndpointRelations>>(expect1);
      }
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<string>(boost::any_cast<string>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<string>(boost::any_cast<string>(m["TotalCount"]));
    }
  }


  virtual ~ListBasicAccelerateIpEndpointRelationsResponseBody() = default;
};
class ListBasicAccelerateIpEndpointRelationsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListBasicAccelerateIpEndpointRelationsResponseBody> body{};

  ListBasicAccelerateIpEndpointRelationsResponse() {}

  explicit ListBasicAccelerateIpEndpointRelationsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListBasicAccelerateIpEndpointRelationsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListBasicAccelerateIpEndpointRelationsResponseBody>(model1);
      }
    }
  }


  virtual ~ListBasicAccelerateIpEndpointRelationsResponse() = default;
};
class ListBasicAccelerateIpsRequest : public Darabonba::Model {
public:
  shared_ptr<string> accelerateIpAddress{};
  shared_ptr<string> accelerateIpId{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> ipSetId{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> regionId{};

  ListBasicAccelerateIpsRequest() {}

  explicit ListBasicAccelerateIpsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accelerateIpAddress) {
      res["AccelerateIpAddress"] = boost::any(*accelerateIpAddress);
    }
    if (accelerateIpId) {
      res["AccelerateIpId"] = boost::any(*accelerateIpId);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (ipSetId) {
      res["IpSetId"] = boost::any(*ipSetId);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccelerateIpAddress") != m.end() && !m["AccelerateIpAddress"].empty()) {
      accelerateIpAddress = make_shared<string>(boost::any_cast<string>(m["AccelerateIpAddress"]));
    }
    if (m.find("AccelerateIpId") != m.end() && !m["AccelerateIpId"].empty()) {
      accelerateIpId = make_shared<string>(boost::any_cast<string>(m["AccelerateIpId"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("IpSetId") != m.end() && !m["IpSetId"].empty()) {
      ipSetId = make_shared<string>(boost::any_cast<string>(m["IpSetId"]));
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~ListBasicAccelerateIpsRequest() = default;
};
class ListBasicAccelerateIpsResponseBodyAccelerateIps : public Darabonba::Model {
public:
  shared_ptr<string> accelerateIpAddress{};
  shared_ptr<string> accelerateIpId{};
  shared_ptr<string> acceleratorId{};
  shared_ptr<string> ipSetId{};
  shared_ptr<string> state{};

  ListBasicAccelerateIpsResponseBodyAccelerateIps() {}

  explicit ListBasicAccelerateIpsResponseBodyAccelerateIps(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accelerateIpAddress) {
      res["AccelerateIpAddress"] = boost::any(*accelerateIpAddress);
    }
    if (accelerateIpId) {
      res["AccelerateIpId"] = boost::any(*accelerateIpId);
    }
    if (acceleratorId) {
      res["AcceleratorId"] = boost::any(*acceleratorId);
    }
    if (ipSetId) {
      res["IpSetId"] = boost::any(*ipSetId);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccelerateIpAddress") != m.end() && !m["AccelerateIpAddress"].empty()) {
      accelerateIpAddress = make_shared<string>(boost::any_cast<string>(m["AccelerateIpAddress"]));
    }
    if (m.find("AccelerateIpId") != m.end() && !m["AccelerateIpId"].empty()) {
      accelerateIpId = make_shared<string>(boost::any_cast<string>(m["AccelerateIpId"]));
    }
    if (m.find("AcceleratorId") != m.end() && !m["AcceleratorId"].empty()) {
      acceleratorId = make_shared<string>(boost::any_cast<string>(m["AcceleratorId"]));
    }
    if (m.find("IpSetId") != m.end() && !m["IpSetId"].empty()) {
      ipSetId = make_shared<string>(boost::any_cast<string>(m["IpSetId"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
  }


  virtual ~ListBasicAccelerateIpsResponseBodyAccelerateIps() = default;
};
class ListBasicAccelerateIpsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListBasicAccelerateIpsResponseBodyAccelerateIps>> accelerateIps{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  ListBasicAccelerateIpsResponseBody() {}

  explicit ListBasicAccelerateIpsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accelerateIps) {
      vector<boost::any> temp1;
      for(auto item1:*accelerateIps){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AccelerateIps"] = boost::any(temp1);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccelerateIps") != m.end() && !m["AccelerateIps"].empty()) {
      if (typeid(vector<boost::any>) == m["AccelerateIps"].type()) {
        vector<ListBasicAccelerateIpsResponseBodyAccelerateIps> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AccelerateIps"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListBasicAccelerateIpsResponseBodyAccelerateIps model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        accelerateIps = make_shared<vector<ListBasicAccelerateIpsResponseBodyAccelerateIps>>(expect1);
      }
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListBasicAccelerateIpsResponseBody() = default;
};
class ListBasicAccelerateIpsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListBasicAccelerateIpsResponseBody> body{};

  ListBasicAccelerateIpsResponse() {}

  explicit ListBasicAccelerateIpsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListBasicAccelerateIpsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListBasicAccelerateIpsResponseBody>(model1);
      }
    }
  }


  virtual ~ListBasicAccelerateIpsResponse() = default;
};
class ListBasicAcceleratorsRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  ListBasicAcceleratorsRequestTag() {}

  explicit ListBasicAcceleratorsRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~ListBasicAcceleratorsRequestTag() = default;
};
class ListBasicAcceleratorsRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceleratorId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> state{};
  shared_ptr<vector<ListBasicAcceleratorsRequestTag>> tag{};

  ListBasicAcceleratorsRequest() {}

  explicit ListBasicAcceleratorsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceleratorId) {
      res["AcceleratorId"] = boost::any(*acceleratorId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceleratorId") != m.end() && !m["AcceleratorId"].empty()) {
      acceleratorId = make_shared<string>(boost::any_cast<string>(m["AcceleratorId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<ListBasicAcceleratorsRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListBasicAcceleratorsRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<ListBasicAcceleratorsRequestTag>>(expect1);
      }
    }
  }


  virtual ~ListBasicAcceleratorsRequest() = default;
};
class ListBasicAcceleratorsResponseBodyAcceleratorsBasicBandwidthPackage : public Darabonba::Model {
public:
  shared_ptr<long> bandwidth{};
  shared_ptr<string> bandwidthType{};
  shared_ptr<string> instanceId{};

  ListBasicAcceleratorsResponseBodyAcceleratorsBasicBandwidthPackage() {}

  explicit ListBasicAcceleratorsResponseBodyAcceleratorsBasicBandwidthPackage(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bandwidth) {
      res["Bandwidth"] = boost::any(*bandwidth);
    }
    if (bandwidthType) {
      res["BandwidthType"] = boost::any(*bandwidthType);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bandwidth") != m.end() && !m["Bandwidth"].empty()) {
      bandwidth = make_shared<long>(boost::any_cast<long>(m["Bandwidth"]));
    }
    if (m.find("BandwidthType") != m.end() && !m["BandwidthType"].empty()) {
      bandwidthType = make_shared<string>(boost::any_cast<string>(m["BandwidthType"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~ListBasicAcceleratorsResponseBodyAcceleratorsBasicBandwidthPackage() = default;
};
class ListBasicAcceleratorsResponseBodyAcceleratorsCrossDomainBandwidthPackage : public Darabonba::Model {
public:
  shared_ptr<long> bandwidth{};
  shared_ptr<string> instanceId{};

  ListBasicAcceleratorsResponseBodyAcceleratorsCrossDomainBandwidthPackage() {}

  explicit ListBasicAcceleratorsResponseBodyAcceleratorsCrossDomainBandwidthPackage(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bandwidth) {
      res["Bandwidth"] = boost::any(*bandwidth);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bandwidth") != m.end() && !m["Bandwidth"].empty()) {
      bandwidth = make_shared<long>(boost::any_cast<long>(m["Bandwidth"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~ListBasicAcceleratorsResponseBodyAcceleratorsCrossDomainBandwidthPackage() = default;
};
class ListBasicAcceleratorsResponseBodyAcceleratorsTags : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  ListBasicAcceleratorsResponseBodyAcceleratorsTags() {}

  explicit ListBasicAcceleratorsResponseBodyAcceleratorsTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~ListBasicAcceleratorsResponseBodyAcceleratorsTags() = default;
};
class ListBasicAcceleratorsResponseBodyAccelerators : public Darabonba::Model {
public:
  shared_ptr<string> acceleratorId{};
  shared_ptr<string> bandwidthBillingType{};
  shared_ptr<ListBasicAcceleratorsResponseBodyAcceleratorsBasicBandwidthPackage> basicBandwidthPackage{};
  shared_ptr<string> basicEndpointGroupId{};
  shared_ptr<string> basicIpSetId{};
  shared_ptr<long> createTime{};
  shared_ptr<bool> crossBorderStatus{};
  shared_ptr<ListBasicAcceleratorsResponseBodyAcceleratorsCrossDomainBandwidthPackage> crossDomainBandwidthPackage{};
  shared_ptr<string> description{};
  shared_ptr<long> expiredTime{};
  shared_ptr<string> instanceChargeType{};
  shared_ptr<string> name{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> state{};
  shared_ptr<vector<ListBasicAcceleratorsResponseBodyAcceleratorsTags>> tags{};
  shared_ptr<string> type{};

  ListBasicAcceleratorsResponseBodyAccelerators() {}

  explicit ListBasicAcceleratorsResponseBodyAccelerators(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceleratorId) {
      res["AcceleratorId"] = boost::any(*acceleratorId);
    }
    if (bandwidthBillingType) {
      res["BandwidthBillingType"] = boost::any(*bandwidthBillingType);
    }
    if (basicBandwidthPackage) {
      res["BasicBandwidthPackage"] = basicBandwidthPackage ? boost::any(basicBandwidthPackage->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (basicEndpointGroupId) {
      res["BasicEndpointGroupId"] = boost::any(*basicEndpointGroupId);
    }
    if (basicIpSetId) {
      res["BasicIpSetId"] = boost::any(*basicIpSetId);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (crossBorderStatus) {
      res["CrossBorderStatus"] = boost::any(*crossBorderStatus);
    }
    if (crossDomainBandwidthPackage) {
      res["CrossDomainBandwidthPackage"] = crossDomainBandwidthPackage ? boost::any(crossDomainBandwidthPackage->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (expiredTime) {
      res["ExpiredTime"] = boost::any(*expiredTime);
    }
    if (instanceChargeType) {
      res["InstanceChargeType"] = boost::any(*instanceChargeType);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tags"] = boost::any(temp1);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceleratorId") != m.end() && !m["AcceleratorId"].empty()) {
      acceleratorId = make_shared<string>(boost::any_cast<string>(m["AcceleratorId"]));
    }
    if (m.find("BandwidthBillingType") != m.end() && !m["BandwidthBillingType"].empty()) {
      bandwidthBillingType = make_shared<string>(boost::any_cast<string>(m["BandwidthBillingType"]));
    }
    if (m.find("BasicBandwidthPackage") != m.end() && !m["BasicBandwidthPackage"].empty()) {
      if (typeid(map<string, boost::any>) == m["BasicBandwidthPackage"].type()) {
        ListBasicAcceleratorsResponseBodyAcceleratorsBasicBandwidthPackage model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["BasicBandwidthPackage"]));
        basicBandwidthPackage = make_shared<ListBasicAcceleratorsResponseBodyAcceleratorsBasicBandwidthPackage>(model1);
      }
    }
    if (m.find("BasicEndpointGroupId") != m.end() && !m["BasicEndpointGroupId"].empty()) {
      basicEndpointGroupId = make_shared<string>(boost::any_cast<string>(m["BasicEndpointGroupId"]));
    }
    if (m.find("BasicIpSetId") != m.end() && !m["BasicIpSetId"].empty()) {
      basicIpSetId = make_shared<string>(boost::any_cast<string>(m["BasicIpSetId"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("CrossBorderStatus") != m.end() && !m["CrossBorderStatus"].empty()) {
      crossBorderStatus = make_shared<bool>(boost::any_cast<bool>(m["CrossBorderStatus"]));
    }
    if (m.find("CrossDomainBandwidthPackage") != m.end() && !m["CrossDomainBandwidthPackage"].empty()) {
      if (typeid(map<string, boost::any>) == m["CrossDomainBandwidthPackage"].type()) {
        ListBasicAcceleratorsResponseBodyAcceleratorsCrossDomainBandwidthPackage model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CrossDomainBandwidthPackage"]));
        crossDomainBandwidthPackage = make_shared<ListBasicAcceleratorsResponseBodyAcceleratorsCrossDomainBandwidthPackage>(model1);
      }
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("ExpiredTime") != m.end() && !m["ExpiredTime"].empty()) {
      expiredTime = make_shared<long>(boost::any_cast<long>(m["ExpiredTime"]));
    }
    if (m.find("InstanceChargeType") != m.end() && !m["InstanceChargeType"].empty()) {
      instanceChargeType = make_shared<string>(boost::any_cast<string>(m["InstanceChargeType"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(vector<boost::any>) == m["Tags"].type()) {
        vector<ListBasicAcceleratorsResponseBodyAcceleratorsTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListBasicAcceleratorsResponseBodyAcceleratorsTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<ListBasicAcceleratorsResponseBodyAcceleratorsTags>>(expect1);
      }
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListBasicAcceleratorsResponseBodyAccelerators() = default;
};
class ListBasicAcceleratorsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListBasicAcceleratorsResponseBodyAccelerators>> accelerators{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  ListBasicAcceleratorsResponseBody() {}

  explicit ListBasicAcceleratorsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accelerators) {
      vector<boost::any> temp1;
      for(auto item1:*accelerators){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Accelerators"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Accelerators") != m.end() && !m["Accelerators"].empty()) {
      if (typeid(vector<boost::any>) == m["Accelerators"].type()) {
        vector<ListBasicAcceleratorsResponseBodyAccelerators> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Accelerators"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListBasicAcceleratorsResponseBodyAccelerators model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        accelerators = make_shared<vector<ListBasicAcceleratorsResponseBodyAccelerators>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListBasicAcceleratorsResponseBody() = default;
};
class ListBasicAcceleratorsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListBasicAcceleratorsResponseBody> body{};

  ListBasicAcceleratorsResponse() {}

  explicit ListBasicAcceleratorsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListBasicAcceleratorsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListBasicAcceleratorsResponseBody>(model1);
      }
    }
  }


  virtual ~ListBasicAcceleratorsResponse() = default;
};
class ListBasicEndpointsRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> endpointGroupId{};
  shared_ptr<string> endpointId{};
  shared_ptr<string> endpointType{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> name{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> regionId{};

  ListBasicEndpointsRequest() {}

  explicit ListBasicEndpointsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (endpointGroupId) {
      res["EndpointGroupId"] = boost::any(*endpointGroupId);
    }
    if (endpointId) {
      res["EndpointId"] = boost::any(*endpointId);
    }
    if (endpointType) {
      res["EndpointType"] = boost::any(*endpointType);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("EndpointGroupId") != m.end() && !m["EndpointGroupId"].empty()) {
      endpointGroupId = make_shared<string>(boost::any_cast<string>(m["EndpointGroupId"]));
    }
    if (m.find("EndpointId") != m.end() && !m["EndpointId"].empty()) {
      endpointId = make_shared<string>(boost::any_cast<string>(m["EndpointId"]));
    }
    if (m.find("EndpointType") != m.end() && !m["EndpointType"].empty()) {
      endpointType = make_shared<string>(boost::any_cast<string>(m["EndpointType"]));
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~ListBasicEndpointsRequest() = default;
};
class ListBasicEndpointsResponseBodyEndpoints : public Darabonba::Model {
public:
  shared_ptr<string> acceleratorId{};
  shared_ptr<string> endpointAddress{};
  shared_ptr<string> endpointGroupId{};
  shared_ptr<string> endpointId{};
  shared_ptr<string> endpointSubAddress{};
  shared_ptr<string> endpointSubAddressType{};
  shared_ptr<string> endpointType{};
  shared_ptr<string> endpointZoneId{};
  shared_ptr<string> name{};
  shared_ptr<string> state{};

  ListBasicEndpointsResponseBodyEndpoints() {}

  explicit ListBasicEndpointsResponseBodyEndpoints(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceleratorId) {
      res["AcceleratorId"] = boost::any(*acceleratorId);
    }
    if (endpointAddress) {
      res["EndpointAddress"] = boost::any(*endpointAddress);
    }
    if (endpointGroupId) {
      res["EndpointGroupId"] = boost::any(*endpointGroupId);
    }
    if (endpointId) {
      res["EndpointId"] = boost::any(*endpointId);
    }
    if (endpointSubAddress) {
      res["EndpointSubAddress"] = boost::any(*endpointSubAddress);
    }
    if (endpointSubAddressType) {
      res["EndpointSubAddressType"] = boost::any(*endpointSubAddressType);
    }
    if (endpointType) {
      res["EndpointType"] = boost::any(*endpointType);
    }
    if (endpointZoneId) {
      res["EndpointZoneId"] = boost::any(*endpointZoneId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceleratorId") != m.end() && !m["AcceleratorId"].empty()) {
      acceleratorId = make_shared<string>(boost::any_cast<string>(m["AcceleratorId"]));
    }
    if (m.find("EndpointAddress") != m.end() && !m["EndpointAddress"].empty()) {
      endpointAddress = make_shared<string>(boost::any_cast<string>(m["EndpointAddress"]));
    }
    if (m.find("EndpointGroupId") != m.end() && !m["EndpointGroupId"].empty()) {
      endpointGroupId = make_shared<string>(boost::any_cast<string>(m["EndpointGroupId"]));
    }
    if (m.find("EndpointId") != m.end() && !m["EndpointId"].empty()) {
      endpointId = make_shared<string>(boost::any_cast<string>(m["EndpointId"]));
    }
    if (m.find("EndpointSubAddress") != m.end() && !m["EndpointSubAddress"].empty()) {
      endpointSubAddress = make_shared<string>(boost::any_cast<string>(m["EndpointSubAddress"]));
    }
    if (m.find("EndpointSubAddressType") != m.end() && !m["EndpointSubAddressType"].empty()) {
      endpointSubAddressType = make_shared<string>(boost::any_cast<string>(m["EndpointSubAddressType"]));
    }
    if (m.find("EndpointType") != m.end() && !m["EndpointType"].empty()) {
      endpointType = make_shared<string>(boost::any_cast<string>(m["EndpointType"]));
    }
    if (m.find("EndpointZoneId") != m.end() && !m["EndpointZoneId"].empty()) {
      endpointZoneId = make_shared<string>(boost::any_cast<string>(m["EndpointZoneId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
  }


  virtual ~ListBasicEndpointsResponseBodyEndpoints() = default;
};
class ListBasicEndpointsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListBasicEndpointsResponseBodyEndpoints>> endpoints{};
  shared_ptr<string> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> requestId{};
  shared_ptr<string> totalCount{};

  ListBasicEndpointsResponseBody() {}

  explicit ListBasicEndpointsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endpoints) {
      vector<boost::any> temp1;
      for(auto item1:*endpoints){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Endpoints"] = boost::any(temp1);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Endpoints") != m.end() && !m["Endpoints"].empty()) {
      if (typeid(vector<boost::any>) == m["Endpoints"].type()) {
        vector<ListBasicEndpointsResponseBodyEndpoints> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Endpoints"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListBasicEndpointsResponseBodyEndpoints model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        endpoints = make_shared<vector<ListBasicEndpointsResponseBodyEndpoints>>(expect1);
      }
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<string>(boost::any_cast<string>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<string>(boost::any_cast<string>(m["TotalCount"]));
    }
  }


  virtual ~ListBasicEndpointsResponseBody() = default;
};
class ListBasicEndpointsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListBasicEndpointsResponseBody> body{};

  ListBasicEndpointsResponse() {}

  explicit ListBasicEndpointsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListBasicEndpointsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListBasicEndpointsResponseBody>(model1);
      }
    }
  }


  virtual ~ListBasicEndpointsResponse() = default;
};
class ListBusiRegionsRequest : public Darabonba::Model {
public:
  shared_ptr<string> regionId{};

  ListBusiRegionsRequest() {}

  explicit ListBusiRegionsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~ListBusiRegionsRequest() = default;
};
class ListBusiRegionsResponseBodyRegions : public Darabonba::Model {
public:
  shared_ptr<string> localName{};
  shared_ptr<string> regionId{};

  ListBusiRegionsResponseBodyRegions() {}

  explicit ListBusiRegionsResponseBodyRegions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (localName) {
      res["LocalName"] = boost::any(*localName);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LocalName") != m.end() && !m["LocalName"].empty()) {
      localName = make_shared<string>(boost::any_cast<string>(m["LocalName"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~ListBusiRegionsResponseBodyRegions() = default;
};
class ListBusiRegionsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListBusiRegionsResponseBodyRegions>> regions{};
  shared_ptr<string> requestId{};

  ListBusiRegionsResponseBody() {}

  explicit ListBusiRegionsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (regions) {
      vector<boost::any> temp1;
      for(auto item1:*regions){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Regions"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Regions") != m.end() && !m["Regions"].empty()) {
      if (typeid(vector<boost::any>) == m["Regions"].type()) {
        vector<ListBusiRegionsResponseBodyRegions> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Regions"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListBusiRegionsResponseBodyRegions model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        regions = make_shared<vector<ListBusiRegionsResponseBodyRegions>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListBusiRegionsResponseBody() = default;
};
class ListBusiRegionsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListBusiRegionsResponseBody> body{};

  ListBusiRegionsResponse() {}

  explicit ListBusiRegionsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListBusiRegionsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListBusiRegionsResponseBody>(model1);
      }
    }
  }


  virtual ~ListBusiRegionsResponse() = default;
};
class ListCommonAreasRequest : public Darabonba::Model {
public:
  shared_ptr<string> ipVersion{};
  shared_ptr<bool> isEpg{};
  shared_ptr<bool> isIpSet{};

  ListCommonAreasRequest() {}

  explicit ListCommonAreasRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ipVersion) {
      res["IpVersion"] = boost::any(*ipVersion);
    }
    if (isEpg) {
      res["IsEpg"] = boost::any(*isEpg);
    }
    if (isIpSet) {
      res["IsIpSet"] = boost::any(*isIpSet);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IpVersion") != m.end() && !m["IpVersion"].empty()) {
      ipVersion = make_shared<string>(boost::any_cast<string>(m["IpVersion"]));
    }
    if (m.find("IsEpg") != m.end() && !m["IsEpg"].empty()) {
      isEpg = make_shared<bool>(boost::any_cast<bool>(m["IsEpg"]));
    }
    if (m.find("IsIpSet") != m.end() && !m["IsIpSet"].empty()) {
      isIpSet = make_shared<bool>(boost::any_cast<bool>(m["IsIpSet"]));
    }
  }


  virtual ~ListCommonAreasRequest() = default;
};
class ListCommonAreasResponseBodyAreasRegionList : public Darabonba::Model {
public:
  shared_ptr<string> localName{};
  shared_ptr<string> regionId{};

  ListCommonAreasResponseBodyAreasRegionList() {}

  explicit ListCommonAreasResponseBodyAreasRegionList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (localName) {
      res["LocalName"] = boost::any(*localName);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LocalName") != m.end() && !m["LocalName"].empty()) {
      localName = make_shared<string>(boost::any_cast<string>(m["LocalName"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~ListCommonAreasResponseBodyAreasRegionList() = default;
};
class ListCommonAreasResponseBodyAreas : public Darabonba::Model {
public:
  shared_ptr<string> areaId{};
  shared_ptr<string> localName{};
  shared_ptr<vector<ListCommonAreasResponseBodyAreasRegionList>> regionList{};

  ListCommonAreasResponseBodyAreas() {}

  explicit ListCommonAreasResponseBodyAreas(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (areaId) {
      res["AreaId"] = boost::any(*areaId);
    }
    if (localName) {
      res["LocalName"] = boost::any(*localName);
    }
    if (regionList) {
      vector<boost::any> temp1;
      for(auto item1:*regionList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RegionList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AreaId") != m.end() && !m["AreaId"].empty()) {
      areaId = make_shared<string>(boost::any_cast<string>(m["AreaId"]));
    }
    if (m.find("LocalName") != m.end() && !m["LocalName"].empty()) {
      localName = make_shared<string>(boost::any_cast<string>(m["LocalName"]));
    }
    if (m.find("RegionList") != m.end() && !m["RegionList"].empty()) {
      if (typeid(vector<boost::any>) == m["RegionList"].type()) {
        vector<ListCommonAreasResponseBodyAreasRegionList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RegionList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListCommonAreasResponseBodyAreasRegionList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        regionList = make_shared<vector<ListCommonAreasResponseBodyAreasRegionList>>(expect1);
      }
    }
  }


  virtual ~ListCommonAreasResponseBodyAreas() = default;
};
class ListCommonAreasResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListCommonAreasResponseBodyAreas>> areas{};
  shared_ptr<string> requestId{};

  ListCommonAreasResponseBody() {}

  explicit ListCommonAreasResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (areas) {
      vector<boost::any> temp1;
      for(auto item1:*areas){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Areas"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Areas") != m.end() && !m["Areas"].empty()) {
      if (typeid(vector<boost::any>) == m["Areas"].type()) {
        vector<ListCommonAreasResponseBodyAreas> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Areas"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListCommonAreasResponseBodyAreas model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        areas = make_shared<vector<ListCommonAreasResponseBodyAreas>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListCommonAreasResponseBody() = default;
};
class ListCommonAreasResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListCommonAreasResponseBody> body{};

  ListCommonAreasResponse() {}

  explicit ListCommonAreasResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListCommonAreasResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListCommonAreasResponseBody>(model1);
      }
    }
  }


  virtual ~ListCommonAreasResponse() = default;
};
class ListCustomRoutingEndpointGroupDestinationsRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceleratorId{};
  shared_ptr<string> endpointGroupId{};
  shared_ptr<long> fromPort{};
  shared_ptr<string> listenerId{};
  shared_ptr<string> pageNumber{};
  shared_ptr<string> pageSize{};
  shared_ptr<vector<string>> protocols{};
  shared_ptr<string> regionId{};
  shared_ptr<long> toPort{};

  ListCustomRoutingEndpointGroupDestinationsRequest() {}

  explicit ListCustomRoutingEndpointGroupDestinationsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceleratorId) {
      res["AcceleratorId"] = boost::any(*acceleratorId);
    }
    if (endpointGroupId) {
      res["EndpointGroupId"] = boost::any(*endpointGroupId);
    }
    if (fromPort) {
      res["FromPort"] = boost::any(*fromPort);
    }
    if (listenerId) {
      res["ListenerId"] = boost::any(*listenerId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (protocols) {
      res["Protocols"] = boost::any(*protocols);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (toPort) {
      res["ToPort"] = boost::any(*toPort);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceleratorId") != m.end() && !m["AcceleratorId"].empty()) {
      acceleratorId = make_shared<string>(boost::any_cast<string>(m["AcceleratorId"]));
    }
    if (m.find("EndpointGroupId") != m.end() && !m["EndpointGroupId"].empty()) {
      endpointGroupId = make_shared<string>(boost::any_cast<string>(m["EndpointGroupId"]));
    }
    if (m.find("FromPort") != m.end() && !m["FromPort"].empty()) {
      fromPort = make_shared<long>(boost::any_cast<long>(m["FromPort"]));
    }
    if (m.find("ListenerId") != m.end() && !m["ListenerId"].empty()) {
      listenerId = make_shared<string>(boost::any_cast<string>(m["ListenerId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<string>(boost::any_cast<string>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<string>(boost::any_cast<string>(m["PageSize"]));
    }
    if (m.find("Protocols") != m.end() && !m["Protocols"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Protocols"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Protocols"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      protocols = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ToPort") != m.end() && !m["ToPort"].empty()) {
      toPort = make_shared<long>(boost::any_cast<long>(m["ToPort"]));
    }
  }


  virtual ~ListCustomRoutingEndpointGroupDestinationsRequest() = default;
};
class ListCustomRoutingEndpointGroupDestinationsResponseBodyDestinations : public Darabonba::Model {
public:
  shared_ptr<string> acceleratorId{};
  shared_ptr<string> destinationId{};
  shared_ptr<string> endpointGroupId{};
  shared_ptr<long> fromPort{};
  shared_ptr<string> listenerId{};
  shared_ptr<vector<string>> protocols{};
  shared_ptr<long> toPort{};

  ListCustomRoutingEndpointGroupDestinationsResponseBodyDestinations() {}

  explicit ListCustomRoutingEndpointGroupDestinationsResponseBodyDestinations(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceleratorId) {
      res["AcceleratorId"] = boost::any(*acceleratorId);
    }
    if (destinationId) {
      res["DestinationId"] = boost::any(*destinationId);
    }
    if (endpointGroupId) {
      res["EndpointGroupId"] = boost::any(*endpointGroupId);
    }
    if (fromPort) {
      res["FromPort"] = boost::any(*fromPort);
    }
    if (listenerId) {
      res["ListenerId"] = boost::any(*listenerId);
    }
    if (protocols) {
      res["Protocols"] = boost::any(*protocols);
    }
    if (toPort) {
      res["ToPort"] = boost::any(*toPort);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceleratorId") != m.end() && !m["AcceleratorId"].empty()) {
      acceleratorId = make_shared<string>(boost::any_cast<string>(m["AcceleratorId"]));
    }
    if (m.find("DestinationId") != m.end() && !m["DestinationId"].empty()) {
      destinationId = make_shared<string>(boost::any_cast<string>(m["DestinationId"]));
    }
    if (m.find("EndpointGroupId") != m.end() && !m["EndpointGroupId"].empty()) {
      endpointGroupId = make_shared<string>(boost::any_cast<string>(m["EndpointGroupId"]));
    }
    if (m.find("FromPort") != m.end() && !m["FromPort"].empty()) {
      fromPort = make_shared<long>(boost::any_cast<long>(m["FromPort"]));
    }
    if (m.find("ListenerId") != m.end() && !m["ListenerId"].empty()) {
      listenerId = make_shared<string>(boost::any_cast<string>(m["ListenerId"]));
    }
    if (m.find("Protocols") != m.end() && !m["Protocols"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Protocols"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Protocols"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      protocols = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ToPort") != m.end() && !m["ToPort"].empty()) {
      toPort = make_shared<long>(boost::any_cast<long>(m["ToPort"]));
    }
  }


  virtual ~ListCustomRoutingEndpointGroupDestinationsResponseBodyDestinations() = default;
};
class ListCustomRoutingEndpointGroupDestinationsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListCustomRoutingEndpointGroupDestinationsResponseBodyDestinations>> destinations{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  ListCustomRoutingEndpointGroupDestinationsResponseBody() {}

  explicit ListCustomRoutingEndpointGroupDestinationsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (destinations) {
      vector<boost::any> temp1;
      for(auto item1:*destinations){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Destinations"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Destinations") != m.end() && !m["Destinations"].empty()) {
      if (typeid(vector<boost::any>) == m["Destinations"].type()) {
        vector<ListCustomRoutingEndpointGroupDestinationsResponseBodyDestinations> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Destinations"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListCustomRoutingEndpointGroupDestinationsResponseBodyDestinations model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        destinations = make_shared<vector<ListCustomRoutingEndpointGroupDestinationsResponseBodyDestinations>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListCustomRoutingEndpointGroupDestinationsResponseBody() = default;
};
class ListCustomRoutingEndpointGroupDestinationsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListCustomRoutingEndpointGroupDestinationsResponseBody> body{};

  ListCustomRoutingEndpointGroupDestinationsResponse() {}

  explicit ListCustomRoutingEndpointGroupDestinationsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListCustomRoutingEndpointGroupDestinationsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListCustomRoutingEndpointGroupDestinationsResponseBody>(model1);
      }
    }
  }


  virtual ~ListCustomRoutingEndpointGroupDestinationsResponse() = default;
};
class ListCustomRoutingEndpointGroupsRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceleratorId{};
  shared_ptr<string> endpointGroupId{};
  shared_ptr<string> listenerId{};
  shared_ptr<string> pageNumber{};
  shared_ptr<string> pageSize{};
  shared_ptr<string> regionId{};

  ListCustomRoutingEndpointGroupsRequest() {}

  explicit ListCustomRoutingEndpointGroupsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceleratorId) {
      res["AcceleratorId"] = boost::any(*acceleratorId);
    }
    if (endpointGroupId) {
      res["EndpointGroupId"] = boost::any(*endpointGroupId);
    }
    if (listenerId) {
      res["ListenerId"] = boost::any(*listenerId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceleratorId") != m.end() && !m["AcceleratorId"].empty()) {
      acceleratorId = make_shared<string>(boost::any_cast<string>(m["AcceleratorId"]));
    }
    if (m.find("EndpointGroupId") != m.end() && !m["EndpointGroupId"].empty()) {
      endpointGroupId = make_shared<string>(boost::any_cast<string>(m["EndpointGroupId"]));
    }
    if (m.find("ListenerId") != m.end() && !m["ListenerId"].empty()) {
      listenerId = make_shared<string>(boost::any_cast<string>(m["ListenerId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<string>(boost::any_cast<string>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<string>(boost::any_cast<string>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~ListCustomRoutingEndpointGroupsRequest() = default;
};
class ListCustomRoutingEndpointGroupsResponseBodyEndpointGroups : public Darabonba::Model {
public:
  shared_ptr<string> acceleratorId{};
  shared_ptr<string> description{};
  shared_ptr<string> endpointGroupId{};
  shared_ptr<vector<string>> endpointGroupIpList{};
  shared_ptr<string> endpointGroupRegion{};
  shared_ptr<vector<string>> endpointGroupUnconfirmedIpList{};
  shared_ptr<string> listenerId{};
  shared_ptr<string> name{};
  shared_ptr<string> state{};

  ListCustomRoutingEndpointGroupsResponseBodyEndpointGroups() {}

  explicit ListCustomRoutingEndpointGroupsResponseBodyEndpointGroups(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceleratorId) {
      res["AcceleratorId"] = boost::any(*acceleratorId);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (endpointGroupId) {
      res["EndpointGroupId"] = boost::any(*endpointGroupId);
    }
    if (endpointGroupIpList) {
      res["EndpointGroupIpList"] = boost::any(*endpointGroupIpList);
    }
    if (endpointGroupRegion) {
      res["EndpointGroupRegion"] = boost::any(*endpointGroupRegion);
    }
    if (endpointGroupUnconfirmedIpList) {
      res["EndpointGroupUnconfirmedIpList"] = boost::any(*endpointGroupUnconfirmedIpList);
    }
    if (listenerId) {
      res["ListenerId"] = boost::any(*listenerId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceleratorId") != m.end() && !m["AcceleratorId"].empty()) {
      acceleratorId = make_shared<string>(boost::any_cast<string>(m["AcceleratorId"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("EndpointGroupId") != m.end() && !m["EndpointGroupId"].empty()) {
      endpointGroupId = make_shared<string>(boost::any_cast<string>(m["EndpointGroupId"]));
    }
    if (m.find("EndpointGroupIpList") != m.end() && !m["EndpointGroupIpList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["EndpointGroupIpList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["EndpointGroupIpList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      endpointGroupIpList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("EndpointGroupRegion") != m.end() && !m["EndpointGroupRegion"].empty()) {
      endpointGroupRegion = make_shared<string>(boost::any_cast<string>(m["EndpointGroupRegion"]));
    }
    if (m.find("EndpointGroupUnconfirmedIpList") != m.end() && !m["EndpointGroupUnconfirmedIpList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["EndpointGroupUnconfirmedIpList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["EndpointGroupUnconfirmedIpList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      endpointGroupUnconfirmedIpList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ListenerId") != m.end() && !m["ListenerId"].empty()) {
      listenerId = make_shared<string>(boost::any_cast<string>(m["ListenerId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
  }


  virtual ~ListCustomRoutingEndpointGroupsResponseBodyEndpointGroups() = default;
};
class ListCustomRoutingEndpointGroupsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListCustomRoutingEndpointGroupsResponseBodyEndpointGroups>> endpointGroups{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  ListCustomRoutingEndpointGroupsResponseBody() {}

  explicit ListCustomRoutingEndpointGroupsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endpointGroups) {
      vector<boost::any> temp1;
      for(auto item1:*endpointGroups){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["EndpointGroups"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndpointGroups") != m.end() && !m["EndpointGroups"].empty()) {
      if (typeid(vector<boost::any>) == m["EndpointGroups"].type()) {
        vector<ListCustomRoutingEndpointGroupsResponseBodyEndpointGroups> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["EndpointGroups"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListCustomRoutingEndpointGroupsResponseBodyEndpointGroups model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        endpointGroups = make_shared<vector<ListCustomRoutingEndpointGroupsResponseBodyEndpointGroups>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListCustomRoutingEndpointGroupsResponseBody() = default;
};
class ListCustomRoutingEndpointGroupsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListCustomRoutingEndpointGroupsResponseBody> body{};

  ListCustomRoutingEndpointGroupsResponse() {}

  explicit ListCustomRoutingEndpointGroupsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListCustomRoutingEndpointGroupsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListCustomRoutingEndpointGroupsResponseBody>(model1);
      }
    }
  }


  virtual ~ListCustomRoutingEndpointGroupsResponse() = default;
};
class ListCustomRoutingEndpointTrafficPoliciesRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceleratorId{};
  shared_ptr<string> address{};
  shared_ptr<string> endpointGroupId{};
  shared_ptr<string> endpointId{};
  shared_ptr<string> listenerId{};
  shared_ptr<string> pageNumber{};
  shared_ptr<string> pageSize{};
  shared_ptr<string> regionId{};

  ListCustomRoutingEndpointTrafficPoliciesRequest() {}

  explicit ListCustomRoutingEndpointTrafficPoliciesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceleratorId) {
      res["AcceleratorId"] = boost::any(*acceleratorId);
    }
    if (address) {
      res["Address"] = boost::any(*address);
    }
    if (endpointGroupId) {
      res["EndpointGroupId"] = boost::any(*endpointGroupId);
    }
    if (endpointId) {
      res["EndpointId"] = boost::any(*endpointId);
    }
    if (listenerId) {
      res["ListenerId"] = boost::any(*listenerId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceleratorId") != m.end() && !m["AcceleratorId"].empty()) {
      acceleratorId = make_shared<string>(boost::any_cast<string>(m["AcceleratorId"]));
    }
    if (m.find("Address") != m.end() && !m["Address"].empty()) {
      address = make_shared<string>(boost::any_cast<string>(m["Address"]));
    }
    if (m.find("EndpointGroupId") != m.end() && !m["EndpointGroupId"].empty()) {
      endpointGroupId = make_shared<string>(boost::any_cast<string>(m["EndpointGroupId"]));
    }
    if (m.find("EndpointId") != m.end() && !m["EndpointId"].empty()) {
      endpointId = make_shared<string>(boost::any_cast<string>(m["EndpointId"]));
    }
    if (m.find("ListenerId") != m.end() && !m["ListenerId"].empty()) {
      listenerId = make_shared<string>(boost::any_cast<string>(m["ListenerId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<string>(boost::any_cast<string>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<string>(boost::any_cast<string>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~ListCustomRoutingEndpointTrafficPoliciesRequest() = default;
};
class ListCustomRoutingEndpointTrafficPoliciesResponseBodyPoliciesPortRanges : public Darabonba::Model {
public:
  shared_ptr<long> fromPort{};
  shared_ptr<long> toPort{};

  ListCustomRoutingEndpointTrafficPoliciesResponseBodyPoliciesPortRanges() {}

  explicit ListCustomRoutingEndpointTrafficPoliciesResponseBodyPoliciesPortRanges(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fromPort) {
      res["FromPort"] = boost::any(*fromPort);
    }
    if (toPort) {
      res["ToPort"] = boost::any(*toPort);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FromPort") != m.end() && !m["FromPort"].empty()) {
      fromPort = make_shared<long>(boost::any_cast<long>(m["FromPort"]));
    }
    if (m.find("ToPort") != m.end() && !m["ToPort"].empty()) {
      toPort = make_shared<long>(boost::any_cast<long>(m["ToPort"]));
    }
  }


  virtual ~ListCustomRoutingEndpointTrafficPoliciesResponseBodyPoliciesPortRanges() = default;
};
class ListCustomRoutingEndpointTrafficPoliciesResponseBodyPolicies : public Darabonba::Model {
public:
  shared_ptr<string> acceleratorId{};
  shared_ptr<string> address{};
  shared_ptr<string> endpointGroupId{};
  shared_ptr<string> endpointId{};
  shared_ptr<string> listenerId{};
  shared_ptr<string> policyId{};
  shared_ptr<vector<ListCustomRoutingEndpointTrafficPoliciesResponseBodyPoliciesPortRanges>> portRanges{};

  ListCustomRoutingEndpointTrafficPoliciesResponseBodyPolicies() {}

  explicit ListCustomRoutingEndpointTrafficPoliciesResponseBodyPolicies(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceleratorId) {
      res["AcceleratorId"] = boost::any(*acceleratorId);
    }
    if (address) {
      res["Address"] = boost::any(*address);
    }
    if (endpointGroupId) {
      res["EndpointGroupId"] = boost::any(*endpointGroupId);
    }
    if (endpointId) {
      res["EndpointId"] = boost::any(*endpointId);
    }
    if (listenerId) {
      res["ListenerId"] = boost::any(*listenerId);
    }
    if (policyId) {
      res["PolicyId"] = boost::any(*policyId);
    }
    if (portRanges) {
      vector<boost::any> temp1;
      for(auto item1:*portRanges){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PortRanges"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceleratorId") != m.end() && !m["AcceleratorId"].empty()) {
      acceleratorId = make_shared<string>(boost::any_cast<string>(m["AcceleratorId"]));
    }
    if (m.find("Address") != m.end() && !m["Address"].empty()) {
      address = make_shared<string>(boost::any_cast<string>(m["Address"]));
    }
    if (m.find("EndpointGroupId") != m.end() && !m["EndpointGroupId"].empty()) {
      endpointGroupId = make_shared<string>(boost::any_cast<string>(m["EndpointGroupId"]));
    }
    if (m.find("EndpointId") != m.end() && !m["EndpointId"].empty()) {
      endpointId = make_shared<string>(boost::any_cast<string>(m["EndpointId"]));
    }
    if (m.find("ListenerId") != m.end() && !m["ListenerId"].empty()) {
      listenerId = make_shared<string>(boost::any_cast<string>(m["ListenerId"]));
    }
    if (m.find("PolicyId") != m.end() && !m["PolicyId"].empty()) {
      policyId = make_shared<string>(boost::any_cast<string>(m["PolicyId"]));
    }
    if (m.find("PortRanges") != m.end() && !m["PortRanges"].empty()) {
      if (typeid(vector<boost::any>) == m["PortRanges"].type()) {
        vector<ListCustomRoutingEndpointTrafficPoliciesResponseBodyPoliciesPortRanges> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PortRanges"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListCustomRoutingEndpointTrafficPoliciesResponseBodyPoliciesPortRanges model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        portRanges = make_shared<vector<ListCustomRoutingEndpointTrafficPoliciesResponseBodyPoliciesPortRanges>>(expect1);
      }
    }
  }


  virtual ~ListCustomRoutingEndpointTrafficPoliciesResponseBodyPolicies() = default;
};
class ListCustomRoutingEndpointTrafficPoliciesResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<vector<ListCustomRoutingEndpointTrafficPoliciesResponseBodyPolicies>> policies{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  ListCustomRoutingEndpointTrafficPoliciesResponseBody() {}

  explicit ListCustomRoutingEndpointTrafficPoliciesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (policies) {
      vector<boost::any> temp1;
      for(auto item1:*policies){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Policies"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Policies") != m.end() && !m["Policies"].empty()) {
      if (typeid(vector<boost::any>) == m["Policies"].type()) {
        vector<ListCustomRoutingEndpointTrafficPoliciesResponseBodyPolicies> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Policies"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListCustomRoutingEndpointTrafficPoliciesResponseBodyPolicies model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        policies = make_shared<vector<ListCustomRoutingEndpointTrafficPoliciesResponseBodyPolicies>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListCustomRoutingEndpointTrafficPoliciesResponseBody() = default;
};
class ListCustomRoutingEndpointTrafficPoliciesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListCustomRoutingEndpointTrafficPoliciesResponseBody> body{};

  ListCustomRoutingEndpointTrafficPoliciesResponse() {}

  explicit ListCustomRoutingEndpointTrafficPoliciesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListCustomRoutingEndpointTrafficPoliciesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListCustomRoutingEndpointTrafficPoliciesResponseBody>(model1);
      }
    }
  }


  virtual ~ListCustomRoutingEndpointTrafficPoliciesResponse() = default;
};
class ListCustomRoutingEndpointsRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceleratorId{};
  shared_ptr<string> endpointGroupId{};
  shared_ptr<string> listenerId{};
  shared_ptr<string> pageNumber{};
  shared_ptr<string> pageSize{};
  shared_ptr<string> regionId{};

  ListCustomRoutingEndpointsRequest() {}

  explicit ListCustomRoutingEndpointsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceleratorId) {
      res["AcceleratorId"] = boost::any(*acceleratorId);
    }
    if (endpointGroupId) {
      res["EndpointGroupId"] = boost::any(*endpointGroupId);
    }
    if (listenerId) {
      res["ListenerId"] = boost::any(*listenerId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceleratorId") != m.end() && !m["AcceleratorId"].empty()) {
      acceleratorId = make_shared<string>(boost::any_cast<string>(m["AcceleratorId"]));
    }
    if (m.find("EndpointGroupId") != m.end() && !m["EndpointGroupId"].empty()) {
      endpointGroupId = make_shared<string>(boost::any_cast<string>(m["EndpointGroupId"]));
    }
    if (m.find("ListenerId") != m.end() && !m["ListenerId"].empty()) {
      listenerId = make_shared<string>(boost::any_cast<string>(m["ListenerId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<string>(boost::any_cast<string>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<string>(boost::any_cast<string>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~ListCustomRoutingEndpointsRequest() = default;
};
class ListCustomRoutingEndpointsResponseBodyEndpoints : public Darabonba::Model {
public:
  shared_ptr<string> acceleratorId{};
  shared_ptr<string> endpoint{};
  shared_ptr<string> endpointGroupId{};
  shared_ptr<string> endpointId{};
  shared_ptr<string> listenerId{};
  shared_ptr<string> trafficToEndpointPolicy{};
  shared_ptr<string> type{};

  ListCustomRoutingEndpointsResponseBodyEndpoints() {}

  explicit ListCustomRoutingEndpointsResponseBodyEndpoints(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceleratorId) {
      res["AcceleratorId"] = boost::any(*acceleratorId);
    }
    if (endpoint) {
      res["Endpoint"] = boost::any(*endpoint);
    }
    if (endpointGroupId) {
      res["EndpointGroupId"] = boost::any(*endpointGroupId);
    }
    if (endpointId) {
      res["EndpointId"] = boost::any(*endpointId);
    }
    if (listenerId) {
      res["ListenerId"] = boost::any(*listenerId);
    }
    if (trafficToEndpointPolicy) {
      res["TrafficToEndpointPolicy"] = boost::any(*trafficToEndpointPolicy);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceleratorId") != m.end() && !m["AcceleratorId"].empty()) {
      acceleratorId = make_shared<string>(boost::any_cast<string>(m["AcceleratorId"]));
    }
    if (m.find("Endpoint") != m.end() && !m["Endpoint"].empty()) {
      endpoint = make_shared<string>(boost::any_cast<string>(m["Endpoint"]));
    }
    if (m.find("EndpointGroupId") != m.end() && !m["EndpointGroupId"].empty()) {
      endpointGroupId = make_shared<string>(boost::any_cast<string>(m["EndpointGroupId"]));
    }
    if (m.find("EndpointId") != m.end() && !m["EndpointId"].empty()) {
      endpointId = make_shared<string>(boost::any_cast<string>(m["EndpointId"]));
    }
    if (m.find("ListenerId") != m.end() && !m["ListenerId"].empty()) {
      listenerId = make_shared<string>(boost::any_cast<string>(m["ListenerId"]));
    }
    if (m.find("TrafficToEndpointPolicy") != m.end() && !m["TrafficToEndpointPolicy"].empty()) {
      trafficToEndpointPolicy = make_shared<string>(boost::any_cast<string>(m["TrafficToEndpointPolicy"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListCustomRoutingEndpointsResponseBodyEndpoints() = default;
};
class ListCustomRoutingEndpointsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListCustomRoutingEndpointsResponseBodyEndpoints>> endpoints{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  ListCustomRoutingEndpointsResponseBody() {}

  explicit ListCustomRoutingEndpointsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endpoints) {
      vector<boost::any> temp1;
      for(auto item1:*endpoints){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Endpoints"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Endpoints") != m.end() && !m["Endpoints"].empty()) {
      if (typeid(vector<boost::any>) == m["Endpoints"].type()) {
        vector<ListCustomRoutingEndpointsResponseBodyEndpoints> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Endpoints"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListCustomRoutingEndpointsResponseBodyEndpoints model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        endpoints = make_shared<vector<ListCustomRoutingEndpointsResponseBodyEndpoints>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListCustomRoutingEndpointsResponseBody() = default;
};
class ListCustomRoutingEndpointsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListCustomRoutingEndpointsResponseBody> body{};

  ListCustomRoutingEndpointsResponse() {}

  explicit ListCustomRoutingEndpointsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListCustomRoutingEndpointsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListCustomRoutingEndpointsResponseBody>(model1);
      }
    }
  }


  virtual ~ListCustomRoutingEndpointsResponse() = default;
};
class ListCustomRoutingPortMappingsRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceleratorId{};
  shared_ptr<string> endpointGroupId{};
  shared_ptr<string> listenerId{};
  shared_ptr<string> pageNumber{};
  shared_ptr<string> pageSize{};
  shared_ptr<string> regionId{};

  ListCustomRoutingPortMappingsRequest() {}

  explicit ListCustomRoutingPortMappingsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceleratorId) {
      res["AcceleratorId"] = boost::any(*acceleratorId);
    }
    if (endpointGroupId) {
      res["EndpointGroupId"] = boost::any(*endpointGroupId);
    }
    if (listenerId) {
      res["ListenerId"] = boost::any(*listenerId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceleratorId") != m.end() && !m["AcceleratorId"].empty()) {
      acceleratorId = make_shared<string>(boost::any_cast<string>(m["AcceleratorId"]));
    }
    if (m.find("EndpointGroupId") != m.end() && !m["EndpointGroupId"].empty()) {
      endpointGroupId = make_shared<string>(boost::any_cast<string>(m["EndpointGroupId"]));
    }
    if (m.find("ListenerId") != m.end() && !m["ListenerId"].empty()) {
      listenerId = make_shared<string>(boost::any_cast<string>(m["ListenerId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<string>(boost::any_cast<string>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<string>(boost::any_cast<string>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~ListCustomRoutingPortMappingsRequest() = default;
};
class ListCustomRoutingPortMappingsResponseBodyPortMappingsDestinationSocketAddress : public Darabonba::Model {
public:
  shared_ptr<string> ipAddress{};
  shared_ptr<long> port{};

  ListCustomRoutingPortMappingsResponseBodyPortMappingsDestinationSocketAddress() {}

  explicit ListCustomRoutingPortMappingsResponseBodyPortMappingsDestinationSocketAddress(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ipAddress) {
      res["IpAddress"] = boost::any(*ipAddress);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IpAddress") != m.end() && !m["IpAddress"].empty()) {
      ipAddress = make_shared<string>(boost::any_cast<string>(m["IpAddress"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<long>(boost::any_cast<long>(m["Port"]));
    }
  }


  virtual ~ListCustomRoutingPortMappingsResponseBodyPortMappingsDestinationSocketAddress() = default;
};
class ListCustomRoutingPortMappingsResponseBodyPortMappings : public Darabonba::Model {
public:
  shared_ptr<string> acceleratorId{};
  shared_ptr<long> acceleratorPort{};
  shared_ptr<ListCustomRoutingPortMappingsResponseBodyPortMappingsDestinationSocketAddress> destinationSocketAddress{};
  shared_ptr<string> destinationTrafficState{};
  shared_ptr<string> endpointGroupId{};
  shared_ptr<string> endpointGroupRegion{};
  shared_ptr<string> endpointId{};
  shared_ptr<string> listenerId{};
  shared_ptr<vector<string>> protocols{};
  shared_ptr<string> vswitch{};

  ListCustomRoutingPortMappingsResponseBodyPortMappings() {}

  explicit ListCustomRoutingPortMappingsResponseBodyPortMappings(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceleratorId) {
      res["AcceleratorId"] = boost::any(*acceleratorId);
    }
    if (acceleratorPort) {
      res["AcceleratorPort"] = boost::any(*acceleratorPort);
    }
    if (destinationSocketAddress) {
      res["DestinationSocketAddress"] = destinationSocketAddress ? boost::any(destinationSocketAddress->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (destinationTrafficState) {
      res["DestinationTrafficState"] = boost::any(*destinationTrafficState);
    }
    if (endpointGroupId) {
      res["EndpointGroupId"] = boost::any(*endpointGroupId);
    }
    if (endpointGroupRegion) {
      res["EndpointGroupRegion"] = boost::any(*endpointGroupRegion);
    }
    if (endpointId) {
      res["EndpointId"] = boost::any(*endpointId);
    }
    if (listenerId) {
      res["ListenerId"] = boost::any(*listenerId);
    }
    if (protocols) {
      res["Protocols"] = boost::any(*protocols);
    }
    if (vswitch) {
      res["Vswitch"] = boost::any(*vswitch);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceleratorId") != m.end() && !m["AcceleratorId"].empty()) {
      acceleratorId = make_shared<string>(boost::any_cast<string>(m["AcceleratorId"]));
    }
    if (m.find("AcceleratorPort") != m.end() && !m["AcceleratorPort"].empty()) {
      acceleratorPort = make_shared<long>(boost::any_cast<long>(m["AcceleratorPort"]));
    }
    if (m.find("DestinationSocketAddress") != m.end() && !m["DestinationSocketAddress"].empty()) {
      if (typeid(map<string, boost::any>) == m["DestinationSocketAddress"].type()) {
        ListCustomRoutingPortMappingsResponseBodyPortMappingsDestinationSocketAddress model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DestinationSocketAddress"]));
        destinationSocketAddress = make_shared<ListCustomRoutingPortMappingsResponseBodyPortMappingsDestinationSocketAddress>(model1);
      }
    }
    if (m.find("DestinationTrafficState") != m.end() && !m["DestinationTrafficState"].empty()) {
      destinationTrafficState = make_shared<string>(boost::any_cast<string>(m["DestinationTrafficState"]));
    }
    if (m.find("EndpointGroupId") != m.end() && !m["EndpointGroupId"].empty()) {
      endpointGroupId = make_shared<string>(boost::any_cast<string>(m["EndpointGroupId"]));
    }
    if (m.find("EndpointGroupRegion") != m.end() && !m["EndpointGroupRegion"].empty()) {
      endpointGroupRegion = make_shared<string>(boost::any_cast<string>(m["EndpointGroupRegion"]));
    }
    if (m.find("EndpointId") != m.end() && !m["EndpointId"].empty()) {
      endpointId = make_shared<string>(boost::any_cast<string>(m["EndpointId"]));
    }
    if (m.find("ListenerId") != m.end() && !m["ListenerId"].empty()) {
      listenerId = make_shared<string>(boost::any_cast<string>(m["ListenerId"]));
    }
    if (m.find("Protocols") != m.end() && !m["Protocols"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Protocols"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Protocols"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      protocols = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Vswitch") != m.end() && !m["Vswitch"].empty()) {
      vswitch = make_shared<string>(boost::any_cast<string>(m["Vswitch"]));
    }
  }


  virtual ~ListCustomRoutingPortMappingsResponseBodyPortMappings() = default;
};
class ListCustomRoutingPortMappingsResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<vector<ListCustomRoutingPortMappingsResponseBodyPortMappings>> portMappings{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  ListCustomRoutingPortMappingsResponseBody() {}

  explicit ListCustomRoutingPortMappingsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (portMappings) {
      vector<boost::any> temp1;
      for(auto item1:*portMappings){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PortMappings"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("PortMappings") != m.end() && !m["PortMappings"].empty()) {
      if (typeid(vector<boost::any>) == m["PortMappings"].type()) {
        vector<ListCustomRoutingPortMappingsResponseBodyPortMappings> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PortMappings"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListCustomRoutingPortMappingsResponseBodyPortMappings model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        portMappings = make_shared<vector<ListCustomRoutingPortMappingsResponseBodyPortMappings>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListCustomRoutingPortMappingsResponseBody() = default;
};
class ListCustomRoutingPortMappingsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListCustomRoutingPortMappingsResponseBody> body{};

  ListCustomRoutingPortMappingsResponse() {}

  explicit ListCustomRoutingPortMappingsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListCustomRoutingPortMappingsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListCustomRoutingPortMappingsResponseBody>(model1);
      }
    }
  }


  virtual ~ListCustomRoutingPortMappingsResponse() = default;
};
class ListCustomRoutingPortMappingsByDestinationRequest : public Darabonba::Model {
public:
  shared_ptr<string> destinationAddress{};
  shared_ptr<string> endpointId{};
  shared_ptr<string> pageNumber{};
  shared_ptr<string> pageSize{};
  shared_ptr<string> regionId{};

  ListCustomRoutingPortMappingsByDestinationRequest() {}

  explicit ListCustomRoutingPortMappingsByDestinationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (destinationAddress) {
      res["DestinationAddress"] = boost::any(*destinationAddress);
    }
    if (endpointId) {
      res["EndpointId"] = boost::any(*endpointId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DestinationAddress") != m.end() && !m["DestinationAddress"].empty()) {
      destinationAddress = make_shared<string>(boost::any_cast<string>(m["DestinationAddress"]));
    }
    if (m.find("EndpointId") != m.end() && !m["EndpointId"].empty()) {
      endpointId = make_shared<string>(boost::any_cast<string>(m["EndpointId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<string>(boost::any_cast<string>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<string>(boost::any_cast<string>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~ListCustomRoutingPortMappingsByDestinationRequest() = default;
};
class ListCustomRoutingPortMappingsByDestinationResponseBodyPortMappingsDestinationSocketAddress : public Darabonba::Model {
public:
  shared_ptr<string> ipAddress{};
  shared_ptr<long> port{};

  ListCustomRoutingPortMappingsByDestinationResponseBodyPortMappingsDestinationSocketAddress() {}

  explicit ListCustomRoutingPortMappingsByDestinationResponseBodyPortMappingsDestinationSocketAddress(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ipAddress) {
      res["IpAddress"] = boost::any(*ipAddress);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IpAddress") != m.end() && !m["IpAddress"].empty()) {
      ipAddress = make_shared<string>(boost::any_cast<string>(m["IpAddress"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<long>(boost::any_cast<long>(m["Port"]));
    }
  }


  virtual ~ListCustomRoutingPortMappingsByDestinationResponseBodyPortMappingsDestinationSocketAddress() = default;
};
class ListCustomRoutingPortMappingsByDestinationResponseBodyPortMappings : public Darabonba::Model {
public:
  shared_ptr<string> acceleratorId{};
  shared_ptr<long> acceleratorPort{};
  shared_ptr<ListCustomRoutingPortMappingsByDestinationResponseBodyPortMappingsDestinationSocketAddress> destinationSocketAddress{};
  shared_ptr<string> destinationTrafficState{};
  shared_ptr<string> endpointGroupId{};
  shared_ptr<string> endpointGroupRegion{};
  shared_ptr<string> endpointId{};
  shared_ptr<string> listenerId{};
  shared_ptr<vector<string>> protocols{};
  shared_ptr<string> vswitch{};

  ListCustomRoutingPortMappingsByDestinationResponseBodyPortMappings() {}

  explicit ListCustomRoutingPortMappingsByDestinationResponseBodyPortMappings(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceleratorId) {
      res["AcceleratorId"] = boost::any(*acceleratorId);
    }
    if (acceleratorPort) {
      res["AcceleratorPort"] = boost::any(*acceleratorPort);
    }
    if (destinationSocketAddress) {
      res["DestinationSocketAddress"] = destinationSocketAddress ? boost::any(destinationSocketAddress->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (destinationTrafficState) {
      res["DestinationTrafficState"] = boost::any(*destinationTrafficState);
    }
    if (endpointGroupId) {
      res["EndpointGroupId"] = boost::any(*endpointGroupId);
    }
    if (endpointGroupRegion) {
      res["EndpointGroupRegion"] = boost::any(*endpointGroupRegion);
    }
    if (endpointId) {
      res["EndpointId"] = boost::any(*endpointId);
    }
    if (listenerId) {
      res["ListenerId"] = boost::any(*listenerId);
    }
    if (protocols) {
      res["Protocols"] = boost::any(*protocols);
    }
    if (vswitch) {
      res["Vswitch"] = boost::any(*vswitch);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceleratorId") != m.end() && !m["AcceleratorId"].empty()) {
      acceleratorId = make_shared<string>(boost::any_cast<string>(m["AcceleratorId"]));
    }
    if (m.find("AcceleratorPort") != m.end() && !m["AcceleratorPort"].empty()) {
      acceleratorPort = make_shared<long>(boost::any_cast<long>(m["AcceleratorPort"]));
    }
    if (m.find("DestinationSocketAddress") != m.end() && !m["DestinationSocketAddress"].empty()) {
      if (typeid(map<string, boost::any>) == m["DestinationSocketAddress"].type()) {
        ListCustomRoutingPortMappingsByDestinationResponseBodyPortMappingsDestinationSocketAddress model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DestinationSocketAddress"]));
        destinationSocketAddress = make_shared<ListCustomRoutingPortMappingsByDestinationResponseBodyPortMappingsDestinationSocketAddress>(model1);
      }
    }
    if (m.find("DestinationTrafficState") != m.end() && !m["DestinationTrafficState"].empty()) {
      destinationTrafficState = make_shared<string>(boost::any_cast<string>(m["DestinationTrafficState"]));
    }
    if (m.find("EndpointGroupId") != m.end() && !m["EndpointGroupId"].empty()) {
      endpointGroupId = make_shared<string>(boost::any_cast<string>(m["EndpointGroupId"]));
    }
    if (m.find("EndpointGroupRegion") != m.end() && !m["EndpointGroupRegion"].empty()) {
      endpointGroupRegion = make_shared<string>(boost::any_cast<string>(m["EndpointGroupRegion"]));
    }
    if (m.find("EndpointId") != m.end() && !m["EndpointId"].empty()) {
      endpointId = make_shared<string>(boost::any_cast<string>(m["EndpointId"]));
    }
    if (m.find("ListenerId") != m.end() && !m["ListenerId"].empty()) {
      listenerId = make_shared<string>(boost::any_cast<string>(m["ListenerId"]));
    }
    if (m.find("Protocols") != m.end() && !m["Protocols"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Protocols"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Protocols"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      protocols = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Vswitch") != m.end() && !m["Vswitch"].empty()) {
      vswitch = make_shared<string>(boost::any_cast<string>(m["Vswitch"]));
    }
  }


  virtual ~ListCustomRoutingPortMappingsByDestinationResponseBodyPortMappings() = default;
};
class ListCustomRoutingPortMappingsByDestinationResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<vector<ListCustomRoutingPortMappingsByDestinationResponseBodyPortMappings>> portMappings{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  ListCustomRoutingPortMappingsByDestinationResponseBody() {}

  explicit ListCustomRoutingPortMappingsByDestinationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (portMappings) {
      vector<boost::any> temp1;
      for(auto item1:*portMappings){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PortMappings"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("PortMappings") != m.end() && !m["PortMappings"].empty()) {
      if (typeid(vector<boost::any>) == m["PortMappings"].type()) {
        vector<ListCustomRoutingPortMappingsByDestinationResponseBodyPortMappings> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PortMappings"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListCustomRoutingPortMappingsByDestinationResponseBodyPortMappings model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        portMappings = make_shared<vector<ListCustomRoutingPortMappingsByDestinationResponseBodyPortMappings>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListCustomRoutingPortMappingsByDestinationResponseBody() = default;
};
class ListCustomRoutingPortMappingsByDestinationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListCustomRoutingPortMappingsByDestinationResponseBody> body{};

  ListCustomRoutingPortMappingsByDestinationResponse() {}

  explicit ListCustomRoutingPortMappingsByDestinationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListCustomRoutingPortMappingsByDestinationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListCustomRoutingPortMappingsByDestinationResponseBody>(model1);
      }
    }
  }


  virtual ~ListCustomRoutingPortMappingsByDestinationResponse() = default;
};
class ListDomainsRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceleratorId{};
  shared_ptr<string> domain{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regionId{};
  shared_ptr<string> state{};

  ListDomainsRequest() {}

  explicit ListDomainsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceleratorId) {
      res["AcceleratorId"] = boost::any(*acceleratorId);
    }
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceleratorId") != m.end() && !m["AcceleratorId"].empty()) {
      acceleratorId = make_shared<string>(boost::any_cast<string>(m["AcceleratorId"]));
    }
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
  }


  virtual ~ListDomainsRequest() = default;
};
class ListDomainsResponseBodyDomainsAccelerators : public Darabonba::Model {
public:
  shared_ptr<string> acceleratorId{};
  shared_ptr<string> name{};

  ListDomainsResponseBodyDomainsAccelerators() {}

  explicit ListDomainsResponseBodyDomainsAccelerators(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceleratorId) {
      res["AcceleratorId"] = boost::any(*acceleratorId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceleratorId") != m.end() && !m["AcceleratorId"].empty()) {
      acceleratorId = make_shared<string>(boost::any_cast<string>(m["AcceleratorId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~ListDomainsResponseBodyDomainsAccelerators() = default;
};
class ListDomainsResponseBodyDomains : public Darabonba::Model {
public:
  shared_ptr<vector<ListDomainsResponseBodyDomainsAccelerators>> accelerators{};
  shared_ptr<string> domain{};
  shared_ptr<string> state{};

  ListDomainsResponseBodyDomains() {}

  explicit ListDomainsResponseBodyDomains(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accelerators) {
      vector<boost::any> temp1;
      for(auto item1:*accelerators){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Accelerators"] = boost::any(temp1);
    }
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Accelerators") != m.end() && !m["Accelerators"].empty()) {
      if (typeid(vector<boost::any>) == m["Accelerators"].type()) {
        vector<ListDomainsResponseBodyDomainsAccelerators> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Accelerators"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDomainsResponseBodyDomainsAccelerators model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        accelerators = make_shared<vector<ListDomainsResponseBodyDomainsAccelerators>>(expect1);
      }
    }
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
  }


  virtual ~ListDomainsResponseBodyDomains() = default;
};
class ListDomainsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListDomainsResponseBodyDomains>> domains{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  ListDomainsResponseBody() {}

  explicit ListDomainsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domains) {
      vector<boost::any> temp1;
      for(auto item1:*domains){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Domains"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Domains") != m.end() && !m["Domains"].empty()) {
      if (typeid(vector<boost::any>) == m["Domains"].type()) {
        vector<ListDomainsResponseBodyDomains> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Domains"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDomainsResponseBodyDomains model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        domains = make_shared<vector<ListDomainsResponseBodyDomains>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListDomainsResponseBody() = default;
};
class ListDomainsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListDomainsResponseBody> body{};

  ListDomainsResponse() {}

  explicit ListDomainsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListDomainsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListDomainsResponseBody>(model1);
      }
    }
  }


  virtual ~ListDomainsResponse() = default;
};
class ListEndpointGroupsRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  ListEndpointGroupsRequestTag() {}

  explicit ListEndpointGroupsRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~ListEndpointGroupsRequestTag() = default;
};
class ListEndpointGroupsRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceleratorId{};
  shared_ptr<string> accessLogSwitch{};
  shared_ptr<string> endpointGroupId{};
  shared_ptr<string> endpointGroupType{};
  shared_ptr<string> listenerId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regionId{};
  shared_ptr<vector<ListEndpointGroupsRequestTag>> tag{};

  ListEndpointGroupsRequest() {}

  explicit ListEndpointGroupsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceleratorId) {
      res["AcceleratorId"] = boost::any(*acceleratorId);
    }
    if (accessLogSwitch) {
      res["AccessLogSwitch"] = boost::any(*accessLogSwitch);
    }
    if (endpointGroupId) {
      res["EndpointGroupId"] = boost::any(*endpointGroupId);
    }
    if (endpointGroupType) {
      res["EndpointGroupType"] = boost::any(*endpointGroupType);
    }
    if (listenerId) {
      res["ListenerId"] = boost::any(*listenerId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceleratorId") != m.end() && !m["AcceleratorId"].empty()) {
      acceleratorId = make_shared<string>(boost::any_cast<string>(m["AcceleratorId"]));
    }
    if (m.find("AccessLogSwitch") != m.end() && !m["AccessLogSwitch"].empty()) {
      accessLogSwitch = make_shared<string>(boost::any_cast<string>(m["AccessLogSwitch"]));
    }
    if (m.find("EndpointGroupId") != m.end() && !m["EndpointGroupId"].empty()) {
      endpointGroupId = make_shared<string>(boost::any_cast<string>(m["EndpointGroupId"]));
    }
    if (m.find("EndpointGroupType") != m.end() && !m["EndpointGroupType"].empty()) {
      endpointGroupType = make_shared<string>(boost::any_cast<string>(m["EndpointGroupType"]));
    }
    if (m.find("ListenerId") != m.end() && !m["ListenerId"].empty()) {
      listenerId = make_shared<string>(boost::any_cast<string>(m["ListenerId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<ListEndpointGroupsRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListEndpointGroupsRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<ListEndpointGroupsRequestTag>>(expect1);
      }
    }
  }


  virtual ~ListEndpointGroupsRequest() = default;
};
class ListEndpointGroupsResponseBodyEndpointGroupsEndpointConfigurations : public Darabonba::Model {
public:
  shared_ptr<bool> enableClientIPPreservation{};
  shared_ptr<string> endpoint{};
  shared_ptr<string> endpointId{};
  shared_ptr<long> probePort{};
  shared_ptr<string> probeProtocol{};
  shared_ptr<string> type{};
  shared_ptr<long> weight{};

  ListEndpointGroupsResponseBodyEndpointGroupsEndpointConfigurations() {}

  explicit ListEndpointGroupsResponseBodyEndpointGroupsEndpointConfigurations(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (enableClientIPPreservation) {
      res["EnableClientIPPreservation"] = boost::any(*enableClientIPPreservation);
    }
    if (endpoint) {
      res["Endpoint"] = boost::any(*endpoint);
    }
    if (endpointId) {
      res["EndpointId"] = boost::any(*endpointId);
    }
    if (probePort) {
      res["ProbePort"] = boost::any(*probePort);
    }
    if (probeProtocol) {
      res["ProbeProtocol"] = boost::any(*probeProtocol);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (weight) {
      res["Weight"] = boost::any(*weight);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EnableClientIPPreservation") != m.end() && !m["EnableClientIPPreservation"].empty()) {
      enableClientIPPreservation = make_shared<bool>(boost::any_cast<bool>(m["EnableClientIPPreservation"]));
    }
    if (m.find("Endpoint") != m.end() && !m["Endpoint"].empty()) {
      endpoint = make_shared<string>(boost::any_cast<string>(m["Endpoint"]));
    }
    if (m.find("EndpointId") != m.end() && !m["EndpointId"].empty()) {
      endpointId = make_shared<string>(boost::any_cast<string>(m["EndpointId"]));
    }
    if (m.find("ProbePort") != m.end() && !m["ProbePort"].empty()) {
      probePort = make_shared<long>(boost::any_cast<long>(m["ProbePort"]));
    }
    if (m.find("ProbeProtocol") != m.end() && !m["ProbeProtocol"].empty()) {
      probeProtocol = make_shared<string>(boost::any_cast<string>(m["ProbeProtocol"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Weight") != m.end() && !m["Weight"].empty()) {
      weight = make_shared<long>(boost::any_cast<long>(m["Weight"]));
    }
  }


  virtual ~ListEndpointGroupsResponseBodyEndpointGroupsEndpointConfigurations() = default;
};
class ListEndpointGroupsResponseBodyEndpointGroupsPortOverrides : public Darabonba::Model {
public:
  shared_ptr<long> endpointPort{};
  shared_ptr<long> listenerPort{};

  ListEndpointGroupsResponseBodyEndpointGroupsPortOverrides() {}

  explicit ListEndpointGroupsResponseBodyEndpointGroupsPortOverrides(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endpointPort) {
      res["EndpointPort"] = boost::any(*endpointPort);
    }
    if (listenerPort) {
      res["ListenerPort"] = boost::any(*listenerPort);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndpointPort") != m.end() && !m["EndpointPort"].empty()) {
      endpointPort = make_shared<long>(boost::any_cast<long>(m["EndpointPort"]));
    }
    if (m.find("ListenerPort") != m.end() && !m["ListenerPort"].empty()) {
      listenerPort = make_shared<long>(boost::any_cast<long>(m["ListenerPort"]));
    }
  }


  virtual ~ListEndpointGroupsResponseBodyEndpointGroupsPortOverrides() = default;
};
class ListEndpointGroupsResponseBodyEndpointGroupsTags : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  ListEndpointGroupsResponseBodyEndpointGroupsTags() {}

  explicit ListEndpointGroupsResponseBodyEndpointGroupsTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~ListEndpointGroupsResponseBodyEndpointGroupsTags() = default;
};
class ListEndpointGroupsResponseBodyEndpointGroups : public Darabonba::Model {
public:
  shared_ptr<string> acceleratorId{};
  shared_ptr<string> description{};
  shared_ptr<vector<ListEndpointGroupsResponseBodyEndpointGroupsEndpointConfigurations>> endpointConfigurations{};
  shared_ptr<string> endpointGroupId{};
  shared_ptr<vector<string>> endpointGroupIpList{};
  shared_ptr<string> endpointGroupRegion{};
  shared_ptr<string> endpointGroupType{};
  shared_ptr<vector<string>> endpointGroupUnconfirmedIpList{};
  shared_ptr<string> endpointRequestProtocol{};
  shared_ptr<vector<string>> forwardingRuleIds{};
  shared_ptr<bool> healthCheckEnabled{};
  shared_ptr<long> healthCheckIntervalSeconds{};
  shared_ptr<string> healthCheckPath{};
  shared_ptr<long> healthCheckPort{};
  shared_ptr<string> healthCheckProtocol{};
  shared_ptr<string> listenerId{};
  shared_ptr<string> name{};
  shared_ptr<vector<ListEndpointGroupsResponseBodyEndpointGroupsPortOverrides>> portOverrides{};
  shared_ptr<string> state{};
  shared_ptr<vector<ListEndpointGroupsResponseBodyEndpointGroupsTags>> tags{};
  shared_ptr<long> thresholdCount{};
  shared_ptr<long> trafficPercentage{};

  ListEndpointGroupsResponseBodyEndpointGroups() {}

  explicit ListEndpointGroupsResponseBodyEndpointGroups(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceleratorId) {
      res["AcceleratorId"] = boost::any(*acceleratorId);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (endpointConfigurations) {
      vector<boost::any> temp1;
      for(auto item1:*endpointConfigurations){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["EndpointConfigurations"] = boost::any(temp1);
    }
    if (endpointGroupId) {
      res["EndpointGroupId"] = boost::any(*endpointGroupId);
    }
    if (endpointGroupIpList) {
      res["EndpointGroupIpList"] = boost::any(*endpointGroupIpList);
    }
    if (endpointGroupRegion) {
      res["EndpointGroupRegion"] = boost::any(*endpointGroupRegion);
    }
    if (endpointGroupType) {
      res["EndpointGroupType"] = boost::any(*endpointGroupType);
    }
    if (endpointGroupUnconfirmedIpList) {
      res["EndpointGroupUnconfirmedIpList"] = boost::any(*endpointGroupUnconfirmedIpList);
    }
    if (endpointRequestProtocol) {
      res["EndpointRequestProtocol"] = boost::any(*endpointRequestProtocol);
    }
    if (forwardingRuleIds) {
      res["ForwardingRuleIds"] = boost::any(*forwardingRuleIds);
    }
    if (healthCheckEnabled) {
      res["HealthCheckEnabled"] = boost::any(*healthCheckEnabled);
    }
    if (healthCheckIntervalSeconds) {
      res["HealthCheckIntervalSeconds"] = boost::any(*healthCheckIntervalSeconds);
    }
    if (healthCheckPath) {
      res["HealthCheckPath"] = boost::any(*healthCheckPath);
    }
    if (healthCheckPort) {
      res["HealthCheckPort"] = boost::any(*healthCheckPort);
    }
    if (healthCheckProtocol) {
      res["HealthCheckProtocol"] = boost::any(*healthCheckProtocol);
    }
    if (listenerId) {
      res["ListenerId"] = boost::any(*listenerId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (portOverrides) {
      vector<boost::any> temp1;
      for(auto item1:*portOverrides){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PortOverrides"] = boost::any(temp1);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tags"] = boost::any(temp1);
    }
    if (thresholdCount) {
      res["ThresholdCount"] = boost::any(*thresholdCount);
    }
    if (trafficPercentage) {
      res["TrafficPercentage"] = boost::any(*trafficPercentage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceleratorId") != m.end() && !m["AcceleratorId"].empty()) {
      acceleratorId = make_shared<string>(boost::any_cast<string>(m["AcceleratorId"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("EndpointConfigurations") != m.end() && !m["EndpointConfigurations"].empty()) {
      if (typeid(vector<boost::any>) == m["EndpointConfigurations"].type()) {
        vector<ListEndpointGroupsResponseBodyEndpointGroupsEndpointConfigurations> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["EndpointConfigurations"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListEndpointGroupsResponseBodyEndpointGroupsEndpointConfigurations model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        endpointConfigurations = make_shared<vector<ListEndpointGroupsResponseBodyEndpointGroupsEndpointConfigurations>>(expect1);
      }
    }
    if (m.find("EndpointGroupId") != m.end() && !m["EndpointGroupId"].empty()) {
      endpointGroupId = make_shared<string>(boost::any_cast<string>(m["EndpointGroupId"]));
    }
    if (m.find("EndpointGroupIpList") != m.end() && !m["EndpointGroupIpList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["EndpointGroupIpList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["EndpointGroupIpList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      endpointGroupIpList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("EndpointGroupRegion") != m.end() && !m["EndpointGroupRegion"].empty()) {
      endpointGroupRegion = make_shared<string>(boost::any_cast<string>(m["EndpointGroupRegion"]));
    }
    if (m.find("EndpointGroupType") != m.end() && !m["EndpointGroupType"].empty()) {
      endpointGroupType = make_shared<string>(boost::any_cast<string>(m["EndpointGroupType"]));
    }
    if (m.find("EndpointGroupUnconfirmedIpList") != m.end() && !m["EndpointGroupUnconfirmedIpList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["EndpointGroupUnconfirmedIpList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["EndpointGroupUnconfirmedIpList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      endpointGroupUnconfirmedIpList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("EndpointRequestProtocol") != m.end() && !m["EndpointRequestProtocol"].empty()) {
      endpointRequestProtocol = make_shared<string>(boost::any_cast<string>(m["EndpointRequestProtocol"]));
    }
    if (m.find("ForwardingRuleIds") != m.end() && !m["ForwardingRuleIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ForwardingRuleIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ForwardingRuleIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      forwardingRuleIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("HealthCheckEnabled") != m.end() && !m["HealthCheckEnabled"].empty()) {
      healthCheckEnabled = make_shared<bool>(boost::any_cast<bool>(m["HealthCheckEnabled"]));
    }
    if (m.find("HealthCheckIntervalSeconds") != m.end() && !m["HealthCheckIntervalSeconds"].empty()) {
      healthCheckIntervalSeconds = make_shared<long>(boost::any_cast<long>(m["HealthCheckIntervalSeconds"]));
    }
    if (m.find("HealthCheckPath") != m.end() && !m["HealthCheckPath"].empty()) {
      healthCheckPath = make_shared<string>(boost::any_cast<string>(m["HealthCheckPath"]));
    }
    if (m.find("HealthCheckPort") != m.end() && !m["HealthCheckPort"].empty()) {
      healthCheckPort = make_shared<long>(boost::any_cast<long>(m["HealthCheckPort"]));
    }
    if (m.find("HealthCheckProtocol") != m.end() && !m["HealthCheckProtocol"].empty()) {
      healthCheckProtocol = make_shared<string>(boost::any_cast<string>(m["HealthCheckProtocol"]));
    }
    if (m.find("ListenerId") != m.end() && !m["ListenerId"].empty()) {
      listenerId = make_shared<string>(boost::any_cast<string>(m["ListenerId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("PortOverrides") != m.end() && !m["PortOverrides"].empty()) {
      if (typeid(vector<boost::any>) == m["PortOverrides"].type()) {
        vector<ListEndpointGroupsResponseBodyEndpointGroupsPortOverrides> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PortOverrides"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListEndpointGroupsResponseBodyEndpointGroupsPortOverrides model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        portOverrides = make_shared<vector<ListEndpointGroupsResponseBodyEndpointGroupsPortOverrides>>(expect1);
      }
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(vector<boost::any>) == m["Tags"].type()) {
        vector<ListEndpointGroupsResponseBodyEndpointGroupsTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListEndpointGroupsResponseBodyEndpointGroupsTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<ListEndpointGroupsResponseBodyEndpointGroupsTags>>(expect1);
      }
    }
    if (m.find("ThresholdCount") != m.end() && !m["ThresholdCount"].empty()) {
      thresholdCount = make_shared<long>(boost::any_cast<long>(m["ThresholdCount"]));
    }
    if (m.find("TrafficPercentage") != m.end() && !m["TrafficPercentage"].empty()) {
      trafficPercentage = make_shared<long>(boost::any_cast<long>(m["TrafficPercentage"]));
    }
  }


  virtual ~ListEndpointGroupsResponseBodyEndpointGroups() = default;
};
class ListEndpointGroupsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListEndpointGroupsResponseBodyEndpointGroups>> endpointGroups{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  ListEndpointGroupsResponseBody() {}

  explicit ListEndpointGroupsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endpointGroups) {
      vector<boost::any> temp1;
      for(auto item1:*endpointGroups){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["EndpointGroups"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndpointGroups") != m.end() && !m["EndpointGroups"].empty()) {
      if (typeid(vector<boost::any>) == m["EndpointGroups"].type()) {
        vector<ListEndpointGroupsResponseBodyEndpointGroups> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["EndpointGroups"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListEndpointGroupsResponseBodyEndpointGroups model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        endpointGroups = make_shared<vector<ListEndpointGroupsResponseBodyEndpointGroups>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListEndpointGroupsResponseBody() = default;
};
class ListEndpointGroupsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListEndpointGroupsResponseBody> body{};

  ListEndpointGroupsResponse() {}

  explicit ListEndpointGroupsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListEndpointGroupsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListEndpointGroupsResponseBody>(model1);
      }
    }
  }


  virtual ~ListEndpointGroupsResponse() = default;
};
class ListForwardingRulesRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceleratorId{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> forwardingRuleId{};
  shared_ptr<string> listenerId{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> regionId{};

  ListForwardingRulesRequest() {}

  explicit ListForwardingRulesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceleratorId) {
      res["AcceleratorId"] = boost::any(*acceleratorId);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (forwardingRuleId) {
      res["ForwardingRuleId"] = boost::any(*forwardingRuleId);
    }
    if (listenerId) {
      res["ListenerId"] = boost::any(*listenerId);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceleratorId") != m.end() && !m["AcceleratorId"].empty()) {
      acceleratorId = make_shared<string>(boost::any_cast<string>(m["AcceleratorId"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("ForwardingRuleId") != m.end() && !m["ForwardingRuleId"].empty()) {
      forwardingRuleId = make_shared<string>(boost::any_cast<string>(m["ForwardingRuleId"]));
    }
    if (m.find("ListenerId") != m.end() && !m["ListenerId"].empty()) {
      listenerId = make_shared<string>(boost::any_cast<string>(m["ListenerId"]));
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~ListForwardingRulesRequest() = default;
};
class ListForwardingRulesResponseBodyForwardingRulesRuleActionsForwardGroupConfigServerGroupTuples : public Darabonba::Model {
public:
  shared_ptr<string> endpointGroupId{};

  ListForwardingRulesResponseBodyForwardingRulesRuleActionsForwardGroupConfigServerGroupTuples() {}

  explicit ListForwardingRulesResponseBodyForwardingRulesRuleActionsForwardGroupConfigServerGroupTuples(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endpointGroupId) {
      res["EndpointGroupId"] = boost::any(*endpointGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndpointGroupId") != m.end() && !m["EndpointGroupId"].empty()) {
      endpointGroupId = make_shared<string>(boost::any_cast<string>(m["EndpointGroupId"]));
    }
  }


  virtual ~ListForwardingRulesResponseBodyForwardingRulesRuleActionsForwardGroupConfigServerGroupTuples() = default;
};
class ListForwardingRulesResponseBodyForwardingRulesRuleActionsForwardGroupConfig : public Darabonba::Model {
public:
  shared_ptr<vector<ListForwardingRulesResponseBodyForwardingRulesRuleActionsForwardGroupConfigServerGroupTuples>> serverGroupTuples{};

  ListForwardingRulesResponseBodyForwardingRulesRuleActionsForwardGroupConfig() {}

  explicit ListForwardingRulesResponseBodyForwardingRulesRuleActionsForwardGroupConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (serverGroupTuples) {
      vector<boost::any> temp1;
      for(auto item1:*serverGroupTuples){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ServerGroupTuples"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ServerGroupTuples") != m.end() && !m["ServerGroupTuples"].empty()) {
      if (typeid(vector<boost::any>) == m["ServerGroupTuples"].type()) {
        vector<ListForwardingRulesResponseBodyForwardingRulesRuleActionsForwardGroupConfigServerGroupTuples> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ServerGroupTuples"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListForwardingRulesResponseBodyForwardingRulesRuleActionsForwardGroupConfigServerGroupTuples model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        serverGroupTuples = make_shared<vector<ListForwardingRulesResponseBodyForwardingRulesRuleActionsForwardGroupConfigServerGroupTuples>>(expect1);
      }
    }
  }


  virtual ~ListForwardingRulesResponseBodyForwardingRulesRuleActionsForwardGroupConfig() = default;
};
class ListForwardingRulesResponseBodyForwardingRulesRuleActions : public Darabonba::Model {
public:
  shared_ptr<ListForwardingRulesResponseBodyForwardingRulesRuleActionsForwardGroupConfig> forwardGroupConfig{};
  shared_ptr<long> order{};
  shared_ptr<string> ruleActionType{};
  shared_ptr<string> ruleActionValue{};

  ListForwardingRulesResponseBodyForwardingRulesRuleActions() {}

  explicit ListForwardingRulesResponseBodyForwardingRulesRuleActions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (forwardGroupConfig) {
      res["ForwardGroupConfig"] = forwardGroupConfig ? boost::any(forwardGroupConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (order) {
      res["Order"] = boost::any(*order);
    }
    if (ruleActionType) {
      res["RuleActionType"] = boost::any(*ruleActionType);
    }
    if (ruleActionValue) {
      res["RuleActionValue"] = boost::any(*ruleActionValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ForwardGroupConfig") != m.end() && !m["ForwardGroupConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["ForwardGroupConfig"].type()) {
        ListForwardingRulesResponseBodyForwardingRulesRuleActionsForwardGroupConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ForwardGroupConfig"]));
        forwardGroupConfig = make_shared<ListForwardingRulesResponseBodyForwardingRulesRuleActionsForwardGroupConfig>(model1);
      }
    }
    if (m.find("Order") != m.end() && !m["Order"].empty()) {
      order = make_shared<long>(boost::any_cast<long>(m["Order"]));
    }
    if (m.find("RuleActionType") != m.end() && !m["RuleActionType"].empty()) {
      ruleActionType = make_shared<string>(boost::any_cast<string>(m["RuleActionType"]));
    }
    if (m.find("RuleActionValue") != m.end() && !m["RuleActionValue"].empty()) {
      ruleActionValue = make_shared<string>(boost::any_cast<string>(m["RuleActionValue"]));
    }
  }


  virtual ~ListForwardingRulesResponseBodyForwardingRulesRuleActions() = default;
};
class ListForwardingRulesResponseBodyForwardingRulesRuleConditionsHostConfig : public Darabonba::Model {
public:
  shared_ptr<vector<string>> values{};

  ListForwardingRulesResponseBodyForwardingRulesRuleConditionsHostConfig() {}

  explicit ListForwardingRulesResponseBodyForwardingRulesRuleConditionsHostConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (values) {
      res["Values"] = boost::any(*values);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Values") != m.end() && !m["Values"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Values"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Values"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      values = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ListForwardingRulesResponseBodyForwardingRulesRuleConditionsHostConfig() = default;
};
class ListForwardingRulesResponseBodyForwardingRulesRuleConditionsPathConfig : public Darabonba::Model {
public:
  shared_ptr<vector<string>> values{};

  ListForwardingRulesResponseBodyForwardingRulesRuleConditionsPathConfig() {}

  explicit ListForwardingRulesResponseBodyForwardingRulesRuleConditionsPathConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (values) {
      res["Values"] = boost::any(*values);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Values") != m.end() && !m["Values"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Values"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Values"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      values = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ListForwardingRulesResponseBodyForwardingRulesRuleConditionsPathConfig() = default;
};
class ListForwardingRulesResponseBodyForwardingRulesRuleConditions : public Darabonba::Model {
public:
  shared_ptr<ListForwardingRulesResponseBodyForwardingRulesRuleConditionsHostConfig> hostConfig{};
  shared_ptr<ListForwardingRulesResponseBodyForwardingRulesRuleConditionsPathConfig> pathConfig{};
  shared_ptr<string> ruleConditionType{};
  shared_ptr<string> ruleConditionValue{};

  ListForwardingRulesResponseBodyForwardingRulesRuleConditions() {}

  explicit ListForwardingRulesResponseBodyForwardingRulesRuleConditions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (hostConfig) {
      res["HostConfig"] = hostConfig ? boost::any(hostConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pathConfig) {
      res["PathConfig"] = pathConfig ? boost::any(pathConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (ruleConditionType) {
      res["RuleConditionType"] = boost::any(*ruleConditionType);
    }
    if (ruleConditionValue) {
      res["RuleConditionValue"] = boost::any(*ruleConditionValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HostConfig") != m.end() && !m["HostConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["HostConfig"].type()) {
        ListForwardingRulesResponseBodyForwardingRulesRuleConditionsHostConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["HostConfig"]));
        hostConfig = make_shared<ListForwardingRulesResponseBodyForwardingRulesRuleConditionsHostConfig>(model1);
      }
    }
    if (m.find("PathConfig") != m.end() && !m["PathConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["PathConfig"].type()) {
        ListForwardingRulesResponseBodyForwardingRulesRuleConditionsPathConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PathConfig"]));
        pathConfig = make_shared<ListForwardingRulesResponseBodyForwardingRulesRuleConditionsPathConfig>(model1);
      }
    }
    if (m.find("RuleConditionType") != m.end() && !m["RuleConditionType"].empty()) {
      ruleConditionType = make_shared<string>(boost::any_cast<string>(m["RuleConditionType"]));
    }
    if (m.find("RuleConditionValue") != m.end() && !m["RuleConditionValue"].empty()) {
      ruleConditionValue = make_shared<string>(boost::any_cast<string>(m["RuleConditionValue"]));
    }
  }


  virtual ~ListForwardingRulesResponseBodyForwardingRulesRuleConditions() = default;
};
class ListForwardingRulesResponseBodyForwardingRules : public Darabonba::Model {
public:
  shared_ptr<string> forwardingRuleDirection{};
  shared_ptr<string> forwardingRuleId{};
  shared_ptr<string> forwardingRuleName{};
  shared_ptr<string> forwardingRuleStatus{};
  shared_ptr<string> listenerId{};
  shared_ptr<long> priority{};
  shared_ptr<vector<ListForwardingRulesResponseBodyForwardingRulesRuleActions>> ruleActions{};
  shared_ptr<vector<ListForwardingRulesResponseBodyForwardingRulesRuleConditions>> ruleConditions{};

  ListForwardingRulesResponseBodyForwardingRules() {}

  explicit ListForwardingRulesResponseBodyForwardingRules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (forwardingRuleDirection) {
      res["ForwardingRuleDirection"] = boost::any(*forwardingRuleDirection);
    }
    if (forwardingRuleId) {
      res["ForwardingRuleId"] = boost::any(*forwardingRuleId);
    }
    if (forwardingRuleName) {
      res["ForwardingRuleName"] = boost::any(*forwardingRuleName);
    }
    if (forwardingRuleStatus) {
      res["ForwardingRuleStatus"] = boost::any(*forwardingRuleStatus);
    }
    if (listenerId) {
      res["ListenerId"] = boost::any(*listenerId);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (ruleActions) {
      vector<boost::any> temp1;
      for(auto item1:*ruleActions){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RuleActions"] = boost::any(temp1);
    }
    if (ruleConditions) {
      vector<boost::any> temp1;
      for(auto item1:*ruleConditions){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RuleConditions"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ForwardingRuleDirection") != m.end() && !m["ForwardingRuleDirection"].empty()) {
      forwardingRuleDirection = make_shared<string>(boost::any_cast<string>(m["ForwardingRuleDirection"]));
    }
    if (m.find("ForwardingRuleId") != m.end() && !m["ForwardingRuleId"].empty()) {
      forwardingRuleId = make_shared<string>(boost::any_cast<string>(m["ForwardingRuleId"]));
    }
    if (m.find("ForwardingRuleName") != m.end() && !m["ForwardingRuleName"].empty()) {
      forwardingRuleName = make_shared<string>(boost::any_cast<string>(m["ForwardingRuleName"]));
    }
    if (m.find("ForwardingRuleStatus") != m.end() && !m["ForwardingRuleStatus"].empty()) {
      forwardingRuleStatus = make_shared<string>(boost::any_cast<string>(m["ForwardingRuleStatus"]));
    }
    if (m.find("ListenerId") != m.end() && !m["ListenerId"].empty()) {
      listenerId = make_shared<string>(boost::any_cast<string>(m["ListenerId"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<long>(boost::any_cast<long>(m["Priority"]));
    }
    if (m.find("RuleActions") != m.end() && !m["RuleActions"].empty()) {
      if (typeid(vector<boost::any>) == m["RuleActions"].type()) {
        vector<ListForwardingRulesResponseBodyForwardingRulesRuleActions> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RuleActions"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListForwardingRulesResponseBodyForwardingRulesRuleActions model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ruleActions = make_shared<vector<ListForwardingRulesResponseBodyForwardingRulesRuleActions>>(expect1);
      }
    }
    if (m.find("RuleConditions") != m.end() && !m["RuleConditions"].empty()) {
      if (typeid(vector<boost::any>) == m["RuleConditions"].type()) {
        vector<ListForwardingRulesResponseBodyForwardingRulesRuleConditions> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RuleConditions"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListForwardingRulesResponseBodyForwardingRulesRuleConditions model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ruleConditions = make_shared<vector<ListForwardingRulesResponseBodyForwardingRulesRuleConditions>>(expect1);
      }
    }
  }


  virtual ~ListForwardingRulesResponseBodyForwardingRules() = default;
};
class ListForwardingRulesResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListForwardingRulesResponseBodyForwardingRules>> forwardingRules{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  ListForwardingRulesResponseBody() {}

  explicit ListForwardingRulesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (forwardingRules) {
      vector<boost::any> temp1;
      for(auto item1:*forwardingRules){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ForwardingRules"] = boost::any(temp1);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ForwardingRules") != m.end() && !m["ForwardingRules"].empty()) {
      if (typeid(vector<boost::any>) == m["ForwardingRules"].type()) {
        vector<ListForwardingRulesResponseBodyForwardingRules> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ForwardingRules"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListForwardingRulesResponseBodyForwardingRules model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        forwardingRules = make_shared<vector<ListForwardingRulesResponseBodyForwardingRules>>(expect1);
      }
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListForwardingRulesResponseBody() = default;
};
class ListForwardingRulesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListForwardingRulesResponseBody> body{};

  ListForwardingRulesResponse() {}

  explicit ListForwardingRulesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListForwardingRulesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListForwardingRulesResponseBody>(model1);
      }
    }
  }


  virtual ~ListForwardingRulesResponse() = default;
};
class ListIpSetsRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceleratorId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regionId{};

  ListIpSetsRequest() {}

  explicit ListIpSetsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceleratorId) {
      res["AcceleratorId"] = boost::any(*acceleratorId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceleratorId") != m.end() && !m["AcceleratorId"].empty()) {
      acceleratorId = make_shared<string>(boost::any_cast<string>(m["AcceleratorId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~ListIpSetsRequest() = default;
};
class ListIpSetsResponseBodyIpSets : public Darabonba::Model {
public:
  shared_ptr<string> accelerateRegionId{};
  shared_ptr<long> bandwidth{};
  shared_ptr<vector<string>> ipAddressList{};
  shared_ptr<string> ipSetId{};
  shared_ptr<string> ipVersion{};
  shared_ptr<string> ispType{};
  shared_ptr<string> state{};

  ListIpSetsResponseBodyIpSets() {}

  explicit ListIpSetsResponseBodyIpSets(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accelerateRegionId) {
      res["AccelerateRegionId"] = boost::any(*accelerateRegionId);
    }
    if (bandwidth) {
      res["Bandwidth"] = boost::any(*bandwidth);
    }
    if (ipAddressList) {
      res["IpAddressList"] = boost::any(*ipAddressList);
    }
    if (ipSetId) {
      res["IpSetId"] = boost::any(*ipSetId);
    }
    if (ipVersion) {
      res["IpVersion"] = boost::any(*ipVersion);
    }
    if (ispType) {
      res["IspType"] = boost::any(*ispType);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccelerateRegionId") != m.end() && !m["AccelerateRegionId"].empty()) {
      accelerateRegionId = make_shared<string>(boost::any_cast<string>(m["AccelerateRegionId"]));
    }
    if (m.find("Bandwidth") != m.end() && !m["Bandwidth"].empty()) {
      bandwidth = make_shared<long>(boost::any_cast<long>(m["Bandwidth"]));
    }
    if (m.find("IpAddressList") != m.end() && !m["IpAddressList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["IpAddressList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["IpAddressList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      ipAddressList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("IpSetId") != m.end() && !m["IpSetId"].empty()) {
      ipSetId = make_shared<string>(boost::any_cast<string>(m["IpSetId"]));
    }
    if (m.find("IpVersion") != m.end() && !m["IpVersion"].empty()) {
      ipVersion = make_shared<string>(boost::any_cast<string>(m["IpVersion"]));
    }
    if (m.find("IspType") != m.end() && !m["IspType"].empty()) {
      ispType = make_shared<string>(boost::any_cast<string>(m["IspType"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
  }


  virtual ~ListIpSetsResponseBodyIpSets() = default;
};
class ListIpSetsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListIpSetsResponseBodyIpSets>> ipSets{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  ListIpSetsResponseBody() {}

  explicit ListIpSetsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ipSets) {
      vector<boost::any> temp1;
      for(auto item1:*ipSets){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["IpSets"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IpSets") != m.end() && !m["IpSets"].empty()) {
      if (typeid(vector<boost::any>) == m["IpSets"].type()) {
        vector<ListIpSetsResponseBodyIpSets> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["IpSets"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListIpSetsResponseBodyIpSets model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ipSets = make_shared<vector<ListIpSetsResponseBodyIpSets>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListIpSetsResponseBody() = default;
};
class ListIpSetsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListIpSetsResponseBody> body{};

  ListIpSetsResponse() {}

  explicit ListIpSetsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListIpSetsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListIpSetsResponseBody>(model1);
      }
    }
  }


  virtual ~ListIpSetsResponse() = default;
};
class ListIspTypesRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceleratorId{};
  shared_ptr<string> acceleratorType{};
  shared_ptr<string> businessRegionId{};

  ListIspTypesRequest() {}

  explicit ListIspTypesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceleratorId) {
      res["AcceleratorId"] = boost::any(*acceleratorId);
    }
    if (acceleratorType) {
      res["AcceleratorType"] = boost::any(*acceleratorType);
    }
    if (businessRegionId) {
      res["BusinessRegionId"] = boost::any(*businessRegionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceleratorId") != m.end() && !m["AcceleratorId"].empty()) {
      acceleratorId = make_shared<string>(boost::any_cast<string>(m["AcceleratorId"]));
    }
    if (m.find("AcceleratorType") != m.end() && !m["AcceleratorType"].empty()) {
      acceleratorType = make_shared<string>(boost::any_cast<string>(m["AcceleratorType"]));
    }
    if (m.find("BusinessRegionId") != m.end() && !m["BusinessRegionId"].empty()) {
      businessRegionId = make_shared<string>(boost::any_cast<string>(m["BusinessRegionId"]));
    }
  }


  virtual ~ListIspTypesRequest() = default;
};
class ListIspTypesResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<string>> ispTypeList{};
  shared_ptr<string> requestId{};

  ListIspTypesResponseBody() {}

  explicit ListIspTypesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ispTypeList) {
      res["IspTypeList"] = boost::any(*ispTypeList);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IspTypeList") != m.end() && !m["IspTypeList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["IspTypeList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["IspTypeList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      ispTypeList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListIspTypesResponseBody() = default;
};
class ListIspTypesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListIspTypesResponseBody> body{};

  ListIspTypesResponse() {}

  explicit ListIspTypesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListIspTypesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListIspTypesResponseBody>(model1);
      }
    }
  }


  virtual ~ListIspTypesResponse() = default;
};
class ListListenerCertificatesRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceleratorId{};
  shared_ptr<string> listenerId{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> regionId{};
  shared_ptr<string> role{};

  ListListenerCertificatesRequest() {}

  explicit ListListenerCertificatesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceleratorId) {
      res["AcceleratorId"] = boost::any(*acceleratorId);
    }
    if (listenerId) {
      res["ListenerId"] = boost::any(*listenerId);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (role) {
      res["Role"] = boost::any(*role);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceleratorId") != m.end() && !m["AcceleratorId"].empty()) {
      acceleratorId = make_shared<string>(boost::any_cast<string>(m["AcceleratorId"]));
    }
    if (m.find("ListenerId") != m.end() && !m["ListenerId"].empty()) {
      listenerId = make_shared<string>(boost::any_cast<string>(m["ListenerId"]));
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Role") != m.end() && !m["Role"].empty()) {
      role = make_shared<string>(boost::any_cast<string>(m["Role"]));
    }
  }


  virtual ~ListListenerCertificatesRequest() = default;
};
class ListListenerCertificatesResponseBodyCertificates : public Darabonba::Model {
public:
  shared_ptr<string> certificateId{};
  shared_ptr<string> domain{};
  shared_ptr<bool> isDefault{};
  shared_ptr<string> state{};

  ListListenerCertificatesResponseBodyCertificates() {}

  explicit ListListenerCertificatesResponseBodyCertificates(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (certificateId) {
      res["CertificateId"] = boost::any(*certificateId);
    }
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (isDefault) {
      res["IsDefault"] = boost::any(*isDefault);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CertificateId") != m.end() && !m["CertificateId"].empty()) {
      certificateId = make_shared<string>(boost::any_cast<string>(m["CertificateId"]));
    }
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("IsDefault") != m.end() && !m["IsDefault"].empty()) {
      isDefault = make_shared<bool>(boost::any_cast<bool>(m["IsDefault"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
  }


  virtual ~ListListenerCertificatesResponseBodyCertificates() = default;
};
class ListListenerCertificatesResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListListenerCertificatesResponseBodyCertificates>> certificates{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  ListListenerCertificatesResponseBody() {}

  explicit ListListenerCertificatesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (certificates) {
      vector<boost::any> temp1;
      for(auto item1:*certificates){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Certificates"] = boost::any(temp1);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Certificates") != m.end() && !m["Certificates"].empty()) {
      if (typeid(vector<boost::any>) == m["Certificates"].type()) {
        vector<ListListenerCertificatesResponseBodyCertificates> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Certificates"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListListenerCertificatesResponseBodyCertificates model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        certificates = make_shared<vector<ListListenerCertificatesResponseBodyCertificates>>(expect1);
      }
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListListenerCertificatesResponseBody() = default;
};
class ListListenerCertificatesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListListenerCertificatesResponseBody> body{};

  ListListenerCertificatesResponse() {}

  explicit ListListenerCertificatesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListListenerCertificatesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListListenerCertificatesResponseBody>(model1);
      }
    }
  }


  virtual ~ListListenerCertificatesResponse() = default;
};
class ListListenersRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceleratorId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regionId{};

  ListListenersRequest() {}

  explicit ListListenersRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceleratorId) {
      res["AcceleratorId"] = boost::any(*acceleratorId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceleratorId") != m.end() && !m["AcceleratorId"].empty()) {
      acceleratorId = make_shared<string>(boost::any_cast<string>(m["AcceleratorId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~ListListenersRequest() = default;
};
class ListListenersResponseBodyListenersBackendPorts : public Darabonba::Model {
public:
  shared_ptr<string> fromPort{};
  shared_ptr<string> toPort{};

  ListListenersResponseBodyListenersBackendPorts() {}

  explicit ListListenersResponseBodyListenersBackendPorts(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fromPort) {
      res["FromPort"] = boost::any(*fromPort);
    }
    if (toPort) {
      res["ToPort"] = boost::any(*toPort);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FromPort") != m.end() && !m["FromPort"].empty()) {
      fromPort = make_shared<string>(boost::any_cast<string>(m["FromPort"]));
    }
    if (m.find("ToPort") != m.end() && !m["ToPort"].empty()) {
      toPort = make_shared<string>(boost::any_cast<string>(m["ToPort"]));
    }
  }


  virtual ~ListListenersResponseBodyListenersBackendPorts() = default;
};
class ListListenersResponseBodyListenersCertificates : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<string> type{};

  ListListenersResponseBodyListenersCertificates() {}

  explicit ListListenersResponseBodyListenersCertificates(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListListenersResponseBodyListenersCertificates() = default;
};
class ListListenersResponseBodyListenersPortRanges : public Darabonba::Model {
public:
  shared_ptr<long> fromPort{};
  shared_ptr<long> toPort{};

  ListListenersResponseBodyListenersPortRanges() {}

  explicit ListListenersResponseBodyListenersPortRanges(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fromPort) {
      res["FromPort"] = boost::any(*fromPort);
    }
    if (toPort) {
      res["ToPort"] = boost::any(*toPort);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FromPort") != m.end() && !m["FromPort"].empty()) {
      fromPort = make_shared<long>(boost::any_cast<long>(m["FromPort"]));
    }
    if (m.find("ToPort") != m.end() && !m["ToPort"].empty()) {
      toPort = make_shared<long>(boost::any_cast<long>(m["ToPort"]));
    }
  }


  virtual ~ListListenersResponseBodyListenersPortRanges() = default;
};
class ListListenersResponseBodyListenersXForwardedForConfig : public Darabonba::Model {
public:
  shared_ptr<bool> XForwardedForGaApEnabled{};
  shared_ptr<bool> XForwardedForGaIdEnabled{};
  shared_ptr<bool> XForwardedForPortEnabled{};
  shared_ptr<bool> XForwardedForProtoEnabled{};
  shared_ptr<bool> XRealIpEnabled{};

  ListListenersResponseBodyListenersXForwardedForConfig() {}

  explicit ListListenersResponseBodyListenersXForwardedForConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (XForwardedForGaApEnabled) {
      res["XForwardedForGaApEnabled"] = boost::any(*XForwardedForGaApEnabled);
    }
    if (XForwardedForGaIdEnabled) {
      res["XForwardedForGaIdEnabled"] = boost::any(*XForwardedForGaIdEnabled);
    }
    if (XForwardedForPortEnabled) {
      res["XForwardedForPortEnabled"] = boost::any(*XForwardedForPortEnabled);
    }
    if (XForwardedForProtoEnabled) {
      res["XForwardedForProtoEnabled"] = boost::any(*XForwardedForProtoEnabled);
    }
    if (XRealIpEnabled) {
      res["XRealIpEnabled"] = boost::any(*XRealIpEnabled);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("XForwardedForGaApEnabled") != m.end() && !m["XForwardedForGaApEnabled"].empty()) {
      XForwardedForGaApEnabled = make_shared<bool>(boost::any_cast<bool>(m["XForwardedForGaApEnabled"]));
    }
    if (m.find("XForwardedForGaIdEnabled") != m.end() && !m["XForwardedForGaIdEnabled"].empty()) {
      XForwardedForGaIdEnabled = make_shared<bool>(boost::any_cast<bool>(m["XForwardedForGaIdEnabled"]));
    }
    if (m.find("XForwardedForPortEnabled") != m.end() && !m["XForwardedForPortEnabled"].empty()) {
      XForwardedForPortEnabled = make_shared<bool>(boost::any_cast<bool>(m["XForwardedForPortEnabled"]));
    }
    if (m.find("XForwardedForProtoEnabled") != m.end() && !m["XForwardedForProtoEnabled"].empty()) {
      XForwardedForProtoEnabled = make_shared<bool>(boost::any_cast<bool>(m["XForwardedForProtoEnabled"]));
    }
    if (m.find("XRealIpEnabled") != m.end() && !m["XRealIpEnabled"].empty()) {
      XRealIpEnabled = make_shared<bool>(boost::any_cast<bool>(m["XRealIpEnabled"]));
    }
  }


  virtual ~ListListenersResponseBodyListenersXForwardedForConfig() = default;
};
class ListListenersResponseBodyListeners : public Darabonba::Model {
public:
  shared_ptr<string> acceleratorId{};
  shared_ptr<vector<ListListenersResponseBodyListenersBackendPorts>> backendPorts{};
  shared_ptr<vector<ListListenersResponseBodyListenersCertificates>> certificates{};
  shared_ptr<string> clientAffinity{};
  shared_ptr<long> createTime{};
  shared_ptr<string> description{};
  shared_ptr<string> listenerId{};
  shared_ptr<string> name{};
  shared_ptr<vector<ListListenersResponseBodyListenersPortRanges>> portRanges{};
  shared_ptr<string> protocol{};
  shared_ptr<bool> proxyProtocol{};
  shared_ptr<string> securityPolicyId{};
  shared_ptr<string> state{};
  shared_ptr<string> type{};
  shared_ptr<ListListenersResponseBodyListenersXForwardedForConfig> XForwardedForConfig{};

  ListListenersResponseBodyListeners() {}

  explicit ListListenersResponseBodyListeners(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceleratorId) {
      res["AcceleratorId"] = boost::any(*acceleratorId);
    }
    if (backendPorts) {
      vector<boost::any> temp1;
      for(auto item1:*backendPorts){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["BackendPorts"] = boost::any(temp1);
    }
    if (certificates) {
      vector<boost::any> temp1;
      for(auto item1:*certificates){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Certificates"] = boost::any(temp1);
    }
    if (clientAffinity) {
      res["ClientAffinity"] = boost::any(*clientAffinity);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (listenerId) {
      res["ListenerId"] = boost::any(*listenerId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (portRanges) {
      vector<boost::any> temp1;
      for(auto item1:*portRanges){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PortRanges"] = boost::any(temp1);
    }
    if (protocol) {
      res["Protocol"] = boost::any(*protocol);
    }
    if (proxyProtocol) {
      res["ProxyProtocol"] = boost::any(*proxyProtocol);
    }
    if (securityPolicyId) {
      res["SecurityPolicyId"] = boost::any(*securityPolicyId);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (XForwardedForConfig) {
      res["XForwardedForConfig"] = XForwardedForConfig ? boost::any(XForwardedForConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceleratorId") != m.end() && !m["AcceleratorId"].empty()) {
      acceleratorId = make_shared<string>(boost::any_cast<string>(m["AcceleratorId"]));
    }
    if (m.find("BackendPorts") != m.end() && !m["BackendPorts"].empty()) {
      if (typeid(vector<boost::any>) == m["BackendPorts"].type()) {
        vector<ListListenersResponseBodyListenersBackendPorts> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["BackendPorts"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListListenersResponseBodyListenersBackendPorts model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        backendPorts = make_shared<vector<ListListenersResponseBodyListenersBackendPorts>>(expect1);
      }
    }
    if (m.find("Certificates") != m.end() && !m["Certificates"].empty()) {
      if (typeid(vector<boost::any>) == m["Certificates"].type()) {
        vector<ListListenersResponseBodyListenersCertificates> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Certificates"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListListenersResponseBodyListenersCertificates model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        certificates = make_shared<vector<ListListenersResponseBodyListenersCertificates>>(expect1);
      }
    }
    if (m.find("ClientAffinity") != m.end() && !m["ClientAffinity"].empty()) {
      clientAffinity = make_shared<string>(boost::any_cast<string>(m["ClientAffinity"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("ListenerId") != m.end() && !m["ListenerId"].empty()) {
      listenerId = make_shared<string>(boost::any_cast<string>(m["ListenerId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("PortRanges") != m.end() && !m["PortRanges"].empty()) {
      if (typeid(vector<boost::any>) == m["PortRanges"].type()) {
        vector<ListListenersResponseBodyListenersPortRanges> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PortRanges"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListListenersResponseBodyListenersPortRanges model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        portRanges = make_shared<vector<ListListenersResponseBodyListenersPortRanges>>(expect1);
      }
    }
    if (m.find("Protocol") != m.end() && !m["Protocol"].empty()) {
      protocol = make_shared<string>(boost::any_cast<string>(m["Protocol"]));
    }
    if (m.find("ProxyProtocol") != m.end() && !m["ProxyProtocol"].empty()) {
      proxyProtocol = make_shared<bool>(boost::any_cast<bool>(m["ProxyProtocol"]));
    }
    if (m.find("SecurityPolicyId") != m.end() && !m["SecurityPolicyId"].empty()) {
      securityPolicyId = make_shared<string>(boost::any_cast<string>(m["SecurityPolicyId"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("XForwardedForConfig") != m.end() && !m["XForwardedForConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["XForwardedForConfig"].type()) {
        ListListenersResponseBodyListenersXForwardedForConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["XForwardedForConfig"]));
        XForwardedForConfig = make_shared<ListListenersResponseBodyListenersXForwardedForConfig>(model1);
      }
    }
  }


  virtual ~ListListenersResponseBodyListeners() = default;
};
class ListListenersResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListListenersResponseBodyListeners>> listeners{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  ListListenersResponseBody() {}

  explicit ListListenersResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (listeners) {
      vector<boost::any> temp1;
      for(auto item1:*listeners){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Listeners"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Listeners") != m.end() && !m["Listeners"].empty()) {
      if (typeid(vector<boost::any>) == m["Listeners"].type()) {
        vector<ListListenersResponseBodyListeners> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Listeners"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListListenersResponseBodyListeners model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        listeners = make_shared<vector<ListListenersResponseBodyListeners>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListListenersResponseBody() = default;
};
class ListListenersResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListListenersResponseBody> body{};

  ListListenersResponse() {}

  explicit ListListenersResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListListenersResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListListenersResponseBody>(model1);
      }
    }
  }


  virtual ~ListListenersResponse() = default;
};
class ListSpareIpsRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceleratorId{};
  shared_ptr<string> clientToken{};
  shared_ptr<bool> dryRun{};
  shared_ptr<string> regionId{};

  ListSpareIpsRequest() {}

  explicit ListSpareIpsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceleratorId) {
      res["AcceleratorId"] = boost::any(*acceleratorId);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (dryRun) {
      res["DryRun"] = boost::any(*dryRun);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceleratorId") != m.end() && !m["AcceleratorId"].empty()) {
      acceleratorId = make_shared<string>(boost::any_cast<string>(m["AcceleratorId"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("DryRun") != m.end() && !m["DryRun"].empty()) {
      dryRun = make_shared<bool>(boost::any_cast<bool>(m["DryRun"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~ListSpareIpsRequest() = default;
};
class ListSpareIpsResponseBodySpareIps : public Darabonba::Model {
public:
  shared_ptr<string> spareIp{};
  shared_ptr<string> state{};

  ListSpareIpsResponseBodySpareIps() {}

  explicit ListSpareIpsResponseBodySpareIps(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (spareIp) {
      res["SpareIp"] = boost::any(*spareIp);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SpareIp") != m.end() && !m["SpareIp"].empty()) {
      spareIp = make_shared<string>(boost::any_cast<string>(m["SpareIp"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
  }


  virtual ~ListSpareIpsResponseBodySpareIps() = default;
};
class ListSpareIpsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<ListSpareIpsResponseBodySpareIps>> spareIps{};

  ListSpareIpsResponseBody() {}

  explicit ListSpareIpsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (spareIps) {
      vector<boost::any> temp1;
      for(auto item1:*spareIps){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SpareIps"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SpareIps") != m.end() && !m["SpareIps"].empty()) {
      if (typeid(vector<boost::any>) == m["SpareIps"].type()) {
        vector<ListSpareIpsResponseBodySpareIps> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SpareIps"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListSpareIpsResponseBodySpareIps model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        spareIps = make_shared<vector<ListSpareIpsResponseBodySpareIps>>(expect1);
      }
    }
  }


  virtual ~ListSpareIpsResponseBody() = default;
};
class ListSpareIpsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListSpareIpsResponseBody> body{};

  ListSpareIpsResponse() {}

  explicit ListSpareIpsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListSpareIpsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListSpareIpsResponseBody>(model1);
      }
    }
  }


  virtual ~ListSpareIpsResponse() = default;
};
class ListSystemSecurityPoliciesRequest : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> regionId{};

  ListSystemSecurityPoliciesRequest() {}

  explicit ListSystemSecurityPoliciesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~ListSystemSecurityPoliciesRequest() = default;
};
class ListSystemSecurityPoliciesResponseBodySecurityPolicies : public Darabonba::Model {
public:
  shared_ptr<vector<string>> ciphers{};
  shared_ptr<string> securityPolicyId{};
  shared_ptr<vector<string>> tlsVersions{};

  ListSystemSecurityPoliciesResponseBodySecurityPolicies() {}

  explicit ListSystemSecurityPoliciesResponseBodySecurityPolicies(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ciphers) {
      res["Ciphers"] = boost::any(*ciphers);
    }
    if (securityPolicyId) {
      res["SecurityPolicyId"] = boost::any(*securityPolicyId);
    }
    if (tlsVersions) {
      res["TlsVersions"] = boost::any(*tlsVersions);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Ciphers") != m.end() && !m["Ciphers"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Ciphers"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Ciphers"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      ciphers = make_shared<vector<string>>(toVec1);
    }
    if (m.find("SecurityPolicyId") != m.end() && !m["SecurityPolicyId"].empty()) {
      securityPolicyId = make_shared<string>(boost::any_cast<string>(m["SecurityPolicyId"]));
    }
    if (m.find("TlsVersions") != m.end() && !m["TlsVersions"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["TlsVersions"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["TlsVersions"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      tlsVersions = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ListSystemSecurityPoliciesResponseBodySecurityPolicies() = default;
};
class ListSystemSecurityPoliciesResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<ListSystemSecurityPoliciesResponseBodySecurityPolicies>> securityPolicies{};
  shared_ptr<long> totalCount{};

  ListSystemSecurityPoliciesResponseBody() {}

  explicit ListSystemSecurityPoliciesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (securityPolicies) {
      vector<boost::any> temp1;
      for(auto item1:*securityPolicies){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SecurityPolicies"] = boost::any(temp1);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SecurityPolicies") != m.end() && !m["SecurityPolicies"].empty()) {
      if (typeid(vector<boost::any>) == m["SecurityPolicies"].type()) {
        vector<ListSystemSecurityPoliciesResponseBodySecurityPolicies> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SecurityPolicies"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListSystemSecurityPoliciesResponseBodySecurityPolicies model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        securityPolicies = make_shared<vector<ListSystemSecurityPoliciesResponseBodySecurityPolicies>>(expect1);
      }
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListSystemSecurityPoliciesResponseBody() = default;
};
class ListSystemSecurityPoliciesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListSystemSecurityPoliciesResponseBody> body{};

  ListSystemSecurityPoliciesResponse() {}

  explicit ListSystemSecurityPoliciesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListSystemSecurityPoliciesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListSystemSecurityPoliciesResponseBody>(model1);
      }
    }
  }


  virtual ~ListSystemSecurityPoliciesResponse() = default;
};
class ListTagResourcesRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  ListTagResourcesRequestTag() {}

  explicit ListTagResourcesRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~ListTagResourcesRequestTag() = default;
};
class ListTagResourcesRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> regionId{};
  shared_ptr<vector<string>> resourceId{};
  shared_ptr<string> resourceType{};
  shared_ptr<vector<ListTagResourcesRequestTag>> tag{};

  ListTagResourcesRequest() {}

  explicit ListTagResourcesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ResourceId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ResourceId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      resourceId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<ListTagResourcesRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListTagResourcesRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<ListTagResourcesRequestTag>>(expect1);
      }
    }
  }


  virtual ~ListTagResourcesRequest() = default;
};
class ListTagResourcesResponseBodyTagResourcesTagResource : public Darabonba::Model {
public:
  shared_ptr<string> resourceId{};
  shared_ptr<string> resourceType{};
  shared_ptr<string> tagKey{};
  shared_ptr<string> tagValue{};

  ListTagResourcesResponseBodyTagResourcesTagResource() {}

  explicit ListTagResourcesResponseBodyTagResourcesTagResource(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (tagKey) {
      res["TagKey"] = boost::any(*tagKey);
    }
    if (tagValue) {
      res["TagValue"] = boost::any(*tagValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      resourceId = make_shared<string>(boost::any_cast<string>(m["ResourceId"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("TagKey") != m.end() && !m["TagKey"].empty()) {
      tagKey = make_shared<string>(boost::any_cast<string>(m["TagKey"]));
    }
    if (m.find("TagValue") != m.end() && !m["TagValue"].empty()) {
      tagValue = make_shared<string>(boost::any_cast<string>(m["TagValue"]));
    }
  }


  virtual ~ListTagResourcesResponseBodyTagResourcesTagResource() = default;
};
class ListTagResourcesResponseBodyTagResources : public Darabonba::Model {
public:
  shared_ptr<vector<ListTagResourcesResponseBodyTagResourcesTagResource>> tagResource{};

  ListTagResourcesResponseBodyTagResources() {}

  explicit ListTagResourcesResponseBodyTagResources(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tagResource) {
      vector<boost::any> temp1;
      for(auto item1:*tagResource){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TagResource"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TagResource") != m.end() && !m["TagResource"].empty()) {
      if (typeid(vector<boost::any>) == m["TagResource"].type()) {
        vector<ListTagResourcesResponseBodyTagResourcesTagResource> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TagResource"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListTagResourcesResponseBodyTagResourcesTagResource model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tagResource = make_shared<vector<ListTagResourcesResponseBodyTagResourcesTagResource>>(expect1);
      }
    }
  }


  virtual ~ListTagResourcesResponseBodyTagResources() = default;
};
class ListTagResourcesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> nextToken{};
  shared_ptr<string> requestId{};
  shared_ptr<ListTagResourcesResponseBodyTagResources> tagResources{};
  shared_ptr<long> totalCount{};

  ListTagResourcesResponseBody() {}

  explicit ListTagResourcesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (tagResources) {
      res["TagResources"] = tagResources ? boost::any(tagResources->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TagResources") != m.end() && !m["TagResources"].empty()) {
      if (typeid(map<string, boost::any>) == m["TagResources"].type()) {
        ListTagResourcesResponseBodyTagResources model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TagResources"]));
        tagResources = make_shared<ListTagResourcesResponseBodyTagResources>(model1);
      }
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListTagResourcesResponseBody() = default;
};
class ListTagResourcesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListTagResourcesResponseBody> body{};

  ListTagResourcesResponse() {}

  explicit ListTagResourcesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListTagResourcesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListTagResourcesResponseBody>(model1);
      }
    }
  }


  virtual ~ListTagResourcesResponse() = default;
};
class RemoveEntriesFromAclRequestAclEntries : public Darabonba::Model {
public:
  shared_ptr<string> entry{};

  RemoveEntriesFromAclRequestAclEntries() {}

  explicit RemoveEntriesFromAclRequestAclEntries(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (entry) {
      res["Entry"] = boost::any(*entry);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Entry") != m.end() && !m["Entry"].empty()) {
      entry = make_shared<string>(boost::any_cast<string>(m["Entry"]));
    }
  }


  virtual ~RemoveEntriesFromAclRequestAclEntries() = default;
};
class RemoveEntriesFromAclRequest : public Darabonba::Model {
public:
  shared_ptr<vector<RemoveEntriesFromAclRequestAclEntries>> aclEntries{};
  shared_ptr<string> aclId{};
  shared_ptr<string> clientToken{};
  shared_ptr<bool> dryRun{};
  shared_ptr<string> regionId{};

  RemoveEntriesFromAclRequest() {}

  explicit RemoveEntriesFromAclRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aclEntries) {
      vector<boost::any> temp1;
      for(auto item1:*aclEntries){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AclEntries"] = boost::any(temp1);
    }
    if (aclId) {
      res["AclId"] = boost::any(*aclId);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (dryRun) {
      res["DryRun"] = boost::any(*dryRun);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AclEntries") != m.end() && !m["AclEntries"].empty()) {
      if (typeid(vector<boost::any>) == m["AclEntries"].type()) {
        vector<RemoveEntriesFromAclRequestAclEntries> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AclEntries"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            RemoveEntriesFromAclRequestAclEntries model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        aclEntries = make_shared<vector<RemoveEntriesFromAclRequestAclEntries>>(expect1);
      }
    }
    if (m.find("AclId") != m.end() && !m["AclId"].empty()) {
      aclId = make_shared<string>(boost::any_cast<string>(m["AclId"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("DryRun") != m.end() && !m["DryRun"].empty()) {
      dryRun = make_shared<bool>(boost::any_cast<bool>(m["DryRun"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~RemoveEntriesFromAclRequest() = default;
};
class RemoveEntriesFromAclResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> aclId{};
  shared_ptr<string> requestId{};

  RemoveEntriesFromAclResponseBody() {}

  explicit RemoveEntriesFromAclResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aclId) {
      res["AclId"] = boost::any(*aclId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AclId") != m.end() && !m["AclId"].empty()) {
      aclId = make_shared<string>(boost::any_cast<string>(m["AclId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RemoveEntriesFromAclResponseBody() = default;
};
class RemoveEntriesFromAclResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RemoveEntriesFromAclResponseBody> body{};

  RemoveEntriesFromAclResponse() {}

  explicit RemoveEntriesFromAclResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RemoveEntriesFromAclResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RemoveEntriesFromAclResponseBody>(model1);
      }
    }
  }


  virtual ~RemoveEntriesFromAclResponse() = default;
};
class ReplaceBandwidthPackageRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceleratorId{};
  shared_ptr<string> bandwidthPackageId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> targetBandwidthPackageId{};

  ReplaceBandwidthPackageRequest() {}

  explicit ReplaceBandwidthPackageRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceleratorId) {
      res["AcceleratorId"] = boost::any(*acceleratorId);
    }
    if (bandwidthPackageId) {
      res["BandwidthPackageId"] = boost::any(*bandwidthPackageId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (targetBandwidthPackageId) {
      res["TargetBandwidthPackageId"] = boost::any(*targetBandwidthPackageId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceleratorId") != m.end() && !m["AcceleratorId"].empty()) {
      acceleratorId = make_shared<string>(boost::any_cast<string>(m["AcceleratorId"]));
    }
    if (m.find("BandwidthPackageId") != m.end() && !m["BandwidthPackageId"].empty()) {
      bandwidthPackageId = make_shared<string>(boost::any_cast<string>(m["BandwidthPackageId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("TargetBandwidthPackageId") != m.end() && !m["TargetBandwidthPackageId"].empty()) {
      targetBandwidthPackageId = make_shared<string>(boost::any_cast<string>(m["TargetBandwidthPackageId"]));
    }
  }


  virtual ~ReplaceBandwidthPackageRequest() = default;
};
class ReplaceBandwidthPackageResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ReplaceBandwidthPackageResponseBody() {}

  explicit ReplaceBandwidthPackageResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ReplaceBandwidthPackageResponseBody() = default;
};
class ReplaceBandwidthPackageResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ReplaceBandwidthPackageResponseBody> body{};

  ReplaceBandwidthPackageResponse() {}

  explicit ReplaceBandwidthPackageResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ReplaceBandwidthPackageResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ReplaceBandwidthPackageResponseBody>(model1);
      }
    }
  }


  virtual ~ReplaceBandwidthPackageResponse() = default;
};
class TagResourcesRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  TagResourcesRequestTag() {}

  explicit TagResourcesRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~TagResourcesRequestTag() = default;
};
class TagResourcesRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> regionId{};
  shared_ptr<vector<string>> resourceId{};
  shared_ptr<string> resourceType{};
  shared_ptr<vector<TagResourcesRequestTag>> tag{};

  TagResourcesRequest() {}

  explicit TagResourcesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ResourceId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ResourceId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      resourceId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<TagResourcesRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            TagResourcesRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<TagResourcesRequestTag>>(expect1);
      }
    }
  }


  virtual ~TagResourcesRequest() = default;
};
class TagResourcesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  TagResourcesResponseBody() {}

  explicit TagResourcesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~TagResourcesResponseBody() = default;
};
class TagResourcesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<TagResourcesResponseBody> body{};

  TagResourcesResponse() {}

  explicit TagResourcesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        TagResourcesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<TagResourcesResponseBody>(model1);
      }
    }
  }


  virtual ~TagResourcesResponse() = default;
};
class UntagResourcesRequest : public Darabonba::Model {
public:
  shared_ptr<bool> all{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> regionId{};
  shared_ptr<vector<string>> resourceId{};
  shared_ptr<string> resourceType{};
  shared_ptr<vector<string>> tagKey{};

  UntagResourcesRequest() {}

  explicit UntagResourcesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (all) {
      res["All"] = boost::any(*all);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (tagKey) {
      res["TagKey"] = boost::any(*tagKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("All") != m.end() && !m["All"].empty()) {
      all = make_shared<bool>(boost::any_cast<bool>(m["All"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ResourceId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ResourceId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      resourceId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("TagKey") != m.end() && !m["TagKey"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["TagKey"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["TagKey"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      tagKey = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~UntagResourcesRequest() = default;
};
class UntagResourcesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UntagResourcesResponseBody() {}

  explicit UntagResourcesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UntagResourcesResponseBody() = default;
};
class UntagResourcesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UntagResourcesResponseBody> body{};

  UntagResourcesResponse() {}

  explicit UntagResourcesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UntagResourcesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UntagResourcesResponseBody>(model1);
      }
    }
  }


  virtual ~UntagResourcesResponse() = default;
};
class UpdateAcceleratorRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceleratorId{};
  shared_ptr<bool> autoPay{};
  shared_ptr<bool> autoUseCoupon{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> regionId{};
  shared_ptr<string> spec{};

  UpdateAcceleratorRequest() {}

  explicit UpdateAcceleratorRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceleratorId) {
      res["AcceleratorId"] = boost::any(*acceleratorId);
    }
    if (autoPay) {
      res["AutoPay"] = boost::any(*autoPay);
    }
    if (autoUseCoupon) {
      res["AutoUseCoupon"] = boost::any(*autoUseCoupon);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (spec) {
      res["Spec"] = boost::any(*spec);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceleratorId") != m.end() && !m["AcceleratorId"].empty()) {
      acceleratorId = make_shared<string>(boost::any_cast<string>(m["AcceleratorId"]));
    }
    if (m.find("AutoPay") != m.end() && !m["AutoPay"].empty()) {
      autoPay = make_shared<bool>(boost::any_cast<bool>(m["AutoPay"]));
    }
    if (m.find("AutoUseCoupon") != m.end() && !m["AutoUseCoupon"].empty()) {
      autoUseCoupon = make_shared<bool>(boost::any_cast<bool>(m["AutoUseCoupon"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Spec") != m.end() && !m["Spec"].empty()) {
      spec = make_shared<string>(boost::any_cast<string>(m["Spec"]));
    }
  }


  virtual ~UpdateAcceleratorRequest() = default;
};
class UpdateAcceleratorResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateAcceleratorResponseBody() {}

  explicit UpdateAcceleratorResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateAcceleratorResponseBody() = default;
};
class UpdateAcceleratorResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateAcceleratorResponseBody> body{};

  UpdateAcceleratorResponse() {}

  explicit UpdateAcceleratorResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateAcceleratorResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateAcceleratorResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateAcceleratorResponse() = default;
};
class UpdateAcceleratorAutoRenewAttributeRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceleratorId{};
  shared_ptr<bool> autoRenew{};
  shared_ptr<long> autoRenewDuration{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> name{};
  shared_ptr<string> regionId{};
  shared_ptr<string> renewalStatus{};

  UpdateAcceleratorAutoRenewAttributeRequest() {}

  explicit UpdateAcceleratorAutoRenewAttributeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceleratorId) {
      res["AcceleratorId"] = boost::any(*acceleratorId);
    }
    if (autoRenew) {
      res["AutoRenew"] = boost::any(*autoRenew);
    }
    if (autoRenewDuration) {
      res["AutoRenewDuration"] = boost::any(*autoRenewDuration);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (renewalStatus) {
      res["RenewalStatus"] = boost::any(*renewalStatus);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceleratorId") != m.end() && !m["AcceleratorId"].empty()) {
      acceleratorId = make_shared<string>(boost::any_cast<string>(m["AcceleratorId"]));
    }
    if (m.find("AutoRenew") != m.end() && !m["AutoRenew"].empty()) {
      autoRenew = make_shared<bool>(boost::any_cast<bool>(m["AutoRenew"]));
    }
    if (m.find("AutoRenewDuration") != m.end() && !m["AutoRenewDuration"].empty()) {
      autoRenewDuration = make_shared<long>(boost::any_cast<long>(m["AutoRenewDuration"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("RenewalStatus") != m.end() && !m["RenewalStatus"].empty()) {
      renewalStatus = make_shared<string>(boost::any_cast<string>(m["RenewalStatus"]));
    }
  }


  virtual ~UpdateAcceleratorAutoRenewAttributeRequest() = default;
};
class UpdateAcceleratorAutoRenewAttributeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> acceleratorId{};
  shared_ptr<string> requestId{};

  UpdateAcceleratorAutoRenewAttributeResponseBody() {}

  explicit UpdateAcceleratorAutoRenewAttributeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceleratorId) {
      res["AcceleratorId"] = boost::any(*acceleratorId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceleratorId") != m.end() && !m["AcceleratorId"].empty()) {
      acceleratorId = make_shared<string>(boost::any_cast<string>(m["AcceleratorId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateAcceleratorAutoRenewAttributeResponseBody() = default;
};
class UpdateAcceleratorAutoRenewAttributeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateAcceleratorAutoRenewAttributeResponseBody> body{};

  UpdateAcceleratorAutoRenewAttributeResponse() {}

  explicit UpdateAcceleratorAutoRenewAttributeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateAcceleratorAutoRenewAttributeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateAcceleratorAutoRenewAttributeResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateAcceleratorAutoRenewAttributeResponse() = default;
};
class UpdateAcceleratorConfirmRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceleratorId{};
  shared_ptr<string> regionId{};

  UpdateAcceleratorConfirmRequest() {}

  explicit UpdateAcceleratorConfirmRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceleratorId) {
      res["AcceleratorId"] = boost::any(*acceleratorId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceleratorId") != m.end() && !m["AcceleratorId"].empty()) {
      acceleratorId = make_shared<string>(boost::any_cast<string>(m["AcceleratorId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~UpdateAcceleratorConfirmRequest() = default;
};
class UpdateAcceleratorConfirmResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateAcceleratorConfirmResponseBody() {}

  explicit UpdateAcceleratorConfirmResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateAcceleratorConfirmResponseBody() = default;
};
class UpdateAcceleratorConfirmResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateAcceleratorConfirmResponseBody> body{};

  UpdateAcceleratorConfirmResponse() {}

  explicit UpdateAcceleratorConfirmResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateAcceleratorConfirmResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateAcceleratorConfirmResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateAcceleratorConfirmResponse() = default;
};
class UpdateAcceleratorCrossBorderModeRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceleratorId{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> crossBorderMode{};
  shared_ptr<string> regionId{};

  UpdateAcceleratorCrossBorderModeRequest() {}

  explicit UpdateAcceleratorCrossBorderModeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceleratorId) {
      res["AcceleratorId"] = boost::any(*acceleratorId);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (crossBorderMode) {
      res["CrossBorderMode"] = boost::any(*crossBorderMode);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceleratorId") != m.end() && !m["AcceleratorId"].empty()) {
      acceleratorId = make_shared<string>(boost::any_cast<string>(m["AcceleratorId"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("CrossBorderMode") != m.end() && !m["CrossBorderMode"].empty()) {
      crossBorderMode = make_shared<string>(boost::any_cast<string>(m["CrossBorderMode"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~UpdateAcceleratorCrossBorderModeRequest() = default;
};
class UpdateAcceleratorCrossBorderModeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateAcceleratorCrossBorderModeResponseBody() {}

  explicit UpdateAcceleratorCrossBorderModeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateAcceleratorCrossBorderModeResponseBody() = default;
};
class UpdateAcceleratorCrossBorderModeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateAcceleratorCrossBorderModeResponseBody> body{};

  UpdateAcceleratorCrossBorderModeResponse() {}

  explicit UpdateAcceleratorCrossBorderModeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateAcceleratorCrossBorderModeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateAcceleratorCrossBorderModeResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateAcceleratorCrossBorderModeResponse() = default;
};
class UpdateAclAttributeRequest : public Darabonba::Model {
public:
  shared_ptr<string> aclId{};
  shared_ptr<string> aclName{};
  shared_ptr<string> clientToken{};
  shared_ptr<bool> dryRun{};
  shared_ptr<string> regionId{};

  UpdateAclAttributeRequest() {}

  explicit UpdateAclAttributeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aclId) {
      res["AclId"] = boost::any(*aclId);
    }
    if (aclName) {
      res["AclName"] = boost::any(*aclName);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (dryRun) {
      res["DryRun"] = boost::any(*dryRun);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AclId") != m.end() && !m["AclId"].empty()) {
      aclId = make_shared<string>(boost::any_cast<string>(m["AclId"]));
    }
    if (m.find("AclName") != m.end() && !m["AclName"].empty()) {
      aclName = make_shared<string>(boost::any_cast<string>(m["AclName"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("DryRun") != m.end() && !m["DryRun"].empty()) {
      dryRun = make_shared<bool>(boost::any_cast<bool>(m["DryRun"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~UpdateAclAttributeRequest() = default;
};
class UpdateAclAttributeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> aclId{};
  shared_ptr<string> requestId{};

  UpdateAclAttributeResponseBody() {}

  explicit UpdateAclAttributeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aclId) {
      res["AclId"] = boost::any(*aclId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AclId") != m.end() && !m["AclId"].empty()) {
      aclId = make_shared<string>(boost::any_cast<string>(m["AclId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateAclAttributeResponseBody() = default;
};
class UpdateAclAttributeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateAclAttributeResponseBody> body{};

  UpdateAclAttributeResponse() {}

  explicit UpdateAclAttributeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateAclAttributeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateAclAttributeResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateAclAttributeResponse() = default;
};
class UpdateAdditionalCertificateWithListenerRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceleratorId{};
  shared_ptr<string> certificateId{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> domain{};
  shared_ptr<bool> dryRun{};
  shared_ptr<string> listenerId{};
  shared_ptr<string> regionId{};

  UpdateAdditionalCertificateWithListenerRequest() {}

  explicit UpdateAdditionalCertificateWithListenerRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceleratorId) {
      res["AcceleratorId"] = boost::any(*acceleratorId);
    }
    if (certificateId) {
      res["CertificateId"] = boost::any(*certificateId);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (dryRun) {
      res["DryRun"] = boost::any(*dryRun);
    }
    if (listenerId) {
      res["ListenerId"] = boost::any(*listenerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceleratorId") != m.end() && !m["AcceleratorId"].empty()) {
      acceleratorId = make_shared<string>(boost::any_cast<string>(m["AcceleratorId"]));
    }
    if (m.find("CertificateId") != m.end() && !m["CertificateId"].empty()) {
      certificateId = make_shared<string>(boost::any_cast<string>(m["CertificateId"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("DryRun") != m.end() && !m["DryRun"].empty()) {
      dryRun = make_shared<bool>(boost::any_cast<bool>(m["DryRun"]));
    }
    if (m.find("ListenerId") != m.end() && !m["ListenerId"].empty()) {
      listenerId = make_shared<string>(boost::any_cast<string>(m["ListenerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~UpdateAdditionalCertificateWithListenerRequest() = default;
};
class UpdateAdditionalCertificateWithListenerResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> listenerId{};
  shared_ptr<string> requestId{};

  UpdateAdditionalCertificateWithListenerResponseBody() {}

  explicit UpdateAdditionalCertificateWithListenerResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (listenerId) {
      res["ListenerId"] = boost::any(*listenerId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ListenerId") != m.end() && !m["ListenerId"].empty()) {
      listenerId = make_shared<string>(boost::any_cast<string>(m["ListenerId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateAdditionalCertificateWithListenerResponseBody() = default;
};
class UpdateAdditionalCertificateWithListenerResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateAdditionalCertificateWithListenerResponseBody> body{};

  UpdateAdditionalCertificateWithListenerResponse() {}

  explicit UpdateAdditionalCertificateWithListenerResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateAdditionalCertificateWithListenerResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateAdditionalCertificateWithListenerResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateAdditionalCertificateWithListenerResponse() = default;
};
class UpdateApplicationMonitorRequest : public Darabonba::Model {
public:
  shared_ptr<string> address{};
  shared_ptr<string> clientToken{};
  shared_ptr<bool> detectEnable{};
  shared_ptr<long> detectThreshold{};
  shared_ptr<long> detectTimes{};
  shared_ptr<string> listenerId{};
  shared_ptr<string> optionsJson{};
  shared_ptr<string> regionId{};
  shared_ptr<long> silenceTime{};
  shared_ptr<string> taskId{};
  shared_ptr<string> taskName{};

  UpdateApplicationMonitorRequest() {}

  explicit UpdateApplicationMonitorRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (address) {
      res["Address"] = boost::any(*address);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (detectEnable) {
      res["DetectEnable"] = boost::any(*detectEnable);
    }
    if (detectThreshold) {
      res["DetectThreshold"] = boost::any(*detectThreshold);
    }
    if (detectTimes) {
      res["DetectTimes"] = boost::any(*detectTimes);
    }
    if (listenerId) {
      res["ListenerId"] = boost::any(*listenerId);
    }
    if (optionsJson) {
      res["OptionsJson"] = boost::any(*optionsJson);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (silenceTime) {
      res["SilenceTime"] = boost::any(*silenceTime);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (taskName) {
      res["TaskName"] = boost::any(*taskName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Address") != m.end() && !m["Address"].empty()) {
      address = make_shared<string>(boost::any_cast<string>(m["Address"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("DetectEnable") != m.end() && !m["DetectEnable"].empty()) {
      detectEnable = make_shared<bool>(boost::any_cast<bool>(m["DetectEnable"]));
    }
    if (m.find("DetectThreshold") != m.end() && !m["DetectThreshold"].empty()) {
      detectThreshold = make_shared<long>(boost::any_cast<long>(m["DetectThreshold"]));
    }
    if (m.find("DetectTimes") != m.end() && !m["DetectTimes"].empty()) {
      detectTimes = make_shared<long>(boost::any_cast<long>(m["DetectTimes"]));
    }
    if (m.find("ListenerId") != m.end() && !m["ListenerId"].empty()) {
      listenerId = make_shared<string>(boost::any_cast<string>(m["ListenerId"]));
    }
    if (m.find("OptionsJson") != m.end() && !m["OptionsJson"].empty()) {
      optionsJson = make_shared<string>(boost::any_cast<string>(m["OptionsJson"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SilenceTime") != m.end() && !m["SilenceTime"].empty()) {
      silenceTime = make_shared<long>(boost::any_cast<long>(m["SilenceTime"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("TaskName") != m.end() && !m["TaskName"].empty()) {
      taskName = make_shared<string>(boost::any_cast<string>(m["TaskName"]));
    }
  }


  virtual ~UpdateApplicationMonitorRequest() = default;
};
class UpdateApplicationMonitorResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateApplicationMonitorResponseBody() {}

  explicit UpdateApplicationMonitorResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateApplicationMonitorResponseBody() = default;
};
class UpdateApplicationMonitorResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateApplicationMonitorResponseBody> body{};

  UpdateApplicationMonitorResponse() {}

  explicit UpdateApplicationMonitorResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateApplicationMonitorResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateApplicationMonitorResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateApplicationMonitorResponse() = default;
};
class UpdateBandwidthPackagaAutoRenewAttributeRequest : public Darabonba::Model {
public:
  shared_ptr<bool> autoRenew{};
  shared_ptr<long> autoRenewDuration{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> name{};
  shared_ptr<string> regionId{};
  shared_ptr<string> renewalStatus{};

  UpdateBandwidthPackagaAutoRenewAttributeRequest() {}

  explicit UpdateBandwidthPackagaAutoRenewAttributeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (autoRenew) {
      res["AutoRenew"] = boost::any(*autoRenew);
    }
    if (autoRenewDuration) {
      res["AutoRenewDuration"] = boost::any(*autoRenewDuration);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (renewalStatus) {
      res["RenewalStatus"] = boost::any(*renewalStatus);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AutoRenew") != m.end() && !m["AutoRenew"].empty()) {
      autoRenew = make_shared<bool>(boost::any_cast<bool>(m["AutoRenew"]));
    }
    if (m.find("AutoRenewDuration") != m.end() && !m["AutoRenewDuration"].empty()) {
      autoRenewDuration = make_shared<long>(boost::any_cast<long>(m["AutoRenewDuration"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("RenewalStatus") != m.end() && !m["RenewalStatus"].empty()) {
      renewalStatus = make_shared<string>(boost::any_cast<string>(m["RenewalStatus"]));
    }
  }


  virtual ~UpdateBandwidthPackagaAutoRenewAttributeRequest() = default;
};
class UpdateBandwidthPackagaAutoRenewAttributeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> requestId{};

  UpdateBandwidthPackagaAutoRenewAttributeResponseBody() {}

  explicit UpdateBandwidthPackagaAutoRenewAttributeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateBandwidthPackagaAutoRenewAttributeResponseBody() = default;
};
class UpdateBandwidthPackagaAutoRenewAttributeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateBandwidthPackagaAutoRenewAttributeResponseBody> body{};

  UpdateBandwidthPackagaAutoRenewAttributeResponse() {}

  explicit UpdateBandwidthPackagaAutoRenewAttributeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateBandwidthPackagaAutoRenewAttributeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateBandwidthPackagaAutoRenewAttributeResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateBandwidthPackagaAutoRenewAttributeResponse() = default;
};
class UpdateBandwidthPackageRequest : public Darabonba::Model {
public:
  shared_ptr<bool> autoPay{};
  shared_ptr<bool> autoUseCoupon{};
  shared_ptr<long> bandwidth{};
  shared_ptr<string> bandwidthPackageId{};
  shared_ptr<string> bandwidthType{};
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> regionId{};

  UpdateBandwidthPackageRequest() {}

  explicit UpdateBandwidthPackageRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (autoPay) {
      res["AutoPay"] = boost::any(*autoPay);
    }
    if (autoUseCoupon) {
      res["AutoUseCoupon"] = boost::any(*autoUseCoupon);
    }
    if (bandwidth) {
      res["Bandwidth"] = boost::any(*bandwidth);
    }
    if (bandwidthPackageId) {
      res["BandwidthPackageId"] = boost::any(*bandwidthPackageId);
    }
    if (bandwidthType) {
      res["BandwidthType"] = boost::any(*bandwidthType);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AutoPay") != m.end() && !m["AutoPay"].empty()) {
      autoPay = make_shared<bool>(boost::any_cast<bool>(m["AutoPay"]));
    }
    if (m.find("AutoUseCoupon") != m.end() && !m["AutoUseCoupon"].empty()) {
      autoUseCoupon = make_shared<bool>(boost::any_cast<bool>(m["AutoUseCoupon"]));
    }
    if (m.find("Bandwidth") != m.end() && !m["Bandwidth"].empty()) {
      bandwidth = make_shared<long>(boost::any_cast<long>(m["Bandwidth"]));
    }
    if (m.find("BandwidthPackageId") != m.end() && !m["BandwidthPackageId"].empty()) {
      bandwidthPackageId = make_shared<string>(boost::any_cast<string>(m["BandwidthPackageId"]));
    }
    if (m.find("BandwidthType") != m.end() && !m["BandwidthType"].empty()) {
      bandwidthType = make_shared<string>(boost::any_cast<string>(m["BandwidthType"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~UpdateBandwidthPackageRequest() = default;
};
class UpdateBandwidthPackageResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> bandwidthPackage{};
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> requestId{};

  UpdateBandwidthPackageResponseBody() {}

  explicit UpdateBandwidthPackageResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bandwidthPackage) {
      res["BandwidthPackage"] = boost::any(*bandwidthPackage);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BandwidthPackage") != m.end() && !m["BandwidthPackage"].empty()) {
      bandwidthPackage = make_shared<string>(boost::any_cast<string>(m["BandwidthPackage"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateBandwidthPackageResponseBody() = default;
};
class UpdateBandwidthPackageResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateBandwidthPackageResponseBody> body{};

  UpdateBandwidthPackageResponse() {}

  explicit UpdateBandwidthPackageResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateBandwidthPackageResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateBandwidthPackageResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateBandwidthPackageResponse() = default;
};
class UpdateBasicAcceleratorRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceleratorId{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> regionId{};

  UpdateBasicAcceleratorRequest() {}

  explicit UpdateBasicAcceleratorRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceleratorId) {
      res["AcceleratorId"] = boost::any(*acceleratorId);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceleratorId") != m.end() && !m["AcceleratorId"].empty()) {
      acceleratorId = make_shared<string>(boost::any_cast<string>(m["AcceleratorId"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~UpdateBasicAcceleratorRequest() = default;
};
class UpdateBasicAcceleratorResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateBasicAcceleratorResponseBody() {}

  explicit UpdateBasicAcceleratorResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateBasicAcceleratorResponseBody() = default;
};
class UpdateBasicAcceleratorResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateBasicAcceleratorResponseBody> body{};

  UpdateBasicAcceleratorResponse() {}

  explicit UpdateBasicAcceleratorResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateBasicAcceleratorResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateBasicAcceleratorResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateBasicAcceleratorResponse() = default;
};
class UpdateBasicEndpointRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> endpointGroupId{};
  shared_ptr<string> endpointId{};
  shared_ptr<string> name{};
  shared_ptr<string> regionId{};

  UpdateBasicEndpointRequest() {}

  explicit UpdateBasicEndpointRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (endpointGroupId) {
      res["EndpointGroupId"] = boost::any(*endpointGroupId);
    }
    if (endpointId) {
      res["EndpointId"] = boost::any(*endpointId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("EndpointGroupId") != m.end() && !m["EndpointGroupId"].empty()) {
      endpointGroupId = make_shared<string>(boost::any_cast<string>(m["EndpointGroupId"]));
    }
    if (m.find("EndpointId") != m.end() && !m["EndpointId"].empty()) {
      endpointId = make_shared<string>(boost::any_cast<string>(m["EndpointId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~UpdateBasicEndpointRequest() = default;
};
class UpdateBasicEndpointResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> endpointGroupId{};
  shared_ptr<string> endpointId{};
  shared_ptr<string> name{};
  shared_ptr<string> requestId{};

  UpdateBasicEndpointResponseBody() {}

  explicit UpdateBasicEndpointResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endpointGroupId) {
      res["EndpointGroupId"] = boost::any(*endpointGroupId);
    }
    if (endpointId) {
      res["EndpointId"] = boost::any(*endpointId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndpointGroupId") != m.end() && !m["EndpointGroupId"].empty()) {
      endpointGroupId = make_shared<string>(boost::any_cast<string>(m["EndpointGroupId"]));
    }
    if (m.find("EndpointId") != m.end() && !m["EndpointId"].empty()) {
      endpointId = make_shared<string>(boost::any_cast<string>(m["EndpointId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateBasicEndpointResponseBody() = default;
};
class UpdateBasicEndpointResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateBasicEndpointResponseBody> body{};

  UpdateBasicEndpointResponse() {}

  explicit UpdateBasicEndpointResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateBasicEndpointResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateBasicEndpointResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateBasicEndpointResponse() = default;
};
class UpdateBasicEndpointGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> description{};
  shared_ptr<string> endpointAddress{};
  shared_ptr<string> endpointGroupId{};
  shared_ptr<string> endpointSubAddress{};
  shared_ptr<string> endpointType{};
  shared_ptr<string> name{};
  shared_ptr<string> regionId{};

  UpdateBasicEndpointGroupRequest() {}

  explicit UpdateBasicEndpointGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (endpointAddress) {
      res["EndpointAddress"] = boost::any(*endpointAddress);
    }
    if (endpointGroupId) {
      res["EndpointGroupId"] = boost::any(*endpointGroupId);
    }
    if (endpointSubAddress) {
      res["EndpointSubAddress"] = boost::any(*endpointSubAddress);
    }
    if (endpointType) {
      res["EndpointType"] = boost::any(*endpointType);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("EndpointAddress") != m.end() && !m["EndpointAddress"].empty()) {
      endpointAddress = make_shared<string>(boost::any_cast<string>(m["EndpointAddress"]));
    }
    if (m.find("EndpointGroupId") != m.end() && !m["EndpointGroupId"].empty()) {
      endpointGroupId = make_shared<string>(boost::any_cast<string>(m["EndpointGroupId"]));
    }
    if (m.find("EndpointSubAddress") != m.end() && !m["EndpointSubAddress"].empty()) {
      endpointSubAddress = make_shared<string>(boost::any_cast<string>(m["EndpointSubAddress"]));
    }
    if (m.find("EndpointType") != m.end() && !m["EndpointType"].empty()) {
      endpointType = make_shared<string>(boost::any_cast<string>(m["EndpointType"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~UpdateBasicEndpointGroupRequest() = default;
};
class UpdateBasicEndpointGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateBasicEndpointGroupResponseBody() {}

  explicit UpdateBasicEndpointGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateBasicEndpointGroupResponseBody() = default;
};
class UpdateBasicEndpointGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateBasicEndpointGroupResponseBody> body{};

  UpdateBasicEndpointGroupResponse() {}

  explicit UpdateBasicEndpointGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateBasicEndpointGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateBasicEndpointGroupResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateBasicEndpointGroupResponse() = default;
};
class UpdateBasicIpSetRequest : public Darabonba::Model {
public:
  shared_ptr<long> bandwidth{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> ipSetId{};
  shared_ptr<string> regionId{};

  UpdateBasicIpSetRequest() {}

  explicit UpdateBasicIpSetRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bandwidth) {
      res["Bandwidth"] = boost::any(*bandwidth);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (ipSetId) {
      res["IpSetId"] = boost::any(*ipSetId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bandwidth") != m.end() && !m["Bandwidth"].empty()) {
      bandwidth = make_shared<long>(boost::any_cast<long>(m["Bandwidth"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("IpSetId") != m.end() && !m["IpSetId"].empty()) {
      ipSetId = make_shared<string>(boost::any_cast<string>(m["IpSetId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~UpdateBasicIpSetRequest() = default;
};
class UpdateBasicIpSetResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateBasicIpSetResponseBody() {}

  explicit UpdateBasicIpSetResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateBasicIpSetResponseBody() = default;
};
class UpdateBasicIpSetResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateBasicIpSetResponseBody> body{};

  UpdateBasicIpSetResponse() {}

  explicit UpdateBasicIpSetResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateBasicIpSetResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateBasicIpSetResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateBasicIpSetResponse() = default;
};
class UpdateCustomRoutingEndpointGroupAttributeRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> description{};
  shared_ptr<string> endpointGroupId{};
  shared_ptr<string> name{};
  shared_ptr<string> regionId{};

  UpdateCustomRoutingEndpointGroupAttributeRequest() {}

  explicit UpdateCustomRoutingEndpointGroupAttributeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (endpointGroupId) {
      res["EndpointGroupId"] = boost::any(*endpointGroupId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("EndpointGroupId") != m.end() && !m["EndpointGroupId"].empty()) {
      endpointGroupId = make_shared<string>(boost::any_cast<string>(m["EndpointGroupId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~UpdateCustomRoutingEndpointGroupAttributeRequest() = default;
};
class UpdateCustomRoutingEndpointGroupAttributeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateCustomRoutingEndpointGroupAttributeResponseBody() {}

  explicit UpdateCustomRoutingEndpointGroupAttributeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateCustomRoutingEndpointGroupAttributeResponseBody() = default;
};
class UpdateCustomRoutingEndpointGroupAttributeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateCustomRoutingEndpointGroupAttributeResponseBody> body{};

  UpdateCustomRoutingEndpointGroupAttributeResponse() {}

  explicit UpdateCustomRoutingEndpointGroupAttributeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateCustomRoutingEndpointGroupAttributeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateCustomRoutingEndpointGroupAttributeResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateCustomRoutingEndpointGroupAttributeResponse() = default;
};
class UpdateCustomRoutingEndpointGroupDestinationsRequestDestinationConfigurations : public Darabonba::Model {
public:
  shared_ptr<string> destinationId{};
  shared_ptr<long> fromPort{};
  shared_ptr<vector<string>> protocols{};
  shared_ptr<long> toPort{};

  UpdateCustomRoutingEndpointGroupDestinationsRequestDestinationConfigurations() {}

  explicit UpdateCustomRoutingEndpointGroupDestinationsRequestDestinationConfigurations(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (destinationId) {
      res["DestinationId"] = boost::any(*destinationId);
    }
    if (fromPort) {
      res["FromPort"] = boost::any(*fromPort);
    }
    if (protocols) {
      res["Protocols"] = boost::any(*protocols);
    }
    if (toPort) {
      res["ToPort"] = boost::any(*toPort);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DestinationId") != m.end() && !m["DestinationId"].empty()) {
      destinationId = make_shared<string>(boost::any_cast<string>(m["DestinationId"]));
    }
    if (m.find("FromPort") != m.end() && !m["FromPort"].empty()) {
      fromPort = make_shared<long>(boost::any_cast<long>(m["FromPort"]));
    }
    if (m.find("Protocols") != m.end() && !m["Protocols"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Protocols"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Protocols"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      protocols = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ToPort") != m.end() && !m["ToPort"].empty()) {
      toPort = make_shared<long>(boost::any_cast<long>(m["ToPort"]));
    }
  }


  virtual ~UpdateCustomRoutingEndpointGroupDestinationsRequestDestinationConfigurations() = default;
};
class UpdateCustomRoutingEndpointGroupDestinationsRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<vector<UpdateCustomRoutingEndpointGroupDestinationsRequestDestinationConfigurations>> destinationConfigurations{};
  shared_ptr<bool> dryRun{};
  shared_ptr<string> endpointGroupId{};
  shared_ptr<string> regionId{};

  UpdateCustomRoutingEndpointGroupDestinationsRequest() {}

  explicit UpdateCustomRoutingEndpointGroupDestinationsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (destinationConfigurations) {
      vector<boost::any> temp1;
      for(auto item1:*destinationConfigurations){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DestinationConfigurations"] = boost::any(temp1);
    }
    if (dryRun) {
      res["DryRun"] = boost::any(*dryRun);
    }
    if (endpointGroupId) {
      res["EndpointGroupId"] = boost::any(*endpointGroupId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("DestinationConfigurations") != m.end() && !m["DestinationConfigurations"].empty()) {
      if (typeid(vector<boost::any>) == m["DestinationConfigurations"].type()) {
        vector<UpdateCustomRoutingEndpointGroupDestinationsRequestDestinationConfigurations> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DestinationConfigurations"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateCustomRoutingEndpointGroupDestinationsRequestDestinationConfigurations model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        destinationConfigurations = make_shared<vector<UpdateCustomRoutingEndpointGroupDestinationsRequestDestinationConfigurations>>(expect1);
      }
    }
    if (m.find("DryRun") != m.end() && !m["DryRun"].empty()) {
      dryRun = make_shared<bool>(boost::any_cast<bool>(m["DryRun"]));
    }
    if (m.find("EndpointGroupId") != m.end() && !m["EndpointGroupId"].empty()) {
      endpointGroupId = make_shared<string>(boost::any_cast<string>(m["EndpointGroupId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~UpdateCustomRoutingEndpointGroupDestinationsRequest() = default;
};
class UpdateCustomRoutingEndpointGroupDestinationsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateCustomRoutingEndpointGroupDestinationsResponseBody() {}

  explicit UpdateCustomRoutingEndpointGroupDestinationsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateCustomRoutingEndpointGroupDestinationsResponseBody() = default;
};
class UpdateCustomRoutingEndpointGroupDestinationsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateCustomRoutingEndpointGroupDestinationsResponseBody> body{};

  UpdateCustomRoutingEndpointGroupDestinationsResponse() {}

  explicit UpdateCustomRoutingEndpointGroupDestinationsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateCustomRoutingEndpointGroupDestinationsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateCustomRoutingEndpointGroupDestinationsResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateCustomRoutingEndpointGroupDestinationsResponse() = default;
};
class UpdateCustomRoutingEndpointTrafficPoliciesRequestPolicyConfigurationsPortRanges : public Darabonba::Model {
public:
  shared_ptr<long> fromPort{};
  shared_ptr<long> toPort{};

  UpdateCustomRoutingEndpointTrafficPoliciesRequestPolicyConfigurationsPortRanges() {}

  explicit UpdateCustomRoutingEndpointTrafficPoliciesRequestPolicyConfigurationsPortRanges(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fromPort) {
      res["FromPort"] = boost::any(*fromPort);
    }
    if (toPort) {
      res["ToPort"] = boost::any(*toPort);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FromPort") != m.end() && !m["FromPort"].empty()) {
      fromPort = make_shared<long>(boost::any_cast<long>(m["FromPort"]));
    }
    if (m.find("ToPort") != m.end() && !m["ToPort"].empty()) {
      toPort = make_shared<long>(boost::any_cast<long>(m["ToPort"]));
    }
  }


  virtual ~UpdateCustomRoutingEndpointTrafficPoliciesRequestPolicyConfigurationsPortRanges() = default;
};
class UpdateCustomRoutingEndpointTrafficPoliciesRequestPolicyConfigurations : public Darabonba::Model {
public:
  shared_ptr<string> address{};
  shared_ptr<string> policyId{};
  shared_ptr<vector<UpdateCustomRoutingEndpointTrafficPoliciesRequestPolicyConfigurationsPortRanges>> portRanges{};

  UpdateCustomRoutingEndpointTrafficPoliciesRequestPolicyConfigurations() {}

  explicit UpdateCustomRoutingEndpointTrafficPoliciesRequestPolicyConfigurations(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (address) {
      res["Address"] = boost::any(*address);
    }
    if (policyId) {
      res["PolicyId"] = boost::any(*policyId);
    }
    if (portRanges) {
      vector<boost::any> temp1;
      for(auto item1:*portRanges){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PortRanges"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Address") != m.end() && !m["Address"].empty()) {
      address = make_shared<string>(boost::any_cast<string>(m["Address"]));
    }
    if (m.find("PolicyId") != m.end() && !m["PolicyId"].empty()) {
      policyId = make_shared<string>(boost::any_cast<string>(m["PolicyId"]));
    }
    if (m.find("PortRanges") != m.end() && !m["PortRanges"].empty()) {
      if (typeid(vector<boost::any>) == m["PortRanges"].type()) {
        vector<UpdateCustomRoutingEndpointTrafficPoliciesRequestPolicyConfigurationsPortRanges> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PortRanges"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateCustomRoutingEndpointTrafficPoliciesRequestPolicyConfigurationsPortRanges model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        portRanges = make_shared<vector<UpdateCustomRoutingEndpointTrafficPoliciesRequestPolicyConfigurationsPortRanges>>(expect1);
      }
    }
  }


  virtual ~UpdateCustomRoutingEndpointTrafficPoliciesRequestPolicyConfigurations() = default;
};
class UpdateCustomRoutingEndpointTrafficPoliciesRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> endpointId{};
  shared_ptr<vector<UpdateCustomRoutingEndpointTrafficPoliciesRequestPolicyConfigurations>> policyConfigurations{};
  shared_ptr<string> regionId{};

  UpdateCustomRoutingEndpointTrafficPoliciesRequest() {}

  explicit UpdateCustomRoutingEndpointTrafficPoliciesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (endpointId) {
      res["EndpointId"] = boost::any(*endpointId);
    }
    if (policyConfigurations) {
      vector<boost::any> temp1;
      for(auto item1:*policyConfigurations){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PolicyConfigurations"] = boost::any(temp1);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("EndpointId") != m.end() && !m["EndpointId"].empty()) {
      endpointId = make_shared<string>(boost::any_cast<string>(m["EndpointId"]));
    }
    if (m.find("PolicyConfigurations") != m.end() && !m["PolicyConfigurations"].empty()) {
      if (typeid(vector<boost::any>) == m["PolicyConfigurations"].type()) {
        vector<UpdateCustomRoutingEndpointTrafficPoliciesRequestPolicyConfigurations> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PolicyConfigurations"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateCustomRoutingEndpointTrafficPoliciesRequestPolicyConfigurations model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        policyConfigurations = make_shared<vector<UpdateCustomRoutingEndpointTrafficPoliciesRequestPolicyConfigurations>>(expect1);
      }
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~UpdateCustomRoutingEndpointTrafficPoliciesRequest() = default;
};
class UpdateCustomRoutingEndpointTrafficPoliciesResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<string>> policyIds{};
  shared_ptr<string> requestId{};

  UpdateCustomRoutingEndpointTrafficPoliciesResponseBody() {}

  explicit UpdateCustomRoutingEndpointTrafficPoliciesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (policyIds) {
      res["PolicyIds"] = boost::any(*policyIds);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PolicyIds") != m.end() && !m["PolicyIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["PolicyIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["PolicyIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      policyIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateCustomRoutingEndpointTrafficPoliciesResponseBody() = default;
};
class UpdateCustomRoutingEndpointTrafficPoliciesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateCustomRoutingEndpointTrafficPoliciesResponseBody> body{};

  UpdateCustomRoutingEndpointTrafficPoliciesResponse() {}

  explicit UpdateCustomRoutingEndpointTrafficPoliciesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateCustomRoutingEndpointTrafficPoliciesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateCustomRoutingEndpointTrafficPoliciesResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateCustomRoutingEndpointTrafficPoliciesResponse() = default;
};
class UpdateCustomRoutingEndpointsRequestEndpointConfigurationsPolicyConfigurationsPortRanges : public Darabonba::Model {
public:
  shared_ptr<string> fromPort{};
  shared_ptr<string> toPort{};

  UpdateCustomRoutingEndpointsRequestEndpointConfigurationsPolicyConfigurationsPortRanges() {}

  explicit UpdateCustomRoutingEndpointsRequestEndpointConfigurationsPolicyConfigurationsPortRanges(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fromPort) {
      res["FromPort"] = boost::any(*fromPort);
    }
    if (toPort) {
      res["ToPort"] = boost::any(*toPort);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FromPort") != m.end() && !m["FromPort"].empty()) {
      fromPort = make_shared<string>(boost::any_cast<string>(m["FromPort"]));
    }
    if (m.find("ToPort") != m.end() && !m["ToPort"].empty()) {
      toPort = make_shared<string>(boost::any_cast<string>(m["ToPort"]));
    }
  }


  virtual ~UpdateCustomRoutingEndpointsRequestEndpointConfigurationsPolicyConfigurationsPortRanges() = default;
};
class UpdateCustomRoutingEndpointsRequestEndpointConfigurationsPolicyConfigurations : public Darabonba::Model {
public:
  shared_ptr<string> address{};
  shared_ptr<vector<UpdateCustomRoutingEndpointsRequestEndpointConfigurationsPolicyConfigurationsPortRanges>> portRanges{};

  UpdateCustomRoutingEndpointsRequestEndpointConfigurationsPolicyConfigurations() {}

  explicit UpdateCustomRoutingEndpointsRequestEndpointConfigurationsPolicyConfigurations(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (address) {
      res["Address"] = boost::any(*address);
    }
    if (portRanges) {
      vector<boost::any> temp1;
      for(auto item1:*portRanges){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PortRanges"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Address") != m.end() && !m["Address"].empty()) {
      address = make_shared<string>(boost::any_cast<string>(m["Address"]));
    }
    if (m.find("PortRanges") != m.end() && !m["PortRanges"].empty()) {
      if (typeid(vector<boost::any>) == m["PortRanges"].type()) {
        vector<UpdateCustomRoutingEndpointsRequestEndpointConfigurationsPolicyConfigurationsPortRanges> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PortRanges"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateCustomRoutingEndpointsRequestEndpointConfigurationsPolicyConfigurationsPortRanges model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        portRanges = make_shared<vector<UpdateCustomRoutingEndpointsRequestEndpointConfigurationsPolicyConfigurationsPortRanges>>(expect1);
      }
    }
  }


  virtual ~UpdateCustomRoutingEndpointsRequestEndpointConfigurationsPolicyConfigurations() = default;
};
class UpdateCustomRoutingEndpointsRequestEndpointConfigurations : public Darabonba::Model {
public:
  shared_ptr<string> endpointId{};
  shared_ptr<vector<UpdateCustomRoutingEndpointsRequestEndpointConfigurationsPolicyConfigurations>> policyConfigurations{};
  shared_ptr<string> trafficToEndpointPolicy{};

  UpdateCustomRoutingEndpointsRequestEndpointConfigurations() {}

  explicit UpdateCustomRoutingEndpointsRequestEndpointConfigurations(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endpointId) {
      res["EndpointId"] = boost::any(*endpointId);
    }
    if (policyConfigurations) {
      vector<boost::any> temp1;
      for(auto item1:*policyConfigurations){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PolicyConfigurations"] = boost::any(temp1);
    }
    if (trafficToEndpointPolicy) {
      res["TrafficToEndpointPolicy"] = boost::any(*trafficToEndpointPolicy);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndpointId") != m.end() && !m["EndpointId"].empty()) {
      endpointId = make_shared<string>(boost::any_cast<string>(m["EndpointId"]));
    }
    if (m.find("PolicyConfigurations") != m.end() && !m["PolicyConfigurations"].empty()) {
      if (typeid(vector<boost::any>) == m["PolicyConfigurations"].type()) {
        vector<UpdateCustomRoutingEndpointsRequestEndpointConfigurationsPolicyConfigurations> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PolicyConfigurations"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateCustomRoutingEndpointsRequestEndpointConfigurationsPolicyConfigurations model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        policyConfigurations = make_shared<vector<UpdateCustomRoutingEndpointsRequestEndpointConfigurationsPolicyConfigurations>>(expect1);
      }
    }
    if (m.find("TrafficToEndpointPolicy") != m.end() && !m["TrafficToEndpointPolicy"].empty()) {
      trafficToEndpointPolicy = make_shared<string>(boost::any_cast<string>(m["TrafficToEndpointPolicy"]));
    }
  }


  virtual ~UpdateCustomRoutingEndpointsRequestEndpointConfigurations() = default;
};
class UpdateCustomRoutingEndpointsRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<vector<UpdateCustomRoutingEndpointsRequestEndpointConfigurations>> endpointConfigurations{};
  shared_ptr<string> endpointGroupId{};
  shared_ptr<string> regionId{};

  UpdateCustomRoutingEndpointsRequest() {}

  explicit UpdateCustomRoutingEndpointsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (endpointConfigurations) {
      vector<boost::any> temp1;
      for(auto item1:*endpointConfigurations){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["EndpointConfigurations"] = boost::any(temp1);
    }
    if (endpointGroupId) {
      res["EndpointGroupId"] = boost::any(*endpointGroupId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("EndpointConfigurations") != m.end() && !m["EndpointConfigurations"].empty()) {
      if (typeid(vector<boost::any>) == m["EndpointConfigurations"].type()) {
        vector<UpdateCustomRoutingEndpointsRequestEndpointConfigurations> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["EndpointConfigurations"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateCustomRoutingEndpointsRequestEndpointConfigurations model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        endpointConfigurations = make_shared<vector<UpdateCustomRoutingEndpointsRequestEndpointConfigurations>>(expect1);
      }
    }
    if (m.find("EndpointGroupId") != m.end() && !m["EndpointGroupId"].empty()) {
      endpointGroupId = make_shared<string>(boost::any_cast<string>(m["EndpointGroupId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~UpdateCustomRoutingEndpointsRequest() = default;
};
class UpdateCustomRoutingEndpointsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<string>> endpointIds{};
  shared_ptr<string> requestId{};

  UpdateCustomRoutingEndpointsResponseBody() {}

  explicit UpdateCustomRoutingEndpointsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endpointIds) {
      res["EndpointIds"] = boost::any(*endpointIds);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndpointIds") != m.end() && !m["EndpointIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["EndpointIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["EndpointIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      endpointIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateCustomRoutingEndpointsResponseBody() = default;
};
class UpdateCustomRoutingEndpointsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateCustomRoutingEndpointsResponseBody> body{};

  UpdateCustomRoutingEndpointsResponse() {}

  explicit UpdateCustomRoutingEndpointsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateCustomRoutingEndpointsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateCustomRoutingEndpointsResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateCustomRoutingEndpointsResponse() = default;
};
class UpdateDomainRequest : public Darabonba::Model {
public:
  shared_ptr<string> domain{};
  shared_ptr<string> regionId{};
  shared_ptr<string> targetDomain{};

  UpdateDomainRequest() {}

  explicit UpdateDomainRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (targetDomain) {
      res["TargetDomain"] = boost::any(*targetDomain);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("TargetDomain") != m.end() && !m["TargetDomain"].empty()) {
      targetDomain = make_shared<string>(boost::any_cast<string>(m["TargetDomain"]));
    }
  }


  virtual ~UpdateDomainRequest() = default;
};
class UpdateDomainResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateDomainResponseBody() {}

  explicit UpdateDomainResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateDomainResponseBody() = default;
};
class UpdateDomainResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateDomainResponseBody> body{};

  UpdateDomainResponse() {}

  explicit UpdateDomainResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateDomainResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateDomainResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateDomainResponse() = default;
};
class UpdateDomainStateRequest : public Darabonba::Model {
public:
  shared_ptr<string> domain{};
  shared_ptr<string> regionId{};

  UpdateDomainStateRequest() {}

  explicit UpdateDomainStateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~UpdateDomainStateRequest() = default;
};
class UpdateDomainStateResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> domain{};
  shared_ptr<string> requestId{};
  shared_ptr<string> state{};

  UpdateDomainStateResponseBody() {}

  explicit UpdateDomainStateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
  }


  virtual ~UpdateDomainStateResponseBody() = default;
};
class UpdateDomainStateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateDomainStateResponseBody> body{};

  UpdateDomainStateResponse() {}

  explicit UpdateDomainStateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateDomainStateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateDomainStateResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateDomainStateResponse() = default;
};
class UpdateEndpointGroupRequestEndpointConfigurations : public Darabonba::Model {
public:
  shared_ptr<bool> enableClientIPPreservation{};
  shared_ptr<string> endpoint{};
  shared_ptr<string> type{};
  shared_ptr<long> weight{};

  UpdateEndpointGroupRequestEndpointConfigurations() {}

  explicit UpdateEndpointGroupRequestEndpointConfigurations(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (enableClientIPPreservation) {
      res["EnableClientIPPreservation"] = boost::any(*enableClientIPPreservation);
    }
    if (endpoint) {
      res["Endpoint"] = boost::any(*endpoint);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (weight) {
      res["Weight"] = boost::any(*weight);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EnableClientIPPreservation") != m.end() && !m["EnableClientIPPreservation"].empty()) {
      enableClientIPPreservation = make_shared<bool>(boost::any_cast<bool>(m["EnableClientIPPreservation"]));
    }
    if (m.find("Endpoint") != m.end() && !m["Endpoint"].empty()) {
      endpoint = make_shared<string>(boost::any_cast<string>(m["Endpoint"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Weight") != m.end() && !m["Weight"].empty()) {
      weight = make_shared<long>(boost::any_cast<long>(m["Weight"]));
    }
  }


  virtual ~UpdateEndpointGroupRequestEndpointConfigurations() = default;
};
class UpdateEndpointGroupRequestPortOverrides : public Darabonba::Model {
public:
  shared_ptr<long> endpointPort{};
  shared_ptr<long> listenerPort{};

  UpdateEndpointGroupRequestPortOverrides() {}

  explicit UpdateEndpointGroupRequestPortOverrides(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endpointPort) {
      res["EndpointPort"] = boost::any(*endpointPort);
    }
    if (listenerPort) {
      res["ListenerPort"] = boost::any(*listenerPort);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndpointPort") != m.end() && !m["EndpointPort"].empty()) {
      endpointPort = make_shared<long>(boost::any_cast<long>(m["EndpointPort"]));
    }
    if (m.find("ListenerPort") != m.end() && !m["ListenerPort"].empty()) {
      listenerPort = make_shared<long>(boost::any_cast<long>(m["ListenerPort"]));
    }
  }


  virtual ~UpdateEndpointGroupRequestPortOverrides() = default;
};
class UpdateEndpointGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> description{};
  shared_ptr<vector<UpdateEndpointGroupRequestEndpointConfigurations>> endpointConfigurations{};
  shared_ptr<string> endpointGroupId{};
  shared_ptr<string> endpointGroupRegion{};
  shared_ptr<string> endpointRequestProtocol{};
  shared_ptr<bool> healthCheckEnabled{};
  shared_ptr<long> healthCheckIntervalSeconds{};
  shared_ptr<string> healthCheckPath{};
  shared_ptr<long> healthCheckPort{};
  shared_ptr<string> healthCheckProtocol{};
  shared_ptr<string> name{};
  shared_ptr<vector<UpdateEndpointGroupRequestPortOverrides>> portOverrides{};
  shared_ptr<string> regionId{};
  shared_ptr<long> thresholdCount{};
  shared_ptr<long> trafficPercentage{};

  UpdateEndpointGroupRequest() {}

  explicit UpdateEndpointGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (endpointConfigurations) {
      vector<boost::any> temp1;
      for(auto item1:*endpointConfigurations){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["EndpointConfigurations"] = boost::any(temp1);
    }
    if (endpointGroupId) {
      res["EndpointGroupId"] = boost::any(*endpointGroupId);
    }
    if (endpointGroupRegion) {
      res["EndpointGroupRegion"] = boost::any(*endpointGroupRegion);
    }
    if (endpointRequestProtocol) {
      res["EndpointRequestProtocol"] = boost::any(*endpointRequestProtocol);
    }
    if (healthCheckEnabled) {
      res["HealthCheckEnabled"] = boost::any(*healthCheckEnabled);
    }
    if (healthCheckIntervalSeconds) {
      res["HealthCheckIntervalSeconds"] = boost::any(*healthCheckIntervalSeconds);
    }
    if (healthCheckPath) {
      res["HealthCheckPath"] = boost::any(*healthCheckPath);
    }
    if (healthCheckPort) {
      res["HealthCheckPort"] = boost::any(*healthCheckPort);
    }
    if (healthCheckProtocol) {
      res["HealthCheckProtocol"] = boost::any(*healthCheckProtocol);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (portOverrides) {
      vector<boost::any> temp1;
      for(auto item1:*portOverrides){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PortOverrides"] = boost::any(temp1);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (thresholdCount) {
      res["ThresholdCount"] = boost::any(*thresholdCount);
    }
    if (trafficPercentage) {
      res["TrafficPercentage"] = boost::any(*trafficPercentage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("EndpointConfigurations") != m.end() && !m["EndpointConfigurations"].empty()) {
      if (typeid(vector<boost::any>) == m["EndpointConfigurations"].type()) {
        vector<UpdateEndpointGroupRequestEndpointConfigurations> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["EndpointConfigurations"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateEndpointGroupRequestEndpointConfigurations model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        endpointConfigurations = make_shared<vector<UpdateEndpointGroupRequestEndpointConfigurations>>(expect1);
      }
    }
    if (m.find("EndpointGroupId") != m.end() && !m["EndpointGroupId"].empty()) {
      endpointGroupId = make_shared<string>(boost::any_cast<string>(m["EndpointGroupId"]));
    }
    if (m.find("EndpointGroupRegion") != m.end() && !m["EndpointGroupRegion"].empty()) {
      endpointGroupRegion = make_shared<string>(boost::any_cast<string>(m["EndpointGroupRegion"]));
    }
    if (m.find("EndpointRequestProtocol") != m.end() && !m["EndpointRequestProtocol"].empty()) {
      endpointRequestProtocol = make_shared<string>(boost::any_cast<string>(m["EndpointRequestProtocol"]));
    }
    if (m.find("HealthCheckEnabled") != m.end() && !m["HealthCheckEnabled"].empty()) {
      healthCheckEnabled = make_shared<bool>(boost::any_cast<bool>(m["HealthCheckEnabled"]));
    }
    if (m.find("HealthCheckIntervalSeconds") != m.end() && !m["HealthCheckIntervalSeconds"].empty()) {
      healthCheckIntervalSeconds = make_shared<long>(boost::any_cast<long>(m["HealthCheckIntervalSeconds"]));
    }
    if (m.find("HealthCheckPath") != m.end() && !m["HealthCheckPath"].empty()) {
      healthCheckPath = make_shared<string>(boost::any_cast<string>(m["HealthCheckPath"]));
    }
    if (m.find("HealthCheckPort") != m.end() && !m["HealthCheckPort"].empty()) {
      healthCheckPort = make_shared<long>(boost::any_cast<long>(m["HealthCheckPort"]));
    }
    if (m.find("HealthCheckProtocol") != m.end() && !m["HealthCheckProtocol"].empty()) {
      healthCheckProtocol = make_shared<string>(boost::any_cast<string>(m["HealthCheckProtocol"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("PortOverrides") != m.end() && !m["PortOverrides"].empty()) {
      if (typeid(vector<boost::any>) == m["PortOverrides"].type()) {
        vector<UpdateEndpointGroupRequestPortOverrides> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PortOverrides"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateEndpointGroupRequestPortOverrides model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        portOverrides = make_shared<vector<UpdateEndpointGroupRequestPortOverrides>>(expect1);
      }
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ThresholdCount") != m.end() && !m["ThresholdCount"].empty()) {
      thresholdCount = make_shared<long>(boost::any_cast<long>(m["ThresholdCount"]));
    }
    if (m.find("TrafficPercentage") != m.end() && !m["TrafficPercentage"].empty()) {
      trafficPercentage = make_shared<long>(boost::any_cast<long>(m["TrafficPercentage"]));
    }
  }


  virtual ~UpdateEndpointGroupRequest() = default;
};
class UpdateEndpointGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateEndpointGroupResponseBody() {}

  explicit UpdateEndpointGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateEndpointGroupResponseBody() = default;
};
class UpdateEndpointGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateEndpointGroupResponseBody> body{};

  UpdateEndpointGroupResponse() {}

  explicit UpdateEndpointGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateEndpointGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateEndpointGroupResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateEndpointGroupResponse() = default;
};
class UpdateEndpointGroupAttributeRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> description{};
  shared_ptr<string> endpointGroupId{};
  shared_ptr<string> name{};
  shared_ptr<string> regionId{};

  UpdateEndpointGroupAttributeRequest() {}

  explicit UpdateEndpointGroupAttributeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (endpointGroupId) {
      res["EndpointGroupId"] = boost::any(*endpointGroupId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("EndpointGroupId") != m.end() && !m["EndpointGroupId"].empty()) {
      endpointGroupId = make_shared<string>(boost::any_cast<string>(m["EndpointGroupId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~UpdateEndpointGroupAttributeRequest() = default;
};
class UpdateEndpointGroupAttributeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateEndpointGroupAttributeResponseBody() {}

  explicit UpdateEndpointGroupAttributeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateEndpointGroupAttributeResponseBody() = default;
};
class UpdateEndpointGroupAttributeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateEndpointGroupAttributeResponseBody> body{};

  UpdateEndpointGroupAttributeResponse() {}

  explicit UpdateEndpointGroupAttributeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateEndpointGroupAttributeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateEndpointGroupAttributeResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateEndpointGroupAttributeResponse() = default;
};
class UpdateEndpointGroupsRequestEndpointGroupConfigurationsEndpointConfigurations : public Darabonba::Model {
public:
  shared_ptr<string> endpoint{};
  shared_ptr<string> type{};
  shared_ptr<long> weight{};

  UpdateEndpointGroupsRequestEndpointGroupConfigurationsEndpointConfigurations() {}

  explicit UpdateEndpointGroupsRequestEndpointGroupConfigurationsEndpointConfigurations(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endpoint) {
      res["Endpoint"] = boost::any(*endpoint);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (weight) {
      res["Weight"] = boost::any(*weight);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Endpoint") != m.end() && !m["Endpoint"].empty()) {
      endpoint = make_shared<string>(boost::any_cast<string>(m["Endpoint"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Weight") != m.end() && !m["Weight"].empty()) {
      weight = make_shared<long>(boost::any_cast<long>(m["Weight"]));
    }
  }


  virtual ~UpdateEndpointGroupsRequestEndpointGroupConfigurationsEndpointConfigurations() = default;
};
class UpdateEndpointGroupsRequestEndpointGroupConfigurationsPortOverrides : public Darabonba::Model {
public:
  shared_ptr<long> endpointPort{};
  shared_ptr<long> listenerPort{};

  UpdateEndpointGroupsRequestEndpointGroupConfigurationsPortOverrides() {}

  explicit UpdateEndpointGroupsRequestEndpointGroupConfigurationsPortOverrides(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endpointPort) {
      res["EndpointPort"] = boost::any(*endpointPort);
    }
    if (listenerPort) {
      res["ListenerPort"] = boost::any(*listenerPort);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndpointPort") != m.end() && !m["EndpointPort"].empty()) {
      endpointPort = make_shared<long>(boost::any_cast<long>(m["EndpointPort"]));
    }
    if (m.find("ListenerPort") != m.end() && !m["ListenerPort"].empty()) {
      listenerPort = make_shared<long>(boost::any_cast<long>(m["ListenerPort"]));
    }
  }


  virtual ~UpdateEndpointGroupsRequestEndpointGroupConfigurationsPortOverrides() = default;
};
class UpdateEndpointGroupsRequestEndpointGroupConfigurations : public Darabonba::Model {
public:
  shared_ptr<bool> enableClientIPPreservationProxyProtocol{};
  shared_ptr<bool> enableClientIPPreservationToa{};
  shared_ptr<vector<UpdateEndpointGroupsRequestEndpointGroupConfigurationsEndpointConfigurations>> endpointConfigurations{};
  shared_ptr<string> endpointGroupDescription{};
  shared_ptr<string> endpointGroupId{};
  shared_ptr<string> endpointGroupName{};
  shared_ptr<string> endpointRequestProtocol{};
  shared_ptr<bool> healthCheckEnabled{};
  shared_ptr<long> healthCheckIntervalSeconds{};
  shared_ptr<string> healthCheckPath{};
  shared_ptr<long> healthCheckPort{};
  shared_ptr<string> healthCheckProtocol{};
  shared_ptr<vector<UpdateEndpointGroupsRequestEndpointGroupConfigurationsPortOverrides>> portOverrides{};
  shared_ptr<long> thresholdCount{};
  shared_ptr<long> trafficPercentage{};

  UpdateEndpointGroupsRequestEndpointGroupConfigurations() {}

  explicit UpdateEndpointGroupsRequestEndpointGroupConfigurations(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (enableClientIPPreservationProxyProtocol) {
      res["EnableClientIPPreservationProxyProtocol"] = boost::any(*enableClientIPPreservationProxyProtocol);
    }
    if (enableClientIPPreservationToa) {
      res["EnableClientIPPreservationToa"] = boost::any(*enableClientIPPreservationToa);
    }
    if (endpointConfigurations) {
      vector<boost::any> temp1;
      for(auto item1:*endpointConfigurations){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["EndpointConfigurations"] = boost::any(temp1);
    }
    if (endpointGroupDescription) {
      res["EndpointGroupDescription"] = boost::any(*endpointGroupDescription);
    }
    if (endpointGroupId) {
      res["EndpointGroupId"] = boost::any(*endpointGroupId);
    }
    if (endpointGroupName) {
      res["EndpointGroupName"] = boost::any(*endpointGroupName);
    }
    if (endpointRequestProtocol) {
      res["EndpointRequestProtocol"] = boost::any(*endpointRequestProtocol);
    }
    if (healthCheckEnabled) {
      res["HealthCheckEnabled"] = boost::any(*healthCheckEnabled);
    }
    if (healthCheckIntervalSeconds) {
      res["HealthCheckIntervalSeconds"] = boost::any(*healthCheckIntervalSeconds);
    }
    if (healthCheckPath) {
      res["HealthCheckPath"] = boost::any(*healthCheckPath);
    }
    if (healthCheckPort) {
      res["HealthCheckPort"] = boost::any(*healthCheckPort);
    }
    if (healthCheckProtocol) {
      res["HealthCheckProtocol"] = boost::any(*healthCheckProtocol);
    }
    if (portOverrides) {
      vector<boost::any> temp1;
      for(auto item1:*portOverrides){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PortOverrides"] = boost::any(temp1);
    }
    if (thresholdCount) {
      res["ThresholdCount"] = boost::any(*thresholdCount);
    }
    if (trafficPercentage) {
      res["TrafficPercentage"] = boost::any(*trafficPercentage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EnableClientIPPreservationProxyProtocol") != m.end() && !m["EnableClientIPPreservationProxyProtocol"].empty()) {
      enableClientIPPreservationProxyProtocol = make_shared<bool>(boost::any_cast<bool>(m["EnableClientIPPreservationProxyProtocol"]));
    }
    if (m.find("EnableClientIPPreservationToa") != m.end() && !m["EnableClientIPPreservationToa"].empty()) {
      enableClientIPPreservationToa = make_shared<bool>(boost::any_cast<bool>(m["EnableClientIPPreservationToa"]));
    }
    if (m.find("EndpointConfigurations") != m.end() && !m["EndpointConfigurations"].empty()) {
      if (typeid(vector<boost::any>) == m["EndpointConfigurations"].type()) {
        vector<UpdateEndpointGroupsRequestEndpointGroupConfigurationsEndpointConfigurations> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["EndpointConfigurations"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateEndpointGroupsRequestEndpointGroupConfigurationsEndpointConfigurations model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        endpointConfigurations = make_shared<vector<UpdateEndpointGroupsRequestEndpointGroupConfigurationsEndpointConfigurations>>(expect1);
      }
    }
    if (m.find("EndpointGroupDescription") != m.end() && !m["EndpointGroupDescription"].empty()) {
      endpointGroupDescription = make_shared<string>(boost::any_cast<string>(m["EndpointGroupDescription"]));
    }
    if (m.find("EndpointGroupId") != m.end() && !m["EndpointGroupId"].empty()) {
      endpointGroupId = make_shared<string>(boost::any_cast<string>(m["EndpointGroupId"]));
    }
    if (m.find("EndpointGroupName") != m.end() && !m["EndpointGroupName"].empty()) {
      endpointGroupName = make_shared<string>(boost::any_cast<string>(m["EndpointGroupName"]));
    }
    if (m.find("EndpointRequestProtocol") != m.end() && !m["EndpointRequestProtocol"].empty()) {
      endpointRequestProtocol = make_shared<string>(boost::any_cast<string>(m["EndpointRequestProtocol"]));
    }
    if (m.find("HealthCheckEnabled") != m.end() && !m["HealthCheckEnabled"].empty()) {
      healthCheckEnabled = make_shared<bool>(boost::any_cast<bool>(m["HealthCheckEnabled"]));
    }
    if (m.find("HealthCheckIntervalSeconds") != m.end() && !m["HealthCheckIntervalSeconds"].empty()) {
      healthCheckIntervalSeconds = make_shared<long>(boost::any_cast<long>(m["HealthCheckIntervalSeconds"]));
    }
    if (m.find("HealthCheckPath") != m.end() && !m["HealthCheckPath"].empty()) {
      healthCheckPath = make_shared<string>(boost::any_cast<string>(m["HealthCheckPath"]));
    }
    if (m.find("HealthCheckPort") != m.end() && !m["HealthCheckPort"].empty()) {
      healthCheckPort = make_shared<long>(boost::any_cast<long>(m["HealthCheckPort"]));
    }
    if (m.find("HealthCheckProtocol") != m.end() && !m["HealthCheckProtocol"].empty()) {
      healthCheckProtocol = make_shared<string>(boost::any_cast<string>(m["HealthCheckProtocol"]));
    }
    if (m.find("PortOverrides") != m.end() && !m["PortOverrides"].empty()) {
      if (typeid(vector<boost::any>) == m["PortOverrides"].type()) {
        vector<UpdateEndpointGroupsRequestEndpointGroupConfigurationsPortOverrides> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PortOverrides"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateEndpointGroupsRequestEndpointGroupConfigurationsPortOverrides model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        portOverrides = make_shared<vector<UpdateEndpointGroupsRequestEndpointGroupConfigurationsPortOverrides>>(expect1);
      }
    }
    if (m.find("ThresholdCount") != m.end() && !m["ThresholdCount"].empty()) {
      thresholdCount = make_shared<long>(boost::any_cast<long>(m["ThresholdCount"]));
    }
    if (m.find("TrafficPercentage") != m.end() && !m["TrafficPercentage"].empty()) {
      trafficPercentage = make_shared<long>(boost::any_cast<long>(m["TrafficPercentage"]));
    }
  }


  virtual ~UpdateEndpointGroupsRequestEndpointGroupConfigurations() = default;
};
class UpdateEndpointGroupsRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<bool> dryRun{};
  shared_ptr<vector<UpdateEndpointGroupsRequestEndpointGroupConfigurations>> endpointGroupConfigurations{};
  shared_ptr<string> listenerId{};
  shared_ptr<string> regionId{};

  UpdateEndpointGroupsRequest() {}

  explicit UpdateEndpointGroupsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (dryRun) {
      res["DryRun"] = boost::any(*dryRun);
    }
    if (endpointGroupConfigurations) {
      vector<boost::any> temp1;
      for(auto item1:*endpointGroupConfigurations){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["EndpointGroupConfigurations"] = boost::any(temp1);
    }
    if (listenerId) {
      res["ListenerId"] = boost::any(*listenerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("DryRun") != m.end() && !m["DryRun"].empty()) {
      dryRun = make_shared<bool>(boost::any_cast<bool>(m["DryRun"]));
    }
    if (m.find("EndpointGroupConfigurations") != m.end() && !m["EndpointGroupConfigurations"].empty()) {
      if (typeid(vector<boost::any>) == m["EndpointGroupConfigurations"].type()) {
        vector<UpdateEndpointGroupsRequestEndpointGroupConfigurations> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["EndpointGroupConfigurations"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateEndpointGroupsRequestEndpointGroupConfigurations model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        endpointGroupConfigurations = make_shared<vector<UpdateEndpointGroupsRequestEndpointGroupConfigurations>>(expect1);
      }
    }
    if (m.find("ListenerId") != m.end() && !m["ListenerId"].empty()) {
      listenerId = make_shared<string>(boost::any_cast<string>(m["ListenerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~UpdateEndpointGroupsRequest() = default;
};
class UpdateEndpointGroupsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<string>> endpointGroupIds{};
  shared_ptr<string> requestId{};

  UpdateEndpointGroupsResponseBody() {}

  explicit UpdateEndpointGroupsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endpointGroupIds) {
      res["EndpointGroupIds"] = boost::any(*endpointGroupIds);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndpointGroupIds") != m.end() && !m["EndpointGroupIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["EndpointGroupIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["EndpointGroupIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      endpointGroupIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateEndpointGroupsResponseBody() = default;
};
class UpdateEndpointGroupsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateEndpointGroupsResponseBody> body{};

  UpdateEndpointGroupsResponse() {}

  explicit UpdateEndpointGroupsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateEndpointGroupsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateEndpointGroupsResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateEndpointGroupsResponse() = default;
};
class UpdateForwardingRulesRequestForwardingRulesRuleActionsForwardGroupConfigServerGroupTuples : public Darabonba::Model {
public:
  shared_ptr<string> endpointGroupId{};

  UpdateForwardingRulesRequestForwardingRulesRuleActionsForwardGroupConfigServerGroupTuples() {}

  explicit UpdateForwardingRulesRequestForwardingRulesRuleActionsForwardGroupConfigServerGroupTuples(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endpointGroupId) {
      res["EndpointGroupId"] = boost::any(*endpointGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndpointGroupId") != m.end() && !m["EndpointGroupId"].empty()) {
      endpointGroupId = make_shared<string>(boost::any_cast<string>(m["EndpointGroupId"]));
    }
  }


  virtual ~UpdateForwardingRulesRequestForwardingRulesRuleActionsForwardGroupConfigServerGroupTuples() = default;
};
class UpdateForwardingRulesRequestForwardingRulesRuleActionsForwardGroupConfig : public Darabonba::Model {
public:
  shared_ptr<vector<UpdateForwardingRulesRequestForwardingRulesRuleActionsForwardGroupConfigServerGroupTuples>> serverGroupTuples{};

  UpdateForwardingRulesRequestForwardingRulesRuleActionsForwardGroupConfig() {}

  explicit UpdateForwardingRulesRequestForwardingRulesRuleActionsForwardGroupConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (serverGroupTuples) {
      vector<boost::any> temp1;
      for(auto item1:*serverGroupTuples){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ServerGroupTuples"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ServerGroupTuples") != m.end() && !m["ServerGroupTuples"].empty()) {
      if (typeid(vector<boost::any>) == m["ServerGroupTuples"].type()) {
        vector<UpdateForwardingRulesRequestForwardingRulesRuleActionsForwardGroupConfigServerGroupTuples> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ServerGroupTuples"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateForwardingRulesRequestForwardingRulesRuleActionsForwardGroupConfigServerGroupTuples model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        serverGroupTuples = make_shared<vector<UpdateForwardingRulesRequestForwardingRulesRuleActionsForwardGroupConfigServerGroupTuples>>(expect1);
      }
    }
  }


  virtual ~UpdateForwardingRulesRequestForwardingRulesRuleActionsForwardGroupConfig() = default;
};
class UpdateForwardingRulesRequestForwardingRulesRuleActions : public Darabonba::Model {
public:
  shared_ptr<UpdateForwardingRulesRequestForwardingRulesRuleActionsForwardGroupConfig> forwardGroupConfig{};
  shared_ptr<long> order{};
  shared_ptr<string> ruleActionType{};
  shared_ptr<string> ruleActionValue{};

  UpdateForwardingRulesRequestForwardingRulesRuleActions() {}

  explicit UpdateForwardingRulesRequestForwardingRulesRuleActions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (forwardGroupConfig) {
      res["ForwardGroupConfig"] = forwardGroupConfig ? boost::any(forwardGroupConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (order) {
      res["Order"] = boost::any(*order);
    }
    if (ruleActionType) {
      res["RuleActionType"] = boost::any(*ruleActionType);
    }
    if (ruleActionValue) {
      res["RuleActionValue"] = boost::any(*ruleActionValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ForwardGroupConfig") != m.end() && !m["ForwardGroupConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["ForwardGroupConfig"].type()) {
        UpdateForwardingRulesRequestForwardingRulesRuleActionsForwardGroupConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ForwardGroupConfig"]));
        forwardGroupConfig = make_shared<UpdateForwardingRulesRequestForwardingRulesRuleActionsForwardGroupConfig>(model1);
      }
    }
    if (m.find("Order") != m.end() && !m["Order"].empty()) {
      order = make_shared<long>(boost::any_cast<long>(m["Order"]));
    }
    if (m.find("RuleActionType") != m.end() && !m["RuleActionType"].empty()) {
      ruleActionType = make_shared<string>(boost::any_cast<string>(m["RuleActionType"]));
    }
    if (m.find("RuleActionValue") != m.end() && !m["RuleActionValue"].empty()) {
      ruleActionValue = make_shared<string>(boost::any_cast<string>(m["RuleActionValue"]));
    }
  }


  virtual ~UpdateForwardingRulesRequestForwardingRulesRuleActions() = default;
};
class UpdateForwardingRulesRequestForwardingRulesRuleConditionsHostConfig : public Darabonba::Model {
public:
  shared_ptr<vector<string>> values{};

  UpdateForwardingRulesRequestForwardingRulesRuleConditionsHostConfig() {}

  explicit UpdateForwardingRulesRequestForwardingRulesRuleConditionsHostConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (values) {
      res["Values"] = boost::any(*values);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Values") != m.end() && !m["Values"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Values"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Values"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      values = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~UpdateForwardingRulesRequestForwardingRulesRuleConditionsHostConfig() = default;
};
class UpdateForwardingRulesRequestForwardingRulesRuleConditionsPathConfig : public Darabonba::Model {
public:
  shared_ptr<vector<string>> values{};

  UpdateForwardingRulesRequestForwardingRulesRuleConditionsPathConfig() {}

  explicit UpdateForwardingRulesRequestForwardingRulesRuleConditionsPathConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (values) {
      res["Values"] = boost::any(*values);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Values") != m.end() && !m["Values"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Values"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Values"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      values = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~UpdateForwardingRulesRequestForwardingRulesRuleConditionsPathConfig() = default;
};
class UpdateForwardingRulesRequestForwardingRulesRuleConditions : public Darabonba::Model {
public:
  shared_ptr<UpdateForwardingRulesRequestForwardingRulesRuleConditionsHostConfig> hostConfig{};
  shared_ptr<UpdateForwardingRulesRequestForwardingRulesRuleConditionsPathConfig> pathConfig{};
  shared_ptr<string> ruleConditionType{};
  shared_ptr<string> ruleConditionValue{};

  UpdateForwardingRulesRequestForwardingRulesRuleConditions() {}

  explicit UpdateForwardingRulesRequestForwardingRulesRuleConditions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (hostConfig) {
      res["HostConfig"] = hostConfig ? boost::any(hostConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pathConfig) {
      res["PathConfig"] = pathConfig ? boost::any(pathConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (ruleConditionType) {
      res["RuleConditionType"] = boost::any(*ruleConditionType);
    }
    if (ruleConditionValue) {
      res["RuleConditionValue"] = boost::any(*ruleConditionValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HostConfig") != m.end() && !m["HostConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["HostConfig"].type()) {
        UpdateForwardingRulesRequestForwardingRulesRuleConditionsHostConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["HostConfig"]));
        hostConfig = make_shared<UpdateForwardingRulesRequestForwardingRulesRuleConditionsHostConfig>(model1);
      }
    }
    if (m.find("PathConfig") != m.end() && !m["PathConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["PathConfig"].type()) {
        UpdateForwardingRulesRequestForwardingRulesRuleConditionsPathConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PathConfig"]));
        pathConfig = make_shared<UpdateForwardingRulesRequestForwardingRulesRuleConditionsPathConfig>(model1);
      }
    }
    if (m.find("RuleConditionType") != m.end() && !m["RuleConditionType"].empty()) {
      ruleConditionType = make_shared<string>(boost::any_cast<string>(m["RuleConditionType"]));
    }
    if (m.find("RuleConditionValue") != m.end() && !m["RuleConditionValue"].empty()) {
      ruleConditionValue = make_shared<string>(boost::any_cast<string>(m["RuleConditionValue"]));
    }
  }


  virtual ~UpdateForwardingRulesRequestForwardingRulesRuleConditions() = default;
};
class UpdateForwardingRulesRequestForwardingRules : public Darabonba::Model {
public:
  shared_ptr<string> forwardingRuleId{};
  shared_ptr<string> forwardingRuleName{};
  shared_ptr<long> priority{};
  shared_ptr<vector<UpdateForwardingRulesRequestForwardingRulesRuleActions>> ruleActions{};
  shared_ptr<vector<UpdateForwardingRulesRequestForwardingRulesRuleConditions>> ruleConditions{};
  shared_ptr<string> ruleDirection{};

  UpdateForwardingRulesRequestForwardingRules() {}

  explicit UpdateForwardingRulesRequestForwardingRules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (forwardingRuleId) {
      res["ForwardingRuleId"] = boost::any(*forwardingRuleId);
    }
    if (forwardingRuleName) {
      res["ForwardingRuleName"] = boost::any(*forwardingRuleName);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (ruleActions) {
      vector<boost::any> temp1;
      for(auto item1:*ruleActions){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RuleActions"] = boost::any(temp1);
    }
    if (ruleConditions) {
      vector<boost::any> temp1;
      for(auto item1:*ruleConditions){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RuleConditions"] = boost::any(temp1);
    }
    if (ruleDirection) {
      res["RuleDirection"] = boost::any(*ruleDirection);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ForwardingRuleId") != m.end() && !m["ForwardingRuleId"].empty()) {
      forwardingRuleId = make_shared<string>(boost::any_cast<string>(m["ForwardingRuleId"]));
    }
    if (m.find("ForwardingRuleName") != m.end() && !m["ForwardingRuleName"].empty()) {
      forwardingRuleName = make_shared<string>(boost::any_cast<string>(m["ForwardingRuleName"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<long>(boost::any_cast<long>(m["Priority"]));
    }
    if (m.find("RuleActions") != m.end() && !m["RuleActions"].empty()) {
      if (typeid(vector<boost::any>) == m["RuleActions"].type()) {
        vector<UpdateForwardingRulesRequestForwardingRulesRuleActions> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RuleActions"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateForwardingRulesRequestForwardingRulesRuleActions model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ruleActions = make_shared<vector<UpdateForwardingRulesRequestForwardingRulesRuleActions>>(expect1);
      }
    }
    if (m.find("RuleConditions") != m.end() && !m["RuleConditions"].empty()) {
      if (typeid(vector<boost::any>) == m["RuleConditions"].type()) {
        vector<UpdateForwardingRulesRequestForwardingRulesRuleConditions> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RuleConditions"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateForwardingRulesRequestForwardingRulesRuleConditions model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ruleConditions = make_shared<vector<UpdateForwardingRulesRequestForwardingRulesRuleConditions>>(expect1);
      }
    }
    if (m.find("RuleDirection") != m.end() && !m["RuleDirection"].empty()) {
      ruleDirection = make_shared<string>(boost::any_cast<string>(m["RuleDirection"]));
    }
  }


  virtual ~UpdateForwardingRulesRequestForwardingRules() = default;
};
class UpdateForwardingRulesRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceleratorId{};
  shared_ptr<string> clientToken{};
  shared_ptr<vector<UpdateForwardingRulesRequestForwardingRules>> forwardingRules{};
  shared_ptr<string> listenerId{};
  shared_ptr<string> regionId{};

  UpdateForwardingRulesRequest() {}

  explicit UpdateForwardingRulesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceleratorId) {
      res["AcceleratorId"] = boost::any(*acceleratorId);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (forwardingRules) {
      vector<boost::any> temp1;
      for(auto item1:*forwardingRules){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ForwardingRules"] = boost::any(temp1);
    }
    if (listenerId) {
      res["ListenerId"] = boost::any(*listenerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceleratorId") != m.end() && !m["AcceleratorId"].empty()) {
      acceleratorId = make_shared<string>(boost::any_cast<string>(m["AcceleratorId"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("ForwardingRules") != m.end() && !m["ForwardingRules"].empty()) {
      if (typeid(vector<boost::any>) == m["ForwardingRules"].type()) {
        vector<UpdateForwardingRulesRequestForwardingRules> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ForwardingRules"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateForwardingRulesRequestForwardingRules model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        forwardingRules = make_shared<vector<UpdateForwardingRulesRequestForwardingRules>>(expect1);
      }
    }
    if (m.find("ListenerId") != m.end() && !m["ListenerId"].empty()) {
      listenerId = make_shared<string>(boost::any_cast<string>(m["ListenerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~UpdateForwardingRulesRequest() = default;
};
class UpdateForwardingRulesResponseBodyForwardingRules : public Darabonba::Model {
public:
  shared_ptr<string> forwardingRuleId{};

  UpdateForwardingRulesResponseBodyForwardingRules() {}

  explicit UpdateForwardingRulesResponseBodyForwardingRules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (forwardingRuleId) {
      res["ForwardingRuleId"] = boost::any(*forwardingRuleId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ForwardingRuleId") != m.end() && !m["ForwardingRuleId"].empty()) {
      forwardingRuleId = make_shared<string>(boost::any_cast<string>(m["ForwardingRuleId"]));
    }
  }


  virtual ~UpdateForwardingRulesResponseBodyForwardingRules() = default;
};
class UpdateForwardingRulesResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<UpdateForwardingRulesResponseBodyForwardingRules>> forwardingRules{};
  shared_ptr<string> requestId{};

  UpdateForwardingRulesResponseBody() {}

  explicit UpdateForwardingRulesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (forwardingRules) {
      vector<boost::any> temp1;
      for(auto item1:*forwardingRules){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ForwardingRules"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ForwardingRules") != m.end() && !m["ForwardingRules"].empty()) {
      if (typeid(vector<boost::any>) == m["ForwardingRules"].type()) {
        vector<UpdateForwardingRulesResponseBodyForwardingRules> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ForwardingRules"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateForwardingRulesResponseBodyForwardingRules model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        forwardingRules = make_shared<vector<UpdateForwardingRulesResponseBodyForwardingRules>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateForwardingRulesResponseBody() = default;
};
class UpdateForwardingRulesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateForwardingRulesResponseBody> body{};

  UpdateForwardingRulesResponse() {}

  explicit UpdateForwardingRulesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateForwardingRulesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateForwardingRulesResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateForwardingRulesResponse() = default;
};
class UpdateIpSetRequest : public Darabonba::Model {
public:
  shared_ptr<long> bandwidth{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> ipSetId{};
  shared_ptr<string> regionId{};

  UpdateIpSetRequest() {}

  explicit UpdateIpSetRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bandwidth) {
      res["Bandwidth"] = boost::any(*bandwidth);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (ipSetId) {
      res["IpSetId"] = boost::any(*ipSetId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bandwidth") != m.end() && !m["Bandwidth"].empty()) {
      bandwidth = make_shared<long>(boost::any_cast<long>(m["Bandwidth"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("IpSetId") != m.end() && !m["IpSetId"].empty()) {
      ipSetId = make_shared<string>(boost::any_cast<string>(m["IpSetId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~UpdateIpSetRequest() = default;
};
class UpdateIpSetResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateIpSetResponseBody() {}

  explicit UpdateIpSetResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateIpSetResponseBody() = default;
};
class UpdateIpSetResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateIpSetResponseBody> body{};

  UpdateIpSetResponse() {}

  explicit UpdateIpSetResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateIpSetResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateIpSetResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateIpSetResponse() = default;
};
class UpdateIpSetsRequestIpSets : public Darabonba::Model {
public:
  shared_ptr<long> bandwidth{};
  shared_ptr<string> ipSetId{};

  UpdateIpSetsRequestIpSets() {}

  explicit UpdateIpSetsRequestIpSets(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bandwidth) {
      res["Bandwidth"] = boost::any(*bandwidth);
    }
    if (ipSetId) {
      res["IpSetId"] = boost::any(*ipSetId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bandwidth") != m.end() && !m["Bandwidth"].empty()) {
      bandwidth = make_shared<long>(boost::any_cast<long>(m["Bandwidth"]));
    }
    if (m.find("IpSetId") != m.end() && !m["IpSetId"].empty()) {
      ipSetId = make_shared<string>(boost::any_cast<string>(m["IpSetId"]));
    }
  }


  virtual ~UpdateIpSetsRequestIpSets() = default;
};
class UpdateIpSetsRequest : public Darabonba::Model {
public:
  shared_ptr<vector<UpdateIpSetsRequestIpSets>> ipSets{};
  shared_ptr<string> regionId{};

  UpdateIpSetsRequest() {}

  explicit UpdateIpSetsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ipSets) {
      vector<boost::any> temp1;
      for(auto item1:*ipSets){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["IpSets"] = boost::any(temp1);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IpSets") != m.end() && !m["IpSets"].empty()) {
      if (typeid(vector<boost::any>) == m["IpSets"].type()) {
        vector<UpdateIpSetsRequestIpSets> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["IpSets"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateIpSetsRequestIpSets model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ipSets = make_shared<vector<UpdateIpSetsRequestIpSets>>(expect1);
      }
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~UpdateIpSetsRequest() = default;
};
class UpdateIpSetsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateIpSetsResponseBody() {}

  explicit UpdateIpSetsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateIpSetsResponseBody() = default;
};
class UpdateIpSetsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateIpSetsResponseBody> body{};

  UpdateIpSetsResponse() {}

  explicit UpdateIpSetsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateIpSetsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateIpSetsResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateIpSetsResponse() = default;
};
class UpdateListenerRequestBackendPorts : public Darabonba::Model {
public:
  shared_ptr<long> fromPort{};
  shared_ptr<long> toPort{};

  UpdateListenerRequestBackendPorts() {}

  explicit UpdateListenerRequestBackendPorts(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fromPort) {
      res["FromPort"] = boost::any(*fromPort);
    }
    if (toPort) {
      res["ToPort"] = boost::any(*toPort);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FromPort") != m.end() && !m["FromPort"].empty()) {
      fromPort = make_shared<long>(boost::any_cast<long>(m["FromPort"]));
    }
    if (m.find("ToPort") != m.end() && !m["ToPort"].empty()) {
      toPort = make_shared<long>(boost::any_cast<long>(m["ToPort"]));
    }
  }


  virtual ~UpdateListenerRequestBackendPorts() = default;
};
class UpdateListenerRequestCertificates : public Darabonba::Model {
public:
  shared_ptr<string> id{};

  UpdateListenerRequestCertificates() {}

  explicit UpdateListenerRequestCertificates(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
  }


  virtual ~UpdateListenerRequestCertificates() = default;
};
class UpdateListenerRequestPortRanges : public Darabonba::Model {
public:
  shared_ptr<long> fromPort{};
  shared_ptr<long> toPort{};

  UpdateListenerRequestPortRanges() {}

  explicit UpdateListenerRequestPortRanges(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fromPort) {
      res["FromPort"] = boost::any(*fromPort);
    }
    if (toPort) {
      res["ToPort"] = boost::any(*toPort);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FromPort") != m.end() && !m["FromPort"].empty()) {
      fromPort = make_shared<long>(boost::any_cast<long>(m["FromPort"]));
    }
    if (m.find("ToPort") != m.end() && !m["ToPort"].empty()) {
      toPort = make_shared<long>(boost::any_cast<long>(m["ToPort"]));
    }
  }


  virtual ~UpdateListenerRequestPortRanges() = default;
};
class UpdateListenerRequestXForwardedForConfig : public Darabonba::Model {
public:
  shared_ptr<bool> XForwardedForGaApEnabled{};
  shared_ptr<bool> XForwardedForGaIdEnabled{};
  shared_ptr<bool> XForwardedForPortEnabled{};
  shared_ptr<bool> XForwardedForProtoEnabled{};
  shared_ptr<bool> XRealIpEnabled{};

  UpdateListenerRequestXForwardedForConfig() {}

  explicit UpdateListenerRequestXForwardedForConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (XForwardedForGaApEnabled) {
      res["XForwardedForGaApEnabled"] = boost::any(*XForwardedForGaApEnabled);
    }
    if (XForwardedForGaIdEnabled) {
      res["XForwardedForGaIdEnabled"] = boost::any(*XForwardedForGaIdEnabled);
    }
    if (XForwardedForPortEnabled) {
      res["XForwardedForPortEnabled"] = boost::any(*XForwardedForPortEnabled);
    }
    if (XForwardedForProtoEnabled) {
      res["XForwardedForProtoEnabled"] = boost::any(*XForwardedForProtoEnabled);
    }
    if (XRealIpEnabled) {
      res["XRealIpEnabled"] = boost::any(*XRealIpEnabled);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("XForwardedForGaApEnabled") != m.end() && !m["XForwardedForGaApEnabled"].empty()) {
      XForwardedForGaApEnabled = make_shared<bool>(boost::any_cast<bool>(m["XForwardedForGaApEnabled"]));
    }
    if (m.find("XForwardedForGaIdEnabled") != m.end() && !m["XForwardedForGaIdEnabled"].empty()) {
      XForwardedForGaIdEnabled = make_shared<bool>(boost::any_cast<bool>(m["XForwardedForGaIdEnabled"]));
    }
    if (m.find("XForwardedForPortEnabled") != m.end() && !m["XForwardedForPortEnabled"].empty()) {
      XForwardedForPortEnabled = make_shared<bool>(boost::any_cast<bool>(m["XForwardedForPortEnabled"]));
    }
    if (m.find("XForwardedForProtoEnabled") != m.end() && !m["XForwardedForProtoEnabled"].empty()) {
      XForwardedForProtoEnabled = make_shared<bool>(boost::any_cast<bool>(m["XForwardedForProtoEnabled"]));
    }
    if (m.find("XRealIpEnabled") != m.end() && !m["XRealIpEnabled"].empty()) {
      XRealIpEnabled = make_shared<bool>(boost::any_cast<bool>(m["XRealIpEnabled"]));
    }
  }


  virtual ~UpdateListenerRequestXForwardedForConfig() = default;
};
class UpdateListenerRequest : public Darabonba::Model {
public:
  shared_ptr<vector<UpdateListenerRequestBackendPorts>> backendPorts{};
  shared_ptr<vector<UpdateListenerRequestCertificates>> certificates{};
  shared_ptr<string> clientAffinity{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> description{};
  shared_ptr<string> listenerId{};
  shared_ptr<string> name{};
  shared_ptr<vector<UpdateListenerRequestPortRanges>> portRanges{};
  shared_ptr<string> protocol{};
  shared_ptr<string> proxyProtocol{};
  shared_ptr<string> regionId{};
  shared_ptr<string> securityPolicyId{};
  shared_ptr<UpdateListenerRequestXForwardedForConfig> XForwardedForConfig{};

  UpdateListenerRequest() {}

  explicit UpdateListenerRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (backendPorts) {
      vector<boost::any> temp1;
      for(auto item1:*backendPorts){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["BackendPorts"] = boost::any(temp1);
    }
    if (certificates) {
      vector<boost::any> temp1;
      for(auto item1:*certificates){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Certificates"] = boost::any(temp1);
    }
    if (clientAffinity) {
      res["ClientAffinity"] = boost::any(*clientAffinity);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (listenerId) {
      res["ListenerId"] = boost::any(*listenerId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (portRanges) {
      vector<boost::any> temp1;
      for(auto item1:*portRanges){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PortRanges"] = boost::any(temp1);
    }
    if (protocol) {
      res["Protocol"] = boost::any(*protocol);
    }
    if (proxyProtocol) {
      res["ProxyProtocol"] = boost::any(*proxyProtocol);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (securityPolicyId) {
      res["SecurityPolicyId"] = boost::any(*securityPolicyId);
    }
    if (XForwardedForConfig) {
      res["XForwardedForConfig"] = XForwardedForConfig ? boost::any(XForwardedForConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BackendPorts") != m.end() && !m["BackendPorts"].empty()) {
      if (typeid(vector<boost::any>) == m["BackendPorts"].type()) {
        vector<UpdateListenerRequestBackendPorts> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["BackendPorts"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateListenerRequestBackendPorts model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        backendPorts = make_shared<vector<UpdateListenerRequestBackendPorts>>(expect1);
      }
    }
    if (m.find("Certificates") != m.end() && !m["Certificates"].empty()) {
      if (typeid(vector<boost::any>) == m["Certificates"].type()) {
        vector<UpdateListenerRequestCertificates> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Certificates"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateListenerRequestCertificates model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        certificates = make_shared<vector<UpdateListenerRequestCertificates>>(expect1);
      }
    }
    if (m.find("ClientAffinity") != m.end() && !m["ClientAffinity"].empty()) {
      clientAffinity = make_shared<string>(boost::any_cast<string>(m["ClientAffinity"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("ListenerId") != m.end() && !m["ListenerId"].empty()) {
      listenerId = make_shared<string>(boost::any_cast<string>(m["ListenerId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("PortRanges") != m.end() && !m["PortRanges"].empty()) {
      if (typeid(vector<boost::any>) == m["PortRanges"].type()) {
        vector<UpdateListenerRequestPortRanges> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PortRanges"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateListenerRequestPortRanges model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        portRanges = make_shared<vector<UpdateListenerRequestPortRanges>>(expect1);
      }
    }
    if (m.find("Protocol") != m.end() && !m["Protocol"].empty()) {
      protocol = make_shared<string>(boost::any_cast<string>(m["Protocol"]));
    }
    if (m.find("ProxyProtocol") != m.end() && !m["ProxyProtocol"].empty()) {
      proxyProtocol = make_shared<string>(boost::any_cast<string>(m["ProxyProtocol"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SecurityPolicyId") != m.end() && !m["SecurityPolicyId"].empty()) {
      securityPolicyId = make_shared<string>(boost::any_cast<string>(m["SecurityPolicyId"]));
    }
    if (m.find("XForwardedForConfig") != m.end() && !m["XForwardedForConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["XForwardedForConfig"].type()) {
        UpdateListenerRequestXForwardedForConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["XForwardedForConfig"]));
        XForwardedForConfig = make_shared<UpdateListenerRequestXForwardedForConfig>(model1);
      }
    }
  }


  virtual ~UpdateListenerRequest() = default;
};
class UpdateListenerResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateListenerResponseBody() {}

  explicit UpdateListenerResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateListenerResponseBody() = default;
};
class UpdateListenerResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateListenerResponseBody> body{};

  UpdateListenerResponse() {}

  explicit UpdateListenerResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateListenerResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateListenerResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateListenerResponse() = default;
};
class Client : Alibabacloud_OpenApi::Client {
public:
  explicit Client(const shared_ptr<Alibabacloud_OpenApi::Config>& config);
  string getEndpoint(shared_ptr<string> productId,
                     shared_ptr<string> regionId,
                     shared_ptr<string> endpointRule,
                     shared_ptr<string> network,
                     shared_ptr<string> suffix,
                     shared_ptr<map<string, string>> endpointMap,
                     shared_ptr<string> endpoint);
  AddEntriesToAclResponse addEntriesToAclWithOptions(shared_ptr<AddEntriesToAclRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddEntriesToAclResponse addEntriesToAcl(shared_ptr<AddEntriesToAclRequest> request);
  AssociateAclsWithListenerResponse associateAclsWithListenerWithOptions(shared_ptr<AssociateAclsWithListenerRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AssociateAclsWithListenerResponse associateAclsWithListener(shared_ptr<AssociateAclsWithListenerRequest> request);
  AssociateAdditionalCertificatesWithListenerResponse associateAdditionalCertificatesWithListenerWithOptions(shared_ptr<AssociateAdditionalCertificatesWithListenerRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AssociateAdditionalCertificatesWithListenerResponse associateAdditionalCertificatesWithListener(shared_ptr<AssociateAdditionalCertificatesWithListenerRequest> request);
  AttachDdosToAcceleratorResponse attachDdosToAcceleratorWithOptions(shared_ptr<AttachDdosToAcceleratorRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AttachDdosToAcceleratorResponse attachDdosToAccelerator(shared_ptr<AttachDdosToAcceleratorRequest> request);
  AttachLogStoreToEndpointGroupResponse attachLogStoreToEndpointGroupWithOptions(shared_ptr<AttachLogStoreToEndpointGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AttachLogStoreToEndpointGroupResponse attachLogStoreToEndpointGroup(shared_ptr<AttachLogStoreToEndpointGroupRequest> request);
  BandwidthPackageAddAcceleratorResponse bandwidthPackageAddAcceleratorWithOptions(shared_ptr<BandwidthPackageAddAcceleratorRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  BandwidthPackageAddAcceleratorResponse bandwidthPackageAddAccelerator(shared_ptr<BandwidthPackageAddAcceleratorRequest> request);
  BandwidthPackageRemoveAcceleratorResponse bandwidthPackageRemoveAcceleratorWithOptions(shared_ptr<BandwidthPackageRemoveAcceleratorRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  BandwidthPackageRemoveAcceleratorResponse bandwidthPackageRemoveAccelerator(shared_ptr<BandwidthPackageRemoveAcceleratorRequest> request);
  ChangeResourceGroupResponse changeResourceGroupWithOptions(shared_ptr<ChangeResourceGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ChangeResourceGroupResponse changeResourceGroup(shared_ptr<ChangeResourceGroupRequest> request);
  ConfigEndpointProbeResponse configEndpointProbeWithOptions(shared_ptr<ConfigEndpointProbeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ConfigEndpointProbeResponse configEndpointProbe(shared_ptr<ConfigEndpointProbeRequest> request);
  CreateAcceleratorResponse createAcceleratorWithOptions(shared_ptr<CreateAcceleratorRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateAcceleratorResponse createAccelerator(shared_ptr<CreateAcceleratorRequest> request);
  CreateAclResponse createAclWithOptions(shared_ptr<CreateAclRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateAclResponse createAcl(shared_ptr<CreateAclRequest> request);
  CreateApplicationMonitorResponse createApplicationMonitorWithOptions(shared_ptr<CreateApplicationMonitorRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateApplicationMonitorResponse createApplicationMonitor(shared_ptr<CreateApplicationMonitorRequest> request);
  CreateBandwidthPackageResponse createBandwidthPackageWithOptions(shared_ptr<CreateBandwidthPackageRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateBandwidthPackageResponse createBandwidthPackage(shared_ptr<CreateBandwidthPackageRequest> request);
  CreateBasicAccelerateIpResponse createBasicAccelerateIpWithOptions(shared_ptr<CreateBasicAccelerateIpRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateBasicAccelerateIpResponse createBasicAccelerateIp(shared_ptr<CreateBasicAccelerateIpRequest> request);
  CreateBasicAccelerateIpEndpointRelationResponse createBasicAccelerateIpEndpointRelationWithOptions(shared_ptr<CreateBasicAccelerateIpEndpointRelationRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateBasicAccelerateIpEndpointRelationResponse createBasicAccelerateIpEndpointRelation(shared_ptr<CreateBasicAccelerateIpEndpointRelationRequest> request);
  CreateBasicAccelerateIpEndpointRelationsResponse createBasicAccelerateIpEndpointRelationsWithOptions(shared_ptr<CreateBasicAccelerateIpEndpointRelationsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateBasicAccelerateIpEndpointRelationsResponse createBasicAccelerateIpEndpointRelations(shared_ptr<CreateBasicAccelerateIpEndpointRelationsRequest> request);
  CreateBasicAcceleratorResponse createBasicAcceleratorWithOptions(shared_ptr<CreateBasicAcceleratorRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateBasicAcceleratorResponse createBasicAccelerator(shared_ptr<CreateBasicAcceleratorRequest> request);
  CreateBasicEndpointResponse createBasicEndpointWithOptions(shared_ptr<CreateBasicEndpointRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateBasicEndpointResponse createBasicEndpoint(shared_ptr<CreateBasicEndpointRequest> request);
  CreateBasicEndpointGroupResponse createBasicEndpointGroupWithOptions(shared_ptr<CreateBasicEndpointGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateBasicEndpointGroupResponse createBasicEndpointGroup(shared_ptr<CreateBasicEndpointGroupRequest> request);
  CreateBasicEndpointsResponse createBasicEndpointsWithOptions(shared_ptr<CreateBasicEndpointsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateBasicEndpointsResponse createBasicEndpoints(shared_ptr<CreateBasicEndpointsRequest> request);
  CreateBasicIpSetResponse createBasicIpSetWithOptions(shared_ptr<CreateBasicIpSetRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateBasicIpSetResponse createBasicIpSet(shared_ptr<CreateBasicIpSetRequest> request);
  CreateCustomRoutingEndpointGroupDestinationsResponse createCustomRoutingEndpointGroupDestinationsWithOptions(shared_ptr<CreateCustomRoutingEndpointGroupDestinationsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateCustomRoutingEndpointGroupDestinationsResponse createCustomRoutingEndpointGroupDestinations(shared_ptr<CreateCustomRoutingEndpointGroupDestinationsRequest> request);
  CreateCustomRoutingEndpointGroupsResponse createCustomRoutingEndpointGroupsWithOptions(shared_ptr<CreateCustomRoutingEndpointGroupsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateCustomRoutingEndpointGroupsResponse createCustomRoutingEndpointGroups(shared_ptr<CreateCustomRoutingEndpointGroupsRequest> request);
  CreateCustomRoutingEndpointTrafficPoliciesResponse createCustomRoutingEndpointTrafficPoliciesWithOptions(shared_ptr<CreateCustomRoutingEndpointTrafficPoliciesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateCustomRoutingEndpointTrafficPoliciesResponse createCustomRoutingEndpointTrafficPolicies(shared_ptr<CreateCustomRoutingEndpointTrafficPoliciesRequest> request);
  CreateCustomRoutingEndpointsResponse createCustomRoutingEndpointsWithOptions(shared_ptr<CreateCustomRoutingEndpointsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateCustomRoutingEndpointsResponse createCustomRoutingEndpoints(shared_ptr<CreateCustomRoutingEndpointsRequest> request);
  CreateDomainResponse createDomainWithOptions(shared_ptr<CreateDomainRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateDomainResponse createDomain(shared_ptr<CreateDomainRequest> request);
  CreateEndpointGroupResponse createEndpointGroupWithOptions(shared_ptr<CreateEndpointGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateEndpointGroupResponse createEndpointGroup(shared_ptr<CreateEndpointGroupRequest> request);
  CreateEndpointGroupsResponse createEndpointGroupsWithOptions(shared_ptr<CreateEndpointGroupsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateEndpointGroupsResponse createEndpointGroups(shared_ptr<CreateEndpointGroupsRequest> request);
  CreateForwardingRulesResponse createForwardingRulesWithOptions(shared_ptr<CreateForwardingRulesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateForwardingRulesResponse createForwardingRules(shared_ptr<CreateForwardingRulesRequest> request);
  CreateIpSetsResponse createIpSetsWithOptions(shared_ptr<CreateIpSetsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateIpSetsResponse createIpSets(shared_ptr<CreateIpSetsRequest> request);
  CreateListenerResponse createListenerWithOptions(shared_ptr<CreateListenerRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateListenerResponse createListener(shared_ptr<CreateListenerRequest> request);
  CreateSpareIpsResponse createSpareIpsWithOptions(shared_ptr<CreateSpareIpsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateSpareIpsResponse createSpareIps(shared_ptr<CreateSpareIpsRequest> request);
  DeleteAcceleratorResponse deleteAcceleratorWithOptions(shared_ptr<DeleteAcceleratorRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteAcceleratorResponse deleteAccelerator(shared_ptr<DeleteAcceleratorRequest> request);
  DeleteAclResponse deleteAclWithOptions(shared_ptr<DeleteAclRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteAclResponse deleteAcl(shared_ptr<DeleteAclRequest> request);
  DeleteApplicationMonitorResponse deleteApplicationMonitorWithOptions(shared_ptr<DeleteApplicationMonitorRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteApplicationMonitorResponse deleteApplicationMonitor(shared_ptr<DeleteApplicationMonitorRequest> request);
  DeleteBandwidthPackageResponse deleteBandwidthPackageWithOptions(shared_ptr<DeleteBandwidthPackageRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteBandwidthPackageResponse deleteBandwidthPackage(shared_ptr<DeleteBandwidthPackageRequest> request);
  DeleteBasicAccelerateIpResponse deleteBasicAccelerateIpWithOptions(shared_ptr<DeleteBasicAccelerateIpRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteBasicAccelerateIpResponse deleteBasicAccelerateIp(shared_ptr<DeleteBasicAccelerateIpRequest> request);
  DeleteBasicAccelerateIpEndpointRelationResponse deleteBasicAccelerateIpEndpointRelationWithOptions(shared_ptr<DeleteBasicAccelerateIpEndpointRelationRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteBasicAccelerateIpEndpointRelationResponse deleteBasicAccelerateIpEndpointRelation(shared_ptr<DeleteBasicAccelerateIpEndpointRelationRequest> request);
  DeleteBasicAcceleratorResponse deleteBasicAcceleratorWithOptions(shared_ptr<DeleteBasicAcceleratorRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteBasicAcceleratorResponse deleteBasicAccelerator(shared_ptr<DeleteBasicAcceleratorRequest> request);
  DeleteBasicEndpointResponse deleteBasicEndpointWithOptions(shared_ptr<DeleteBasicEndpointRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteBasicEndpointResponse deleteBasicEndpoint(shared_ptr<DeleteBasicEndpointRequest> request);
  DeleteBasicEndpointGroupResponse deleteBasicEndpointGroupWithOptions(shared_ptr<DeleteBasicEndpointGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteBasicEndpointGroupResponse deleteBasicEndpointGroup(shared_ptr<DeleteBasicEndpointGroupRequest> request);
  DeleteBasicIpSetResponse deleteBasicIpSetWithOptions(shared_ptr<DeleteBasicIpSetRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteBasicIpSetResponse deleteBasicIpSet(shared_ptr<DeleteBasicIpSetRequest> request);
  DeleteCustomRoutingEndpointGroupDestinationsResponse deleteCustomRoutingEndpointGroupDestinationsWithOptions(shared_ptr<DeleteCustomRoutingEndpointGroupDestinationsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteCustomRoutingEndpointGroupDestinationsResponse deleteCustomRoutingEndpointGroupDestinations(shared_ptr<DeleteCustomRoutingEndpointGroupDestinationsRequest> request);
  DeleteCustomRoutingEndpointGroupsResponse deleteCustomRoutingEndpointGroupsWithOptions(shared_ptr<DeleteCustomRoutingEndpointGroupsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteCustomRoutingEndpointGroupsResponse deleteCustomRoutingEndpointGroups(shared_ptr<DeleteCustomRoutingEndpointGroupsRequest> request);
  DeleteCustomRoutingEndpointTrafficPoliciesResponse deleteCustomRoutingEndpointTrafficPoliciesWithOptions(shared_ptr<DeleteCustomRoutingEndpointTrafficPoliciesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteCustomRoutingEndpointTrafficPoliciesResponse deleteCustomRoutingEndpointTrafficPolicies(shared_ptr<DeleteCustomRoutingEndpointTrafficPoliciesRequest> request);
  DeleteCustomRoutingEndpointsResponse deleteCustomRoutingEndpointsWithOptions(shared_ptr<DeleteCustomRoutingEndpointsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteCustomRoutingEndpointsResponse deleteCustomRoutingEndpoints(shared_ptr<DeleteCustomRoutingEndpointsRequest> request);
  DeleteDomainAcceleratorRelationResponse deleteDomainAcceleratorRelationWithOptions(shared_ptr<DeleteDomainAcceleratorRelationRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteDomainAcceleratorRelationResponse deleteDomainAcceleratorRelation(shared_ptr<DeleteDomainAcceleratorRelationRequest> request);
  DeleteEndpointGroupResponse deleteEndpointGroupWithOptions(shared_ptr<DeleteEndpointGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteEndpointGroupResponse deleteEndpointGroup(shared_ptr<DeleteEndpointGroupRequest> request);
  DeleteEndpointGroupsResponse deleteEndpointGroupsWithOptions(shared_ptr<DeleteEndpointGroupsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteEndpointGroupsResponse deleteEndpointGroups(shared_ptr<DeleteEndpointGroupsRequest> request);
  DeleteForwardingRulesResponse deleteForwardingRulesWithOptions(shared_ptr<DeleteForwardingRulesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteForwardingRulesResponse deleteForwardingRules(shared_ptr<DeleteForwardingRulesRequest> request);
  DeleteIpSetResponse deleteIpSetWithOptions(shared_ptr<DeleteIpSetRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteIpSetResponse deleteIpSet(shared_ptr<DeleteIpSetRequest> request);
  DeleteIpSetsResponse deleteIpSetsWithOptions(shared_ptr<DeleteIpSetsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteIpSetsResponse deleteIpSets(shared_ptr<DeleteIpSetsRequest> request);
  DeleteListenerResponse deleteListenerWithOptions(shared_ptr<DeleteListenerRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteListenerResponse deleteListener(shared_ptr<DeleteListenerRequest> request);
  DeleteSpareIpsResponse deleteSpareIpsWithOptions(shared_ptr<DeleteSpareIpsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteSpareIpsResponse deleteSpareIps(shared_ptr<DeleteSpareIpsRequest> request);
  DescribeAcceleratorResponse describeAcceleratorWithOptions(shared_ptr<DescribeAcceleratorRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeAcceleratorResponse describeAccelerator(shared_ptr<DescribeAcceleratorRequest> request);
  DescribeAcceleratorAutoRenewAttributeResponse describeAcceleratorAutoRenewAttributeWithOptions(shared_ptr<DescribeAcceleratorAutoRenewAttributeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeAcceleratorAutoRenewAttributeResponse describeAcceleratorAutoRenewAttribute(shared_ptr<DescribeAcceleratorAutoRenewAttributeRequest> request);
  DescribeApplicationMonitorResponse describeApplicationMonitorWithOptions(shared_ptr<DescribeApplicationMonitorRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeApplicationMonitorResponse describeApplicationMonitor(shared_ptr<DescribeApplicationMonitorRequest> request);
  DescribeBandwidthPackageResponse describeBandwidthPackageWithOptions(shared_ptr<DescribeBandwidthPackageRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeBandwidthPackageResponse describeBandwidthPackage(shared_ptr<DescribeBandwidthPackageRequest> request);
  DescribeBandwidthPackageAutoRenewAttributeResponse describeBandwidthPackageAutoRenewAttributeWithOptions(shared_ptr<DescribeBandwidthPackageAutoRenewAttributeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeBandwidthPackageAutoRenewAttributeResponse describeBandwidthPackageAutoRenewAttribute(shared_ptr<DescribeBandwidthPackageAutoRenewAttributeRequest> request);
  DescribeCommodityResponse describeCommodityWithOptions(shared_ptr<DescribeCommodityRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeCommodityResponse describeCommodity(shared_ptr<DescribeCommodityRequest> request);
  DescribeCommodityPriceResponse describeCommodityPriceWithOptions(shared_ptr<DescribeCommodityPriceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeCommodityPriceResponse describeCommodityPrice(shared_ptr<DescribeCommodityPriceRequest> request);
  DescribeCustomRoutingEndPointTrafficPolicyResponse describeCustomRoutingEndPointTrafficPolicyWithOptions(shared_ptr<DescribeCustomRoutingEndPointTrafficPolicyRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeCustomRoutingEndPointTrafficPolicyResponse describeCustomRoutingEndPointTrafficPolicy(shared_ptr<DescribeCustomRoutingEndPointTrafficPolicyRequest> request);
  DescribeCustomRoutingEndpointResponse describeCustomRoutingEndpointWithOptions(shared_ptr<DescribeCustomRoutingEndpointRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeCustomRoutingEndpointResponse describeCustomRoutingEndpoint(shared_ptr<DescribeCustomRoutingEndpointRequest> request);
  DescribeCustomRoutingEndpointGroupResponse describeCustomRoutingEndpointGroupWithOptions(shared_ptr<DescribeCustomRoutingEndpointGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeCustomRoutingEndpointGroupResponse describeCustomRoutingEndpointGroup(shared_ptr<DescribeCustomRoutingEndpointGroupRequest> request);
  DescribeCustomRoutingEndpointGroupDestinationsResponse describeCustomRoutingEndpointGroupDestinationsWithOptions(shared_ptr<DescribeCustomRoutingEndpointGroupDestinationsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeCustomRoutingEndpointGroupDestinationsResponse describeCustomRoutingEndpointGroupDestinations(shared_ptr<DescribeCustomRoutingEndpointGroupDestinationsRequest> request);
  DescribeEndpointGroupResponse describeEndpointGroupWithOptions(shared_ptr<DescribeEndpointGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeEndpointGroupResponse describeEndpointGroup(shared_ptr<DescribeEndpointGroupRequest> request);
  DescribeIpSetResponse describeIpSetWithOptions(shared_ptr<DescribeIpSetRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeIpSetResponse describeIpSet(shared_ptr<DescribeIpSetRequest> request);
  DescribeListenerResponse describeListenerWithOptions(shared_ptr<DescribeListenerRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeListenerResponse describeListener(shared_ptr<DescribeListenerRequest> request);
  DescribeRegionsResponse describeRegionsWithOptions(shared_ptr<DescribeRegionsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeRegionsResponse describeRegions(shared_ptr<DescribeRegionsRequest> request);
  DetachDdosFromAcceleratorResponse detachDdosFromAcceleratorWithOptions(shared_ptr<DetachDdosFromAcceleratorRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DetachDdosFromAcceleratorResponse detachDdosFromAccelerator(shared_ptr<DetachDdosFromAcceleratorRequest> request);
  DetachLogStoreFromEndpointGroupResponse detachLogStoreFromEndpointGroupWithOptions(shared_ptr<DetachLogStoreFromEndpointGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DetachLogStoreFromEndpointGroupResponse detachLogStoreFromEndpointGroup(shared_ptr<DetachLogStoreFromEndpointGroupRequest> request);
  DetectApplicationMonitorResponse detectApplicationMonitorWithOptions(shared_ptr<DetectApplicationMonitorRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DetectApplicationMonitorResponse detectApplicationMonitor(shared_ptr<DetectApplicationMonitorRequest> request);
  DisableApplicationMonitorResponse disableApplicationMonitorWithOptions(shared_ptr<DisableApplicationMonitorRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DisableApplicationMonitorResponse disableApplicationMonitor(shared_ptr<DisableApplicationMonitorRequest> request);
  DissociateAclsFromListenerResponse dissociateAclsFromListenerWithOptions(shared_ptr<DissociateAclsFromListenerRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DissociateAclsFromListenerResponse dissociateAclsFromListener(shared_ptr<DissociateAclsFromListenerRequest> request);
  DissociateAdditionalCertificatesFromListenerResponse dissociateAdditionalCertificatesFromListenerWithOptions(shared_ptr<DissociateAdditionalCertificatesFromListenerRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DissociateAdditionalCertificatesFromListenerResponse dissociateAdditionalCertificatesFromListener(shared_ptr<DissociateAdditionalCertificatesFromListenerRequest> request);
  EnableApplicationMonitorResponse enableApplicationMonitorWithOptions(shared_ptr<EnableApplicationMonitorRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  EnableApplicationMonitorResponse enableApplicationMonitor(shared_ptr<EnableApplicationMonitorRequest> request);
  GetAclResponse getAclWithOptions(shared_ptr<GetAclRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetAclResponse getAcl(shared_ptr<GetAclRequest> request);
  GetBasicAccelerateIpResponse getBasicAccelerateIpWithOptions(shared_ptr<GetBasicAccelerateIpRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetBasicAccelerateIpResponse getBasicAccelerateIp(shared_ptr<GetBasicAccelerateIpRequest> request);
  GetBasicAccelerateIpEndpointRelationResponse getBasicAccelerateIpEndpointRelationWithOptions(shared_ptr<GetBasicAccelerateIpEndpointRelationRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetBasicAccelerateIpEndpointRelationResponse getBasicAccelerateIpEndpointRelation(shared_ptr<GetBasicAccelerateIpEndpointRelationRequest> request);
  GetBasicAccelerateIpIdleCountResponse getBasicAccelerateIpIdleCountWithOptions(shared_ptr<GetBasicAccelerateIpIdleCountRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetBasicAccelerateIpIdleCountResponse getBasicAccelerateIpIdleCount(shared_ptr<GetBasicAccelerateIpIdleCountRequest> request);
  GetBasicAcceleratorResponse getBasicAcceleratorWithOptions(shared_ptr<GetBasicAcceleratorRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetBasicAcceleratorResponse getBasicAccelerator(shared_ptr<GetBasicAcceleratorRequest> request);
  GetBasicEndpointResponse getBasicEndpointWithOptions(shared_ptr<GetBasicEndpointRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetBasicEndpointResponse getBasicEndpoint(shared_ptr<GetBasicEndpointRequest> request);
  GetBasicEndpointGroupResponse getBasicEndpointGroupWithOptions(shared_ptr<GetBasicEndpointGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetBasicEndpointGroupResponse getBasicEndpointGroup(shared_ptr<GetBasicEndpointGroupRequest> request);
  GetBasicIpSetResponse getBasicIpSetWithOptions(shared_ptr<GetBasicIpSetRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetBasicIpSetResponse getBasicIpSet(shared_ptr<GetBasicIpSetRequest> request);
  GetHealthStatusResponse getHealthStatusWithOptions(shared_ptr<GetHealthStatusRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetHealthStatusResponse getHealthStatus(shared_ptr<GetHealthStatusRequest> request);
  GetInvalidDomainCountResponse getInvalidDomainCountWithOptions(shared_ptr<GetInvalidDomainCountRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetInvalidDomainCountResponse getInvalidDomainCount(shared_ptr<GetInvalidDomainCountRequest> request);
  GetIpsetsBandwidthLimitResponse getIpsetsBandwidthLimitWithOptions(shared_ptr<GetIpsetsBandwidthLimitRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetIpsetsBandwidthLimitResponse getIpsetsBandwidthLimit(shared_ptr<GetIpsetsBandwidthLimitRequest> request);
  GetSpareIpResponse getSpareIpWithOptions(shared_ptr<GetSpareIpRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetSpareIpResponse getSpareIp(shared_ptr<GetSpareIpRequest> request);
  ListAccelerateAreasResponse listAccelerateAreasWithOptions(shared_ptr<ListAccelerateAreasRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListAccelerateAreasResponse listAccelerateAreas(shared_ptr<ListAccelerateAreasRequest> request);
  ListAcceleratorsResponse listAcceleratorsWithOptions(shared_ptr<ListAcceleratorsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListAcceleratorsResponse listAccelerators(shared_ptr<ListAcceleratorsRequest> request);
  ListAclsResponse listAclsWithOptions(shared_ptr<ListAclsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListAclsResponse listAcls(shared_ptr<ListAclsRequest> request);
  ListApplicationMonitorResponse listApplicationMonitorWithOptions(shared_ptr<ListApplicationMonitorRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListApplicationMonitorResponse listApplicationMonitor(shared_ptr<ListApplicationMonitorRequest> request);
  ListApplicationMonitorDetectResultResponse listApplicationMonitorDetectResultWithOptions(shared_ptr<ListApplicationMonitorDetectResultRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListApplicationMonitorDetectResultResponse listApplicationMonitorDetectResult(shared_ptr<ListApplicationMonitorDetectResultRequest> request);
  ListAvailableAccelerateAreasResponse listAvailableAccelerateAreasWithOptions(shared_ptr<ListAvailableAccelerateAreasRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListAvailableAccelerateAreasResponse listAvailableAccelerateAreas(shared_ptr<ListAvailableAccelerateAreasRequest> request);
  ListAvailableBusiRegionsResponse listAvailableBusiRegionsWithOptions(shared_ptr<ListAvailableBusiRegionsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListAvailableBusiRegionsResponse listAvailableBusiRegions(shared_ptr<ListAvailableBusiRegionsRequest> request);
  ListBandwidthPackagesResponse listBandwidthPackagesWithOptions(shared_ptr<ListBandwidthPackagesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListBandwidthPackagesResponse listBandwidthPackages(shared_ptr<ListBandwidthPackagesRequest> request);
  ListBandwidthackagesResponse listBandwidthackagesWithOptions(shared_ptr<ListBandwidthackagesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListBandwidthackagesResponse listBandwidthackages(shared_ptr<ListBandwidthackagesRequest> request);
  ListBasicAccelerateIpEndpointRelationsResponse listBasicAccelerateIpEndpointRelationsWithOptions(shared_ptr<ListBasicAccelerateIpEndpointRelationsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListBasicAccelerateIpEndpointRelationsResponse listBasicAccelerateIpEndpointRelations(shared_ptr<ListBasicAccelerateIpEndpointRelationsRequest> request);
  ListBasicAccelerateIpsResponse listBasicAccelerateIpsWithOptions(shared_ptr<ListBasicAccelerateIpsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListBasicAccelerateIpsResponse listBasicAccelerateIps(shared_ptr<ListBasicAccelerateIpsRequest> request);
  ListBasicAcceleratorsResponse listBasicAcceleratorsWithOptions(shared_ptr<ListBasicAcceleratorsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListBasicAcceleratorsResponse listBasicAccelerators(shared_ptr<ListBasicAcceleratorsRequest> request);
  ListBasicEndpointsResponse listBasicEndpointsWithOptions(shared_ptr<ListBasicEndpointsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListBasicEndpointsResponse listBasicEndpoints(shared_ptr<ListBasicEndpointsRequest> request);
  ListBusiRegionsResponse listBusiRegionsWithOptions(shared_ptr<ListBusiRegionsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListBusiRegionsResponse listBusiRegions(shared_ptr<ListBusiRegionsRequest> request);
  ListCommonAreasResponse listCommonAreasWithOptions(shared_ptr<ListCommonAreasRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListCommonAreasResponse listCommonAreas(shared_ptr<ListCommonAreasRequest> request);
  ListCustomRoutingEndpointGroupDestinationsResponse listCustomRoutingEndpointGroupDestinationsWithOptions(shared_ptr<ListCustomRoutingEndpointGroupDestinationsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListCustomRoutingEndpointGroupDestinationsResponse listCustomRoutingEndpointGroupDestinations(shared_ptr<ListCustomRoutingEndpointGroupDestinationsRequest> request);
  ListCustomRoutingEndpointGroupsResponse listCustomRoutingEndpointGroupsWithOptions(shared_ptr<ListCustomRoutingEndpointGroupsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListCustomRoutingEndpointGroupsResponse listCustomRoutingEndpointGroups(shared_ptr<ListCustomRoutingEndpointGroupsRequest> request);
  ListCustomRoutingEndpointTrafficPoliciesResponse listCustomRoutingEndpointTrafficPoliciesWithOptions(shared_ptr<ListCustomRoutingEndpointTrafficPoliciesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListCustomRoutingEndpointTrafficPoliciesResponse listCustomRoutingEndpointTrafficPolicies(shared_ptr<ListCustomRoutingEndpointTrafficPoliciesRequest> request);
  ListCustomRoutingEndpointsResponse listCustomRoutingEndpointsWithOptions(shared_ptr<ListCustomRoutingEndpointsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListCustomRoutingEndpointsResponse listCustomRoutingEndpoints(shared_ptr<ListCustomRoutingEndpointsRequest> request);
  ListCustomRoutingPortMappingsResponse listCustomRoutingPortMappingsWithOptions(shared_ptr<ListCustomRoutingPortMappingsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListCustomRoutingPortMappingsResponse listCustomRoutingPortMappings(shared_ptr<ListCustomRoutingPortMappingsRequest> request);
  ListCustomRoutingPortMappingsByDestinationResponse listCustomRoutingPortMappingsByDestinationWithOptions(shared_ptr<ListCustomRoutingPortMappingsByDestinationRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListCustomRoutingPortMappingsByDestinationResponse listCustomRoutingPortMappingsByDestination(shared_ptr<ListCustomRoutingPortMappingsByDestinationRequest> request);
  ListDomainsResponse listDomainsWithOptions(shared_ptr<ListDomainsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListDomainsResponse listDomains(shared_ptr<ListDomainsRequest> request);
  ListEndpointGroupsResponse listEndpointGroupsWithOptions(shared_ptr<ListEndpointGroupsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListEndpointGroupsResponse listEndpointGroups(shared_ptr<ListEndpointGroupsRequest> request);
  ListForwardingRulesResponse listForwardingRulesWithOptions(shared_ptr<ListForwardingRulesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListForwardingRulesResponse listForwardingRules(shared_ptr<ListForwardingRulesRequest> request);
  ListIpSetsResponse listIpSetsWithOptions(shared_ptr<ListIpSetsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListIpSetsResponse listIpSets(shared_ptr<ListIpSetsRequest> request);
  ListIspTypesResponse listIspTypesWithOptions(shared_ptr<ListIspTypesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListIspTypesResponse listIspTypes(shared_ptr<ListIspTypesRequest> request);
  ListListenerCertificatesResponse listListenerCertificatesWithOptions(shared_ptr<ListListenerCertificatesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListListenerCertificatesResponse listListenerCertificates(shared_ptr<ListListenerCertificatesRequest> request);
  ListListenersResponse listListenersWithOptions(shared_ptr<ListListenersRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListListenersResponse listListeners(shared_ptr<ListListenersRequest> request);
  ListSpareIpsResponse listSpareIpsWithOptions(shared_ptr<ListSpareIpsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListSpareIpsResponse listSpareIps(shared_ptr<ListSpareIpsRequest> request);
  ListSystemSecurityPoliciesResponse listSystemSecurityPoliciesWithOptions(shared_ptr<ListSystemSecurityPoliciesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListSystemSecurityPoliciesResponse listSystemSecurityPolicies(shared_ptr<ListSystemSecurityPoliciesRequest> request);
  ListTagResourcesResponse listTagResourcesWithOptions(shared_ptr<ListTagResourcesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListTagResourcesResponse listTagResources(shared_ptr<ListTagResourcesRequest> request);
  RemoveEntriesFromAclResponse removeEntriesFromAclWithOptions(shared_ptr<RemoveEntriesFromAclRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RemoveEntriesFromAclResponse removeEntriesFromAcl(shared_ptr<RemoveEntriesFromAclRequest> request);
  ReplaceBandwidthPackageResponse replaceBandwidthPackageWithOptions(shared_ptr<ReplaceBandwidthPackageRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ReplaceBandwidthPackageResponse replaceBandwidthPackage(shared_ptr<ReplaceBandwidthPackageRequest> request);
  TagResourcesResponse tagResourcesWithOptions(shared_ptr<TagResourcesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  TagResourcesResponse tagResources(shared_ptr<TagResourcesRequest> request);
  UntagResourcesResponse untagResourcesWithOptions(shared_ptr<UntagResourcesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UntagResourcesResponse untagResources(shared_ptr<UntagResourcesRequest> request);
  UpdateAcceleratorResponse updateAcceleratorWithOptions(shared_ptr<UpdateAcceleratorRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateAcceleratorResponse updateAccelerator(shared_ptr<UpdateAcceleratorRequest> request);
  UpdateAcceleratorAutoRenewAttributeResponse updateAcceleratorAutoRenewAttributeWithOptions(shared_ptr<UpdateAcceleratorAutoRenewAttributeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateAcceleratorAutoRenewAttributeResponse updateAcceleratorAutoRenewAttribute(shared_ptr<UpdateAcceleratorAutoRenewAttributeRequest> request);
  UpdateAcceleratorConfirmResponse updateAcceleratorConfirmWithOptions(shared_ptr<UpdateAcceleratorConfirmRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateAcceleratorConfirmResponse updateAcceleratorConfirm(shared_ptr<UpdateAcceleratorConfirmRequest> request);
  UpdateAcceleratorCrossBorderModeResponse updateAcceleratorCrossBorderModeWithOptions(shared_ptr<UpdateAcceleratorCrossBorderModeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateAcceleratorCrossBorderModeResponse updateAcceleratorCrossBorderMode(shared_ptr<UpdateAcceleratorCrossBorderModeRequest> request);
  UpdateAclAttributeResponse updateAclAttributeWithOptions(shared_ptr<UpdateAclAttributeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateAclAttributeResponse updateAclAttribute(shared_ptr<UpdateAclAttributeRequest> request);
  UpdateAdditionalCertificateWithListenerResponse updateAdditionalCertificateWithListenerWithOptions(shared_ptr<UpdateAdditionalCertificateWithListenerRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateAdditionalCertificateWithListenerResponse updateAdditionalCertificateWithListener(shared_ptr<UpdateAdditionalCertificateWithListenerRequest> request);
  UpdateApplicationMonitorResponse updateApplicationMonitorWithOptions(shared_ptr<UpdateApplicationMonitorRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateApplicationMonitorResponse updateApplicationMonitor(shared_ptr<UpdateApplicationMonitorRequest> request);
  UpdateBandwidthPackagaAutoRenewAttributeResponse updateBandwidthPackagaAutoRenewAttributeWithOptions(shared_ptr<UpdateBandwidthPackagaAutoRenewAttributeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateBandwidthPackagaAutoRenewAttributeResponse updateBandwidthPackagaAutoRenewAttribute(shared_ptr<UpdateBandwidthPackagaAutoRenewAttributeRequest> request);
  UpdateBandwidthPackageResponse updateBandwidthPackageWithOptions(shared_ptr<UpdateBandwidthPackageRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateBandwidthPackageResponse updateBandwidthPackage(shared_ptr<UpdateBandwidthPackageRequest> request);
  UpdateBasicAcceleratorResponse updateBasicAcceleratorWithOptions(shared_ptr<UpdateBasicAcceleratorRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateBasicAcceleratorResponse updateBasicAccelerator(shared_ptr<UpdateBasicAcceleratorRequest> request);
  UpdateBasicEndpointResponse updateBasicEndpointWithOptions(shared_ptr<UpdateBasicEndpointRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateBasicEndpointResponse updateBasicEndpoint(shared_ptr<UpdateBasicEndpointRequest> request);
  UpdateBasicEndpointGroupResponse updateBasicEndpointGroupWithOptions(shared_ptr<UpdateBasicEndpointGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateBasicEndpointGroupResponse updateBasicEndpointGroup(shared_ptr<UpdateBasicEndpointGroupRequest> request);
  UpdateBasicIpSetResponse updateBasicIpSetWithOptions(shared_ptr<UpdateBasicIpSetRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateBasicIpSetResponse updateBasicIpSet(shared_ptr<UpdateBasicIpSetRequest> request);
  UpdateCustomRoutingEndpointGroupAttributeResponse updateCustomRoutingEndpointGroupAttributeWithOptions(shared_ptr<UpdateCustomRoutingEndpointGroupAttributeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateCustomRoutingEndpointGroupAttributeResponse updateCustomRoutingEndpointGroupAttribute(shared_ptr<UpdateCustomRoutingEndpointGroupAttributeRequest> request);
  UpdateCustomRoutingEndpointGroupDestinationsResponse updateCustomRoutingEndpointGroupDestinationsWithOptions(shared_ptr<UpdateCustomRoutingEndpointGroupDestinationsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateCustomRoutingEndpointGroupDestinationsResponse updateCustomRoutingEndpointGroupDestinations(shared_ptr<UpdateCustomRoutingEndpointGroupDestinationsRequest> request);
  UpdateCustomRoutingEndpointTrafficPoliciesResponse updateCustomRoutingEndpointTrafficPoliciesWithOptions(shared_ptr<UpdateCustomRoutingEndpointTrafficPoliciesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateCustomRoutingEndpointTrafficPoliciesResponse updateCustomRoutingEndpointTrafficPolicies(shared_ptr<UpdateCustomRoutingEndpointTrafficPoliciesRequest> request);
  UpdateCustomRoutingEndpointsResponse updateCustomRoutingEndpointsWithOptions(shared_ptr<UpdateCustomRoutingEndpointsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateCustomRoutingEndpointsResponse updateCustomRoutingEndpoints(shared_ptr<UpdateCustomRoutingEndpointsRequest> request);
  UpdateDomainResponse updateDomainWithOptions(shared_ptr<UpdateDomainRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateDomainResponse updateDomain(shared_ptr<UpdateDomainRequest> request);
  UpdateDomainStateResponse updateDomainStateWithOptions(shared_ptr<UpdateDomainStateRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateDomainStateResponse updateDomainState(shared_ptr<UpdateDomainStateRequest> request);
  UpdateEndpointGroupResponse updateEndpointGroupWithOptions(shared_ptr<UpdateEndpointGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateEndpointGroupResponse updateEndpointGroup(shared_ptr<UpdateEndpointGroupRequest> request);
  UpdateEndpointGroupAttributeResponse updateEndpointGroupAttributeWithOptions(shared_ptr<UpdateEndpointGroupAttributeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateEndpointGroupAttributeResponse updateEndpointGroupAttribute(shared_ptr<UpdateEndpointGroupAttributeRequest> request);
  UpdateEndpointGroupsResponse updateEndpointGroupsWithOptions(shared_ptr<UpdateEndpointGroupsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateEndpointGroupsResponse updateEndpointGroups(shared_ptr<UpdateEndpointGroupsRequest> request);
  UpdateForwardingRulesResponse updateForwardingRulesWithOptions(shared_ptr<UpdateForwardingRulesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateForwardingRulesResponse updateForwardingRules(shared_ptr<UpdateForwardingRulesRequest> request);
  UpdateIpSetResponse updateIpSetWithOptions(shared_ptr<UpdateIpSetRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateIpSetResponse updateIpSet(shared_ptr<UpdateIpSetRequest> request);
  UpdateIpSetsResponse updateIpSetsWithOptions(shared_ptr<UpdateIpSetsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateIpSetsResponse updateIpSets(shared_ptr<UpdateIpSetsRequest> request);
  UpdateListenerResponse updateListenerWithOptions(shared_ptr<UpdateListenerRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateListenerResponse updateListener(shared_ptr<UpdateListenerRequest> request);

  virtual ~Client() = default;
};
} // namespace Alibabacloud_Ga20191120

#endif
