// This file is auto-generated, don't edit it. Thanks.

#ifndef ALIBABACLOUD_CCC20200701_H_
#define ALIBABACLOUD_CCC20200701_H_

#include <alibabacloud/open_api.hpp>
#include <boost/any.hpp>
#include <boost/throw_exception.hpp>
#include <darabonba/core.hpp>
#include <darabonba/util.hpp>
#include <iostream>
#include <map>
#include <vector>

using namespace std;

namespace Alibabacloud_CCC20200701 {
class AbortCampaignRequest : public Darabonba::Model {
public:
  shared_ptr<string> campaignId{};
  shared_ptr<string> instanceId{};

  AbortCampaignRequest() {}

  explicit AbortCampaignRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (campaignId) {
      res["CampaignId"] = boost::any(*campaignId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CampaignId") != m.end() && !m["CampaignId"].empty()) {
      campaignId = make_shared<string>(boost::any_cast<string>(m["CampaignId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~AbortCampaignRequest() = default;
};
class AbortCampaignResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  AbortCampaignResponseBody() {}

  explicit AbortCampaignResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<string>(boost::any_cast<string>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AbortCampaignResponseBody() = default;
};
class AbortCampaignResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AbortCampaignResponseBody> body{};

  AbortCampaignResponse() {}

  explicit AbortCampaignResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AbortCampaignResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AbortCampaignResponseBody>(model1);
      }
    }
  }


  virtual ~AbortCampaignResponse() = default;
};
class AddCasesRequestCaseList : public Darabonba::Model {
public:
  shared_ptr<string> customVariables{};
  shared_ptr<string> phoneNumber{};
  shared_ptr<string> referenceId{};

  AddCasesRequestCaseList() {}

  explicit AddCasesRequestCaseList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (customVariables) {
      res["CustomVariables"] = boost::any(*customVariables);
    }
    if (phoneNumber) {
      res["PhoneNumber"] = boost::any(*phoneNumber);
    }
    if (referenceId) {
      res["ReferenceId"] = boost::any(*referenceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CustomVariables") != m.end() && !m["CustomVariables"].empty()) {
      customVariables = make_shared<string>(boost::any_cast<string>(m["CustomVariables"]));
    }
    if (m.find("PhoneNumber") != m.end() && !m["PhoneNumber"].empty()) {
      phoneNumber = make_shared<string>(boost::any_cast<string>(m["PhoneNumber"]));
    }
    if (m.find("ReferenceId") != m.end() && !m["ReferenceId"].empty()) {
      referenceId = make_shared<string>(boost::any_cast<string>(m["ReferenceId"]));
    }
  }


  virtual ~AddCasesRequestCaseList() = default;
};
class AddCasesRequest : public Darabonba::Model {
public:
  shared_ptr<string> campaignId{};
  shared_ptr<vector<AddCasesRequestCaseList>> caseList{};
  shared_ptr<string> instanceId{};

  AddCasesRequest() {}

  explicit AddCasesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (campaignId) {
      res["CampaignId"] = boost::any(*campaignId);
    }
    if (caseList) {
      vector<boost::any> temp1;
      for(auto item1:*caseList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CaseList"] = boost::any(temp1);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CampaignId") != m.end() && !m["CampaignId"].empty()) {
      campaignId = make_shared<string>(boost::any_cast<string>(m["CampaignId"]));
    }
    if (m.find("CaseList") != m.end() && !m["CaseList"].empty()) {
      if (typeid(vector<boost::any>) == m["CaseList"].type()) {
        vector<AddCasesRequestCaseList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CaseList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            AddCasesRequestCaseList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        caseList = make_shared<vector<AddCasesRequestCaseList>>(expect1);
      }
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~AddCasesRequest() = default;
};
class AddCasesShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> campaignId{};
  shared_ptr<string> caseListShrink{};
  shared_ptr<string> instanceId{};

  AddCasesShrinkRequest() {}

  explicit AddCasesShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (campaignId) {
      res["CampaignId"] = boost::any(*campaignId);
    }
    if (caseListShrink) {
      res["CaseList"] = boost::any(*caseListShrink);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CampaignId") != m.end() && !m["CampaignId"].empty()) {
      campaignId = make_shared<string>(boost::any_cast<string>(m["CampaignId"]));
    }
    if (m.find("CaseList") != m.end() && !m["CaseList"].empty()) {
      caseListShrink = make_shared<string>(boost::any_cast<string>(m["CaseList"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~AddCasesShrinkRequest() = default;
};
class AddCasesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  AddCasesResponseBody() {}

  explicit AddCasesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<string>(boost::any_cast<string>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AddCasesResponseBody() = default;
};
class AddCasesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddCasesResponseBody> body{};

  AddCasesResponse() {}

  explicit AddCasesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddCasesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddCasesResponseBody>(model1);
      }
    }
  }


  virtual ~AddCasesResponse() = default;
};
class AddNumbersToSkillGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> numberList{};
  shared_ptr<string> skillGroupId{};

  AddNumbersToSkillGroupRequest() {}

  explicit AddNumbersToSkillGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (numberList) {
      res["NumberList"] = boost::any(*numberList);
    }
    if (skillGroupId) {
      res["SkillGroupId"] = boost::any(*skillGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("NumberList") != m.end() && !m["NumberList"].empty()) {
      numberList = make_shared<string>(boost::any_cast<string>(m["NumberList"]));
    }
    if (m.find("SkillGroupId") != m.end() && !m["SkillGroupId"].empty()) {
      skillGroupId = make_shared<string>(boost::any_cast<string>(m["SkillGroupId"]));
    }
  }


  virtual ~AddNumbersToSkillGroupRequest() = default;
};
class AddNumbersToSkillGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  AddNumbersToSkillGroupResponseBody() {}

  explicit AddNumbersToSkillGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AddNumbersToSkillGroupResponseBody() = default;
};
class AddNumbersToSkillGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddNumbersToSkillGroupResponseBody> body{};

  AddNumbersToSkillGroupResponse() {}

  explicit AddNumbersToSkillGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddNumbersToSkillGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddNumbersToSkillGroupResponseBody>(model1);
      }
    }
  }


  virtual ~AddNumbersToSkillGroupResponse() = default;
};
class AddPersonalNumbersToUserRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> numberList{};
  shared_ptr<string> userId{};

  AddPersonalNumbersToUserRequest() {}

  explicit AddPersonalNumbersToUserRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (numberList) {
      res["NumberList"] = boost::any(*numberList);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("NumberList") != m.end() && !m["NumberList"].empty()) {
      numberList = make_shared<string>(boost::any_cast<string>(m["NumberList"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~AddPersonalNumbersToUserRequest() = default;
};
class AddPersonalNumbersToUserResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<vector<string>> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  AddPersonalNumbersToUserResponseBody() {}

  explicit AddPersonalNumbersToUserResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Data"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      data = make_shared<vector<string>>(toVec1);
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AddPersonalNumbersToUserResponseBody() = default;
};
class AddPersonalNumbersToUserResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddPersonalNumbersToUserResponseBody> body{};

  AddPersonalNumbersToUserResponse() {}

  explicit AddPersonalNumbersToUserResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddPersonalNumbersToUserResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddPersonalNumbersToUserResponseBody>(model1);
      }
    }
  }


  virtual ~AddPersonalNumbersToUserResponse() = default;
};
class AddPhoneNumberToSkillGroupsRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> number{};
  shared_ptr<string> skillGroupIdList{};

  AddPhoneNumberToSkillGroupsRequest() {}

  explicit AddPhoneNumberToSkillGroupsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (number) {
      res["Number"] = boost::any(*number);
    }
    if (skillGroupIdList) {
      res["SkillGroupIdList"] = boost::any(*skillGroupIdList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Number") != m.end() && !m["Number"].empty()) {
      number = make_shared<string>(boost::any_cast<string>(m["Number"]));
    }
    if (m.find("SkillGroupIdList") != m.end() && !m["SkillGroupIdList"].empty()) {
      skillGroupIdList = make_shared<string>(boost::any_cast<string>(m["SkillGroupIdList"]));
    }
  }


  virtual ~AddPhoneNumberToSkillGroupsRequest() = default;
};
class AddPhoneNumberToSkillGroupsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  AddPhoneNumberToSkillGroupsResponseBody() {}

  explicit AddPhoneNumberToSkillGroupsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AddPhoneNumberToSkillGroupsResponseBody() = default;
};
class AddPhoneNumberToSkillGroupsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddPhoneNumberToSkillGroupsResponseBody> body{};

  AddPhoneNumberToSkillGroupsResponse() {}

  explicit AddPhoneNumberToSkillGroupsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddPhoneNumberToSkillGroupsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddPhoneNumberToSkillGroupsResponseBody>(model1);
      }
    }
  }


  virtual ~AddPhoneNumberToSkillGroupsResponse() = default;
};
class AddPhoneNumbersRequest : public Darabonba::Model {
public:
  shared_ptr<string> contactFlowId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> numberGroupId{};
  shared_ptr<string> numberList{};
  shared_ptr<string> usage{};

  AddPhoneNumbersRequest() {}

  explicit AddPhoneNumbersRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contactFlowId) {
      res["ContactFlowId"] = boost::any(*contactFlowId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (numberGroupId) {
      res["NumberGroupId"] = boost::any(*numberGroupId);
    }
    if (numberList) {
      res["NumberList"] = boost::any(*numberList);
    }
    if (usage) {
      res["Usage"] = boost::any(*usage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ContactFlowId") != m.end() && !m["ContactFlowId"].empty()) {
      contactFlowId = make_shared<string>(boost::any_cast<string>(m["ContactFlowId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("NumberGroupId") != m.end() && !m["NumberGroupId"].empty()) {
      numberGroupId = make_shared<string>(boost::any_cast<string>(m["NumberGroupId"]));
    }
    if (m.find("NumberList") != m.end() && !m["NumberList"].empty()) {
      numberList = make_shared<string>(boost::any_cast<string>(m["NumberList"]));
    }
    if (m.find("Usage") != m.end() && !m["Usage"].empty()) {
      usage = make_shared<string>(boost::any_cast<string>(m["Usage"]));
    }
  }


  virtual ~AddPhoneNumbersRequest() = default;
};
class AddPhoneNumbersResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<vector<string>> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  AddPhoneNumbersResponseBody() {}

  explicit AddPhoneNumbersResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Data"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      data = make_shared<vector<string>>(toVec1);
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AddPhoneNumbersResponseBody() = default;
};
class AddPhoneNumbersResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddPhoneNumbersResponseBody> body{};

  AddPhoneNumbersResponse() {}

  explicit AddPhoneNumbersResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddPhoneNumbersResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddPhoneNumbersResponseBody>(model1);
      }
    }
  }


  virtual ~AddPhoneNumbersResponse() = default;
};
class AddSkillGroupsToUserRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> skillLevelList{};
  shared_ptr<string> userId{};

  AddSkillGroupsToUserRequest() {}

  explicit AddSkillGroupsToUserRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (skillLevelList) {
      res["SkillLevelList"] = boost::any(*skillLevelList);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("SkillLevelList") != m.end() && !m["SkillLevelList"].empty()) {
      skillLevelList = make_shared<string>(boost::any_cast<string>(m["SkillLevelList"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~AddSkillGroupsToUserRequest() = default;
};
class AddSkillGroupsToUserResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  AddSkillGroupsToUserResponseBody() {}

  explicit AddSkillGroupsToUserResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AddSkillGroupsToUserResponseBody() = default;
};
class AddSkillGroupsToUserResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddSkillGroupsToUserResponseBody> body{};

  AddSkillGroupsToUserResponse() {}

  explicit AddSkillGroupsToUserResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddSkillGroupsToUserResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddSkillGroupsToUserResponseBody>(model1);
      }
    }
  }


  virtual ~AddSkillGroupsToUserResponse() = default;
};
class AddUsersToSkillGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> skillGroupId{};
  shared_ptr<string> userSkillLevelList{};

  AddUsersToSkillGroupRequest() {}

  explicit AddUsersToSkillGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (skillGroupId) {
      res["SkillGroupId"] = boost::any(*skillGroupId);
    }
    if (userSkillLevelList) {
      res["UserSkillLevelList"] = boost::any(*userSkillLevelList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("SkillGroupId") != m.end() && !m["SkillGroupId"].empty()) {
      skillGroupId = make_shared<string>(boost::any_cast<string>(m["SkillGroupId"]));
    }
    if (m.find("UserSkillLevelList") != m.end() && !m["UserSkillLevelList"].empty()) {
      userSkillLevelList = make_shared<string>(boost::any_cast<string>(m["UserSkillLevelList"]));
    }
  }


  virtual ~AddUsersToSkillGroupRequest() = default;
};
class AddUsersToSkillGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  AddUsersToSkillGroupResponseBody() {}

  explicit AddUsersToSkillGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AddUsersToSkillGroupResponseBody() = default;
};
class AddUsersToSkillGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddUsersToSkillGroupResponseBody> body{};

  AddUsersToSkillGroupResponse() {}

  explicit AddUsersToSkillGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddUsersToSkillGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddUsersToSkillGroupResponseBody>(model1);
      }
    }
  }


  virtual ~AddUsersToSkillGroupResponse() = default;
};
class AnswerCallRequest : public Darabonba::Model {
public:
  shared_ptr<string> deviceId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> jobId{};
  shared_ptr<string> userId{};

  AnswerCallRequest() {}

  explicit AnswerCallRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~AnswerCallRequest() = default;
};
class AnswerCallResponseBodyDataCallContextChannelContexts : public Darabonba::Model {
public:
  shared_ptr<string> callType{};
  shared_ptr<string> channelId{};
  shared_ptr<string> channelState{};
  shared_ptr<string> destination{};
  shared_ptr<string> jobId{};
  shared_ptr<string> originator{};
  shared_ptr<string> releaseInitiator{};
  shared_ptr<string> releaseReason{};
  shared_ptr<string> skillGroupId{};
  shared_ptr<long> timestamp{};
  shared_ptr<string> userExtension{};
  shared_ptr<string> userId{};

  AnswerCallResponseBodyDataCallContextChannelContexts() {}

  explicit AnswerCallResponseBodyDataCallContextChannelContexts(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callType) {
      res["CallType"] = boost::any(*callType);
    }
    if (channelId) {
      res["ChannelId"] = boost::any(*channelId);
    }
    if (channelState) {
      res["ChannelState"] = boost::any(*channelState);
    }
    if (destination) {
      res["Destination"] = boost::any(*destination);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (originator) {
      res["Originator"] = boost::any(*originator);
    }
    if (releaseInitiator) {
      res["ReleaseInitiator"] = boost::any(*releaseInitiator);
    }
    if (releaseReason) {
      res["ReleaseReason"] = boost::any(*releaseReason);
    }
    if (skillGroupId) {
      res["SkillGroupId"] = boost::any(*skillGroupId);
    }
    if (timestamp) {
      res["Timestamp"] = boost::any(*timestamp);
    }
    if (userExtension) {
      res["UserExtension"] = boost::any(*userExtension);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallType") != m.end() && !m["CallType"].empty()) {
      callType = make_shared<string>(boost::any_cast<string>(m["CallType"]));
    }
    if (m.find("ChannelId") != m.end() && !m["ChannelId"].empty()) {
      channelId = make_shared<string>(boost::any_cast<string>(m["ChannelId"]));
    }
    if (m.find("ChannelState") != m.end() && !m["ChannelState"].empty()) {
      channelState = make_shared<string>(boost::any_cast<string>(m["ChannelState"]));
    }
    if (m.find("Destination") != m.end() && !m["Destination"].empty()) {
      destination = make_shared<string>(boost::any_cast<string>(m["Destination"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("Originator") != m.end() && !m["Originator"].empty()) {
      originator = make_shared<string>(boost::any_cast<string>(m["Originator"]));
    }
    if (m.find("ReleaseInitiator") != m.end() && !m["ReleaseInitiator"].empty()) {
      releaseInitiator = make_shared<string>(boost::any_cast<string>(m["ReleaseInitiator"]));
    }
    if (m.find("ReleaseReason") != m.end() && !m["ReleaseReason"].empty()) {
      releaseReason = make_shared<string>(boost::any_cast<string>(m["ReleaseReason"]));
    }
    if (m.find("SkillGroupId") != m.end() && !m["SkillGroupId"].empty()) {
      skillGroupId = make_shared<string>(boost::any_cast<string>(m["SkillGroupId"]));
    }
    if (m.find("Timestamp") != m.end() && !m["Timestamp"].empty()) {
      timestamp = make_shared<long>(boost::any_cast<long>(m["Timestamp"]));
    }
    if (m.find("UserExtension") != m.end() && !m["UserExtension"].empty()) {
      userExtension = make_shared<string>(boost::any_cast<string>(m["UserExtension"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~AnswerCallResponseBodyDataCallContextChannelContexts() = default;
};
class AnswerCallResponseBodyDataCallContext : public Darabonba::Model {
public:
  shared_ptr<string> callType{};
  shared_ptr<vector<AnswerCallResponseBodyDataCallContextChannelContexts>> channelContexts{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> jobId{};

  AnswerCallResponseBodyDataCallContext() {}

  explicit AnswerCallResponseBodyDataCallContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callType) {
      res["CallType"] = boost::any(*callType);
    }
    if (channelContexts) {
      vector<boost::any> temp1;
      for(auto item1:*channelContexts){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ChannelContexts"] = boost::any(temp1);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallType") != m.end() && !m["CallType"].empty()) {
      callType = make_shared<string>(boost::any_cast<string>(m["CallType"]));
    }
    if (m.find("ChannelContexts") != m.end() && !m["ChannelContexts"].empty()) {
      if (typeid(vector<boost::any>) == m["ChannelContexts"].type()) {
        vector<AnswerCallResponseBodyDataCallContextChannelContexts> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ChannelContexts"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            AnswerCallResponseBodyDataCallContextChannelContexts model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        channelContexts = make_shared<vector<AnswerCallResponseBodyDataCallContextChannelContexts>>(expect1);
      }
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
  }


  virtual ~AnswerCallResponseBodyDataCallContext() = default;
};
class AnswerCallResponseBodyDataUserContext : public Darabonba::Model {
public:
  shared_ptr<string> breakCode{};
  shared_ptr<string> deviceId{};
  shared_ptr<string> extension{};
  shared_ptr<long> heartbeat{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> jobId{};
  shared_ptr<string> mobile{};
  shared_ptr<bool> outboundScenario{};
  shared_ptr<long> reserved{};
  shared_ptr<vector<string>> signedSkillGroupIdList{};
  shared_ptr<string> userId{};
  shared_ptr<string> userState{};
  shared_ptr<string> workMode{};

  AnswerCallResponseBodyDataUserContext() {}

  explicit AnswerCallResponseBodyDataUserContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (breakCode) {
      res["BreakCode"] = boost::any(*breakCode);
    }
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (extension) {
      res["Extension"] = boost::any(*extension);
    }
    if (heartbeat) {
      res["Heartbeat"] = boost::any(*heartbeat);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (mobile) {
      res["Mobile"] = boost::any(*mobile);
    }
    if (outboundScenario) {
      res["OutboundScenario"] = boost::any(*outboundScenario);
    }
    if (reserved) {
      res["Reserved"] = boost::any(*reserved);
    }
    if (signedSkillGroupIdList) {
      res["SignedSkillGroupIdList"] = boost::any(*signedSkillGroupIdList);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (userState) {
      res["UserState"] = boost::any(*userState);
    }
    if (workMode) {
      res["WorkMode"] = boost::any(*workMode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BreakCode") != m.end() && !m["BreakCode"].empty()) {
      breakCode = make_shared<string>(boost::any_cast<string>(m["BreakCode"]));
    }
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("Extension") != m.end() && !m["Extension"].empty()) {
      extension = make_shared<string>(boost::any_cast<string>(m["Extension"]));
    }
    if (m.find("Heartbeat") != m.end() && !m["Heartbeat"].empty()) {
      heartbeat = make_shared<long>(boost::any_cast<long>(m["Heartbeat"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("Mobile") != m.end() && !m["Mobile"].empty()) {
      mobile = make_shared<string>(boost::any_cast<string>(m["Mobile"]));
    }
    if (m.find("OutboundScenario") != m.end() && !m["OutboundScenario"].empty()) {
      outboundScenario = make_shared<bool>(boost::any_cast<bool>(m["OutboundScenario"]));
    }
    if (m.find("Reserved") != m.end() && !m["Reserved"].empty()) {
      reserved = make_shared<long>(boost::any_cast<long>(m["Reserved"]));
    }
    if (m.find("SignedSkillGroupIdList") != m.end() && !m["SignedSkillGroupIdList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SignedSkillGroupIdList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SignedSkillGroupIdList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      signedSkillGroupIdList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
    if (m.find("UserState") != m.end() && !m["UserState"].empty()) {
      userState = make_shared<string>(boost::any_cast<string>(m["UserState"]));
    }
    if (m.find("WorkMode") != m.end() && !m["WorkMode"].empty()) {
      workMode = make_shared<string>(boost::any_cast<string>(m["WorkMode"]));
    }
  }


  virtual ~AnswerCallResponseBodyDataUserContext() = default;
};
class AnswerCallResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<AnswerCallResponseBodyDataCallContext> callContext{};
  shared_ptr<long> contextId{};
  shared_ptr<AnswerCallResponseBodyDataUserContext> userContext{};

  AnswerCallResponseBodyData() {}

  explicit AnswerCallResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callContext) {
      res["CallContext"] = callContext ? boost::any(callContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (contextId) {
      res["ContextId"] = boost::any(*contextId);
    }
    if (userContext) {
      res["UserContext"] = userContext ? boost::any(userContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallContext") != m.end() && !m["CallContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["CallContext"].type()) {
        AnswerCallResponseBodyDataCallContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CallContext"]));
        callContext = make_shared<AnswerCallResponseBodyDataCallContext>(model1);
      }
    }
    if (m.find("ContextId") != m.end() && !m["ContextId"].empty()) {
      contextId = make_shared<long>(boost::any_cast<long>(m["ContextId"]));
    }
    if (m.find("UserContext") != m.end() && !m["UserContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["UserContext"].type()) {
        AnswerCallResponseBodyDataUserContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["UserContext"]));
        userContext = make_shared<AnswerCallResponseBodyDataUserContext>(model1);
      }
    }
  }


  virtual ~AnswerCallResponseBodyData() = default;
};
class AnswerCallResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<AnswerCallResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<vector<string>> params{};
  shared_ptr<string> requestId{};

  AnswerCallResponseBody() {}

  explicit AnswerCallResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (params) {
      res["Params"] = boost::any(*params);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        AnswerCallResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<AnswerCallResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Params") != m.end() && !m["Params"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Params"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Params"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      params = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AnswerCallResponseBody() = default;
};
class AnswerCallResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AnswerCallResponseBody> body{};

  AnswerCallResponse() {}

  explicit AnswerCallResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AnswerCallResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AnswerCallResponseBody>(model1);
      }
    }
  }


  virtual ~AnswerCallResponse() = default;
};
class AssignUsersRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> ramIdList{};
  shared_ptr<string> roleId{};
  shared_ptr<string> skillLevelList{};
  shared_ptr<string> workMode{};

  AssignUsersRequest() {}

  explicit AssignUsersRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (ramIdList) {
      res["RamIdList"] = boost::any(*ramIdList);
    }
    if (roleId) {
      res["RoleId"] = boost::any(*roleId);
    }
    if (skillLevelList) {
      res["SkillLevelList"] = boost::any(*skillLevelList);
    }
    if (workMode) {
      res["WorkMode"] = boost::any(*workMode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RamIdList") != m.end() && !m["RamIdList"].empty()) {
      ramIdList = make_shared<string>(boost::any_cast<string>(m["RamIdList"]));
    }
    if (m.find("RoleId") != m.end() && !m["RoleId"].empty()) {
      roleId = make_shared<string>(boost::any_cast<string>(m["RoleId"]));
    }
    if (m.find("SkillLevelList") != m.end() && !m["SkillLevelList"].empty()) {
      skillLevelList = make_shared<string>(boost::any_cast<string>(m["SkillLevelList"]));
    }
    if (m.find("WorkMode") != m.end() && !m["WorkMode"].empty()) {
      workMode = make_shared<string>(boost::any_cast<string>(m["WorkMode"]));
    }
  }


  virtual ~AssignUsersRequest() = default;
};
class AssignUsersResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<string> workflowId{};

  AssignUsersResponseBody() {}

  explicit AssignUsersResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (workflowId) {
      res["WorkflowId"] = boost::any(*workflowId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("WorkflowId") != m.end() && !m["WorkflowId"].empty()) {
      workflowId = make_shared<string>(boost::any_cast<string>(m["WorkflowId"]));
    }
  }


  virtual ~AssignUsersResponseBody() = default;
};
class AssignUsersResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AssignUsersResponseBody> body{};

  AssignUsersResponse() {}

  explicit AssignUsersResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AssignUsersResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AssignUsersResponseBody>(model1);
      }
    }
  }


  virtual ~AssignUsersResponse() = default;
};
class BargeInCallRequest : public Darabonba::Model {
public:
  shared_ptr<string> bargedUserId{};
  shared_ptr<string> deviceId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> jobId{};
  shared_ptr<long> timeoutSeconds{};
  shared_ptr<string> userId{};

  BargeInCallRequest() {}

  explicit BargeInCallRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bargedUserId) {
      res["BargedUserId"] = boost::any(*bargedUserId);
    }
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (timeoutSeconds) {
      res["TimeoutSeconds"] = boost::any(*timeoutSeconds);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BargedUserId") != m.end() && !m["BargedUserId"].empty()) {
      bargedUserId = make_shared<string>(boost::any_cast<string>(m["BargedUserId"]));
    }
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("TimeoutSeconds") != m.end() && !m["TimeoutSeconds"].empty()) {
      timeoutSeconds = make_shared<long>(boost::any_cast<long>(m["TimeoutSeconds"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~BargeInCallRequest() = default;
};
class BargeInCallResponseBodyDataCallContextChannelContexts : public Darabonba::Model {
public:
  shared_ptr<string> callType{};
  shared_ptr<string> channelFlags{};
  shared_ptr<string> channelId{};
  shared_ptr<string> channelState{};
  shared_ptr<string> destination{};
  shared_ptr<long> index{};
  shared_ptr<string> jobId{};
  shared_ptr<string> originator{};
  shared_ptr<string> releaseInitiator{};
  shared_ptr<string> releaseReason{};
  shared_ptr<string> skillGroupId{};
  shared_ptr<long> timestamp{};
  shared_ptr<string> userExtension{};
  shared_ptr<string> userId{};

  BargeInCallResponseBodyDataCallContextChannelContexts() {}

  explicit BargeInCallResponseBodyDataCallContextChannelContexts(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callType) {
      res["CallType"] = boost::any(*callType);
    }
    if (channelFlags) {
      res["ChannelFlags"] = boost::any(*channelFlags);
    }
    if (channelId) {
      res["ChannelId"] = boost::any(*channelId);
    }
    if (channelState) {
      res["ChannelState"] = boost::any(*channelState);
    }
    if (destination) {
      res["Destination"] = boost::any(*destination);
    }
    if (index) {
      res["Index"] = boost::any(*index);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (originator) {
      res["Originator"] = boost::any(*originator);
    }
    if (releaseInitiator) {
      res["ReleaseInitiator"] = boost::any(*releaseInitiator);
    }
    if (releaseReason) {
      res["ReleaseReason"] = boost::any(*releaseReason);
    }
    if (skillGroupId) {
      res["SkillGroupId"] = boost::any(*skillGroupId);
    }
    if (timestamp) {
      res["Timestamp"] = boost::any(*timestamp);
    }
    if (userExtension) {
      res["UserExtension"] = boost::any(*userExtension);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallType") != m.end() && !m["CallType"].empty()) {
      callType = make_shared<string>(boost::any_cast<string>(m["CallType"]));
    }
    if (m.find("ChannelFlags") != m.end() && !m["ChannelFlags"].empty()) {
      channelFlags = make_shared<string>(boost::any_cast<string>(m["ChannelFlags"]));
    }
    if (m.find("ChannelId") != m.end() && !m["ChannelId"].empty()) {
      channelId = make_shared<string>(boost::any_cast<string>(m["ChannelId"]));
    }
    if (m.find("ChannelState") != m.end() && !m["ChannelState"].empty()) {
      channelState = make_shared<string>(boost::any_cast<string>(m["ChannelState"]));
    }
    if (m.find("Destination") != m.end() && !m["Destination"].empty()) {
      destination = make_shared<string>(boost::any_cast<string>(m["Destination"]));
    }
    if (m.find("Index") != m.end() && !m["Index"].empty()) {
      index = make_shared<long>(boost::any_cast<long>(m["Index"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("Originator") != m.end() && !m["Originator"].empty()) {
      originator = make_shared<string>(boost::any_cast<string>(m["Originator"]));
    }
    if (m.find("ReleaseInitiator") != m.end() && !m["ReleaseInitiator"].empty()) {
      releaseInitiator = make_shared<string>(boost::any_cast<string>(m["ReleaseInitiator"]));
    }
    if (m.find("ReleaseReason") != m.end() && !m["ReleaseReason"].empty()) {
      releaseReason = make_shared<string>(boost::any_cast<string>(m["ReleaseReason"]));
    }
    if (m.find("SkillGroupId") != m.end() && !m["SkillGroupId"].empty()) {
      skillGroupId = make_shared<string>(boost::any_cast<string>(m["SkillGroupId"]));
    }
    if (m.find("Timestamp") != m.end() && !m["Timestamp"].empty()) {
      timestamp = make_shared<long>(boost::any_cast<long>(m["Timestamp"]));
    }
    if (m.find("UserExtension") != m.end() && !m["UserExtension"].empty()) {
      userExtension = make_shared<string>(boost::any_cast<string>(m["UserExtension"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~BargeInCallResponseBodyDataCallContextChannelContexts() = default;
};
class BargeInCallResponseBodyDataCallContext : public Darabonba::Model {
public:
  shared_ptr<string> callType{};
  shared_ptr<vector<BargeInCallResponseBodyDataCallContextChannelContexts>> channelContexts{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> jobId{};

  BargeInCallResponseBodyDataCallContext() {}

  explicit BargeInCallResponseBodyDataCallContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callType) {
      res["CallType"] = boost::any(*callType);
    }
    if (channelContexts) {
      vector<boost::any> temp1;
      for(auto item1:*channelContexts){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ChannelContexts"] = boost::any(temp1);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallType") != m.end() && !m["CallType"].empty()) {
      callType = make_shared<string>(boost::any_cast<string>(m["CallType"]));
    }
    if (m.find("ChannelContexts") != m.end() && !m["ChannelContexts"].empty()) {
      if (typeid(vector<boost::any>) == m["ChannelContexts"].type()) {
        vector<BargeInCallResponseBodyDataCallContextChannelContexts> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ChannelContexts"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            BargeInCallResponseBodyDataCallContextChannelContexts model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        channelContexts = make_shared<vector<BargeInCallResponseBodyDataCallContextChannelContexts>>(expect1);
      }
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
  }


  virtual ~BargeInCallResponseBodyDataCallContext() = default;
};
class BargeInCallResponseBodyDataUserContext : public Darabonba::Model {
public:
  shared_ptr<string> breakCode{};
  shared_ptr<string> deviceId{};
  shared_ptr<string> extension{};
  shared_ptr<long> heartbeat{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> jobId{};
  shared_ptr<string> mobile{};
  shared_ptr<bool> outboundScenario{};
  shared_ptr<long> reserved{};
  shared_ptr<vector<string>> signedSkillGroupIdList{};
  shared_ptr<string> userId{};
  shared_ptr<string> userState{};
  shared_ptr<string> workMode{};

  BargeInCallResponseBodyDataUserContext() {}

  explicit BargeInCallResponseBodyDataUserContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (breakCode) {
      res["BreakCode"] = boost::any(*breakCode);
    }
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (extension) {
      res["Extension"] = boost::any(*extension);
    }
    if (heartbeat) {
      res["Heartbeat"] = boost::any(*heartbeat);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (mobile) {
      res["Mobile"] = boost::any(*mobile);
    }
    if (outboundScenario) {
      res["OutboundScenario"] = boost::any(*outboundScenario);
    }
    if (reserved) {
      res["Reserved"] = boost::any(*reserved);
    }
    if (signedSkillGroupIdList) {
      res["SignedSkillGroupIdList"] = boost::any(*signedSkillGroupIdList);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (userState) {
      res["UserState"] = boost::any(*userState);
    }
    if (workMode) {
      res["WorkMode"] = boost::any(*workMode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BreakCode") != m.end() && !m["BreakCode"].empty()) {
      breakCode = make_shared<string>(boost::any_cast<string>(m["BreakCode"]));
    }
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("Extension") != m.end() && !m["Extension"].empty()) {
      extension = make_shared<string>(boost::any_cast<string>(m["Extension"]));
    }
    if (m.find("Heartbeat") != m.end() && !m["Heartbeat"].empty()) {
      heartbeat = make_shared<long>(boost::any_cast<long>(m["Heartbeat"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("Mobile") != m.end() && !m["Mobile"].empty()) {
      mobile = make_shared<string>(boost::any_cast<string>(m["Mobile"]));
    }
    if (m.find("OutboundScenario") != m.end() && !m["OutboundScenario"].empty()) {
      outboundScenario = make_shared<bool>(boost::any_cast<bool>(m["OutboundScenario"]));
    }
    if (m.find("Reserved") != m.end() && !m["Reserved"].empty()) {
      reserved = make_shared<long>(boost::any_cast<long>(m["Reserved"]));
    }
    if (m.find("SignedSkillGroupIdList") != m.end() && !m["SignedSkillGroupIdList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SignedSkillGroupIdList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SignedSkillGroupIdList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      signedSkillGroupIdList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
    if (m.find("UserState") != m.end() && !m["UserState"].empty()) {
      userState = make_shared<string>(boost::any_cast<string>(m["UserState"]));
    }
    if (m.find("WorkMode") != m.end() && !m["WorkMode"].empty()) {
      workMode = make_shared<string>(boost::any_cast<string>(m["WorkMode"]));
    }
  }


  virtual ~BargeInCallResponseBodyDataUserContext() = default;
};
class BargeInCallResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<BargeInCallResponseBodyDataCallContext> callContext{};
  shared_ptr<BargeInCallResponseBodyDataUserContext> userContext{};

  BargeInCallResponseBodyData() {}

  explicit BargeInCallResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callContext) {
      res["CallContext"] = callContext ? boost::any(callContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (userContext) {
      res["UserContext"] = userContext ? boost::any(userContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallContext") != m.end() && !m["CallContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["CallContext"].type()) {
        BargeInCallResponseBodyDataCallContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CallContext"]));
        callContext = make_shared<BargeInCallResponseBodyDataCallContext>(model1);
      }
    }
    if (m.find("UserContext") != m.end() && !m["UserContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["UserContext"].type()) {
        BargeInCallResponseBodyDataUserContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["UserContext"]));
        userContext = make_shared<BargeInCallResponseBodyDataUserContext>(model1);
      }
    }
  }


  virtual ~BargeInCallResponseBodyData() = default;
};
class BargeInCallResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<BargeInCallResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<vector<string>> params{};
  shared_ptr<string> requestId{};

  BargeInCallResponseBody() {}

  explicit BargeInCallResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (params) {
      res["Params"] = boost::any(*params);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        BargeInCallResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<BargeInCallResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Params") != m.end() && !m["Params"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Params"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Params"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      params = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~BargeInCallResponseBody() = default;
};
class BargeInCallResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<BargeInCallResponseBody> body{};

  BargeInCallResponse() {}

  explicit BargeInCallResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        BargeInCallResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<BargeInCallResponseBody>(model1);
      }
    }
  }


  virtual ~BargeInCallResponse() = default;
};
class BlindTransferRequest : public Darabonba::Model {
public:
  shared_ptr<string> deviceId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> jobId{};
  shared_ptr<long> timeoutSeconds{};
  shared_ptr<string> transferee{};
  shared_ptr<string> transferor{};
  shared_ptr<string> userId{};

  BlindTransferRequest() {}

  explicit BlindTransferRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (timeoutSeconds) {
      res["TimeoutSeconds"] = boost::any(*timeoutSeconds);
    }
    if (transferee) {
      res["Transferee"] = boost::any(*transferee);
    }
    if (transferor) {
      res["Transferor"] = boost::any(*transferor);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("TimeoutSeconds") != m.end() && !m["TimeoutSeconds"].empty()) {
      timeoutSeconds = make_shared<long>(boost::any_cast<long>(m["TimeoutSeconds"]));
    }
    if (m.find("Transferee") != m.end() && !m["Transferee"].empty()) {
      transferee = make_shared<string>(boost::any_cast<string>(m["Transferee"]));
    }
    if (m.find("Transferor") != m.end() && !m["Transferor"].empty()) {
      transferor = make_shared<string>(boost::any_cast<string>(m["Transferor"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~BlindTransferRequest() = default;
};
class BlindTransferResponseBodyDataCallContextChannelContexts : public Darabonba::Model {
public:
  shared_ptr<string> callType{};
  shared_ptr<string> channelFlags{};
  shared_ptr<string> channelId{};
  shared_ptr<string> channelState{};
  shared_ptr<string> destination{};
  shared_ptr<string> jobId{};
  shared_ptr<string> originator{};
  shared_ptr<string> releaseInitiator{};
  shared_ptr<string> releaseReason{};
  shared_ptr<long> timestamp{};
  shared_ptr<string> userExtension{};
  shared_ptr<string> userId{};

  BlindTransferResponseBodyDataCallContextChannelContexts() {}

  explicit BlindTransferResponseBodyDataCallContextChannelContexts(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callType) {
      res["CallType"] = boost::any(*callType);
    }
    if (channelFlags) {
      res["ChannelFlags"] = boost::any(*channelFlags);
    }
    if (channelId) {
      res["ChannelId"] = boost::any(*channelId);
    }
    if (channelState) {
      res["ChannelState"] = boost::any(*channelState);
    }
    if (destination) {
      res["Destination"] = boost::any(*destination);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (originator) {
      res["Originator"] = boost::any(*originator);
    }
    if (releaseInitiator) {
      res["ReleaseInitiator"] = boost::any(*releaseInitiator);
    }
    if (releaseReason) {
      res["ReleaseReason"] = boost::any(*releaseReason);
    }
    if (timestamp) {
      res["Timestamp"] = boost::any(*timestamp);
    }
    if (userExtension) {
      res["UserExtension"] = boost::any(*userExtension);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallType") != m.end() && !m["CallType"].empty()) {
      callType = make_shared<string>(boost::any_cast<string>(m["CallType"]));
    }
    if (m.find("ChannelFlags") != m.end() && !m["ChannelFlags"].empty()) {
      channelFlags = make_shared<string>(boost::any_cast<string>(m["ChannelFlags"]));
    }
    if (m.find("ChannelId") != m.end() && !m["ChannelId"].empty()) {
      channelId = make_shared<string>(boost::any_cast<string>(m["ChannelId"]));
    }
    if (m.find("ChannelState") != m.end() && !m["ChannelState"].empty()) {
      channelState = make_shared<string>(boost::any_cast<string>(m["ChannelState"]));
    }
    if (m.find("Destination") != m.end() && !m["Destination"].empty()) {
      destination = make_shared<string>(boost::any_cast<string>(m["Destination"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("Originator") != m.end() && !m["Originator"].empty()) {
      originator = make_shared<string>(boost::any_cast<string>(m["Originator"]));
    }
    if (m.find("ReleaseInitiator") != m.end() && !m["ReleaseInitiator"].empty()) {
      releaseInitiator = make_shared<string>(boost::any_cast<string>(m["ReleaseInitiator"]));
    }
    if (m.find("ReleaseReason") != m.end() && !m["ReleaseReason"].empty()) {
      releaseReason = make_shared<string>(boost::any_cast<string>(m["ReleaseReason"]));
    }
    if (m.find("Timestamp") != m.end() && !m["Timestamp"].empty()) {
      timestamp = make_shared<long>(boost::any_cast<long>(m["Timestamp"]));
    }
    if (m.find("UserExtension") != m.end() && !m["UserExtension"].empty()) {
      userExtension = make_shared<string>(boost::any_cast<string>(m["UserExtension"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~BlindTransferResponseBodyDataCallContextChannelContexts() = default;
};
class BlindTransferResponseBodyDataCallContext : public Darabonba::Model {
public:
  shared_ptr<string> callType{};
  shared_ptr<vector<BlindTransferResponseBodyDataCallContextChannelContexts>> channelContexts{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> jobId{};

  BlindTransferResponseBodyDataCallContext() {}

  explicit BlindTransferResponseBodyDataCallContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callType) {
      res["CallType"] = boost::any(*callType);
    }
    if (channelContexts) {
      vector<boost::any> temp1;
      for(auto item1:*channelContexts){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ChannelContexts"] = boost::any(temp1);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallType") != m.end() && !m["CallType"].empty()) {
      callType = make_shared<string>(boost::any_cast<string>(m["CallType"]));
    }
    if (m.find("ChannelContexts") != m.end() && !m["ChannelContexts"].empty()) {
      if (typeid(vector<boost::any>) == m["ChannelContexts"].type()) {
        vector<BlindTransferResponseBodyDataCallContextChannelContexts> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ChannelContexts"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            BlindTransferResponseBodyDataCallContextChannelContexts model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        channelContexts = make_shared<vector<BlindTransferResponseBodyDataCallContextChannelContexts>>(expect1);
      }
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
  }


  virtual ~BlindTransferResponseBodyDataCallContext() = default;
};
class BlindTransferResponseBodyDataUserContext : public Darabonba::Model {
public:
  shared_ptr<string> breakCode{};
  shared_ptr<string> deviceId{};
  shared_ptr<string> extension{};
  shared_ptr<long> heartbeat{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> jobId{};
  shared_ptr<string> mobile{};
  shared_ptr<bool> outboundScenario{};
  shared_ptr<long> reserved{};
  shared_ptr<vector<string>> signedSkillGroupIdList{};
  shared_ptr<string> userId{};
  shared_ptr<string> userState{};
  shared_ptr<string> workMode{};

  BlindTransferResponseBodyDataUserContext() {}

  explicit BlindTransferResponseBodyDataUserContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (breakCode) {
      res["BreakCode"] = boost::any(*breakCode);
    }
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (extension) {
      res["Extension"] = boost::any(*extension);
    }
    if (heartbeat) {
      res["Heartbeat"] = boost::any(*heartbeat);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (mobile) {
      res["Mobile"] = boost::any(*mobile);
    }
    if (outboundScenario) {
      res["OutboundScenario"] = boost::any(*outboundScenario);
    }
    if (reserved) {
      res["Reserved"] = boost::any(*reserved);
    }
    if (signedSkillGroupIdList) {
      res["SignedSkillGroupIdList"] = boost::any(*signedSkillGroupIdList);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (userState) {
      res["UserState"] = boost::any(*userState);
    }
    if (workMode) {
      res["WorkMode"] = boost::any(*workMode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BreakCode") != m.end() && !m["BreakCode"].empty()) {
      breakCode = make_shared<string>(boost::any_cast<string>(m["BreakCode"]));
    }
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("Extension") != m.end() && !m["Extension"].empty()) {
      extension = make_shared<string>(boost::any_cast<string>(m["Extension"]));
    }
    if (m.find("Heartbeat") != m.end() && !m["Heartbeat"].empty()) {
      heartbeat = make_shared<long>(boost::any_cast<long>(m["Heartbeat"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("Mobile") != m.end() && !m["Mobile"].empty()) {
      mobile = make_shared<string>(boost::any_cast<string>(m["Mobile"]));
    }
    if (m.find("OutboundScenario") != m.end() && !m["OutboundScenario"].empty()) {
      outboundScenario = make_shared<bool>(boost::any_cast<bool>(m["OutboundScenario"]));
    }
    if (m.find("Reserved") != m.end() && !m["Reserved"].empty()) {
      reserved = make_shared<long>(boost::any_cast<long>(m["Reserved"]));
    }
    if (m.find("SignedSkillGroupIdList") != m.end() && !m["SignedSkillGroupIdList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SignedSkillGroupIdList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SignedSkillGroupIdList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      signedSkillGroupIdList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
    if (m.find("UserState") != m.end() && !m["UserState"].empty()) {
      userState = make_shared<string>(boost::any_cast<string>(m["UserState"]));
    }
    if (m.find("WorkMode") != m.end() && !m["WorkMode"].empty()) {
      workMode = make_shared<string>(boost::any_cast<string>(m["WorkMode"]));
    }
  }


  virtual ~BlindTransferResponseBodyDataUserContext() = default;
};
class BlindTransferResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<BlindTransferResponseBodyDataCallContext> callContext{};
  shared_ptr<long> contextId{};
  shared_ptr<BlindTransferResponseBodyDataUserContext> userContext{};

  BlindTransferResponseBodyData() {}

  explicit BlindTransferResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callContext) {
      res["CallContext"] = callContext ? boost::any(callContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (contextId) {
      res["ContextId"] = boost::any(*contextId);
    }
    if (userContext) {
      res["UserContext"] = userContext ? boost::any(userContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallContext") != m.end() && !m["CallContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["CallContext"].type()) {
        BlindTransferResponseBodyDataCallContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CallContext"]));
        callContext = make_shared<BlindTransferResponseBodyDataCallContext>(model1);
      }
    }
    if (m.find("ContextId") != m.end() && !m["ContextId"].empty()) {
      contextId = make_shared<long>(boost::any_cast<long>(m["ContextId"]));
    }
    if (m.find("UserContext") != m.end() && !m["UserContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["UserContext"].type()) {
        BlindTransferResponseBodyDataUserContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["UserContext"]));
        userContext = make_shared<BlindTransferResponseBodyDataUserContext>(model1);
      }
    }
  }


  virtual ~BlindTransferResponseBodyData() = default;
};
class BlindTransferResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<BlindTransferResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<vector<string>> params{};
  shared_ptr<string> requestId{};

  BlindTransferResponseBody() {}

  explicit BlindTransferResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (params) {
      res["Params"] = boost::any(*params);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        BlindTransferResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<BlindTransferResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Params") != m.end() && !m["Params"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Params"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Params"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      params = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~BlindTransferResponseBody() = default;
};
class BlindTransferResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<BlindTransferResponseBody> body{};

  BlindTransferResponse() {}

  explicit BlindTransferResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        BlindTransferResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<BlindTransferResponseBody>(model1);
      }
    }
  }


  virtual ~BlindTransferResponse() = default;
};
class CancelAttendedTransferRequest : public Darabonba::Model {
public:
  shared_ptr<string> deviceId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> jobId{};
  shared_ptr<string> userId{};

  CancelAttendedTransferRequest() {}

  explicit CancelAttendedTransferRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~CancelAttendedTransferRequest() = default;
};
class CancelAttendedTransferResponseBodyDataCallContextChannelContexts : public Darabonba::Model {
public:
  shared_ptr<string> callType{};
  shared_ptr<string> channelFlags{};
  shared_ptr<string> channelId{};
  shared_ptr<string> channelState{};
  shared_ptr<string> destination{};
  shared_ptr<long> index{};
  shared_ptr<string> jobId{};
  shared_ptr<string> originator{};
  shared_ptr<string> releaseInitiator{};
  shared_ptr<string> releaseReason{};
  shared_ptr<long> timestamp{};
  shared_ptr<string> userExtension{};
  shared_ptr<string> userId{};

  CancelAttendedTransferResponseBodyDataCallContextChannelContexts() {}

  explicit CancelAttendedTransferResponseBodyDataCallContextChannelContexts(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callType) {
      res["CallType"] = boost::any(*callType);
    }
    if (channelFlags) {
      res["ChannelFlags"] = boost::any(*channelFlags);
    }
    if (channelId) {
      res["ChannelId"] = boost::any(*channelId);
    }
    if (channelState) {
      res["ChannelState"] = boost::any(*channelState);
    }
    if (destination) {
      res["Destination"] = boost::any(*destination);
    }
    if (index) {
      res["Index"] = boost::any(*index);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (originator) {
      res["Originator"] = boost::any(*originator);
    }
    if (releaseInitiator) {
      res["ReleaseInitiator"] = boost::any(*releaseInitiator);
    }
    if (releaseReason) {
      res["ReleaseReason"] = boost::any(*releaseReason);
    }
    if (timestamp) {
      res["Timestamp"] = boost::any(*timestamp);
    }
    if (userExtension) {
      res["UserExtension"] = boost::any(*userExtension);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallType") != m.end() && !m["CallType"].empty()) {
      callType = make_shared<string>(boost::any_cast<string>(m["CallType"]));
    }
    if (m.find("ChannelFlags") != m.end() && !m["ChannelFlags"].empty()) {
      channelFlags = make_shared<string>(boost::any_cast<string>(m["ChannelFlags"]));
    }
    if (m.find("ChannelId") != m.end() && !m["ChannelId"].empty()) {
      channelId = make_shared<string>(boost::any_cast<string>(m["ChannelId"]));
    }
    if (m.find("ChannelState") != m.end() && !m["ChannelState"].empty()) {
      channelState = make_shared<string>(boost::any_cast<string>(m["ChannelState"]));
    }
    if (m.find("Destination") != m.end() && !m["Destination"].empty()) {
      destination = make_shared<string>(boost::any_cast<string>(m["Destination"]));
    }
    if (m.find("Index") != m.end() && !m["Index"].empty()) {
      index = make_shared<long>(boost::any_cast<long>(m["Index"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("Originator") != m.end() && !m["Originator"].empty()) {
      originator = make_shared<string>(boost::any_cast<string>(m["Originator"]));
    }
    if (m.find("ReleaseInitiator") != m.end() && !m["ReleaseInitiator"].empty()) {
      releaseInitiator = make_shared<string>(boost::any_cast<string>(m["ReleaseInitiator"]));
    }
    if (m.find("ReleaseReason") != m.end() && !m["ReleaseReason"].empty()) {
      releaseReason = make_shared<string>(boost::any_cast<string>(m["ReleaseReason"]));
    }
    if (m.find("Timestamp") != m.end() && !m["Timestamp"].empty()) {
      timestamp = make_shared<long>(boost::any_cast<long>(m["Timestamp"]));
    }
    if (m.find("UserExtension") != m.end() && !m["UserExtension"].empty()) {
      userExtension = make_shared<string>(boost::any_cast<string>(m["UserExtension"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~CancelAttendedTransferResponseBodyDataCallContextChannelContexts() = default;
};
class CancelAttendedTransferResponseBodyDataCallContext : public Darabonba::Model {
public:
  shared_ptr<string> callType{};
  shared_ptr<vector<CancelAttendedTransferResponseBodyDataCallContextChannelContexts>> channelContexts{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> jobId{};

  CancelAttendedTransferResponseBodyDataCallContext() {}

  explicit CancelAttendedTransferResponseBodyDataCallContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callType) {
      res["CallType"] = boost::any(*callType);
    }
    if (channelContexts) {
      vector<boost::any> temp1;
      for(auto item1:*channelContexts){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ChannelContexts"] = boost::any(temp1);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallType") != m.end() && !m["CallType"].empty()) {
      callType = make_shared<string>(boost::any_cast<string>(m["CallType"]));
    }
    if (m.find("ChannelContexts") != m.end() && !m["ChannelContexts"].empty()) {
      if (typeid(vector<boost::any>) == m["ChannelContexts"].type()) {
        vector<CancelAttendedTransferResponseBodyDataCallContextChannelContexts> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ChannelContexts"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CancelAttendedTransferResponseBodyDataCallContextChannelContexts model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        channelContexts = make_shared<vector<CancelAttendedTransferResponseBodyDataCallContextChannelContexts>>(expect1);
      }
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
  }


  virtual ~CancelAttendedTransferResponseBodyDataCallContext() = default;
};
class CancelAttendedTransferResponseBodyDataUserContext : public Darabonba::Model {
public:
  shared_ptr<string> breakCode{};
  shared_ptr<string> deviceId{};
  shared_ptr<string> extension{};
  shared_ptr<long> heartbeat{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> jobId{};
  shared_ptr<string> mobile{};
  shared_ptr<bool> outboundScenario{};
  shared_ptr<long> reserved{};
  shared_ptr<vector<string>> signedSkillGroupIdList{};
  shared_ptr<string> userId{};
  shared_ptr<string> userState{};
  shared_ptr<string> workMode{};

  CancelAttendedTransferResponseBodyDataUserContext() {}

  explicit CancelAttendedTransferResponseBodyDataUserContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (breakCode) {
      res["BreakCode"] = boost::any(*breakCode);
    }
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (extension) {
      res["Extension"] = boost::any(*extension);
    }
    if (heartbeat) {
      res["Heartbeat"] = boost::any(*heartbeat);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (mobile) {
      res["Mobile"] = boost::any(*mobile);
    }
    if (outboundScenario) {
      res["OutboundScenario"] = boost::any(*outboundScenario);
    }
    if (reserved) {
      res["Reserved"] = boost::any(*reserved);
    }
    if (signedSkillGroupIdList) {
      res["SignedSkillGroupIdList"] = boost::any(*signedSkillGroupIdList);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (userState) {
      res["UserState"] = boost::any(*userState);
    }
    if (workMode) {
      res["WorkMode"] = boost::any(*workMode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BreakCode") != m.end() && !m["BreakCode"].empty()) {
      breakCode = make_shared<string>(boost::any_cast<string>(m["BreakCode"]));
    }
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("Extension") != m.end() && !m["Extension"].empty()) {
      extension = make_shared<string>(boost::any_cast<string>(m["Extension"]));
    }
    if (m.find("Heartbeat") != m.end() && !m["Heartbeat"].empty()) {
      heartbeat = make_shared<long>(boost::any_cast<long>(m["Heartbeat"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("Mobile") != m.end() && !m["Mobile"].empty()) {
      mobile = make_shared<string>(boost::any_cast<string>(m["Mobile"]));
    }
    if (m.find("OutboundScenario") != m.end() && !m["OutboundScenario"].empty()) {
      outboundScenario = make_shared<bool>(boost::any_cast<bool>(m["OutboundScenario"]));
    }
    if (m.find("Reserved") != m.end() && !m["Reserved"].empty()) {
      reserved = make_shared<long>(boost::any_cast<long>(m["Reserved"]));
    }
    if (m.find("SignedSkillGroupIdList") != m.end() && !m["SignedSkillGroupIdList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SignedSkillGroupIdList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SignedSkillGroupIdList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      signedSkillGroupIdList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
    if (m.find("UserState") != m.end() && !m["UserState"].empty()) {
      userState = make_shared<string>(boost::any_cast<string>(m["UserState"]));
    }
    if (m.find("WorkMode") != m.end() && !m["WorkMode"].empty()) {
      workMode = make_shared<string>(boost::any_cast<string>(m["WorkMode"]));
    }
  }


  virtual ~CancelAttendedTransferResponseBodyDataUserContext() = default;
};
class CancelAttendedTransferResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<CancelAttendedTransferResponseBodyDataCallContext> callContext{};
  shared_ptr<long> contextId{};
  shared_ptr<CancelAttendedTransferResponseBodyDataUserContext> userContext{};

  CancelAttendedTransferResponseBodyData() {}

  explicit CancelAttendedTransferResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callContext) {
      res["CallContext"] = callContext ? boost::any(callContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (contextId) {
      res["ContextId"] = boost::any(*contextId);
    }
    if (userContext) {
      res["UserContext"] = userContext ? boost::any(userContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallContext") != m.end() && !m["CallContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["CallContext"].type()) {
        CancelAttendedTransferResponseBodyDataCallContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CallContext"]));
        callContext = make_shared<CancelAttendedTransferResponseBodyDataCallContext>(model1);
      }
    }
    if (m.find("ContextId") != m.end() && !m["ContextId"].empty()) {
      contextId = make_shared<long>(boost::any_cast<long>(m["ContextId"]));
    }
    if (m.find("UserContext") != m.end() && !m["UserContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["UserContext"].type()) {
        CancelAttendedTransferResponseBodyDataUserContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["UserContext"]));
        userContext = make_shared<CancelAttendedTransferResponseBodyDataUserContext>(model1);
      }
    }
  }


  virtual ~CancelAttendedTransferResponseBodyData() = default;
};
class CancelAttendedTransferResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<CancelAttendedTransferResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<vector<string>> params{};
  shared_ptr<string> requestId{};

  CancelAttendedTransferResponseBody() {}

  explicit CancelAttendedTransferResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (params) {
      res["Params"] = boost::any(*params);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        CancelAttendedTransferResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<CancelAttendedTransferResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Params") != m.end() && !m["Params"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Params"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Params"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      params = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CancelAttendedTransferResponseBody() = default;
};
class CancelAttendedTransferResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CancelAttendedTransferResponseBody> body{};

  CancelAttendedTransferResponse() {}

  explicit CancelAttendedTransferResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CancelAttendedTransferResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CancelAttendedTransferResponseBody>(model1);
      }
    }
  }


  virtual ~CancelAttendedTransferResponse() = default;
};
class ChangeWorkModeRequest : public Darabonba::Model {
public:
  shared_ptr<string> deviceId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> mobile{};
  shared_ptr<string> signedSkillGroupIdList{};
  shared_ptr<string> userId{};
  shared_ptr<string> workMode{};

  ChangeWorkModeRequest() {}

  explicit ChangeWorkModeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (mobile) {
      res["Mobile"] = boost::any(*mobile);
    }
    if (signedSkillGroupIdList) {
      res["SignedSkillGroupIdList"] = boost::any(*signedSkillGroupIdList);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (workMode) {
      res["WorkMode"] = boost::any(*workMode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Mobile") != m.end() && !m["Mobile"].empty()) {
      mobile = make_shared<string>(boost::any_cast<string>(m["Mobile"]));
    }
    if (m.find("SignedSkillGroupIdList") != m.end() && !m["SignedSkillGroupIdList"].empty()) {
      signedSkillGroupIdList = make_shared<string>(boost::any_cast<string>(m["SignedSkillGroupIdList"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
    if (m.find("WorkMode") != m.end() && !m["WorkMode"].empty()) {
      workMode = make_shared<string>(boost::any_cast<string>(m["WorkMode"]));
    }
  }


  virtual ~ChangeWorkModeRequest() = default;
};
class ChangeWorkModeResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> breakCode{};
  shared_ptr<string> deviceId{};
  shared_ptr<string> extension{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> jobId{};
  shared_ptr<bool> outboundScenario{};
  shared_ptr<vector<string>> signedSkillGroupIdList{};
  shared_ptr<string> userId{};
  shared_ptr<string> userState{};
  shared_ptr<string> workMode{};

  ChangeWorkModeResponseBodyData() {}

  explicit ChangeWorkModeResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (breakCode) {
      res["BreakCode"] = boost::any(*breakCode);
    }
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (extension) {
      res["Extension"] = boost::any(*extension);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (outboundScenario) {
      res["OutboundScenario"] = boost::any(*outboundScenario);
    }
    if (signedSkillGroupIdList) {
      res["SignedSkillGroupIdList"] = boost::any(*signedSkillGroupIdList);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (userState) {
      res["UserState"] = boost::any(*userState);
    }
    if (workMode) {
      res["WorkMode"] = boost::any(*workMode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BreakCode") != m.end() && !m["BreakCode"].empty()) {
      breakCode = make_shared<string>(boost::any_cast<string>(m["BreakCode"]));
    }
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("Extension") != m.end() && !m["Extension"].empty()) {
      extension = make_shared<string>(boost::any_cast<string>(m["Extension"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("OutboundScenario") != m.end() && !m["OutboundScenario"].empty()) {
      outboundScenario = make_shared<bool>(boost::any_cast<bool>(m["OutboundScenario"]));
    }
    if (m.find("SignedSkillGroupIdList") != m.end() && !m["SignedSkillGroupIdList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SignedSkillGroupIdList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SignedSkillGroupIdList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      signedSkillGroupIdList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
    if (m.find("UserState") != m.end() && !m["UserState"].empty()) {
      userState = make_shared<string>(boost::any_cast<string>(m["UserState"]));
    }
    if (m.find("WorkMode") != m.end() && !m["WorkMode"].empty()) {
      workMode = make_shared<string>(boost::any_cast<string>(m["WorkMode"]));
    }
  }


  virtual ~ChangeWorkModeResponseBodyData() = default;
};
class ChangeWorkModeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<ChangeWorkModeResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<vector<string>> params{};
  shared_ptr<string> requestId{};

  ChangeWorkModeResponseBody() {}

  explicit ChangeWorkModeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (params) {
      res["Params"] = boost::any(*params);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ChangeWorkModeResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ChangeWorkModeResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Params") != m.end() && !m["Params"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Params"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Params"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      params = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ChangeWorkModeResponseBody() = default;
};
class ChangeWorkModeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ChangeWorkModeResponseBody> body{};

  ChangeWorkModeResponse() {}

  explicit ChangeWorkModeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ChangeWorkModeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ChangeWorkModeResponseBody>(model1);
      }
    }
  }


  virtual ~ChangeWorkModeResponse() = default;
};
class CoachCallRequest : public Darabonba::Model {
public:
  shared_ptr<string> coachedUserId{};
  shared_ptr<string> deviceId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> jobId{};
  shared_ptr<long> timeoutSeconds{};
  shared_ptr<string> userId{};

  CoachCallRequest() {}

  explicit CoachCallRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (coachedUserId) {
      res["CoachedUserId"] = boost::any(*coachedUserId);
    }
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (timeoutSeconds) {
      res["TimeoutSeconds"] = boost::any(*timeoutSeconds);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CoachedUserId") != m.end() && !m["CoachedUserId"].empty()) {
      coachedUserId = make_shared<string>(boost::any_cast<string>(m["CoachedUserId"]));
    }
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("TimeoutSeconds") != m.end() && !m["TimeoutSeconds"].empty()) {
      timeoutSeconds = make_shared<long>(boost::any_cast<long>(m["TimeoutSeconds"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~CoachCallRequest() = default;
};
class CoachCallResponseBodyDataCallContextChannelContexts : public Darabonba::Model {
public:
  shared_ptr<string> callType{};
  shared_ptr<string> channelFlags{};
  shared_ptr<string> channelId{};
  shared_ptr<string> channelState{};
  shared_ptr<string> destination{};
  shared_ptr<long> index{};
  shared_ptr<string> jobId{};
  shared_ptr<string> originator{};
  shared_ptr<string> releaseInitiator{};
  shared_ptr<string> releaseReason{};
  shared_ptr<string> skillGroupId{};
  shared_ptr<long> timestamp{};
  shared_ptr<string> userExtension{};
  shared_ptr<string> userId{};

  CoachCallResponseBodyDataCallContextChannelContexts() {}

  explicit CoachCallResponseBodyDataCallContextChannelContexts(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callType) {
      res["CallType"] = boost::any(*callType);
    }
    if (channelFlags) {
      res["ChannelFlags"] = boost::any(*channelFlags);
    }
    if (channelId) {
      res["ChannelId"] = boost::any(*channelId);
    }
    if (channelState) {
      res["ChannelState"] = boost::any(*channelState);
    }
    if (destination) {
      res["Destination"] = boost::any(*destination);
    }
    if (index) {
      res["Index"] = boost::any(*index);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (originator) {
      res["Originator"] = boost::any(*originator);
    }
    if (releaseInitiator) {
      res["ReleaseInitiator"] = boost::any(*releaseInitiator);
    }
    if (releaseReason) {
      res["ReleaseReason"] = boost::any(*releaseReason);
    }
    if (skillGroupId) {
      res["SkillGroupId"] = boost::any(*skillGroupId);
    }
    if (timestamp) {
      res["Timestamp"] = boost::any(*timestamp);
    }
    if (userExtension) {
      res["UserExtension"] = boost::any(*userExtension);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallType") != m.end() && !m["CallType"].empty()) {
      callType = make_shared<string>(boost::any_cast<string>(m["CallType"]));
    }
    if (m.find("ChannelFlags") != m.end() && !m["ChannelFlags"].empty()) {
      channelFlags = make_shared<string>(boost::any_cast<string>(m["ChannelFlags"]));
    }
    if (m.find("ChannelId") != m.end() && !m["ChannelId"].empty()) {
      channelId = make_shared<string>(boost::any_cast<string>(m["ChannelId"]));
    }
    if (m.find("ChannelState") != m.end() && !m["ChannelState"].empty()) {
      channelState = make_shared<string>(boost::any_cast<string>(m["ChannelState"]));
    }
    if (m.find("Destination") != m.end() && !m["Destination"].empty()) {
      destination = make_shared<string>(boost::any_cast<string>(m["Destination"]));
    }
    if (m.find("Index") != m.end() && !m["Index"].empty()) {
      index = make_shared<long>(boost::any_cast<long>(m["Index"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("Originator") != m.end() && !m["Originator"].empty()) {
      originator = make_shared<string>(boost::any_cast<string>(m["Originator"]));
    }
    if (m.find("ReleaseInitiator") != m.end() && !m["ReleaseInitiator"].empty()) {
      releaseInitiator = make_shared<string>(boost::any_cast<string>(m["ReleaseInitiator"]));
    }
    if (m.find("ReleaseReason") != m.end() && !m["ReleaseReason"].empty()) {
      releaseReason = make_shared<string>(boost::any_cast<string>(m["ReleaseReason"]));
    }
    if (m.find("SkillGroupId") != m.end() && !m["SkillGroupId"].empty()) {
      skillGroupId = make_shared<string>(boost::any_cast<string>(m["SkillGroupId"]));
    }
    if (m.find("Timestamp") != m.end() && !m["Timestamp"].empty()) {
      timestamp = make_shared<long>(boost::any_cast<long>(m["Timestamp"]));
    }
    if (m.find("UserExtension") != m.end() && !m["UserExtension"].empty()) {
      userExtension = make_shared<string>(boost::any_cast<string>(m["UserExtension"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~CoachCallResponseBodyDataCallContextChannelContexts() = default;
};
class CoachCallResponseBodyDataCallContext : public Darabonba::Model {
public:
  shared_ptr<string> callType{};
  shared_ptr<vector<CoachCallResponseBodyDataCallContextChannelContexts>> channelContexts{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> jobId{};

  CoachCallResponseBodyDataCallContext() {}

  explicit CoachCallResponseBodyDataCallContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callType) {
      res["CallType"] = boost::any(*callType);
    }
    if (channelContexts) {
      vector<boost::any> temp1;
      for(auto item1:*channelContexts){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ChannelContexts"] = boost::any(temp1);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallType") != m.end() && !m["CallType"].empty()) {
      callType = make_shared<string>(boost::any_cast<string>(m["CallType"]));
    }
    if (m.find("ChannelContexts") != m.end() && !m["ChannelContexts"].empty()) {
      if (typeid(vector<boost::any>) == m["ChannelContexts"].type()) {
        vector<CoachCallResponseBodyDataCallContextChannelContexts> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ChannelContexts"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CoachCallResponseBodyDataCallContextChannelContexts model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        channelContexts = make_shared<vector<CoachCallResponseBodyDataCallContextChannelContexts>>(expect1);
      }
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
  }


  virtual ~CoachCallResponseBodyDataCallContext() = default;
};
class CoachCallResponseBodyDataUserContext : public Darabonba::Model {
public:
  shared_ptr<string> breakCode{};
  shared_ptr<string> deviceId{};
  shared_ptr<string> deviceState{};
  shared_ptr<string> extension{};
  shared_ptr<long> heartbeat{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> jobId{};
  shared_ptr<string> mobile{};
  shared_ptr<bool> outboundScenario{};
  shared_ptr<long> reserved{};
  shared_ptr<vector<string>> signedSkillGroupIdList{};
  shared_ptr<string> uri{};
  shared_ptr<string> userId{};
  shared_ptr<string> userState{};
  shared_ptr<string> workMode{};

  CoachCallResponseBodyDataUserContext() {}

  explicit CoachCallResponseBodyDataUserContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (breakCode) {
      res["BreakCode"] = boost::any(*breakCode);
    }
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (deviceState) {
      res["DeviceState"] = boost::any(*deviceState);
    }
    if (extension) {
      res["Extension"] = boost::any(*extension);
    }
    if (heartbeat) {
      res["Heartbeat"] = boost::any(*heartbeat);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (mobile) {
      res["Mobile"] = boost::any(*mobile);
    }
    if (outboundScenario) {
      res["OutboundScenario"] = boost::any(*outboundScenario);
    }
    if (reserved) {
      res["Reserved"] = boost::any(*reserved);
    }
    if (signedSkillGroupIdList) {
      res["SignedSkillGroupIdList"] = boost::any(*signedSkillGroupIdList);
    }
    if (uri) {
      res["Uri"] = boost::any(*uri);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (userState) {
      res["UserState"] = boost::any(*userState);
    }
    if (workMode) {
      res["WorkMode"] = boost::any(*workMode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BreakCode") != m.end() && !m["BreakCode"].empty()) {
      breakCode = make_shared<string>(boost::any_cast<string>(m["BreakCode"]));
    }
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("DeviceState") != m.end() && !m["DeviceState"].empty()) {
      deviceState = make_shared<string>(boost::any_cast<string>(m["DeviceState"]));
    }
    if (m.find("Extension") != m.end() && !m["Extension"].empty()) {
      extension = make_shared<string>(boost::any_cast<string>(m["Extension"]));
    }
    if (m.find("Heartbeat") != m.end() && !m["Heartbeat"].empty()) {
      heartbeat = make_shared<long>(boost::any_cast<long>(m["Heartbeat"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("Mobile") != m.end() && !m["Mobile"].empty()) {
      mobile = make_shared<string>(boost::any_cast<string>(m["Mobile"]));
    }
    if (m.find("OutboundScenario") != m.end() && !m["OutboundScenario"].empty()) {
      outboundScenario = make_shared<bool>(boost::any_cast<bool>(m["OutboundScenario"]));
    }
    if (m.find("Reserved") != m.end() && !m["Reserved"].empty()) {
      reserved = make_shared<long>(boost::any_cast<long>(m["Reserved"]));
    }
    if (m.find("SignedSkillGroupIdList") != m.end() && !m["SignedSkillGroupIdList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SignedSkillGroupIdList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SignedSkillGroupIdList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      signedSkillGroupIdList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Uri") != m.end() && !m["Uri"].empty()) {
      uri = make_shared<string>(boost::any_cast<string>(m["Uri"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
    if (m.find("UserState") != m.end() && !m["UserState"].empty()) {
      userState = make_shared<string>(boost::any_cast<string>(m["UserState"]));
    }
    if (m.find("WorkMode") != m.end() && !m["WorkMode"].empty()) {
      workMode = make_shared<string>(boost::any_cast<string>(m["WorkMode"]));
    }
  }


  virtual ~CoachCallResponseBodyDataUserContext() = default;
};
class CoachCallResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<CoachCallResponseBodyDataCallContext> callContext{};
  shared_ptr<CoachCallResponseBodyDataUserContext> userContext{};

  CoachCallResponseBodyData() {}

  explicit CoachCallResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callContext) {
      res["CallContext"] = callContext ? boost::any(callContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (userContext) {
      res["UserContext"] = userContext ? boost::any(userContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallContext") != m.end() && !m["CallContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["CallContext"].type()) {
        CoachCallResponseBodyDataCallContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CallContext"]));
        callContext = make_shared<CoachCallResponseBodyDataCallContext>(model1);
      }
    }
    if (m.find("UserContext") != m.end() && !m["UserContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["UserContext"].type()) {
        CoachCallResponseBodyDataUserContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["UserContext"]));
        userContext = make_shared<CoachCallResponseBodyDataUserContext>(model1);
      }
    }
  }


  virtual ~CoachCallResponseBodyData() = default;
};
class CoachCallResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<CoachCallResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<vector<string>> params{};
  shared_ptr<string> requestId{};

  CoachCallResponseBody() {}

  explicit CoachCallResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (params) {
      res["Params"] = boost::any(*params);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        CoachCallResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<CoachCallResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Params") != m.end() && !m["Params"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Params"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Params"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      params = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CoachCallResponseBody() = default;
};
class CoachCallResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CoachCallResponseBody> body{};

  CoachCallResponse() {}

  explicit CoachCallResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CoachCallResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CoachCallResponseBody>(model1);
      }
    }
  }


  virtual ~CoachCallResponse() = default;
};
class CompleteAttendedTransferRequest : public Darabonba::Model {
public:
  shared_ptr<string> deviceId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> jobId{};
  shared_ptr<string> userId{};

  CompleteAttendedTransferRequest() {}

  explicit CompleteAttendedTransferRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~CompleteAttendedTransferRequest() = default;
};
class CompleteAttendedTransferResponseBodyDataCallContextChannelContexts : public Darabonba::Model {
public:
  shared_ptr<string> callType{};
  shared_ptr<string> channelFlags{};
  shared_ptr<string> channelId{};
  shared_ptr<string> channelState{};
  shared_ptr<string> destination{};
  shared_ptr<long> index{};
  shared_ptr<string> jobId{};
  shared_ptr<string> originator{};
  shared_ptr<string> releaseInitiator{};
  shared_ptr<string> releaseReason{};
  shared_ptr<string> skillGroupId{};
  shared_ptr<long> timestamp{};
  shared_ptr<string> userExtension{};
  shared_ptr<string> userId{};

  CompleteAttendedTransferResponseBodyDataCallContextChannelContexts() {}

  explicit CompleteAttendedTransferResponseBodyDataCallContextChannelContexts(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callType) {
      res["CallType"] = boost::any(*callType);
    }
    if (channelFlags) {
      res["ChannelFlags"] = boost::any(*channelFlags);
    }
    if (channelId) {
      res["ChannelId"] = boost::any(*channelId);
    }
    if (channelState) {
      res["ChannelState"] = boost::any(*channelState);
    }
    if (destination) {
      res["Destination"] = boost::any(*destination);
    }
    if (index) {
      res["Index"] = boost::any(*index);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (originator) {
      res["Originator"] = boost::any(*originator);
    }
    if (releaseInitiator) {
      res["ReleaseInitiator"] = boost::any(*releaseInitiator);
    }
    if (releaseReason) {
      res["ReleaseReason"] = boost::any(*releaseReason);
    }
    if (skillGroupId) {
      res["SkillGroupId"] = boost::any(*skillGroupId);
    }
    if (timestamp) {
      res["Timestamp"] = boost::any(*timestamp);
    }
    if (userExtension) {
      res["UserExtension"] = boost::any(*userExtension);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallType") != m.end() && !m["CallType"].empty()) {
      callType = make_shared<string>(boost::any_cast<string>(m["CallType"]));
    }
    if (m.find("ChannelFlags") != m.end() && !m["ChannelFlags"].empty()) {
      channelFlags = make_shared<string>(boost::any_cast<string>(m["ChannelFlags"]));
    }
    if (m.find("ChannelId") != m.end() && !m["ChannelId"].empty()) {
      channelId = make_shared<string>(boost::any_cast<string>(m["ChannelId"]));
    }
    if (m.find("ChannelState") != m.end() && !m["ChannelState"].empty()) {
      channelState = make_shared<string>(boost::any_cast<string>(m["ChannelState"]));
    }
    if (m.find("Destination") != m.end() && !m["Destination"].empty()) {
      destination = make_shared<string>(boost::any_cast<string>(m["Destination"]));
    }
    if (m.find("Index") != m.end() && !m["Index"].empty()) {
      index = make_shared<long>(boost::any_cast<long>(m["Index"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("Originator") != m.end() && !m["Originator"].empty()) {
      originator = make_shared<string>(boost::any_cast<string>(m["Originator"]));
    }
    if (m.find("ReleaseInitiator") != m.end() && !m["ReleaseInitiator"].empty()) {
      releaseInitiator = make_shared<string>(boost::any_cast<string>(m["ReleaseInitiator"]));
    }
    if (m.find("ReleaseReason") != m.end() && !m["ReleaseReason"].empty()) {
      releaseReason = make_shared<string>(boost::any_cast<string>(m["ReleaseReason"]));
    }
    if (m.find("SkillGroupId") != m.end() && !m["SkillGroupId"].empty()) {
      skillGroupId = make_shared<string>(boost::any_cast<string>(m["SkillGroupId"]));
    }
    if (m.find("Timestamp") != m.end() && !m["Timestamp"].empty()) {
      timestamp = make_shared<long>(boost::any_cast<long>(m["Timestamp"]));
    }
    if (m.find("UserExtension") != m.end() && !m["UserExtension"].empty()) {
      userExtension = make_shared<string>(boost::any_cast<string>(m["UserExtension"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~CompleteAttendedTransferResponseBodyDataCallContextChannelContexts() = default;
};
class CompleteAttendedTransferResponseBodyDataCallContext : public Darabonba::Model {
public:
  shared_ptr<string> callType{};
  shared_ptr<vector<CompleteAttendedTransferResponseBodyDataCallContextChannelContexts>> channelContexts{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> jobId{};

  CompleteAttendedTransferResponseBodyDataCallContext() {}

  explicit CompleteAttendedTransferResponseBodyDataCallContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callType) {
      res["CallType"] = boost::any(*callType);
    }
    if (channelContexts) {
      vector<boost::any> temp1;
      for(auto item1:*channelContexts){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ChannelContexts"] = boost::any(temp1);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallType") != m.end() && !m["CallType"].empty()) {
      callType = make_shared<string>(boost::any_cast<string>(m["CallType"]));
    }
    if (m.find("ChannelContexts") != m.end() && !m["ChannelContexts"].empty()) {
      if (typeid(vector<boost::any>) == m["ChannelContexts"].type()) {
        vector<CompleteAttendedTransferResponseBodyDataCallContextChannelContexts> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ChannelContexts"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CompleteAttendedTransferResponseBodyDataCallContextChannelContexts model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        channelContexts = make_shared<vector<CompleteAttendedTransferResponseBodyDataCallContextChannelContexts>>(expect1);
      }
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
  }


  virtual ~CompleteAttendedTransferResponseBodyDataCallContext() = default;
};
class CompleteAttendedTransferResponseBodyDataUserContext : public Darabonba::Model {
public:
  shared_ptr<string> breakCode{};
  shared_ptr<string> deviceId{};
  shared_ptr<string> extension{};
  shared_ptr<long> heartbeat{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> jobId{};
  shared_ptr<string> mobile{};
  shared_ptr<bool> outboundScenario{};
  shared_ptr<long> reserved{};
  shared_ptr<vector<string>> signedSkillGroupIdList{};
  shared_ptr<string> userId{};
  shared_ptr<string> userState{};
  shared_ptr<string> workMode{};

  CompleteAttendedTransferResponseBodyDataUserContext() {}

  explicit CompleteAttendedTransferResponseBodyDataUserContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (breakCode) {
      res["BreakCode"] = boost::any(*breakCode);
    }
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (extension) {
      res["Extension"] = boost::any(*extension);
    }
    if (heartbeat) {
      res["Heartbeat"] = boost::any(*heartbeat);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (mobile) {
      res["Mobile"] = boost::any(*mobile);
    }
    if (outboundScenario) {
      res["OutboundScenario"] = boost::any(*outboundScenario);
    }
    if (reserved) {
      res["Reserved"] = boost::any(*reserved);
    }
    if (signedSkillGroupIdList) {
      res["SignedSkillGroupIdList"] = boost::any(*signedSkillGroupIdList);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (userState) {
      res["UserState"] = boost::any(*userState);
    }
    if (workMode) {
      res["WorkMode"] = boost::any(*workMode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BreakCode") != m.end() && !m["BreakCode"].empty()) {
      breakCode = make_shared<string>(boost::any_cast<string>(m["BreakCode"]));
    }
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("Extension") != m.end() && !m["Extension"].empty()) {
      extension = make_shared<string>(boost::any_cast<string>(m["Extension"]));
    }
    if (m.find("Heartbeat") != m.end() && !m["Heartbeat"].empty()) {
      heartbeat = make_shared<long>(boost::any_cast<long>(m["Heartbeat"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("Mobile") != m.end() && !m["Mobile"].empty()) {
      mobile = make_shared<string>(boost::any_cast<string>(m["Mobile"]));
    }
    if (m.find("OutboundScenario") != m.end() && !m["OutboundScenario"].empty()) {
      outboundScenario = make_shared<bool>(boost::any_cast<bool>(m["OutboundScenario"]));
    }
    if (m.find("Reserved") != m.end() && !m["Reserved"].empty()) {
      reserved = make_shared<long>(boost::any_cast<long>(m["Reserved"]));
    }
    if (m.find("SignedSkillGroupIdList") != m.end() && !m["SignedSkillGroupIdList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SignedSkillGroupIdList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SignedSkillGroupIdList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      signedSkillGroupIdList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
    if (m.find("UserState") != m.end() && !m["UserState"].empty()) {
      userState = make_shared<string>(boost::any_cast<string>(m["UserState"]));
    }
    if (m.find("WorkMode") != m.end() && !m["WorkMode"].empty()) {
      workMode = make_shared<string>(boost::any_cast<string>(m["WorkMode"]));
    }
  }


  virtual ~CompleteAttendedTransferResponseBodyDataUserContext() = default;
};
class CompleteAttendedTransferResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<CompleteAttendedTransferResponseBodyDataCallContext> callContext{};
  shared_ptr<long> contextId{};
  shared_ptr<CompleteAttendedTransferResponseBodyDataUserContext> userContext{};

  CompleteAttendedTransferResponseBodyData() {}

  explicit CompleteAttendedTransferResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callContext) {
      res["CallContext"] = callContext ? boost::any(callContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (contextId) {
      res["ContextId"] = boost::any(*contextId);
    }
    if (userContext) {
      res["UserContext"] = userContext ? boost::any(userContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallContext") != m.end() && !m["CallContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["CallContext"].type()) {
        CompleteAttendedTransferResponseBodyDataCallContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CallContext"]));
        callContext = make_shared<CompleteAttendedTransferResponseBodyDataCallContext>(model1);
      }
    }
    if (m.find("ContextId") != m.end() && !m["ContextId"].empty()) {
      contextId = make_shared<long>(boost::any_cast<long>(m["ContextId"]));
    }
    if (m.find("UserContext") != m.end() && !m["UserContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["UserContext"].type()) {
        CompleteAttendedTransferResponseBodyDataUserContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["UserContext"]));
        userContext = make_shared<CompleteAttendedTransferResponseBodyDataUserContext>(model1);
      }
    }
  }


  virtual ~CompleteAttendedTransferResponseBodyData() = default;
};
class CompleteAttendedTransferResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<CompleteAttendedTransferResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<vector<string>> params{};
  shared_ptr<string> requestId{};

  CompleteAttendedTransferResponseBody() {}

  explicit CompleteAttendedTransferResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (params) {
      res["Params"] = boost::any(*params);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        CompleteAttendedTransferResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<CompleteAttendedTransferResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Params") != m.end() && !m["Params"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Params"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Params"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      params = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CompleteAttendedTransferResponseBody() = default;
};
class CompleteAttendedTransferResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CompleteAttendedTransferResponseBody> body{};

  CompleteAttendedTransferResponse() {}

  explicit CompleteAttendedTransferResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CompleteAttendedTransferResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CompleteAttendedTransferResponseBody>(model1);
      }
    }
  }


  virtual ~CompleteAttendedTransferResponse() = default;
};
class CreateAudioFileRequest : public Darabonba::Model {
public:
  shared_ptr<string> audioFileName{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> name{};
  shared_ptr<string> ossFileKey{};

  CreateAudioFileRequest() {}

  explicit CreateAudioFileRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (audioFileName) {
      res["AudioFileName"] = boost::any(*audioFileName);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (ossFileKey) {
      res["OssFileKey"] = boost::any(*ossFileKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AudioFileName") != m.end() && !m["AudioFileName"].empty()) {
      audioFileName = make_shared<string>(boost::any_cast<string>(m["AudioFileName"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("OssFileKey") != m.end() && !m["OssFileKey"].empty()) {
      ossFileKey = make_shared<string>(boost::any_cast<string>(m["OssFileKey"]));
    }
  }


  virtual ~CreateAudioFileRequest() = default;
};
class CreateAudioFileResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  CreateAudioFileResponseBody() {}

  explicit CreateAudioFileResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateAudioFileResponseBody() = default;
};
class CreateAudioFileResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateAudioFileResponseBody> body{};

  CreateAudioFileResponse() {}

  explicit CreateAudioFileResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateAudioFileResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateAudioFileResponseBody>(model1);
      }
    }
  }


  virtual ~CreateAudioFileResponse() = default;
};
class CreateCallTagsRequest : public Darabonba::Model {
public:
  shared_ptr<string> callTagNameList{};
  shared_ptr<string> instanceId{};

  CreateCallTagsRequest() {}

  explicit CreateCallTagsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callTagNameList) {
      res["CallTagNameList"] = boost::any(*callTagNameList);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallTagNameList") != m.end() && !m["CallTagNameList"].empty()) {
      callTagNameList = make_shared<string>(boost::any_cast<string>(m["CallTagNameList"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~CreateCallTagsRequest() = default;
};
class CreateCallTagsResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> item{};
  shared_ptr<string> reason{};

  CreateCallTagsResponseBodyData() {}

  explicit CreateCallTagsResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (item) {
      res["Item"] = boost::any(*item);
    }
    if (reason) {
      res["Reason"] = boost::any(*reason);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Item") != m.end() && !m["Item"].empty()) {
      item = make_shared<string>(boost::any_cast<string>(m["Item"]));
    }
    if (m.find("Reason") != m.end() && !m["Reason"].empty()) {
      reason = make_shared<string>(boost::any_cast<string>(m["Reason"]));
    }
  }


  virtual ~CreateCallTagsResponseBodyData() = default;
};
class CreateCallTagsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<vector<CreateCallTagsResponseBodyData>> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  CreateCallTagsResponseBody() {}

  explicit CreateCallTagsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<CreateCallTagsResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateCallTagsResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<CreateCallTagsResponseBodyData>>(expect1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateCallTagsResponseBody() = default;
};
class CreateCallTagsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateCallTagsResponseBody> body{};

  CreateCallTagsResponse() {}

  explicit CreateCallTagsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateCallTagsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateCallTagsResponseBody>(model1);
      }
    }
  }


  virtual ~CreateCallTagsResponse() = default;
};
class CreateCampaignRequestCaseList : public Darabonba::Model {
public:
  shared_ptr<string> customVariables{};
  shared_ptr<string> phoneNumber{};
  shared_ptr<string> referenceId{};

  CreateCampaignRequestCaseList() {}

  explicit CreateCampaignRequestCaseList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (customVariables) {
      res["CustomVariables"] = boost::any(*customVariables);
    }
    if (phoneNumber) {
      res["PhoneNumber"] = boost::any(*phoneNumber);
    }
    if (referenceId) {
      res["ReferenceId"] = boost::any(*referenceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CustomVariables") != m.end() && !m["CustomVariables"].empty()) {
      customVariables = make_shared<string>(boost::any_cast<string>(m["CustomVariables"]));
    }
    if (m.find("PhoneNumber") != m.end() && !m["PhoneNumber"].empty()) {
      phoneNumber = make_shared<string>(boost::any_cast<string>(m["PhoneNumber"]));
    }
    if (m.find("ReferenceId") != m.end() && !m["ReferenceId"].empty()) {
      referenceId = make_shared<string>(boost::any_cast<string>(m["ReferenceId"]));
    }
  }


  virtual ~CreateCampaignRequestCaseList() = default;
};
class CreateCampaignRequest : public Darabonba::Model {
public:
  shared_ptr<string> callableTime{};
  shared_ptr<string> caseFileKey{};
  shared_ptr<vector<CreateCampaignRequestCaseList>> caseList{};
  shared_ptr<string> contactFlowId{};
  shared_ptr<string> endTime{};
  shared_ptr<string> instanceId{};
  shared_ptr<long> maxAttemptCount{};
  shared_ptr<long> minAttemptInterval{};
  shared_ptr<string> name{};
  shared_ptr<string> queueId{};
  shared_ptr<bool> simulation{};
  shared_ptr<string> simulationParameters{};
  shared_ptr<string> startTime{};
  shared_ptr<string> strategyParameters{};
  shared_ptr<string> strategyType{};

  CreateCampaignRequest() {}

  explicit CreateCampaignRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callableTime) {
      res["CallableTime"] = boost::any(*callableTime);
    }
    if (caseFileKey) {
      res["CaseFileKey"] = boost::any(*caseFileKey);
    }
    if (caseList) {
      vector<boost::any> temp1;
      for(auto item1:*caseList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CaseList"] = boost::any(temp1);
    }
    if (contactFlowId) {
      res["ContactFlowId"] = boost::any(*contactFlowId);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (maxAttemptCount) {
      res["MaxAttemptCount"] = boost::any(*maxAttemptCount);
    }
    if (minAttemptInterval) {
      res["MinAttemptInterval"] = boost::any(*minAttemptInterval);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (queueId) {
      res["QueueId"] = boost::any(*queueId);
    }
    if (simulation) {
      res["Simulation"] = boost::any(*simulation);
    }
    if (simulationParameters) {
      res["SimulationParameters"] = boost::any(*simulationParameters);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (strategyParameters) {
      res["StrategyParameters"] = boost::any(*strategyParameters);
    }
    if (strategyType) {
      res["StrategyType"] = boost::any(*strategyType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallableTime") != m.end() && !m["CallableTime"].empty()) {
      callableTime = make_shared<string>(boost::any_cast<string>(m["CallableTime"]));
    }
    if (m.find("CaseFileKey") != m.end() && !m["CaseFileKey"].empty()) {
      caseFileKey = make_shared<string>(boost::any_cast<string>(m["CaseFileKey"]));
    }
    if (m.find("CaseList") != m.end() && !m["CaseList"].empty()) {
      if (typeid(vector<boost::any>) == m["CaseList"].type()) {
        vector<CreateCampaignRequestCaseList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CaseList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateCampaignRequestCaseList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        caseList = make_shared<vector<CreateCampaignRequestCaseList>>(expect1);
      }
    }
    if (m.find("ContactFlowId") != m.end() && !m["ContactFlowId"].empty()) {
      contactFlowId = make_shared<string>(boost::any_cast<string>(m["ContactFlowId"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("MaxAttemptCount") != m.end() && !m["MaxAttemptCount"].empty()) {
      maxAttemptCount = make_shared<long>(boost::any_cast<long>(m["MaxAttemptCount"]));
    }
    if (m.find("MinAttemptInterval") != m.end() && !m["MinAttemptInterval"].empty()) {
      minAttemptInterval = make_shared<long>(boost::any_cast<long>(m["MinAttemptInterval"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("QueueId") != m.end() && !m["QueueId"].empty()) {
      queueId = make_shared<string>(boost::any_cast<string>(m["QueueId"]));
    }
    if (m.find("Simulation") != m.end() && !m["Simulation"].empty()) {
      simulation = make_shared<bool>(boost::any_cast<bool>(m["Simulation"]));
    }
    if (m.find("SimulationParameters") != m.end() && !m["SimulationParameters"].empty()) {
      simulationParameters = make_shared<string>(boost::any_cast<string>(m["SimulationParameters"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("StrategyParameters") != m.end() && !m["StrategyParameters"].empty()) {
      strategyParameters = make_shared<string>(boost::any_cast<string>(m["StrategyParameters"]));
    }
    if (m.find("StrategyType") != m.end() && !m["StrategyType"].empty()) {
      strategyType = make_shared<string>(boost::any_cast<string>(m["StrategyType"]));
    }
  }


  virtual ~CreateCampaignRequest() = default;
};
class CreateCampaignShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> callableTime{};
  shared_ptr<string> caseFileKey{};
  shared_ptr<string> caseListShrink{};
  shared_ptr<string> contactFlowId{};
  shared_ptr<string> endTime{};
  shared_ptr<string> instanceId{};
  shared_ptr<long> maxAttemptCount{};
  shared_ptr<long> minAttemptInterval{};
  shared_ptr<string> name{};
  shared_ptr<string> queueId{};
  shared_ptr<bool> simulation{};
  shared_ptr<string> simulationParameters{};
  shared_ptr<string> startTime{};
  shared_ptr<string> strategyParameters{};
  shared_ptr<string> strategyType{};

  CreateCampaignShrinkRequest() {}

  explicit CreateCampaignShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callableTime) {
      res["CallableTime"] = boost::any(*callableTime);
    }
    if (caseFileKey) {
      res["CaseFileKey"] = boost::any(*caseFileKey);
    }
    if (caseListShrink) {
      res["CaseList"] = boost::any(*caseListShrink);
    }
    if (contactFlowId) {
      res["ContactFlowId"] = boost::any(*contactFlowId);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (maxAttemptCount) {
      res["MaxAttemptCount"] = boost::any(*maxAttemptCount);
    }
    if (minAttemptInterval) {
      res["MinAttemptInterval"] = boost::any(*minAttemptInterval);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (queueId) {
      res["QueueId"] = boost::any(*queueId);
    }
    if (simulation) {
      res["Simulation"] = boost::any(*simulation);
    }
    if (simulationParameters) {
      res["SimulationParameters"] = boost::any(*simulationParameters);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (strategyParameters) {
      res["StrategyParameters"] = boost::any(*strategyParameters);
    }
    if (strategyType) {
      res["StrategyType"] = boost::any(*strategyType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallableTime") != m.end() && !m["CallableTime"].empty()) {
      callableTime = make_shared<string>(boost::any_cast<string>(m["CallableTime"]));
    }
    if (m.find("CaseFileKey") != m.end() && !m["CaseFileKey"].empty()) {
      caseFileKey = make_shared<string>(boost::any_cast<string>(m["CaseFileKey"]));
    }
    if (m.find("CaseList") != m.end() && !m["CaseList"].empty()) {
      caseListShrink = make_shared<string>(boost::any_cast<string>(m["CaseList"]));
    }
    if (m.find("ContactFlowId") != m.end() && !m["ContactFlowId"].empty()) {
      contactFlowId = make_shared<string>(boost::any_cast<string>(m["ContactFlowId"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("MaxAttemptCount") != m.end() && !m["MaxAttemptCount"].empty()) {
      maxAttemptCount = make_shared<long>(boost::any_cast<long>(m["MaxAttemptCount"]));
    }
    if (m.find("MinAttemptInterval") != m.end() && !m["MinAttemptInterval"].empty()) {
      minAttemptInterval = make_shared<long>(boost::any_cast<long>(m["MinAttemptInterval"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("QueueId") != m.end() && !m["QueueId"].empty()) {
      queueId = make_shared<string>(boost::any_cast<string>(m["QueueId"]));
    }
    if (m.find("Simulation") != m.end() && !m["Simulation"].empty()) {
      simulation = make_shared<bool>(boost::any_cast<bool>(m["Simulation"]));
    }
    if (m.find("SimulationParameters") != m.end() && !m["SimulationParameters"].empty()) {
      simulationParameters = make_shared<string>(boost::any_cast<string>(m["SimulationParameters"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("StrategyParameters") != m.end() && !m["StrategyParameters"].empty()) {
      strategyParameters = make_shared<string>(boost::any_cast<string>(m["StrategyParameters"]));
    }
    if (m.find("StrategyType") != m.end() && !m["StrategyType"].empty()) {
      strategyType = make_shared<string>(boost::any_cast<string>(m["StrategyType"]));
    }
  }


  virtual ~CreateCampaignShrinkRequest() = default;
};
class CreateCampaignResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  CreateCampaignResponseBody() {}

  explicit CreateCampaignResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateCampaignResponseBody() = default;
};
class CreateCampaignResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateCampaignResponseBody> body{};

  CreateCampaignResponse() {}

  explicit CreateCampaignResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateCampaignResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateCampaignResponseBody>(model1);
      }
    }
  }


  virtual ~CreateCampaignResponse() = default;
};
class CreateCustomCallTaggingRequest : public Darabonba::Model {
public:
  shared_ptr<string> customNumberList{};
  shared_ptr<string> instanceId{};

  CreateCustomCallTaggingRequest() {}

  explicit CreateCustomCallTaggingRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (customNumberList) {
      res["CustomNumberList"] = boost::any(*customNumberList);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CustomNumberList") != m.end() && !m["CustomNumberList"].empty()) {
      customNumberList = make_shared<string>(boost::any_cast<string>(m["CustomNumberList"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~CreateCustomCallTaggingRequest() = default;
};
class CreateCustomCallTaggingResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> item{};
  shared_ptr<string> reason{};

  CreateCustomCallTaggingResponseBodyData() {}

  explicit CreateCustomCallTaggingResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (item) {
      res["Item"] = boost::any(*item);
    }
    if (reason) {
      res["Reason"] = boost::any(*reason);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Item") != m.end() && !m["Item"].empty()) {
      item = make_shared<string>(boost::any_cast<string>(m["Item"]));
    }
    if (m.find("Reason") != m.end() && !m["Reason"].empty()) {
      reason = make_shared<string>(boost::any_cast<string>(m["Reason"]));
    }
  }


  virtual ~CreateCustomCallTaggingResponseBodyData() = default;
};
class CreateCustomCallTaggingResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<vector<CreateCustomCallTaggingResponseBodyData>> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  CreateCustomCallTaggingResponseBody() {}

  explicit CreateCustomCallTaggingResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<CreateCustomCallTaggingResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateCustomCallTaggingResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<CreateCustomCallTaggingResponseBodyData>>(expect1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateCustomCallTaggingResponseBody() = default;
};
class CreateCustomCallTaggingResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateCustomCallTaggingResponseBody> body{};

  CreateCustomCallTaggingResponse() {}

  explicit CreateCustomCallTaggingResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateCustomCallTaggingResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateCustomCallTaggingResponseBody>(model1);
      }
    }
  }


  virtual ~CreateCustomCallTaggingResponse() = default;
};
class CreateInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<string> adminRamIdList{};
  shared_ptr<string> description{};
  shared_ptr<string> domainName{};
  shared_ptr<string> name{};
  shared_ptr<string> numberList{};

  CreateInstanceRequest() {}

  explicit CreateInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (adminRamIdList) {
      res["AdminRamIdList"] = boost::any(*adminRamIdList);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (numberList) {
      res["NumberList"] = boost::any(*numberList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AdminRamIdList") != m.end() && !m["AdminRamIdList"].empty()) {
      adminRamIdList = make_shared<string>(boost::any_cast<string>(m["AdminRamIdList"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("NumberList") != m.end() && !m["NumberList"].empty()) {
      numberList = make_shared<string>(boost::any_cast<string>(m["NumberList"]));
    }
  }


  virtual ~CreateInstanceRequest() = default;
};
class CreateInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  CreateInstanceResponseBody() {}

  explicit CreateInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateInstanceResponseBody() = default;
};
class CreateInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateInstanceResponseBody> body{};

  CreateInstanceResponse() {}

  explicit CreateInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~CreateInstanceResponse() = default;
};
class CreateSkillGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> displayName{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> name{};

  CreateSkillGroupRequest() {}

  explicit CreateSkillGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (displayName) {
      res["DisplayName"] = boost::any(*displayName);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DisplayName") != m.end() && !m["DisplayName"].empty()) {
      displayName = make_shared<string>(boost::any_cast<string>(m["DisplayName"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~CreateSkillGroupRequest() = default;
};
class CreateSkillGroupResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> name{};
  shared_ptr<string> skillGroupId{};

  CreateSkillGroupResponseBodyData() {}

  explicit CreateSkillGroupResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (skillGroupId) {
      res["SkillGroupId"] = boost::any(*skillGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("SkillGroupId") != m.end() && !m["SkillGroupId"].empty()) {
      skillGroupId = make_shared<string>(boost::any_cast<string>(m["SkillGroupId"]));
    }
  }


  virtual ~CreateSkillGroupResponseBodyData() = default;
};
class CreateSkillGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<CreateSkillGroupResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  CreateSkillGroupResponseBody() {}

  explicit CreateSkillGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        CreateSkillGroupResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<CreateSkillGroupResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateSkillGroupResponseBody() = default;
};
class CreateSkillGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateSkillGroupResponseBody> body{};

  CreateSkillGroupResponse() {}

  explicit CreateSkillGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateSkillGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateSkillGroupResponseBody>(model1);
      }
    }
  }


  virtual ~CreateSkillGroupResponse() = default;
};
class CreateUserRequest : public Darabonba::Model {
public:
  shared_ptr<string> displayId{};
  shared_ptr<string> displayName{};
  shared_ptr<string> email{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> loginName{};
  shared_ptr<string> mobile{};
  shared_ptr<bool> resetPassword{};
  shared_ptr<string> roleId{};
  shared_ptr<string> skillLevelList{};
  shared_ptr<string> workMode{};

  CreateUserRequest() {}

  explicit CreateUserRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (displayId) {
      res["DisplayId"] = boost::any(*displayId);
    }
    if (displayName) {
      res["DisplayName"] = boost::any(*displayName);
    }
    if (email) {
      res["Email"] = boost::any(*email);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (loginName) {
      res["LoginName"] = boost::any(*loginName);
    }
    if (mobile) {
      res["Mobile"] = boost::any(*mobile);
    }
    if (resetPassword) {
      res["ResetPassword"] = boost::any(*resetPassword);
    }
    if (roleId) {
      res["RoleId"] = boost::any(*roleId);
    }
    if (skillLevelList) {
      res["SkillLevelList"] = boost::any(*skillLevelList);
    }
    if (workMode) {
      res["WorkMode"] = boost::any(*workMode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DisplayId") != m.end() && !m["DisplayId"].empty()) {
      displayId = make_shared<string>(boost::any_cast<string>(m["DisplayId"]));
    }
    if (m.find("DisplayName") != m.end() && !m["DisplayName"].empty()) {
      displayName = make_shared<string>(boost::any_cast<string>(m["DisplayName"]));
    }
    if (m.find("Email") != m.end() && !m["Email"].empty()) {
      email = make_shared<string>(boost::any_cast<string>(m["Email"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("LoginName") != m.end() && !m["LoginName"].empty()) {
      loginName = make_shared<string>(boost::any_cast<string>(m["LoginName"]));
    }
    if (m.find("Mobile") != m.end() && !m["Mobile"].empty()) {
      mobile = make_shared<string>(boost::any_cast<string>(m["Mobile"]));
    }
    if (m.find("ResetPassword") != m.end() && !m["ResetPassword"].empty()) {
      resetPassword = make_shared<bool>(boost::any_cast<bool>(m["ResetPassword"]));
    }
    if (m.find("RoleId") != m.end() && !m["RoleId"].empty()) {
      roleId = make_shared<string>(boost::any_cast<string>(m["RoleId"]));
    }
    if (m.find("SkillLevelList") != m.end() && !m["SkillLevelList"].empty()) {
      skillLevelList = make_shared<string>(boost::any_cast<string>(m["SkillLevelList"]));
    }
    if (m.find("WorkMode") != m.end() && !m["WorkMode"].empty()) {
      workMode = make_shared<string>(boost::any_cast<string>(m["WorkMode"]));
    }
  }


  virtual ~CreateUserRequest() = default;
};
class CreateUserResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> displayName{};
  shared_ptr<string> email{};
  shared_ptr<string> extension{};
  shared_ptr<string> loginName{};
  shared_ptr<string> mobile{};
  shared_ptr<string> userId{};
  shared_ptr<string> workMode{};

  CreateUserResponseBodyData() {}

  explicit CreateUserResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (displayName) {
      res["DisplayName"] = boost::any(*displayName);
    }
    if (email) {
      res["Email"] = boost::any(*email);
    }
    if (extension) {
      res["Extension"] = boost::any(*extension);
    }
    if (loginName) {
      res["LoginName"] = boost::any(*loginName);
    }
    if (mobile) {
      res["Mobile"] = boost::any(*mobile);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (workMode) {
      res["WorkMode"] = boost::any(*workMode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DisplayName") != m.end() && !m["DisplayName"].empty()) {
      displayName = make_shared<string>(boost::any_cast<string>(m["DisplayName"]));
    }
    if (m.find("Email") != m.end() && !m["Email"].empty()) {
      email = make_shared<string>(boost::any_cast<string>(m["Email"]));
    }
    if (m.find("Extension") != m.end() && !m["Extension"].empty()) {
      extension = make_shared<string>(boost::any_cast<string>(m["Extension"]));
    }
    if (m.find("LoginName") != m.end() && !m["LoginName"].empty()) {
      loginName = make_shared<string>(boost::any_cast<string>(m["LoginName"]));
    }
    if (m.find("Mobile") != m.end() && !m["Mobile"].empty()) {
      mobile = make_shared<string>(boost::any_cast<string>(m["Mobile"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
    if (m.find("WorkMode") != m.end() && !m["WorkMode"].empty()) {
      workMode = make_shared<string>(boost::any_cast<string>(m["WorkMode"]));
    }
  }


  virtual ~CreateUserResponseBodyData() = default;
};
class CreateUserResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<CreateUserResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  CreateUserResponseBody() {}

  explicit CreateUserResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        CreateUserResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<CreateUserResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateUserResponseBody() = default;
};
class CreateUserResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateUserResponseBody> body{};

  CreateUserResponse() {}

  explicit CreateUserResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateUserResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateUserResponseBody>(model1);
      }
    }
  }


  virtual ~CreateUserResponse() = default;
};
class DeleteAudioFileRequest : public Darabonba::Model {
public:
  shared_ptr<string> audioResourceId{};
  shared_ptr<string> instanceId{};

  DeleteAudioFileRequest() {}

  explicit DeleteAudioFileRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (audioResourceId) {
      res["AudioResourceId"] = boost::any(*audioResourceId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AudioResourceId") != m.end() && !m["AudioResourceId"].empty()) {
      audioResourceId = make_shared<string>(boost::any_cast<string>(m["AudioResourceId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~DeleteAudioFileRequest() = default;
};
class DeleteAudioFileResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  DeleteAudioFileResponseBody() {}

  explicit DeleteAudioFileResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteAudioFileResponseBody() = default;
};
class DeleteAudioFileResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteAudioFileResponseBody> body{};

  DeleteAudioFileResponse() {}

  explicit DeleteAudioFileResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteAudioFileResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteAudioFileResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteAudioFileResponse() = default;
};
class DeleteCallTagRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> tagName{};

  DeleteCallTagRequest() {}

  explicit DeleteCallTagRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (tagName) {
      res["TagName"] = boost::any(*tagName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("TagName") != m.end() && !m["TagName"].empty()) {
      tagName = make_shared<string>(boost::any_cast<string>(m["TagName"]));
    }
  }


  virtual ~DeleteCallTagRequest() = default;
};
class DeleteCallTagResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  DeleteCallTagResponseBody() {}

  explicit DeleteCallTagResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteCallTagResponseBody() = default;
};
class DeleteCallTagResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteCallTagResponseBody> body{};

  DeleteCallTagResponse() {}

  explicit DeleteCallTagResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteCallTagResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteCallTagResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteCallTagResponse() = default;
};
class DeleteCustomCallTaggingRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> number{};

  DeleteCustomCallTaggingRequest() {}

  explicit DeleteCustomCallTaggingRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (number) {
      res["Number"] = boost::any(*number);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Number") != m.end() && !m["Number"].empty()) {
      number = make_shared<string>(boost::any_cast<string>(m["Number"]));
    }
  }


  virtual ~DeleteCustomCallTaggingRequest() = default;
};
class DeleteCustomCallTaggingResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  DeleteCustomCallTaggingResponseBody() {}

  explicit DeleteCustomCallTaggingResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteCustomCallTaggingResponseBody() = default;
};
class DeleteCustomCallTaggingResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteCustomCallTaggingResponseBody> body{};

  DeleteCustomCallTaggingResponse() {}

  explicit DeleteCustomCallTaggingResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteCustomCallTaggingResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteCustomCallTaggingResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteCustomCallTaggingResponse() = default;
};
class DeleteSkillGroupRequest : public Darabonba::Model {
public:
  shared_ptr<bool> force{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> skillGroupId{};

  DeleteSkillGroupRequest() {}

  explicit DeleteSkillGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (force) {
      res["Force"] = boost::any(*force);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (skillGroupId) {
      res["SkillGroupId"] = boost::any(*skillGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Force") != m.end() && !m["Force"].empty()) {
      force = make_shared<bool>(boost::any_cast<bool>(m["Force"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("SkillGroupId") != m.end() && !m["SkillGroupId"].empty()) {
      skillGroupId = make_shared<string>(boost::any_cast<string>(m["SkillGroupId"]));
    }
  }


  virtual ~DeleteSkillGroupRequest() = default;
};
class DeleteSkillGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  DeleteSkillGroupResponseBody() {}

  explicit DeleteSkillGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteSkillGroupResponseBody() = default;
};
class DeleteSkillGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteSkillGroupResponseBody> body{};

  DeleteSkillGroupResponse() {}

  explicit DeleteSkillGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteSkillGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteSkillGroupResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteSkillGroupResponse() = default;
};
class EndConferenceRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> jobId{};
  shared_ptr<string> userId{};

  EndConferenceRequest() {}

  explicit EndConferenceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~EndConferenceRequest() = default;
};
class EndConferenceResponseBodyDataCallContextChannelContexts : public Darabonba::Model {
public:
  shared_ptr<string> callType{};
  shared_ptr<string> channelId{};
  shared_ptr<string> channelState{};
  shared_ptr<string> destination{};
  shared_ptr<string> jobId{};
  shared_ptr<string> originator{};
  shared_ptr<string> releaseInitiator{};
  shared_ptr<string> releaseReason{};
  shared_ptr<long> timestamp{};
  shared_ptr<string> userExtension{};
  shared_ptr<string> userId{};

  EndConferenceResponseBodyDataCallContextChannelContexts() {}

  explicit EndConferenceResponseBodyDataCallContextChannelContexts(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callType) {
      res["CallType"] = boost::any(*callType);
    }
    if (channelId) {
      res["ChannelId"] = boost::any(*channelId);
    }
    if (channelState) {
      res["ChannelState"] = boost::any(*channelState);
    }
    if (destination) {
      res["Destination"] = boost::any(*destination);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (originator) {
      res["Originator"] = boost::any(*originator);
    }
    if (releaseInitiator) {
      res["ReleaseInitiator"] = boost::any(*releaseInitiator);
    }
    if (releaseReason) {
      res["ReleaseReason"] = boost::any(*releaseReason);
    }
    if (timestamp) {
      res["Timestamp"] = boost::any(*timestamp);
    }
    if (userExtension) {
      res["UserExtension"] = boost::any(*userExtension);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallType") != m.end() && !m["CallType"].empty()) {
      callType = make_shared<string>(boost::any_cast<string>(m["CallType"]));
    }
    if (m.find("ChannelId") != m.end() && !m["ChannelId"].empty()) {
      channelId = make_shared<string>(boost::any_cast<string>(m["ChannelId"]));
    }
    if (m.find("ChannelState") != m.end() && !m["ChannelState"].empty()) {
      channelState = make_shared<string>(boost::any_cast<string>(m["ChannelState"]));
    }
    if (m.find("Destination") != m.end() && !m["Destination"].empty()) {
      destination = make_shared<string>(boost::any_cast<string>(m["Destination"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("Originator") != m.end() && !m["Originator"].empty()) {
      originator = make_shared<string>(boost::any_cast<string>(m["Originator"]));
    }
    if (m.find("ReleaseInitiator") != m.end() && !m["ReleaseInitiator"].empty()) {
      releaseInitiator = make_shared<string>(boost::any_cast<string>(m["ReleaseInitiator"]));
    }
    if (m.find("ReleaseReason") != m.end() && !m["ReleaseReason"].empty()) {
      releaseReason = make_shared<string>(boost::any_cast<string>(m["ReleaseReason"]));
    }
    if (m.find("Timestamp") != m.end() && !m["Timestamp"].empty()) {
      timestamp = make_shared<long>(boost::any_cast<long>(m["Timestamp"]));
    }
    if (m.find("UserExtension") != m.end() && !m["UserExtension"].empty()) {
      userExtension = make_shared<string>(boost::any_cast<string>(m["UserExtension"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~EndConferenceResponseBodyDataCallContextChannelContexts() = default;
};
class EndConferenceResponseBodyDataCallContext : public Darabonba::Model {
public:
  shared_ptr<vector<EndConferenceResponseBodyDataCallContextChannelContexts>> channelContexts{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> jobId{};

  EndConferenceResponseBodyDataCallContext() {}

  explicit EndConferenceResponseBodyDataCallContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (channelContexts) {
      vector<boost::any> temp1;
      for(auto item1:*channelContexts){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ChannelContexts"] = boost::any(temp1);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChannelContexts") != m.end() && !m["ChannelContexts"].empty()) {
      if (typeid(vector<boost::any>) == m["ChannelContexts"].type()) {
        vector<EndConferenceResponseBodyDataCallContextChannelContexts> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ChannelContexts"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            EndConferenceResponseBodyDataCallContextChannelContexts model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        channelContexts = make_shared<vector<EndConferenceResponseBodyDataCallContextChannelContexts>>(expect1);
      }
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
  }


  virtual ~EndConferenceResponseBodyDataCallContext() = default;
};
class EndConferenceResponseBodyDataUserContext : public Darabonba::Model {
public:
  shared_ptr<string> breakCode{};
  shared_ptr<string> deviceId{};
  shared_ptr<string> deviceState{};
  shared_ptr<string> extension{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> jobId{};
  shared_ptr<bool> outboundScenario{};
  shared_ptr<vector<string>> signedSkillGroupIdList{};
  shared_ptr<string> userId{};
  shared_ptr<string> userState{};
  shared_ptr<string> workMode{};

  EndConferenceResponseBodyDataUserContext() {}

  explicit EndConferenceResponseBodyDataUserContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (breakCode) {
      res["BreakCode"] = boost::any(*breakCode);
    }
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (deviceState) {
      res["DeviceState"] = boost::any(*deviceState);
    }
    if (extension) {
      res["Extension"] = boost::any(*extension);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (outboundScenario) {
      res["OutboundScenario"] = boost::any(*outboundScenario);
    }
    if (signedSkillGroupIdList) {
      res["SignedSkillGroupIdList"] = boost::any(*signedSkillGroupIdList);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (userState) {
      res["UserState"] = boost::any(*userState);
    }
    if (workMode) {
      res["WorkMode"] = boost::any(*workMode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BreakCode") != m.end() && !m["BreakCode"].empty()) {
      breakCode = make_shared<string>(boost::any_cast<string>(m["BreakCode"]));
    }
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("DeviceState") != m.end() && !m["DeviceState"].empty()) {
      deviceState = make_shared<string>(boost::any_cast<string>(m["DeviceState"]));
    }
    if (m.find("Extension") != m.end() && !m["Extension"].empty()) {
      extension = make_shared<string>(boost::any_cast<string>(m["Extension"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("OutboundScenario") != m.end() && !m["OutboundScenario"].empty()) {
      outboundScenario = make_shared<bool>(boost::any_cast<bool>(m["OutboundScenario"]));
    }
    if (m.find("SignedSkillGroupIdList") != m.end() && !m["SignedSkillGroupIdList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SignedSkillGroupIdList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SignedSkillGroupIdList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      signedSkillGroupIdList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
    if (m.find("UserState") != m.end() && !m["UserState"].empty()) {
      userState = make_shared<string>(boost::any_cast<string>(m["UserState"]));
    }
    if (m.find("WorkMode") != m.end() && !m["WorkMode"].empty()) {
      workMode = make_shared<string>(boost::any_cast<string>(m["WorkMode"]));
    }
  }


  virtual ~EndConferenceResponseBodyDataUserContext() = default;
};
class EndConferenceResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<EndConferenceResponseBodyDataCallContext> callContext{};
  shared_ptr<long> contextId{};
  shared_ptr<EndConferenceResponseBodyDataUserContext> userContext{};

  EndConferenceResponseBodyData() {}

  explicit EndConferenceResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callContext) {
      res["CallContext"] = callContext ? boost::any(callContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (contextId) {
      res["ContextId"] = boost::any(*contextId);
    }
    if (userContext) {
      res["UserContext"] = userContext ? boost::any(userContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallContext") != m.end() && !m["CallContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["CallContext"].type()) {
        EndConferenceResponseBodyDataCallContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CallContext"]));
        callContext = make_shared<EndConferenceResponseBodyDataCallContext>(model1);
      }
    }
    if (m.find("ContextId") != m.end() && !m["ContextId"].empty()) {
      contextId = make_shared<long>(boost::any_cast<long>(m["ContextId"]));
    }
    if (m.find("UserContext") != m.end() && !m["UserContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["UserContext"].type()) {
        EndConferenceResponseBodyDataUserContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["UserContext"]));
        userContext = make_shared<EndConferenceResponseBodyDataUserContext>(model1);
      }
    }
  }


  virtual ~EndConferenceResponseBodyData() = default;
};
class EndConferenceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<EndConferenceResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<vector<string>> params{};
  shared_ptr<string> requestId{};

  EndConferenceResponseBody() {}

  explicit EndConferenceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (params) {
      res["Params"] = boost::any(*params);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        EndConferenceResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<EndConferenceResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Params") != m.end() && !m["Params"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Params"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Params"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      params = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~EndConferenceResponseBody() = default;
};
class EndConferenceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<EndConferenceResponseBody> body{};

  EndConferenceResponse() {}

  explicit EndConferenceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        EndConferenceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<EndConferenceResponseBody>(model1);
      }
    }
  }


  virtual ~EndConferenceResponse() = default;
};
class ExportCustomCallTaggingRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};

  ExportCustomCallTaggingRequest() {}

  explicit ExportCustomCallTaggingRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~ExportCustomCallTaggingRequest() = default;
};
class ExportCustomCallTaggingResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  ExportCustomCallTaggingResponseBody() {}

  explicit ExportCustomCallTaggingResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ExportCustomCallTaggingResponseBody() = default;
};
class ExportCustomCallTaggingResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ExportCustomCallTaggingResponseBody> body{};

  ExportCustomCallTaggingResponse() {}

  explicit ExportCustomCallTaggingResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ExportCustomCallTaggingResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ExportCustomCallTaggingResponseBody>(model1);
      }
    }
  }


  virtual ~ExportCustomCallTaggingResponse() = default;
};
class ExportDoNotCallNumbersRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> scope{};
  shared_ptr<string> searchPattern{};

  ExportDoNotCallNumbersRequest() {}

  explicit ExportDoNotCallNumbersRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (scope) {
      res["Scope"] = boost::any(*scope);
    }
    if (searchPattern) {
      res["SearchPattern"] = boost::any(*searchPattern);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Scope") != m.end() && !m["Scope"].empty()) {
      scope = make_shared<string>(boost::any_cast<string>(m["Scope"]));
    }
    if (m.find("SearchPattern") != m.end() && !m["SearchPattern"].empty()) {
      searchPattern = make_shared<string>(boost::any_cast<string>(m["SearchPattern"]));
    }
  }


  virtual ~ExportDoNotCallNumbersRequest() = default;
};
class ExportDoNotCallNumbersResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  ExportDoNotCallNumbersResponseBody() {}

  explicit ExportDoNotCallNumbersResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ExportDoNotCallNumbersResponseBody() = default;
};
class ExportDoNotCallNumbersResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ExportDoNotCallNumbersResponseBody> body{};

  ExportDoNotCallNumbersResponse() {}

  explicit ExportDoNotCallNumbersResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ExportDoNotCallNumbersResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ExportDoNotCallNumbersResponseBody>(model1);
      }
    }
  }


  virtual ~ExportDoNotCallNumbersResponse() = default;
};
class GetAudioFileRequest : public Darabonba::Model {
public:
  shared_ptr<string> audioResourceId{};
  shared_ptr<string> instanceId{};

  GetAudioFileRequest() {}

  explicit GetAudioFileRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (audioResourceId) {
      res["AudioResourceId"] = boost::any(*audioResourceId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AudioResourceId") != m.end() && !m["AudioResourceId"].empty()) {
      audioResourceId = make_shared<string>(boost::any_cast<string>(m["AudioResourceId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~GetAudioFileRequest() = default;
};
class GetAudioFileResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> audioFileName{};
  shared_ptr<string> audioResourceId{};
  shared_ptr<string> createdTime{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> name{};
  shared_ptr<string> ossFileKey{};
  shared_ptr<string> updatedTime{};

  GetAudioFileResponseBodyData() {}

  explicit GetAudioFileResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (audioFileName) {
      res["AudioFileName"] = boost::any(*audioFileName);
    }
    if (audioResourceId) {
      res["AudioResourceId"] = boost::any(*audioResourceId);
    }
    if (createdTime) {
      res["CreatedTime"] = boost::any(*createdTime);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (ossFileKey) {
      res["OssFileKey"] = boost::any(*ossFileKey);
    }
    if (updatedTime) {
      res["UpdatedTime"] = boost::any(*updatedTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AudioFileName") != m.end() && !m["AudioFileName"].empty()) {
      audioFileName = make_shared<string>(boost::any_cast<string>(m["AudioFileName"]));
    }
    if (m.find("AudioResourceId") != m.end() && !m["AudioResourceId"].empty()) {
      audioResourceId = make_shared<string>(boost::any_cast<string>(m["AudioResourceId"]));
    }
    if (m.find("CreatedTime") != m.end() && !m["CreatedTime"].empty()) {
      createdTime = make_shared<string>(boost::any_cast<string>(m["CreatedTime"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("OssFileKey") != m.end() && !m["OssFileKey"].empty()) {
      ossFileKey = make_shared<string>(boost::any_cast<string>(m["OssFileKey"]));
    }
    if (m.find("UpdatedTime") != m.end() && !m["UpdatedTime"].empty()) {
      updatedTime = make_shared<string>(boost::any_cast<string>(m["UpdatedTime"]));
    }
  }


  virtual ~GetAudioFileResponseBodyData() = default;
};
class GetAudioFileResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<GetAudioFileResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  GetAudioFileResponseBody() {}

  explicit GetAudioFileResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetAudioFileResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetAudioFileResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetAudioFileResponseBody() = default;
};
class GetAudioFileResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetAudioFileResponseBody> body{};

  GetAudioFileResponse() {}

  explicit GetAudioFileResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetAudioFileResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetAudioFileResponseBody>(model1);
      }
    }
  }


  virtual ~GetAudioFileResponse() = default;
};
class GetAudioFileDownloadUrlRequest : public Darabonba::Model {
public:
  shared_ptr<string> audioResourceId{};
  shared_ptr<string> instanceId{};

  GetAudioFileDownloadUrlRequest() {}

  explicit GetAudioFileDownloadUrlRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (audioResourceId) {
      res["AudioResourceId"] = boost::any(*audioResourceId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AudioResourceId") != m.end() && !m["AudioResourceId"].empty()) {
      audioResourceId = make_shared<string>(boost::any_cast<string>(m["AudioResourceId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~GetAudioFileDownloadUrlRequest() = default;
};
class GetAudioFileDownloadUrlResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  GetAudioFileDownloadUrlResponseBody() {}

  explicit GetAudioFileDownloadUrlResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetAudioFileDownloadUrlResponseBody() = default;
};
class GetAudioFileDownloadUrlResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetAudioFileDownloadUrlResponseBody> body{};

  GetAudioFileDownloadUrlResponse() {}

  explicit GetAudioFileDownloadUrlResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetAudioFileDownloadUrlResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetAudioFileDownloadUrlResponseBody>(model1);
      }
    }
  }


  virtual ~GetAudioFileDownloadUrlResponse() = default;
};
class GetAudioFileUploadParametersRequest : public Darabonba::Model {
public:
  shared_ptr<string> audioFileName{};
  shared_ptr<string> instanceId{};

  GetAudioFileUploadParametersRequest() {}

  explicit GetAudioFileUploadParametersRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (audioFileName) {
      res["AudioFileName"] = boost::any(*audioFileName);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AudioFileName") != m.end() && !m["AudioFileName"].empty()) {
      audioFileName = make_shared<string>(boost::any_cast<string>(m["AudioFileName"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~GetAudioFileUploadParametersRequest() = default;
};
class GetAudioFileUploadParametersResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> accessKeyId{};
  shared_ptr<long> expireTime{};
  shared_ptr<string> filePath{};
  shared_ptr<string> host{};
  shared_ptr<string> policy{};
  shared_ptr<string> signature{};

  GetAudioFileUploadParametersResponseBodyData() {}

  explicit GetAudioFileUploadParametersResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessKeyId) {
      res["AccessKeyId"] = boost::any(*accessKeyId);
    }
    if (expireTime) {
      res["ExpireTime"] = boost::any(*expireTime);
    }
    if (filePath) {
      res["FilePath"] = boost::any(*filePath);
    }
    if (host) {
      res["Host"] = boost::any(*host);
    }
    if (policy) {
      res["Policy"] = boost::any(*policy);
    }
    if (signature) {
      res["Signature"] = boost::any(*signature);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccessKeyId") != m.end() && !m["AccessKeyId"].empty()) {
      accessKeyId = make_shared<string>(boost::any_cast<string>(m["AccessKeyId"]));
    }
    if (m.find("ExpireTime") != m.end() && !m["ExpireTime"].empty()) {
      expireTime = make_shared<long>(boost::any_cast<long>(m["ExpireTime"]));
    }
    if (m.find("FilePath") != m.end() && !m["FilePath"].empty()) {
      filePath = make_shared<string>(boost::any_cast<string>(m["FilePath"]));
    }
    if (m.find("Host") != m.end() && !m["Host"].empty()) {
      host = make_shared<string>(boost::any_cast<string>(m["Host"]));
    }
    if (m.find("Policy") != m.end() && !m["Policy"].empty()) {
      policy = make_shared<string>(boost::any_cast<string>(m["Policy"]));
    }
    if (m.find("Signature") != m.end() && !m["Signature"].empty()) {
      signature = make_shared<string>(boost::any_cast<string>(m["Signature"]));
    }
  }


  virtual ~GetAudioFileUploadParametersResponseBodyData() = default;
};
class GetAudioFileUploadParametersResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<GetAudioFileUploadParametersResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  GetAudioFileUploadParametersResponseBody() {}

  explicit GetAudioFileUploadParametersResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetAudioFileUploadParametersResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetAudioFileUploadParametersResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetAudioFileUploadParametersResponseBody() = default;
};
class GetAudioFileUploadParametersResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetAudioFileUploadParametersResponseBody> body{};

  GetAudioFileUploadParametersResponse() {}

  explicit GetAudioFileUploadParametersResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetAudioFileUploadParametersResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetAudioFileUploadParametersResponseBody>(model1);
      }
    }
  }


  virtual ~GetAudioFileUploadParametersResponse() = default;
};
class GetCallDetailRecordRequest : public Darabonba::Model {
public:
  shared_ptr<string> contactId{};
  shared_ptr<string> instanceId{};

  GetCallDetailRecordRequest() {}

  explicit GetCallDetailRecordRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contactId) {
      res["ContactId"] = boost::any(*contactId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ContactId") != m.end() && !m["ContactId"].empty()) {
      contactId = make_shared<string>(boost::any_cast<string>(m["ContactId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~GetCallDetailRecordRequest() = default;
};
class GetCallDetailRecordResponseBodyDataAgentEventsEventSequence : public Darabonba::Model {
public:
  shared_ptr<long> duration{};
  shared_ptr<string> event{};
  shared_ptr<long> eventTime{};

  GetCallDetailRecordResponseBodyDataAgentEventsEventSequence() {}

  explicit GetCallDetailRecordResponseBodyDataAgentEventsEventSequence(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (event) {
      res["Event"] = boost::any(*event);
    }
    if (eventTime) {
      res["EventTime"] = boost::any(*eventTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<long>(boost::any_cast<long>(m["Duration"]));
    }
    if (m.find("Event") != m.end() && !m["Event"].empty()) {
      event = make_shared<string>(boost::any_cast<string>(m["Event"]));
    }
    if (m.find("EventTime") != m.end() && !m["EventTime"].empty()) {
      eventTime = make_shared<long>(boost::any_cast<long>(m["EventTime"]));
    }
  }


  virtual ~GetCallDetailRecordResponseBodyDataAgentEventsEventSequence() = default;
};
class GetCallDetailRecordResponseBodyDataAgentEvents : public Darabonba::Model {
public:
  shared_ptr<string> agentId{};
  shared_ptr<string> agentName{};
  shared_ptr<vector<GetCallDetailRecordResponseBodyDataAgentEventsEventSequence>> eventSequence{};
  shared_ptr<string> skillGroupId{};

  GetCallDetailRecordResponseBodyDataAgentEvents() {}

  explicit GetCallDetailRecordResponseBodyDataAgentEvents(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agentId) {
      res["AgentId"] = boost::any(*agentId);
    }
    if (agentName) {
      res["AgentName"] = boost::any(*agentName);
    }
    if (eventSequence) {
      vector<boost::any> temp1;
      for(auto item1:*eventSequence){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["EventSequence"] = boost::any(temp1);
    }
    if (skillGroupId) {
      res["SkillGroupId"] = boost::any(*skillGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AgentId") != m.end() && !m["AgentId"].empty()) {
      agentId = make_shared<string>(boost::any_cast<string>(m["AgentId"]));
    }
    if (m.find("AgentName") != m.end() && !m["AgentName"].empty()) {
      agentName = make_shared<string>(boost::any_cast<string>(m["AgentName"]));
    }
    if (m.find("EventSequence") != m.end() && !m["EventSequence"].empty()) {
      if (typeid(vector<boost::any>) == m["EventSequence"].type()) {
        vector<GetCallDetailRecordResponseBodyDataAgentEventsEventSequence> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["EventSequence"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetCallDetailRecordResponseBodyDataAgentEventsEventSequence model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        eventSequence = make_shared<vector<GetCallDetailRecordResponseBodyDataAgentEventsEventSequence>>(expect1);
      }
    }
    if (m.find("SkillGroupId") != m.end() && !m["SkillGroupId"].empty()) {
      skillGroupId = make_shared<string>(boost::any_cast<string>(m["SkillGroupId"]));
    }
  }


  virtual ~GetCallDetailRecordResponseBodyDataAgentEvents() = default;
};
class GetCallDetailRecordResponseBodyDataCustomerEventsEventSequence : public Darabonba::Model {
public:
  shared_ptr<string> event{};
  shared_ptr<long> eventTime{};

  GetCallDetailRecordResponseBodyDataCustomerEventsEventSequence() {}

  explicit GetCallDetailRecordResponseBodyDataCustomerEventsEventSequence(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (event) {
      res["Event"] = boost::any(*event);
    }
    if (eventTime) {
      res["EventTime"] = boost::any(*eventTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Event") != m.end() && !m["Event"].empty()) {
      event = make_shared<string>(boost::any_cast<string>(m["Event"]));
    }
    if (m.find("EventTime") != m.end() && !m["EventTime"].empty()) {
      eventTime = make_shared<long>(boost::any_cast<long>(m["EventTime"]));
    }
  }


  virtual ~GetCallDetailRecordResponseBodyDataCustomerEventsEventSequence() = default;
};
class GetCallDetailRecordResponseBodyDataCustomerEvents : public Darabonba::Model {
public:
  shared_ptr<string> customerId{};
  shared_ptr<vector<GetCallDetailRecordResponseBodyDataCustomerEventsEventSequence>> eventSequence{};

  GetCallDetailRecordResponseBodyDataCustomerEvents() {}

  explicit GetCallDetailRecordResponseBodyDataCustomerEvents(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (customerId) {
      res["CustomerId"] = boost::any(*customerId);
    }
    if (eventSequence) {
      vector<boost::any> temp1;
      for(auto item1:*eventSequence){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["EventSequence"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CustomerId") != m.end() && !m["CustomerId"].empty()) {
      customerId = make_shared<string>(boost::any_cast<string>(m["CustomerId"]));
    }
    if (m.find("EventSequence") != m.end() && !m["EventSequence"].empty()) {
      if (typeid(vector<boost::any>) == m["EventSequence"].type()) {
        vector<GetCallDetailRecordResponseBodyDataCustomerEventsEventSequence> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["EventSequence"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetCallDetailRecordResponseBodyDataCustomerEventsEventSequence model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        eventSequence = make_shared<vector<GetCallDetailRecordResponseBodyDataCustomerEventsEventSequence>>(expect1);
      }
    }
  }


  virtual ~GetCallDetailRecordResponseBodyDataCustomerEvents() = default;
};
class GetCallDetailRecordResponseBodyDataIvrEventsEventSequence : public Darabonba::Model {
public:
  shared_ptr<string> event{};
  shared_ptr<long> eventTime{};

  GetCallDetailRecordResponseBodyDataIvrEventsEventSequence() {}

  explicit GetCallDetailRecordResponseBodyDataIvrEventsEventSequence(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (event) {
      res["Event"] = boost::any(*event);
    }
    if (eventTime) {
      res["EventTime"] = boost::any(*eventTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Event") != m.end() && !m["Event"].empty()) {
      event = make_shared<string>(boost::any_cast<string>(m["Event"]));
    }
    if (m.find("EventTime") != m.end() && !m["EventTime"].empty()) {
      eventTime = make_shared<long>(boost::any_cast<long>(m["EventTime"]));
    }
  }


  virtual ~GetCallDetailRecordResponseBodyDataIvrEventsEventSequence() = default;
};
class GetCallDetailRecordResponseBodyDataIvrEvents : public Darabonba::Model {
public:
  shared_ptr<vector<GetCallDetailRecordResponseBodyDataIvrEventsEventSequence>> eventSequence{};
  shared_ptr<string> flowId{};
  shared_ptr<string> flowType{};

  GetCallDetailRecordResponseBodyDataIvrEvents() {}

  explicit GetCallDetailRecordResponseBodyDataIvrEvents(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (eventSequence) {
      vector<boost::any> temp1;
      for(auto item1:*eventSequence){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["EventSequence"] = boost::any(temp1);
    }
    if (flowId) {
      res["FlowId"] = boost::any(*flowId);
    }
    if (flowType) {
      res["FlowType"] = boost::any(*flowType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EventSequence") != m.end() && !m["EventSequence"].empty()) {
      if (typeid(vector<boost::any>) == m["EventSequence"].type()) {
        vector<GetCallDetailRecordResponseBodyDataIvrEventsEventSequence> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["EventSequence"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetCallDetailRecordResponseBodyDataIvrEventsEventSequence model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        eventSequence = make_shared<vector<GetCallDetailRecordResponseBodyDataIvrEventsEventSequence>>(expect1);
      }
    }
    if (m.find("FlowId") != m.end() && !m["FlowId"].empty()) {
      flowId = make_shared<string>(boost::any_cast<string>(m["FlowId"]));
    }
    if (m.find("FlowType") != m.end() && !m["FlowType"].empty()) {
      flowType = make_shared<string>(boost::any_cast<string>(m["FlowType"]));
    }
  }


  virtual ~GetCallDetailRecordResponseBodyDataIvrEvents() = default;
};
class GetCallDetailRecordResponseBodyDataQueueEventsEventSequence : public Darabonba::Model {
public:
  shared_ptr<string> event{};
  shared_ptr<long> eventTime{};

  GetCallDetailRecordResponseBodyDataQueueEventsEventSequence() {}

  explicit GetCallDetailRecordResponseBodyDataQueueEventsEventSequence(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (event) {
      res["Event"] = boost::any(*event);
    }
    if (eventTime) {
      res["EventTime"] = boost::any(*eventTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Event") != m.end() && !m["Event"].empty()) {
      event = make_shared<string>(boost::any_cast<string>(m["Event"]));
    }
    if (m.find("EventTime") != m.end() && !m["EventTime"].empty()) {
      eventTime = make_shared<long>(boost::any_cast<long>(m["EventTime"]));
    }
  }


  virtual ~GetCallDetailRecordResponseBodyDataQueueEventsEventSequence() = default;
};
class GetCallDetailRecordResponseBodyDataQueueEvents : public Darabonba::Model {
public:
  shared_ptr<vector<GetCallDetailRecordResponseBodyDataQueueEventsEventSequence>> eventSequence{};
  shared_ptr<string> flowId{};
  shared_ptr<string> queueId{};
  shared_ptr<string> queueName{};
  shared_ptr<long> queueType{};

  GetCallDetailRecordResponseBodyDataQueueEvents() {}

  explicit GetCallDetailRecordResponseBodyDataQueueEvents(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (eventSequence) {
      vector<boost::any> temp1;
      for(auto item1:*eventSequence){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["EventSequence"] = boost::any(temp1);
    }
    if (flowId) {
      res["FlowId"] = boost::any(*flowId);
    }
    if (queueId) {
      res["QueueId"] = boost::any(*queueId);
    }
    if (queueName) {
      res["QueueName"] = boost::any(*queueName);
    }
    if (queueType) {
      res["QueueType"] = boost::any(*queueType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EventSequence") != m.end() && !m["EventSequence"].empty()) {
      if (typeid(vector<boost::any>) == m["EventSequence"].type()) {
        vector<GetCallDetailRecordResponseBodyDataQueueEventsEventSequence> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["EventSequence"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetCallDetailRecordResponseBodyDataQueueEventsEventSequence model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        eventSequence = make_shared<vector<GetCallDetailRecordResponseBodyDataQueueEventsEventSequence>>(expect1);
      }
    }
    if (m.find("FlowId") != m.end() && !m["FlowId"].empty()) {
      flowId = make_shared<string>(boost::any_cast<string>(m["FlowId"]));
    }
    if (m.find("QueueId") != m.end() && !m["QueueId"].empty()) {
      queueId = make_shared<string>(boost::any_cast<string>(m["QueueId"]));
    }
    if (m.find("QueueName") != m.end() && !m["QueueName"].empty()) {
      queueName = make_shared<string>(boost::any_cast<string>(m["QueueName"]));
    }
    if (m.find("QueueType") != m.end() && !m["QueueType"].empty()) {
      queueType = make_shared<long>(boost::any_cast<long>(m["QueueType"]));
    }
  }


  virtual ~GetCallDetailRecordResponseBodyDataQueueEvents() = default;
};
class GetCallDetailRecordResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<GetCallDetailRecordResponseBodyDataAgentEvents>> agentEvents{};
  shared_ptr<string> agentIds{};
  shared_ptr<string> agentNames{};
  shared_ptr<long> callDuration{};
  shared_ptr<string> calledNumber{};
  shared_ptr<string> calleeLocation{};
  shared_ptr<string> callerLocation{};
  shared_ptr<string> callingNumber{};
  shared_ptr<string> contactDisposition{};
  shared_ptr<string> contactId{};
  shared_ptr<string> contactType{};
  shared_ptr<vector<GetCallDetailRecordResponseBodyDataCustomerEvents>> customerEvents{};
  shared_ptr<string> earlyMediaState{};
  shared_ptr<long> establishedTime{};
  shared_ptr<string> instanceId{};
  shared_ptr<vector<GetCallDetailRecordResponseBodyDataIvrEvents>> ivrEvents{};
  shared_ptr<vector<GetCallDetailRecordResponseBodyDataQueueEvents>> queueEvents{};
  shared_ptr<bool> recordingReady{};
  shared_ptr<string> releaseInitiator{};
  shared_ptr<string> releaseReason{};
  shared_ptr<long> releaseTime{};
  shared_ptr<long> satisfaction{};
  shared_ptr<string> satisfactionSurveyChannel{};
  shared_ptr<bool> satisfactionSurveyOffered{};
  shared_ptr<string> skillGroupIds{};
  shared_ptr<string> skillGroupNames{};
  shared_ptr<long> startTime{};

  GetCallDetailRecordResponseBodyData() {}

  explicit GetCallDetailRecordResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agentEvents) {
      vector<boost::any> temp1;
      for(auto item1:*agentEvents){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AgentEvents"] = boost::any(temp1);
    }
    if (agentIds) {
      res["AgentIds"] = boost::any(*agentIds);
    }
    if (agentNames) {
      res["AgentNames"] = boost::any(*agentNames);
    }
    if (callDuration) {
      res["CallDuration"] = boost::any(*callDuration);
    }
    if (calledNumber) {
      res["CalledNumber"] = boost::any(*calledNumber);
    }
    if (calleeLocation) {
      res["CalleeLocation"] = boost::any(*calleeLocation);
    }
    if (callerLocation) {
      res["CallerLocation"] = boost::any(*callerLocation);
    }
    if (callingNumber) {
      res["CallingNumber"] = boost::any(*callingNumber);
    }
    if (contactDisposition) {
      res["ContactDisposition"] = boost::any(*contactDisposition);
    }
    if (contactId) {
      res["ContactId"] = boost::any(*contactId);
    }
    if (contactType) {
      res["ContactType"] = boost::any(*contactType);
    }
    if (customerEvents) {
      vector<boost::any> temp1;
      for(auto item1:*customerEvents){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CustomerEvents"] = boost::any(temp1);
    }
    if (earlyMediaState) {
      res["EarlyMediaState"] = boost::any(*earlyMediaState);
    }
    if (establishedTime) {
      res["EstablishedTime"] = boost::any(*establishedTime);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (ivrEvents) {
      vector<boost::any> temp1;
      for(auto item1:*ivrEvents){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["IvrEvents"] = boost::any(temp1);
    }
    if (queueEvents) {
      vector<boost::any> temp1;
      for(auto item1:*queueEvents){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["QueueEvents"] = boost::any(temp1);
    }
    if (recordingReady) {
      res["RecordingReady"] = boost::any(*recordingReady);
    }
    if (releaseInitiator) {
      res["ReleaseInitiator"] = boost::any(*releaseInitiator);
    }
    if (releaseReason) {
      res["ReleaseReason"] = boost::any(*releaseReason);
    }
    if (releaseTime) {
      res["ReleaseTime"] = boost::any(*releaseTime);
    }
    if (satisfaction) {
      res["Satisfaction"] = boost::any(*satisfaction);
    }
    if (satisfactionSurveyChannel) {
      res["SatisfactionSurveyChannel"] = boost::any(*satisfactionSurveyChannel);
    }
    if (satisfactionSurveyOffered) {
      res["SatisfactionSurveyOffered"] = boost::any(*satisfactionSurveyOffered);
    }
    if (skillGroupIds) {
      res["SkillGroupIds"] = boost::any(*skillGroupIds);
    }
    if (skillGroupNames) {
      res["SkillGroupNames"] = boost::any(*skillGroupNames);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AgentEvents") != m.end() && !m["AgentEvents"].empty()) {
      if (typeid(vector<boost::any>) == m["AgentEvents"].type()) {
        vector<GetCallDetailRecordResponseBodyDataAgentEvents> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AgentEvents"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetCallDetailRecordResponseBodyDataAgentEvents model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        agentEvents = make_shared<vector<GetCallDetailRecordResponseBodyDataAgentEvents>>(expect1);
      }
    }
    if (m.find("AgentIds") != m.end() && !m["AgentIds"].empty()) {
      agentIds = make_shared<string>(boost::any_cast<string>(m["AgentIds"]));
    }
    if (m.find("AgentNames") != m.end() && !m["AgentNames"].empty()) {
      agentNames = make_shared<string>(boost::any_cast<string>(m["AgentNames"]));
    }
    if (m.find("CallDuration") != m.end() && !m["CallDuration"].empty()) {
      callDuration = make_shared<long>(boost::any_cast<long>(m["CallDuration"]));
    }
    if (m.find("CalledNumber") != m.end() && !m["CalledNumber"].empty()) {
      calledNumber = make_shared<string>(boost::any_cast<string>(m["CalledNumber"]));
    }
    if (m.find("CalleeLocation") != m.end() && !m["CalleeLocation"].empty()) {
      calleeLocation = make_shared<string>(boost::any_cast<string>(m["CalleeLocation"]));
    }
    if (m.find("CallerLocation") != m.end() && !m["CallerLocation"].empty()) {
      callerLocation = make_shared<string>(boost::any_cast<string>(m["CallerLocation"]));
    }
    if (m.find("CallingNumber") != m.end() && !m["CallingNumber"].empty()) {
      callingNumber = make_shared<string>(boost::any_cast<string>(m["CallingNumber"]));
    }
    if (m.find("ContactDisposition") != m.end() && !m["ContactDisposition"].empty()) {
      contactDisposition = make_shared<string>(boost::any_cast<string>(m["ContactDisposition"]));
    }
    if (m.find("ContactId") != m.end() && !m["ContactId"].empty()) {
      contactId = make_shared<string>(boost::any_cast<string>(m["ContactId"]));
    }
    if (m.find("ContactType") != m.end() && !m["ContactType"].empty()) {
      contactType = make_shared<string>(boost::any_cast<string>(m["ContactType"]));
    }
    if (m.find("CustomerEvents") != m.end() && !m["CustomerEvents"].empty()) {
      if (typeid(vector<boost::any>) == m["CustomerEvents"].type()) {
        vector<GetCallDetailRecordResponseBodyDataCustomerEvents> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CustomerEvents"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetCallDetailRecordResponseBodyDataCustomerEvents model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        customerEvents = make_shared<vector<GetCallDetailRecordResponseBodyDataCustomerEvents>>(expect1);
      }
    }
    if (m.find("EarlyMediaState") != m.end() && !m["EarlyMediaState"].empty()) {
      earlyMediaState = make_shared<string>(boost::any_cast<string>(m["EarlyMediaState"]));
    }
    if (m.find("EstablishedTime") != m.end() && !m["EstablishedTime"].empty()) {
      establishedTime = make_shared<long>(boost::any_cast<long>(m["EstablishedTime"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("IvrEvents") != m.end() && !m["IvrEvents"].empty()) {
      if (typeid(vector<boost::any>) == m["IvrEvents"].type()) {
        vector<GetCallDetailRecordResponseBodyDataIvrEvents> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["IvrEvents"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetCallDetailRecordResponseBodyDataIvrEvents model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ivrEvents = make_shared<vector<GetCallDetailRecordResponseBodyDataIvrEvents>>(expect1);
      }
    }
    if (m.find("QueueEvents") != m.end() && !m["QueueEvents"].empty()) {
      if (typeid(vector<boost::any>) == m["QueueEvents"].type()) {
        vector<GetCallDetailRecordResponseBodyDataQueueEvents> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["QueueEvents"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetCallDetailRecordResponseBodyDataQueueEvents model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        queueEvents = make_shared<vector<GetCallDetailRecordResponseBodyDataQueueEvents>>(expect1);
      }
    }
    if (m.find("RecordingReady") != m.end() && !m["RecordingReady"].empty()) {
      recordingReady = make_shared<bool>(boost::any_cast<bool>(m["RecordingReady"]));
    }
    if (m.find("ReleaseInitiator") != m.end() && !m["ReleaseInitiator"].empty()) {
      releaseInitiator = make_shared<string>(boost::any_cast<string>(m["ReleaseInitiator"]));
    }
    if (m.find("ReleaseReason") != m.end() && !m["ReleaseReason"].empty()) {
      releaseReason = make_shared<string>(boost::any_cast<string>(m["ReleaseReason"]));
    }
    if (m.find("ReleaseTime") != m.end() && !m["ReleaseTime"].empty()) {
      releaseTime = make_shared<long>(boost::any_cast<long>(m["ReleaseTime"]));
    }
    if (m.find("Satisfaction") != m.end() && !m["Satisfaction"].empty()) {
      satisfaction = make_shared<long>(boost::any_cast<long>(m["Satisfaction"]));
    }
    if (m.find("SatisfactionSurveyChannel") != m.end() && !m["SatisfactionSurveyChannel"].empty()) {
      satisfactionSurveyChannel = make_shared<string>(boost::any_cast<string>(m["SatisfactionSurveyChannel"]));
    }
    if (m.find("SatisfactionSurveyOffered") != m.end() && !m["SatisfactionSurveyOffered"].empty()) {
      satisfactionSurveyOffered = make_shared<bool>(boost::any_cast<bool>(m["SatisfactionSurveyOffered"]));
    }
    if (m.find("SkillGroupIds") != m.end() && !m["SkillGroupIds"].empty()) {
      skillGroupIds = make_shared<string>(boost::any_cast<string>(m["SkillGroupIds"]));
    }
    if (m.find("SkillGroupNames") != m.end() && !m["SkillGroupNames"].empty()) {
      skillGroupNames = make_shared<string>(boost::any_cast<string>(m["SkillGroupNames"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
  }


  virtual ~GetCallDetailRecordResponseBodyData() = default;
};
class GetCallDetailRecordResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<GetCallDetailRecordResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  GetCallDetailRecordResponseBody() {}

  explicit GetCallDetailRecordResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetCallDetailRecordResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetCallDetailRecordResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetCallDetailRecordResponseBody() = default;
};
class GetCallDetailRecordResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetCallDetailRecordResponseBody> body{};

  GetCallDetailRecordResponse() {}

  explicit GetCallDetailRecordResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetCallDetailRecordResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetCallDetailRecordResponseBody>(model1);
      }
    }
  }


  virtual ~GetCallDetailRecordResponse() = default;
};
class GetCampaignRequest : public Darabonba::Model {
public:
  shared_ptr<string> campaignId{};
  shared_ptr<string> instanceId{};

  GetCampaignRequest() {}

  explicit GetCampaignRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (campaignId) {
      res["CampaignId"] = boost::any(*campaignId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CampaignId") != m.end() && !m["CampaignId"].empty()) {
      campaignId = make_shared<string>(boost::any_cast<string>(m["CampaignId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~GetCampaignRequest() = default;
};
class GetCampaignResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> actualEndTime{};
  shared_ptr<long> actualStartTime{};
  shared_ptr<string> campaignId{};
  shared_ptr<long> casesAborted{};
  shared_ptr<long> casesConnected{};
  shared_ptr<long> casesUncompleted{};
  shared_ptr<long> casesUncompletedAfterAttempted{};
  shared_ptr<long> maxAttemptCount{};
  shared_ptr<long> minAttemptInterval{};
  shared_ptr<string> name{};
  shared_ptr<long> planedEndTime{};
  shared_ptr<long> planedStartTime{};
  shared_ptr<string> queueId{};
  shared_ptr<string> queueName{};
  shared_ptr<bool> simulation{};
  shared_ptr<string> simulationParameters{};
  shared_ptr<string> state{};
  shared_ptr<string> strategyParameters{};
  shared_ptr<string> strategyType{};
  shared_ptr<long> totalCases{};

  GetCampaignResponseBodyData() {}

  explicit GetCampaignResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (actualEndTime) {
      res["ActualEndTime"] = boost::any(*actualEndTime);
    }
    if (actualStartTime) {
      res["ActualStartTime"] = boost::any(*actualStartTime);
    }
    if (campaignId) {
      res["CampaignId"] = boost::any(*campaignId);
    }
    if (casesAborted) {
      res["CasesAborted"] = boost::any(*casesAborted);
    }
    if (casesConnected) {
      res["CasesConnected"] = boost::any(*casesConnected);
    }
    if (casesUncompleted) {
      res["CasesUncompleted"] = boost::any(*casesUncompleted);
    }
    if (casesUncompletedAfterAttempted) {
      res["CasesUncompletedAfterAttempted"] = boost::any(*casesUncompletedAfterAttempted);
    }
    if (maxAttemptCount) {
      res["MaxAttemptCount"] = boost::any(*maxAttemptCount);
    }
    if (minAttemptInterval) {
      res["MinAttemptInterval"] = boost::any(*minAttemptInterval);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (planedEndTime) {
      res["PlanedEndTime"] = boost::any(*planedEndTime);
    }
    if (planedStartTime) {
      res["PlanedStartTime"] = boost::any(*planedStartTime);
    }
    if (queueId) {
      res["QueueId"] = boost::any(*queueId);
    }
    if (queueName) {
      res["QueueName"] = boost::any(*queueName);
    }
    if (simulation) {
      res["Simulation"] = boost::any(*simulation);
    }
    if (simulationParameters) {
      res["SimulationParameters"] = boost::any(*simulationParameters);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (strategyParameters) {
      res["StrategyParameters"] = boost::any(*strategyParameters);
    }
    if (strategyType) {
      res["StrategyType"] = boost::any(*strategyType);
    }
    if (totalCases) {
      res["TotalCases"] = boost::any(*totalCases);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ActualEndTime") != m.end() && !m["ActualEndTime"].empty()) {
      actualEndTime = make_shared<long>(boost::any_cast<long>(m["ActualEndTime"]));
    }
    if (m.find("ActualStartTime") != m.end() && !m["ActualStartTime"].empty()) {
      actualStartTime = make_shared<long>(boost::any_cast<long>(m["ActualStartTime"]));
    }
    if (m.find("CampaignId") != m.end() && !m["CampaignId"].empty()) {
      campaignId = make_shared<string>(boost::any_cast<string>(m["CampaignId"]));
    }
    if (m.find("CasesAborted") != m.end() && !m["CasesAborted"].empty()) {
      casesAborted = make_shared<long>(boost::any_cast<long>(m["CasesAborted"]));
    }
    if (m.find("CasesConnected") != m.end() && !m["CasesConnected"].empty()) {
      casesConnected = make_shared<long>(boost::any_cast<long>(m["CasesConnected"]));
    }
    if (m.find("CasesUncompleted") != m.end() && !m["CasesUncompleted"].empty()) {
      casesUncompleted = make_shared<long>(boost::any_cast<long>(m["CasesUncompleted"]));
    }
    if (m.find("CasesUncompletedAfterAttempted") != m.end() && !m["CasesUncompletedAfterAttempted"].empty()) {
      casesUncompletedAfterAttempted = make_shared<long>(boost::any_cast<long>(m["CasesUncompletedAfterAttempted"]));
    }
    if (m.find("MaxAttemptCount") != m.end() && !m["MaxAttemptCount"].empty()) {
      maxAttemptCount = make_shared<long>(boost::any_cast<long>(m["MaxAttemptCount"]));
    }
    if (m.find("MinAttemptInterval") != m.end() && !m["MinAttemptInterval"].empty()) {
      minAttemptInterval = make_shared<long>(boost::any_cast<long>(m["MinAttemptInterval"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("PlanedEndTime") != m.end() && !m["PlanedEndTime"].empty()) {
      planedEndTime = make_shared<long>(boost::any_cast<long>(m["PlanedEndTime"]));
    }
    if (m.find("PlanedStartTime") != m.end() && !m["PlanedStartTime"].empty()) {
      planedStartTime = make_shared<long>(boost::any_cast<long>(m["PlanedStartTime"]));
    }
    if (m.find("QueueId") != m.end() && !m["QueueId"].empty()) {
      queueId = make_shared<string>(boost::any_cast<string>(m["QueueId"]));
    }
    if (m.find("QueueName") != m.end() && !m["QueueName"].empty()) {
      queueName = make_shared<string>(boost::any_cast<string>(m["QueueName"]));
    }
    if (m.find("Simulation") != m.end() && !m["Simulation"].empty()) {
      simulation = make_shared<bool>(boost::any_cast<bool>(m["Simulation"]));
    }
    if (m.find("SimulationParameters") != m.end() && !m["SimulationParameters"].empty()) {
      simulationParameters = make_shared<string>(boost::any_cast<string>(m["SimulationParameters"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("StrategyParameters") != m.end() && !m["StrategyParameters"].empty()) {
      strategyParameters = make_shared<string>(boost::any_cast<string>(m["StrategyParameters"]));
    }
    if (m.find("StrategyType") != m.end() && !m["StrategyType"].empty()) {
      strategyType = make_shared<string>(boost::any_cast<string>(m["StrategyType"]));
    }
    if (m.find("TotalCases") != m.end() && !m["TotalCases"].empty()) {
      totalCases = make_shared<long>(boost::any_cast<long>(m["TotalCases"]));
    }
  }


  virtual ~GetCampaignResponseBodyData() = default;
};
class GetCampaignResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<GetCampaignResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> requestId{};

  GetCampaignResponseBody() {}

  explicit GetCampaignResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetCampaignResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetCampaignResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetCampaignResponseBody() = default;
};
class GetCampaignResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetCampaignResponseBody> body{};

  GetCampaignResponse() {}

  explicit GetCampaignResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetCampaignResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetCampaignResponseBody>(model1);
      }
    }
  }


  virtual ~GetCampaignResponse() = default;
};
class GetCaseFileUploadUrlRequest : public Darabonba::Model {
public:
  shared_ptr<string> fileName{};
  shared_ptr<string> instanceId{};

  GetCaseFileUploadUrlRequest() {}

  explicit GetCaseFileUploadUrlRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fileName) {
      res["FileName"] = boost::any(*fileName);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FileName") != m.end() && !m["FileName"].empty()) {
      fileName = make_shared<string>(boost::any_cast<string>(m["FileName"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~GetCaseFileUploadUrlRequest() = default;
};
class GetCaseFileUploadUrlResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> caseFileKey{};
  shared_ptr<string> url{};

  GetCaseFileUploadUrlResponseBodyData() {}

  explicit GetCaseFileUploadUrlResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (caseFileKey) {
      res["CaseFileKey"] = boost::any(*caseFileKey);
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CaseFileKey") != m.end() && !m["CaseFileKey"].empty()) {
      caseFileKey = make_shared<string>(boost::any_cast<string>(m["CaseFileKey"]));
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
  }


  virtual ~GetCaseFileUploadUrlResponseBodyData() = default;
};
class GetCaseFileUploadUrlResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<GetCaseFileUploadUrlResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  GetCaseFileUploadUrlResponseBody() {}

  explicit GetCaseFileUploadUrlResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetCaseFileUploadUrlResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetCaseFileUploadUrlResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetCaseFileUploadUrlResponseBody() = default;
};
class GetCaseFileUploadUrlResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetCaseFileUploadUrlResponseBody> body{};

  GetCaseFileUploadUrlResponse() {}

  explicit GetCaseFileUploadUrlResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetCaseFileUploadUrlResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetCaseFileUploadUrlResponseBody>(model1);
      }
    }
  }


  virtual ~GetCaseFileUploadUrlResponse() = default;
};
class GetConversationDetailRequest : public Darabonba::Model {
public:
  shared_ptr<string> contactId{};
  shared_ptr<string> instanceId{};

  GetConversationDetailRequest() {}

  explicit GetConversationDetailRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contactId) {
      res["ContactId"] = boost::any(*contactId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ContactId") != m.end() && !m["ContactId"].empty()) {
      contactId = make_shared<string>(boost::any_cast<string>(m["ContactId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~GetConversationDetailRequest() = default;
};
class GetConversationDetailResponseBodyPhrases : public Darabonba::Model {
public:
  shared_ptr<long> begin{};
  shared_ptr<long> end{};
  shared_ptr<string> identity{};
  shared_ptr<string> role{};
  shared_ptr<string> words{};

  GetConversationDetailResponseBodyPhrases() {}

  explicit GetConversationDetailResponseBodyPhrases(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (begin) {
      res["Begin"] = boost::any(*begin);
    }
    if (end) {
      res["End"] = boost::any(*end);
    }
    if (identity) {
      res["Identity"] = boost::any(*identity);
    }
    if (role) {
      res["Role"] = boost::any(*role);
    }
    if (words) {
      res["Words"] = boost::any(*words);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Begin") != m.end() && !m["Begin"].empty()) {
      begin = make_shared<long>(boost::any_cast<long>(m["Begin"]));
    }
    if (m.find("End") != m.end() && !m["End"].empty()) {
      end = make_shared<long>(boost::any_cast<long>(m["End"]));
    }
    if (m.find("Identity") != m.end() && !m["Identity"].empty()) {
      identity = make_shared<string>(boost::any_cast<string>(m["Identity"]));
    }
    if (m.find("Role") != m.end() && !m["Role"].empty()) {
      role = make_shared<string>(boost::any_cast<string>(m["Role"]));
    }
    if (m.find("Words") != m.end() && !m["Words"].empty()) {
      words = make_shared<string>(boost::any_cast<string>(m["Words"]));
    }
  }


  virtual ~GetConversationDetailResponseBodyPhrases() = default;
};
class GetConversationDetailResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<vector<GetConversationDetailResponseBodyPhrases>> phrases{};
  shared_ptr<string> requestId{};

  GetConversationDetailResponseBody() {}

  explicit GetConversationDetailResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (phrases) {
      vector<boost::any> temp1;
      for(auto item1:*phrases){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Phrases"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Phrases") != m.end() && !m["Phrases"].empty()) {
      if (typeid(vector<boost::any>) == m["Phrases"].type()) {
        vector<GetConversationDetailResponseBodyPhrases> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Phrases"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetConversationDetailResponseBodyPhrases model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        phrases = make_shared<vector<GetConversationDetailResponseBodyPhrases>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetConversationDetailResponseBody() = default;
};
class GetConversationDetailResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetConversationDetailResponseBody> body{};

  GetConversationDetailResponse() {}

  explicit GetConversationDetailResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetConversationDetailResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetConversationDetailResponseBody>(model1);
      }
    }
  }


  virtual ~GetConversationDetailResponse() = default;
};
class GetDoNotCallFileUploadParametersRequest : public Darabonba::Model {
public:
  shared_ptr<string> fileName{};
  shared_ptr<string> instanceId{};

  GetDoNotCallFileUploadParametersRequest() {}

  explicit GetDoNotCallFileUploadParametersRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fileName) {
      res["FileName"] = boost::any(*fileName);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FileName") != m.end() && !m["FileName"].empty()) {
      fileName = make_shared<string>(boost::any_cast<string>(m["FileName"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~GetDoNotCallFileUploadParametersRequest() = default;
};
class GetDoNotCallFileUploadParametersResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> accessKeyId{};
  shared_ptr<long> expireTime{};
  shared_ptr<string> filePath{};
  shared_ptr<string> host{};
  shared_ptr<string> policy{};
  shared_ptr<string> signature{};

  GetDoNotCallFileUploadParametersResponseBodyData() {}

  explicit GetDoNotCallFileUploadParametersResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessKeyId) {
      res["AccessKeyId"] = boost::any(*accessKeyId);
    }
    if (expireTime) {
      res["ExpireTime"] = boost::any(*expireTime);
    }
    if (filePath) {
      res["FilePath"] = boost::any(*filePath);
    }
    if (host) {
      res["Host"] = boost::any(*host);
    }
    if (policy) {
      res["Policy"] = boost::any(*policy);
    }
    if (signature) {
      res["Signature"] = boost::any(*signature);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccessKeyId") != m.end() && !m["AccessKeyId"].empty()) {
      accessKeyId = make_shared<string>(boost::any_cast<string>(m["AccessKeyId"]));
    }
    if (m.find("ExpireTime") != m.end() && !m["ExpireTime"].empty()) {
      expireTime = make_shared<long>(boost::any_cast<long>(m["ExpireTime"]));
    }
    if (m.find("FilePath") != m.end() && !m["FilePath"].empty()) {
      filePath = make_shared<string>(boost::any_cast<string>(m["FilePath"]));
    }
    if (m.find("Host") != m.end() && !m["Host"].empty()) {
      host = make_shared<string>(boost::any_cast<string>(m["Host"]));
    }
    if (m.find("Policy") != m.end() && !m["Policy"].empty()) {
      policy = make_shared<string>(boost::any_cast<string>(m["Policy"]));
    }
    if (m.find("Signature") != m.end() && !m["Signature"].empty()) {
      signature = make_shared<string>(boost::any_cast<string>(m["Signature"]));
    }
  }


  virtual ~GetDoNotCallFileUploadParametersResponseBodyData() = default;
};
class GetDoNotCallFileUploadParametersResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<GetDoNotCallFileUploadParametersResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GetDoNotCallFileUploadParametersResponseBody() {}

  explicit GetDoNotCallFileUploadParametersResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetDoNotCallFileUploadParametersResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetDoNotCallFileUploadParametersResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetDoNotCallFileUploadParametersResponseBody() = default;
};
class GetDoNotCallFileUploadParametersResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetDoNotCallFileUploadParametersResponseBody> body{};

  GetDoNotCallFileUploadParametersResponse() {}

  explicit GetDoNotCallFileUploadParametersResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetDoNotCallFileUploadParametersResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetDoNotCallFileUploadParametersResponseBody>(model1);
      }
    }
  }


  virtual ~GetDoNotCallFileUploadParametersResponse() = default;
};
class GetHistoricalCallerReportRequest : public Darabonba::Model {
public:
  shared_ptr<string> callingNumber{};
  shared_ptr<string> instanceId{};
  shared_ptr<long> startTime{};
  shared_ptr<long> stopTime{};

  GetHistoricalCallerReportRequest() {}

  explicit GetHistoricalCallerReportRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callingNumber) {
      res["CallingNumber"] = boost::any(*callingNumber);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (stopTime) {
      res["StopTime"] = boost::any(*stopTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallingNumber") != m.end() && !m["CallingNumber"].empty()) {
      callingNumber = make_shared<string>(boost::any_cast<string>(m["CallingNumber"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("StopTime") != m.end() && !m["StopTime"].empty()) {
      stopTime = make_shared<long>(boost::any_cast<long>(m["StopTime"]));
    }
  }


  virtual ~GetHistoricalCallerReportRequest() = default;
};
class GetHistoricalCallerReportResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> lastCallingTime{};
  shared_ptr<long> totalCalls{};

  GetHistoricalCallerReportResponseBodyData() {}

  explicit GetHistoricalCallerReportResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lastCallingTime) {
      res["LastCallingTime"] = boost::any(*lastCallingTime);
    }
    if (totalCalls) {
      res["TotalCalls"] = boost::any(*totalCalls);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LastCallingTime") != m.end() && !m["LastCallingTime"].empty()) {
      lastCallingTime = make_shared<long>(boost::any_cast<long>(m["LastCallingTime"]));
    }
    if (m.find("TotalCalls") != m.end() && !m["TotalCalls"].empty()) {
      totalCalls = make_shared<long>(boost::any_cast<long>(m["TotalCalls"]));
    }
  }


  virtual ~GetHistoricalCallerReportResponseBodyData() = default;
};
class GetHistoricalCallerReportResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<GetHistoricalCallerReportResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  GetHistoricalCallerReportResponseBody() {}

  explicit GetHistoricalCallerReportResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetHistoricalCallerReportResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetHistoricalCallerReportResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetHistoricalCallerReportResponseBody() = default;
};
class GetHistoricalCallerReportResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetHistoricalCallerReportResponseBody> body{};

  GetHistoricalCallerReportResponse() {}

  explicit GetHistoricalCallerReportResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetHistoricalCallerReportResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetHistoricalCallerReportResponseBody>(model1);
      }
    }
  }


  virtual ~GetHistoricalCallerReportResponse() = default;
};
class GetHistoricalCampaignReportRequest : public Darabonba::Model {
public:
  shared_ptr<string> campaignId{};
  shared_ptr<string> instanceId{};

  GetHistoricalCampaignReportRequest() {}

  explicit GetHistoricalCampaignReportRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (campaignId) {
      res["CampaignId"] = boost::any(*campaignId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CampaignId") != m.end() && !m["CampaignId"].empty()) {
      campaignId = make_shared<string>(boost::any_cast<string>(m["CampaignId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~GetHistoricalCampaignReportRequest() = default;
};
class GetHistoricalCampaignReportResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<double> abandonedRate{};
  shared_ptr<long> callsAbandoned{};
  shared_ptr<long> callsConnected{};
  shared_ptr<long> callsDialed{};
  shared_ptr<double> connectedRate{};
  shared_ptr<double> occupancyRate{};

  GetHistoricalCampaignReportResponseBodyData() {}

  explicit GetHistoricalCampaignReportResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (abandonedRate) {
      res["AbandonedRate"] = boost::any(*abandonedRate);
    }
    if (callsAbandoned) {
      res["CallsAbandoned"] = boost::any(*callsAbandoned);
    }
    if (callsConnected) {
      res["CallsConnected"] = boost::any(*callsConnected);
    }
    if (callsDialed) {
      res["CallsDialed"] = boost::any(*callsDialed);
    }
    if (connectedRate) {
      res["ConnectedRate"] = boost::any(*connectedRate);
    }
    if (occupancyRate) {
      res["OccupancyRate"] = boost::any(*occupancyRate);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AbandonedRate") != m.end() && !m["AbandonedRate"].empty()) {
      abandonedRate = make_shared<double>(boost::any_cast<double>(m["AbandonedRate"]));
    }
    if (m.find("CallsAbandoned") != m.end() && !m["CallsAbandoned"].empty()) {
      callsAbandoned = make_shared<long>(boost::any_cast<long>(m["CallsAbandoned"]));
    }
    if (m.find("CallsConnected") != m.end() && !m["CallsConnected"].empty()) {
      callsConnected = make_shared<long>(boost::any_cast<long>(m["CallsConnected"]));
    }
    if (m.find("CallsDialed") != m.end() && !m["CallsDialed"].empty()) {
      callsDialed = make_shared<long>(boost::any_cast<long>(m["CallsDialed"]));
    }
    if (m.find("ConnectedRate") != m.end() && !m["ConnectedRate"].empty()) {
      connectedRate = make_shared<double>(boost::any_cast<double>(m["ConnectedRate"]));
    }
    if (m.find("OccupancyRate") != m.end() && !m["OccupancyRate"].empty()) {
      occupancyRate = make_shared<double>(boost::any_cast<double>(m["OccupancyRate"]));
    }
  }


  virtual ~GetHistoricalCampaignReportResponseBodyData() = default;
};
class GetHistoricalCampaignReportResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<GetHistoricalCampaignReportResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  GetHistoricalCampaignReportResponseBody() {}

  explicit GetHistoricalCampaignReportResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetHistoricalCampaignReportResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetHistoricalCampaignReportResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetHistoricalCampaignReportResponseBody() = default;
};
class GetHistoricalCampaignReportResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetHistoricalCampaignReportResponseBody> body{};

  GetHistoricalCampaignReportResponse() {}

  explicit GetHistoricalCampaignReportResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetHistoricalCampaignReportResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetHistoricalCampaignReportResponseBody>(model1);
      }
    }
  }


  virtual ~GetHistoricalCampaignReportResponse() = default;
};
class GetHistoricalInstanceReportRequest : public Darabonba::Model {
public:
  shared_ptr<long> endTime{};
  shared_ptr<string> instanceId{};
  shared_ptr<long> startTime{};

  GetHistoricalInstanceReportRequest() {}

  explicit GetHistoricalInstanceReportRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
  }


  virtual ~GetHistoricalInstanceReportRequest() = default;
};
class GetHistoricalInstanceReportResponseBodyDataInbound : public Darabonba::Model {
public:
  shared_ptr<double> abandonRate{};
  shared_ptr<double> averageAbandonTime{};
  shared_ptr<double> averageAbandonedInIVRTime{};
  shared_ptr<double> averageAbandonedInQueueTime{};
  shared_ptr<double> averageAbandonedInRingTime{};
  shared_ptr<double> averageHoldTime{};
  shared_ptr<double> averageRingTime{};
  shared_ptr<double> averageTalkTime{};
  shared_ptr<double> averageWaitTime{};
  shared_ptr<double> averageWorkTime{};
  shared_ptr<long> callsAbandoned{};
  shared_ptr<long> callsAbandonedInIVR{};
  shared_ptr<long> callsAbandonedInQueue{};
  shared_ptr<long> callsAbandonedInRing{};
  shared_ptr<long> callsAbandonedInVoiceNavigator{};
  shared_ptr<long> callsAttendedTransferred{};
  shared_ptr<long> callsBlindTransferred{};
  shared_ptr<long> callsForwardToOutsideNumber{};
  shared_ptr<long> callsHandled{};
  shared_ptr<long> callsHold{};
  shared_ptr<long> callsIVRException{};
  shared_ptr<long> callsOffered{};
  shared_ptr<long> callsQueued{};
  shared_ptr<long> callsQueuingFailed{};
  shared_ptr<long> callsQueuingOverflow{};
  shared_ptr<long> callsQueuingTimeout{};
  shared_ptr<long> callsRinged{};
  shared_ptr<long> callsVoicemail{};
  shared_ptr<double> handleRate{};
  shared_ptr<long> maxAbandonTime{};
  shared_ptr<long> maxAbandonedInIVRTime{};
  shared_ptr<long> maxAbandonedInQueueTime{};
  shared_ptr<long> maxAbandonedInRingTime{};
  shared_ptr<long> maxHoldTime{};
  shared_ptr<long> maxRingTime{};
  shared_ptr<long> maxTalkTime{};
  shared_ptr<long> maxWaitTime{};
  shared_ptr<long> maxWorkTime{};
  shared_ptr<double> satisfactionIndex{};
  shared_ptr<double> satisfactionRate{};
  shared_ptr<long> satisfactionSurveysOffered{};
  shared_ptr<long> satisfactionSurveysResponded{};
  shared_ptr<double> serviceLevel20{};
  shared_ptr<long> totalAbandonTime{};
  shared_ptr<long> totalAbandonedInIVRTime{};
  shared_ptr<long> totalAbandonedInQueueTime{};
  shared_ptr<long> totalAbandonedInRingTime{};
  shared_ptr<long> totalHoldTime{};
  shared_ptr<long> totalRingTime{};
  shared_ptr<long> totalTalkTime{};
  shared_ptr<long> totalWaitTime{};
  shared_ptr<long> totalWorkTime{};

  GetHistoricalInstanceReportResponseBodyDataInbound() {}

  explicit GetHistoricalInstanceReportResponseBodyDataInbound(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (abandonRate) {
      res["AbandonRate"] = boost::any(*abandonRate);
    }
    if (averageAbandonTime) {
      res["AverageAbandonTime"] = boost::any(*averageAbandonTime);
    }
    if (averageAbandonedInIVRTime) {
      res["AverageAbandonedInIVRTime"] = boost::any(*averageAbandonedInIVRTime);
    }
    if (averageAbandonedInQueueTime) {
      res["AverageAbandonedInQueueTime"] = boost::any(*averageAbandonedInQueueTime);
    }
    if (averageAbandonedInRingTime) {
      res["AverageAbandonedInRingTime"] = boost::any(*averageAbandonedInRingTime);
    }
    if (averageHoldTime) {
      res["AverageHoldTime"] = boost::any(*averageHoldTime);
    }
    if (averageRingTime) {
      res["AverageRingTime"] = boost::any(*averageRingTime);
    }
    if (averageTalkTime) {
      res["AverageTalkTime"] = boost::any(*averageTalkTime);
    }
    if (averageWaitTime) {
      res["AverageWaitTime"] = boost::any(*averageWaitTime);
    }
    if (averageWorkTime) {
      res["AverageWorkTime"] = boost::any(*averageWorkTime);
    }
    if (callsAbandoned) {
      res["CallsAbandoned"] = boost::any(*callsAbandoned);
    }
    if (callsAbandonedInIVR) {
      res["CallsAbandonedInIVR"] = boost::any(*callsAbandonedInIVR);
    }
    if (callsAbandonedInQueue) {
      res["CallsAbandonedInQueue"] = boost::any(*callsAbandonedInQueue);
    }
    if (callsAbandonedInRing) {
      res["CallsAbandonedInRing"] = boost::any(*callsAbandonedInRing);
    }
    if (callsAbandonedInVoiceNavigator) {
      res["CallsAbandonedInVoiceNavigator"] = boost::any(*callsAbandonedInVoiceNavigator);
    }
    if (callsAttendedTransferred) {
      res["CallsAttendedTransferred"] = boost::any(*callsAttendedTransferred);
    }
    if (callsBlindTransferred) {
      res["CallsBlindTransferred"] = boost::any(*callsBlindTransferred);
    }
    if (callsForwardToOutsideNumber) {
      res["CallsForwardToOutsideNumber"] = boost::any(*callsForwardToOutsideNumber);
    }
    if (callsHandled) {
      res["CallsHandled"] = boost::any(*callsHandled);
    }
    if (callsHold) {
      res["CallsHold"] = boost::any(*callsHold);
    }
    if (callsIVRException) {
      res["CallsIVRException"] = boost::any(*callsIVRException);
    }
    if (callsOffered) {
      res["CallsOffered"] = boost::any(*callsOffered);
    }
    if (callsQueued) {
      res["CallsQueued"] = boost::any(*callsQueued);
    }
    if (callsQueuingFailed) {
      res["CallsQueuingFailed"] = boost::any(*callsQueuingFailed);
    }
    if (callsQueuingOverflow) {
      res["CallsQueuingOverflow"] = boost::any(*callsQueuingOverflow);
    }
    if (callsQueuingTimeout) {
      res["CallsQueuingTimeout"] = boost::any(*callsQueuingTimeout);
    }
    if (callsRinged) {
      res["CallsRinged"] = boost::any(*callsRinged);
    }
    if (callsVoicemail) {
      res["CallsVoicemail"] = boost::any(*callsVoicemail);
    }
    if (handleRate) {
      res["HandleRate"] = boost::any(*handleRate);
    }
    if (maxAbandonTime) {
      res["MaxAbandonTime"] = boost::any(*maxAbandonTime);
    }
    if (maxAbandonedInIVRTime) {
      res["MaxAbandonedInIVRTime"] = boost::any(*maxAbandonedInIVRTime);
    }
    if (maxAbandonedInQueueTime) {
      res["MaxAbandonedInQueueTime"] = boost::any(*maxAbandonedInQueueTime);
    }
    if (maxAbandonedInRingTime) {
      res["MaxAbandonedInRingTime"] = boost::any(*maxAbandonedInRingTime);
    }
    if (maxHoldTime) {
      res["MaxHoldTime"] = boost::any(*maxHoldTime);
    }
    if (maxRingTime) {
      res["MaxRingTime"] = boost::any(*maxRingTime);
    }
    if (maxTalkTime) {
      res["MaxTalkTime"] = boost::any(*maxTalkTime);
    }
    if (maxWaitTime) {
      res["MaxWaitTime"] = boost::any(*maxWaitTime);
    }
    if (maxWorkTime) {
      res["MaxWorkTime"] = boost::any(*maxWorkTime);
    }
    if (satisfactionIndex) {
      res["SatisfactionIndex"] = boost::any(*satisfactionIndex);
    }
    if (satisfactionRate) {
      res["SatisfactionRate"] = boost::any(*satisfactionRate);
    }
    if (satisfactionSurveysOffered) {
      res["SatisfactionSurveysOffered"] = boost::any(*satisfactionSurveysOffered);
    }
    if (satisfactionSurveysResponded) {
      res["SatisfactionSurveysResponded"] = boost::any(*satisfactionSurveysResponded);
    }
    if (serviceLevel20) {
      res["ServiceLevel20"] = boost::any(*serviceLevel20);
    }
    if (totalAbandonTime) {
      res["TotalAbandonTime"] = boost::any(*totalAbandonTime);
    }
    if (totalAbandonedInIVRTime) {
      res["TotalAbandonedInIVRTime"] = boost::any(*totalAbandonedInIVRTime);
    }
    if (totalAbandonedInQueueTime) {
      res["TotalAbandonedInQueueTime"] = boost::any(*totalAbandonedInQueueTime);
    }
    if (totalAbandonedInRingTime) {
      res["TotalAbandonedInRingTime"] = boost::any(*totalAbandonedInRingTime);
    }
    if (totalHoldTime) {
      res["TotalHoldTime"] = boost::any(*totalHoldTime);
    }
    if (totalRingTime) {
      res["TotalRingTime"] = boost::any(*totalRingTime);
    }
    if (totalTalkTime) {
      res["TotalTalkTime"] = boost::any(*totalTalkTime);
    }
    if (totalWaitTime) {
      res["TotalWaitTime"] = boost::any(*totalWaitTime);
    }
    if (totalWorkTime) {
      res["TotalWorkTime"] = boost::any(*totalWorkTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AbandonRate") != m.end() && !m["AbandonRate"].empty()) {
      abandonRate = make_shared<double>(boost::any_cast<double>(m["AbandonRate"]));
    }
    if (m.find("AverageAbandonTime") != m.end() && !m["AverageAbandonTime"].empty()) {
      averageAbandonTime = make_shared<double>(boost::any_cast<double>(m["AverageAbandonTime"]));
    }
    if (m.find("AverageAbandonedInIVRTime") != m.end() && !m["AverageAbandonedInIVRTime"].empty()) {
      averageAbandonedInIVRTime = make_shared<double>(boost::any_cast<double>(m["AverageAbandonedInIVRTime"]));
    }
    if (m.find("AverageAbandonedInQueueTime") != m.end() && !m["AverageAbandonedInQueueTime"].empty()) {
      averageAbandonedInQueueTime = make_shared<double>(boost::any_cast<double>(m["AverageAbandonedInQueueTime"]));
    }
    if (m.find("AverageAbandonedInRingTime") != m.end() && !m["AverageAbandonedInRingTime"].empty()) {
      averageAbandonedInRingTime = make_shared<double>(boost::any_cast<double>(m["AverageAbandonedInRingTime"]));
    }
    if (m.find("AverageHoldTime") != m.end() && !m["AverageHoldTime"].empty()) {
      averageHoldTime = make_shared<double>(boost::any_cast<double>(m["AverageHoldTime"]));
    }
    if (m.find("AverageRingTime") != m.end() && !m["AverageRingTime"].empty()) {
      averageRingTime = make_shared<double>(boost::any_cast<double>(m["AverageRingTime"]));
    }
    if (m.find("AverageTalkTime") != m.end() && !m["AverageTalkTime"].empty()) {
      averageTalkTime = make_shared<double>(boost::any_cast<double>(m["AverageTalkTime"]));
    }
    if (m.find("AverageWaitTime") != m.end() && !m["AverageWaitTime"].empty()) {
      averageWaitTime = make_shared<double>(boost::any_cast<double>(m["AverageWaitTime"]));
    }
    if (m.find("AverageWorkTime") != m.end() && !m["AverageWorkTime"].empty()) {
      averageWorkTime = make_shared<double>(boost::any_cast<double>(m["AverageWorkTime"]));
    }
    if (m.find("CallsAbandoned") != m.end() && !m["CallsAbandoned"].empty()) {
      callsAbandoned = make_shared<long>(boost::any_cast<long>(m["CallsAbandoned"]));
    }
    if (m.find("CallsAbandonedInIVR") != m.end() && !m["CallsAbandonedInIVR"].empty()) {
      callsAbandonedInIVR = make_shared<long>(boost::any_cast<long>(m["CallsAbandonedInIVR"]));
    }
    if (m.find("CallsAbandonedInQueue") != m.end() && !m["CallsAbandonedInQueue"].empty()) {
      callsAbandonedInQueue = make_shared<long>(boost::any_cast<long>(m["CallsAbandonedInQueue"]));
    }
    if (m.find("CallsAbandonedInRing") != m.end() && !m["CallsAbandonedInRing"].empty()) {
      callsAbandonedInRing = make_shared<long>(boost::any_cast<long>(m["CallsAbandonedInRing"]));
    }
    if (m.find("CallsAbandonedInVoiceNavigator") != m.end() && !m["CallsAbandonedInVoiceNavigator"].empty()) {
      callsAbandonedInVoiceNavigator = make_shared<long>(boost::any_cast<long>(m["CallsAbandonedInVoiceNavigator"]));
    }
    if (m.find("CallsAttendedTransferred") != m.end() && !m["CallsAttendedTransferred"].empty()) {
      callsAttendedTransferred = make_shared<long>(boost::any_cast<long>(m["CallsAttendedTransferred"]));
    }
    if (m.find("CallsBlindTransferred") != m.end() && !m["CallsBlindTransferred"].empty()) {
      callsBlindTransferred = make_shared<long>(boost::any_cast<long>(m["CallsBlindTransferred"]));
    }
    if (m.find("CallsForwardToOutsideNumber") != m.end() && !m["CallsForwardToOutsideNumber"].empty()) {
      callsForwardToOutsideNumber = make_shared<long>(boost::any_cast<long>(m["CallsForwardToOutsideNumber"]));
    }
    if (m.find("CallsHandled") != m.end() && !m["CallsHandled"].empty()) {
      callsHandled = make_shared<long>(boost::any_cast<long>(m["CallsHandled"]));
    }
    if (m.find("CallsHold") != m.end() && !m["CallsHold"].empty()) {
      callsHold = make_shared<long>(boost::any_cast<long>(m["CallsHold"]));
    }
    if (m.find("CallsIVRException") != m.end() && !m["CallsIVRException"].empty()) {
      callsIVRException = make_shared<long>(boost::any_cast<long>(m["CallsIVRException"]));
    }
    if (m.find("CallsOffered") != m.end() && !m["CallsOffered"].empty()) {
      callsOffered = make_shared<long>(boost::any_cast<long>(m["CallsOffered"]));
    }
    if (m.find("CallsQueued") != m.end() && !m["CallsQueued"].empty()) {
      callsQueued = make_shared<long>(boost::any_cast<long>(m["CallsQueued"]));
    }
    if (m.find("CallsQueuingFailed") != m.end() && !m["CallsQueuingFailed"].empty()) {
      callsQueuingFailed = make_shared<long>(boost::any_cast<long>(m["CallsQueuingFailed"]));
    }
    if (m.find("CallsQueuingOverflow") != m.end() && !m["CallsQueuingOverflow"].empty()) {
      callsQueuingOverflow = make_shared<long>(boost::any_cast<long>(m["CallsQueuingOverflow"]));
    }
    if (m.find("CallsQueuingTimeout") != m.end() && !m["CallsQueuingTimeout"].empty()) {
      callsQueuingTimeout = make_shared<long>(boost::any_cast<long>(m["CallsQueuingTimeout"]));
    }
    if (m.find("CallsRinged") != m.end() && !m["CallsRinged"].empty()) {
      callsRinged = make_shared<long>(boost::any_cast<long>(m["CallsRinged"]));
    }
    if (m.find("CallsVoicemail") != m.end() && !m["CallsVoicemail"].empty()) {
      callsVoicemail = make_shared<long>(boost::any_cast<long>(m["CallsVoicemail"]));
    }
    if (m.find("HandleRate") != m.end() && !m["HandleRate"].empty()) {
      handleRate = make_shared<double>(boost::any_cast<double>(m["HandleRate"]));
    }
    if (m.find("MaxAbandonTime") != m.end() && !m["MaxAbandonTime"].empty()) {
      maxAbandonTime = make_shared<long>(boost::any_cast<long>(m["MaxAbandonTime"]));
    }
    if (m.find("MaxAbandonedInIVRTime") != m.end() && !m["MaxAbandonedInIVRTime"].empty()) {
      maxAbandonedInIVRTime = make_shared<long>(boost::any_cast<long>(m["MaxAbandonedInIVRTime"]));
    }
    if (m.find("MaxAbandonedInQueueTime") != m.end() && !m["MaxAbandonedInQueueTime"].empty()) {
      maxAbandonedInQueueTime = make_shared<long>(boost::any_cast<long>(m["MaxAbandonedInQueueTime"]));
    }
    if (m.find("MaxAbandonedInRingTime") != m.end() && !m["MaxAbandonedInRingTime"].empty()) {
      maxAbandonedInRingTime = make_shared<long>(boost::any_cast<long>(m["MaxAbandonedInRingTime"]));
    }
    if (m.find("MaxHoldTime") != m.end() && !m["MaxHoldTime"].empty()) {
      maxHoldTime = make_shared<long>(boost::any_cast<long>(m["MaxHoldTime"]));
    }
    if (m.find("MaxRingTime") != m.end() && !m["MaxRingTime"].empty()) {
      maxRingTime = make_shared<long>(boost::any_cast<long>(m["MaxRingTime"]));
    }
    if (m.find("MaxTalkTime") != m.end() && !m["MaxTalkTime"].empty()) {
      maxTalkTime = make_shared<long>(boost::any_cast<long>(m["MaxTalkTime"]));
    }
    if (m.find("MaxWaitTime") != m.end() && !m["MaxWaitTime"].empty()) {
      maxWaitTime = make_shared<long>(boost::any_cast<long>(m["MaxWaitTime"]));
    }
    if (m.find("MaxWorkTime") != m.end() && !m["MaxWorkTime"].empty()) {
      maxWorkTime = make_shared<long>(boost::any_cast<long>(m["MaxWorkTime"]));
    }
    if (m.find("SatisfactionIndex") != m.end() && !m["SatisfactionIndex"].empty()) {
      satisfactionIndex = make_shared<double>(boost::any_cast<double>(m["SatisfactionIndex"]));
    }
    if (m.find("SatisfactionRate") != m.end() && !m["SatisfactionRate"].empty()) {
      satisfactionRate = make_shared<double>(boost::any_cast<double>(m["SatisfactionRate"]));
    }
    if (m.find("SatisfactionSurveysOffered") != m.end() && !m["SatisfactionSurveysOffered"].empty()) {
      satisfactionSurveysOffered = make_shared<long>(boost::any_cast<long>(m["SatisfactionSurveysOffered"]));
    }
    if (m.find("SatisfactionSurveysResponded") != m.end() && !m["SatisfactionSurveysResponded"].empty()) {
      satisfactionSurveysResponded = make_shared<long>(boost::any_cast<long>(m["SatisfactionSurveysResponded"]));
    }
    if (m.find("ServiceLevel20") != m.end() && !m["ServiceLevel20"].empty()) {
      serviceLevel20 = make_shared<double>(boost::any_cast<double>(m["ServiceLevel20"]));
    }
    if (m.find("TotalAbandonTime") != m.end() && !m["TotalAbandonTime"].empty()) {
      totalAbandonTime = make_shared<long>(boost::any_cast<long>(m["TotalAbandonTime"]));
    }
    if (m.find("TotalAbandonedInIVRTime") != m.end() && !m["TotalAbandonedInIVRTime"].empty()) {
      totalAbandonedInIVRTime = make_shared<long>(boost::any_cast<long>(m["TotalAbandonedInIVRTime"]));
    }
    if (m.find("TotalAbandonedInQueueTime") != m.end() && !m["TotalAbandonedInQueueTime"].empty()) {
      totalAbandonedInQueueTime = make_shared<long>(boost::any_cast<long>(m["TotalAbandonedInQueueTime"]));
    }
    if (m.find("TotalAbandonedInRingTime") != m.end() && !m["TotalAbandonedInRingTime"].empty()) {
      totalAbandonedInRingTime = make_shared<long>(boost::any_cast<long>(m["TotalAbandonedInRingTime"]));
    }
    if (m.find("TotalHoldTime") != m.end() && !m["TotalHoldTime"].empty()) {
      totalHoldTime = make_shared<long>(boost::any_cast<long>(m["TotalHoldTime"]));
    }
    if (m.find("TotalRingTime") != m.end() && !m["TotalRingTime"].empty()) {
      totalRingTime = make_shared<long>(boost::any_cast<long>(m["TotalRingTime"]));
    }
    if (m.find("TotalTalkTime") != m.end() && !m["TotalTalkTime"].empty()) {
      totalTalkTime = make_shared<long>(boost::any_cast<long>(m["TotalTalkTime"]));
    }
    if (m.find("TotalWaitTime") != m.end() && !m["TotalWaitTime"].empty()) {
      totalWaitTime = make_shared<long>(boost::any_cast<long>(m["TotalWaitTime"]));
    }
    if (m.find("TotalWorkTime") != m.end() && !m["TotalWorkTime"].empty()) {
      totalWorkTime = make_shared<long>(boost::any_cast<long>(m["TotalWorkTime"]));
    }
  }


  virtual ~GetHistoricalInstanceReportResponseBodyDataInbound() = default;
};
class GetHistoricalInstanceReportResponseBodyDataOutbound : public Darabonba::Model {
public:
  shared_ptr<double> answerRate{};
  shared_ptr<double> averageDialingTime{};
  shared_ptr<double> averageHoldTime{};
  shared_ptr<double> averageRingTime{};
  shared_ptr<double> averageTalkTime{};
  shared_ptr<double> averageWorkTime{};
  shared_ptr<long> callsAnswered{};
  shared_ptr<long> callsAttendedTransferred{};
  shared_ptr<long> callsBlindTransferred{};
  shared_ptr<long> callsDialed{};
  shared_ptr<long> callsHold{};
  shared_ptr<long> callsRinged{};
  shared_ptr<long> maxDialingTime{};
  shared_ptr<long> maxHoldTime{};
  shared_ptr<long> maxRingTime{};
  shared_ptr<long> maxTalkTime{};
  shared_ptr<long> maxWorkTime{};
  shared_ptr<double> satisfactionIndex{};
  shared_ptr<double> satisfactionRate{};
  shared_ptr<long> satisfactionSurveysOffered{};
  shared_ptr<long> satisfactionSurveysResponded{};
  shared_ptr<long> totalDialingTime{};
  shared_ptr<long> totalHoldTime{};
  shared_ptr<long> totalRingTime{};
  shared_ptr<long> totalTalkTime{};
  shared_ptr<long> totalWorkTime{};

  GetHistoricalInstanceReportResponseBodyDataOutbound() {}

  explicit GetHistoricalInstanceReportResponseBodyDataOutbound(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (answerRate) {
      res["AnswerRate"] = boost::any(*answerRate);
    }
    if (averageDialingTime) {
      res["AverageDialingTime"] = boost::any(*averageDialingTime);
    }
    if (averageHoldTime) {
      res["AverageHoldTime"] = boost::any(*averageHoldTime);
    }
    if (averageRingTime) {
      res["AverageRingTime"] = boost::any(*averageRingTime);
    }
    if (averageTalkTime) {
      res["AverageTalkTime"] = boost::any(*averageTalkTime);
    }
    if (averageWorkTime) {
      res["AverageWorkTime"] = boost::any(*averageWorkTime);
    }
    if (callsAnswered) {
      res["CallsAnswered"] = boost::any(*callsAnswered);
    }
    if (callsAttendedTransferred) {
      res["CallsAttendedTransferred"] = boost::any(*callsAttendedTransferred);
    }
    if (callsBlindTransferred) {
      res["CallsBlindTransferred"] = boost::any(*callsBlindTransferred);
    }
    if (callsDialed) {
      res["CallsDialed"] = boost::any(*callsDialed);
    }
    if (callsHold) {
      res["CallsHold"] = boost::any(*callsHold);
    }
    if (callsRinged) {
      res["CallsRinged"] = boost::any(*callsRinged);
    }
    if (maxDialingTime) {
      res["MaxDialingTime"] = boost::any(*maxDialingTime);
    }
    if (maxHoldTime) {
      res["MaxHoldTime"] = boost::any(*maxHoldTime);
    }
    if (maxRingTime) {
      res["MaxRingTime"] = boost::any(*maxRingTime);
    }
    if (maxTalkTime) {
      res["MaxTalkTime"] = boost::any(*maxTalkTime);
    }
    if (maxWorkTime) {
      res["MaxWorkTime"] = boost::any(*maxWorkTime);
    }
    if (satisfactionIndex) {
      res["SatisfactionIndex"] = boost::any(*satisfactionIndex);
    }
    if (satisfactionRate) {
      res["SatisfactionRate"] = boost::any(*satisfactionRate);
    }
    if (satisfactionSurveysOffered) {
      res["SatisfactionSurveysOffered"] = boost::any(*satisfactionSurveysOffered);
    }
    if (satisfactionSurveysResponded) {
      res["SatisfactionSurveysResponded"] = boost::any(*satisfactionSurveysResponded);
    }
    if (totalDialingTime) {
      res["TotalDialingTime"] = boost::any(*totalDialingTime);
    }
    if (totalHoldTime) {
      res["TotalHoldTime"] = boost::any(*totalHoldTime);
    }
    if (totalRingTime) {
      res["TotalRingTime"] = boost::any(*totalRingTime);
    }
    if (totalTalkTime) {
      res["TotalTalkTime"] = boost::any(*totalTalkTime);
    }
    if (totalWorkTime) {
      res["TotalWorkTime"] = boost::any(*totalWorkTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AnswerRate") != m.end() && !m["AnswerRate"].empty()) {
      answerRate = make_shared<double>(boost::any_cast<double>(m["AnswerRate"]));
    }
    if (m.find("AverageDialingTime") != m.end() && !m["AverageDialingTime"].empty()) {
      averageDialingTime = make_shared<double>(boost::any_cast<double>(m["AverageDialingTime"]));
    }
    if (m.find("AverageHoldTime") != m.end() && !m["AverageHoldTime"].empty()) {
      averageHoldTime = make_shared<double>(boost::any_cast<double>(m["AverageHoldTime"]));
    }
    if (m.find("AverageRingTime") != m.end() && !m["AverageRingTime"].empty()) {
      averageRingTime = make_shared<double>(boost::any_cast<double>(m["AverageRingTime"]));
    }
    if (m.find("AverageTalkTime") != m.end() && !m["AverageTalkTime"].empty()) {
      averageTalkTime = make_shared<double>(boost::any_cast<double>(m["AverageTalkTime"]));
    }
    if (m.find("AverageWorkTime") != m.end() && !m["AverageWorkTime"].empty()) {
      averageWorkTime = make_shared<double>(boost::any_cast<double>(m["AverageWorkTime"]));
    }
    if (m.find("CallsAnswered") != m.end() && !m["CallsAnswered"].empty()) {
      callsAnswered = make_shared<long>(boost::any_cast<long>(m["CallsAnswered"]));
    }
    if (m.find("CallsAttendedTransferred") != m.end() && !m["CallsAttendedTransferred"].empty()) {
      callsAttendedTransferred = make_shared<long>(boost::any_cast<long>(m["CallsAttendedTransferred"]));
    }
    if (m.find("CallsBlindTransferred") != m.end() && !m["CallsBlindTransferred"].empty()) {
      callsBlindTransferred = make_shared<long>(boost::any_cast<long>(m["CallsBlindTransferred"]));
    }
    if (m.find("CallsDialed") != m.end() && !m["CallsDialed"].empty()) {
      callsDialed = make_shared<long>(boost::any_cast<long>(m["CallsDialed"]));
    }
    if (m.find("CallsHold") != m.end() && !m["CallsHold"].empty()) {
      callsHold = make_shared<long>(boost::any_cast<long>(m["CallsHold"]));
    }
    if (m.find("CallsRinged") != m.end() && !m["CallsRinged"].empty()) {
      callsRinged = make_shared<long>(boost::any_cast<long>(m["CallsRinged"]));
    }
    if (m.find("MaxDialingTime") != m.end() && !m["MaxDialingTime"].empty()) {
      maxDialingTime = make_shared<long>(boost::any_cast<long>(m["MaxDialingTime"]));
    }
    if (m.find("MaxHoldTime") != m.end() && !m["MaxHoldTime"].empty()) {
      maxHoldTime = make_shared<long>(boost::any_cast<long>(m["MaxHoldTime"]));
    }
    if (m.find("MaxRingTime") != m.end() && !m["MaxRingTime"].empty()) {
      maxRingTime = make_shared<long>(boost::any_cast<long>(m["MaxRingTime"]));
    }
    if (m.find("MaxTalkTime") != m.end() && !m["MaxTalkTime"].empty()) {
      maxTalkTime = make_shared<long>(boost::any_cast<long>(m["MaxTalkTime"]));
    }
    if (m.find("MaxWorkTime") != m.end() && !m["MaxWorkTime"].empty()) {
      maxWorkTime = make_shared<long>(boost::any_cast<long>(m["MaxWorkTime"]));
    }
    if (m.find("SatisfactionIndex") != m.end() && !m["SatisfactionIndex"].empty()) {
      satisfactionIndex = make_shared<double>(boost::any_cast<double>(m["SatisfactionIndex"]));
    }
    if (m.find("SatisfactionRate") != m.end() && !m["SatisfactionRate"].empty()) {
      satisfactionRate = make_shared<double>(boost::any_cast<double>(m["SatisfactionRate"]));
    }
    if (m.find("SatisfactionSurveysOffered") != m.end() && !m["SatisfactionSurveysOffered"].empty()) {
      satisfactionSurveysOffered = make_shared<long>(boost::any_cast<long>(m["SatisfactionSurveysOffered"]));
    }
    if (m.find("SatisfactionSurveysResponded") != m.end() && !m["SatisfactionSurveysResponded"].empty()) {
      satisfactionSurveysResponded = make_shared<long>(boost::any_cast<long>(m["SatisfactionSurveysResponded"]));
    }
    if (m.find("TotalDialingTime") != m.end() && !m["TotalDialingTime"].empty()) {
      totalDialingTime = make_shared<long>(boost::any_cast<long>(m["TotalDialingTime"]));
    }
    if (m.find("TotalHoldTime") != m.end() && !m["TotalHoldTime"].empty()) {
      totalHoldTime = make_shared<long>(boost::any_cast<long>(m["TotalHoldTime"]));
    }
    if (m.find("TotalRingTime") != m.end() && !m["TotalRingTime"].empty()) {
      totalRingTime = make_shared<long>(boost::any_cast<long>(m["TotalRingTime"]));
    }
    if (m.find("TotalTalkTime") != m.end() && !m["TotalTalkTime"].empty()) {
      totalTalkTime = make_shared<long>(boost::any_cast<long>(m["TotalTalkTime"]));
    }
    if (m.find("TotalWorkTime") != m.end() && !m["TotalWorkTime"].empty()) {
      totalWorkTime = make_shared<long>(boost::any_cast<long>(m["TotalWorkTime"]));
    }
  }


  virtual ~GetHistoricalInstanceReportResponseBodyDataOutbound() = default;
};
class GetHistoricalInstanceReportResponseBodyDataOverall : public Darabonba::Model {
public:
  shared_ptr<double> averageBreakTime{};
  shared_ptr<double> averageHoldTime{};
  shared_ptr<double> averageReadyTime{};
  shared_ptr<double> averageTalkTime{};
  shared_ptr<double> averageWorkTime{};
  shared_ptr<long> maxBreakTime{};
  shared_ptr<long> maxHoldTime{};
  shared_ptr<long> maxReadyTime{};
  shared_ptr<long> maxTalkTime{};
  shared_ptr<long> maxWorkTime{};
  shared_ptr<double> occupancyRate{};
  shared_ptr<double> satisfactionIndex{};
  shared_ptr<double> satisfactionRate{};
  shared_ptr<long> satisfactionSurveysOffered{};
  shared_ptr<long> satisfactionSurveysResponded{};
  shared_ptr<long> totalBreakTime{};
  shared_ptr<long> totalCalls{};
  shared_ptr<long> totalHoldTime{};
  shared_ptr<long> totalLoggedInTime{};
  shared_ptr<long> totalReadyTime{};
  shared_ptr<long> totalTalkTime{};
  shared_ptr<long> totalWorkTime{};

  GetHistoricalInstanceReportResponseBodyDataOverall() {}

  explicit GetHistoricalInstanceReportResponseBodyDataOverall(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (averageBreakTime) {
      res["AverageBreakTime"] = boost::any(*averageBreakTime);
    }
    if (averageHoldTime) {
      res["AverageHoldTime"] = boost::any(*averageHoldTime);
    }
    if (averageReadyTime) {
      res["AverageReadyTime"] = boost::any(*averageReadyTime);
    }
    if (averageTalkTime) {
      res["AverageTalkTime"] = boost::any(*averageTalkTime);
    }
    if (averageWorkTime) {
      res["AverageWorkTime"] = boost::any(*averageWorkTime);
    }
    if (maxBreakTime) {
      res["MaxBreakTime"] = boost::any(*maxBreakTime);
    }
    if (maxHoldTime) {
      res["MaxHoldTime"] = boost::any(*maxHoldTime);
    }
    if (maxReadyTime) {
      res["MaxReadyTime"] = boost::any(*maxReadyTime);
    }
    if (maxTalkTime) {
      res["MaxTalkTime"] = boost::any(*maxTalkTime);
    }
    if (maxWorkTime) {
      res["MaxWorkTime"] = boost::any(*maxWorkTime);
    }
    if (occupancyRate) {
      res["OccupancyRate"] = boost::any(*occupancyRate);
    }
    if (satisfactionIndex) {
      res["SatisfactionIndex"] = boost::any(*satisfactionIndex);
    }
    if (satisfactionRate) {
      res["SatisfactionRate"] = boost::any(*satisfactionRate);
    }
    if (satisfactionSurveysOffered) {
      res["SatisfactionSurveysOffered"] = boost::any(*satisfactionSurveysOffered);
    }
    if (satisfactionSurveysResponded) {
      res["SatisfactionSurveysResponded"] = boost::any(*satisfactionSurveysResponded);
    }
    if (totalBreakTime) {
      res["TotalBreakTime"] = boost::any(*totalBreakTime);
    }
    if (totalCalls) {
      res["TotalCalls"] = boost::any(*totalCalls);
    }
    if (totalHoldTime) {
      res["TotalHoldTime"] = boost::any(*totalHoldTime);
    }
    if (totalLoggedInTime) {
      res["TotalLoggedInTime"] = boost::any(*totalLoggedInTime);
    }
    if (totalReadyTime) {
      res["TotalReadyTime"] = boost::any(*totalReadyTime);
    }
    if (totalTalkTime) {
      res["TotalTalkTime"] = boost::any(*totalTalkTime);
    }
    if (totalWorkTime) {
      res["TotalWorkTime"] = boost::any(*totalWorkTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AverageBreakTime") != m.end() && !m["AverageBreakTime"].empty()) {
      averageBreakTime = make_shared<double>(boost::any_cast<double>(m["AverageBreakTime"]));
    }
    if (m.find("AverageHoldTime") != m.end() && !m["AverageHoldTime"].empty()) {
      averageHoldTime = make_shared<double>(boost::any_cast<double>(m["AverageHoldTime"]));
    }
    if (m.find("AverageReadyTime") != m.end() && !m["AverageReadyTime"].empty()) {
      averageReadyTime = make_shared<double>(boost::any_cast<double>(m["AverageReadyTime"]));
    }
    if (m.find("AverageTalkTime") != m.end() && !m["AverageTalkTime"].empty()) {
      averageTalkTime = make_shared<double>(boost::any_cast<double>(m["AverageTalkTime"]));
    }
    if (m.find("AverageWorkTime") != m.end() && !m["AverageWorkTime"].empty()) {
      averageWorkTime = make_shared<double>(boost::any_cast<double>(m["AverageWorkTime"]));
    }
    if (m.find("MaxBreakTime") != m.end() && !m["MaxBreakTime"].empty()) {
      maxBreakTime = make_shared<long>(boost::any_cast<long>(m["MaxBreakTime"]));
    }
    if (m.find("MaxHoldTime") != m.end() && !m["MaxHoldTime"].empty()) {
      maxHoldTime = make_shared<long>(boost::any_cast<long>(m["MaxHoldTime"]));
    }
    if (m.find("MaxReadyTime") != m.end() && !m["MaxReadyTime"].empty()) {
      maxReadyTime = make_shared<long>(boost::any_cast<long>(m["MaxReadyTime"]));
    }
    if (m.find("MaxTalkTime") != m.end() && !m["MaxTalkTime"].empty()) {
      maxTalkTime = make_shared<long>(boost::any_cast<long>(m["MaxTalkTime"]));
    }
    if (m.find("MaxWorkTime") != m.end() && !m["MaxWorkTime"].empty()) {
      maxWorkTime = make_shared<long>(boost::any_cast<long>(m["MaxWorkTime"]));
    }
    if (m.find("OccupancyRate") != m.end() && !m["OccupancyRate"].empty()) {
      occupancyRate = make_shared<double>(boost::any_cast<double>(m["OccupancyRate"]));
    }
    if (m.find("SatisfactionIndex") != m.end() && !m["SatisfactionIndex"].empty()) {
      satisfactionIndex = make_shared<double>(boost::any_cast<double>(m["SatisfactionIndex"]));
    }
    if (m.find("SatisfactionRate") != m.end() && !m["SatisfactionRate"].empty()) {
      satisfactionRate = make_shared<double>(boost::any_cast<double>(m["SatisfactionRate"]));
    }
    if (m.find("SatisfactionSurveysOffered") != m.end() && !m["SatisfactionSurveysOffered"].empty()) {
      satisfactionSurveysOffered = make_shared<long>(boost::any_cast<long>(m["SatisfactionSurveysOffered"]));
    }
    if (m.find("SatisfactionSurveysResponded") != m.end() && !m["SatisfactionSurveysResponded"].empty()) {
      satisfactionSurveysResponded = make_shared<long>(boost::any_cast<long>(m["SatisfactionSurveysResponded"]));
    }
    if (m.find("TotalBreakTime") != m.end() && !m["TotalBreakTime"].empty()) {
      totalBreakTime = make_shared<long>(boost::any_cast<long>(m["TotalBreakTime"]));
    }
    if (m.find("TotalCalls") != m.end() && !m["TotalCalls"].empty()) {
      totalCalls = make_shared<long>(boost::any_cast<long>(m["TotalCalls"]));
    }
    if (m.find("TotalHoldTime") != m.end() && !m["TotalHoldTime"].empty()) {
      totalHoldTime = make_shared<long>(boost::any_cast<long>(m["TotalHoldTime"]));
    }
    if (m.find("TotalLoggedInTime") != m.end() && !m["TotalLoggedInTime"].empty()) {
      totalLoggedInTime = make_shared<long>(boost::any_cast<long>(m["TotalLoggedInTime"]));
    }
    if (m.find("TotalReadyTime") != m.end() && !m["TotalReadyTime"].empty()) {
      totalReadyTime = make_shared<long>(boost::any_cast<long>(m["TotalReadyTime"]));
    }
    if (m.find("TotalTalkTime") != m.end() && !m["TotalTalkTime"].empty()) {
      totalTalkTime = make_shared<long>(boost::any_cast<long>(m["TotalTalkTime"]));
    }
    if (m.find("TotalWorkTime") != m.end() && !m["TotalWorkTime"].empty()) {
      totalWorkTime = make_shared<long>(boost::any_cast<long>(m["TotalWorkTime"]));
    }
  }


  virtual ~GetHistoricalInstanceReportResponseBodyDataOverall() = default;
};
class GetHistoricalInstanceReportResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<GetHistoricalInstanceReportResponseBodyDataInbound> inbound{};
  shared_ptr<GetHistoricalInstanceReportResponseBodyDataOutbound> outbound{};
  shared_ptr<GetHistoricalInstanceReportResponseBodyDataOverall> overall{};

  GetHistoricalInstanceReportResponseBodyData() {}

  explicit GetHistoricalInstanceReportResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (inbound) {
      res["Inbound"] = inbound ? boost::any(inbound->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (outbound) {
      res["Outbound"] = outbound ? boost::any(outbound->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (overall) {
      res["Overall"] = overall ? boost::any(overall->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Inbound") != m.end() && !m["Inbound"].empty()) {
      if (typeid(map<string, boost::any>) == m["Inbound"].type()) {
        GetHistoricalInstanceReportResponseBodyDataInbound model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Inbound"]));
        inbound = make_shared<GetHistoricalInstanceReportResponseBodyDataInbound>(model1);
      }
    }
    if (m.find("Outbound") != m.end() && !m["Outbound"].empty()) {
      if (typeid(map<string, boost::any>) == m["Outbound"].type()) {
        GetHistoricalInstanceReportResponseBodyDataOutbound model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Outbound"]));
        outbound = make_shared<GetHistoricalInstanceReportResponseBodyDataOutbound>(model1);
      }
    }
    if (m.find("Overall") != m.end() && !m["Overall"].empty()) {
      if (typeid(map<string, boost::any>) == m["Overall"].type()) {
        GetHistoricalInstanceReportResponseBodyDataOverall model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Overall"]));
        overall = make_shared<GetHistoricalInstanceReportResponseBodyDataOverall>(model1);
      }
    }
  }


  virtual ~GetHistoricalInstanceReportResponseBodyData() = default;
};
class GetHistoricalInstanceReportResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<GetHistoricalInstanceReportResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  GetHistoricalInstanceReportResponseBody() {}

  explicit GetHistoricalInstanceReportResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetHistoricalInstanceReportResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetHistoricalInstanceReportResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetHistoricalInstanceReportResponseBody() = default;
};
class GetHistoricalInstanceReportResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetHistoricalInstanceReportResponseBody> body{};

  GetHistoricalInstanceReportResponse() {}

  explicit GetHistoricalInstanceReportResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetHistoricalInstanceReportResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetHistoricalInstanceReportResponseBody>(model1);
      }
    }
  }


  virtual ~GetHistoricalInstanceReportResponse() = default;
};
class GetInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};

  GetInstanceRequest() {}

  explicit GetInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~GetInstanceRequest() = default;
};
class GetInstanceResponseBodyDataAdminList : public Darabonba::Model {
public:
  shared_ptr<string> displayName{};
  shared_ptr<string> email{};
  shared_ptr<string> extension{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> loginName{};
  shared_ptr<string> mobile{};
  shared_ptr<string> roleId{};
  shared_ptr<string> roleName{};
  shared_ptr<string> userId{};
  shared_ptr<string> workMode{};

  GetInstanceResponseBodyDataAdminList() {}

  explicit GetInstanceResponseBodyDataAdminList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (displayName) {
      res["DisplayName"] = boost::any(*displayName);
    }
    if (email) {
      res["Email"] = boost::any(*email);
    }
    if (extension) {
      res["Extension"] = boost::any(*extension);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (loginName) {
      res["LoginName"] = boost::any(*loginName);
    }
    if (mobile) {
      res["Mobile"] = boost::any(*mobile);
    }
    if (roleId) {
      res["RoleId"] = boost::any(*roleId);
    }
    if (roleName) {
      res["RoleName"] = boost::any(*roleName);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (workMode) {
      res["WorkMode"] = boost::any(*workMode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DisplayName") != m.end() && !m["DisplayName"].empty()) {
      displayName = make_shared<string>(boost::any_cast<string>(m["DisplayName"]));
    }
    if (m.find("Email") != m.end() && !m["Email"].empty()) {
      email = make_shared<string>(boost::any_cast<string>(m["Email"]));
    }
    if (m.find("Extension") != m.end() && !m["Extension"].empty()) {
      extension = make_shared<string>(boost::any_cast<string>(m["Extension"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("LoginName") != m.end() && !m["LoginName"].empty()) {
      loginName = make_shared<string>(boost::any_cast<string>(m["LoginName"]));
    }
    if (m.find("Mobile") != m.end() && !m["Mobile"].empty()) {
      mobile = make_shared<string>(boost::any_cast<string>(m["Mobile"]));
    }
    if (m.find("RoleId") != m.end() && !m["RoleId"].empty()) {
      roleId = make_shared<string>(boost::any_cast<string>(m["RoleId"]));
    }
    if (m.find("RoleName") != m.end() && !m["RoleName"].empty()) {
      roleName = make_shared<string>(boost::any_cast<string>(m["RoleName"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
    if (m.find("WorkMode") != m.end() && !m["WorkMode"].empty()) {
      workMode = make_shared<string>(boost::any_cast<string>(m["WorkMode"]));
    }
  }


  virtual ~GetInstanceResponseBodyDataAdminList() = default;
};
class GetInstanceResponseBodyDataNumberListSkillGroups : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> displayName{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> name{};
  shared_ptr<long> phoneNumberCount{};
  shared_ptr<string> skillGroupId{};
  shared_ptr<long> userCount{};

  GetInstanceResponseBodyDataNumberListSkillGroups() {}

  explicit GetInstanceResponseBodyDataNumberListSkillGroups(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (displayName) {
      res["DisplayName"] = boost::any(*displayName);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (phoneNumberCount) {
      res["PhoneNumberCount"] = boost::any(*phoneNumberCount);
    }
    if (skillGroupId) {
      res["SkillGroupId"] = boost::any(*skillGroupId);
    }
    if (userCount) {
      res["UserCount"] = boost::any(*userCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DisplayName") != m.end() && !m["DisplayName"].empty()) {
      displayName = make_shared<string>(boost::any_cast<string>(m["DisplayName"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("PhoneNumberCount") != m.end() && !m["PhoneNumberCount"].empty()) {
      phoneNumberCount = make_shared<long>(boost::any_cast<long>(m["PhoneNumberCount"]));
    }
    if (m.find("SkillGroupId") != m.end() && !m["SkillGroupId"].empty()) {
      skillGroupId = make_shared<string>(boost::any_cast<string>(m["SkillGroupId"]));
    }
    if (m.find("UserCount") != m.end() && !m["UserCount"].empty()) {
      userCount = make_shared<long>(boost::any_cast<long>(m["UserCount"]));
    }
  }


  virtual ~GetInstanceResponseBodyDataNumberListSkillGroups() = default;
};
class GetInstanceResponseBodyDataNumberList : public Darabonba::Model {
public:
  shared_ptr<bool> active{};
  shared_ptr<string> city{};
  shared_ptr<string> contactFlowId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> number{};
  shared_ptr<string> province{};
  shared_ptr<vector<GetInstanceResponseBodyDataNumberListSkillGroups>> skillGroups{};
  shared_ptr<string> usage{};
  shared_ptr<string> userId{};

  GetInstanceResponseBodyDataNumberList() {}

  explicit GetInstanceResponseBodyDataNumberList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (active) {
      res["Active"] = boost::any(*active);
    }
    if (city) {
      res["City"] = boost::any(*city);
    }
    if (contactFlowId) {
      res["ContactFlowId"] = boost::any(*contactFlowId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (number) {
      res["Number"] = boost::any(*number);
    }
    if (province) {
      res["Province"] = boost::any(*province);
    }
    if (skillGroups) {
      vector<boost::any> temp1;
      for(auto item1:*skillGroups){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SkillGroups"] = boost::any(temp1);
    }
    if (usage) {
      res["Usage"] = boost::any(*usage);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Active") != m.end() && !m["Active"].empty()) {
      active = make_shared<bool>(boost::any_cast<bool>(m["Active"]));
    }
    if (m.find("City") != m.end() && !m["City"].empty()) {
      city = make_shared<string>(boost::any_cast<string>(m["City"]));
    }
    if (m.find("ContactFlowId") != m.end() && !m["ContactFlowId"].empty()) {
      contactFlowId = make_shared<string>(boost::any_cast<string>(m["ContactFlowId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Number") != m.end() && !m["Number"].empty()) {
      number = make_shared<string>(boost::any_cast<string>(m["Number"]));
    }
    if (m.find("Province") != m.end() && !m["Province"].empty()) {
      province = make_shared<string>(boost::any_cast<string>(m["Province"]));
    }
    if (m.find("SkillGroups") != m.end() && !m["SkillGroups"].empty()) {
      if (typeid(vector<boost::any>) == m["SkillGroups"].type()) {
        vector<GetInstanceResponseBodyDataNumberListSkillGroups> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SkillGroups"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetInstanceResponseBodyDataNumberListSkillGroups model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        skillGroups = make_shared<vector<GetInstanceResponseBodyDataNumberListSkillGroups>>(expect1);
      }
    }
    if (m.find("Usage") != m.end() && !m["Usage"].empty()) {
      usage = make_shared<string>(boost::any_cast<string>(m["Usage"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~GetInstanceResponseBodyDataNumberList() = default;
};
class GetInstanceResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<GetInstanceResponseBodyDataAdminList>> adminList{};
  shared_ptr<string> aliyunUid{};
  shared_ptr<string> consoleUrl{};
  shared_ptr<string> description{};
  shared_ptr<string> domainName{};
  shared_ptr<string> id{};
  shared_ptr<string> name{};
  shared_ptr<vector<GetInstanceResponseBodyDataNumberList>> numberList{};
  shared_ptr<string> status{};

  GetInstanceResponseBodyData() {}

  explicit GetInstanceResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (adminList) {
      vector<boost::any> temp1;
      for(auto item1:*adminList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AdminList"] = boost::any(temp1);
    }
    if (aliyunUid) {
      res["AliyunUid"] = boost::any(*aliyunUid);
    }
    if (consoleUrl) {
      res["ConsoleUrl"] = boost::any(*consoleUrl);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (numberList) {
      vector<boost::any> temp1;
      for(auto item1:*numberList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["NumberList"] = boost::any(temp1);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AdminList") != m.end() && !m["AdminList"].empty()) {
      if (typeid(vector<boost::any>) == m["AdminList"].type()) {
        vector<GetInstanceResponseBodyDataAdminList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AdminList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetInstanceResponseBodyDataAdminList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        adminList = make_shared<vector<GetInstanceResponseBodyDataAdminList>>(expect1);
      }
    }
    if (m.find("AliyunUid") != m.end() && !m["AliyunUid"].empty()) {
      aliyunUid = make_shared<string>(boost::any_cast<string>(m["AliyunUid"]));
    }
    if (m.find("ConsoleUrl") != m.end() && !m["ConsoleUrl"].empty()) {
      consoleUrl = make_shared<string>(boost::any_cast<string>(m["ConsoleUrl"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("NumberList") != m.end() && !m["NumberList"].empty()) {
      if (typeid(vector<boost::any>) == m["NumberList"].type()) {
        vector<GetInstanceResponseBodyDataNumberList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["NumberList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetInstanceResponseBodyDataNumberList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        numberList = make_shared<vector<GetInstanceResponseBodyDataNumberList>>(expect1);
      }
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~GetInstanceResponseBodyData() = default;
};
class GetInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<GetInstanceResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  GetInstanceResponseBody() {}

  explicit GetInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetInstanceResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetInstanceResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetInstanceResponseBody() = default;
};
class GetInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetInstanceResponseBody> body{};

  GetInstanceResponse() {}

  explicit GetInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~GetInstanceResponse() = default;
};
class GetInstanceTrendingReportRequest : public Darabonba::Model {
public:
  shared_ptr<long> endTime{};
  shared_ptr<string> instanceId{};
  shared_ptr<long> startTime{};

  GetInstanceTrendingReportRequest() {}

  explicit GetInstanceTrendingReportRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
  }


  virtual ~GetInstanceTrendingReportRequest() = default;
};
class GetInstanceTrendingReportResponseBodyDataInbound : public Darabonba::Model {
public:
  shared_ptr<long> callsAbandonedInIVR{};
  shared_ptr<long> callsAbandonedInQueue{};
  shared_ptr<long> callsAbandonedInRing{};
  shared_ptr<long> callsHandled{};
  shared_ptr<long> callsQueued{};
  shared_ptr<long> statsTime{};
  shared_ptr<long> totalCalls{};

  GetInstanceTrendingReportResponseBodyDataInbound() {}

  explicit GetInstanceTrendingReportResponseBodyDataInbound(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callsAbandonedInIVR) {
      res["CallsAbandonedInIVR"] = boost::any(*callsAbandonedInIVR);
    }
    if (callsAbandonedInQueue) {
      res["CallsAbandonedInQueue"] = boost::any(*callsAbandonedInQueue);
    }
    if (callsAbandonedInRing) {
      res["CallsAbandonedInRing"] = boost::any(*callsAbandonedInRing);
    }
    if (callsHandled) {
      res["CallsHandled"] = boost::any(*callsHandled);
    }
    if (callsQueued) {
      res["CallsQueued"] = boost::any(*callsQueued);
    }
    if (statsTime) {
      res["StatsTime"] = boost::any(*statsTime);
    }
    if (totalCalls) {
      res["TotalCalls"] = boost::any(*totalCalls);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallsAbandonedInIVR") != m.end() && !m["CallsAbandonedInIVR"].empty()) {
      callsAbandonedInIVR = make_shared<long>(boost::any_cast<long>(m["CallsAbandonedInIVR"]));
    }
    if (m.find("CallsAbandonedInQueue") != m.end() && !m["CallsAbandonedInQueue"].empty()) {
      callsAbandonedInQueue = make_shared<long>(boost::any_cast<long>(m["CallsAbandonedInQueue"]));
    }
    if (m.find("CallsAbandonedInRing") != m.end() && !m["CallsAbandonedInRing"].empty()) {
      callsAbandonedInRing = make_shared<long>(boost::any_cast<long>(m["CallsAbandonedInRing"]));
    }
    if (m.find("CallsHandled") != m.end() && !m["CallsHandled"].empty()) {
      callsHandled = make_shared<long>(boost::any_cast<long>(m["CallsHandled"]));
    }
    if (m.find("CallsQueued") != m.end() && !m["CallsQueued"].empty()) {
      callsQueued = make_shared<long>(boost::any_cast<long>(m["CallsQueued"]));
    }
    if (m.find("StatsTime") != m.end() && !m["StatsTime"].empty()) {
      statsTime = make_shared<long>(boost::any_cast<long>(m["StatsTime"]));
    }
    if (m.find("TotalCalls") != m.end() && !m["TotalCalls"].empty()) {
      totalCalls = make_shared<long>(boost::any_cast<long>(m["TotalCalls"]));
    }
  }


  virtual ~GetInstanceTrendingReportResponseBodyDataInbound() = default;
};
class GetInstanceTrendingReportResponseBodyDataOutbound : public Darabonba::Model {
public:
  shared_ptr<long> callsAnswered{};
  shared_ptr<long> statsTime{};
  shared_ptr<long> totalCalls{};

  GetInstanceTrendingReportResponseBodyDataOutbound() {}

  explicit GetInstanceTrendingReportResponseBodyDataOutbound(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callsAnswered) {
      res["CallsAnswered"] = boost::any(*callsAnswered);
    }
    if (statsTime) {
      res["StatsTime"] = boost::any(*statsTime);
    }
    if (totalCalls) {
      res["TotalCalls"] = boost::any(*totalCalls);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallsAnswered") != m.end() && !m["CallsAnswered"].empty()) {
      callsAnswered = make_shared<long>(boost::any_cast<long>(m["CallsAnswered"]));
    }
    if (m.find("StatsTime") != m.end() && !m["StatsTime"].empty()) {
      statsTime = make_shared<long>(boost::any_cast<long>(m["StatsTime"]));
    }
    if (m.find("TotalCalls") != m.end() && !m["TotalCalls"].empty()) {
      totalCalls = make_shared<long>(boost::any_cast<long>(m["TotalCalls"]));
    }
  }


  virtual ~GetInstanceTrendingReportResponseBodyDataOutbound() = default;
};
class GetInstanceTrendingReportResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<GetInstanceTrendingReportResponseBodyDataInbound>> inbound{};
  shared_ptr<vector<GetInstanceTrendingReportResponseBodyDataOutbound>> outbound{};

  GetInstanceTrendingReportResponseBodyData() {}

  explicit GetInstanceTrendingReportResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (inbound) {
      vector<boost::any> temp1;
      for(auto item1:*inbound){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Inbound"] = boost::any(temp1);
    }
    if (outbound) {
      vector<boost::any> temp1;
      for(auto item1:*outbound){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Outbound"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Inbound") != m.end() && !m["Inbound"].empty()) {
      if (typeid(vector<boost::any>) == m["Inbound"].type()) {
        vector<GetInstanceTrendingReportResponseBodyDataInbound> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Inbound"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetInstanceTrendingReportResponseBodyDataInbound model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        inbound = make_shared<vector<GetInstanceTrendingReportResponseBodyDataInbound>>(expect1);
      }
    }
    if (m.find("Outbound") != m.end() && !m["Outbound"].empty()) {
      if (typeid(vector<boost::any>) == m["Outbound"].type()) {
        vector<GetInstanceTrendingReportResponseBodyDataOutbound> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Outbound"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetInstanceTrendingReportResponseBodyDataOutbound model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        outbound = make_shared<vector<GetInstanceTrendingReportResponseBodyDataOutbound>>(expect1);
      }
    }
  }


  virtual ~GetInstanceTrendingReportResponseBodyData() = default;
};
class GetInstanceTrendingReportResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<GetInstanceTrendingReportResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  GetInstanceTrendingReportResponseBody() {}

  explicit GetInstanceTrendingReportResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetInstanceTrendingReportResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetInstanceTrendingReportResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetInstanceTrendingReportResponseBody() = default;
};
class GetInstanceTrendingReportResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetInstanceTrendingReportResponseBody> body{};

  GetInstanceTrendingReportResponse() {}

  explicit GetInstanceTrendingReportResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetInstanceTrendingReportResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetInstanceTrendingReportResponseBody>(model1);
      }
    }
  }


  virtual ~GetInstanceTrendingReportResponse() = default;
};
class GetLoginDetailsRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> userId{};

  GetLoginDetailsRequest() {}

  explicit GetLoginDetailsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~GetLoginDetailsRequest() = default;
};
class GetLoginDetailsResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> agentServerUrl{};
  shared_ptr<string> deviceExt{};
  shared_ptr<string> deviceId{};
  shared_ptr<string> deviceState{};
  shared_ptr<string> displayName{};
  shared_ptr<string> extension{};
  shared_ptr<string> signature{};
  shared_ptr<string> signature2{};
  shared_ptr<string> sipServerUrl{};
  shared_ptr<string> userId{};
  shared_ptr<string> userKey{};
  shared_ptr<string> userKey2{};
  shared_ptr<string> workMode{};

  GetLoginDetailsResponseBodyData() {}

  explicit GetLoginDetailsResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agentServerUrl) {
      res["AgentServerUrl"] = boost::any(*agentServerUrl);
    }
    if (deviceExt) {
      res["DeviceExt"] = boost::any(*deviceExt);
    }
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (deviceState) {
      res["DeviceState"] = boost::any(*deviceState);
    }
    if (displayName) {
      res["DisplayName"] = boost::any(*displayName);
    }
    if (extension) {
      res["Extension"] = boost::any(*extension);
    }
    if (signature) {
      res["Signature"] = boost::any(*signature);
    }
    if (signature2) {
      res["Signature2"] = boost::any(*signature2);
    }
    if (sipServerUrl) {
      res["SipServerUrl"] = boost::any(*sipServerUrl);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (userKey) {
      res["UserKey"] = boost::any(*userKey);
    }
    if (userKey2) {
      res["UserKey2"] = boost::any(*userKey2);
    }
    if (workMode) {
      res["WorkMode"] = boost::any(*workMode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AgentServerUrl") != m.end() && !m["AgentServerUrl"].empty()) {
      agentServerUrl = make_shared<string>(boost::any_cast<string>(m["AgentServerUrl"]));
    }
    if (m.find("DeviceExt") != m.end() && !m["DeviceExt"].empty()) {
      deviceExt = make_shared<string>(boost::any_cast<string>(m["DeviceExt"]));
    }
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("DeviceState") != m.end() && !m["DeviceState"].empty()) {
      deviceState = make_shared<string>(boost::any_cast<string>(m["DeviceState"]));
    }
    if (m.find("DisplayName") != m.end() && !m["DisplayName"].empty()) {
      displayName = make_shared<string>(boost::any_cast<string>(m["DisplayName"]));
    }
    if (m.find("Extension") != m.end() && !m["Extension"].empty()) {
      extension = make_shared<string>(boost::any_cast<string>(m["Extension"]));
    }
    if (m.find("Signature") != m.end() && !m["Signature"].empty()) {
      signature = make_shared<string>(boost::any_cast<string>(m["Signature"]));
    }
    if (m.find("Signature2") != m.end() && !m["Signature2"].empty()) {
      signature2 = make_shared<string>(boost::any_cast<string>(m["Signature2"]));
    }
    if (m.find("SipServerUrl") != m.end() && !m["SipServerUrl"].empty()) {
      sipServerUrl = make_shared<string>(boost::any_cast<string>(m["SipServerUrl"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
    if (m.find("UserKey") != m.end() && !m["UserKey"].empty()) {
      userKey = make_shared<string>(boost::any_cast<string>(m["UserKey"]));
    }
    if (m.find("UserKey2") != m.end() && !m["UserKey2"].empty()) {
      userKey2 = make_shared<string>(boost::any_cast<string>(m["UserKey2"]));
    }
    if (m.find("WorkMode") != m.end() && !m["WorkMode"].empty()) {
      workMode = make_shared<string>(boost::any_cast<string>(m["WorkMode"]));
    }
  }


  virtual ~GetLoginDetailsResponseBodyData() = default;
};
class GetLoginDetailsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<GetLoginDetailsResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<vector<string>> params{};
  shared_ptr<string> requestId{};

  GetLoginDetailsResponseBody() {}

  explicit GetLoginDetailsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (params) {
      res["Params"] = boost::any(*params);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetLoginDetailsResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetLoginDetailsResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Params") != m.end() && !m["Params"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Params"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Params"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      params = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetLoginDetailsResponseBody() = default;
};
class GetLoginDetailsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetLoginDetailsResponseBody> body{};

  GetLoginDetailsResponse() {}

  explicit GetLoginDetailsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetLoginDetailsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetLoginDetailsResponseBody>(model1);
      }
    }
  }


  virtual ~GetLoginDetailsResponse() = default;
};
class GetMonoRecordingRequest : public Darabonba::Model {
public:
  shared_ptr<string> contactId{};
  shared_ptr<string> instanceId{};

  GetMonoRecordingRequest() {}

  explicit GetMonoRecordingRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contactId) {
      res["ContactId"] = boost::any(*contactId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ContactId") != m.end() && !m["ContactId"].empty()) {
      contactId = make_shared<string>(boost::any_cast<string>(m["ContactId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~GetMonoRecordingRequest() = default;
};
class GetMonoRecordingResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> fileName{};
  shared_ptr<string> fileUrl{};

  GetMonoRecordingResponseBodyData() {}

  explicit GetMonoRecordingResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fileName) {
      res["FileName"] = boost::any(*fileName);
    }
    if (fileUrl) {
      res["FileUrl"] = boost::any(*fileUrl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FileName") != m.end() && !m["FileName"].empty()) {
      fileName = make_shared<string>(boost::any_cast<string>(m["FileName"]));
    }
    if (m.find("FileUrl") != m.end() && !m["FileUrl"].empty()) {
      fileUrl = make_shared<string>(boost::any_cast<string>(m["FileUrl"]));
    }
  }


  virtual ~GetMonoRecordingResponseBodyData() = default;
};
class GetMonoRecordingResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<GetMonoRecordingResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  GetMonoRecordingResponseBody() {}

  explicit GetMonoRecordingResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetMonoRecordingResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetMonoRecordingResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetMonoRecordingResponseBody() = default;
};
class GetMonoRecordingResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetMonoRecordingResponseBody> body{};

  GetMonoRecordingResponse() {}

  explicit GetMonoRecordingResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetMonoRecordingResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetMonoRecordingResponseBody>(model1);
      }
    }
  }


  virtual ~GetMonoRecordingResponse() = default;
};
class GetMultiChannelRecordingRequest : public Darabonba::Model {
public:
  shared_ptr<string> contactId{};
  shared_ptr<string> instanceId{};

  GetMultiChannelRecordingRequest() {}

  explicit GetMultiChannelRecordingRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contactId) {
      res["ContactId"] = boost::any(*contactId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ContactId") != m.end() && !m["ContactId"].empty()) {
      contactId = make_shared<string>(boost::any_cast<string>(m["ContactId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~GetMultiChannelRecordingRequest() = default;
};
class GetMultiChannelRecordingResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> fileName{};
  shared_ptr<string> fileUrl{};

  GetMultiChannelRecordingResponseBodyData() {}

  explicit GetMultiChannelRecordingResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fileName) {
      res["FileName"] = boost::any(*fileName);
    }
    if (fileUrl) {
      res["FileUrl"] = boost::any(*fileUrl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FileName") != m.end() && !m["FileName"].empty()) {
      fileName = make_shared<string>(boost::any_cast<string>(m["FileName"]));
    }
    if (m.find("FileUrl") != m.end() && !m["FileUrl"].empty()) {
      fileUrl = make_shared<string>(boost::any_cast<string>(m["FileUrl"]));
    }
  }


  virtual ~GetMultiChannelRecordingResponseBodyData() = default;
};
class GetMultiChannelRecordingResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<GetMultiChannelRecordingResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  GetMultiChannelRecordingResponseBody() {}

  explicit GetMultiChannelRecordingResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetMultiChannelRecordingResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetMultiChannelRecordingResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetMultiChannelRecordingResponseBody() = default;
};
class GetMultiChannelRecordingResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetMultiChannelRecordingResponseBody> body{};

  GetMultiChannelRecordingResponse() {}

  explicit GetMultiChannelRecordingResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetMultiChannelRecordingResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetMultiChannelRecordingResponseBody>(model1);
      }
    }
  }


  virtual ~GetMultiChannelRecordingResponse() = default;
};
class GetNumberLocationRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> number{};

  GetNumberLocationRequest() {}

  explicit GetNumberLocationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (number) {
      res["Number"] = boost::any(*number);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Number") != m.end() && !m["Number"].empty()) {
      number = make_shared<string>(boost::any_cast<string>(m["Number"]));
    }
  }


  virtual ~GetNumberLocationRequest() = default;
};
class GetNumberLocationResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> city{};
  shared_ptr<string> number{};
  shared_ptr<string> province{};

  GetNumberLocationResponseBodyData() {}

  explicit GetNumberLocationResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (city) {
      res["City"] = boost::any(*city);
    }
    if (number) {
      res["Number"] = boost::any(*number);
    }
    if (province) {
      res["Province"] = boost::any(*province);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("City") != m.end() && !m["City"].empty()) {
      city = make_shared<string>(boost::any_cast<string>(m["City"]));
    }
    if (m.find("Number") != m.end() && !m["Number"].empty()) {
      number = make_shared<string>(boost::any_cast<string>(m["Number"]));
    }
    if (m.find("Province") != m.end() && !m["Province"].empty()) {
      province = make_shared<string>(boost::any_cast<string>(m["Province"]));
    }
  }


  virtual ~GetNumberLocationResponseBodyData() = default;
};
class GetNumberLocationResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<GetNumberLocationResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  GetNumberLocationResponseBody() {}

  explicit GetNumberLocationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetNumberLocationResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetNumberLocationResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetNumberLocationResponseBody() = default;
};
class GetNumberLocationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetNumberLocationResponseBody> body{};

  GetNumberLocationResponse() {}

  explicit GetNumberLocationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetNumberLocationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetNumberLocationResponseBody>(model1);
      }
    }
  }


  virtual ~GetNumberLocationResponse() = default;
};
class GetRealtimeCampaignStatsRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> queueId{};

  GetRealtimeCampaignStatsRequest() {}

  explicit GetRealtimeCampaignStatsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (queueId) {
      res["QueueId"] = boost::any(*queueId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("QueueId") != m.end() && !m["QueueId"].empty()) {
      queueId = make_shared<string>(boost::any_cast<string>(m["QueueId"]));
    }
  }


  virtual ~GetRealtimeCampaignStatsRequest() = default;
};
class GetRealtimeCampaignStatsResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> breakingAgents{};
  shared_ptr<long> caps{};
  shared_ptr<long> loggedInAgents{};
  shared_ptr<long> readyAgents{};
  shared_ptr<long> talkingAgents{};
  shared_ptr<long> totalAgents{};
  shared_ptr<long> workingAgents{};

  GetRealtimeCampaignStatsResponseBodyData() {}

  explicit GetRealtimeCampaignStatsResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (breakingAgents) {
      res["BreakingAgents"] = boost::any(*breakingAgents);
    }
    if (caps) {
      res["Caps"] = boost::any(*caps);
    }
    if (loggedInAgents) {
      res["LoggedInAgents"] = boost::any(*loggedInAgents);
    }
    if (readyAgents) {
      res["ReadyAgents"] = boost::any(*readyAgents);
    }
    if (talkingAgents) {
      res["TalkingAgents"] = boost::any(*talkingAgents);
    }
    if (totalAgents) {
      res["TotalAgents"] = boost::any(*totalAgents);
    }
    if (workingAgents) {
      res["WorkingAgents"] = boost::any(*workingAgents);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BreakingAgents") != m.end() && !m["BreakingAgents"].empty()) {
      breakingAgents = make_shared<long>(boost::any_cast<long>(m["BreakingAgents"]));
    }
    if (m.find("Caps") != m.end() && !m["Caps"].empty()) {
      caps = make_shared<long>(boost::any_cast<long>(m["Caps"]));
    }
    if (m.find("LoggedInAgents") != m.end() && !m["LoggedInAgents"].empty()) {
      loggedInAgents = make_shared<long>(boost::any_cast<long>(m["LoggedInAgents"]));
    }
    if (m.find("ReadyAgents") != m.end() && !m["ReadyAgents"].empty()) {
      readyAgents = make_shared<long>(boost::any_cast<long>(m["ReadyAgents"]));
    }
    if (m.find("TalkingAgents") != m.end() && !m["TalkingAgents"].empty()) {
      talkingAgents = make_shared<long>(boost::any_cast<long>(m["TalkingAgents"]));
    }
    if (m.find("TotalAgents") != m.end() && !m["TotalAgents"].empty()) {
      totalAgents = make_shared<long>(boost::any_cast<long>(m["TotalAgents"]));
    }
    if (m.find("WorkingAgents") != m.end() && !m["WorkingAgents"].empty()) {
      workingAgents = make_shared<long>(boost::any_cast<long>(m["WorkingAgents"]));
    }
  }


  virtual ~GetRealtimeCampaignStatsResponseBodyData() = default;
};
class GetRealtimeCampaignStatsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<GetRealtimeCampaignStatsResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  GetRealtimeCampaignStatsResponseBody() {}

  explicit GetRealtimeCampaignStatsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetRealtimeCampaignStatsResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetRealtimeCampaignStatsResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetRealtimeCampaignStatsResponseBody() = default;
};
class GetRealtimeCampaignStatsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetRealtimeCampaignStatsResponseBody> body{};

  GetRealtimeCampaignStatsResponse() {}

  explicit GetRealtimeCampaignStatsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetRealtimeCampaignStatsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetRealtimeCampaignStatsResponseBody>(model1);
      }
    }
  }


  virtual ~GetRealtimeCampaignStatsResponse() = default;
};
class GetRealtimeInstanceStatesRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};

  GetRealtimeInstanceStatesRequest() {}

  explicit GetRealtimeInstanceStatesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~GetRealtimeInstanceStatesRequest() = default;
};
class GetRealtimeInstanceStatesResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> breakingAgents{};
  shared_ptr<string> instanceId{};
  shared_ptr<long> interactiveCalls{};
  shared_ptr<long> loggedInAgents{};
  shared_ptr<long> longestWaitingTime{};
  shared_ptr<long> readyAgents{};
  shared_ptr<long> talkingAgents{};
  shared_ptr<long> totalAgents{};
  shared_ptr<long> waitingCalls{};
  shared_ptr<long> workingAgents{};

  GetRealtimeInstanceStatesResponseBodyData() {}

  explicit GetRealtimeInstanceStatesResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (breakingAgents) {
      res["BreakingAgents"] = boost::any(*breakingAgents);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (interactiveCalls) {
      res["InteractiveCalls"] = boost::any(*interactiveCalls);
    }
    if (loggedInAgents) {
      res["LoggedInAgents"] = boost::any(*loggedInAgents);
    }
    if (longestWaitingTime) {
      res["LongestWaitingTime"] = boost::any(*longestWaitingTime);
    }
    if (readyAgents) {
      res["ReadyAgents"] = boost::any(*readyAgents);
    }
    if (talkingAgents) {
      res["TalkingAgents"] = boost::any(*talkingAgents);
    }
    if (totalAgents) {
      res["TotalAgents"] = boost::any(*totalAgents);
    }
    if (waitingCalls) {
      res["WaitingCalls"] = boost::any(*waitingCalls);
    }
    if (workingAgents) {
      res["WorkingAgents"] = boost::any(*workingAgents);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BreakingAgents") != m.end() && !m["BreakingAgents"].empty()) {
      breakingAgents = make_shared<long>(boost::any_cast<long>(m["BreakingAgents"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("InteractiveCalls") != m.end() && !m["InteractiveCalls"].empty()) {
      interactiveCalls = make_shared<long>(boost::any_cast<long>(m["InteractiveCalls"]));
    }
    if (m.find("LoggedInAgents") != m.end() && !m["LoggedInAgents"].empty()) {
      loggedInAgents = make_shared<long>(boost::any_cast<long>(m["LoggedInAgents"]));
    }
    if (m.find("LongestWaitingTime") != m.end() && !m["LongestWaitingTime"].empty()) {
      longestWaitingTime = make_shared<long>(boost::any_cast<long>(m["LongestWaitingTime"]));
    }
    if (m.find("ReadyAgents") != m.end() && !m["ReadyAgents"].empty()) {
      readyAgents = make_shared<long>(boost::any_cast<long>(m["ReadyAgents"]));
    }
    if (m.find("TalkingAgents") != m.end() && !m["TalkingAgents"].empty()) {
      talkingAgents = make_shared<long>(boost::any_cast<long>(m["TalkingAgents"]));
    }
    if (m.find("TotalAgents") != m.end() && !m["TotalAgents"].empty()) {
      totalAgents = make_shared<long>(boost::any_cast<long>(m["TotalAgents"]));
    }
    if (m.find("WaitingCalls") != m.end() && !m["WaitingCalls"].empty()) {
      waitingCalls = make_shared<long>(boost::any_cast<long>(m["WaitingCalls"]));
    }
    if (m.find("WorkingAgents") != m.end() && !m["WorkingAgents"].empty()) {
      workingAgents = make_shared<long>(boost::any_cast<long>(m["WorkingAgents"]));
    }
  }


  virtual ~GetRealtimeInstanceStatesResponseBodyData() = default;
};
class GetRealtimeInstanceStatesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<GetRealtimeInstanceStatesResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  GetRealtimeInstanceStatesResponseBody() {}

  explicit GetRealtimeInstanceStatesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetRealtimeInstanceStatesResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetRealtimeInstanceStatesResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetRealtimeInstanceStatesResponseBody() = default;
};
class GetRealtimeInstanceStatesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetRealtimeInstanceStatesResponseBody> body{};

  GetRealtimeInstanceStatesResponse() {}

  explicit GetRealtimeInstanceStatesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetRealtimeInstanceStatesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetRealtimeInstanceStatesResponseBody>(model1);
      }
    }
  }


  virtual ~GetRealtimeInstanceStatesResponse() = default;
};
class GetSkillGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> skillGroupId{};

  GetSkillGroupRequest() {}

  explicit GetSkillGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (skillGroupId) {
      res["SkillGroupId"] = boost::any(*skillGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("SkillGroupId") != m.end() && !m["SkillGroupId"].empty()) {
      skillGroupId = make_shared<string>(boost::any_cast<string>(m["SkillGroupId"]));
    }
  }


  virtual ~GetSkillGroupRequest() = default;
};
class GetSkillGroupResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> displayName{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> name{};
  shared_ptr<string> skillGroupId{};

  GetSkillGroupResponseBodyData() {}

  explicit GetSkillGroupResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (displayName) {
      res["DisplayName"] = boost::any(*displayName);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (skillGroupId) {
      res["SkillGroupId"] = boost::any(*skillGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DisplayName") != m.end() && !m["DisplayName"].empty()) {
      displayName = make_shared<string>(boost::any_cast<string>(m["DisplayName"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("SkillGroupId") != m.end() && !m["SkillGroupId"].empty()) {
      skillGroupId = make_shared<string>(boost::any_cast<string>(m["SkillGroupId"]));
    }
  }


  virtual ~GetSkillGroupResponseBodyData() = default;
};
class GetSkillGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<GetSkillGroupResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  GetSkillGroupResponseBody() {}

  explicit GetSkillGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetSkillGroupResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetSkillGroupResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetSkillGroupResponseBody() = default;
};
class GetSkillGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetSkillGroupResponseBody> body{};

  GetSkillGroupResponse() {}

  explicit GetSkillGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetSkillGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetSkillGroupResponseBody>(model1);
      }
    }
  }


  virtual ~GetSkillGroupResponse() = default;
};
class GetTurnCredentialsRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> userId{};

  GetTurnCredentialsRequest() {}

  explicit GetTurnCredentialsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~GetTurnCredentialsRequest() = default;
};
class GetTurnCredentialsResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> password{};
  shared_ptr<string> userName{};

  GetTurnCredentialsResponseBodyData() {}

  explicit GetTurnCredentialsResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (password) {
      res["Password"] = boost::any(*password);
    }
    if (userName) {
      res["UserName"] = boost::any(*userName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Password") != m.end() && !m["Password"].empty()) {
      password = make_shared<string>(boost::any_cast<string>(m["Password"]));
    }
    if (m.find("UserName") != m.end() && !m["UserName"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["UserName"]));
    }
  }


  virtual ~GetTurnCredentialsResponseBodyData() = default;
};
class GetTurnCredentialsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<GetTurnCredentialsResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  GetTurnCredentialsResponseBody() {}

  explicit GetTurnCredentialsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetTurnCredentialsResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetTurnCredentialsResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetTurnCredentialsResponseBody() = default;
};
class GetTurnCredentialsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetTurnCredentialsResponseBody> body{};

  GetTurnCredentialsResponse() {}

  explicit GetTurnCredentialsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetTurnCredentialsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetTurnCredentialsResponseBody>(model1);
      }
    }
  }


  virtual ~GetTurnCredentialsResponse() = default;
};
class GetTurnServerListRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};

  GetTurnServerListRequest() {}

  explicit GetTurnServerListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~GetTurnServerListRequest() = default;
};
class GetTurnServerListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  GetTurnServerListResponseBody() {}

  explicit GetTurnServerListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetTurnServerListResponseBody() = default;
};
class GetTurnServerListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetTurnServerListResponseBody> body{};

  GetTurnServerListResponse() {}

  explicit GetTurnServerListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetTurnServerListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetTurnServerListResponseBody>(model1);
      }
    }
  }


  virtual ~GetTurnServerListResponse() = default;
};
class GetUploadAudioDataParamsRequest : public Darabonba::Model {
public:
  shared_ptr<string> contactId{};
  shared_ptr<string> instanceId{};

  GetUploadAudioDataParamsRequest() {}

  explicit GetUploadAudioDataParamsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contactId) {
      res["ContactId"] = boost::any(*contactId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ContactId") != m.end() && !m["ContactId"].empty()) {
      contactId = make_shared<string>(boost::any_cast<string>(m["ContactId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~GetUploadAudioDataParamsRequest() = default;
};
class GetUploadAudioDataParamsResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> paramsStr{};

  GetUploadAudioDataParamsResponseBodyData() {}

  explicit GetUploadAudioDataParamsResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (paramsStr) {
      res["ParamsStr"] = boost::any(*paramsStr);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ParamsStr") != m.end() && !m["ParamsStr"].empty()) {
      paramsStr = make_shared<string>(boost::any_cast<string>(m["ParamsStr"]));
    }
  }


  virtual ~GetUploadAudioDataParamsResponseBodyData() = default;
};
class GetUploadAudioDataParamsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<GetUploadAudioDataParamsResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  GetUploadAudioDataParamsResponseBody() {}

  explicit GetUploadAudioDataParamsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetUploadAudioDataParamsResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetUploadAudioDataParamsResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetUploadAudioDataParamsResponseBody() = default;
};
class GetUploadAudioDataParamsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetUploadAudioDataParamsResponseBody> body{};

  GetUploadAudioDataParamsResponse() {}

  explicit GetUploadAudioDataParamsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetUploadAudioDataParamsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetUploadAudioDataParamsResponseBody>(model1);
      }
    }
  }


  virtual ~GetUploadAudioDataParamsResponse() = default;
};
class GetUserRequest : public Darabonba::Model {
public:
  shared_ptr<string> extension{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> userId{};

  GetUserRequest() {}

  explicit GetUserRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (extension) {
      res["Extension"] = boost::any(*extension);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Extension") != m.end() && !m["Extension"].empty()) {
      extension = make_shared<string>(boost::any_cast<string>(m["Extension"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~GetUserRequest() = default;
};
class GetUserResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> deviceExt{};
  shared_ptr<string> deviceId{};
  shared_ptr<string> deviceState{};
  shared_ptr<string> displayId{};
  shared_ptr<string> displayName{};
  shared_ptr<string> email{};
  shared_ptr<string> extension{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> loginName{};
  shared_ptr<string> mobile{};
  shared_ptr<string> roleId{};
  shared_ptr<string> roleName{};
  shared_ptr<string> userId{};
  shared_ptr<string> workMode{};

  GetUserResponseBodyData() {}

  explicit GetUserResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceExt) {
      res["DeviceExt"] = boost::any(*deviceExt);
    }
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (deviceState) {
      res["DeviceState"] = boost::any(*deviceState);
    }
    if (displayId) {
      res["DisplayId"] = boost::any(*displayId);
    }
    if (displayName) {
      res["DisplayName"] = boost::any(*displayName);
    }
    if (email) {
      res["Email"] = boost::any(*email);
    }
    if (extension) {
      res["Extension"] = boost::any(*extension);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (loginName) {
      res["LoginName"] = boost::any(*loginName);
    }
    if (mobile) {
      res["Mobile"] = boost::any(*mobile);
    }
    if (roleId) {
      res["RoleId"] = boost::any(*roleId);
    }
    if (roleName) {
      res["RoleName"] = boost::any(*roleName);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (workMode) {
      res["WorkMode"] = boost::any(*workMode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceExt") != m.end() && !m["DeviceExt"].empty()) {
      deviceExt = make_shared<string>(boost::any_cast<string>(m["DeviceExt"]));
    }
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("DeviceState") != m.end() && !m["DeviceState"].empty()) {
      deviceState = make_shared<string>(boost::any_cast<string>(m["DeviceState"]));
    }
    if (m.find("DisplayId") != m.end() && !m["DisplayId"].empty()) {
      displayId = make_shared<string>(boost::any_cast<string>(m["DisplayId"]));
    }
    if (m.find("DisplayName") != m.end() && !m["DisplayName"].empty()) {
      displayName = make_shared<string>(boost::any_cast<string>(m["DisplayName"]));
    }
    if (m.find("Email") != m.end() && !m["Email"].empty()) {
      email = make_shared<string>(boost::any_cast<string>(m["Email"]));
    }
    if (m.find("Extension") != m.end() && !m["Extension"].empty()) {
      extension = make_shared<string>(boost::any_cast<string>(m["Extension"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("LoginName") != m.end() && !m["LoginName"].empty()) {
      loginName = make_shared<string>(boost::any_cast<string>(m["LoginName"]));
    }
    if (m.find("Mobile") != m.end() && !m["Mobile"].empty()) {
      mobile = make_shared<string>(boost::any_cast<string>(m["Mobile"]));
    }
    if (m.find("RoleId") != m.end() && !m["RoleId"].empty()) {
      roleId = make_shared<string>(boost::any_cast<string>(m["RoleId"]));
    }
    if (m.find("RoleName") != m.end() && !m["RoleName"].empty()) {
      roleName = make_shared<string>(boost::any_cast<string>(m["RoleName"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
    if (m.find("WorkMode") != m.end() && !m["WorkMode"].empty()) {
      workMode = make_shared<string>(boost::any_cast<string>(m["WorkMode"]));
    }
  }


  virtual ~GetUserResponseBodyData() = default;
};
class GetUserResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<GetUserResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  GetUserResponseBody() {}

  explicit GetUserResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetUserResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetUserResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetUserResponseBody() = default;
};
class GetUserResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetUserResponseBody> body{};

  GetUserResponse() {}

  explicit GetUserResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetUserResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetUserResponseBody>(model1);
      }
    }
  }


  virtual ~GetUserResponse() = default;
};
class GetVoicemailRecordingRequest : public Darabonba::Model {
public:
  shared_ptr<string> contactId{};
  shared_ptr<string> instanceId{};

  GetVoicemailRecordingRequest() {}

  explicit GetVoicemailRecordingRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contactId) {
      res["ContactId"] = boost::any(*contactId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ContactId") != m.end() && !m["ContactId"].empty()) {
      contactId = make_shared<string>(boost::any_cast<string>(m["ContactId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~GetVoicemailRecordingRequest() = default;
};
class GetVoicemailRecordingResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> fileName{};
  shared_ptr<string> fileUrl{};

  GetVoicemailRecordingResponseBodyData() {}

  explicit GetVoicemailRecordingResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fileName) {
      res["FileName"] = boost::any(*fileName);
    }
    if (fileUrl) {
      res["FileUrl"] = boost::any(*fileUrl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FileName") != m.end() && !m["FileName"].empty()) {
      fileName = make_shared<string>(boost::any_cast<string>(m["FileName"]));
    }
    if (m.find("FileUrl") != m.end() && !m["FileUrl"].empty()) {
      fileUrl = make_shared<string>(boost::any_cast<string>(m["FileUrl"]));
    }
  }


  virtual ~GetVoicemailRecordingResponseBodyData() = default;
};
class GetVoicemailRecordingResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<GetVoicemailRecordingResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  GetVoicemailRecordingResponseBody() {}

  explicit GetVoicemailRecordingResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        GetVoicemailRecordingResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<GetVoicemailRecordingResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetVoicemailRecordingResponseBody() = default;
};
class GetVoicemailRecordingResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetVoicemailRecordingResponseBody> body{};

  GetVoicemailRecordingResponse() {}

  explicit GetVoicemailRecordingResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetVoicemailRecordingResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetVoicemailRecordingResponseBody>(model1);
      }
    }
  }


  virtual ~GetVoicemailRecordingResponse() = default;
};
class HoldCallRequest : public Darabonba::Model {
public:
  shared_ptr<string> channelId{};
  shared_ptr<string> deviceId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> jobId{};
  shared_ptr<string> music{};
  shared_ptr<string> userId{};

  HoldCallRequest() {}

  explicit HoldCallRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (channelId) {
      res["ChannelId"] = boost::any(*channelId);
    }
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (music) {
      res["Music"] = boost::any(*music);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChannelId") != m.end() && !m["ChannelId"].empty()) {
      channelId = make_shared<string>(boost::any_cast<string>(m["ChannelId"]));
    }
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("Music") != m.end() && !m["Music"].empty()) {
      music = make_shared<string>(boost::any_cast<string>(m["Music"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~HoldCallRequest() = default;
};
class HoldCallResponseBodyDataCallContextChannelContexts : public Darabonba::Model {
public:
  shared_ptr<string> callType{};
  shared_ptr<string> channelId{};
  shared_ptr<string> channelState{};
  shared_ptr<string> destination{};
  shared_ptr<string> jobId{};
  shared_ptr<string> originator{};
  shared_ptr<string> releaseInitiator{};
  shared_ptr<string> releaseReason{};
  shared_ptr<string> skillGroupId{};
  shared_ptr<long> timestamp{};
  shared_ptr<string> userExtension{};
  shared_ptr<string> userId{};

  HoldCallResponseBodyDataCallContextChannelContexts() {}

  explicit HoldCallResponseBodyDataCallContextChannelContexts(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callType) {
      res["CallType"] = boost::any(*callType);
    }
    if (channelId) {
      res["ChannelId"] = boost::any(*channelId);
    }
    if (channelState) {
      res["ChannelState"] = boost::any(*channelState);
    }
    if (destination) {
      res["Destination"] = boost::any(*destination);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (originator) {
      res["Originator"] = boost::any(*originator);
    }
    if (releaseInitiator) {
      res["ReleaseInitiator"] = boost::any(*releaseInitiator);
    }
    if (releaseReason) {
      res["ReleaseReason"] = boost::any(*releaseReason);
    }
    if (skillGroupId) {
      res["SkillGroupId"] = boost::any(*skillGroupId);
    }
    if (timestamp) {
      res["Timestamp"] = boost::any(*timestamp);
    }
    if (userExtension) {
      res["UserExtension"] = boost::any(*userExtension);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallType") != m.end() && !m["CallType"].empty()) {
      callType = make_shared<string>(boost::any_cast<string>(m["CallType"]));
    }
    if (m.find("ChannelId") != m.end() && !m["ChannelId"].empty()) {
      channelId = make_shared<string>(boost::any_cast<string>(m["ChannelId"]));
    }
    if (m.find("ChannelState") != m.end() && !m["ChannelState"].empty()) {
      channelState = make_shared<string>(boost::any_cast<string>(m["ChannelState"]));
    }
    if (m.find("Destination") != m.end() && !m["Destination"].empty()) {
      destination = make_shared<string>(boost::any_cast<string>(m["Destination"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("Originator") != m.end() && !m["Originator"].empty()) {
      originator = make_shared<string>(boost::any_cast<string>(m["Originator"]));
    }
    if (m.find("ReleaseInitiator") != m.end() && !m["ReleaseInitiator"].empty()) {
      releaseInitiator = make_shared<string>(boost::any_cast<string>(m["ReleaseInitiator"]));
    }
    if (m.find("ReleaseReason") != m.end() && !m["ReleaseReason"].empty()) {
      releaseReason = make_shared<string>(boost::any_cast<string>(m["ReleaseReason"]));
    }
    if (m.find("SkillGroupId") != m.end() && !m["SkillGroupId"].empty()) {
      skillGroupId = make_shared<string>(boost::any_cast<string>(m["SkillGroupId"]));
    }
    if (m.find("Timestamp") != m.end() && !m["Timestamp"].empty()) {
      timestamp = make_shared<long>(boost::any_cast<long>(m["Timestamp"]));
    }
    if (m.find("UserExtension") != m.end() && !m["UserExtension"].empty()) {
      userExtension = make_shared<string>(boost::any_cast<string>(m["UserExtension"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~HoldCallResponseBodyDataCallContextChannelContexts() = default;
};
class HoldCallResponseBodyDataCallContext : public Darabonba::Model {
public:
  shared_ptr<string> callType{};
  shared_ptr<vector<HoldCallResponseBodyDataCallContextChannelContexts>> channelContexts{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> jobId{};

  HoldCallResponseBodyDataCallContext() {}

  explicit HoldCallResponseBodyDataCallContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callType) {
      res["CallType"] = boost::any(*callType);
    }
    if (channelContexts) {
      vector<boost::any> temp1;
      for(auto item1:*channelContexts){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ChannelContexts"] = boost::any(temp1);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallType") != m.end() && !m["CallType"].empty()) {
      callType = make_shared<string>(boost::any_cast<string>(m["CallType"]));
    }
    if (m.find("ChannelContexts") != m.end() && !m["ChannelContexts"].empty()) {
      if (typeid(vector<boost::any>) == m["ChannelContexts"].type()) {
        vector<HoldCallResponseBodyDataCallContextChannelContexts> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ChannelContexts"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            HoldCallResponseBodyDataCallContextChannelContexts model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        channelContexts = make_shared<vector<HoldCallResponseBodyDataCallContextChannelContexts>>(expect1);
      }
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
  }


  virtual ~HoldCallResponseBodyDataCallContext() = default;
};
class HoldCallResponseBodyDataUserContext : public Darabonba::Model {
public:
  shared_ptr<string> breakCode{};
  shared_ptr<string> deviceId{};
  shared_ptr<string> extension{};
  shared_ptr<long> heartbeat{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> jobId{};
  shared_ptr<string> mobile{};
  shared_ptr<bool> outboundScenario{};
  shared_ptr<long> reserved{};
  shared_ptr<vector<string>> signedSkillGroupIdList{};
  shared_ptr<string> userId{};
  shared_ptr<string> userState{};
  shared_ptr<string> workMode{};

  HoldCallResponseBodyDataUserContext() {}

  explicit HoldCallResponseBodyDataUserContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (breakCode) {
      res["BreakCode"] = boost::any(*breakCode);
    }
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (extension) {
      res["Extension"] = boost::any(*extension);
    }
    if (heartbeat) {
      res["Heartbeat"] = boost::any(*heartbeat);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (mobile) {
      res["Mobile"] = boost::any(*mobile);
    }
    if (outboundScenario) {
      res["OutboundScenario"] = boost::any(*outboundScenario);
    }
    if (reserved) {
      res["Reserved"] = boost::any(*reserved);
    }
    if (signedSkillGroupIdList) {
      res["SignedSkillGroupIdList"] = boost::any(*signedSkillGroupIdList);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (userState) {
      res["UserState"] = boost::any(*userState);
    }
    if (workMode) {
      res["WorkMode"] = boost::any(*workMode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BreakCode") != m.end() && !m["BreakCode"].empty()) {
      breakCode = make_shared<string>(boost::any_cast<string>(m["BreakCode"]));
    }
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("Extension") != m.end() && !m["Extension"].empty()) {
      extension = make_shared<string>(boost::any_cast<string>(m["Extension"]));
    }
    if (m.find("Heartbeat") != m.end() && !m["Heartbeat"].empty()) {
      heartbeat = make_shared<long>(boost::any_cast<long>(m["Heartbeat"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("Mobile") != m.end() && !m["Mobile"].empty()) {
      mobile = make_shared<string>(boost::any_cast<string>(m["Mobile"]));
    }
    if (m.find("OutboundScenario") != m.end() && !m["OutboundScenario"].empty()) {
      outboundScenario = make_shared<bool>(boost::any_cast<bool>(m["OutboundScenario"]));
    }
    if (m.find("Reserved") != m.end() && !m["Reserved"].empty()) {
      reserved = make_shared<long>(boost::any_cast<long>(m["Reserved"]));
    }
    if (m.find("SignedSkillGroupIdList") != m.end() && !m["SignedSkillGroupIdList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SignedSkillGroupIdList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SignedSkillGroupIdList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      signedSkillGroupIdList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
    if (m.find("UserState") != m.end() && !m["UserState"].empty()) {
      userState = make_shared<string>(boost::any_cast<string>(m["UserState"]));
    }
    if (m.find("WorkMode") != m.end() && !m["WorkMode"].empty()) {
      workMode = make_shared<string>(boost::any_cast<string>(m["WorkMode"]));
    }
  }


  virtual ~HoldCallResponseBodyDataUserContext() = default;
};
class HoldCallResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<HoldCallResponseBodyDataCallContext> callContext{};
  shared_ptr<HoldCallResponseBodyDataUserContext> userContext{};

  HoldCallResponseBodyData() {}

  explicit HoldCallResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callContext) {
      res["CallContext"] = callContext ? boost::any(callContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (userContext) {
      res["UserContext"] = userContext ? boost::any(userContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallContext") != m.end() && !m["CallContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["CallContext"].type()) {
        HoldCallResponseBodyDataCallContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CallContext"]));
        callContext = make_shared<HoldCallResponseBodyDataCallContext>(model1);
      }
    }
    if (m.find("UserContext") != m.end() && !m["UserContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["UserContext"].type()) {
        HoldCallResponseBodyDataUserContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["UserContext"]));
        userContext = make_shared<HoldCallResponseBodyDataUserContext>(model1);
      }
    }
  }


  virtual ~HoldCallResponseBodyData() = default;
};
class HoldCallResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<HoldCallResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<vector<string>> params{};
  shared_ptr<string> requestId{};

  HoldCallResponseBody() {}

  explicit HoldCallResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (params) {
      res["Params"] = boost::any(*params);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        HoldCallResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<HoldCallResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Params") != m.end() && !m["Params"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Params"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Params"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      params = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~HoldCallResponseBody() = default;
};
class HoldCallResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<HoldCallResponseBody> body{};

  HoldCallResponse() {}

  explicit HoldCallResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        HoldCallResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<HoldCallResponseBody>(model1);
      }
    }
  }


  virtual ~HoldCallResponse() = default;
};
class ImportAdminsRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> ramIdList{};

  ImportAdminsRequest() {}

  explicit ImportAdminsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (ramIdList) {
      res["RamIdList"] = boost::any(*ramIdList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RamIdList") != m.end() && !m["RamIdList"].empty()) {
      ramIdList = make_shared<string>(boost::any_cast<string>(m["RamIdList"]));
    }
  }


  virtual ~ImportAdminsRequest() = default;
};
class ImportAdminsResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> extension{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> ramId{};
  shared_ptr<string> roleId{};
  shared_ptr<string> userId{};

  ImportAdminsResponseBodyData() {}

  explicit ImportAdminsResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (extension) {
      res["Extension"] = boost::any(*extension);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (ramId) {
      res["RamId"] = boost::any(*ramId);
    }
    if (roleId) {
      res["RoleId"] = boost::any(*roleId);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Extension") != m.end() && !m["Extension"].empty()) {
      extension = make_shared<string>(boost::any_cast<string>(m["Extension"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("RamId") != m.end() && !m["RamId"].empty()) {
      ramId = make_shared<string>(boost::any_cast<string>(m["RamId"]));
    }
    if (m.find("RoleId") != m.end() && !m["RoleId"].empty()) {
      roleId = make_shared<string>(boost::any_cast<string>(m["RoleId"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~ImportAdminsResponseBodyData() = default;
};
class ImportAdminsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<vector<ImportAdminsResponseBodyData>> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  ImportAdminsResponseBody() {}

  explicit ImportAdminsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<ImportAdminsResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ImportAdminsResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<ImportAdminsResponseBodyData>>(expect1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ImportAdminsResponseBody() = default;
};
class ImportAdminsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ImportAdminsResponseBody> body{};

  ImportAdminsResponse() {}

  explicit ImportAdminsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ImportAdminsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ImportAdminsResponseBody>(model1);
      }
    }
  }


  virtual ~ImportAdminsResponse() = default;
};
class ImportCustomCallTaggingRequest : public Darabonba::Model {
public:
  shared_ptr<string> filePath{};
  shared_ptr<string> instanceId{};

  ImportCustomCallTaggingRequest() {}

  explicit ImportCustomCallTaggingRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (filePath) {
      res["FilePath"] = boost::any(*filePath);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FilePath") != m.end() && !m["FilePath"].empty()) {
      filePath = make_shared<string>(boost::any_cast<string>(m["FilePath"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~ImportCustomCallTaggingRequest() = default;
};
class ImportCustomCallTaggingResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> item{};
  shared_ptr<string> reason{};

  ImportCustomCallTaggingResponseBodyData() {}

  explicit ImportCustomCallTaggingResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (item) {
      res["Item"] = boost::any(*item);
    }
    if (reason) {
      res["Reason"] = boost::any(*reason);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Item") != m.end() && !m["Item"].empty()) {
      item = make_shared<string>(boost::any_cast<string>(m["Item"]));
    }
    if (m.find("Reason") != m.end() && !m["Reason"].empty()) {
      reason = make_shared<string>(boost::any_cast<string>(m["Reason"]));
    }
  }


  virtual ~ImportCustomCallTaggingResponseBodyData() = default;
};
class ImportCustomCallTaggingResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<vector<ImportCustomCallTaggingResponseBodyData>> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  ImportCustomCallTaggingResponseBody() {}

  explicit ImportCustomCallTaggingResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<ImportCustomCallTaggingResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ImportCustomCallTaggingResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<ImportCustomCallTaggingResponseBodyData>>(expect1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ImportCustomCallTaggingResponseBody() = default;
};
class ImportCustomCallTaggingResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ImportCustomCallTaggingResponseBody> body{};

  ImportCustomCallTaggingResponse() {}

  explicit ImportCustomCallTaggingResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ImportCustomCallTaggingResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ImportCustomCallTaggingResponseBody>(model1);
      }
    }
  }


  virtual ~ImportCustomCallTaggingResponse() = default;
};
class ImportDoNotCallNumbersRequest : public Darabonba::Model {
public:
  shared_ptr<string> filePath{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> numberList{};
  shared_ptr<string> remark{};

  ImportDoNotCallNumbersRequest() {}

  explicit ImportDoNotCallNumbersRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (filePath) {
      res["FilePath"] = boost::any(*filePath);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (numberList) {
      res["NumberList"] = boost::any(*numberList);
    }
    if (remark) {
      res["Remark"] = boost::any(*remark);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FilePath") != m.end() && !m["FilePath"].empty()) {
      filePath = make_shared<string>(boost::any_cast<string>(m["FilePath"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("NumberList") != m.end() && !m["NumberList"].empty()) {
      numberList = make_shared<string>(boost::any_cast<string>(m["NumberList"]));
    }
    if (m.find("Remark") != m.end() && !m["Remark"].empty()) {
      remark = make_shared<string>(boost::any_cast<string>(m["Remark"]));
    }
  }


  virtual ~ImportDoNotCallNumbersRequest() = default;
};
class ImportDoNotCallNumbersResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  ImportDoNotCallNumbersResponseBody() {}

  explicit ImportDoNotCallNumbersResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ImportDoNotCallNumbersResponseBody() = default;
};
class ImportDoNotCallNumbersResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ImportDoNotCallNumbersResponseBody> body{};

  ImportDoNotCallNumbersResponse() {}

  explicit ImportDoNotCallNumbersResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ImportDoNotCallNumbersResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ImportDoNotCallNumbersResponseBody>(model1);
      }
    }
  }


  virtual ~ImportDoNotCallNumbersResponse() = default;
};
class InitiateAttendedTransferRequest : public Darabonba::Model {
public:
  shared_ptr<string> deviceId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> jobId{};
  shared_ptr<long> timeoutSeconds{};
  shared_ptr<string> transferee{};
  shared_ptr<string> transferor{};
  shared_ptr<string> userId{};

  InitiateAttendedTransferRequest() {}

  explicit InitiateAttendedTransferRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (timeoutSeconds) {
      res["TimeoutSeconds"] = boost::any(*timeoutSeconds);
    }
    if (transferee) {
      res["Transferee"] = boost::any(*transferee);
    }
    if (transferor) {
      res["Transferor"] = boost::any(*transferor);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("TimeoutSeconds") != m.end() && !m["TimeoutSeconds"].empty()) {
      timeoutSeconds = make_shared<long>(boost::any_cast<long>(m["TimeoutSeconds"]));
    }
    if (m.find("Transferee") != m.end() && !m["Transferee"].empty()) {
      transferee = make_shared<string>(boost::any_cast<string>(m["Transferee"]));
    }
    if (m.find("Transferor") != m.end() && !m["Transferor"].empty()) {
      transferor = make_shared<string>(boost::any_cast<string>(m["Transferor"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~InitiateAttendedTransferRequest() = default;
};
class InitiateAttendedTransferResponseBodyDataCallContextChannelContexts : public Darabonba::Model {
public:
  shared_ptr<string> callType{};
  shared_ptr<string> channelFlags{};
  shared_ptr<string> channelId{};
  shared_ptr<string> channelState{};
  shared_ptr<string> destination{};
  shared_ptr<long> index{};
  shared_ptr<string> jobId{};
  shared_ptr<string> originator{};
  shared_ptr<string> releaseInitiator{};
  shared_ptr<string> releaseReason{};
  shared_ptr<string> skillGroupId{};
  shared_ptr<long> timestamp{};
  shared_ptr<string> userExtension{};
  shared_ptr<string> userId{};

  InitiateAttendedTransferResponseBodyDataCallContextChannelContexts() {}

  explicit InitiateAttendedTransferResponseBodyDataCallContextChannelContexts(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callType) {
      res["CallType"] = boost::any(*callType);
    }
    if (channelFlags) {
      res["ChannelFlags"] = boost::any(*channelFlags);
    }
    if (channelId) {
      res["ChannelId"] = boost::any(*channelId);
    }
    if (channelState) {
      res["ChannelState"] = boost::any(*channelState);
    }
    if (destination) {
      res["Destination"] = boost::any(*destination);
    }
    if (index) {
      res["Index"] = boost::any(*index);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (originator) {
      res["Originator"] = boost::any(*originator);
    }
    if (releaseInitiator) {
      res["ReleaseInitiator"] = boost::any(*releaseInitiator);
    }
    if (releaseReason) {
      res["ReleaseReason"] = boost::any(*releaseReason);
    }
    if (skillGroupId) {
      res["SkillGroupId"] = boost::any(*skillGroupId);
    }
    if (timestamp) {
      res["Timestamp"] = boost::any(*timestamp);
    }
    if (userExtension) {
      res["UserExtension"] = boost::any(*userExtension);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallType") != m.end() && !m["CallType"].empty()) {
      callType = make_shared<string>(boost::any_cast<string>(m["CallType"]));
    }
    if (m.find("ChannelFlags") != m.end() && !m["ChannelFlags"].empty()) {
      channelFlags = make_shared<string>(boost::any_cast<string>(m["ChannelFlags"]));
    }
    if (m.find("ChannelId") != m.end() && !m["ChannelId"].empty()) {
      channelId = make_shared<string>(boost::any_cast<string>(m["ChannelId"]));
    }
    if (m.find("ChannelState") != m.end() && !m["ChannelState"].empty()) {
      channelState = make_shared<string>(boost::any_cast<string>(m["ChannelState"]));
    }
    if (m.find("Destination") != m.end() && !m["Destination"].empty()) {
      destination = make_shared<string>(boost::any_cast<string>(m["Destination"]));
    }
    if (m.find("Index") != m.end() && !m["Index"].empty()) {
      index = make_shared<long>(boost::any_cast<long>(m["Index"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("Originator") != m.end() && !m["Originator"].empty()) {
      originator = make_shared<string>(boost::any_cast<string>(m["Originator"]));
    }
    if (m.find("ReleaseInitiator") != m.end() && !m["ReleaseInitiator"].empty()) {
      releaseInitiator = make_shared<string>(boost::any_cast<string>(m["ReleaseInitiator"]));
    }
    if (m.find("ReleaseReason") != m.end() && !m["ReleaseReason"].empty()) {
      releaseReason = make_shared<string>(boost::any_cast<string>(m["ReleaseReason"]));
    }
    if (m.find("SkillGroupId") != m.end() && !m["SkillGroupId"].empty()) {
      skillGroupId = make_shared<string>(boost::any_cast<string>(m["SkillGroupId"]));
    }
    if (m.find("Timestamp") != m.end() && !m["Timestamp"].empty()) {
      timestamp = make_shared<long>(boost::any_cast<long>(m["Timestamp"]));
    }
    if (m.find("UserExtension") != m.end() && !m["UserExtension"].empty()) {
      userExtension = make_shared<string>(boost::any_cast<string>(m["UserExtension"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~InitiateAttendedTransferResponseBodyDataCallContextChannelContexts() = default;
};
class InitiateAttendedTransferResponseBodyDataCallContext : public Darabonba::Model {
public:
  shared_ptr<string> callType{};
  shared_ptr<vector<InitiateAttendedTransferResponseBodyDataCallContextChannelContexts>> channelContexts{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> jobId{};

  InitiateAttendedTransferResponseBodyDataCallContext() {}

  explicit InitiateAttendedTransferResponseBodyDataCallContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callType) {
      res["CallType"] = boost::any(*callType);
    }
    if (channelContexts) {
      vector<boost::any> temp1;
      for(auto item1:*channelContexts){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ChannelContexts"] = boost::any(temp1);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallType") != m.end() && !m["CallType"].empty()) {
      callType = make_shared<string>(boost::any_cast<string>(m["CallType"]));
    }
    if (m.find("ChannelContexts") != m.end() && !m["ChannelContexts"].empty()) {
      if (typeid(vector<boost::any>) == m["ChannelContexts"].type()) {
        vector<InitiateAttendedTransferResponseBodyDataCallContextChannelContexts> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ChannelContexts"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            InitiateAttendedTransferResponseBodyDataCallContextChannelContexts model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        channelContexts = make_shared<vector<InitiateAttendedTransferResponseBodyDataCallContextChannelContexts>>(expect1);
      }
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
  }


  virtual ~InitiateAttendedTransferResponseBodyDataCallContext() = default;
};
class InitiateAttendedTransferResponseBodyDataUserContext : public Darabonba::Model {
public:
  shared_ptr<string> breakCode{};
  shared_ptr<string> deviceId{};
  shared_ptr<string> extension{};
  shared_ptr<long> heartbeat{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> jobId{};
  shared_ptr<string> mobile{};
  shared_ptr<bool> outboundScenario{};
  shared_ptr<long> reserved{};
  shared_ptr<vector<string>> signedSkillGroupIdList{};
  shared_ptr<string> userId{};
  shared_ptr<string> userState{};
  shared_ptr<string> workMode{};

  InitiateAttendedTransferResponseBodyDataUserContext() {}

  explicit InitiateAttendedTransferResponseBodyDataUserContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (breakCode) {
      res["BreakCode"] = boost::any(*breakCode);
    }
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (extension) {
      res["Extension"] = boost::any(*extension);
    }
    if (heartbeat) {
      res["Heartbeat"] = boost::any(*heartbeat);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (mobile) {
      res["Mobile"] = boost::any(*mobile);
    }
    if (outboundScenario) {
      res["OutboundScenario"] = boost::any(*outboundScenario);
    }
    if (reserved) {
      res["Reserved"] = boost::any(*reserved);
    }
    if (signedSkillGroupIdList) {
      res["SignedSkillGroupIdList"] = boost::any(*signedSkillGroupIdList);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (userState) {
      res["UserState"] = boost::any(*userState);
    }
    if (workMode) {
      res["WorkMode"] = boost::any(*workMode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BreakCode") != m.end() && !m["BreakCode"].empty()) {
      breakCode = make_shared<string>(boost::any_cast<string>(m["BreakCode"]));
    }
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("Extension") != m.end() && !m["Extension"].empty()) {
      extension = make_shared<string>(boost::any_cast<string>(m["Extension"]));
    }
    if (m.find("Heartbeat") != m.end() && !m["Heartbeat"].empty()) {
      heartbeat = make_shared<long>(boost::any_cast<long>(m["Heartbeat"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("Mobile") != m.end() && !m["Mobile"].empty()) {
      mobile = make_shared<string>(boost::any_cast<string>(m["Mobile"]));
    }
    if (m.find("OutboundScenario") != m.end() && !m["OutboundScenario"].empty()) {
      outboundScenario = make_shared<bool>(boost::any_cast<bool>(m["OutboundScenario"]));
    }
    if (m.find("Reserved") != m.end() && !m["Reserved"].empty()) {
      reserved = make_shared<long>(boost::any_cast<long>(m["Reserved"]));
    }
    if (m.find("SignedSkillGroupIdList") != m.end() && !m["SignedSkillGroupIdList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SignedSkillGroupIdList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SignedSkillGroupIdList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      signedSkillGroupIdList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
    if (m.find("UserState") != m.end() && !m["UserState"].empty()) {
      userState = make_shared<string>(boost::any_cast<string>(m["UserState"]));
    }
    if (m.find("WorkMode") != m.end() && !m["WorkMode"].empty()) {
      workMode = make_shared<string>(boost::any_cast<string>(m["WorkMode"]));
    }
  }


  virtual ~InitiateAttendedTransferResponseBodyDataUserContext() = default;
};
class InitiateAttendedTransferResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<InitiateAttendedTransferResponseBodyDataCallContext> callContext{};
  shared_ptr<long> contextId{};
  shared_ptr<InitiateAttendedTransferResponseBodyDataUserContext> userContext{};

  InitiateAttendedTransferResponseBodyData() {}

  explicit InitiateAttendedTransferResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callContext) {
      res["CallContext"] = callContext ? boost::any(callContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (contextId) {
      res["ContextId"] = boost::any(*contextId);
    }
    if (userContext) {
      res["UserContext"] = userContext ? boost::any(userContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallContext") != m.end() && !m["CallContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["CallContext"].type()) {
        InitiateAttendedTransferResponseBodyDataCallContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CallContext"]));
        callContext = make_shared<InitiateAttendedTransferResponseBodyDataCallContext>(model1);
      }
    }
    if (m.find("ContextId") != m.end() && !m["ContextId"].empty()) {
      contextId = make_shared<long>(boost::any_cast<long>(m["ContextId"]));
    }
    if (m.find("UserContext") != m.end() && !m["UserContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["UserContext"].type()) {
        InitiateAttendedTransferResponseBodyDataUserContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["UserContext"]));
        userContext = make_shared<InitiateAttendedTransferResponseBodyDataUserContext>(model1);
      }
    }
  }


  virtual ~InitiateAttendedTransferResponseBodyData() = default;
};
class InitiateAttendedTransferResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<InitiateAttendedTransferResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<vector<string>> params{};
  shared_ptr<string> requestId{};

  InitiateAttendedTransferResponseBody() {}

  explicit InitiateAttendedTransferResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (params) {
      res["Params"] = boost::any(*params);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        InitiateAttendedTransferResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<InitiateAttendedTransferResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Params") != m.end() && !m["Params"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Params"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Params"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      params = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~InitiateAttendedTransferResponseBody() = default;
};
class InitiateAttendedTransferResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<InitiateAttendedTransferResponseBody> body{};

  InitiateAttendedTransferResponse() {}

  explicit InitiateAttendedTransferResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        InitiateAttendedTransferResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<InitiateAttendedTransferResponseBody>(model1);
      }
    }
  }


  virtual ~InitiateAttendedTransferResponse() = default;
};
class InterceptCallRequest : public Darabonba::Model {
public:
  shared_ptr<string> deviceId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> interceptedUserId{};
  shared_ptr<string> jobId{};
  shared_ptr<long> timeoutSeconds{};
  shared_ptr<string> userId{};

  InterceptCallRequest() {}

  explicit InterceptCallRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (interceptedUserId) {
      res["InterceptedUserId"] = boost::any(*interceptedUserId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (timeoutSeconds) {
      res["TimeoutSeconds"] = boost::any(*timeoutSeconds);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("InterceptedUserId") != m.end() && !m["InterceptedUserId"].empty()) {
      interceptedUserId = make_shared<string>(boost::any_cast<string>(m["InterceptedUserId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("TimeoutSeconds") != m.end() && !m["TimeoutSeconds"].empty()) {
      timeoutSeconds = make_shared<long>(boost::any_cast<long>(m["TimeoutSeconds"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~InterceptCallRequest() = default;
};
class InterceptCallResponseBodyDataCallContextChannelContexts : public Darabonba::Model {
public:
  shared_ptr<string> callType{};
  shared_ptr<string> channelFlags{};
  shared_ptr<string> channelId{};
  shared_ptr<string> channelState{};
  shared_ptr<string> destination{};
  shared_ptr<long> index{};
  shared_ptr<string> jobId{};
  shared_ptr<string> originator{};
  shared_ptr<string> releaseInitiator{};
  shared_ptr<string> releaseReason{};
  shared_ptr<string> skillGroupId{};
  shared_ptr<long> timestamp{};
  shared_ptr<string> userExtension{};
  shared_ptr<string> userId{};

  InterceptCallResponseBodyDataCallContextChannelContexts() {}

  explicit InterceptCallResponseBodyDataCallContextChannelContexts(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callType) {
      res["CallType"] = boost::any(*callType);
    }
    if (channelFlags) {
      res["ChannelFlags"] = boost::any(*channelFlags);
    }
    if (channelId) {
      res["ChannelId"] = boost::any(*channelId);
    }
    if (channelState) {
      res["ChannelState"] = boost::any(*channelState);
    }
    if (destination) {
      res["Destination"] = boost::any(*destination);
    }
    if (index) {
      res["Index"] = boost::any(*index);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (originator) {
      res["Originator"] = boost::any(*originator);
    }
    if (releaseInitiator) {
      res["ReleaseInitiator"] = boost::any(*releaseInitiator);
    }
    if (releaseReason) {
      res["ReleaseReason"] = boost::any(*releaseReason);
    }
    if (skillGroupId) {
      res["SkillGroupId"] = boost::any(*skillGroupId);
    }
    if (timestamp) {
      res["Timestamp"] = boost::any(*timestamp);
    }
    if (userExtension) {
      res["UserExtension"] = boost::any(*userExtension);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallType") != m.end() && !m["CallType"].empty()) {
      callType = make_shared<string>(boost::any_cast<string>(m["CallType"]));
    }
    if (m.find("ChannelFlags") != m.end() && !m["ChannelFlags"].empty()) {
      channelFlags = make_shared<string>(boost::any_cast<string>(m["ChannelFlags"]));
    }
    if (m.find("ChannelId") != m.end() && !m["ChannelId"].empty()) {
      channelId = make_shared<string>(boost::any_cast<string>(m["ChannelId"]));
    }
    if (m.find("ChannelState") != m.end() && !m["ChannelState"].empty()) {
      channelState = make_shared<string>(boost::any_cast<string>(m["ChannelState"]));
    }
    if (m.find("Destination") != m.end() && !m["Destination"].empty()) {
      destination = make_shared<string>(boost::any_cast<string>(m["Destination"]));
    }
    if (m.find("Index") != m.end() && !m["Index"].empty()) {
      index = make_shared<long>(boost::any_cast<long>(m["Index"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("Originator") != m.end() && !m["Originator"].empty()) {
      originator = make_shared<string>(boost::any_cast<string>(m["Originator"]));
    }
    if (m.find("ReleaseInitiator") != m.end() && !m["ReleaseInitiator"].empty()) {
      releaseInitiator = make_shared<string>(boost::any_cast<string>(m["ReleaseInitiator"]));
    }
    if (m.find("ReleaseReason") != m.end() && !m["ReleaseReason"].empty()) {
      releaseReason = make_shared<string>(boost::any_cast<string>(m["ReleaseReason"]));
    }
    if (m.find("SkillGroupId") != m.end() && !m["SkillGroupId"].empty()) {
      skillGroupId = make_shared<string>(boost::any_cast<string>(m["SkillGroupId"]));
    }
    if (m.find("Timestamp") != m.end() && !m["Timestamp"].empty()) {
      timestamp = make_shared<long>(boost::any_cast<long>(m["Timestamp"]));
    }
    if (m.find("UserExtension") != m.end() && !m["UserExtension"].empty()) {
      userExtension = make_shared<string>(boost::any_cast<string>(m["UserExtension"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~InterceptCallResponseBodyDataCallContextChannelContexts() = default;
};
class InterceptCallResponseBodyDataCallContext : public Darabonba::Model {
public:
  shared_ptr<string> callType{};
  shared_ptr<vector<InterceptCallResponseBodyDataCallContextChannelContexts>> channelContexts{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> jobId{};

  InterceptCallResponseBodyDataCallContext() {}

  explicit InterceptCallResponseBodyDataCallContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callType) {
      res["CallType"] = boost::any(*callType);
    }
    if (channelContexts) {
      vector<boost::any> temp1;
      for(auto item1:*channelContexts){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ChannelContexts"] = boost::any(temp1);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallType") != m.end() && !m["CallType"].empty()) {
      callType = make_shared<string>(boost::any_cast<string>(m["CallType"]));
    }
    if (m.find("ChannelContexts") != m.end() && !m["ChannelContexts"].empty()) {
      if (typeid(vector<boost::any>) == m["ChannelContexts"].type()) {
        vector<InterceptCallResponseBodyDataCallContextChannelContexts> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ChannelContexts"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            InterceptCallResponseBodyDataCallContextChannelContexts model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        channelContexts = make_shared<vector<InterceptCallResponseBodyDataCallContextChannelContexts>>(expect1);
      }
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
  }


  virtual ~InterceptCallResponseBodyDataCallContext() = default;
};
class InterceptCallResponseBodyDataUserContext : public Darabonba::Model {
public:
  shared_ptr<string> breakCode{};
  shared_ptr<string> deviceId{};
  shared_ptr<string> extension{};
  shared_ptr<long> heartbeat{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> jobId{};
  shared_ptr<string> mobile{};
  shared_ptr<bool> outboundScenario{};
  shared_ptr<long> reserved{};
  shared_ptr<vector<string>> signedSkillGroupIdList{};
  shared_ptr<string> userId{};
  shared_ptr<string> userState{};
  shared_ptr<string> workMode{};

  InterceptCallResponseBodyDataUserContext() {}

  explicit InterceptCallResponseBodyDataUserContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (breakCode) {
      res["BreakCode"] = boost::any(*breakCode);
    }
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (extension) {
      res["Extension"] = boost::any(*extension);
    }
    if (heartbeat) {
      res["Heartbeat"] = boost::any(*heartbeat);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (mobile) {
      res["Mobile"] = boost::any(*mobile);
    }
    if (outboundScenario) {
      res["OutboundScenario"] = boost::any(*outboundScenario);
    }
    if (reserved) {
      res["Reserved"] = boost::any(*reserved);
    }
    if (signedSkillGroupIdList) {
      res["SignedSkillGroupIdList"] = boost::any(*signedSkillGroupIdList);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (userState) {
      res["UserState"] = boost::any(*userState);
    }
    if (workMode) {
      res["WorkMode"] = boost::any(*workMode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BreakCode") != m.end() && !m["BreakCode"].empty()) {
      breakCode = make_shared<string>(boost::any_cast<string>(m["BreakCode"]));
    }
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("Extension") != m.end() && !m["Extension"].empty()) {
      extension = make_shared<string>(boost::any_cast<string>(m["Extension"]));
    }
    if (m.find("Heartbeat") != m.end() && !m["Heartbeat"].empty()) {
      heartbeat = make_shared<long>(boost::any_cast<long>(m["Heartbeat"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("Mobile") != m.end() && !m["Mobile"].empty()) {
      mobile = make_shared<string>(boost::any_cast<string>(m["Mobile"]));
    }
    if (m.find("OutboundScenario") != m.end() && !m["OutboundScenario"].empty()) {
      outboundScenario = make_shared<bool>(boost::any_cast<bool>(m["OutboundScenario"]));
    }
    if (m.find("Reserved") != m.end() && !m["Reserved"].empty()) {
      reserved = make_shared<long>(boost::any_cast<long>(m["Reserved"]));
    }
    if (m.find("SignedSkillGroupIdList") != m.end() && !m["SignedSkillGroupIdList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SignedSkillGroupIdList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SignedSkillGroupIdList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      signedSkillGroupIdList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
    if (m.find("UserState") != m.end() && !m["UserState"].empty()) {
      userState = make_shared<string>(boost::any_cast<string>(m["UserState"]));
    }
    if (m.find("WorkMode") != m.end() && !m["WorkMode"].empty()) {
      workMode = make_shared<string>(boost::any_cast<string>(m["WorkMode"]));
    }
  }


  virtual ~InterceptCallResponseBodyDataUserContext() = default;
};
class InterceptCallResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<InterceptCallResponseBodyDataCallContext> callContext{};
  shared_ptr<InterceptCallResponseBodyDataUserContext> userContext{};

  InterceptCallResponseBodyData() {}

  explicit InterceptCallResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callContext) {
      res["CallContext"] = callContext ? boost::any(callContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (userContext) {
      res["UserContext"] = userContext ? boost::any(userContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallContext") != m.end() && !m["CallContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["CallContext"].type()) {
        InterceptCallResponseBodyDataCallContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CallContext"]));
        callContext = make_shared<InterceptCallResponseBodyDataCallContext>(model1);
      }
    }
    if (m.find("UserContext") != m.end() && !m["UserContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["UserContext"].type()) {
        InterceptCallResponseBodyDataUserContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["UserContext"]));
        userContext = make_shared<InterceptCallResponseBodyDataUserContext>(model1);
      }
    }
  }


  virtual ~InterceptCallResponseBodyData() = default;
};
class InterceptCallResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<InterceptCallResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<vector<string>> params{};
  shared_ptr<string> requestId{};

  InterceptCallResponseBody() {}

  explicit InterceptCallResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (params) {
      res["Params"] = boost::any(*params);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        InterceptCallResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<InterceptCallResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Params") != m.end() && !m["Params"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Params"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Params"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      params = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~InterceptCallResponseBody() = default;
};
class InterceptCallResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<InterceptCallResponseBody> body{};

  InterceptCallResponse() {}

  explicit InterceptCallResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        InterceptCallResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<InterceptCallResponseBody>(model1);
      }
    }
  }


  virtual ~InterceptCallResponse() = default;
};
class LaunchAuthenticationRequest : public Darabonba::Model {
public:
  shared_ptr<string> contactFlowId{};
  shared_ptr<string> contactFlowVariables{};
  shared_ptr<string> deviceId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> jobId{};
  shared_ptr<string> userId{};

  LaunchAuthenticationRequest() {}

  explicit LaunchAuthenticationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contactFlowId) {
      res["ContactFlowId"] = boost::any(*contactFlowId);
    }
    if (contactFlowVariables) {
      res["ContactFlowVariables"] = boost::any(*contactFlowVariables);
    }
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ContactFlowId") != m.end() && !m["ContactFlowId"].empty()) {
      contactFlowId = make_shared<string>(boost::any_cast<string>(m["ContactFlowId"]));
    }
    if (m.find("ContactFlowVariables") != m.end() && !m["ContactFlowVariables"].empty()) {
      contactFlowVariables = make_shared<string>(boost::any_cast<string>(m["ContactFlowVariables"]));
    }
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~LaunchAuthenticationRequest() = default;
};
class LaunchAuthenticationResponseBodyDataCallContextChannelContexts : public Darabonba::Model {
public:
  shared_ptr<string> callType{};
  shared_ptr<string> channelFlags{};
  shared_ptr<string> channelId{};
  shared_ptr<string> channelState{};
  shared_ptr<string> destination{};
  shared_ptr<long> index{};
  shared_ptr<string> jobId{};
  shared_ptr<string> originator{};
  shared_ptr<string> releaseInitiator{};
  shared_ptr<string> releaseReason{};
  shared_ptr<string> skillGroupId{};
  shared_ptr<long> timestamp{};
  shared_ptr<string> userExtension{};
  shared_ptr<string> userId{};

  LaunchAuthenticationResponseBodyDataCallContextChannelContexts() {}

  explicit LaunchAuthenticationResponseBodyDataCallContextChannelContexts(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callType) {
      res["CallType"] = boost::any(*callType);
    }
    if (channelFlags) {
      res["ChannelFlags"] = boost::any(*channelFlags);
    }
    if (channelId) {
      res["ChannelId"] = boost::any(*channelId);
    }
    if (channelState) {
      res["ChannelState"] = boost::any(*channelState);
    }
    if (destination) {
      res["Destination"] = boost::any(*destination);
    }
    if (index) {
      res["Index"] = boost::any(*index);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (originator) {
      res["Originator"] = boost::any(*originator);
    }
    if (releaseInitiator) {
      res["ReleaseInitiator"] = boost::any(*releaseInitiator);
    }
    if (releaseReason) {
      res["ReleaseReason"] = boost::any(*releaseReason);
    }
    if (skillGroupId) {
      res["SkillGroupId"] = boost::any(*skillGroupId);
    }
    if (timestamp) {
      res["Timestamp"] = boost::any(*timestamp);
    }
    if (userExtension) {
      res["UserExtension"] = boost::any(*userExtension);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallType") != m.end() && !m["CallType"].empty()) {
      callType = make_shared<string>(boost::any_cast<string>(m["CallType"]));
    }
    if (m.find("ChannelFlags") != m.end() && !m["ChannelFlags"].empty()) {
      channelFlags = make_shared<string>(boost::any_cast<string>(m["ChannelFlags"]));
    }
    if (m.find("ChannelId") != m.end() && !m["ChannelId"].empty()) {
      channelId = make_shared<string>(boost::any_cast<string>(m["ChannelId"]));
    }
    if (m.find("ChannelState") != m.end() && !m["ChannelState"].empty()) {
      channelState = make_shared<string>(boost::any_cast<string>(m["ChannelState"]));
    }
    if (m.find("Destination") != m.end() && !m["Destination"].empty()) {
      destination = make_shared<string>(boost::any_cast<string>(m["Destination"]));
    }
    if (m.find("Index") != m.end() && !m["Index"].empty()) {
      index = make_shared<long>(boost::any_cast<long>(m["Index"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("Originator") != m.end() && !m["Originator"].empty()) {
      originator = make_shared<string>(boost::any_cast<string>(m["Originator"]));
    }
    if (m.find("ReleaseInitiator") != m.end() && !m["ReleaseInitiator"].empty()) {
      releaseInitiator = make_shared<string>(boost::any_cast<string>(m["ReleaseInitiator"]));
    }
    if (m.find("ReleaseReason") != m.end() && !m["ReleaseReason"].empty()) {
      releaseReason = make_shared<string>(boost::any_cast<string>(m["ReleaseReason"]));
    }
    if (m.find("SkillGroupId") != m.end() && !m["SkillGroupId"].empty()) {
      skillGroupId = make_shared<string>(boost::any_cast<string>(m["SkillGroupId"]));
    }
    if (m.find("Timestamp") != m.end() && !m["Timestamp"].empty()) {
      timestamp = make_shared<long>(boost::any_cast<long>(m["Timestamp"]));
    }
    if (m.find("UserExtension") != m.end() && !m["UserExtension"].empty()) {
      userExtension = make_shared<string>(boost::any_cast<string>(m["UserExtension"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~LaunchAuthenticationResponseBodyDataCallContextChannelContexts() = default;
};
class LaunchAuthenticationResponseBodyDataCallContext : public Darabonba::Model {
public:
  shared_ptr<string> callType{};
  shared_ptr<vector<LaunchAuthenticationResponseBodyDataCallContextChannelContexts>> channelContexts{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> jobId{};

  LaunchAuthenticationResponseBodyDataCallContext() {}

  explicit LaunchAuthenticationResponseBodyDataCallContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callType) {
      res["CallType"] = boost::any(*callType);
    }
    if (channelContexts) {
      vector<boost::any> temp1;
      for(auto item1:*channelContexts){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ChannelContexts"] = boost::any(temp1);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallType") != m.end() && !m["CallType"].empty()) {
      callType = make_shared<string>(boost::any_cast<string>(m["CallType"]));
    }
    if (m.find("ChannelContexts") != m.end() && !m["ChannelContexts"].empty()) {
      if (typeid(vector<boost::any>) == m["ChannelContexts"].type()) {
        vector<LaunchAuthenticationResponseBodyDataCallContextChannelContexts> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ChannelContexts"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            LaunchAuthenticationResponseBodyDataCallContextChannelContexts model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        channelContexts = make_shared<vector<LaunchAuthenticationResponseBodyDataCallContextChannelContexts>>(expect1);
      }
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
  }


  virtual ~LaunchAuthenticationResponseBodyDataCallContext() = default;
};
class LaunchAuthenticationResponseBodyDataUserContext : public Darabonba::Model {
public:
  shared_ptr<string> breakCode{};
  shared_ptr<string> deviceId{};
  shared_ptr<string> extension{};
  shared_ptr<long> heartbeat{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> jobId{};
  shared_ptr<string> mobile{};
  shared_ptr<bool> outboundScenario{};
  shared_ptr<long> reserved{};
  shared_ptr<vector<string>> signedSkillGroupIdList{};
  shared_ptr<string> userId{};
  shared_ptr<string> userState{};
  shared_ptr<string> workMode{};

  LaunchAuthenticationResponseBodyDataUserContext() {}

  explicit LaunchAuthenticationResponseBodyDataUserContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (breakCode) {
      res["BreakCode"] = boost::any(*breakCode);
    }
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (extension) {
      res["Extension"] = boost::any(*extension);
    }
    if (heartbeat) {
      res["Heartbeat"] = boost::any(*heartbeat);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (mobile) {
      res["Mobile"] = boost::any(*mobile);
    }
    if (outboundScenario) {
      res["OutboundScenario"] = boost::any(*outboundScenario);
    }
    if (reserved) {
      res["Reserved"] = boost::any(*reserved);
    }
    if (signedSkillGroupIdList) {
      res["SignedSkillGroupIdList"] = boost::any(*signedSkillGroupIdList);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (userState) {
      res["UserState"] = boost::any(*userState);
    }
    if (workMode) {
      res["WorkMode"] = boost::any(*workMode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BreakCode") != m.end() && !m["BreakCode"].empty()) {
      breakCode = make_shared<string>(boost::any_cast<string>(m["BreakCode"]));
    }
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("Extension") != m.end() && !m["Extension"].empty()) {
      extension = make_shared<string>(boost::any_cast<string>(m["Extension"]));
    }
    if (m.find("Heartbeat") != m.end() && !m["Heartbeat"].empty()) {
      heartbeat = make_shared<long>(boost::any_cast<long>(m["Heartbeat"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("Mobile") != m.end() && !m["Mobile"].empty()) {
      mobile = make_shared<string>(boost::any_cast<string>(m["Mobile"]));
    }
    if (m.find("OutboundScenario") != m.end() && !m["OutboundScenario"].empty()) {
      outboundScenario = make_shared<bool>(boost::any_cast<bool>(m["OutboundScenario"]));
    }
    if (m.find("Reserved") != m.end() && !m["Reserved"].empty()) {
      reserved = make_shared<long>(boost::any_cast<long>(m["Reserved"]));
    }
    if (m.find("SignedSkillGroupIdList") != m.end() && !m["SignedSkillGroupIdList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SignedSkillGroupIdList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SignedSkillGroupIdList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      signedSkillGroupIdList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
    if (m.find("UserState") != m.end() && !m["UserState"].empty()) {
      userState = make_shared<string>(boost::any_cast<string>(m["UserState"]));
    }
    if (m.find("WorkMode") != m.end() && !m["WorkMode"].empty()) {
      workMode = make_shared<string>(boost::any_cast<string>(m["WorkMode"]));
    }
  }


  virtual ~LaunchAuthenticationResponseBodyDataUserContext() = default;
};
class LaunchAuthenticationResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<LaunchAuthenticationResponseBodyDataCallContext> callContext{};
  shared_ptr<LaunchAuthenticationResponseBodyDataUserContext> userContext{};

  LaunchAuthenticationResponseBodyData() {}

  explicit LaunchAuthenticationResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callContext) {
      res["CallContext"] = callContext ? boost::any(callContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (userContext) {
      res["UserContext"] = userContext ? boost::any(userContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallContext") != m.end() && !m["CallContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["CallContext"].type()) {
        LaunchAuthenticationResponseBodyDataCallContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CallContext"]));
        callContext = make_shared<LaunchAuthenticationResponseBodyDataCallContext>(model1);
      }
    }
    if (m.find("UserContext") != m.end() && !m["UserContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["UserContext"].type()) {
        LaunchAuthenticationResponseBodyDataUserContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["UserContext"]));
        userContext = make_shared<LaunchAuthenticationResponseBodyDataUserContext>(model1);
      }
    }
  }


  virtual ~LaunchAuthenticationResponseBodyData() = default;
};
class LaunchAuthenticationResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<LaunchAuthenticationResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<vector<string>> params{};
  shared_ptr<string> requestId{};

  LaunchAuthenticationResponseBody() {}

  explicit LaunchAuthenticationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (params) {
      res["Params"] = boost::any(*params);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        LaunchAuthenticationResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<LaunchAuthenticationResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Params") != m.end() && !m["Params"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Params"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Params"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      params = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~LaunchAuthenticationResponseBody() = default;
};
class LaunchAuthenticationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<LaunchAuthenticationResponseBody> body{};

  LaunchAuthenticationResponse() {}

  explicit LaunchAuthenticationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        LaunchAuthenticationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<LaunchAuthenticationResponseBody>(model1);
      }
    }
  }


  virtual ~LaunchAuthenticationResponse() = default;
};
class LaunchSurveyRequest : public Darabonba::Model {
public:
  shared_ptr<string> contactFlowId{};
  shared_ptr<string> contactFlowVariables{};
  shared_ptr<string> deviceId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> jobId{};
  shared_ptr<string> smsMetadataId{};
  shared_ptr<string> surveyChannel{};
  shared_ptr<string> userId{};

  LaunchSurveyRequest() {}

  explicit LaunchSurveyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contactFlowId) {
      res["ContactFlowId"] = boost::any(*contactFlowId);
    }
    if (contactFlowVariables) {
      res["ContactFlowVariables"] = boost::any(*contactFlowVariables);
    }
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (smsMetadataId) {
      res["SmsMetadataId"] = boost::any(*smsMetadataId);
    }
    if (surveyChannel) {
      res["SurveyChannel"] = boost::any(*surveyChannel);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ContactFlowId") != m.end() && !m["ContactFlowId"].empty()) {
      contactFlowId = make_shared<string>(boost::any_cast<string>(m["ContactFlowId"]));
    }
    if (m.find("ContactFlowVariables") != m.end() && !m["ContactFlowVariables"].empty()) {
      contactFlowVariables = make_shared<string>(boost::any_cast<string>(m["ContactFlowVariables"]));
    }
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("SmsMetadataId") != m.end() && !m["SmsMetadataId"].empty()) {
      smsMetadataId = make_shared<string>(boost::any_cast<string>(m["SmsMetadataId"]));
    }
    if (m.find("SurveyChannel") != m.end() && !m["SurveyChannel"].empty()) {
      surveyChannel = make_shared<string>(boost::any_cast<string>(m["SurveyChannel"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~LaunchSurveyRequest() = default;
};
class LaunchSurveyResponseBodyDataCallContextChannelContexts : public Darabonba::Model {
public:
  shared_ptr<string> callType{};
  shared_ptr<string> channelFlags{};
  shared_ptr<string> channelId{};
  shared_ptr<string> channelState{};
  shared_ptr<string> destination{};
  shared_ptr<long> index{};
  shared_ptr<string> jobId{};
  shared_ptr<string> originator{};
  shared_ptr<string> releaseInitiator{};
  shared_ptr<string> releaseReason{};
  shared_ptr<string> skillGroupId{};
  shared_ptr<long> timestamp{};
  shared_ptr<string> userExtension{};
  shared_ptr<string> userId{};

  LaunchSurveyResponseBodyDataCallContextChannelContexts() {}

  explicit LaunchSurveyResponseBodyDataCallContextChannelContexts(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callType) {
      res["CallType"] = boost::any(*callType);
    }
    if (channelFlags) {
      res["ChannelFlags"] = boost::any(*channelFlags);
    }
    if (channelId) {
      res["ChannelId"] = boost::any(*channelId);
    }
    if (channelState) {
      res["ChannelState"] = boost::any(*channelState);
    }
    if (destination) {
      res["Destination"] = boost::any(*destination);
    }
    if (index) {
      res["Index"] = boost::any(*index);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (originator) {
      res["Originator"] = boost::any(*originator);
    }
    if (releaseInitiator) {
      res["ReleaseInitiator"] = boost::any(*releaseInitiator);
    }
    if (releaseReason) {
      res["ReleaseReason"] = boost::any(*releaseReason);
    }
    if (skillGroupId) {
      res["SkillGroupId"] = boost::any(*skillGroupId);
    }
    if (timestamp) {
      res["Timestamp"] = boost::any(*timestamp);
    }
    if (userExtension) {
      res["UserExtension"] = boost::any(*userExtension);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallType") != m.end() && !m["CallType"].empty()) {
      callType = make_shared<string>(boost::any_cast<string>(m["CallType"]));
    }
    if (m.find("ChannelFlags") != m.end() && !m["ChannelFlags"].empty()) {
      channelFlags = make_shared<string>(boost::any_cast<string>(m["ChannelFlags"]));
    }
    if (m.find("ChannelId") != m.end() && !m["ChannelId"].empty()) {
      channelId = make_shared<string>(boost::any_cast<string>(m["ChannelId"]));
    }
    if (m.find("ChannelState") != m.end() && !m["ChannelState"].empty()) {
      channelState = make_shared<string>(boost::any_cast<string>(m["ChannelState"]));
    }
    if (m.find("Destination") != m.end() && !m["Destination"].empty()) {
      destination = make_shared<string>(boost::any_cast<string>(m["Destination"]));
    }
    if (m.find("Index") != m.end() && !m["Index"].empty()) {
      index = make_shared<long>(boost::any_cast<long>(m["Index"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("Originator") != m.end() && !m["Originator"].empty()) {
      originator = make_shared<string>(boost::any_cast<string>(m["Originator"]));
    }
    if (m.find("ReleaseInitiator") != m.end() && !m["ReleaseInitiator"].empty()) {
      releaseInitiator = make_shared<string>(boost::any_cast<string>(m["ReleaseInitiator"]));
    }
    if (m.find("ReleaseReason") != m.end() && !m["ReleaseReason"].empty()) {
      releaseReason = make_shared<string>(boost::any_cast<string>(m["ReleaseReason"]));
    }
    if (m.find("SkillGroupId") != m.end() && !m["SkillGroupId"].empty()) {
      skillGroupId = make_shared<string>(boost::any_cast<string>(m["SkillGroupId"]));
    }
    if (m.find("Timestamp") != m.end() && !m["Timestamp"].empty()) {
      timestamp = make_shared<long>(boost::any_cast<long>(m["Timestamp"]));
    }
    if (m.find("UserExtension") != m.end() && !m["UserExtension"].empty()) {
      userExtension = make_shared<string>(boost::any_cast<string>(m["UserExtension"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~LaunchSurveyResponseBodyDataCallContextChannelContexts() = default;
};
class LaunchSurveyResponseBodyDataCallContext : public Darabonba::Model {
public:
  shared_ptr<string> callType{};
  shared_ptr<vector<LaunchSurveyResponseBodyDataCallContextChannelContexts>> channelContexts{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> jobId{};

  LaunchSurveyResponseBodyDataCallContext() {}

  explicit LaunchSurveyResponseBodyDataCallContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callType) {
      res["CallType"] = boost::any(*callType);
    }
    if (channelContexts) {
      vector<boost::any> temp1;
      for(auto item1:*channelContexts){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ChannelContexts"] = boost::any(temp1);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallType") != m.end() && !m["CallType"].empty()) {
      callType = make_shared<string>(boost::any_cast<string>(m["CallType"]));
    }
    if (m.find("ChannelContexts") != m.end() && !m["ChannelContexts"].empty()) {
      if (typeid(vector<boost::any>) == m["ChannelContexts"].type()) {
        vector<LaunchSurveyResponseBodyDataCallContextChannelContexts> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ChannelContexts"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            LaunchSurveyResponseBodyDataCallContextChannelContexts model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        channelContexts = make_shared<vector<LaunchSurveyResponseBodyDataCallContextChannelContexts>>(expect1);
      }
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
  }


  virtual ~LaunchSurveyResponseBodyDataCallContext() = default;
};
class LaunchSurveyResponseBodyDataUserContext : public Darabonba::Model {
public:
  shared_ptr<string> breakCode{};
  shared_ptr<string> deviceId{};
  shared_ptr<string> extension{};
  shared_ptr<long> heartbeat{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> jobId{};
  shared_ptr<string> mobile{};
  shared_ptr<bool> outboundScenario{};
  shared_ptr<long> reserved{};
  shared_ptr<vector<string>> signedSkillGroupIdList{};
  shared_ptr<string> userId{};
  shared_ptr<string> userState{};
  shared_ptr<string> workMode{};

  LaunchSurveyResponseBodyDataUserContext() {}

  explicit LaunchSurveyResponseBodyDataUserContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (breakCode) {
      res["BreakCode"] = boost::any(*breakCode);
    }
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (extension) {
      res["Extension"] = boost::any(*extension);
    }
    if (heartbeat) {
      res["Heartbeat"] = boost::any(*heartbeat);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (mobile) {
      res["Mobile"] = boost::any(*mobile);
    }
    if (outboundScenario) {
      res["OutboundScenario"] = boost::any(*outboundScenario);
    }
    if (reserved) {
      res["Reserved"] = boost::any(*reserved);
    }
    if (signedSkillGroupIdList) {
      res["SignedSkillGroupIdList"] = boost::any(*signedSkillGroupIdList);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (userState) {
      res["UserState"] = boost::any(*userState);
    }
    if (workMode) {
      res["WorkMode"] = boost::any(*workMode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BreakCode") != m.end() && !m["BreakCode"].empty()) {
      breakCode = make_shared<string>(boost::any_cast<string>(m["BreakCode"]));
    }
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("Extension") != m.end() && !m["Extension"].empty()) {
      extension = make_shared<string>(boost::any_cast<string>(m["Extension"]));
    }
    if (m.find("Heartbeat") != m.end() && !m["Heartbeat"].empty()) {
      heartbeat = make_shared<long>(boost::any_cast<long>(m["Heartbeat"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("Mobile") != m.end() && !m["Mobile"].empty()) {
      mobile = make_shared<string>(boost::any_cast<string>(m["Mobile"]));
    }
    if (m.find("OutboundScenario") != m.end() && !m["OutboundScenario"].empty()) {
      outboundScenario = make_shared<bool>(boost::any_cast<bool>(m["OutboundScenario"]));
    }
    if (m.find("Reserved") != m.end() && !m["Reserved"].empty()) {
      reserved = make_shared<long>(boost::any_cast<long>(m["Reserved"]));
    }
    if (m.find("SignedSkillGroupIdList") != m.end() && !m["SignedSkillGroupIdList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SignedSkillGroupIdList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SignedSkillGroupIdList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      signedSkillGroupIdList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
    if (m.find("UserState") != m.end() && !m["UserState"].empty()) {
      userState = make_shared<string>(boost::any_cast<string>(m["UserState"]));
    }
    if (m.find("WorkMode") != m.end() && !m["WorkMode"].empty()) {
      workMode = make_shared<string>(boost::any_cast<string>(m["WorkMode"]));
    }
  }


  virtual ~LaunchSurveyResponseBodyDataUserContext() = default;
};
class LaunchSurveyResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<LaunchSurveyResponseBodyDataCallContext> callContext{};
  shared_ptr<long> contextId{};
  shared_ptr<LaunchSurveyResponseBodyDataUserContext> userContext{};

  LaunchSurveyResponseBodyData() {}

  explicit LaunchSurveyResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callContext) {
      res["CallContext"] = callContext ? boost::any(callContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (contextId) {
      res["ContextId"] = boost::any(*contextId);
    }
    if (userContext) {
      res["UserContext"] = userContext ? boost::any(userContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallContext") != m.end() && !m["CallContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["CallContext"].type()) {
        LaunchSurveyResponseBodyDataCallContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CallContext"]));
        callContext = make_shared<LaunchSurveyResponseBodyDataCallContext>(model1);
      }
    }
    if (m.find("ContextId") != m.end() && !m["ContextId"].empty()) {
      contextId = make_shared<long>(boost::any_cast<long>(m["ContextId"]));
    }
    if (m.find("UserContext") != m.end() && !m["UserContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["UserContext"].type()) {
        LaunchSurveyResponseBodyDataUserContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["UserContext"]));
        userContext = make_shared<LaunchSurveyResponseBodyDataUserContext>(model1);
      }
    }
  }


  virtual ~LaunchSurveyResponseBodyData() = default;
};
class LaunchSurveyResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<LaunchSurveyResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<vector<string>> params{};
  shared_ptr<string> requestId{};

  LaunchSurveyResponseBody() {}

  explicit LaunchSurveyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (params) {
      res["Params"] = boost::any(*params);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        LaunchSurveyResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<LaunchSurveyResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Params") != m.end() && !m["Params"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Params"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Params"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      params = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~LaunchSurveyResponseBody() = default;
};
class LaunchSurveyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<LaunchSurveyResponseBody> body{};

  LaunchSurveyResponse() {}

  explicit LaunchSurveyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        LaunchSurveyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<LaunchSurveyResponseBody>(model1);
      }
    }
  }


  virtual ~LaunchSurveyResponse() = default;
};
class ListAgentStateLogsRequest : public Darabonba::Model {
public:
  shared_ptr<string> agentId{};
  shared_ptr<long> endTime{};
  shared_ptr<string> instanceId{};
  shared_ptr<long> startTime{};

  ListAgentStateLogsRequest() {}

  explicit ListAgentStateLogsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agentId) {
      res["AgentId"] = boost::any(*agentId);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AgentId") != m.end() && !m["AgentId"].empty()) {
      agentId = make_shared<string>(boost::any_cast<string>(m["AgentId"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
  }


  virtual ~ListAgentStateLogsRequest() = default;
};
class ListAgentStateLogsResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> duration{};
  shared_ptr<bool> outboundScenario{};
  shared_ptr<long> startTime{};
  shared_ptr<string> state{};
  shared_ptr<string> stateCode{};

  ListAgentStateLogsResponseBodyData() {}

  explicit ListAgentStateLogsResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (outboundScenario) {
      res["OutboundScenario"] = boost::any(*outboundScenario);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (stateCode) {
      res["StateCode"] = boost::any(*stateCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<long>(boost::any_cast<long>(m["Duration"]));
    }
    if (m.find("OutboundScenario") != m.end() && !m["OutboundScenario"].empty()) {
      outboundScenario = make_shared<bool>(boost::any_cast<bool>(m["OutboundScenario"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("StateCode") != m.end() && !m["StateCode"].empty()) {
      stateCode = make_shared<string>(boost::any_cast<string>(m["StateCode"]));
    }
  }


  virtual ~ListAgentStateLogsResponseBodyData() = default;
};
class ListAgentStateLogsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<vector<ListAgentStateLogsResponseBodyData>> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  ListAgentStateLogsResponseBody() {}

  explicit ListAgentStateLogsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<ListAgentStateLogsResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListAgentStateLogsResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<ListAgentStateLogsResponseBodyData>>(expect1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListAgentStateLogsResponseBody() = default;
};
class ListAgentStateLogsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListAgentStateLogsResponseBody> body{};

  ListAgentStateLogsResponse() {}

  explicit ListAgentStateLogsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListAgentStateLogsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListAgentStateLogsResponseBody>(model1);
      }
    }
  }


  virtual ~ListAgentStateLogsResponse() = default;
};
class ListAgentStatesRequest : public Darabonba::Model {
public:
  shared_ptr<string> agentIds{};
  shared_ptr<bool> excludeOfflineUsers{};
  shared_ptr<string> instanceId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> skillGroupId{};
  shared_ptr<string> state{};

  ListAgentStatesRequest() {}

  explicit ListAgentStatesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agentIds) {
      res["AgentIds"] = boost::any(*agentIds);
    }
    if (excludeOfflineUsers) {
      res["ExcludeOfflineUsers"] = boost::any(*excludeOfflineUsers);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (skillGroupId) {
      res["SkillGroupId"] = boost::any(*skillGroupId);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AgentIds") != m.end() && !m["AgentIds"].empty()) {
      agentIds = make_shared<string>(boost::any_cast<string>(m["AgentIds"]));
    }
    if (m.find("ExcludeOfflineUsers") != m.end() && !m["ExcludeOfflineUsers"].empty()) {
      excludeOfflineUsers = make_shared<bool>(boost::any_cast<bool>(m["ExcludeOfflineUsers"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SkillGroupId") != m.end() && !m["SkillGroupId"].empty()) {
      skillGroupId = make_shared<string>(boost::any_cast<string>(m["SkillGroupId"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
  }


  virtual ~ListAgentStatesRequest() = default;
};
class ListAgentStatesResponseBodyDataList : public Darabonba::Model {
public:
  shared_ptr<string> agentId{};
  shared_ptr<string> agentName{};
  shared_ptr<string> breakCode{};
  shared_ptr<string> dn{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> loginName{};
  shared_ptr<bool> outboundScenario{};
  shared_ptr<string> state{};
  shared_ptr<string> stateDuration{};

  ListAgentStatesResponseBodyDataList() {}

  explicit ListAgentStatesResponseBodyDataList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agentId) {
      res["AgentId"] = boost::any(*agentId);
    }
    if (agentName) {
      res["AgentName"] = boost::any(*agentName);
    }
    if (breakCode) {
      res["BreakCode"] = boost::any(*breakCode);
    }
    if (dn) {
      res["Dn"] = boost::any(*dn);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (loginName) {
      res["LoginName"] = boost::any(*loginName);
    }
    if (outboundScenario) {
      res["OutboundScenario"] = boost::any(*outboundScenario);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (stateDuration) {
      res["StateDuration"] = boost::any(*stateDuration);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AgentId") != m.end() && !m["AgentId"].empty()) {
      agentId = make_shared<string>(boost::any_cast<string>(m["AgentId"]));
    }
    if (m.find("AgentName") != m.end() && !m["AgentName"].empty()) {
      agentName = make_shared<string>(boost::any_cast<string>(m["AgentName"]));
    }
    if (m.find("BreakCode") != m.end() && !m["BreakCode"].empty()) {
      breakCode = make_shared<string>(boost::any_cast<string>(m["BreakCode"]));
    }
    if (m.find("Dn") != m.end() && !m["Dn"].empty()) {
      dn = make_shared<string>(boost::any_cast<string>(m["Dn"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("LoginName") != m.end() && !m["LoginName"].empty()) {
      loginName = make_shared<string>(boost::any_cast<string>(m["LoginName"]));
    }
    if (m.find("OutboundScenario") != m.end() && !m["OutboundScenario"].empty()) {
      outboundScenario = make_shared<bool>(boost::any_cast<bool>(m["OutboundScenario"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("StateDuration") != m.end() && !m["StateDuration"].empty()) {
      stateDuration = make_shared<string>(boost::any_cast<string>(m["StateDuration"]));
    }
  }


  virtual ~ListAgentStatesResponseBodyDataList() = default;
};
class ListAgentStatesResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<ListAgentStatesResponseBodyDataList>> list{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  ListAgentStatesResponseBodyData() {}

  explicit ListAgentStatesResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (list) {
      vector<boost::any> temp1;
      for(auto item1:*list){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["List"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(vector<boost::any>) == m["List"].type()) {
        vector<ListAgentStatesResponseBodyDataList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["List"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListAgentStatesResponseBodyDataList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        list = make_shared<vector<ListAgentStatesResponseBodyDataList>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListAgentStatesResponseBodyData() = default;
};
class ListAgentStatesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<ListAgentStatesResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ListAgentStatesResponseBody() {}

  explicit ListAgentStatesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ListAgentStatesResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ListAgentStatesResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ListAgentStatesResponseBody() = default;
};
class ListAgentStatesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListAgentStatesResponseBody> body{};

  ListAgentStatesResponse() {}

  explicit ListAgentStatesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListAgentStatesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListAgentStatesResponseBody>(model1);
      }
    }
  }


  virtual ~ListAgentStatesResponse() = default;
};
class ListAgentSummaryReportsSinceMidnightRequest : public Darabonba::Model {
public:
  shared_ptr<string> agentIds{};
  shared_ptr<string> instanceId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> skillGroupId{};

  ListAgentSummaryReportsSinceMidnightRequest() {}

  explicit ListAgentSummaryReportsSinceMidnightRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agentIds) {
      res["AgentIds"] = boost::any(*agentIds);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (skillGroupId) {
      res["SkillGroupId"] = boost::any(*skillGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AgentIds") != m.end() && !m["AgentIds"].empty()) {
      agentIds = make_shared<string>(boost::any_cast<string>(m["AgentIds"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SkillGroupId") != m.end() && !m["SkillGroupId"].empty()) {
      skillGroupId = make_shared<string>(boost::any_cast<string>(m["SkillGroupId"]));
    }
  }


  virtual ~ListAgentSummaryReportsSinceMidnightRequest() = default;
};
class ListAgentSummaryReportsSinceMidnightResponseBodyPagedAgentSummaryReportListInbound : public Darabonba::Model {
public:
  shared_ptr<long> averageRingTime{};
  shared_ptr<long> averageTalkTime{};
  shared_ptr<long> averageWorkTime{};
  shared_ptr<long> callsHandled{};
  shared_ptr<long> callsOffered{};
  shared_ptr<double> handleRate{};
  shared_ptr<long> maxRingTime{};
  shared_ptr<long> maxTalkTime{};
  shared_ptr<long> maxWorkTime{};
  shared_ptr<double> satisfactionIndex{};
  shared_ptr<long> satisfactionSurveysOffered{};
  shared_ptr<long> satisfactionSurveysResponded{};
  shared_ptr<double> serviceLevel20{};
  shared_ptr<long> totalRingTime{};
  shared_ptr<long> totalTalkTime{};
  shared_ptr<long> totalWorkTime{};

  ListAgentSummaryReportsSinceMidnightResponseBodyPagedAgentSummaryReportListInbound() {}

  explicit ListAgentSummaryReportsSinceMidnightResponseBodyPagedAgentSummaryReportListInbound(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (averageRingTime) {
      res["AverageRingTime"] = boost::any(*averageRingTime);
    }
    if (averageTalkTime) {
      res["AverageTalkTime"] = boost::any(*averageTalkTime);
    }
    if (averageWorkTime) {
      res["AverageWorkTime"] = boost::any(*averageWorkTime);
    }
    if (callsHandled) {
      res["CallsHandled"] = boost::any(*callsHandled);
    }
    if (callsOffered) {
      res["CallsOffered"] = boost::any(*callsOffered);
    }
    if (handleRate) {
      res["HandleRate"] = boost::any(*handleRate);
    }
    if (maxRingTime) {
      res["MaxRingTime"] = boost::any(*maxRingTime);
    }
    if (maxTalkTime) {
      res["MaxTalkTime"] = boost::any(*maxTalkTime);
    }
    if (maxWorkTime) {
      res["MaxWorkTime"] = boost::any(*maxWorkTime);
    }
    if (satisfactionIndex) {
      res["SatisfactionIndex"] = boost::any(*satisfactionIndex);
    }
    if (satisfactionSurveysOffered) {
      res["SatisfactionSurveysOffered"] = boost::any(*satisfactionSurveysOffered);
    }
    if (satisfactionSurveysResponded) {
      res["SatisfactionSurveysResponded"] = boost::any(*satisfactionSurveysResponded);
    }
    if (serviceLevel20) {
      res["ServiceLevel20"] = boost::any(*serviceLevel20);
    }
    if (totalRingTime) {
      res["TotalRingTime"] = boost::any(*totalRingTime);
    }
    if (totalTalkTime) {
      res["TotalTalkTime"] = boost::any(*totalTalkTime);
    }
    if (totalWorkTime) {
      res["TotalWorkTime"] = boost::any(*totalWorkTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AverageRingTime") != m.end() && !m["AverageRingTime"].empty()) {
      averageRingTime = make_shared<long>(boost::any_cast<long>(m["AverageRingTime"]));
    }
    if (m.find("AverageTalkTime") != m.end() && !m["AverageTalkTime"].empty()) {
      averageTalkTime = make_shared<long>(boost::any_cast<long>(m["AverageTalkTime"]));
    }
    if (m.find("AverageWorkTime") != m.end() && !m["AverageWorkTime"].empty()) {
      averageWorkTime = make_shared<long>(boost::any_cast<long>(m["AverageWorkTime"]));
    }
    if (m.find("CallsHandled") != m.end() && !m["CallsHandled"].empty()) {
      callsHandled = make_shared<long>(boost::any_cast<long>(m["CallsHandled"]));
    }
    if (m.find("CallsOffered") != m.end() && !m["CallsOffered"].empty()) {
      callsOffered = make_shared<long>(boost::any_cast<long>(m["CallsOffered"]));
    }
    if (m.find("HandleRate") != m.end() && !m["HandleRate"].empty()) {
      handleRate = make_shared<double>(boost::any_cast<double>(m["HandleRate"]));
    }
    if (m.find("MaxRingTime") != m.end() && !m["MaxRingTime"].empty()) {
      maxRingTime = make_shared<long>(boost::any_cast<long>(m["MaxRingTime"]));
    }
    if (m.find("MaxTalkTime") != m.end() && !m["MaxTalkTime"].empty()) {
      maxTalkTime = make_shared<long>(boost::any_cast<long>(m["MaxTalkTime"]));
    }
    if (m.find("MaxWorkTime") != m.end() && !m["MaxWorkTime"].empty()) {
      maxWorkTime = make_shared<long>(boost::any_cast<long>(m["MaxWorkTime"]));
    }
    if (m.find("SatisfactionIndex") != m.end() && !m["SatisfactionIndex"].empty()) {
      satisfactionIndex = make_shared<double>(boost::any_cast<double>(m["SatisfactionIndex"]));
    }
    if (m.find("SatisfactionSurveysOffered") != m.end() && !m["SatisfactionSurveysOffered"].empty()) {
      satisfactionSurveysOffered = make_shared<long>(boost::any_cast<long>(m["SatisfactionSurveysOffered"]));
    }
    if (m.find("SatisfactionSurveysResponded") != m.end() && !m["SatisfactionSurveysResponded"].empty()) {
      satisfactionSurveysResponded = make_shared<long>(boost::any_cast<long>(m["SatisfactionSurveysResponded"]));
    }
    if (m.find("ServiceLevel20") != m.end() && !m["ServiceLevel20"].empty()) {
      serviceLevel20 = make_shared<double>(boost::any_cast<double>(m["ServiceLevel20"]));
    }
    if (m.find("TotalRingTime") != m.end() && !m["TotalRingTime"].empty()) {
      totalRingTime = make_shared<long>(boost::any_cast<long>(m["TotalRingTime"]));
    }
    if (m.find("TotalTalkTime") != m.end() && !m["TotalTalkTime"].empty()) {
      totalTalkTime = make_shared<long>(boost::any_cast<long>(m["TotalTalkTime"]));
    }
    if (m.find("TotalWorkTime") != m.end() && !m["TotalWorkTime"].empty()) {
      totalWorkTime = make_shared<long>(boost::any_cast<long>(m["TotalWorkTime"]));
    }
  }


  virtual ~ListAgentSummaryReportsSinceMidnightResponseBodyPagedAgentSummaryReportListInbound() = default;
};
class ListAgentSummaryReportsSinceMidnightResponseBodyPagedAgentSummaryReportListOutbound : public Darabonba::Model {
public:
  shared_ptr<double> answerRate{};
  shared_ptr<long> averageDialingTime{};
  shared_ptr<long> averageTalkTime{};
  shared_ptr<long> averageWorkTime{};
  shared_ptr<long> callsAnswered{};
  shared_ptr<long> callsDialed{};
  shared_ptr<long> maxDialingTime{};
  shared_ptr<long> maxTalkTime{};
  shared_ptr<string> maxWorkTime{};
  shared_ptr<double> satisfactionIndex{};
  shared_ptr<long> satisfactionSurveysOffered{};
  shared_ptr<long> satisfactionSurveysResponded{};
  shared_ptr<long> totalDialingTime{};
  shared_ptr<long> totalTalkTime{};
  shared_ptr<long> totalWorkTime{};

  ListAgentSummaryReportsSinceMidnightResponseBodyPagedAgentSummaryReportListOutbound() {}

  explicit ListAgentSummaryReportsSinceMidnightResponseBodyPagedAgentSummaryReportListOutbound(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (answerRate) {
      res["AnswerRate"] = boost::any(*answerRate);
    }
    if (averageDialingTime) {
      res["AverageDialingTime"] = boost::any(*averageDialingTime);
    }
    if (averageTalkTime) {
      res["AverageTalkTime"] = boost::any(*averageTalkTime);
    }
    if (averageWorkTime) {
      res["AverageWorkTime"] = boost::any(*averageWorkTime);
    }
    if (callsAnswered) {
      res["CallsAnswered"] = boost::any(*callsAnswered);
    }
    if (callsDialed) {
      res["CallsDialed"] = boost::any(*callsDialed);
    }
    if (maxDialingTime) {
      res["MaxDialingTime"] = boost::any(*maxDialingTime);
    }
    if (maxTalkTime) {
      res["MaxTalkTime"] = boost::any(*maxTalkTime);
    }
    if (maxWorkTime) {
      res["MaxWorkTime"] = boost::any(*maxWorkTime);
    }
    if (satisfactionIndex) {
      res["SatisfactionIndex"] = boost::any(*satisfactionIndex);
    }
    if (satisfactionSurveysOffered) {
      res["SatisfactionSurveysOffered"] = boost::any(*satisfactionSurveysOffered);
    }
    if (satisfactionSurveysResponded) {
      res["SatisfactionSurveysResponded"] = boost::any(*satisfactionSurveysResponded);
    }
    if (totalDialingTime) {
      res["TotalDialingTime"] = boost::any(*totalDialingTime);
    }
    if (totalTalkTime) {
      res["TotalTalkTime"] = boost::any(*totalTalkTime);
    }
    if (totalWorkTime) {
      res["TotalWorkTime"] = boost::any(*totalWorkTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AnswerRate") != m.end() && !m["AnswerRate"].empty()) {
      answerRate = make_shared<double>(boost::any_cast<double>(m["AnswerRate"]));
    }
    if (m.find("AverageDialingTime") != m.end() && !m["AverageDialingTime"].empty()) {
      averageDialingTime = make_shared<long>(boost::any_cast<long>(m["AverageDialingTime"]));
    }
    if (m.find("AverageTalkTime") != m.end() && !m["AverageTalkTime"].empty()) {
      averageTalkTime = make_shared<long>(boost::any_cast<long>(m["AverageTalkTime"]));
    }
    if (m.find("AverageWorkTime") != m.end() && !m["AverageWorkTime"].empty()) {
      averageWorkTime = make_shared<long>(boost::any_cast<long>(m["AverageWorkTime"]));
    }
    if (m.find("CallsAnswered") != m.end() && !m["CallsAnswered"].empty()) {
      callsAnswered = make_shared<long>(boost::any_cast<long>(m["CallsAnswered"]));
    }
    if (m.find("CallsDialed") != m.end() && !m["CallsDialed"].empty()) {
      callsDialed = make_shared<long>(boost::any_cast<long>(m["CallsDialed"]));
    }
    if (m.find("MaxDialingTime") != m.end() && !m["MaxDialingTime"].empty()) {
      maxDialingTime = make_shared<long>(boost::any_cast<long>(m["MaxDialingTime"]));
    }
    if (m.find("MaxTalkTime") != m.end() && !m["MaxTalkTime"].empty()) {
      maxTalkTime = make_shared<long>(boost::any_cast<long>(m["MaxTalkTime"]));
    }
    if (m.find("MaxWorkTime") != m.end() && !m["MaxWorkTime"].empty()) {
      maxWorkTime = make_shared<string>(boost::any_cast<string>(m["MaxWorkTime"]));
    }
    if (m.find("SatisfactionIndex") != m.end() && !m["SatisfactionIndex"].empty()) {
      satisfactionIndex = make_shared<double>(boost::any_cast<double>(m["SatisfactionIndex"]));
    }
    if (m.find("SatisfactionSurveysOffered") != m.end() && !m["SatisfactionSurveysOffered"].empty()) {
      satisfactionSurveysOffered = make_shared<long>(boost::any_cast<long>(m["SatisfactionSurveysOffered"]));
    }
    if (m.find("SatisfactionSurveysResponded") != m.end() && !m["SatisfactionSurveysResponded"].empty()) {
      satisfactionSurveysResponded = make_shared<long>(boost::any_cast<long>(m["SatisfactionSurveysResponded"]));
    }
    if (m.find("TotalDialingTime") != m.end() && !m["TotalDialingTime"].empty()) {
      totalDialingTime = make_shared<long>(boost::any_cast<long>(m["TotalDialingTime"]));
    }
    if (m.find("TotalTalkTime") != m.end() && !m["TotalTalkTime"].empty()) {
      totalTalkTime = make_shared<long>(boost::any_cast<long>(m["TotalTalkTime"]));
    }
    if (m.find("TotalWorkTime") != m.end() && !m["TotalWorkTime"].empty()) {
      totalWorkTime = make_shared<long>(boost::any_cast<long>(m["TotalWorkTime"]));
    }
  }


  virtual ~ListAgentSummaryReportsSinceMidnightResponseBodyPagedAgentSummaryReportListOutbound() = default;
};
class ListAgentSummaryReportsSinceMidnightResponseBodyPagedAgentSummaryReportListOverall : public Darabonba::Model {
public:
  shared_ptr<long> averageReadyTime{};
  shared_ptr<long> averageTalkTime{};
  shared_ptr<long> averageWorkTime{};
  shared_ptr<long> maxReadyTime{};
  shared_ptr<long> maxTalkTime{};
  shared_ptr<long> maxWorkTime{};
  shared_ptr<double> occupancyRate{};
  shared_ptr<long> oneTransferCalls{};
  shared_ptr<double> satisfactionIndex{};
  shared_ptr<long> satisfactionSurveysOffered{};
  shared_ptr<long> satisfactionSurveysResponded{};
  shared_ptr<long> totalBreakTime{};
  shared_ptr<long> totalCalls{};
  shared_ptr<long> totalLoggedInTime{};
  shared_ptr<long> totalReadyTime{};
  shared_ptr<long> totalTalkTime{};
  shared_ptr<long> totalWorkTime{};

  ListAgentSummaryReportsSinceMidnightResponseBodyPagedAgentSummaryReportListOverall() {}

  explicit ListAgentSummaryReportsSinceMidnightResponseBodyPagedAgentSummaryReportListOverall(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (averageReadyTime) {
      res["AverageReadyTime"] = boost::any(*averageReadyTime);
    }
    if (averageTalkTime) {
      res["AverageTalkTime"] = boost::any(*averageTalkTime);
    }
    if (averageWorkTime) {
      res["AverageWorkTime"] = boost::any(*averageWorkTime);
    }
    if (maxReadyTime) {
      res["MaxReadyTime"] = boost::any(*maxReadyTime);
    }
    if (maxTalkTime) {
      res["MaxTalkTime"] = boost::any(*maxTalkTime);
    }
    if (maxWorkTime) {
      res["MaxWorkTime"] = boost::any(*maxWorkTime);
    }
    if (occupancyRate) {
      res["OccupancyRate"] = boost::any(*occupancyRate);
    }
    if (oneTransferCalls) {
      res["OneTransferCalls"] = boost::any(*oneTransferCalls);
    }
    if (satisfactionIndex) {
      res["SatisfactionIndex"] = boost::any(*satisfactionIndex);
    }
    if (satisfactionSurveysOffered) {
      res["SatisfactionSurveysOffered"] = boost::any(*satisfactionSurveysOffered);
    }
    if (satisfactionSurveysResponded) {
      res["SatisfactionSurveysResponded"] = boost::any(*satisfactionSurveysResponded);
    }
    if (totalBreakTime) {
      res["TotalBreakTime"] = boost::any(*totalBreakTime);
    }
    if (totalCalls) {
      res["TotalCalls"] = boost::any(*totalCalls);
    }
    if (totalLoggedInTime) {
      res["TotalLoggedInTime"] = boost::any(*totalLoggedInTime);
    }
    if (totalReadyTime) {
      res["TotalReadyTime"] = boost::any(*totalReadyTime);
    }
    if (totalTalkTime) {
      res["TotalTalkTime"] = boost::any(*totalTalkTime);
    }
    if (totalWorkTime) {
      res["TotalWorkTime"] = boost::any(*totalWorkTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AverageReadyTime") != m.end() && !m["AverageReadyTime"].empty()) {
      averageReadyTime = make_shared<long>(boost::any_cast<long>(m["AverageReadyTime"]));
    }
    if (m.find("AverageTalkTime") != m.end() && !m["AverageTalkTime"].empty()) {
      averageTalkTime = make_shared<long>(boost::any_cast<long>(m["AverageTalkTime"]));
    }
    if (m.find("AverageWorkTime") != m.end() && !m["AverageWorkTime"].empty()) {
      averageWorkTime = make_shared<long>(boost::any_cast<long>(m["AverageWorkTime"]));
    }
    if (m.find("MaxReadyTime") != m.end() && !m["MaxReadyTime"].empty()) {
      maxReadyTime = make_shared<long>(boost::any_cast<long>(m["MaxReadyTime"]));
    }
    if (m.find("MaxTalkTime") != m.end() && !m["MaxTalkTime"].empty()) {
      maxTalkTime = make_shared<long>(boost::any_cast<long>(m["MaxTalkTime"]));
    }
    if (m.find("MaxWorkTime") != m.end() && !m["MaxWorkTime"].empty()) {
      maxWorkTime = make_shared<long>(boost::any_cast<long>(m["MaxWorkTime"]));
    }
    if (m.find("OccupancyRate") != m.end() && !m["OccupancyRate"].empty()) {
      occupancyRate = make_shared<double>(boost::any_cast<double>(m["OccupancyRate"]));
    }
    if (m.find("OneTransferCalls") != m.end() && !m["OneTransferCalls"].empty()) {
      oneTransferCalls = make_shared<long>(boost::any_cast<long>(m["OneTransferCalls"]));
    }
    if (m.find("SatisfactionIndex") != m.end() && !m["SatisfactionIndex"].empty()) {
      satisfactionIndex = make_shared<double>(boost::any_cast<double>(m["SatisfactionIndex"]));
    }
    if (m.find("SatisfactionSurveysOffered") != m.end() && !m["SatisfactionSurveysOffered"].empty()) {
      satisfactionSurveysOffered = make_shared<long>(boost::any_cast<long>(m["SatisfactionSurveysOffered"]));
    }
    if (m.find("SatisfactionSurveysResponded") != m.end() && !m["SatisfactionSurveysResponded"].empty()) {
      satisfactionSurveysResponded = make_shared<long>(boost::any_cast<long>(m["SatisfactionSurveysResponded"]));
    }
    if (m.find("TotalBreakTime") != m.end() && !m["TotalBreakTime"].empty()) {
      totalBreakTime = make_shared<long>(boost::any_cast<long>(m["TotalBreakTime"]));
    }
    if (m.find("TotalCalls") != m.end() && !m["TotalCalls"].empty()) {
      totalCalls = make_shared<long>(boost::any_cast<long>(m["TotalCalls"]));
    }
    if (m.find("TotalLoggedInTime") != m.end() && !m["TotalLoggedInTime"].empty()) {
      totalLoggedInTime = make_shared<long>(boost::any_cast<long>(m["TotalLoggedInTime"]));
    }
    if (m.find("TotalReadyTime") != m.end() && !m["TotalReadyTime"].empty()) {
      totalReadyTime = make_shared<long>(boost::any_cast<long>(m["TotalReadyTime"]));
    }
    if (m.find("TotalTalkTime") != m.end() && !m["TotalTalkTime"].empty()) {
      totalTalkTime = make_shared<long>(boost::any_cast<long>(m["TotalTalkTime"]));
    }
    if (m.find("TotalWorkTime") != m.end() && !m["TotalWorkTime"].empty()) {
      totalWorkTime = make_shared<long>(boost::any_cast<long>(m["TotalWorkTime"]));
    }
  }


  virtual ~ListAgentSummaryReportsSinceMidnightResponseBodyPagedAgentSummaryReportListOverall() = default;
};
class ListAgentSummaryReportsSinceMidnightResponseBodyPagedAgentSummaryReportList : public Darabonba::Model {
public:
  shared_ptr<string> agentId{};
  shared_ptr<string> agentName{};
  shared_ptr<ListAgentSummaryReportsSinceMidnightResponseBodyPagedAgentSummaryReportListInbound> inbound{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> loginName{};
  shared_ptr<ListAgentSummaryReportsSinceMidnightResponseBodyPagedAgentSummaryReportListOutbound> outbound{};
  shared_ptr<ListAgentSummaryReportsSinceMidnightResponseBodyPagedAgentSummaryReportListOverall> overall{};
  shared_ptr<string> skillGroupIds{};
  shared_ptr<string> skillGroupNames{};
  shared_ptr<string> timestamp{};

  ListAgentSummaryReportsSinceMidnightResponseBodyPagedAgentSummaryReportList() {}

  explicit ListAgentSummaryReportsSinceMidnightResponseBodyPagedAgentSummaryReportList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agentId) {
      res["AgentId"] = boost::any(*agentId);
    }
    if (agentName) {
      res["AgentName"] = boost::any(*agentName);
    }
    if (inbound) {
      res["Inbound"] = inbound ? boost::any(inbound->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (loginName) {
      res["LoginName"] = boost::any(*loginName);
    }
    if (outbound) {
      res["Outbound"] = outbound ? boost::any(outbound->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (overall) {
      res["Overall"] = overall ? boost::any(overall->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (skillGroupIds) {
      res["SkillGroupIds"] = boost::any(*skillGroupIds);
    }
    if (skillGroupNames) {
      res["SkillGroupNames"] = boost::any(*skillGroupNames);
    }
    if (timestamp) {
      res["Timestamp"] = boost::any(*timestamp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AgentId") != m.end() && !m["AgentId"].empty()) {
      agentId = make_shared<string>(boost::any_cast<string>(m["AgentId"]));
    }
    if (m.find("AgentName") != m.end() && !m["AgentName"].empty()) {
      agentName = make_shared<string>(boost::any_cast<string>(m["AgentName"]));
    }
    if (m.find("Inbound") != m.end() && !m["Inbound"].empty()) {
      if (typeid(map<string, boost::any>) == m["Inbound"].type()) {
        ListAgentSummaryReportsSinceMidnightResponseBodyPagedAgentSummaryReportListInbound model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Inbound"]));
        inbound = make_shared<ListAgentSummaryReportsSinceMidnightResponseBodyPagedAgentSummaryReportListInbound>(model1);
      }
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("LoginName") != m.end() && !m["LoginName"].empty()) {
      loginName = make_shared<string>(boost::any_cast<string>(m["LoginName"]));
    }
    if (m.find("Outbound") != m.end() && !m["Outbound"].empty()) {
      if (typeid(map<string, boost::any>) == m["Outbound"].type()) {
        ListAgentSummaryReportsSinceMidnightResponseBodyPagedAgentSummaryReportListOutbound model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Outbound"]));
        outbound = make_shared<ListAgentSummaryReportsSinceMidnightResponseBodyPagedAgentSummaryReportListOutbound>(model1);
      }
    }
    if (m.find("Overall") != m.end() && !m["Overall"].empty()) {
      if (typeid(map<string, boost::any>) == m["Overall"].type()) {
        ListAgentSummaryReportsSinceMidnightResponseBodyPagedAgentSummaryReportListOverall model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Overall"]));
        overall = make_shared<ListAgentSummaryReportsSinceMidnightResponseBodyPagedAgentSummaryReportListOverall>(model1);
      }
    }
    if (m.find("SkillGroupIds") != m.end() && !m["SkillGroupIds"].empty()) {
      skillGroupIds = make_shared<string>(boost::any_cast<string>(m["SkillGroupIds"]));
    }
    if (m.find("SkillGroupNames") != m.end() && !m["SkillGroupNames"].empty()) {
      skillGroupNames = make_shared<string>(boost::any_cast<string>(m["SkillGroupNames"]));
    }
    if (m.find("Timestamp") != m.end() && !m["Timestamp"].empty()) {
      timestamp = make_shared<string>(boost::any_cast<string>(m["Timestamp"]));
    }
  }


  virtual ~ListAgentSummaryReportsSinceMidnightResponseBodyPagedAgentSummaryReportList() = default;
};
class ListAgentSummaryReportsSinceMidnightResponseBodyPagedAgentSummaryReport : public Darabonba::Model {
public:
  shared_ptr<vector<ListAgentSummaryReportsSinceMidnightResponseBodyPagedAgentSummaryReportList>> list{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  ListAgentSummaryReportsSinceMidnightResponseBodyPagedAgentSummaryReport() {}

  explicit ListAgentSummaryReportsSinceMidnightResponseBodyPagedAgentSummaryReport(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (list) {
      vector<boost::any> temp1;
      for(auto item1:*list){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["List"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(vector<boost::any>) == m["List"].type()) {
        vector<ListAgentSummaryReportsSinceMidnightResponseBodyPagedAgentSummaryReportList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["List"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListAgentSummaryReportsSinceMidnightResponseBodyPagedAgentSummaryReportList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        list = make_shared<vector<ListAgentSummaryReportsSinceMidnightResponseBodyPagedAgentSummaryReportList>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListAgentSummaryReportsSinceMidnightResponseBodyPagedAgentSummaryReport() = default;
};
class ListAgentSummaryReportsSinceMidnightResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<ListAgentSummaryReportsSinceMidnightResponseBodyPagedAgentSummaryReport> pagedAgentSummaryReport{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ListAgentSummaryReportsSinceMidnightResponseBody() {}

  explicit ListAgentSummaryReportsSinceMidnightResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (pagedAgentSummaryReport) {
      res["PagedAgentSummaryReport"] = pagedAgentSummaryReport ? boost::any(pagedAgentSummaryReport->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("PagedAgentSummaryReport") != m.end() && !m["PagedAgentSummaryReport"].empty()) {
      if (typeid(map<string, boost::any>) == m["PagedAgentSummaryReport"].type()) {
        ListAgentSummaryReportsSinceMidnightResponseBodyPagedAgentSummaryReport model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PagedAgentSummaryReport"]));
        pagedAgentSummaryReport = make_shared<ListAgentSummaryReportsSinceMidnightResponseBodyPagedAgentSummaryReport>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ListAgentSummaryReportsSinceMidnightResponseBody() = default;
};
class ListAgentSummaryReportsSinceMidnightResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListAgentSummaryReportsSinceMidnightResponseBody> body{};

  ListAgentSummaryReportsSinceMidnightResponse() {}

  explicit ListAgentSummaryReportsSinceMidnightResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListAgentSummaryReportsSinceMidnightResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListAgentSummaryReportsSinceMidnightResponseBody>(model1);
      }
    }
  }


  virtual ~ListAgentSummaryReportsSinceMidnightResponse() = default;
};
class ListAttemptsRequest : public Darabonba::Model {
public:
  shared_ptr<string> agentId{};
  shared_ptr<string> attemptId{};
  shared_ptr<string> callee{};
  shared_ptr<string> caller{};
  shared_ptr<string> campaignId{};
  shared_ptr<string> caseId{};
  shared_ptr<string> contactId{};
  shared_ptr<long> endTime{};
  shared_ptr<string> instanceId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> queueId{};
  shared_ptr<long> startTime{};

  ListAttemptsRequest() {}

  explicit ListAttemptsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agentId) {
      res["AgentId"] = boost::any(*agentId);
    }
    if (attemptId) {
      res["AttemptId"] = boost::any(*attemptId);
    }
    if (callee) {
      res["Callee"] = boost::any(*callee);
    }
    if (caller) {
      res["Caller"] = boost::any(*caller);
    }
    if (campaignId) {
      res["CampaignId"] = boost::any(*campaignId);
    }
    if (caseId) {
      res["CaseId"] = boost::any(*caseId);
    }
    if (contactId) {
      res["ContactId"] = boost::any(*contactId);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (queueId) {
      res["QueueId"] = boost::any(*queueId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AgentId") != m.end() && !m["AgentId"].empty()) {
      agentId = make_shared<string>(boost::any_cast<string>(m["AgentId"]));
    }
    if (m.find("AttemptId") != m.end() && !m["AttemptId"].empty()) {
      attemptId = make_shared<string>(boost::any_cast<string>(m["AttemptId"]));
    }
    if (m.find("Callee") != m.end() && !m["Callee"].empty()) {
      callee = make_shared<string>(boost::any_cast<string>(m["Callee"]));
    }
    if (m.find("Caller") != m.end() && !m["Caller"].empty()) {
      caller = make_shared<string>(boost::any_cast<string>(m["Caller"]));
    }
    if (m.find("CampaignId") != m.end() && !m["CampaignId"].empty()) {
      campaignId = make_shared<string>(boost::any_cast<string>(m["CampaignId"]));
    }
    if (m.find("CaseId") != m.end() && !m["CaseId"].empty()) {
      caseId = make_shared<string>(boost::any_cast<string>(m["CaseId"]));
    }
    if (m.find("ContactId") != m.end() && !m["ContactId"].empty()) {
      contactId = make_shared<string>(boost::any_cast<string>(m["ContactId"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("QueueId") != m.end() && !m["QueueId"].empty()) {
      queueId = make_shared<string>(boost::any_cast<string>(m["QueueId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
  }


  virtual ~ListAttemptsRequest() = default;
};
class ListAttemptsResponseBodyDataList : public Darabonba::Model {
public:
  shared_ptr<long> agentEstablishedTime{};
  shared_ptr<string> agentId{};
  shared_ptr<long> agentRingDuration{};
  shared_ptr<long> assignAgentTime{};
  shared_ptr<string> attemptId{};
  shared_ptr<string> callee{};
  shared_ptr<string> caller{};
  shared_ptr<string> campaignId{};
  shared_ptr<string> caseId{};
  shared_ptr<string> contactId{};
  shared_ptr<long> customerEstablishedTime{};
  shared_ptr<long> customerReleasedTime{};
  shared_ptr<long> dialDuration{};
  shared_ptr<long> dialTime{};
  shared_ptr<long> enqueueTime{};
  shared_ptr<long> enterIvrTime{};
  shared_ptr<string> instanceId{};
  shared_ptr<long> ivrDuration{};
  shared_ptr<long> queueDuration{};
  shared_ptr<string> queueId{};

  ListAttemptsResponseBodyDataList() {}

  explicit ListAttemptsResponseBodyDataList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agentEstablishedTime) {
      res["AgentEstablishedTime"] = boost::any(*agentEstablishedTime);
    }
    if (agentId) {
      res["AgentId"] = boost::any(*agentId);
    }
    if (agentRingDuration) {
      res["AgentRingDuration"] = boost::any(*agentRingDuration);
    }
    if (assignAgentTime) {
      res["AssignAgentTime"] = boost::any(*assignAgentTime);
    }
    if (attemptId) {
      res["AttemptId"] = boost::any(*attemptId);
    }
    if (callee) {
      res["Callee"] = boost::any(*callee);
    }
    if (caller) {
      res["Caller"] = boost::any(*caller);
    }
    if (campaignId) {
      res["CampaignId"] = boost::any(*campaignId);
    }
    if (caseId) {
      res["CaseId"] = boost::any(*caseId);
    }
    if (contactId) {
      res["ContactId"] = boost::any(*contactId);
    }
    if (customerEstablishedTime) {
      res["CustomerEstablishedTime"] = boost::any(*customerEstablishedTime);
    }
    if (customerReleasedTime) {
      res["CustomerReleasedTime"] = boost::any(*customerReleasedTime);
    }
    if (dialDuration) {
      res["DialDuration"] = boost::any(*dialDuration);
    }
    if (dialTime) {
      res["DialTime"] = boost::any(*dialTime);
    }
    if (enqueueTime) {
      res["EnqueueTime"] = boost::any(*enqueueTime);
    }
    if (enterIvrTime) {
      res["EnterIvrTime"] = boost::any(*enterIvrTime);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (ivrDuration) {
      res["IvrDuration"] = boost::any(*ivrDuration);
    }
    if (queueDuration) {
      res["QueueDuration"] = boost::any(*queueDuration);
    }
    if (queueId) {
      res["QueueId"] = boost::any(*queueId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AgentEstablishedTime") != m.end() && !m["AgentEstablishedTime"].empty()) {
      agentEstablishedTime = make_shared<long>(boost::any_cast<long>(m["AgentEstablishedTime"]));
    }
    if (m.find("AgentId") != m.end() && !m["AgentId"].empty()) {
      agentId = make_shared<string>(boost::any_cast<string>(m["AgentId"]));
    }
    if (m.find("AgentRingDuration") != m.end() && !m["AgentRingDuration"].empty()) {
      agentRingDuration = make_shared<long>(boost::any_cast<long>(m["AgentRingDuration"]));
    }
    if (m.find("AssignAgentTime") != m.end() && !m["AssignAgentTime"].empty()) {
      assignAgentTime = make_shared<long>(boost::any_cast<long>(m["AssignAgentTime"]));
    }
    if (m.find("AttemptId") != m.end() && !m["AttemptId"].empty()) {
      attemptId = make_shared<string>(boost::any_cast<string>(m["AttemptId"]));
    }
    if (m.find("Callee") != m.end() && !m["Callee"].empty()) {
      callee = make_shared<string>(boost::any_cast<string>(m["Callee"]));
    }
    if (m.find("Caller") != m.end() && !m["Caller"].empty()) {
      caller = make_shared<string>(boost::any_cast<string>(m["Caller"]));
    }
    if (m.find("CampaignId") != m.end() && !m["CampaignId"].empty()) {
      campaignId = make_shared<string>(boost::any_cast<string>(m["CampaignId"]));
    }
    if (m.find("CaseId") != m.end() && !m["CaseId"].empty()) {
      caseId = make_shared<string>(boost::any_cast<string>(m["CaseId"]));
    }
    if (m.find("ContactId") != m.end() && !m["ContactId"].empty()) {
      contactId = make_shared<string>(boost::any_cast<string>(m["ContactId"]));
    }
    if (m.find("CustomerEstablishedTime") != m.end() && !m["CustomerEstablishedTime"].empty()) {
      customerEstablishedTime = make_shared<long>(boost::any_cast<long>(m["CustomerEstablishedTime"]));
    }
    if (m.find("CustomerReleasedTime") != m.end() && !m["CustomerReleasedTime"].empty()) {
      customerReleasedTime = make_shared<long>(boost::any_cast<long>(m["CustomerReleasedTime"]));
    }
    if (m.find("DialDuration") != m.end() && !m["DialDuration"].empty()) {
      dialDuration = make_shared<long>(boost::any_cast<long>(m["DialDuration"]));
    }
    if (m.find("DialTime") != m.end() && !m["DialTime"].empty()) {
      dialTime = make_shared<long>(boost::any_cast<long>(m["DialTime"]));
    }
    if (m.find("EnqueueTime") != m.end() && !m["EnqueueTime"].empty()) {
      enqueueTime = make_shared<long>(boost::any_cast<long>(m["EnqueueTime"]));
    }
    if (m.find("EnterIvrTime") != m.end() && !m["EnterIvrTime"].empty()) {
      enterIvrTime = make_shared<long>(boost::any_cast<long>(m["EnterIvrTime"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("IvrDuration") != m.end() && !m["IvrDuration"].empty()) {
      ivrDuration = make_shared<long>(boost::any_cast<long>(m["IvrDuration"]));
    }
    if (m.find("QueueDuration") != m.end() && !m["QueueDuration"].empty()) {
      queueDuration = make_shared<long>(boost::any_cast<long>(m["QueueDuration"]));
    }
    if (m.find("QueueId") != m.end() && !m["QueueId"].empty()) {
      queueId = make_shared<string>(boost::any_cast<string>(m["QueueId"]));
    }
  }


  virtual ~ListAttemptsResponseBodyDataList() = default;
};
class ListAttemptsResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<ListAttemptsResponseBodyDataList>> list{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  ListAttemptsResponseBodyData() {}

  explicit ListAttemptsResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (list) {
      vector<boost::any> temp1;
      for(auto item1:*list){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["List"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(vector<boost::any>) == m["List"].type()) {
        vector<ListAttemptsResponseBodyDataList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["List"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListAttemptsResponseBodyDataList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        list = make_shared<vector<ListAttemptsResponseBodyDataList>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListAttemptsResponseBodyData() = default;
};
class ListAttemptsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<ListAttemptsResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  ListAttemptsResponseBody() {}

  explicit ListAttemptsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ListAttemptsResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ListAttemptsResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListAttemptsResponseBody() = default;
};
class ListAttemptsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListAttemptsResponseBody> body{};

  ListAttemptsResponse() {}

  explicit ListAttemptsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListAttemptsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListAttemptsResponseBody>(model1);
      }
    }
  }


  virtual ~ListAttemptsResponse() = default;
};
class ListAudioFilesRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};

  ListAudioFilesRequest() {}

  explicit ListAudioFilesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~ListAudioFilesRequest() = default;
};
class ListAudioFilesResponseBodyDataList : public Darabonba::Model {
public:
  shared_ptr<string> audioFileName{};
  shared_ptr<string> audioResourceId{};
  shared_ptr<string> createdTime{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> name{};
  shared_ptr<string> ossFileKey{};
  shared_ptr<string> updatedTime{};

  ListAudioFilesResponseBodyDataList() {}

  explicit ListAudioFilesResponseBodyDataList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (audioFileName) {
      res["AudioFileName"] = boost::any(*audioFileName);
    }
    if (audioResourceId) {
      res["AudioResourceId"] = boost::any(*audioResourceId);
    }
    if (createdTime) {
      res["CreatedTime"] = boost::any(*createdTime);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (ossFileKey) {
      res["OssFileKey"] = boost::any(*ossFileKey);
    }
    if (updatedTime) {
      res["UpdatedTime"] = boost::any(*updatedTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AudioFileName") != m.end() && !m["AudioFileName"].empty()) {
      audioFileName = make_shared<string>(boost::any_cast<string>(m["AudioFileName"]));
    }
    if (m.find("AudioResourceId") != m.end() && !m["AudioResourceId"].empty()) {
      audioResourceId = make_shared<string>(boost::any_cast<string>(m["AudioResourceId"]));
    }
    if (m.find("CreatedTime") != m.end() && !m["CreatedTime"].empty()) {
      createdTime = make_shared<string>(boost::any_cast<string>(m["CreatedTime"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("OssFileKey") != m.end() && !m["OssFileKey"].empty()) {
      ossFileKey = make_shared<string>(boost::any_cast<string>(m["OssFileKey"]));
    }
    if (m.find("UpdatedTime") != m.end() && !m["UpdatedTime"].empty()) {
      updatedTime = make_shared<string>(boost::any_cast<string>(m["UpdatedTime"]));
    }
  }


  virtual ~ListAudioFilesResponseBodyDataList() = default;
};
class ListAudioFilesResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<ListAudioFilesResponseBodyDataList>> list{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  ListAudioFilesResponseBodyData() {}

  explicit ListAudioFilesResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (list) {
      vector<boost::any> temp1;
      for(auto item1:*list){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["List"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(vector<boost::any>) == m["List"].type()) {
        vector<ListAudioFilesResponseBodyDataList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["List"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListAudioFilesResponseBodyDataList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        list = make_shared<vector<ListAudioFilesResponseBodyDataList>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListAudioFilesResponseBodyData() = default;
};
class ListAudioFilesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<ListAudioFilesResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  ListAudioFilesResponseBody() {}

  explicit ListAudioFilesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ListAudioFilesResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ListAudioFilesResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListAudioFilesResponseBody() = default;
};
class ListAudioFilesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListAudioFilesResponseBody> body{};

  ListAudioFilesResponse() {}

  explicit ListAudioFilesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListAudioFilesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListAudioFilesResponseBody>(model1);
      }
    }
  }


  virtual ~ListAudioFilesResponse() = default;
};
class ListBriefSkillGroupsRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> searchPattern{};

  ListBriefSkillGroupsRequest() {}

  explicit ListBriefSkillGroupsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (searchPattern) {
      res["SearchPattern"] = boost::any(*searchPattern);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SearchPattern") != m.end() && !m["SearchPattern"].empty()) {
      searchPattern = make_shared<string>(boost::any_cast<string>(m["SearchPattern"]));
    }
  }


  virtual ~ListBriefSkillGroupsRequest() = default;
};
class ListBriefSkillGroupsResponseBodyDataList : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> displayName{};
  shared_ptr<string> instanceId{};
  shared_ptr<long> phoneNumberCount{};
  shared_ptr<string> skillGroupId{};
  shared_ptr<string> skillGroupName{};
  shared_ptr<long> userCount{};

  ListBriefSkillGroupsResponseBodyDataList() {}

  explicit ListBriefSkillGroupsResponseBodyDataList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (displayName) {
      res["DisplayName"] = boost::any(*displayName);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (phoneNumberCount) {
      res["PhoneNumberCount"] = boost::any(*phoneNumberCount);
    }
    if (skillGroupId) {
      res["SkillGroupId"] = boost::any(*skillGroupId);
    }
    if (skillGroupName) {
      res["SkillGroupName"] = boost::any(*skillGroupName);
    }
    if (userCount) {
      res["UserCount"] = boost::any(*userCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DisplayName") != m.end() && !m["DisplayName"].empty()) {
      displayName = make_shared<string>(boost::any_cast<string>(m["DisplayName"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("PhoneNumberCount") != m.end() && !m["PhoneNumberCount"].empty()) {
      phoneNumberCount = make_shared<long>(boost::any_cast<long>(m["PhoneNumberCount"]));
    }
    if (m.find("SkillGroupId") != m.end() && !m["SkillGroupId"].empty()) {
      skillGroupId = make_shared<string>(boost::any_cast<string>(m["SkillGroupId"]));
    }
    if (m.find("SkillGroupName") != m.end() && !m["SkillGroupName"].empty()) {
      skillGroupName = make_shared<string>(boost::any_cast<string>(m["SkillGroupName"]));
    }
    if (m.find("UserCount") != m.end() && !m["UserCount"].empty()) {
      userCount = make_shared<long>(boost::any_cast<long>(m["UserCount"]));
    }
  }


  virtual ~ListBriefSkillGroupsResponseBodyDataList() = default;
};
class ListBriefSkillGroupsResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<ListBriefSkillGroupsResponseBodyDataList>> list{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  ListBriefSkillGroupsResponseBodyData() {}

  explicit ListBriefSkillGroupsResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (list) {
      vector<boost::any> temp1;
      for(auto item1:*list){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["List"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(vector<boost::any>) == m["List"].type()) {
        vector<ListBriefSkillGroupsResponseBodyDataList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["List"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListBriefSkillGroupsResponseBodyDataList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        list = make_shared<vector<ListBriefSkillGroupsResponseBodyDataList>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListBriefSkillGroupsResponseBodyData() = default;
};
class ListBriefSkillGroupsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<ListBriefSkillGroupsResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  ListBriefSkillGroupsResponseBody() {}

  explicit ListBriefSkillGroupsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ListBriefSkillGroupsResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ListBriefSkillGroupsResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListBriefSkillGroupsResponseBody() = default;
};
class ListBriefSkillGroupsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListBriefSkillGroupsResponseBody> body{};

  ListBriefSkillGroupsResponse() {}

  explicit ListBriefSkillGroupsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListBriefSkillGroupsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListBriefSkillGroupsResponseBody>(model1);
      }
    }
  }


  virtual ~ListBriefSkillGroupsResponse() = default;
};
class ListCallDetailRecordsRequest : public Darabonba::Model {
public:
  shared_ptr<string> agentId{};
  shared_ptr<string> calledNumber{};
  shared_ptr<string> callingNumber{};
  shared_ptr<string> contactDisposition{};
  shared_ptr<string> contactDispositionList{};
  shared_ptr<string> contactId{};
  shared_ptr<string> contactType{};
  shared_ptr<string> contactTypeList{};
  shared_ptr<string> criteria{};
  shared_ptr<string> earlyMediaStateList{};
  shared_ptr<long> endTime{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> orderByField{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> satisfactionDescriptionList{};
  shared_ptr<string> satisfactionList{};
  shared_ptr<string> satisfactionSurveyChannel{};
  shared_ptr<string> skillGroupId{};
  shared_ptr<string> sortOrder{};
  shared_ptr<long> startTime{};

  ListCallDetailRecordsRequest() {}

  explicit ListCallDetailRecordsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agentId) {
      res["AgentId"] = boost::any(*agentId);
    }
    if (calledNumber) {
      res["CalledNumber"] = boost::any(*calledNumber);
    }
    if (callingNumber) {
      res["CallingNumber"] = boost::any(*callingNumber);
    }
    if (contactDisposition) {
      res["ContactDisposition"] = boost::any(*contactDisposition);
    }
    if (contactDispositionList) {
      res["ContactDispositionList"] = boost::any(*contactDispositionList);
    }
    if (contactId) {
      res["ContactId"] = boost::any(*contactId);
    }
    if (contactType) {
      res["ContactType"] = boost::any(*contactType);
    }
    if (contactTypeList) {
      res["ContactTypeList"] = boost::any(*contactTypeList);
    }
    if (criteria) {
      res["Criteria"] = boost::any(*criteria);
    }
    if (earlyMediaStateList) {
      res["EarlyMediaStateList"] = boost::any(*earlyMediaStateList);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (orderByField) {
      res["OrderByField"] = boost::any(*orderByField);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (satisfactionDescriptionList) {
      res["SatisfactionDescriptionList"] = boost::any(*satisfactionDescriptionList);
    }
    if (satisfactionList) {
      res["SatisfactionList"] = boost::any(*satisfactionList);
    }
    if (satisfactionSurveyChannel) {
      res["SatisfactionSurveyChannel"] = boost::any(*satisfactionSurveyChannel);
    }
    if (skillGroupId) {
      res["SkillGroupId"] = boost::any(*skillGroupId);
    }
    if (sortOrder) {
      res["SortOrder"] = boost::any(*sortOrder);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AgentId") != m.end() && !m["AgentId"].empty()) {
      agentId = make_shared<string>(boost::any_cast<string>(m["AgentId"]));
    }
    if (m.find("CalledNumber") != m.end() && !m["CalledNumber"].empty()) {
      calledNumber = make_shared<string>(boost::any_cast<string>(m["CalledNumber"]));
    }
    if (m.find("CallingNumber") != m.end() && !m["CallingNumber"].empty()) {
      callingNumber = make_shared<string>(boost::any_cast<string>(m["CallingNumber"]));
    }
    if (m.find("ContactDisposition") != m.end() && !m["ContactDisposition"].empty()) {
      contactDisposition = make_shared<string>(boost::any_cast<string>(m["ContactDisposition"]));
    }
    if (m.find("ContactDispositionList") != m.end() && !m["ContactDispositionList"].empty()) {
      contactDispositionList = make_shared<string>(boost::any_cast<string>(m["ContactDispositionList"]));
    }
    if (m.find("ContactId") != m.end() && !m["ContactId"].empty()) {
      contactId = make_shared<string>(boost::any_cast<string>(m["ContactId"]));
    }
    if (m.find("ContactType") != m.end() && !m["ContactType"].empty()) {
      contactType = make_shared<string>(boost::any_cast<string>(m["ContactType"]));
    }
    if (m.find("ContactTypeList") != m.end() && !m["ContactTypeList"].empty()) {
      contactTypeList = make_shared<string>(boost::any_cast<string>(m["ContactTypeList"]));
    }
    if (m.find("Criteria") != m.end() && !m["Criteria"].empty()) {
      criteria = make_shared<string>(boost::any_cast<string>(m["Criteria"]));
    }
    if (m.find("EarlyMediaStateList") != m.end() && !m["EarlyMediaStateList"].empty()) {
      earlyMediaStateList = make_shared<string>(boost::any_cast<string>(m["EarlyMediaStateList"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("OrderByField") != m.end() && !m["OrderByField"].empty()) {
      orderByField = make_shared<string>(boost::any_cast<string>(m["OrderByField"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SatisfactionDescriptionList") != m.end() && !m["SatisfactionDescriptionList"].empty()) {
      satisfactionDescriptionList = make_shared<string>(boost::any_cast<string>(m["SatisfactionDescriptionList"]));
    }
    if (m.find("SatisfactionList") != m.end() && !m["SatisfactionList"].empty()) {
      satisfactionList = make_shared<string>(boost::any_cast<string>(m["SatisfactionList"]));
    }
    if (m.find("SatisfactionSurveyChannel") != m.end() && !m["SatisfactionSurveyChannel"].empty()) {
      satisfactionSurveyChannel = make_shared<string>(boost::any_cast<string>(m["SatisfactionSurveyChannel"]));
    }
    if (m.find("SkillGroupId") != m.end() && !m["SkillGroupId"].empty()) {
      skillGroupId = make_shared<string>(boost::any_cast<string>(m["SkillGroupId"]));
    }
    if (m.find("SortOrder") != m.end() && !m["SortOrder"].empty()) {
      sortOrder = make_shared<string>(boost::any_cast<string>(m["SortOrder"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
  }


  virtual ~ListCallDetailRecordsRequest() = default;
};
class ListCallDetailRecordsResponseBodyDataList : public Darabonba::Model {
public:
  shared_ptr<string> additionalBroker{};
  shared_ptr<string> agentIds{};
  shared_ptr<string> agentNames{};
  shared_ptr<string> broker{};
  shared_ptr<string> callDuration{};
  shared_ptr<string> calledNumber{};
  shared_ptr<string> calleeLocation{};
  shared_ptr<string> callerLocation{};
  shared_ptr<string> callingNumber{};
  shared_ptr<string> contactDisposition{};
  shared_ptr<string> contactId{};
  shared_ptr<string> contactType{};
  shared_ptr<long> dialingTime{};
  shared_ptr<string> earlyMediaState{};
  shared_ptr<long> establishedTime{};
  shared_ptr<string> instanceId{};
  shared_ptr<long> ivrTime{};
  shared_ptr<long> queueTime{};
  shared_ptr<long> recordingDuration{};
  shared_ptr<bool> recordingReady{};
  shared_ptr<string> releaseInitiator{};
  shared_ptr<string> releaseReason{};
  shared_ptr<long> releaseTime{};
  shared_ptr<long> ringTime{};
  shared_ptr<string> satisfactionDescription{};
  shared_ptr<long> satisfactionIndex{};
  shared_ptr<string> satisfactionSurveyChannel{};
  shared_ptr<bool> satisfactionSurveyOffered{};
  shared_ptr<string> skillGroupIds{};
  shared_ptr<string> skillGroupNames{};
  shared_ptr<long> startTime{};
  shared_ptr<long> waitTime{};

  ListCallDetailRecordsResponseBodyDataList() {}

  explicit ListCallDetailRecordsResponseBodyDataList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (additionalBroker) {
      res["AdditionalBroker"] = boost::any(*additionalBroker);
    }
    if (agentIds) {
      res["AgentIds"] = boost::any(*agentIds);
    }
    if (agentNames) {
      res["AgentNames"] = boost::any(*agentNames);
    }
    if (broker) {
      res["Broker"] = boost::any(*broker);
    }
    if (callDuration) {
      res["CallDuration"] = boost::any(*callDuration);
    }
    if (calledNumber) {
      res["CalledNumber"] = boost::any(*calledNumber);
    }
    if (calleeLocation) {
      res["CalleeLocation"] = boost::any(*calleeLocation);
    }
    if (callerLocation) {
      res["CallerLocation"] = boost::any(*callerLocation);
    }
    if (callingNumber) {
      res["CallingNumber"] = boost::any(*callingNumber);
    }
    if (contactDisposition) {
      res["ContactDisposition"] = boost::any(*contactDisposition);
    }
    if (contactId) {
      res["ContactId"] = boost::any(*contactId);
    }
    if (contactType) {
      res["ContactType"] = boost::any(*contactType);
    }
    if (dialingTime) {
      res["DialingTime"] = boost::any(*dialingTime);
    }
    if (earlyMediaState) {
      res["EarlyMediaState"] = boost::any(*earlyMediaState);
    }
    if (establishedTime) {
      res["EstablishedTime"] = boost::any(*establishedTime);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (ivrTime) {
      res["IvrTime"] = boost::any(*ivrTime);
    }
    if (queueTime) {
      res["QueueTime"] = boost::any(*queueTime);
    }
    if (recordingDuration) {
      res["RecordingDuration"] = boost::any(*recordingDuration);
    }
    if (recordingReady) {
      res["RecordingReady"] = boost::any(*recordingReady);
    }
    if (releaseInitiator) {
      res["ReleaseInitiator"] = boost::any(*releaseInitiator);
    }
    if (releaseReason) {
      res["ReleaseReason"] = boost::any(*releaseReason);
    }
    if (releaseTime) {
      res["ReleaseTime"] = boost::any(*releaseTime);
    }
    if (ringTime) {
      res["RingTime"] = boost::any(*ringTime);
    }
    if (satisfactionDescription) {
      res["SatisfactionDescription"] = boost::any(*satisfactionDescription);
    }
    if (satisfactionIndex) {
      res["SatisfactionIndex"] = boost::any(*satisfactionIndex);
    }
    if (satisfactionSurveyChannel) {
      res["SatisfactionSurveyChannel"] = boost::any(*satisfactionSurveyChannel);
    }
    if (satisfactionSurveyOffered) {
      res["SatisfactionSurveyOffered"] = boost::any(*satisfactionSurveyOffered);
    }
    if (skillGroupIds) {
      res["SkillGroupIds"] = boost::any(*skillGroupIds);
    }
    if (skillGroupNames) {
      res["SkillGroupNames"] = boost::any(*skillGroupNames);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (waitTime) {
      res["WaitTime"] = boost::any(*waitTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AdditionalBroker") != m.end() && !m["AdditionalBroker"].empty()) {
      additionalBroker = make_shared<string>(boost::any_cast<string>(m["AdditionalBroker"]));
    }
    if (m.find("AgentIds") != m.end() && !m["AgentIds"].empty()) {
      agentIds = make_shared<string>(boost::any_cast<string>(m["AgentIds"]));
    }
    if (m.find("AgentNames") != m.end() && !m["AgentNames"].empty()) {
      agentNames = make_shared<string>(boost::any_cast<string>(m["AgentNames"]));
    }
    if (m.find("Broker") != m.end() && !m["Broker"].empty()) {
      broker = make_shared<string>(boost::any_cast<string>(m["Broker"]));
    }
    if (m.find("CallDuration") != m.end() && !m["CallDuration"].empty()) {
      callDuration = make_shared<string>(boost::any_cast<string>(m["CallDuration"]));
    }
    if (m.find("CalledNumber") != m.end() && !m["CalledNumber"].empty()) {
      calledNumber = make_shared<string>(boost::any_cast<string>(m["CalledNumber"]));
    }
    if (m.find("CalleeLocation") != m.end() && !m["CalleeLocation"].empty()) {
      calleeLocation = make_shared<string>(boost::any_cast<string>(m["CalleeLocation"]));
    }
    if (m.find("CallerLocation") != m.end() && !m["CallerLocation"].empty()) {
      callerLocation = make_shared<string>(boost::any_cast<string>(m["CallerLocation"]));
    }
    if (m.find("CallingNumber") != m.end() && !m["CallingNumber"].empty()) {
      callingNumber = make_shared<string>(boost::any_cast<string>(m["CallingNumber"]));
    }
    if (m.find("ContactDisposition") != m.end() && !m["ContactDisposition"].empty()) {
      contactDisposition = make_shared<string>(boost::any_cast<string>(m["ContactDisposition"]));
    }
    if (m.find("ContactId") != m.end() && !m["ContactId"].empty()) {
      contactId = make_shared<string>(boost::any_cast<string>(m["ContactId"]));
    }
    if (m.find("ContactType") != m.end() && !m["ContactType"].empty()) {
      contactType = make_shared<string>(boost::any_cast<string>(m["ContactType"]));
    }
    if (m.find("DialingTime") != m.end() && !m["DialingTime"].empty()) {
      dialingTime = make_shared<long>(boost::any_cast<long>(m["DialingTime"]));
    }
    if (m.find("EarlyMediaState") != m.end() && !m["EarlyMediaState"].empty()) {
      earlyMediaState = make_shared<string>(boost::any_cast<string>(m["EarlyMediaState"]));
    }
    if (m.find("EstablishedTime") != m.end() && !m["EstablishedTime"].empty()) {
      establishedTime = make_shared<long>(boost::any_cast<long>(m["EstablishedTime"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("IvrTime") != m.end() && !m["IvrTime"].empty()) {
      ivrTime = make_shared<long>(boost::any_cast<long>(m["IvrTime"]));
    }
    if (m.find("QueueTime") != m.end() && !m["QueueTime"].empty()) {
      queueTime = make_shared<long>(boost::any_cast<long>(m["QueueTime"]));
    }
    if (m.find("RecordingDuration") != m.end() && !m["RecordingDuration"].empty()) {
      recordingDuration = make_shared<long>(boost::any_cast<long>(m["RecordingDuration"]));
    }
    if (m.find("RecordingReady") != m.end() && !m["RecordingReady"].empty()) {
      recordingReady = make_shared<bool>(boost::any_cast<bool>(m["RecordingReady"]));
    }
    if (m.find("ReleaseInitiator") != m.end() && !m["ReleaseInitiator"].empty()) {
      releaseInitiator = make_shared<string>(boost::any_cast<string>(m["ReleaseInitiator"]));
    }
    if (m.find("ReleaseReason") != m.end() && !m["ReleaseReason"].empty()) {
      releaseReason = make_shared<string>(boost::any_cast<string>(m["ReleaseReason"]));
    }
    if (m.find("ReleaseTime") != m.end() && !m["ReleaseTime"].empty()) {
      releaseTime = make_shared<long>(boost::any_cast<long>(m["ReleaseTime"]));
    }
    if (m.find("RingTime") != m.end() && !m["RingTime"].empty()) {
      ringTime = make_shared<long>(boost::any_cast<long>(m["RingTime"]));
    }
    if (m.find("SatisfactionDescription") != m.end() && !m["SatisfactionDescription"].empty()) {
      satisfactionDescription = make_shared<string>(boost::any_cast<string>(m["SatisfactionDescription"]));
    }
    if (m.find("SatisfactionIndex") != m.end() && !m["SatisfactionIndex"].empty()) {
      satisfactionIndex = make_shared<long>(boost::any_cast<long>(m["SatisfactionIndex"]));
    }
    if (m.find("SatisfactionSurveyChannel") != m.end() && !m["SatisfactionSurveyChannel"].empty()) {
      satisfactionSurveyChannel = make_shared<string>(boost::any_cast<string>(m["SatisfactionSurveyChannel"]));
    }
    if (m.find("SatisfactionSurveyOffered") != m.end() && !m["SatisfactionSurveyOffered"].empty()) {
      satisfactionSurveyOffered = make_shared<bool>(boost::any_cast<bool>(m["SatisfactionSurveyOffered"]));
    }
    if (m.find("SkillGroupIds") != m.end() && !m["SkillGroupIds"].empty()) {
      skillGroupIds = make_shared<string>(boost::any_cast<string>(m["SkillGroupIds"]));
    }
    if (m.find("SkillGroupNames") != m.end() && !m["SkillGroupNames"].empty()) {
      skillGroupNames = make_shared<string>(boost::any_cast<string>(m["SkillGroupNames"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("WaitTime") != m.end() && !m["WaitTime"].empty()) {
      waitTime = make_shared<long>(boost::any_cast<long>(m["WaitTime"]));
    }
  }


  virtual ~ListCallDetailRecordsResponseBodyDataList() = default;
};
class ListCallDetailRecordsResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<ListCallDetailRecordsResponseBodyDataList>> list{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  ListCallDetailRecordsResponseBodyData() {}

  explicit ListCallDetailRecordsResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (list) {
      vector<boost::any> temp1;
      for(auto item1:*list){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["List"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(vector<boost::any>) == m["List"].type()) {
        vector<ListCallDetailRecordsResponseBodyDataList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["List"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListCallDetailRecordsResponseBodyDataList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        list = make_shared<vector<ListCallDetailRecordsResponseBodyDataList>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListCallDetailRecordsResponseBodyData() = default;
};
class ListCallDetailRecordsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<ListCallDetailRecordsResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  ListCallDetailRecordsResponseBody() {}

  explicit ListCallDetailRecordsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ListCallDetailRecordsResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ListCallDetailRecordsResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListCallDetailRecordsResponseBody() = default;
};
class ListCallDetailRecordsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListCallDetailRecordsResponseBody> body{};

  ListCallDetailRecordsResponse() {}

  explicit ListCallDetailRecordsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListCallDetailRecordsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListCallDetailRecordsResponseBody>(model1);
      }
    }
  }


  virtual ~ListCallDetailRecordsResponse() = default;
};
class ListCallTagsRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};

  ListCallTagsRequest() {}

  explicit ListCallTagsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~ListCallTagsRequest() = default;
};
class ListCallTagsResponseBodyDataList : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> tagName{};

  ListCallTagsResponseBodyDataList() {}

  explicit ListCallTagsResponseBodyDataList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (tagName) {
      res["TagName"] = boost::any(*tagName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("TagName") != m.end() && !m["TagName"].empty()) {
      tagName = make_shared<string>(boost::any_cast<string>(m["TagName"]));
    }
  }


  virtual ~ListCallTagsResponseBodyDataList() = default;
};
class ListCallTagsResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<ListCallTagsResponseBodyDataList>> list{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  ListCallTagsResponseBodyData() {}

  explicit ListCallTagsResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (list) {
      vector<boost::any> temp1;
      for(auto item1:*list){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["List"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(vector<boost::any>) == m["List"].type()) {
        vector<ListCallTagsResponseBodyDataList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["List"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListCallTagsResponseBodyDataList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        list = make_shared<vector<ListCallTagsResponseBodyDataList>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListCallTagsResponseBodyData() = default;
};
class ListCallTagsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<ListCallTagsResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  ListCallTagsResponseBody() {}

  explicit ListCallTagsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ListCallTagsResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ListCallTagsResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListCallTagsResponseBody() = default;
};
class ListCallTagsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListCallTagsResponseBody> body{};

  ListCallTagsResponse() {}

  explicit ListCallTagsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListCallTagsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListCallTagsResponseBody>(model1);
      }
    }
  }


  virtual ~ListCallTagsResponse() = default;
};
class ListCampaignTrendingReportRequest : public Darabonba::Model {
public:
  shared_ptr<string> campaignId{};
  shared_ptr<long> endTime{};
  shared_ptr<string> instanceId{};
  shared_ptr<long> startTime{};

  ListCampaignTrendingReportRequest() {}

  explicit ListCampaignTrendingReportRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (campaignId) {
      res["CampaignId"] = boost::any(*campaignId);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CampaignId") != m.end() && !m["CampaignId"].empty()) {
      campaignId = make_shared<string>(boost::any_cast<string>(m["CampaignId"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
  }


  virtual ~ListCampaignTrendingReportRequest() = default;
};
class ListCampaignTrendingReportResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> breakAgents{};
  shared_ptr<long> concurrency{};
  shared_ptr<long> datetime{};
  shared_ptr<long> loggedInAgents{};
  shared_ptr<long> readyAgents{};
  shared_ptr<long> talkAgents{};
  shared_ptr<long> workAgents{};

  ListCampaignTrendingReportResponseBodyData() {}

  explicit ListCampaignTrendingReportResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (breakAgents) {
      res["BreakAgents"] = boost::any(*breakAgents);
    }
    if (concurrency) {
      res["Concurrency"] = boost::any(*concurrency);
    }
    if (datetime) {
      res["Datetime"] = boost::any(*datetime);
    }
    if (loggedInAgents) {
      res["LoggedInAgents"] = boost::any(*loggedInAgents);
    }
    if (readyAgents) {
      res["ReadyAgents"] = boost::any(*readyAgents);
    }
    if (talkAgents) {
      res["TalkAgents"] = boost::any(*talkAgents);
    }
    if (workAgents) {
      res["WorkAgents"] = boost::any(*workAgents);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BreakAgents") != m.end() && !m["BreakAgents"].empty()) {
      breakAgents = make_shared<long>(boost::any_cast<long>(m["BreakAgents"]));
    }
    if (m.find("Concurrency") != m.end() && !m["Concurrency"].empty()) {
      concurrency = make_shared<long>(boost::any_cast<long>(m["Concurrency"]));
    }
    if (m.find("Datetime") != m.end() && !m["Datetime"].empty()) {
      datetime = make_shared<long>(boost::any_cast<long>(m["Datetime"]));
    }
    if (m.find("LoggedInAgents") != m.end() && !m["LoggedInAgents"].empty()) {
      loggedInAgents = make_shared<long>(boost::any_cast<long>(m["LoggedInAgents"]));
    }
    if (m.find("ReadyAgents") != m.end() && !m["ReadyAgents"].empty()) {
      readyAgents = make_shared<long>(boost::any_cast<long>(m["ReadyAgents"]));
    }
    if (m.find("TalkAgents") != m.end() && !m["TalkAgents"].empty()) {
      talkAgents = make_shared<long>(boost::any_cast<long>(m["TalkAgents"]));
    }
    if (m.find("WorkAgents") != m.end() && !m["WorkAgents"].empty()) {
      workAgents = make_shared<long>(boost::any_cast<long>(m["WorkAgents"]));
    }
  }


  virtual ~ListCampaignTrendingReportResponseBodyData() = default;
};
class ListCampaignTrendingReportResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<vector<ListCampaignTrendingReportResponseBodyData>> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  ListCampaignTrendingReportResponseBody() {}

  explicit ListCampaignTrendingReportResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<ListCampaignTrendingReportResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListCampaignTrendingReportResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<ListCampaignTrendingReportResponseBodyData>>(expect1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListCampaignTrendingReportResponseBody() = default;
};
class ListCampaignTrendingReportResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListCampaignTrendingReportResponseBody> body{};

  ListCampaignTrendingReportResponse() {}

  explicit ListCampaignTrendingReportResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListCampaignTrendingReportResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListCampaignTrendingReportResponseBody>(model1);
      }
    }
  }


  virtual ~ListCampaignTrendingReportResponse() = default;
};
class ListCampaignsRequest : public Darabonba::Model {
public:
  shared_ptr<string> actualStartTimeFrom{};
  shared_ptr<string> actualStartTimeTo{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> name{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> planedStartTimeFrom{};
  shared_ptr<string> planedStartTimeTo{};
  shared_ptr<string> queueId{};
  shared_ptr<string> state{};

  ListCampaignsRequest() {}

  explicit ListCampaignsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (actualStartTimeFrom) {
      res["ActualStartTimeFrom"] = boost::any(*actualStartTimeFrom);
    }
    if (actualStartTimeTo) {
      res["ActualStartTimeTo"] = boost::any(*actualStartTimeTo);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (planedStartTimeFrom) {
      res["PlanedStartTimeFrom"] = boost::any(*planedStartTimeFrom);
    }
    if (planedStartTimeTo) {
      res["PlanedStartTimeTo"] = boost::any(*planedStartTimeTo);
    }
    if (queueId) {
      res["QueueId"] = boost::any(*queueId);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ActualStartTimeFrom") != m.end() && !m["ActualStartTimeFrom"].empty()) {
      actualStartTimeFrom = make_shared<string>(boost::any_cast<string>(m["ActualStartTimeFrom"]));
    }
    if (m.find("ActualStartTimeTo") != m.end() && !m["ActualStartTimeTo"].empty()) {
      actualStartTimeTo = make_shared<string>(boost::any_cast<string>(m["ActualStartTimeTo"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("PlanedStartTimeFrom") != m.end() && !m["PlanedStartTimeFrom"].empty()) {
      planedStartTimeFrom = make_shared<string>(boost::any_cast<string>(m["PlanedStartTimeFrom"]));
    }
    if (m.find("PlanedStartTimeTo") != m.end() && !m["PlanedStartTimeTo"].empty()) {
      planedStartTimeTo = make_shared<string>(boost::any_cast<string>(m["PlanedStartTimeTo"]));
    }
    if (m.find("QueueId") != m.end() && !m["QueueId"].empty()) {
      queueId = make_shared<string>(boost::any_cast<string>(m["QueueId"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
  }


  virtual ~ListCampaignsRequest() = default;
};
class ListCampaignsResponseBodyDataList : public Darabonba::Model {
public:
  shared_ptr<long> actualEndTime{};
  shared_ptr<long> actualStartTime{};
  shared_ptr<string> campaignId{};
  shared_ptr<long> casesAborted{};
  shared_ptr<long> casesConnected{};
  shared_ptr<long> casesUncompleted{};
  shared_ptr<long> maxAttemptCount{};
  shared_ptr<long> minAttemptInterval{};
  shared_ptr<string> name{};
  shared_ptr<long> planedEndTime{};
  shared_ptr<long> planedStartTime{};
  shared_ptr<string> queueId{};
  shared_ptr<string> queueName{};
  shared_ptr<bool> simulation{};
  shared_ptr<string> state{};
  shared_ptr<string> strategyParameters{};
  shared_ptr<string> strategyType{};
  shared_ptr<long> totalCases{};

  ListCampaignsResponseBodyDataList() {}

  explicit ListCampaignsResponseBodyDataList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (actualEndTime) {
      res["ActualEndTime"] = boost::any(*actualEndTime);
    }
    if (actualStartTime) {
      res["ActualStartTime"] = boost::any(*actualStartTime);
    }
    if (campaignId) {
      res["CampaignId"] = boost::any(*campaignId);
    }
    if (casesAborted) {
      res["CasesAborted"] = boost::any(*casesAborted);
    }
    if (casesConnected) {
      res["CasesConnected"] = boost::any(*casesConnected);
    }
    if (casesUncompleted) {
      res["CasesUncompleted"] = boost::any(*casesUncompleted);
    }
    if (maxAttemptCount) {
      res["MaxAttemptCount"] = boost::any(*maxAttemptCount);
    }
    if (minAttemptInterval) {
      res["MinAttemptInterval"] = boost::any(*minAttemptInterval);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (planedEndTime) {
      res["PlanedEndTime"] = boost::any(*planedEndTime);
    }
    if (planedStartTime) {
      res["PlanedStartTime"] = boost::any(*planedStartTime);
    }
    if (queueId) {
      res["QueueId"] = boost::any(*queueId);
    }
    if (queueName) {
      res["QueueName"] = boost::any(*queueName);
    }
    if (simulation) {
      res["Simulation"] = boost::any(*simulation);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (strategyParameters) {
      res["StrategyParameters"] = boost::any(*strategyParameters);
    }
    if (strategyType) {
      res["StrategyType"] = boost::any(*strategyType);
    }
    if (totalCases) {
      res["TotalCases"] = boost::any(*totalCases);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ActualEndTime") != m.end() && !m["ActualEndTime"].empty()) {
      actualEndTime = make_shared<long>(boost::any_cast<long>(m["ActualEndTime"]));
    }
    if (m.find("ActualStartTime") != m.end() && !m["ActualStartTime"].empty()) {
      actualStartTime = make_shared<long>(boost::any_cast<long>(m["ActualStartTime"]));
    }
    if (m.find("CampaignId") != m.end() && !m["CampaignId"].empty()) {
      campaignId = make_shared<string>(boost::any_cast<string>(m["CampaignId"]));
    }
    if (m.find("CasesAborted") != m.end() && !m["CasesAborted"].empty()) {
      casesAborted = make_shared<long>(boost::any_cast<long>(m["CasesAborted"]));
    }
    if (m.find("CasesConnected") != m.end() && !m["CasesConnected"].empty()) {
      casesConnected = make_shared<long>(boost::any_cast<long>(m["CasesConnected"]));
    }
    if (m.find("CasesUncompleted") != m.end() && !m["CasesUncompleted"].empty()) {
      casesUncompleted = make_shared<long>(boost::any_cast<long>(m["CasesUncompleted"]));
    }
    if (m.find("MaxAttemptCount") != m.end() && !m["MaxAttemptCount"].empty()) {
      maxAttemptCount = make_shared<long>(boost::any_cast<long>(m["MaxAttemptCount"]));
    }
    if (m.find("MinAttemptInterval") != m.end() && !m["MinAttemptInterval"].empty()) {
      minAttemptInterval = make_shared<long>(boost::any_cast<long>(m["MinAttemptInterval"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("PlanedEndTime") != m.end() && !m["PlanedEndTime"].empty()) {
      planedEndTime = make_shared<long>(boost::any_cast<long>(m["PlanedEndTime"]));
    }
    if (m.find("PlanedStartTime") != m.end() && !m["PlanedStartTime"].empty()) {
      planedStartTime = make_shared<long>(boost::any_cast<long>(m["PlanedStartTime"]));
    }
    if (m.find("QueueId") != m.end() && !m["QueueId"].empty()) {
      queueId = make_shared<string>(boost::any_cast<string>(m["QueueId"]));
    }
    if (m.find("QueueName") != m.end() && !m["QueueName"].empty()) {
      queueName = make_shared<string>(boost::any_cast<string>(m["QueueName"]));
    }
    if (m.find("Simulation") != m.end() && !m["Simulation"].empty()) {
      simulation = make_shared<bool>(boost::any_cast<bool>(m["Simulation"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("StrategyParameters") != m.end() && !m["StrategyParameters"].empty()) {
      strategyParameters = make_shared<string>(boost::any_cast<string>(m["StrategyParameters"]));
    }
    if (m.find("StrategyType") != m.end() && !m["StrategyType"].empty()) {
      strategyType = make_shared<string>(boost::any_cast<string>(m["StrategyType"]));
    }
    if (m.find("TotalCases") != m.end() && !m["TotalCases"].empty()) {
      totalCases = make_shared<long>(boost::any_cast<long>(m["TotalCases"]));
    }
  }


  virtual ~ListCampaignsResponseBodyDataList() = default;
};
class ListCampaignsResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<ListCampaignsResponseBodyDataList>> list{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  ListCampaignsResponseBodyData() {}

  explicit ListCampaignsResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (list) {
      vector<boost::any> temp1;
      for(auto item1:*list){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["List"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(vector<boost::any>) == m["List"].type()) {
        vector<ListCampaignsResponseBodyDataList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["List"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListCampaignsResponseBodyDataList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        list = make_shared<vector<ListCampaignsResponseBodyDataList>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListCampaignsResponseBodyData() = default;
};
class ListCampaignsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<ListCampaignsResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ListCampaignsResponseBody() {}

  explicit ListCampaignsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ListCampaignsResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ListCampaignsResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ListCampaignsResponseBody() = default;
};
class ListCampaignsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListCampaignsResponseBody> body{};

  ListCampaignsResponse() {}

  explicit ListCampaignsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListCampaignsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListCampaignsResponseBody>(model1);
      }
    }
  }


  virtual ~ListCampaignsResponse() = default;
};
class ListCasesRequest : public Darabonba::Model {
public:
  shared_ptr<string> campaignId{};
  shared_ptr<string> instanceId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> phoneNumber{};

  ListCasesRequest() {}

  explicit ListCasesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (campaignId) {
      res["CampaignId"] = boost::any(*campaignId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (phoneNumber) {
      res["PhoneNumber"] = boost::any(*phoneNumber);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CampaignId") != m.end() && !m["CampaignId"].empty()) {
      campaignId = make_shared<string>(boost::any_cast<string>(m["CampaignId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("PhoneNumber") != m.end() && !m["PhoneNumber"].empty()) {
      phoneNumber = make_shared<string>(boost::any_cast<string>(m["PhoneNumber"]));
    }
  }


  virtual ~ListCasesRequest() = default;
};
class ListCasesResponseBodyDataList : public Darabonba::Model {
public:
  shared_ptr<string> abandonType{};
  shared_ptr<long> attemptCount{};
  shared_ptr<string> caseId{};
  shared_ptr<string> customVariables{};
  shared_ptr<string> failureReason{};
  shared_ptr<string> phoneNumber{};
  shared_ptr<string> state{};

  ListCasesResponseBodyDataList() {}

  explicit ListCasesResponseBodyDataList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (abandonType) {
      res["AbandonType"] = boost::any(*abandonType);
    }
    if (attemptCount) {
      res["AttemptCount"] = boost::any(*attemptCount);
    }
    if (caseId) {
      res["CaseId"] = boost::any(*caseId);
    }
    if (customVariables) {
      res["CustomVariables"] = boost::any(*customVariables);
    }
    if (failureReason) {
      res["FailureReason"] = boost::any(*failureReason);
    }
    if (phoneNumber) {
      res["PhoneNumber"] = boost::any(*phoneNumber);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AbandonType") != m.end() && !m["AbandonType"].empty()) {
      abandonType = make_shared<string>(boost::any_cast<string>(m["AbandonType"]));
    }
    if (m.find("AttemptCount") != m.end() && !m["AttemptCount"].empty()) {
      attemptCount = make_shared<long>(boost::any_cast<long>(m["AttemptCount"]));
    }
    if (m.find("CaseId") != m.end() && !m["CaseId"].empty()) {
      caseId = make_shared<string>(boost::any_cast<string>(m["CaseId"]));
    }
    if (m.find("CustomVariables") != m.end() && !m["CustomVariables"].empty()) {
      customVariables = make_shared<string>(boost::any_cast<string>(m["CustomVariables"]));
    }
    if (m.find("FailureReason") != m.end() && !m["FailureReason"].empty()) {
      failureReason = make_shared<string>(boost::any_cast<string>(m["FailureReason"]));
    }
    if (m.find("PhoneNumber") != m.end() && !m["PhoneNumber"].empty()) {
      phoneNumber = make_shared<string>(boost::any_cast<string>(m["PhoneNumber"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
  }


  virtual ~ListCasesResponseBodyDataList() = default;
};
class ListCasesResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<ListCasesResponseBodyDataList>> list{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  ListCasesResponseBodyData() {}

  explicit ListCasesResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (list) {
      vector<boost::any> temp1;
      for(auto item1:*list){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["List"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(vector<boost::any>) == m["List"].type()) {
        vector<ListCasesResponseBodyDataList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["List"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListCasesResponseBodyDataList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        list = make_shared<vector<ListCasesResponseBodyDataList>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListCasesResponseBodyData() = default;
};
class ListCasesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<ListCasesResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  ListCasesResponseBody() {}

  explicit ListCasesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ListCasesResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ListCasesResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListCasesResponseBody() = default;
};
class ListCasesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListCasesResponseBody> body{};

  ListCasesResponse() {}

  explicit ListCasesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListCasesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListCasesResponseBody>(model1);
      }
    }
  }


  virtual ~ListCasesResponse() = default;
};
class ListConfigItemsRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> objectId{};
  shared_ptr<string> objectType{};

  ListConfigItemsRequest() {}

  explicit ListConfigItemsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (objectId) {
      res["ObjectId"] = boost::any(*objectId);
    }
    if (objectType) {
      res["ObjectType"] = boost::any(*objectType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("ObjectId") != m.end() && !m["ObjectId"].empty()) {
      objectId = make_shared<string>(boost::any_cast<string>(m["ObjectId"]));
    }
    if (m.find("ObjectType") != m.end() && !m["ObjectType"].empty()) {
      objectType = make_shared<string>(boost::any_cast<string>(m["ObjectType"]));
    }
  }


  virtual ~ListConfigItemsRequest() = default;
};
class ListConfigItemsResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> name{};
  shared_ptr<string> objectId{};
  shared_ptr<string> objectType{};
  shared_ptr<string> value{};

  ListConfigItemsResponseBodyData() {}

  explicit ListConfigItemsResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (objectId) {
      res["ObjectId"] = boost::any(*objectId);
    }
    if (objectType) {
      res["ObjectType"] = boost::any(*objectType);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ObjectId") != m.end() && !m["ObjectId"].empty()) {
      objectId = make_shared<string>(boost::any_cast<string>(m["ObjectId"]));
    }
    if (m.find("ObjectType") != m.end() && !m["ObjectType"].empty()) {
      objectType = make_shared<string>(boost::any_cast<string>(m["ObjectType"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~ListConfigItemsResponseBodyData() = default;
};
class ListConfigItemsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<vector<ListConfigItemsResponseBodyData>> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<vector<string>> params{};
  shared_ptr<string> requestId{};

  ListConfigItemsResponseBody() {}

  explicit ListConfigItemsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (params) {
      res["Params"] = boost::any(*params);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<ListConfigItemsResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListConfigItemsResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<ListConfigItemsResponseBodyData>>(expect1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Params") != m.end() && !m["Params"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Params"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Params"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      params = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListConfigItemsResponseBody() = default;
};
class ListConfigItemsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListConfigItemsResponseBody> body{};

  ListConfigItemsResponse() {}

  explicit ListConfigItemsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListConfigItemsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListConfigItemsResponseBody>(model1);
      }
    }
  }


  virtual ~ListConfigItemsResponse() = default;
};
class ListContactFlowsRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> type{};

  ListContactFlowsRequest() {}

  explicit ListContactFlowsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListContactFlowsRequest() = default;
};
class ListContactFlowsResponseBodyDataList : public Darabonba::Model {
public:
  shared_ptr<string> contactFlowId{};
  shared_ptr<string> createdTime{};
  shared_ptr<string> definition{};
  shared_ptr<string> description{};
  shared_ptr<string> draftId{};
  shared_ptr<string> editor{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> name{};
  shared_ptr<vector<string>> numberList{};
  shared_ptr<bool> published{};
  shared_ptr<string> type{};
  shared_ptr<string> updatedTime{};

  ListContactFlowsResponseBodyDataList() {}

  explicit ListContactFlowsResponseBodyDataList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contactFlowId) {
      res["ContactFlowId"] = boost::any(*contactFlowId);
    }
    if (createdTime) {
      res["CreatedTime"] = boost::any(*createdTime);
    }
    if (definition) {
      res["Definition"] = boost::any(*definition);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (draftId) {
      res["DraftId"] = boost::any(*draftId);
    }
    if (editor) {
      res["Editor"] = boost::any(*editor);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (numberList) {
      res["NumberList"] = boost::any(*numberList);
    }
    if (published) {
      res["Published"] = boost::any(*published);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (updatedTime) {
      res["UpdatedTime"] = boost::any(*updatedTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ContactFlowId") != m.end() && !m["ContactFlowId"].empty()) {
      contactFlowId = make_shared<string>(boost::any_cast<string>(m["ContactFlowId"]));
    }
    if (m.find("CreatedTime") != m.end() && !m["CreatedTime"].empty()) {
      createdTime = make_shared<string>(boost::any_cast<string>(m["CreatedTime"]));
    }
    if (m.find("Definition") != m.end() && !m["Definition"].empty()) {
      definition = make_shared<string>(boost::any_cast<string>(m["Definition"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DraftId") != m.end() && !m["DraftId"].empty()) {
      draftId = make_shared<string>(boost::any_cast<string>(m["DraftId"]));
    }
    if (m.find("Editor") != m.end() && !m["Editor"].empty()) {
      editor = make_shared<string>(boost::any_cast<string>(m["Editor"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("NumberList") != m.end() && !m["NumberList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["NumberList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["NumberList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      numberList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Published") != m.end() && !m["Published"].empty()) {
      published = make_shared<bool>(boost::any_cast<bool>(m["Published"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("UpdatedTime") != m.end() && !m["UpdatedTime"].empty()) {
      updatedTime = make_shared<string>(boost::any_cast<string>(m["UpdatedTime"]));
    }
  }


  virtual ~ListContactFlowsResponseBodyDataList() = default;
};
class ListContactFlowsResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<ListContactFlowsResponseBodyDataList>> list{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  ListContactFlowsResponseBodyData() {}

  explicit ListContactFlowsResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (list) {
      vector<boost::any> temp1;
      for(auto item1:*list){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["List"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(vector<boost::any>) == m["List"].type()) {
        vector<ListContactFlowsResponseBodyDataList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["List"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListContactFlowsResponseBodyDataList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        list = make_shared<vector<ListContactFlowsResponseBodyDataList>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListContactFlowsResponseBodyData() = default;
};
class ListContactFlowsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<ListContactFlowsResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  ListContactFlowsResponseBody() {}

  explicit ListContactFlowsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ListContactFlowsResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ListContactFlowsResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListContactFlowsResponseBody() = default;
};
class ListContactFlowsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListContactFlowsResponseBody> body{};

  ListContactFlowsResponse() {}

  explicit ListContactFlowsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListContactFlowsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListContactFlowsResponseBody>(model1);
      }
    }
  }


  virtual ~ListContactFlowsResponse() = default;
};
class ListCustomCallTaggingRequest : public Darabonba::Model {
public:
  shared_ptr<string> callTagNameList{};
  shared_ptr<string> instanceId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> searchPattern{};

  ListCustomCallTaggingRequest() {}

  explicit ListCustomCallTaggingRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callTagNameList) {
      res["CallTagNameList"] = boost::any(*callTagNameList);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (searchPattern) {
      res["SearchPattern"] = boost::any(*searchPattern);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallTagNameList") != m.end() && !m["CallTagNameList"].empty()) {
      callTagNameList = make_shared<string>(boost::any_cast<string>(m["CallTagNameList"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SearchPattern") != m.end() && !m["SearchPattern"].empty()) {
      searchPattern = make_shared<string>(boost::any_cast<string>(m["SearchPattern"]));
    }
  }


  virtual ~ListCustomCallTaggingRequest() = default;
};
class ListCustomCallTaggingResponseBodyDataListCallTagList : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> tagName{};

  ListCustomCallTaggingResponseBodyDataListCallTagList() {}

  explicit ListCustomCallTaggingResponseBodyDataListCallTagList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (tagName) {
      res["TagName"] = boost::any(*tagName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("TagName") != m.end() && !m["TagName"].empty()) {
      tagName = make_shared<string>(boost::any_cast<string>(m["TagName"]));
    }
  }


  virtual ~ListCustomCallTaggingResponseBodyDataListCallTagList() = default;
};
class ListCustomCallTaggingResponseBodyDataList : public Darabonba::Model {
public:
  shared_ptr<vector<ListCustomCallTaggingResponseBodyDataListCallTagList>> callTagList{};
  shared_ptr<string> creator{};
  shared_ptr<string> description{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> number{};
  shared_ptr<string> updateTime{};

  ListCustomCallTaggingResponseBodyDataList() {}

  explicit ListCustomCallTaggingResponseBodyDataList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callTagList) {
      vector<boost::any> temp1;
      for(auto item1:*callTagList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CallTagList"] = boost::any(temp1);
    }
    if (creator) {
      res["Creator"] = boost::any(*creator);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (number) {
      res["Number"] = boost::any(*number);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallTagList") != m.end() && !m["CallTagList"].empty()) {
      if (typeid(vector<boost::any>) == m["CallTagList"].type()) {
        vector<ListCustomCallTaggingResponseBodyDataListCallTagList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CallTagList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListCustomCallTaggingResponseBodyDataListCallTagList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        callTagList = make_shared<vector<ListCustomCallTaggingResponseBodyDataListCallTagList>>(expect1);
      }
    }
    if (m.find("Creator") != m.end() && !m["Creator"].empty()) {
      creator = make_shared<string>(boost::any_cast<string>(m["Creator"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Number") != m.end() && !m["Number"].empty()) {
      number = make_shared<string>(boost::any_cast<string>(m["Number"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<string>(boost::any_cast<string>(m["UpdateTime"]));
    }
  }


  virtual ~ListCustomCallTaggingResponseBodyDataList() = default;
};
class ListCustomCallTaggingResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<ListCustomCallTaggingResponseBodyDataList>> list{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  ListCustomCallTaggingResponseBodyData() {}

  explicit ListCustomCallTaggingResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (list) {
      vector<boost::any> temp1;
      for(auto item1:*list){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["List"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(vector<boost::any>) == m["List"].type()) {
        vector<ListCustomCallTaggingResponseBodyDataList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["List"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListCustomCallTaggingResponseBodyDataList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        list = make_shared<vector<ListCustomCallTaggingResponseBodyDataList>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListCustomCallTaggingResponseBodyData() = default;
};
class ListCustomCallTaggingResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<ListCustomCallTaggingResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  ListCustomCallTaggingResponseBody() {}

  explicit ListCustomCallTaggingResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ListCustomCallTaggingResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ListCustomCallTaggingResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListCustomCallTaggingResponseBody() = default;
};
class ListCustomCallTaggingResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListCustomCallTaggingResponseBody> body{};

  ListCustomCallTaggingResponse() {}

  explicit ListCustomCallTaggingResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListCustomCallTaggingResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListCustomCallTaggingResponseBody>(model1);
      }
    }
  }


  virtual ~ListCustomCallTaggingResponse() = default;
};
class ListDevicesRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> userId{};

  ListDevicesRequest() {}

  explicit ListDevicesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~ListDevicesRequest() = default;
};
class ListDevicesResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> callId{};
  shared_ptr<string> contact{};
  shared_ptr<string> deviceId{};
  shared_ptr<long> expires{};
  shared_ptr<string> extension{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> userId{};

  ListDevicesResponseBodyData() {}

  explicit ListDevicesResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callId) {
      res["CallId"] = boost::any(*callId);
    }
    if (contact) {
      res["Contact"] = boost::any(*contact);
    }
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (expires) {
      res["Expires"] = boost::any(*expires);
    }
    if (extension) {
      res["Extension"] = boost::any(*extension);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallId") != m.end() && !m["CallId"].empty()) {
      callId = make_shared<string>(boost::any_cast<string>(m["CallId"]));
    }
    if (m.find("Contact") != m.end() && !m["Contact"].empty()) {
      contact = make_shared<string>(boost::any_cast<string>(m["Contact"]));
    }
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("Expires") != m.end() && !m["Expires"].empty()) {
      expires = make_shared<long>(boost::any_cast<long>(m["Expires"]));
    }
    if (m.find("Extension") != m.end() && !m["Extension"].empty()) {
      extension = make_shared<string>(boost::any_cast<string>(m["Extension"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~ListDevicesResponseBodyData() = default;
};
class ListDevicesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<vector<ListDevicesResponseBodyData>> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<vector<string>> params{};
  shared_ptr<string> requestId{};

  ListDevicesResponseBody() {}

  explicit ListDevicesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (params) {
      res["Params"] = boost::any(*params);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<ListDevicesResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDevicesResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<ListDevicesResponseBodyData>>(expect1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Params") != m.end() && !m["Params"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Params"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Params"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      params = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListDevicesResponseBody() = default;
};
class ListDevicesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListDevicesResponseBody> body{};

  ListDevicesResponse() {}

  explicit ListDevicesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListDevicesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListDevicesResponseBody>(model1);
      }
    }
  }


  virtual ~ListDevicesResponse() = default;
};
class ListDoNotCallNumbersRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> scope{};
  shared_ptr<string> searchPattern{};

  ListDoNotCallNumbersRequest() {}

  explicit ListDoNotCallNumbersRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (scope) {
      res["Scope"] = boost::any(*scope);
    }
    if (searchPattern) {
      res["SearchPattern"] = boost::any(*searchPattern);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Scope") != m.end() && !m["Scope"].empty()) {
      scope = make_shared<string>(boost::any_cast<string>(m["Scope"]));
    }
    if (m.find("SearchPattern") != m.end() && !m["SearchPattern"].empty()) {
      searchPattern = make_shared<string>(boost::any_cast<string>(m["SearchPattern"]));
    }
  }


  virtual ~ListDoNotCallNumbersRequest() = default;
};
class ListDoNotCallNumbersResponseBodyDataList : public Darabonba::Model {
public:
  shared_ptr<long> createTime{};
  shared_ptr<string> creator{};
  shared_ptr<string> number{};
  shared_ptr<string> remark{};
  shared_ptr<string> scope{};

  ListDoNotCallNumbersResponseBodyDataList() {}

  explicit ListDoNotCallNumbersResponseBodyDataList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (creator) {
      res["Creator"] = boost::any(*creator);
    }
    if (number) {
      res["Number"] = boost::any(*number);
    }
    if (remark) {
      res["Remark"] = boost::any(*remark);
    }
    if (scope) {
      res["Scope"] = boost::any(*scope);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("Creator") != m.end() && !m["Creator"].empty()) {
      creator = make_shared<string>(boost::any_cast<string>(m["Creator"]));
    }
    if (m.find("Number") != m.end() && !m["Number"].empty()) {
      number = make_shared<string>(boost::any_cast<string>(m["Number"]));
    }
    if (m.find("Remark") != m.end() && !m["Remark"].empty()) {
      remark = make_shared<string>(boost::any_cast<string>(m["Remark"]));
    }
    if (m.find("Scope") != m.end() && !m["Scope"].empty()) {
      scope = make_shared<string>(boost::any_cast<string>(m["Scope"]));
    }
  }


  virtual ~ListDoNotCallNumbersResponseBodyDataList() = default;
};
class ListDoNotCallNumbersResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<ListDoNotCallNumbersResponseBodyDataList>> list{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  ListDoNotCallNumbersResponseBodyData() {}

  explicit ListDoNotCallNumbersResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (list) {
      vector<boost::any> temp1;
      for(auto item1:*list){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["List"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(vector<boost::any>) == m["List"].type()) {
        vector<ListDoNotCallNumbersResponseBodyDataList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["List"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDoNotCallNumbersResponseBodyDataList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        list = make_shared<vector<ListDoNotCallNumbersResponseBodyDataList>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListDoNotCallNumbersResponseBodyData() = default;
};
class ListDoNotCallNumbersResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<ListDoNotCallNumbersResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  ListDoNotCallNumbersResponseBody() {}

  explicit ListDoNotCallNumbersResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ListDoNotCallNumbersResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ListDoNotCallNumbersResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListDoNotCallNumbersResponseBody() = default;
};
class ListDoNotCallNumbersResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListDoNotCallNumbersResponseBody> body{};

  ListDoNotCallNumbersResponse() {}

  explicit ListDoNotCallNumbersResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListDoNotCallNumbersResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListDoNotCallNumbersResponseBody>(model1);
      }
    }
  }


  virtual ~ListDoNotCallNumbersResponse() = default;
};
class ListHistoricalAgentReportRequest : public Darabonba::Model {
public:
  shared_ptr<string> agentIdList{};
  shared_ptr<string> instanceId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> startTime{};
  shared_ptr<long> stopTime{};

  ListHistoricalAgentReportRequest() {}

  explicit ListHistoricalAgentReportRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agentIdList) {
      res["AgentIdList"] = boost::any(*agentIdList);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (stopTime) {
      res["StopTime"] = boost::any(*stopTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AgentIdList") != m.end() && !m["AgentIdList"].empty()) {
      agentIdList = make_shared<string>(boost::any_cast<string>(m["AgentIdList"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("StopTime") != m.end() && !m["StopTime"].empty()) {
      stopTime = make_shared<long>(boost::any_cast<long>(m["StopTime"]));
    }
  }


  virtual ~ListHistoricalAgentReportRequest() = default;
};
class ListHistoricalAgentReportResponseBodyDataListInbound : public Darabonba::Model {
public:
  shared_ptr<double> averageHoldTime{};
  shared_ptr<double> averageRingTime{};
  shared_ptr<double> averageTalkTime{};
  shared_ptr<double> averageWorkTime{};
  shared_ptr<long> callsAttendedTransferIn{};
  shared_ptr<long> callsAttendedTransferOut{};
  shared_ptr<long> callsBlindTransferIn{};
  shared_ptr<long> callsBlindTransferOut{};
  shared_ptr<long> callsHandled{};
  shared_ptr<long> callsHold{};
  shared_ptr<long> callsOffered{};
  shared_ptr<long> callsRinged{};
  shared_ptr<double> handleRate{};
  shared_ptr<long> maxHoldTime{};
  shared_ptr<long> maxRingTime{};
  shared_ptr<long> maxTalkTime{};
  shared_ptr<long> maxWorkTime{};
  shared_ptr<double> satisfactionIndex{};
  shared_ptr<double> satisfactionRate{};
  shared_ptr<long> satisfactionSurveysOffered{};
  shared_ptr<long> satisfactionSurveysResponded{};
  shared_ptr<long> totalHoldTime{};
  shared_ptr<long> totalRingTime{};
  shared_ptr<long> totalTalkTime{};
  shared_ptr<long> totalWorkTime{};

  ListHistoricalAgentReportResponseBodyDataListInbound() {}

  explicit ListHistoricalAgentReportResponseBodyDataListInbound(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (averageHoldTime) {
      res["AverageHoldTime"] = boost::any(*averageHoldTime);
    }
    if (averageRingTime) {
      res["AverageRingTime"] = boost::any(*averageRingTime);
    }
    if (averageTalkTime) {
      res["AverageTalkTime"] = boost::any(*averageTalkTime);
    }
    if (averageWorkTime) {
      res["AverageWorkTime"] = boost::any(*averageWorkTime);
    }
    if (callsAttendedTransferIn) {
      res["CallsAttendedTransferIn"] = boost::any(*callsAttendedTransferIn);
    }
    if (callsAttendedTransferOut) {
      res["CallsAttendedTransferOut"] = boost::any(*callsAttendedTransferOut);
    }
    if (callsBlindTransferIn) {
      res["CallsBlindTransferIn"] = boost::any(*callsBlindTransferIn);
    }
    if (callsBlindTransferOut) {
      res["CallsBlindTransferOut"] = boost::any(*callsBlindTransferOut);
    }
    if (callsHandled) {
      res["CallsHandled"] = boost::any(*callsHandled);
    }
    if (callsHold) {
      res["CallsHold"] = boost::any(*callsHold);
    }
    if (callsOffered) {
      res["CallsOffered"] = boost::any(*callsOffered);
    }
    if (callsRinged) {
      res["CallsRinged"] = boost::any(*callsRinged);
    }
    if (handleRate) {
      res["HandleRate"] = boost::any(*handleRate);
    }
    if (maxHoldTime) {
      res["MaxHoldTime"] = boost::any(*maxHoldTime);
    }
    if (maxRingTime) {
      res["MaxRingTime"] = boost::any(*maxRingTime);
    }
    if (maxTalkTime) {
      res["MaxTalkTime"] = boost::any(*maxTalkTime);
    }
    if (maxWorkTime) {
      res["MaxWorkTime"] = boost::any(*maxWorkTime);
    }
    if (satisfactionIndex) {
      res["SatisfactionIndex"] = boost::any(*satisfactionIndex);
    }
    if (satisfactionRate) {
      res["SatisfactionRate"] = boost::any(*satisfactionRate);
    }
    if (satisfactionSurveysOffered) {
      res["SatisfactionSurveysOffered"] = boost::any(*satisfactionSurveysOffered);
    }
    if (satisfactionSurveysResponded) {
      res["SatisfactionSurveysResponded"] = boost::any(*satisfactionSurveysResponded);
    }
    if (totalHoldTime) {
      res["TotalHoldTime"] = boost::any(*totalHoldTime);
    }
    if (totalRingTime) {
      res["TotalRingTime"] = boost::any(*totalRingTime);
    }
    if (totalTalkTime) {
      res["TotalTalkTime"] = boost::any(*totalTalkTime);
    }
    if (totalWorkTime) {
      res["TotalWorkTime"] = boost::any(*totalWorkTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AverageHoldTime") != m.end() && !m["AverageHoldTime"].empty()) {
      averageHoldTime = make_shared<double>(boost::any_cast<double>(m["AverageHoldTime"]));
    }
    if (m.find("AverageRingTime") != m.end() && !m["AverageRingTime"].empty()) {
      averageRingTime = make_shared<double>(boost::any_cast<double>(m["AverageRingTime"]));
    }
    if (m.find("AverageTalkTime") != m.end() && !m["AverageTalkTime"].empty()) {
      averageTalkTime = make_shared<double>(boost::any_cast<double>(m["AverageTalkTime"]));
    }
    if (m.find("AverageWorkTime") != m.end() && !m["AverageWorkTime"].empty()) {
      averageWorkTime = make_shared<double>(boost::any_cast<double>(m["AverageWorkTime"]));
    }
    if (m.find("CallsAttendedTransferIn") != m.end() && !m["CallsAttendedTransferIn"].empty()) {
      callsAttendedTransferIn = make_shared<long>(boost::any_cast<long>(m["CallsAttendedTransferIn"]));
    }
    if (m.find("CallsAttendedTransferOut") != m.end() && !m["CallsAttendedTransferOut"].empty()) {
      callsAttendedTransferOut = make_shared<long>(boost::any_cast<long>(m["CallsAttendedTransferOut"]));
    }
    if (m.find("CallsBlindTransferIn") != m.end() && !m["CallsBlindTransferIn"].empty()) {
      callsBlindTransferIn = make_shared<long>(boost::any_cast<long>(m["CallsBlindTransferIn"]));
    }
    if (m.find("CallsBlindTransferOut") != m.end() && !m["CallsBlindTransferOut"].empty()) {
      callsBlindTransferOut = make_shared<long>(boost::any_cast<long>(m["CallsBlindTransferOut"]));
    }
    if (m.find("CallsHandled") != m.end() && !m["CallsHandled"].empty()) {
      callsHandled = make_shared<long>(boost::any_cast<long>(m["CallsHandled"]));
    }
    if (m.find("CallsHold") != m.end() && !m["CallsHold"].empty()) {
      callsHold = make_shared<long>(boost::any_cast<long>(m["CallsHold"]));
    }
    if (m.find("CallsOffered") != m.end() && !m["CallsOffered"].empty()) {
      callsOffered = make_shared<long>(boost::any_cast<long>(m["CallsOffered"]));
    }
    if (m.find("CallsRinged") != m.end() && !m["CallsRinged"].empty()) {
      callsRinged = make_shared<long>(boost::any_cast<long>(m["CallsRinged"]));
    }
    if (m.find("HandleRate") != m.end() && !m["HandleRate"].empty()) {
      handleRate = make_shared<double>(boost::any_cast<double>(m["HandleRate"]));
    }
    if (m.find("MaxHoldTime") != m.end() && !m["MaxHoldTime"].empty()) {
      maxHoldTime = make_shared<long>(boost::any_cast<long>(m["MaxHoldTime"]));
    }
    if (m.find("MaxRingTime") != m.end() && !m["MaxRingTime"].empty()) {
      maxRingTime = make_shared<long>(boost::any_cast<long>(m["MaxRingTime"]));
    }
    if (m.find("MaxTalkTime") != m.end() && !m["MaxTalkTime"].empty()) {
      maxTalkTime = make_shared<long>(boost::any_cast<long>(m["MaxTalkTime"]));
    }
    if (m.find("MaxWorkTime") != m.end() && !m["MaxWorkTime"].empty()) {
      maxWorkTime = make_shared<long>(boost::any_cast<long>(m["MaxWorkTime"]));
    }
    if (m.find("SatisfactionIndex") != m.end() && !m["SatisfactionIndex"].empty()) {
      satisfactionIndex = make_shared<double>(boost::any_cast<double>(m["SatisfactionIndex"]));
    }
    if (m.find("SatisfactionRate") != m.end() && !m["SatisfactionRate"].empty()) {
      satisfactionRate = make_shared<double>(boost::any_cast<double>(m["SatisfactionRate"]));
    }
    if (m.find("SatisfactionSurveysOffered") != m.end() && !m["SatisfactionSurveysOffered"].empty()) {
      satisfactionSurveysOffered = make_shared<long>(boost::any_cast<long>(m["SatisfactionSurveysOffered"]));
    }
    if (m.find("SatisfactionSurveysResponded") != m.end() && !m["SatisfactionSurveysResponded"].empty()) {
      satisfactionSurveysResponded = make_shared<long>(boost::any_cast<long>(m["SatisfactionSurveysResponded"]));
    }
    if (m.find("TotalHoldTime") != m.end() && !m["TotalHoldTime"].empty()) {
      totalHoldTime = make_shared<long>(boost::any_cast<long>(m["TotalHoldTime"]));
    }
    if (m.find("TotalRingTime") != m.end() && !m["TotalRingTime"].empty()) {
      totalRingTime = make_shared<long>(boost::any_cast<long>(m["TotalRingTime"]));
    }
    if (m.find("TotalTalkTime") != m.end() && !m["TotalTalkTime"].empty()) {
      totalTalkTime = make_shared<long>(boost::any_cast<long>(m["TotalTalkTime"]));
    }
    if (m.find("TotalWorkTime") != m.end() && !m["TotalWorkTime"].empty()) {
      totalWorkTime = make_shared<long>(boost::any_cast<long>(m["TotalWorkTime"]));
    }
  }


  virtual ~ListHistoricalAgentReportResponseBodyDataListInbound() = default;
};
class ListHistoricalAgentReportResponseBodyDataListOutbound : public Darabonba::Model {
public:
  shared_ptr<double> answerRate{};
  shared_ptr<double> averageDialingTime{};
  shared_ptr<double> averageHoldTime{};
  shared_ptr<double> averageRingTime{};
  shared_ptr<double> averageTalkTime{};
  shared_ptr<double> averageWorkTime{};
  shared_ptr<long> callsAnswered{};
  shared_ptr<long> callsAttendedTransferIn{};
  shared_ptr<long> callsAttendedTransferOut{};
  shared_ptr<long> callsBlindTransferIn{};
  shared_ptr<long> callsBlindTransferOut{};
  shared_ptr<long> callsDialed{};
  shared_ptr<long> callsHold{};
  shared_ptr<long> callsRinged{};
  shared_ptr<long> maxDialingTime{};
  shared_ptr<long> maxHoldTime{};
  shared_ptr<long> maxRingTime{};
  shared_ptr<long> maxTalkTime{};
  shared_ptr<long> maxWorkTime{};
  shared_ptr<double> satisfactionIndex{};
  shared_ptr<double> satisfactionRate{};
  shared_ptr<long> satisfactionSurveysOffered{};
  shared_ptr<long> satisfactionSurveysResponded{};
  shared_ptr<long> totalDialingTime{};
  shared_ptr<long> totalHoldTime{};
  shared_ptr<long> totalRingTime{};
  shared_ptr<long> totalTalkTime{};
  shared_ptr<long> totalWorkTime{};

  ListHistoricalAgentReportResponseBodyDataListOutbound() {}

  explicit ListHistoricalAgentReportResponseBodyDataListOutbound(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (answerRate) {
      res["AnswerRate"] = boost::any(*answerRate);
    }
    if (averageDialingTime) {
      res["AverageDialingTime"] = boost::any(*averageDialingTime);
    }
    if (averageHoldTime) {
      res["AverageHoldTime"] = boost::any(*averageHoldTime);
    }
    if (averageRingTime) {
      res["AverageRingTime"] = boost::any(*averageRingTime);
    }
    if (averageTalkTime) {
      res["AverageTalkTime"] = boost::any(*averageTalkTime);
    }
    if (averageWorkTime) {
      res["AverageWorkTime"] = boost::any(*averageWorkTime);
    }
    if (callsAnswered) {
      res["CallsAnswered"] = boost::any(*callsAnswered);
    }
    if (callsAttendedTransferIn) {
      res["CallsAttendedTransferIn"] = boost::any(*callsAttendedTransferIn);
    }
    if (callsAttendedTransferOut) {
      res["CallsAttendedTransferOut"] = boost::any(*callsAttendedTransferOut);
    }
    if (callsBlindTransferIn) {
      res["CallsBlindTransferIn"] = boost::any(*callsBlindTransferIn);
    }
    if (callsBlindTransferOut) {
      res["CallsBlindTransferOut"] = boost::any(*callsBlindTransferOut);
    }
    if (callsDialed) {
      res["CallsDialed"] = boost::any(*callsDialed);
    }
    if (callsHold) {
      res["CallsHold"] = boost::any(*callsHold);
    }
    if (callsRinged) {
      res["CallsRinged"] = boost::any(*callsRinged);
    }
    if (maxDialingTime) {
      res["MaxDialingTime"] = boost::any(*maxDialingTime);
    }
    if (maxHoldTime) {
      res["MaxHoldTime"] = boost::any(*maxHoldTime);
    }
    if (maxRingTime) {
      res["MaxRingTime"] = boost::any(*maxRingTime);
    }
    if (maxTalkTime) {
      res["MaxTalkTime"] = boost::any(*maxTalkTime);
    }
    if (maxWorkTime) {
      res["MaxWorkTime"] = boost::any(*maxWorkTime);
    }
    if (satisfactionIndex) {
      res["SatisfactionIndex"] = boost::any(*satisfactionIndex);
    }
    if (satisfactionRate) {
      res["SatisfactionRate"] = boost::any(*satisfactionRate);
    }
    if (satisfactionSurveysOffered) {
      res["SatisfactionSurveysOffered"] = boost::any(*satisfactionSurveysOffered);
    }
    if (satisfactionSurveysResponded) {
      res["SatisfactionSurveysResponded"] = boost::any(*satisfactionSurveysResponded);
    }
    if (totalDialingTime) {
      res["TotalDialingTime"] = boost::any(*totalDialingTime);
    }
    if (totalHoldTime) {
      res["TotalHoldTime"] = boost::any(*totalHoldTime);
    }
    if (totalRingTime) {
      res["TotalRingTime"] = boost::any(*totalRingTime);
    }
    if (totalTalkTime) {
      res["TotalTalkTime"] = boost::any(*totalTalkTime);
    }
    if (totalWorkTime) {
      res["TotalWorkTime"] = boost::any(*totalWorkTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AnswerRate") != m.end() && !m["AnswerRate"].empty()) {
      answerRate = make_shared<double>(boost::any_cast<double>(m["AnswerRate"]));
    }
    if (m.find("AverageDialingTime") != m.end() && !m["AverageDialingTime"].empty()) {
      averageDialingTime = make_shared<double>(boost::any_cast<double>(m["AverageDialingTime"]));
    }
    if (m.find("AverageHoldTime") != m.end() && !m["AverageHoldTime"].empty()) {
      averageHoldTime = make_shared<double>(boost::any_cast<double>(m["AverageHoldTime"]));
    }
    if (m.find("AverageRingTime") != m.end() && !m["AverageRingTime"].empty()) {
      averageRingTime = make_shared<double>(boost::any_cast<double>(m["AverageRingTime"]));
    }
    if (m.find("AverageTalkTime") != m.end() && !m["AverageTalkTime"].empty()) {
      averageTalkTime = make_shared<double>(boost::any_cast<double>(m["AverageTalkTime"]));
    }
    if (m.find("AverageWorkTime") != m.end() && !m["AverageWorkTime"].empty()) {
      averageWorkTime = make_shared<double>(boost::any_cast<double>(m["AverageWorkTime"]));
    }
    if (m.find("CallsAnswered") != m.end() && !m["CallsAnswered"].empty()) {
      callsAnswered = make_shared<long>(boost::any_cast<long>(m["CallsAnswered"]));
    }
    if (m.find("CallsAttendedTransferIn") != m.end() && !m["CallsAttendedTransferIn"].empty()) {
      callsAttendedTransferIn = make_shared<long>(boost::any_cast<long>(m["CallsAttendedTransferIn"]));
    }
    if (m.find("CallsAttendedTransferOut") != m.end() && !m["CallsAttendedTransferOut"].empty()) {
      callsAttendedTransferOut = make_shared<long>(boost::any_cast<long>(m["CallsAttendedTransferOut"]));
    }
    if (m.find("CallsBlindTransferIn") != m.end() && !m["CallsBlindTransferIn"].empty()) {
      callsBlindTransferIn = make_shared<long>(boost::any_cast<long>(m["CallsBlindTransferIn"]));
    }
    if (m.find("CallsBlindTransferOut") != m.end() && !m["CallsBlindTransferOut"].empty()) {
      callsBlindTransferOut = make_shared<long>(boost::any_cast<long>(m["CallsBlindTransferOut"]));
    }
    if (m.find("CallsDialed") != m.end() && !m["CallsDialed"].empty()) {
      callsDialed = make_shared<long>(boost::any_cast<long>(m["CallsDialed"]));
    }
    if (m.find("CallsHold") != m.end() && !m["CallsHold"].empty()) {
      callsHold = make_shared<long>(boost::any_cast<long>(m["CallsHold"]));
    }
    if (m.find("CallsRinged") != m.end() && !m["CallsRinged"].empty()) {
      callsRinged = make_shared<long>(boost::any_cast<long>(m["CallsRinged"]));
    }
    if (m.find("MaxDialingTime") != m.end() && !m["MaxDialingTime"].empty()) {
      maxDialingTime = make_shared<long>(boost::any_cast<long>(m["MaxDialingTime"]));
    }
    if (m.find("MaxHoldTime") != m.end() && !m["MaxHoldTime"].empty()) {
      maxHoldTime = make_shared<long>(boost::any_cast<long>(m["MaxHoldTime"]));
    }
    if (m.find("MaxRingTime") != m.end() && !m["MaxRingTime"].empty()) {
      maxRingTime = make_shared<long>(boost::any_cast<long>(m["MaxRingTime"]));
    }
    if (m.find("MaxTalkTime") != m.end() && !m["MaxTalkTime"].empty()) {
      maxTalkTime = make_shared<long>(boost::any_cast<long>(m["MaxTalkTime"]));
    }
    if (m.find("MaxWorkTime") != m.end() && !m["MaxWorkTime"].empty()) {
      maxWorkTime = make_shared<long>(boost::any_cast<long>(m["MaxWorkTime"]));
    }
    if (m.find("SatisfactionIndex") != m.end() && !m["SatisfactionIndex"].empty()) {
      satisfactionIndex = make_shared<double>(boost::any_cast<double>(m["SatisfactionIndex"]));
    }
    if (m.find("SatisfactionRate") != m.end() && !m["SatisfactionRate"].empty()) {
      satisfactionRate = make_shared<double>(boost::any_cast<double>(m["SatisfactionRate"]));
    }
    if (m.find("SatisfactionSurveysOffered") != m.end() && !m["SatisfactionSurveysOffered"].empty()) {
      satisfactionSurveysOffered = make_shared<long>(boost::any_cast<long>(m["SatisfactionSurveysOffered"]));
    }
    if (m.find("SatisfactionSurveysResponded") != m.end() && !m["SatisfactionSurveysResponded"].empty()) {
      satisfactionSurveysResponded = make_shared<long>(boost::any_cast<long>(m["SatisfactionSurveysResponded"]));
    }
    if (m.find("TotalDialingTime") != m.end() && !m["TotalDialingTime"].empty()) {
      totalDialingTime = make_shared<long>(boost::any_cast<long>(m["TotalDialingTime"]));
    }
    if (m.find("TotalHoldTime") != m.end() && !m["TotalHoldTime"].empty()) {
      totalHoldTime = make_shared<long>(boost::any_cast<long>(m["TotalHoldTime"]));
    }
    if (m.find("TotalRingTime") != m.end() && !m["TotalRingTime"].empty()) {
      totalRingTime = make_shared<long>(boost::any_cast<long>(m["TotalRingTime"]));
    }
    if (m.find("TotalTalkTime") != m.end() && !m["TotalTalkTime"].empty()) {
      totalTalkTime = make_shared<long>(boost::any_cast<long>(m["TotalTalkTime"]));
    }
    if (m.find("TotalWorkTime") != m.end() && !m["TotalWorkTime"].empty()) {
      totalWorkTime = make_shared<long>(boost::any_cast<long>(m["TotalWorkTime"]));
    }
  }


  virtual ~ListHistoricalAgentReportResponseBodyDataListOutbound() = default;
};
class ListHistoricalAgentReportResponseBodyDataListOverall : public Darabonba::Model {
public:
  shared_ptr<double> averageBreakTime{};
  shared_ptr<double> averageHoldTime{};
  shared_ptr<double> averageReadyTime{};
  shared_ptr<double> averageTalkTime{};
  shared_ptr<double> averageWorkTime{};
  shared_ptr<long> maxBreakTime{};
  shared_ptr<long> maxHoldTime{};
  shared_ptr<long> maxReadyTime{};
  shared_ptr<long> maxTalkTime{};
  shared_ptr<long> maxWorkTime{};
  shared_ptr<double> occupancyRate{};
  shared_ptr<double> satisfactionIndex{};
  shared_ptr<double> satisfactionRate{};
  shared_ptr<long> satisfactionSurveysOffered{};
  shared_ptr<long> satisfactionSurveysResponded{};
  shared_ptr<long> totalBreakTime{};
  shared_ptr<long> totalCalls{};
  shared_ptr<long> totalHoldTime{};
  shared_ptr<long> totalLoggedInTime{};
  shared_ptr<long> totalReadyTime{};
  shared_ptr<long> totalTalkTime{};
  shared_ptr<long> totalWorkTime{};

  ListHistoricalAgentReportResponseBodyDataListOverall() {}

  explicit ListHistoricalAgentReportResponseBodyDataListOverall(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (averageBreakTime) {
      res["AverageBreakTime"] = boost::any(*averageBreakTime);
    }
    if (averageHoldTime) {
      res["AverageHoldTime"] = boost::any(*averageHoldTime);
    }
    if (averageReadyTime) {
      res["AverageReadyTime"] = boost::any(*averageReadyTime);
    }
    if (averageTalkTime) {
      res["AverageTalkTime"] = boost::any(*averageTalkTime);
    }
    if (averageWorkTime) {
      res["AverageWorkTime"] = boost::any(*averageWorkTime);
    }
    if (maxBreakTime) {
      res["MaxBreakTime"] = boost::any(*maxBreakTime);
    }
    if (maxHoldTime) {
      res["MaxHoldTime"] = boost::any(*maxHoldTime);
    }
    if (maxReadyTime) {
      res["MaxReadyTime"] = boost::any(*maxReadyTime);
    }
    if (maxTalkTime) {
      res["MaxTalkTime"] = boost::any(*maxTalkTime);
    }
    if (maxWorkTime) {
      res["MaxWorkTime"] = boost::any(*maxWorkTime);
    }
    if (occupancyRate) {
      res["OccupancyRate"] = boost::any(*occupancyRate);
    }
    if (satisfactionIndex) {
      res["SatisfactionIndex"] = boost::any(*satisfactionIndex);
    }
    if (satisfactionRate) {
      res["SatisfactionRate"] = boost::any(*satisfactionRate);
    }
    if (satisfactionSurveysOffered) {
      res["SatisfactionSurveysOffered"] = boost::any(*satisfactionSurveysOffered);
    }
    if (satisfactionSurveysResponded) {
      res["SatisfactionSurveysResponded"] = boost::any(*satisfactionSurveysResponded);
    }
    if (totalBreakTime) {
      res["TotalBreakTime"] = boost::any(*totalBreakTime);
    }
    if (totalCalls) {
      res["TotalCalls"] = boost::any(*totalCalls);
    }
    if (totalHoldTime) {
      res["TotalHoldTime"] = boost::any(*totalHoldTime);
    }
    if (totalLoggedInTime) {
      res["TotalLoggedInTime"] = boost::any(*totalLoggedInTime);
    }
    if (totalReadyTime) {
      res["TotalReadyTime"] = boost::any(*totalReadyTime);
    }
    if (totalTalkTime) {
      res["TotalTalkTime"] = boost::any(*totalTalkTime);
    }
    if (totalWorkTime) {
      res["TotalWorkTime"] = boost::any(*totalWorkTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AverageBreakTime") != m.end() && !m["AverageBreakTime"].empty()) {
      averageBreakTime = make_shared<double>(boost::any_cast<double>(m["AverageBreakTime"]));
    }
    if (m.find("AverageHoldTime") != m.end() && !m["AverageHoldTime"].empty()) {
      averageHoldTime = make_shared<double>(boost::any_cast<double>(m["AverageHoldTime"]));
    }
    if (m.find("AverageReadyTime") != m.end() && !m["AverageReadyTime"].empty()) {
      averageReadyTime = make_shared<double>(boost::any_cast<double>(m["AverageReadyTime"]));
    }
    if (m.find("AverageTalkTime") != m.end() && !m["AverageTalkTime"].empty()) {
      averageTalkTime = make_shared<double>(boost::any_cast<double>(m["AverageTalkTime"]));
    }
    if (m.find("AverageWorkTime") != m.end() && !m["AverageWorkTime"].empty()) {
      averageWorkTime = make_shared<double>(boost::any_cast<double>(m["AverageWorkTime"]));
    }
    if (m.find("MaxBreakTime") != m.end() && !m["MaxBreakTime"].empty()) {
      maxBreakTime = make_shared<long>(boost::any_cast<long>(m["MaxBreakTime"]));
    }
    if (m.find("MaxHoldTime") != m.end() && !m["MaxHoldTime"].empty()) {
      maxHoldTime = make_shared<long>(boost::any_cast<long>(m["MaxHoldTime"]));
    }
    if (m.find("MaxReadyTime") != m.end() && !m["MaxReadyTime"].empty()) {
      maxReadyTime = make_shared<long>(boost::any_cast<long>(m["MaxReadyTime"]));
    }
    if (m.find("MaxTalkTime") != m.end() && !m["MaxTalkTime"].empty()) {
      maxTalkTime = make_shared<long>(boost::any_cast<long>(m["MaxTalkTime"]));
    }
    if (m.find("MaxWorkTime") != m.end() && !m["MaxWorkTime"].empty()) {
      maxWorkTime = make_shared<long>(boost::any_cast<long>(m["MaxWorkTime"]));
    }
    if (m.find("OccupancyRate") != m.end() && !m["OccupancyRate"].empty()) {
      occupancyRate = make_shared<double>(boost::any_cast<double>(m["OccupancyRate"]));
    }
    if (m.find("SatisfactionIndex") != m.end() && !m["SatisfactionIndex"].empty()) {
      satisfactionIndex = make_shared<double>(boost::any_cast<double>(m["SatisfactionIndex"]));
    }
    if (m.find("SatisfactionRate") != m.end() && !m["SatisfactionRate"].empty()) {
      satisfactionRate = make_shared<double>(boost::any_cast<double>(m["SatisfactionRate"]));
    }
    if (m.find("SatisfactionSurveysOffered") != m.end() && !m["SatisfactionSurveysOffered"].empty()) {
      satisfactionSurveysOffered = make_shared<long>(boost::any_cast<long>(m["SatisfactionSurveysOffered"]));
    }
    if (m.find("SatisfactionSurveysResponded") != m.end() && !m["SatisfactionSurveysResponded"].empty()) {
      satisfactionSurveysResponded = make_shared<long>(boost::any_cast<long>(m["SatisfactionSurveysResponded"]));
    }
    if (m.find("TotalBreakTime") != m.end() && !m["TotalBreakTime"].empty()) {
      totalBreakTime = make_shared<long>(boost::any_cast<long>(m["TotalBreakTime"]));
    }
    if (m.find("TotalCalls") != m.end() && !m["TotalCalls"].empty()) {
      totalCalls = make_shared<long>(boost::any_cast<long>(m["TotalCalls"]));
    }
    if (m.find("TotalHoldTime") != m.end() && !m["TotalHoldTime"].empty()) {
      totalHoldTime = make_shared<long>(boost::any_cast<long>(m["TotalHoldTime"]));
    }
    if (m.find("TotalLoggedInTime") != m.end() && !m["TotalLoggedInTime"].empty()) {
      totalLoggedInTime = make_shared<long>(boost::any_cast<long>(m["TotalLoggedInTime"]));
    }
    if (m.find("TotalReadyTime") != m.end() && !m["TotalReadyTime"].empty()) {
      totalReadyTime = make_shared<long>(boost::any_cast<long>(m["TotalReadyTime"]));
    }
    if (m.find("TotalTalkTime") != m.end() && !m["TotalTalkTime"].empty()) {
      totalTalkTime = make_shared<long>(boost::any_cast<long>(m["TotalTalkTime"]));
    }
    if (m.find("TotalWorkTime") != m.end() && !m["TotalWorkTime"].empty()) {
      totalWorkTime = make_shared<long>(boost::any_cast<long>(m["TotalWorkTime"]));
    }
  }


  virtual ~ListHistoricalAgentReportResponseBodyDataListOverall() = default;
};
class ListHistoricalAgentReportResponseBodyDataList : public Darabonba::Model {
public:
  shared_ptr<string> agentId{};
  shared_ptr<string> agentName{};
  shared_ptr<string> displayId{};
  shared_ptr<ListHistoricalAgentReportResponseBodyDataListInbound> inbound{};
  shared_ptr<ListHistoricalAgentReportResponseBodyDataListOutbound> outbound{};
  shared_ptr<ListHistoricalAgentReportResponseBodyDataListOverall> overall{};
  shared_ptr<string> skillGroupIds{};
  shared_ptr<string> skillGroupNames{};

  ListHistoricalAgentReportResponseBodyDataList() {}

  explicit ListHistoricalAgentReportResponseBodyDataList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agentId) {
      res["AgentId"] = boost::any(*agentId);
    }
    if (agentName) {
      res["AgentName"] = boost::any(*agentName);
    }
    if (displayId) {
      res["DisplayId"] = boost::any(*displayId);
    }
    if (inbound) {
      res["Inbound"] = inbound ? boost::any(inbound->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (outbound) {
      res["Outbound"] = outbound ? boost::any(outbound->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (overall) {
      res["Overall"] = overall ? boost::any(overall->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (skillGroupIds) {
      res["SkillGroupIds"] = boost::any(*skillGroupIds);
    }
    if (skillGroupNames) {
      res["SkillGroupNames"] = boost::any(*skillGroupNames);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AgentId") != m.end() && !m["AgentId"].empty()) {
      agentId = make_shared<string>(boost::any_cast<string>(m["AgentId"]));
    }
    if (m.find("AgentName") != m.end() && !m["AgentName"].empty()) {
      agentName = make_shared<string>(boost::any_cast<string>(m["AgentName"]));
    }
    if (m.find("DisplayId") != m.end() && !m["DisplayId"].empty()) {
      displayId = make_shared<string>(boost::any_cast<string>(m["DisplayId"]));
    }
    if (m.find("Inbound") != m.end() && !m["Inbound"].empty()) {
      if (typeid(map<string, boost::any>) == m["Inbound"].type()) {
        ListHistoricalAgentReportResponseBodyDataListInbound model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Inbound"]));
        inbound = make_shared<ListHistoricalAgentReportResponseBodyDataListInbound>(model1);
      }
    }
    if (m.find("Outbound") != m.end() && !m["Outbound"].empty()) {
      if (typeid(map<string, boost::any>) == m["Outbound"].type()) {
        ListHistoricalAgentReportResponseBodyDataListOutbound model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Outbound"]));
        outbound = make_shared<ListHistoricalAgentReportResponseBodyDataListOutbound>(model1);
      }
    }
    if (m.find("Overall") != m.end() && !m["Overall"].empty()) {
      if (typeid(map<string, boost::any>) == m["Overall"].type()) {
        ListHistoricalAgentReportResponseBodyDataListOverall model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Overall"]));
        overall = make_shared<ListHistoricalAgentReportResponseBodyDataListOverall>(model1);
      }
    }
    if (m.find("SkillGroupIds") != m.end() && !m["SkillGroupIds"].empty()) {
      skillGroupIds = make_shared<string>(boost::any_cast<string>(m["SkillGroupIds"]));
    }
    if (m.find("SkillGroupNames") != m.end() && !m["SkillGroupNames"].empty()) {
      skillGroupNames = make_shared<string>(boost::any_cast<string>(m["SkillGroupNames"]));
    }
  }


  virtual ~ListHistoricalAgentReportResponseBodyDataList() = default;
};
class ListHistoricalAgentReportResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<ListHistoricalAgentReportResponseBodyDataList>> list{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  ListHistoricalAgentReportResponseBodyData() {}

  explicit ListHistoricalAgentReportResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (list) {
      vector<boost::any> temp1;
      for(auto item1:*list){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["List"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(vector<boost::any>) == m["List"].type()) {
        vector<ListHistoricalAgentReportResponseBodyDataList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["List"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListHistoricalAgentReportResponseBodyDataList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        list = make_shared<vector<ListHistoricalAgentReportResponseBodyDataList>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListHistoricalAgentReportResponseBodyData() = default;
};
class ListHistoricalAgentReportResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<ListHistoricalAgentReportResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  ListHistoricalAgentReportResponseBody() {}

  explicit ListHistoricalAgentReportResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ListHistoricalAgentReportResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ListHistoricalAgentReportResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListHistoricalAgentReportResponseBody() = default;
};
class ListHistoricalAgentReportResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListHistoricalAgentReportResponseBody> body{};

  ListHistoricalAgentReportResponse() {}

  explicit ListHistoricalAgentReportResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListHistoricalAgentReportResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListHistoricalAgentReportResponseBody>(model1);
      }
    }
  }


  virtual ~ListHistoricalAgentReportResponse() = default;
};
class ListHistoricalSkillGroupReportRequest : public Darabonba::Model {
public:
  shared_ptr<long> endTime{};
  shared_ptr<string> instanceId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> skillGroupIdList{};
  shared_ptr<long> startTime{};

  ListHistoricalSkillGroupReportRequest() {}

  explicit ListHistoricalSkillGroupReportRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (skillGroupIdList) {
      res["SkillGroupIdList"] = boost::any(*skillGroupIdList);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SkillGroupIdList") != m.end() && !m["SkillGroupIdList"].empty()) {
      skillGroupIdList = make_shared<string>(boost::any_cast<string>(m["SkillGroupIdList"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
  }


  virtual ~ListHistoricalSkillGroupReportRequest() = default;
};
class ListHistoricalSkillGroupReportResponseBodyDataListInbound : public Darabonba::Model {
public:
  shared_ptr<double> abandonRate{};
  shared_ptr<double> averageAbandonTime{};
  shared_ptr<double> averageAbandonedInQueueTime{};
  shared_ptr<double> averageAbandonedInRingTime{};
  shared_ptr<double> averageHoldTime{};
  shared_ptr<double> averageRingTime{};
  shared_ptr<double> averageTalkTime{};
  shared_ptr<double> averageWaitTime{};
  shared_ptr<double> averageWorkTime{};
  shared_ptr<long> callsAbandoned{};
  shared_ptr<long> callsAbandonedInQueue{};
  shared_ptr<long> callsAbandonedInRing{};
  shared_ptr<long> callsAttendedTransferIn{};
  shared_ptr<long> callsAttendedTransferOut{};
  shared_ptr<long> callsBlindTransferIn{};
  shared_ptr<long> callsBlindTransferOut{};
  shared_ptr<long> callsHandled{};
  shared_ptr<long> callsHold{};
  shared_ptr<long> callsOffered{};
  shared_ptr<long> callsOverflow{};
  shared_ptr<long> callsQueued{};
  shared_ptr<long> callsRinged{};
  shared_ptr<long> callsTimeout{};
  shared_ptr<double> handleRate{};
  shared_ptr<long> maxAbandonTime{};
  shared_ptr<long> maxAbandonedInQueueTime{};
  shared_ptr<long> maxAbandonedInRingTime{};
  shared_ptr<long> maxHoldTime{};
  shared_ptr<long> maxRingTime{};
  shared_ptr<long> maxTalkTime{};
  shared_ptr<long> maxWaitTime{};
  shared_ptr<long> maxWorkTime{};
  shared_ptr<double> satisfactionIndex{};
  shared_ptr<double> satisfactionRate{};
  shared_ptr<long> satisfactionSurveysOffered{};
  shared_ptr<long> satisfactionSurveysResponded{};
  shared_ptr<double> serviceLevel20{};
  shared_ptr<long> totalAbandonTime{};
  shared_ptr<long> totalAbandonedInQueueTime{};
  shared_ptr<long> totalAbandonedInRingTime{};
  shared_ptr<long> totalHoldTime{};
  shared_ptr<long> totalRingTime{};
  shared_ptr<long> totalTalkTime{};
  shared_ptr<long> totalWaitTime{};
  shared_ptr<long> totalWorkTime{};

  ListHistoricalSkillGroupReportResponseBodyDataListInbound() {}

  explicit ListHistoricalSkillGroupReportResponseBodyDataListInbound(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (abandonRate) {
      res["AbandonRate"] = boost::any(*abandonRate);
    }
    if (averageAbandonTime) {
      res["AverageAbandonTime"] = boost::any(*averageAbandonTime);
    }
    if (averageAbandonedInQueueTime) {
      res["AverageAbandonedInQueueTime"] = boost::any(*averageAbandonedInQueueTime);
    }
    if (averageAbandonedInRingTime) {
      res["AverageAbandonedInRingTime"] = boost::any(*averageAbandonedInRingTime);
    }
    if (averageHoldTime) {
      res["AverageHoldTime"] = boost::any(*averageHoldTime);
    }
    if (averageRingTime) {
      res["AverageRingTime"] = boost::any(*averageRingTime);
    }
    if (averageTalkTime) {
      res["AverageTalkTime"] = boost::any(*averageTalkTime);
    }
    if (averageWaitTime) {
      res["AverageWaitTime"] = boost::any(*averageWaitTime);
    }
    if (averageWorkTime) {
      res["AverageWorkTime"] = boost::any(*averageWorkTime);
    }
    if (callsAbandoned) {
      res["CallsAbandoned"] = boost::any(*callsAbandoned);
    }
    if (callsAbandonedInQueue) {
      res["CallsAbandonedInQueue"] = boost::any(*callsAbandonedInQueue);
    }
    if (callsAbandonedInRing) {
      res["CallsAbandonedInRing"] = boost::any(*callsAbandonedInRing);
    }
    if (callsAttendedTransferIn) {
      res["CallsAttendedTransferIn"] = boost::any(*callsAttendedTransferIn);
    }
    if (callsAttendedTransferOut) {
      res["CallsAttendedTransferOut"] = boost::any(*callsAttendedTransferOut);
    }
    if (callsBlindTransferIn) {
      res["CallsBlindTransferIn"] = boost::any(*callsBlindTransferIn);
    }
    if (callsBlindTransferOut) {
      res["CallsBlindTransferOut"] = boost::any(*callsBlindTransferOut);
    }
    if (callsHandled) {
      res["CallsHandled"] = boost::any(*callsHandled);
    }
    if (callsHold) {
      res["CallsHold"] = boost::any(*callsHold);
    }
    if (callsOffered) {
      res["CallsOffered"] = boost::any(*callsOffered);
    }
    if (callsOverflow) {
      res["CallsOverflow"] = boost::any(*callsOverflow);
    }
    if (callsQueued) {
      res["CallsQueued"] = boost::any(*callsQueued);
    }
    if (callsRinged) {
      res["CallsRinged"] = boost::any(*callsRinged);
    }
    if (callsTimeout) {
      res["CallsTimeout"] = boost::any(*callsTimeout);
    }
    if (handleRate) {
      res["HandleRate"] = boost::any(*handleRate);
    }
    if (maxAbandonTime) {
      res["MaxAbandonTime"] = boost::any(*maxAbandonTime);
    }
    if (maxAbandonedInQueueTime) {
      res["MaxAbandonedInQueueTime"] = boost::any(*maxAbandonedInQueueTime);
    }
    if (maxAbandonedInRingTime) {
      res["MaxAbandonedInRingTime"] = boost::any(*maxAbandonedInRingTime);
    }
    if (maxHoldTime) {
      res["MaxHoldTime"] = boost::any(*maxHoldTime);
    }
    if (maxRingTime) {
      res["MaxRingTime"] = boost::any(*maxRingTime);
    }
    if (maxTalkTime) {
      res["MaxTalkTime"] = boost::any(*maxTalkTime);
    }
    if (maxWaitTime) {
      res["MaxWaitTime"] = boost::any(*maxWaitTime);
    }
    if (maxWorkTime) {
      res["MaxWorkTime"] = boost::any(*maxWorkTime);
    }
    if (satisfactionIndex) {
      res["SatisfactionIndex"] = boost::any(*satisfactionIndex);
    }
    if (satisfactionRate) {
      res["SatisfactionRate"] = boost::any(*satisfactionRate);
    }
    if (satisfactionSurveysOffered) {
      res["SatisfactionSurveysOffered"] = boost::any(*satisfactionSurveysOffered);
    }
    if (satisfactionSurveysResponded) {
      res["SatisfactionSurveysResponded"] = boost::any(*satisfactionSurveysResponded);
    }
    if (serviceLevel20) {
      res["ServiceLevel20"] = boost::any(*serviceLevel20);
    }
    if (totalAbandonTime) {
      res["TotalAbandonTime"] = boost::any(*totalAbandonTime);
    }
    if (totalAbandonedInQueueTime) {
      res["TotalAbandonedInQueueTime"] = boost::any(*totalAbandonedInQueueTime);
    }
    if (totalAbandonedInRingTime) {
      res["TotalAbandonedInRingTime"] = boost::any(*totalAbandonedInRingTime);
    }
    if (totalHoldTime) {
      res["TotalHoldTime"] = boost::any(*totalHoldTime);
    }
    if (totalRingTime) {
      res["TotalRingTime"] = boost::any(*totalRingTime);
    }
    if (totalTalkTime) {
      res["TotalTalkTime"] = boost::any(*totalTalkTime);
    }
    if (totalWaitTime) {
      res["TotalWaitTime"] = boost::any(*totalWaitTime);
    }
    if (totalWorkTime) {
      res["TotalWorkTime"] = boost::any(*totalWorkTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AbandonRate") != m.end() && !m["AbandonRate"].empty()) {
      abandonRate = make_shared<double>(boost::any_cast<double>(m["AbandonRate"]));
    }
    if (m.find("AverageAbandonTime") != m.end() && !m["AverageAbandonTime"].empty()) {
      averageAbandonTime = make_shared<double>(boost::any_cast<double>(m["AverageAbandonTime"]));
    }
    if (m.find("AverageAbandonedInQueueTime") != m.end() && !m["AverageAbandonedInQueueTime"].empty()) {
      averageAbandonedInQueueTime = make_shared<double>(boost::any_cast<double>(m["AverageAbandonedInQueueTime"]));
    }
    if (m.find("AverageAbandonedInRingTime") != m.end() && !m["AverageAbandonedInRingTime"].empty()) {
      averageAbandonedInRingTime = make_shared<double>(boost::any_cast<double>(m["AverageAbandonedInRingTime"]));
    }
    if (m.find("AverageHoldTime") != m.end() && !m["AverageHoldTime"].empty()) {
      averageHoldTime = make_shared<double>(boost::any_cast<double>(m["AverageHoldTime"]));
    }
    if (m.find("AverageRingTime") != m.end() && !m["AverageRingTime"].empty()) {
      averageRingTime = make_shared<double>(boost::any_cast<double>(m["AverageRingTime"]));
    }
    if (m.find("AverageTalkTime") != m.end() && !m["AverageTalkTime"].empty()) {
      averageTalkTime = make_shared<double>(boost::any_cast<double>(m["AverageTalkTime"]));
    }
    if (m.find("AverageWaitTime") != m.end() && !m["AverageWaitTime"].empty()) {
      averageWaitTime = make_shared<double>(boost::any_cast<double>(m["AverageWaitTime"]));
    }
    if (m.find("AverageWorkTime") != m.end() && !m["AverageWorkTime"].empty()) {
      averageWorkTime = make_shared<double>(boost::any_cast<double>(m["AverageWorkTime"]));
    }
    if (m.find("CallsAbandoned") != m.end() && !m["CallsAbandoned"].empty()) {
      callsAbandoned = make_shared<long>(boost::any_cast<long>(m["CallsAbandoned"]));
    }
    if (m.find("CallsAbandonedInQueue") != m.end() && !m["CallsAbandonedInQueue"].empty()) {
      callsAbandonedInQueue = make_shared<long>(boost::any_cast<long>(m["CallsAbandonedInQueue"]));
    }
    if (m.find("CallsAbandonedInRing") != m.end() && !m["CallsAbandonedInRing"].empty()) {
      callsAbandonedInRing = make_shared<long>(boost::any_cast<long>(m["CallsAbandonedInRing"]));
    }
    if (m.find("CallsAttendedTransferIn") != m.end() && !m["CallsAttendedTransferIn"].empty()) {
      callsAttendedTransferIn = make_shared<long>(boost::any_cast<long>(m["CallsAttendedTransferIn"]));
    }
    if (m.find("CallsAttendedTransferOut") != m.end() && !m["CallsAttendedTransferOut"].empty()) {
      callsAttendedTransferOut = make_shared<long>(boost::any_cast<long>(m["CallsAttendedTransferOut"]));
    }
    if (m.find("CallsBlindTransferIn") != m.end() && !m["CallsBlindTransferIn"].empty()) {
      callsBlindTransferIn = make_shared<long>(boost::any_cast<long>(m["CallsBlindTransferIn"]));
    }
    if (m.find("CallsBlindTransferOut") != m.end() && !m["CallsBlindTransferOut"].empty()) {
      callsBlindTransferOut = make_shared<long>(boost::any_cast<long>(m["CallsBlindTransferOut"]));
    }
    if (m.find("CallsHandled") != m.end() && !m["CallsHandled"].empty()) {
      callsHandled = make_shared<long>(boost::any_cast<long>(m["CallsHandled"]));
    }
    if (m.find("CallsHold") != m.end() && !m["CallsHold"].empty()) {
      callsHold = make_shared<long>(boost::any_cast<long>(m["CallsHold"]));
    }
    if (m.find("CallsOffered") != m.end() && !m["CallsOffered"].empty()) {
      callsOffered = make_shared<long>(boost::any_cast<long>(m["CallsOffered"]));
    }
    if (m.find("CallsOverflow") != m.end() && !m["CallsOverflow"].empty()) {
      callsOverflow = make_shared<long>(boost::any_cast<long>(m["CallsOverflow"]));
    }
    if (m.find("CallsQueued") != m.end() && !m["CallsQueued"].empty()) {
      callsQueued = make_shared<long>(boost::any_cast<long>(m["CallsQueued"]));
    }
    if (m.find("CallsRinged") != m.end() && !m["CallsRinged"].empty()) {
      callsRinged = make_shared<long>(boost::any_cast<long>(m["CallsRinged"]));
    }
    if (m.find("CallsTimeout") != m.end() && !m["CallsTimeout"].empty()) {
      callsTimeout = make_shared<long>(boost::any_cast<long>(m["CallsTimeout"]));
    }
    if (m.find("HandleRate") != m.end() && !m["HandleRate"].empty()) {
      handleRate = make_shared<double>(boost::any_cast<double>(m["HandleRate"]));
    }
    if (m.find("MaxAbandonTime") != m.end() && !m["MaxAbandonTime"].empty()) {
      maxAbandonTime = make_shared<long>(boost::any_cast<long>(m["MaxAbandonTime"]));
    }
    if (m.find("MaxAbandonedInQueueTime") != m.end() && !m["MaxAbandonedInQueueTime"].empty()) {
      maxAbandonedInQueueTime = make_shared<long>(boost::any_cast<long>(m["MaxAbandonedInQueueTime"]));
    }
    if (m.find("MaxAbandonedInRingTime") != m.end() && !m["MaxAbandonedInRingTime"].empty()) {
      maxAbandonedInRingTime = make_shared<long>(boost::any_cast<long>(m["MaxAbandonedInRingTime"]));
    }
    if (m.find("MaxHoldTime") != m.end() && !m["MaxHoldTime"].empty()) {
      maxHoldTime = make_shared<long>(boost::any_cast<long>(m["MaxHoldTime"]));
    }
    if (m.find("MaxRingTime") != m.end() && !m["MaxRingTime"].empty()) {
      maxRingTime = make_shared<long>(boost::any_cast<long>(m["MaxRingTime"]));
    }
    if (m.find("MaxTalkTime") != m.end() && !m["MaxTalkTime"].empty()) {
      maxTalkTime = make_shared<long>(boost::any_cast<long>(m["MaxTalkTime"]));
    }
    if (m.find("MaxWaitTime") != m.end() && !m["MaxWaitTime"].empty()) {
      maxWaitTime = make_shared<long>(boost::any_cast<long>(m["MaxWaitTime"]));
    }
    if (m.find("MaxWorkTime") != m.end() && !m["MaxWorkTime"].empty()) {
      maxWorkTime = make_shared<long>(boost::any_cast<long>(m["MaxWorkTime"]));
    }
    if (m.find("SatisfactionIndex") != m.end() && !m["SatisfactionIndex"].empty()) {
      satisfactionIndex = make_shared<double>(boost::any_cast<double>(m["SatisfactionIndex"]));
    }
    if (m.find("SatisfactionRate") != m.end() && !m["SatisfactionRate"].empty()) {
      satisfactionRate = make_shared<double>(boost::any_cast<double>(m["SatisfactionRate"]));
    }
    if (m.find("SatisfactionSurveysOffered") != m.end() && !m["SatisfactionSurveysOffered"].empty()) {
      satisfactionSurveysOffered = make_shared<long>(boost::any_cast<long>(m["SatisfactionSurveysOffered"]));
    }
    if (m.find("SatisfactionSurveysResponded") != m.end() && !m["SatisfactionSurveysResponded"].empty()) {
      satisfactionSurveysResponded = make_shared<long>(boost::any_cast<long>(m["SatisfactionSurveysResponded"]));
    }
    if (m.find("ServiceLevel20") != m.end() && !m["ServiceLevel20"].empty()) {
      serviceLevel20 = make_shared<double>(boost::any_cast<double>(m["ServiceLevel20"]));
    }
    if (m.find("TotalAbandonTime") != m.end() && !m["TotalAbandonTime"].empty()) {
      totalAbandonTime = make_shared<long>(boost::any_cast<long>(m["TotalAbandonTime"]));
    }
    if (m.find("TotalAbandonedInQueueTime") != m.end() && !m["TotalAbandonedInQueueTime"].empty()) {
      totalAbandonedInQueueTime = make_shared<long>(boost::any_cast<long>(m["TotalAbandonedInQueueTime"]));
    }
    if (m.find("TotalAbandonedInRingTime") != m.end() && !m["TotalAbandonedInRingTime"].empty()) {
      totalAbandonedInRingTime = make_shared<long>(boost::any_cast<long>(m["TotalAbandonedInRingTime"]));
    }
    if (m.find("TotalHoldTime") != m.end() && !m["TotalHoldTime"].empty()) {
      totalHoldTime = make_shared<long>(boost::any_cast<long>(m["TotalHoldTime"]));
    }
    if (m.find("TotalRingTime") != m.end() && !m["TotalRingTime"].empty()) {
      totalRingTime = make_shared<long>(boost::any_cast<long>(m["TotalRingTime"]));
    }
    if (m.find("TotalTalkTime") != m.end() && !m["TotalTalkTime"].empty()) {
      totalTalkTime = make_shared<long>(boost::any_cast<long>(m["TotalTalkTime"]));
    }
    if (m.find("TotalWaitTime") != m.end() && !m["TotalWaitTime"].empty()) {
      totalWaitTime = make_shared<long>(boost::any_cast<long>(m["TotalWaitTime"]));
    }
    if (m.find("TotalWorkTime") != m.end() && !m["TotalWorkTime"].empty()) {
      totalWorkTime = make_shared<long>(boost::any_cast<long>(m["TotalWorkTime"]));
    }
  }


  virtual ~ListHistoricalSkillGroupReportResponseBodyDataListInbound() = default;
};
class ListHistoricalSkillGroupReportResponseBodyDataListOutbound : public Darabonba::Model {
public:
  shared_ptr<double> answerRate{};
  shared_ptr<double> averageDialingTime{};
  shared_ptr<double> averageHoldTime{};
  shared_ptr<double> averageRingTime{};
  shared_ptr<double> averageTalkTime{};
  shared_ptr<double> averageWorkTime{};
  shared_ptr<long> callsAnswered{};
  shared_ptr<long> callsAttendedTransferIn{};
  shared_ptr<long> callsAttendedTransferOut{};
  shared_ptr<long> callsBlindTransferIn{};
  shared_ptr<long> callsBlindTransferOut{};
  shared_ptr<long> callsDialed{};
  shared_ptr<long> callsHold{};
  shared_ptr<long> callsRinged{};
  shared_ptr<long> maxDialingTime{};
  shared_ptr<long> maxHoldTime{};
  shared_ptr<long> maxRingTime{};
  shared_ptr<long> maxTalkTime{};
  shared_ptr<long> maxWorkTime{};
  shared_ptr<double> satisfactionIndex{};
  shared_ptr<double> satisfactionRate{};
  shared_ptr<long> satisfactionSurveysOffered{};
  shared_ptr<long> satisfactionSurveysResponded{};
  shared_ptr<long> totalDialingTime{};
  shared_ptr<long> totalHoldTime{};
  shared_ptr<long> totalRingTime{};
  shared_ptr<long> totalTalkTime{};
  shared_ptr<long> totalWorkTime{};

  ListHistoricalSkillGroupReportResponseBodyDataListOutbound() {}

  explicit ListHistoricalSkillGroupReportResponseBodyDataListOutbound(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (answerRate) {
      res["AnswerRate"] = boost::any(*answerRate);
    }
    if (averageDialingTime) {
      res["AverageDialingTime"] = boost::any(*averageDialingTime);
    }
    if (averageHoldTime) {
      res["AverageHoldTime"] = boost::any(*averageHoldTime);
    }
    if (averageRingTime) {
      res["AverageRingTime"] = boost::any(*averageRingTime);
    }
    if (averageTalkTime) {
      res["AverageTalkTime"] = boost::any(*averageTalkTime);
    }
    if (averageWorkTime) {
      res["AverageWorkTime"] = boost::any(*averageWorkTime);
    }
    if (callsAnswered) {
      res["CallsAnswered"] = boost::any(*callsAnswered);
    }
    if (callsAttendedTransferIn) {
      res["CallsAttendedTransferIn"] = boost::any(*callsAttendedTransferIn);
    }
    if (callsAttendedTransferOut) {
      res["CallsAttendedTransferOut"] = boost::any(*callsAttendedTransferOut);
    }
    if (callsBlindTransferIn) {
      res["CallsBlindTransferIn"] = boost::any(*callsBlindTransferIn);
    }
    if (callsBlindTransferOut) {
      res["CallsBlindTransferOut"] = boost::any(*callsBlindTransferOut);
    }
    if (callsDialed) {
      res["CallsDialed"] = boost::any(*callsDialed);
    }
    if (callsHold) {
      res["CallsHold"] = boost::any(*callsHold);
    }
    if (callsRinged) {
      res["CallsRinged"] = boost::any(*callsRinged);
    }
    if (maxDialingTime) {
      res["MaxDialingTime"] = boost::any(*maxDialingTime);
    }
    if (maxHoldTime) {
      res["MaxHoldTime"] = boost::any(*maxHoldTime);
    }
    if (maxRingTime) {
      res["MaxRingTime"] = boost::any(*maxRingTime);
    }
    if (maxTalkTime) {
      res["MaxTalkTime"] = boost::any(*maxTalkTime);
    }
    if (maxWorkTime) {
      res["MaxWorkTime"] = boost::any(*maxWorkTime);
    }
    if (satisfactionIndex) {
      res["SatisfactionIndex"] = boost::any(*satisfactionIndex);
    }
    if (satisfactionRate) {
      res["SatisfactionRate"] = boost::any(*satisfactionRate);
    }
    if (satisfactionSurveysOffered) {
      res["SatisfactionSurveysOffered"] = boost::any(*satisfactionSurveysOffered);
    }
    if (satisfactionSurveysResponded) {
      res["SatisfactionSurveysResponded"] = boost::any(*satisfactionSurveysResponded);
    }
    if (totalDialingTime) {
      res["TotalDialingTime"] = boost::any(*totalDialingTime);
    }
    if (totalHoldTime) {
      res["TotalHoldTime"] = boost::any(*totalHoldTime);
    }
    if (totalRingTime) {
      res["TotalRingTime"] = boost::any(*totalRingTime);
    }
    if (totalTalkTime) {
      res["TotalTalkTime"] = boost::any(*totalTalkTime);
    }
    if (totalWorkTime) {
      res["TotalWorkTime"] = boost::any(*totalWorkTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AnswerRate") != m.end() && !m["AnswerRate"].empty()) {
      answerRate = make_shared<double>(boost::any_cast<double>(m["AnswerRate"]));
    }
    if (m.find("AverageDialingTime") != m.end() && !m["AverageDialingTime"].empty()) {
      averageDialingTime = make_shared<double>(boost::any_cast<double>(m["AverageDialingTime"]));
    }
    if (m.find("AverageHoldTime") != m.end() && !m["AverageHoldTime"].empty()) {
      averageHoldTime = make_shared<double>(boost::any_cast<double>(m["AverageHoldTime"]));
    }
    if (m.find("AverageRingTime") != m.end() && !m["AverageRingTime"].empty()) {
      averageRingTime = make_shared<double>(boost::any_cast<double>(m["AverageRingTime"]));
    }
    if (m.find("AverageTalkTime") != m.end() && !m["AverageTalkTime"].empty()) {
      averageTalkTime = make_shared<double>(boost::any_cast<double>(m["AverageTalkTime"]));
    }
    if (m.find("AverageWorkTime") != m.end() && !m["AverageWorkTime"].empty()) {
      averageWorkTime = make_shared<double>(boost::any_cast<double>(m["AverageWorkTime"]));
    }
    if (m.find("CallsAnswered") != m.end() && !m["CallsAnswered"].empty()) {
      callsAnswered = make_shared<long>(boost::any_cast<long>(m["CallsAnswered"]));
    }
    if (m.find("CallsAttendedTransferIn") != m.end() && !m["CallsAttendedTransferIn"].empty()) {
      callsAttendedTransferIn = make_shared<long>(boost::any_cast<long>(m["CallsAttendedTransferIn"]));
    }
    if (m.find("CallsAttendedTransferOut") != m.end() && !m["CallsAttendedTransferOut"].empty()) {
      callsAttendedTransferOut = make_shared<long>(boost::any_cast<long>(m["CallsAttendedTransferOut"]));
    }
    if (m.find("CallsBlindTransferIn") != m.end() && !m["CallsBlindTransferIn"].empty()) {
      callsBlindTransferIn = make_shared<long>(boost::any_cast<long>(m["CallsBlindTransferIn"]));
    }
    if (m.find("CallsBlindTransferOut") != m.end() && !m["CallsBlindTransferOut"].empty()) {
      callsBlindTransferOut = make_shared<long>(boost::any_cast<long>(m["CallsBlindTransferOut"]));
    }
    if (m.find("CallsDialed") != m.end() && !m["CallsDialed"].empty()) {
      callsDialed = make_shared<long>(boost::any_cast<long>(m["CallsDialed"]));
    }
    if (m.find("CallsHold") != m.end() && !m["CallsHold"].empty()) {
      callsHold = make_shared<long>(boost::any_cast<long>(m["CallsHold"]));
    }
    if (m.find("CallsRinged") != m.end() && !m["CallsRinged"].empty()) {
      callsRinged = make_shared<long>(boost::any_cast<long>(m["CallsRinged"]));
    }
    if (m.find("MaxDialingTime") != m.end() && !m["MaxDialingTime"].empty()) {
      maxDialingTime = make_shared<long>(boost::any_cast<long>(m["MaxDialingTime"]));
    }
    if (m.find("MaxHoldTime") != m.end() && !m["MaxHoldTime"].empty()) {
      maxHoldTime = make_shared<long>(boost::any_cast<long>(m["MaxHoldTime"]));
    }
    if (m.find("MaxRingTime") != m.end() && !m["MaxRingTime"].empty()) {
      maxRingTime = make_shared<long>(boost::any_cast<long>(m["MaxRingTime"]));
    }
    if (m.find("MaxTalkTime") != m.end() && !m["MaxTalkTime"].empty()) {
      maxTalkTime = make_shared<long>(boost::any_cast<long>(m["MaxTalkTime"]));
    }
    if (m.find("MaxWorkTime") != m.end() && !m["MaxWorkTime"].empty()) {
      maxWorkTime = make_shared<long>(boost::any_cast<long>(m["MaxWorkTime"]));
    }
    if (m.find("SatisfactionIndex") != m.end() && !m["SatisfactionIndex"].empty()) {
      satisfactionIndex = make_shared<double>(boost::any_cast<double>(m["SatisfactionIndex"]));
    }
    if (m.find("SatisfactionRate") != m.end() && !m["SatisfactionRate"].empty()) {
      satisfactionRate = make_shared<double>(boost::any_cast<double>(m["SatisfactionRate"]));
    }
    if (m.find("SatisfactionSurveysOffered") != m.end() && !m["SatisfactionSurveysOffered"].empty()) {
      satisfactionSurveysOffered = make_shared<long>(boost::any_cast<long>(m["SatisfactionSurveysOffered"]));
    }
    if (m.find("SatisfactionSurveysResponded") != m.end() && !m["SatisfactionSurveysResponded"].empty()) {
      satisfactionSurveysResponded = make_shared<long>(boost::any_cast<long>(m["SatisfactionSurveysResponded"]));
    }
    if (m.find("TotalDialingTime") != m.end() && !m["TotalDialingTime"].empty()) {
      totalDialingTime = make_shared<long>(boost::any_cast<long>(m["TotalDialingTime"]));
    }
    if (m.find("TotalHoldTime") != m.end() && !m["TotalHoldTime"].empty()) {
      totalHoldTime = make_shared<long>(boost::any_cast<long>(m["TotalHoldTime"]));
    }
    if (m.find("TotalRingTime") != m.end() && !m["TotalRingTime"].empty()) {
      totalRingTime = make_shared<long>(boost::any_cast<long>(m["TotalRingTime"]));
    }
    if (m.find("TotalTalkTime") != m.end() && !m["TotalTalkTime"].empty()) {
      totalTalkTime = make_shared<long>(boost::any_cast<long>(m["TotalTalkTime"]));
    }
    if (m.find("TotalWorkTime") != m.end() && !m["TotalWorkTime"].empty()) {
      totalWorkTime = make_shared<long>(boost::any_cast<long>(m["TotalWorkTime"]));
    }
  }


  virtual ~ListHistoricalSkillGroupReportResponseBodyDataListOutbound() = default;
};
class ListHistoricalSkillGroupReportResponseBodyDataListOverall : public Darabonba::Model {
public:
  shared_ptr<double> averageBreakTime{};
  shared_ptr<double> averageHoldTime{};
  shared_ptr<double> averageReadyTime{};
  shared_ptr<double> averageTalkTime{};
  shared_ptr<double> averageWorkTime{};
  shared_ptr<long> maxBreakTime{};
  shared_ptr<long> maxHoldTime{};
  shared_ptr<long> maxReadyTime{};
  shared_ptr<long> maxTalkTime{};
  shared_ptr<long> maxWorkTime{};
  shared_ptr<double> occupancyRate{};
  shared_ptr<double> satisfactionIndex{};
  shared_ptr<double> satisfactionRate{};
  shared_ptr<long> satisfactionSurveysOffered{};
  shared_ptr<long> satisfactionSurveysResponded{};
  shared_ptr<long> totalBreakTime{};
  shared_ptr<long> totalCalls{};
  shared_ptr<long> totalHoldTime{};
  shared_ptr<long> totalLoggedInTime{};
  shared_ptr<long> totalReadyTime{};
  shared_ptr<long> totalTalkTime{};
  shared_ptr<long> totalWorkTime{};

  ListHistoricalSkillGroupReportResponseBodyDataListOverall() {}

  explicit ListHistoricalSkillGroupReportResponseBodyDataListOverall(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (averageBreakTime) {
      res["AverageBreakTime"] = boost::any(*averageBreakTime);
    }
    if (averageHoldTime) {
      res["AverageHoldTime"] = boost::any(*averageHoldTime);
    }
    if (averageReadyTime) {
      res["AverageReadyTime"] = boost::any(*averageReadyTime);
    }
    if (averageTalkTime) {
      res["AverageTalkTime"] = boost::any(*averageTalkTime);
    }
    if (averageWorkTime) {
      res["AverageWorkTime"] = boost::any(*averageWorkTime);
    }
    if (maxBreakTime) {
      res["MaxBreakTime"] = boost::any(*maxBreakTime);
    }
    if (maxHoldTime) {
      res["MaxHoldTime"] = boost::any(*maxHoldTime);
    }
    if (maxReadyTime) {
      res["MaxReadyTime"] = boost::any(*maxReadyTime);
    }
    if (maxTalkTime) {
      res["MaxTalkTime"] = boost::any(*maxTalkTime);
    }
    if (maxWorkTime) {
      res["MaxWorkTime"] = boost::any(*maxWorkTime);
    }
    if (occupancyRate) {
      res["OccupancyRate"] = boost::any(*occupancyRate);
    }
    if (satisfactionIndex) {
      res["SatisfactionIndex"] = boost::any(*satisfactionIndex);
    }
    if (satisfactionRate) {
      res["SatisfactionRate"] = boost::any(*satisfactionRate);
    }
    if (satisfactionSurveysOffered) {
      res["SatisfactionSurveysOffered"] = boost::any(*satisfactionSurveysOffered);
    }
    if (satisfactionSurveysResponded) {
      res["SatisfactionSurveysResponded"] = boost::any(*satisfactionSurveysResponded);
    }
    if (totalBreakTime) {
      res["TotalBreakTime"] = boost::any(*totalBreakTime);
    }
    if (totalCalls) {
      res["TotalCalls"] = boost::any(*totalCalls);
    }
    if (totalHoldTime) {
      res["TotalHoldTime"] = boost::any(*totalHoldTime);
    }
    if (totalLoggedInTime) {
      res["TotalLoggedInTime"] = boost::any(*totalLoggedInTime);
    }
    if (totalReadyTime) {
      res["TotalReadyTime"] = boost::any(*totalReadyTime);
    }
    if (totalTalkTime) {
      res["TotalTalkTime"] = boost::any(*totalTalkTime);
    }
    if (totalWorkTime) {
      res["TotalWorkTime"] = boost::any(*totalWorkTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AverageBreakTime") != m.end() && !m["AverageBreakTime"].empty()) {
      averageBreakTime = make_shared<double>(boost::any_cast<double>(m["AverageBreakTime"]));
    }
    if (m.find("AverageHoldTime") != m.end() && !m["AverageHoldTime"].empty()) {
      averageHoldTime = make_shared<double>(boost::any_cast<double>(m["AverageHoldTime"]));
    }
    if (m.find("AverageReadyTime") != m.end() && !m["AverageReadyTime"].empty()) {
      averageReadyTime = make_shared<double>(boost::any_cast<double>(m["AverageReadyTime"]));
    }
    if (m.find("AverageTalkTime") != m.end() && !m["AverageTalkTime"].empty()) {
      averageTalkTime = make_shared<double>(boost::any_cast<double>(m["AverageTalkTime"]));
    }
    if (m.find("AverageWorkTime") != m.end() && !m["AverageWorkTime"].empty()) {
      averageWorkTime = make_shared<double>(boost::any_cast<double>(m["AverageWorkTime"]));
    }
    if (m.find("MaxBreakTime") != m.end() && !m["MaxBreakTime"].empty()) {
      maxBreakTime = make_shared<long>(boost::any_cast<long>(m["MaxBreakTime"]));
    }
    if (m.find("MaxHoldTime") != m.end() && !m["MaxHoldTime"].empty()) {
      maxHoldTime = make_shared<long>(boost::any_cast<long>(m["MaxHoldTime"]));
    }
    if (m.find("MaxReadyTime") != m.end() && !m["MaxReadyTime"].empty()) {
      maxReadyTime = make_shared<long>(boost::any_cast<long>(m["MaxReadyTime"]));
    }
    if (m.find("MaxTalkTime") != m.end() && !m["MaxTalkTime"].empty()) {
      maxTalkTime = make_shared<long>(boost::any_cast<long>(m["MaxTalkTime"]));
    }
    if (m.find("MaxWorkTime") != m.end() && !m["MaxWorkTime"].empty()) {
      maxWorkTime = make_shared<long>(boost::any_cast<long>(m["MaxWorkTime"]));
    }
    if (m.find("OccupancyRate") != m.end() && !m["OccupancyRate"].empty()) {
      occupancyRate = make_shared<double>(boost::any_cast<double>(m["OccupancyRate"]));
    }
    if (m.find("SatisfactionIndex") != m.end() && !m["SatisfactionIndex"].empty()) {
      satisfactionIndex = make_shared<double>(boost::any_cast<double>(m["SatisfactionIndex"]));
    }
    if (m.find("SatisfactionRate") != m.end() && !m["SatisfactionRate"].empty()) {
      satisfactionRate = make_shared<double>(boost::any_cast<double>(m["SatisfactionRate"]));
    }
    if (m.find("SatisfactionSurveysOffered") != m.end() && !m["SatisfactionSurveysOffered"].empty()) {
      satisfactionSurveysOffered = make_shared<long>(boost::any_cast<long>(m["SatisfactionSurveysOffered"]));
    }
    if (m.find("SatisfactionSurveysResponded") != m.end() && !m["SatisfactionSurveysResponded"].empty()) {
      satisfactionSurveysResponded = make_shared<long>(boost::any_cast<long>(m["SatisfactionSurveysResponded"]));
    }
    if (m.find("TotalBreakTime") != m.end() && !m["TotalBreakTime"].empty()) {
      totalBreakTime = make_shared<long>(boost::any_cast<long>(m["TotalBreakTime"]));
    }
    if (m.find("TotalCalls") != m.end() && !m["TotalCalls"].empty()) {
      totalCalls = make_shared<long>(boost::any_cast<long>(m["TotalCalls"]));
    }
    if (m.find("TotalHoldTime") != m.end() && !m["TotalHoldTime"].empty()) {
      totalHoldTime = make_shared<long>(boost::any_cast<long>(m["TotalHoldTime"]));
    }
    if (m.find("TotalLoggedInTime") != m.end() && !m["TotalLoggedInTime"].empty()) {
      totalLoggedInTime = make_shared<long>(boost::any_cast<long>(m["TotalLoggedInTime"]));
    }
    if (m.find("TotalReadyTime") != m.end() && !m["TotalReadyTime"].empty()) {
      totalReadyTime = make_shared<long>(boost::any_cast<long>(m["TotalReadyTime"]));
    }
    if (m.find("TotalTalkTime") != m.end() && !m["TotalTalkTime"].empty()) {
      totalTalkTime = make_shared<long>(boost::any_cast<long>(m["TotalTalkTime"]));
    }
    if (m.find("TotalWorkTime") != m.end() && !m["TotalWorkTime"].empty()) {
      totalWorkTime = make_shared<long>(boost::any_cast<long>(m["TotalWorkTime"]));
    }
  }


  virtual ~ListHistoricalSkillGroupReportResponseBodyDataListOverall() = default;
};
class ListHistoricalSkillGroupReportResponseBodyDataList : public Darabonba::Model {
public:
  shared_ptr<ListHistoricalSkillGroupReportResponseBodyDataListInbound> inbound{};
  shared_ptr<ListHistoricalSkillGroupReportResponseBodyDataListOutbound> outbound{};
  shared_ptr<ListHistoricalSkillGroupReportResponseBodyDataListOverall> overall{};
  shared_ptr<string> skillGroupId{};
  shared_ptr<string> skillGroupName{};

  ListHistoricalSkillGroupReportResponseBodyDataList() {}

  explicit ListHistoricalSkillGroupReportResponseBodyDataList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (inbound) {
      res["Inbound"] = inbound ? boost::any(inbound->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (outbound) {
      res["Outbound"] = outbound ? boost::any(outbound->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (overall) {
      res["Overall"] = overall ? boost::any(overall->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (skillGroupId) {
      res["SkillGroupId"] = boost::any(*skillGroupId);
    }
    if (skillGroupName) {
      res["SkillGroupName"] = boost::any(*skillGroupName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Inbound") != m.end() && !m["Inbound"].empty()) {
      if (typeid(map<string, boost::any>) == m["Inbound"].type()) {
        ListHistoricalSkillGroupReportResponseBodyDataListInbound model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Inbound"]));
        inbound = make_shared<ListHistoricalSkillGroupReportResponseBodyDataListInbound>(model1);
      }
    }
    if (m.find("Outbound") != m.end() && !m["Outbound"].empty()) {
      if (typeid(map<string, boost::any>) == m["Outbound"].type()) {
        ListHistoricalSkillGroupReportResponseBodyDataListOutbound model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Outbound"]));
        outbound = make_shared<ListHistoricalSkillGroupReportResponseBodyDataListOutbound>(model1);
      }
    }
    if (m.find("Overall") != m.end() && !m["Overall"].empty()) {
      if (typeid(map<string, boost::any>) == m["Overall"].type()) {
        ListHistoricalSkillGroupReportResponseBodyDataListOverall model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Overall"]));
        overall = make_shared<ListHistoricalSkillGroupReportResponseBodyDataListOverall>(model1);
      }
    }
    if (m.find("SkillGroupId") != m.end() && !m["SkillGroupId"].empty()) {
      skillGroupId = make_shared<string>(boost::any_cast<string>(m["SkillGroupId"]));
    }
    if (m.find("SkillGroupName") != m.end() && !m["SkillGroupName"].empty()) {
      skillGroupName = make_shared<string>(boost::any_cast<string>(m["SkillGroupName"]));
    }
  }


  virtual ~ListHistoricalSkillGroupReportResponseBodyDataList() = default;
};
class ListHistoricalSkillGroupReportResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<ListHistoricalSkillGroupReportResponseBodyDataList>> list{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  ListHistoricalSkillGroupReportResponseBodyData() {}

  explicit ListHistoricalSkillGroupReportResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (list) {
      vector<boost::any> temp1;
      for(auto item1:*list){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["List"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(vector<boost::any>) == m["List"].type()) {
        vector<ListHistoricalSkillGroupReportResponseBodyDataList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["List"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListHistoricalSkillGroupReportResponseBodyDataList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        list = make_shared<vector<ListHistoricalSkillGroupReportResponseBodyDataList>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListHistoricalSkillGroupReportResponseBodyData() = default;
};
class ListHistoricalSkillGroupReportResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<ListHistoricalSkillGroupReportResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  ListHistoricalSkillGroupReportResponseBody() {}

  explicit ListHistoricalSkillGroupReportResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ListHistoricalSkillGroupReportResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ListHistoricalSkillGroupReportResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListHistoricalSkillGroupReportResponseBody() = default;
};
class ListHistoricalSkillGroupReportResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListHistoricalSkillGroupReportResponseBody> body{};

  ListHistoricalSkillGroupReportResponse() {}

  explicit ListHistoricalSkillGroupReportResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListHistoricalSkillGroupReportResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListHistoricalSkillGroupReportResponseBody>(model1);
      }
    }
  }


  virtual ~ListHistoricalSkillGroupReportResponse() = default;
};
class ListInstancesRequest : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};

  ListInstancesRequest() {}

  explicit ListInstancesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~ListInstancesRequest() = default;
};
class ListInstancesResponseBodyDataListAdminList : public Darabonba::Model {
public:
  shared_ptr<string> displayName{};
  shared_ptr<string> email{};
  shared_ptr<string> extension{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> loginName{};
  shared_ptr<string> mobile{};
  shared_ptr<string> roleId{};
  shared_ptr<string> roleName{};
  shared_ptr<string> userId{};
  shared_ptr<string> workMode{};

  ListInstancesResponseBodyDataListAdminList() {}

  explicit ListInstancesResponseBodyDataListAdminList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (displayName) {
      res["DisplayName"] = boost::any(*displayName);
    }
    if (email) {
      res["Email"] = boost::any(*email);
    }
    if (extension) {
      res["Extension"] = boost::any(*extension);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (loginName) {
      res["LoginName"] = boost::any(*loginName);
    }
    if (mobile) {
      res["Mobile"] = boost::any(*mobile);
    }
    if (roleId) {
      res["RoleId"] = boost::any(*roleId);
    }
    if (roleName) {
      res["RoleName"] = boost::any(*roleName);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (workMode) {
      res["WorkMode"] = boost::any(*workMode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DisplayName") != m.end() && !m["DisplayName"].empty()) {
      displayName = make_shared<string>(boost::any_cast<string>(m["DisplayName"]));
    }
    if (m.find("Email") != m.end() && !m["Email"].empty()) {
      email = make_shared<string>(boost::any_cast<string>(m["Email"]));
    }
    if (m.find("Extension") != m.end() && !m["Extension"].empty()) {
      extension = make_shared<string>(boost::any_cast<string>(m["Extension"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("LoginName") != m.end() && !m["LoginName"].empty()) {
      loginName = make_shared<string>(boost::any_cast<string>(m["LoginName"]));
    }
    if (m.find("Mobile") != m.end() && !m["Mobile"].empty()) {
      mobile = make_shared<string>(boost::any_cast<string>(m["Mobile"]));
    }
    if (m.find("RoleId") != m.end() && !m["RoleId"].empty()) {
      roleId = make_shared<string>(boost::any_cast<string>(m["RoleId"]));
    }
    if (m.find("RoleName") != m.end() && !m["RoleName"].empty()) {
      roleName = make_shared<string>(boost::any_cast<string>(m["RoleName"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
    if (m.find("WorkMode") != m.end() && !m["WorkMode"].empty()) {
      workMode = make_shared<string>(boost::any_cast<string>(m["WorkMode"]));
    }
  }


  virtual ~ListInstancesResponseBodyDataListAdminList() = default;
};
class ListInstancesResponseBodyDataListNumberList : public Darabonba::Model {
public:
  shared_ptr<string> number{};

  ListInstancesResponseBodyDataListNumberList() {}

  explicit ListInstancesResponseBodyDataListNumberList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (number) {
      res["Number"] = boost::any(*number);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Number") != m.end() && !m["Number"].empty()) {
      number = make_shared<string>(boost::any_cast<string>(m["Number"]));
    }
  }


  virtual ~ListInstancesResponseBodyDataListNumberList() = default;
};
class ListInstancesResponseBodyDataList : public Darabonba::Model {
public:
  shared_ptr<vector<ListInstancesResponseBodyDataListAdminList>> adminList{};
  shared_ptr<string> aliyunUid{};
  shared_ptr<string> consoleUrl{};
  shared_ptr<long> createTime{};
  shared_ptr<string> description{};
  shared_ptr<string> domainName{};
  shared_ptr<string> id{};
  shared_ptr<string> name{};
  shared_ptr<vector<ListInstancesResponseBodyDataListNumberList>> numberList{};
  shared_ptr<string> status{};

  ListInstancesResponseBodyDataList() {}

  explicit ListInstancesResponseBodyDataList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (adminList) {
      vector<boost::any> temp1;
      for(auto item1:*adminList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AdminList"] = boost::any(temp1);
    }
    if (aliyunUid) {
      res["AliyunUid"] = boost::any(*aliyunUid);
    }
    if (consoleUrl) {
      res["ConsoleUrl"] = boost::any(*consoleUrl);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (numberList) {
      vector<boost::any> temp1;
      for(auto item1:*numberList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["NumberList"] = boost::any(temp1);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AdminList") != m.end() && !m["AdminList"].empty()) {
      if (typeid(vector<boost::any>) == m["AdminList"].type()) {
        vector<ListInstancesResponseBodyDataListAdminList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AdminList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListInstancesResponseBodyDataListAdminList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        adminList = make_shared<vector<ListInstancesResponseBodyDataListAdminList>>(expect1);
      }
    }
    if (m.find("AliyunUid") != m.end() && !m["AliyunUid"].empty()) {
      aliyunUid = make_shared<string>(boost::any_cast<string>(m["AliyunUid"]));
    }
    if (m.find("ConsoleUrl") != m.end() && !m["ConsoleUrl"].empty()) {
      consoleUrl = make_shared<string>(boost::any_cast<string>(m["ConsoleUrl"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("NumberList") != m.end() && !m["NumberList"].empty()) {
      if (typeid(vector<boost::any>) == m["NumberList"].type()) {
        vector<ListInstancesResponseBodyDataListNumberList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["NumberList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListInstancesResponseBodyDataListNumberList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        numberList = make_shared<vector<ListInstancesResponseBodyDataListNumberList>>(expect1);
      }
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~ListInstancesResponseBodyDataList() = default;
};
class ListInstancesResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<ListInstancesResponseBodyDataList>> list{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  ListInstancesResponseBodyData() {}

  explicit ListInstancesResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (list) {
      vector<boost::any> temp1;
      for(auto item1:*list){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["List"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(vector<boost::any>) == m["List"].type()) {
        vector<ListInstancesResponseBodyDataList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["List"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListInstancesResponseBodyDataList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        list = make_shared<vector<ListInstancesResponseBodyDataList>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListInstancesResponseBodyData() = default;
};
class ListInstancesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<ListInstancesResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  ListInstancesResponseBody() {}

  explicit ListInstancesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ListInstancesResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ListInstancesResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListInstancesResponseBody() = default;
};
class ListInstancesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListInstancesResponseBody> body{};

  ListInstancesResponse() {}

  explicit ListInstancesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListInstancesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListInstancesResponseBody>(model1);
      }
    }
  }


  virtual ~ListInstancesResponse() = default;
};
class ListInstancesOfUserRequest : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};

  ListInstancesOfUserRequest() {}

  explicit ListInstancesOfUserRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~ListInstancesOfUserRequest() = default;
};
class ListInstancesOfUserResponseBodyDataListAdminList : public Darabonba::Model {
public:
  shared_ptr<string> displayName{};
  shared_ptr<string> email{};
  shared_ptr<string> extension{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> loginName{};
  shared_ptr<string> mobile{};
  shared_ptr<string> roleId{};
  shared_ptr<string> roleName{};
  shared_ptr<string> userId{};
  shared_ptr<string> workMode{};

  ListInstancesOfUserResponseBodyDataListAdminList() {}

  explicit ListInstancesOfUserResponseBodyDataListAdminList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (displayName) {
      res["DisplayName"] = boost::any(*displayName);
    }
    if (email) {
      res["Email"] = boost::any(*email);
    }
    if (extension) {
      res["Extension"] = boost::any(*extension);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (loginName) {
      res["LoginName"] = boost::any(*loginName);
    }
    if (mobile) {
      res["Mobile"] = boost::any(*mobile);
    }
    if (roleId) {
      res["RoleId"] = boost::any(*roleId);
    }
    if (roleName) {
      res["RoleName"] = boost::any(*roleName);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (workMode) {
      res["WorkMode"] = boost::any(*workMode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DisplayName") != m.end() && !m["DisplayName"].empty()) {
      displayName = make_shared<string>(boost::any_cast<string>(m["DisplayName"]));
    }
    if (m.find("Email") != m.end() && !m["Email"].empty()) {
      email = make_shared<string>(boost::any_cast<string>(m["Email"]));
    }
    if (m.find("Extension") != m.end() && !m["Extension"].empty()) {
      extension = make_shared<string>(boost::any_cast<string>(m["Extension"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("LoginName") != m.end() && !m["LoginName"].empty()) {
      loginName = make_shared<string>(boost::any_cast<string>(m["LoginName"]));
    }
    if (m.find("Mobile") != m.end() && !m["Mobile"].empty()) {
      mobile = make_shared<string>(boost::any_cast<string>(m["Mobile"]));
    }
    if (m.find("RoleId") != m.end() && !m["RoleId"].empty()) {
      roleId = make_shared<string>(boost::any_cast<string>(m["RoleId"]));
    }
    if (m.find("RoleName") != m.end() && !m["RoleName"].empty()) {
      roleName = make_shared<string>(boost::any_cast<string>(m["RoleName"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
    if (m.find("WorkMode") != m.end() && !m["WorkMode"].empty()) {
      workMode = make_shared<string>(boost::any_cast<string>(m["WorkMode"]));
    }
  }


  virtual ~ListInstancesOfUserResponseBodyDataListAdminList() = default;
};
class ListInstancesOfUserResponseBodyDataListNumberListSkillGroups : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> displayName{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> name{};
  shared_ptr<long> phoneNumberCount{};
  shared_ptr<string> skillGroupId{};
  shared_ptr<long> userCount{};

  ListInstancesOfUserResponseBodyDataListNumberListSkillGroups() {}

  explicit ListInstancesOfUserResponseBodyDataListNumberListSkillGroups(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (displayName) {
      res["DisplayName"] = boost::any(*displayName);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (phoneNumberCount) {
      res["PhoneNumberCount"] = boost::any(*phoneNumberCount);
    }
    if (skillGroupId) {
      res["SkillGroupId"] = boost::any(*skillGroupId);
    }
    if (userCount) {
      res["UserCount"] = boost::any(*userCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DisplayName") != m.end() && !m["DisplayName"].empty()) {
      displayName = make_shared<string>(boost::any_cast<string>(m["DisplayName"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("PhoneNumberCount") != m.end() && !m["PhoneNumberCount"].empty()) {
      phoneNumberCount = make_shared<long>(boost::any_cast<long>(m["PhoneNumberCount"]));
    }
    if (m.find("SkillGroupId") != m.end() && !m["SkillGroupId"].empty()) {
      skillGroupId = make_shared<string>(boost::any_cast<string>(m["SkillGroupId"]));
    }
    if (m.find("UserCount") != m.end() && !m["UserCount"].empty()) {
      userCount = make_shared<long>(boost::any_cast<long>(m["UserCount"]));
    }
  }


  virtual ~ListInstancesOfUserResponseBodyDataListNumberListSkillGroups() = default;
};
class ListInstancesOfUserResponseBodyDataListNumberList : public Darabonba::Model {
public:
  shared_ptr<bool> active{};
  shared_ptr<string> city{};
  shared_ptr<string> contactFlowId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> number{};
  shared_ptr<string> province{};
  shared_ptr<vector<ListInstancesOfUserResponseBodyDataListNumberListSkillGroups>> skillGroups{};
  shared_ptr<string> usage{};
  shared_ptr<string> userId{};

  ListInstancesOfUserResponseBodyDataListNumberList() {}

  explicit ListInstancesOfUserResponseBodyDataListNumberList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (active) {
      res["Active"] = boost::any(*active);
    }
    if (city) {
      res["City"] = boost::any(*city);
    }
    if (contactFlowId) {
      res["ContactFlowId"] = boost::any(*contactFlowId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (number) {
      res["Number"] = boost::any(*number);
    }
    if (province) {
      res["Province"] = boost::any(*province);
    }
    if (skillGroups) {
      vector<boost::any> temp1;
      for(auto item1:*skillGroups){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SkillGroups"] = boost::any(temp1);
    }
    if (usage) {
      res["Usage"] = boost::any(*usage);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Active") != m.end() && !m["Active"].empty()) {
      active = make_shared<bool>(boost::any_cast<bool>(m["Active"]));
    }
    if (m.find("City") != m.end() && !m["City"].empty()) {
      city = make_shared<string>(boost::any_cast<string>(m["City"]));
    }
    if (m.find("ContactFlowId") != m.end() && !m["ContactFlowId"].empty()) {
      contactFlowId = make_shared<string>(boost::any_cast<string>(m["ContactFlowId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Number") != m.end() && !m["Number"].empty()) {
      number = make_shared<string>(boost::any_cast<string>(m["Number"]));
    }
    if (m.find("Province") != m.end() && !m["Province"].empty()) {
      province = make_shared<string>(boost::any_cast<string>(m["Province"]));
    }
    if (m.find("SkillGroups") != m.end() && !m["SkillGroups"].empty()) {
      if (typeid(vector<boost::any>) == m["SkillGroups"].type()) {
        vector<ListInstancesOfUserResponseBodyDataListNumberListSkillGroups> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SkillGroups"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListInstancesOfUserResponseBodyDataListNumberListSkillGroups model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        skillGroups = make_shared<vector<ListInstancesOfUserResponseBodyDataListNumberListSkillGroups>>(expect1);
      }
    }
    if (m.find("Usage") != m.end() && !m["Usage"].empty()) {
      usage = make_shared<string>(boost::any_cast<string>(m["Usage"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~ListInstancesOfUserResponseBodyDataListNumberList() = default;
};
class ListInstancesOfUserResponseBodyDataList : public Darabonba::Model {
public:
  shared_ptr<vector<ListInstancesOfUserResponseBodyDataListAdminList>> adminList{};
  shared_ptr<string> aliyunUid{};
  shared_ptr<string> consoleUrl{};
  shared_ptr<string> description{};
  shared_ptr<string> domainName{};
  shared_ptr<string> id{};
  shared_ptr<string> name{};
  shared_ptr<vector<ListInstancesOfUserResponseBodyDataListNumberList>> numberList{};
  shared_ptr<string> status{};

  ListInstancesOfUserResponseBodyDataList() {}

  explicit ListInstancesOfUserResponseBodyDataList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (adminList) {
      vector<boost::any> temp1;
      for(auto item1:*adminList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AdminList"] = boost::any(temp1);
    }
    if (aliyunUid) {
      res["AliyunUid"] = boost::any(*aliyunUid);
    }
    if (consoleUrl) {
      res["ConsoleUrl"] = boost::any(*consoleUrl);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (numberList) {
      vector<boost::any> temp1;
      for(auto item1:*numberList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["NumberList"] = boost::any(temp1);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AdminList") != m.end() && !m["AdminList"].empty()) {
      if (typeid(vector<boost::any>) == m["AdminList"].type()) {
        vector<ListInstancesOfUserResponseBodyDataListAdminList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AdminList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListInstancesOfUserResponseBodyDataListAdminList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        adminList = make_shared<vector<ListInstancesOfUserResponseBodyDataListAdminList>>(expect1);
      }
    }
    if (m.find("AliyunUid") != m.end() && !m["AliyunUid"].empty()) {
      aliyunUid = make_shared<string>(boost::any_cast<string>(m["AliyunUid"]));
    }
    if (m.find("ConsoleUrl") != m.end() && !m["ConsoleUrl"].empty()) {
      consoleUrl = make_shared<string>(boost::any_cast<string>(m["ConsoleUrl"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("NumberList") != m.end() && !m["NumberList"].empty()) {
      if (typeid(vector<boost::any>) == m["NumberList"].type()) {
        vector<ListInstancesOfUserResponseBodyDataListNumberList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["NumberList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListInstancesOfUserResponseBodyDataListNumberList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        numberList = make_shared<vector<ListInstancesOfUserResponseBodyDataListNumberList>>(expect1);
      }
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~ListInstancesOfUserResponseBodyDataList() = default;
};
class ListInstancesOfUserResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<ListInstancesOfUserResponseBodyDataList>> list{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  ListInstancesOfUserResponseBodyData() {}

  explicit ListInstancesOfUserResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (list) {
      vector<boost::any> temp1;
      for(auto item1:*list){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["List"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(vector<boost::any>) == m["List"].type()) {
        vector<ListInstancesOfUserResponseBodyDataList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["List"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListInstancesOfUserResponseBodyDataList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        list = make_shared<vector<ListInstancesOfUserResponseBodyDataList>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListInstancesOfUserResponseBodyData() = default;
};
class ListInstancesOfUserResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<ListInstancesOfUserResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  ListInstancesOfUserResponseBody() {}

  explicit ListInstancesOfUserResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ListInstancesOfUserResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ListInstancesOfUserResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListInstancesOfUserResponseBody() = default;
};
class ListInstancesOfUserResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListInstancesOfUserResponseBody> body{};

  ListInstancesOfUserResponse() {}

  explicit ListInstancesOfUserResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListInstancesOfUserResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListInstancesOfUserResponseBody>(model1);
      }
    }
  }


  virtual ~ListInstancesOfUserResponse() = default;
};
class ListIntervalAgentReportRequest : public Darabonba::Model {
public:
  shared_ptr<string> agentId{};
  shared_ptr<long> endTime{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> interval{};
  shared_ptr<long> startTime{};

  ListIntervalAgentReportRequest() {}

  explicit ListIntervalAgentReportRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agentId) {
      res["AgentId"] = boost::any(*agentId);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AgentId") != m.end() && !m["AgentId"].empty()) {
      agentId = make_shared<string>(boost::any_cast<string>(m["AgentId"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<string>(boost::any_cast<string>(m["Interval"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
  }


  virtual ~ListIntervalAgentReportRequest() = default;
};
class ListIntervalAgentReportResponseBodyDataInbound : public Darabonba::Model {
public:
  shared_ptr<double> averageHoldTime{};
  shared_ptr<double> averageRingTime{};
  shared_ptr<double> averageTalkTime{};
  shared_ptr<double> averageWorkTime{};
  shared_ptr<long> callsAttendedTransferIn{};
  shared_ptr<long> callsAttendedTransferOut{};
  shared_ptr<long> callsBlindTransferIn{};
  shared_ptr<long> callsBlindTransferOut{};
  shared_ptr<long> callsHandled{};
  shared_ptr<long> callsHold{};
  shared_ptr<long> callsOffered{};
  shared_ptr<long> callsRinged{};
  shared_ptr<double> handleRate{};
  shared_ptr<long> maxHoldTime{};
  shared_ptr<long> maxRingTime{};
  shared_ptr<long> maxTalkTime{};
  shared_ptr<long> maxWorkTime{};
  shared_ptr<double> satisfactionIndex{};
  shared_ptr<double> satisfactionRate{};
  shared_ptr<long> satisfactionSurveysOffered{};
  shared_ptr<long> satisfactionSurveysResponded{};
  shared_ptr<long> totalHoldTime{};
  shared_ptr<long> totalRingTime{};
  shared_ptr<long> totalTalkTime{};
  shared_ptr<long> totalWorkTime{};

  ListIntervalAgentReportResponseBodyDataInbound() {}

  explicit ListIntervalAgentReportResponseBodyDataInbound(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (averageHoldTime) {
      res["AverageHoldTime"] = boost::any(*averageHoldTime);
    }
    if (averageRingTime) {
      res["AverageRingTime"] = boost::any(*averageRingTime);
    }
    if (averageTalkTime) {
      res["AverageTalkTime"] = boost::any(*averageTalkTime);
    }
    if (averageWorkTime) {
      res["AverageWorkTime"] = boost::any(*averageWorkTime);
    }
    if (callsAttendedTransferIn) {
      res["CallsAttendedTransferIn"] = boost::any(*callsAttendedTransferIn);
    }
    if (callsAttendedTransferOut) {
      res["CallsAttendedTransferOut"] = boost::any(*callsAttendedTransferOut);
    }
    if (callsBlindTransferIn) {
      res["CallsBlindTransferIn"] = boost::any(*callsBlindTransferIn);
    }
    if (callsBlindTransferOut) {
      res["CallsBlindTransferOut"] = boost::any(*callsBlindTransferOut);
    }
    if (callsHandled) {
      res["CallsHandled"] = boost::any(*callsHandled);
    }
    if (callsHold) {
      res["CallsHold"] = boost::any(*callsHold);
    }
    if (callsOffered) {
      res["CallsOffered"] = boost::any(*callsOffered);
    }
    if (callsRinged) {
      res["CallsRinged"] = boost::any(*callsRinged);
    }
    if (handleRate) {
      res["HandleRate"] = boost::any(*handleRate);
    }
    if (maxHoldTime) {
      res["MaxHoldTime"] = boost::any(*maxHoldTime);
    }
    if (maxRingTime) {
      res["MaxRingTime"] = boost::any(*maxRingTime);
    }
    if (maxTalkTime) {
      res["MaxTalkTime"] = boost::any(*maxTalkTime);
    }
    if (maxWorkTime) {
      res["MaxWorkTime"] = boost::any(*maxWorkTime);
    }
    if (satisfactionIndex) {
      res["SatisfactionIndex"] = boost::any(*satisfactionIndex);
    }
    if (satisfactionRate) {
      res["SatisfactionRate"] = boost::any(*satisfactionRate);
    }
    if (satisfactionSurveysOffered) {
      res["SatisfactionSurveysOffered"] = boost::any(*satisfactionSurveysOffered);
    }
    if (satisfactionSurveysResponded) {
      res["SatisfactionSurveysResponded"] = boost::any(*satisfactionSurveysResponded);
    }
    if (totalHoldTime) {
      res["TotalHoldTime"] = boost::any(*totalHoldTime);
    }
    if (totalRingTime) {
      res["TotalRingTime"] = boost::any(*totalRingTime);
    }
    if (totalTalkTime) {
      res["TotalTalkTime"] = boost::any(*totalTalkTime);
    }
    if (totalWorkTime) {
      res["TotalWorkTime"] = boost::any(*totalWorkTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AverageHoldTime") != m.end() && !m["AverageHoldTime"].empty()) {
      averageHoldTime = make_shared<double>(boost::any_cast<double>(m["AverageHoldTime"]));
    }
    if (m.find("AverageRingTime") != m.end() && !m["AverageRingTime"].empty()) {
      averageRingTime = make_shared<double>(boost::any_cast<double>(m["AverageRingTime"]));
    }
    if (m.find("AverageTalkTime") != m.end() && !m["AverageTalkTime"].empty()) {
      averageTalkTime = make_shared<double>(boost::any_cast<double>(m["AverageTalkTime"]));
    }
    if (m.find("AverageWorkTime") != m.end() && !m["AverageWorkTime"].empty()) {
      averageWorkTime = make_shared<double>(boost::any_cast<double>(m["AverageWorkTime"]));
    }
    if (m.find("CallsAttendedTransferIn") != m.end() && !m["CallsAttendedTransferIn"].empty()) {
      callsAttendedTransferIn = make_shared<long>(boost::any_cast<long>(m["CallsAttendedTransferIn"]));
    }
    if (m.find("CallsAttendedTransferOut") != m.end() && !m["CallsAttendedTransferOut"].empty()) {
      callsAttendedTransferOut = make_shared<long>(boost::any_cast<long>(m["CallsAttendedTransferOut"]));
    }
    if (m.find("CallsBlindTransferIn") != m.end() && !m["CallsBlindTransferIn"].empty()) {
      callsBlindTransferIn = make_shared<long>(boost::any_cast<long>(m["CallsBlindTransferIn"]));
    }
    if (m.find("CallsBlindTransferOut") != m.end() && !m["CallsBlindTransferOut"].empty()) {
      callsBlindTransferOut = make_shared<long>(boost::any_cast<long>(m["CallsBlindTransferOut"]));
    }
    if (m.find("CallsHandled") != m.end() && !m["CallsHandled"].empty()) {
      callsHandled = make_shared<long>(boost::any_cast<long>(m["CallsHandled"]));
    }
    if (m.find("CallsHold") != m.end() && !m["CallsHold"].empty()) {
      callsHold = make_shared<long>(boost::any_cast<long>(m["CallsHold"]));
    }
    if (m.find("CallsOffered") != m.end() && !m["CallsOffered"].empty()) {
      callsOffered = make_shared<long>(boost::any_cast<long>(m["CallsOffered"]));
    }
    if (m.find("CallsRinged") != m.end() && !m["CallsRinged"].empty()) {
      callsRinged = make_shared<long>(boost::any_cast<long>(m["CallsRinged"]));
    }
    if (m.find("HandleRate") != m.end() && !m["HandleRate"].empty()) {
      handleRate = make_shared<double>(boost::any_cast<double>(m["HandleRate"]));
    }
    if (m.find("MaxHoldTime") != m.end() && !m["MaxHoldTime"].empty()) {
      maxHoldTime = make_shared<long>(boost::any_cast<long>(m["MaxHoldTime"]));
    }
    if (m.find("MaxRingTime") != m.end() && !m["MaxRingTime"].empty()) {
      maxRingTime = make_shared<long>(boost::any_cast<long>(m["MaxRingTime"]));
    }
    if (m.find("MaxTalkTime") != m.end() && !m["MaxTalkTime"].empty()) {
      maxTalkTime = make_shared<long>(boost::any_cast<long>(m["MaxTalkTime"]));
    }
    if (m.find("MaxWorkTime") != m.end() && !m["MaxWorkTime"].empty()) {
      maxWorkTime = make_shared<long>(boost::any_cast<long>(m["MaxWorkTime"]));
    }
    if (m.find("SatisfactionIndex") != m.end() && !m["SatisfactionIndex"].empty()) {
      satisfactionIndex = make_shared<double>(boost::any_cast<double>(m["SatisfactionIndex"]));
    }
    if (m.find("SatisfactionRate") != m.end() && !m["SatisfactionRate"].empty()) {
      satisfactionRate = make_shared<double>(boost::any_cast<double>(m["SatisfactionRate"]));
    }
    if (m.find("SatisfactionSurveysOffered") != m.end() && !m["SatisfactionSurveysOffered"].empty()) {
      satisfactionSurveysOffered = make_shared<long>(boost::any_cast<long>(m["SatisfactionSurveysOffered"]));
    }
    if (m.find("SatisfactionSurveysResponded") != m.end() && !m["SatisfactionSurveysResponded"].empty()) {
      satisfactionSurveysResponded = make_shared<long>(boost::any_cast<long>(m["SatisfactionSurveysResponded"]));
    }
    if (m.find("TotalHoldTime") != m.end() && !m["TotalHoldTime"].empty()) {
      totalHoldTime = make_shared<long>(boost::any_cast<long>(m["TotalHoldTime"]));
    }
    if (m.find("TotalRingTime") != m.end() && !m["TotalRingTime"].empty()) {
      totalRingTime = make_shared<long>(boost::any_cast<long>(m["TotalRingTime"]));
    }
    if (m.find("TotalTalkTime") != m.end() && !m["TotalTalkTime"].empty()) {
      totalTalkTime = make_shared<long>(boost::any_cast<long>(m["TotalTalkTime"]));
    }
    if (m.find("TotalWorkTime") != m.end() && !m["TotalWorkTime"].empty()) {
      totalWorkTime = make_shared<long>(boost::any_cast<long>(m["TotalWorkTime"]));
    }
  }


  virtual ~ListIntervalAgentReportResponseBodyDataInbound() = default;
};
class ListIntervalAgentReportResponseBodyDataOutbound : public Darabonba::Model {
public:
  shared_ptr<double> answerRate{};
  shared_ptr<double> averageDialingTime{};
  shared_ptr<double> averageHoldTime{};
  shared_ptr<double> averageRingTime{};
  shared_ptr<double> averageTalkTime{};
  shared_ptr<double> averageWorkTime{};
  shared_ptr<long> callsAnswered{};
  shared_ptr<long> callsAttendedTransferIn{};
  shared_ptr<long> callsAttendedTransferOut{};
  shared_ptr<long> callsBlindTransferIn{};
  shared_ptr<long> callsBlindTransferOut{};
  shared_ptr<long> callsDialed{};
  shared_ptr<long> callsHold{};
  shared_ptr<long> callsRinged{};
  shared_ptr<long> maxDialingTime{};
  shared_ptr<long> maxHoldTime{};
  shared_ptr<long> maxRingTime{};
  shared_ptr<long> maxTalkTime{};
  shared_ptr<long> maxWorkTime{};
  shared_ptr<double> satisfactionIndex{};
  shared_ptr<double> satisfactionRate{};
  shared_ptr<long> satisfactionSurveysOffered{};
  shared_ptr<long> satisfactionSurveysResponded{};
  shared_ptr<long> totalDialingTime{};
  shared_ptr<long> totalHoldTime{};
  shared_ptr<long> totalRingTime{};
  shared_ptr<long> totalTalkTime{};
  shared_ptr<long> totalWorkTime{};

  ListIntervalAgentReportResponseBodyDataOutbound() {}

  explicit ListIntervalAgentReportResponseBodyDataOutbound(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (answerRate) {
      res["AnswerRate"] = boost::any(*answerRate);
    }
    if (averageDialingTime) {
      res["AverageDialingTime"] = boost::any(*averageDialingTime);
    }
    if (averageHoldTime) {
      res["AverageHoldTime"] = boost::any(*averageHoldTime);
    }
    if (averageRingTime) {
      res["AverageRingTime"] = boost::any(*averageRingTime);
    }
    if (averageTalkTime) {
      res["AverageTalkTime"] = boost::any(*averageTalkTime);
    }
    if (averageWorkTime) {
      res["AverageWorkTime"] = boost::any(*averageWorkTime);
    }
    if (callsAnswered) {
      res["CallsAnswered"] = boost::any(*callsAnswered);
    }
    if (callsAttendedTransferIn) {
      res["CallsAttendedTransferIn"] = boost::any(*callsAttendedTransferIn);
    }
    if (callsAttendedTransferOut) {
      res["CallsAttendedTransferOut"] = boost::any(*callsAttendedTransferOut);
    }
    if (callsBlindTransferIn) {
      res["CallsBlindTransferIn"] = boost::any(*callsBlindTransferIn);
    }
    if (callsBlindTransferOut) {
      res["CallsBlindTransferOut"] = boost::any(*callsBlindTransferOut);
    }
    if (callsDialed) {
      res["CallsDialed"] = boost::any(*callsDialed);
    }
    if (callsHold) {
      res["CallsHold"] = boost::any(*callsHold);
    }
    if (callsRinged) {
      res["CallsRinged"] = boost::any(*callsRinged);
    }
    if (maxDialingTime) {
      res["MaxDialingTime"] = boost::any(*maxDialingTime);
    }
    if (maxHoldTime) {
      res["MaxHoldTime"] = boost::any(*maxHoldTime);
    }
    if (maxRingTime) {
      res["MaxRingTime"] = boost::any(*maxRingTime);
    }
    if (maxTalkTime) {
      res["MaxTalkTime"] = boost::any(*maxTalkTime);
    }
    if (maxWorkTime) {
      res["MaxWorkTime"] = boost::any(*maxWorkTime);
    }
    if (satisfactionIndex) {
      res["SatisfactionIndex"] = boost::any(*satisfactionIndex);
    }
    if (satisfactionRate) {
      res["SatisfactionRate"] = boost::any(*satisfactionRate);
    }
    if (satisfactionSurveysOffered) {
      res["SatisfactionSurveysOffered"] = boost::any(*satisfactionSurveysOffered);
    }
    if (satisfactionSurveysResponded) {
      res["SatisfactionSurveysResponded"] = boost::any(*satisfactionSurveysResponded);
    }
    if (totalDialingTime) {
      res["TotalDialingTime"] = boost::any(*totalDialingTime);
    }
    if (totalHoldTime) {
      res["TotalHoldTime"] = boost::any(*totalHoldTime);
    }
    if (totalRingTime) {
      res["TotalRingTime"] = boost::any(*totalRingTime);
    }
    if (totalTalkTime) {
      res["TotalTalkTime"] = boost::any(*totalTalkTime);
    }
    if (totalWorkTime) {
      res["TotalWorkTime"] = boost::any(*totalWorkTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AnswerRate") != m.end() && !m["AnswerRate"].empty()) {
      answerRate = make_shared<double>(boost::any_cast<double>(m["AnswerRate"]));
    }
    if (m.find("AverageDialingTime") != m.end() && !m["AverageDialingTime"].empty()) {
      averageDialingTime = make_shared<double>(boost::any_cast<double>(m["AverageDialingTime"]));
    }
    if (m.find("AverageHoldTime") != m.end() && !m["AverageHoldTime"].empty()) {
      averageHoldTime = make_shared<double>(boost::any_cast<double>(m["AverageHoldTime"]));
    }
    if (m.find("AverageRingTime") != m.end() && !m["AverageRingTime"].empty()) {
      averageRingTime = make_shared<double>(boost::any_cast<double>(m["AverageRingTime"]));
    }
    if (m.find("AverageTalkTime") != m.end() && !m["AverageTalkTime"].empty()) {
      averageTalkTime = make_shared<double>(boost::any_cast<double>(m["AverageTalkTime"]));
    }
    if (m.find("AverageWorkTime") != m.end() && !m["AverageWorkTime"].empty()) {
      averageWorkTime = make_shared<double>(boost::any_cast<double>(m["AverageWorkTime"]));
    }
    if (m.find("CallsAnswered") != m.end() && !m["CallsAnswered"].empty()) {
      callsAnswered = make_shared<long>(boost::any_cast<long>(m["CallsAnswered"]));
    }
    if (m.find("CallsAttendedTransferIn") != m.end() && !m["CallsAttendedTransferIn"].empty()) {
      callsAttendedTransferIn = make_shared<long>(boost::any_cast<long>(m["CallsAttendedTransferIn"]));
    }
    if (m.find("CallsAttendedTransferOut") != m.end() && !m["CallsAttendedTransferOut"].empty()) {
      callsAttendedTransferOut = make_shared<long>(boost::any_cast<long>(m["CallsAttendedTransferOut"]));
    }
    if (m.find("CallsBlindTransferIn") != m.end() && !m["CallsBlindTransferIn"].empty()) {
      callsBlindTransferIn = make_shared<long>(boost::any_cast<long>(m["CallsBlindTransferIn"]));
    }
    if (m.find("CallsBlindTransferOut") != m.end() && !m["CallsBlindTransferOut"].empty()) {
      callsBlindTransferOut = make_shared<long>(boost::any_cast<long>(m["CallsBlindTransferOut"]));
    }
    if (m.find("CallsDialed") != m.end() && !m["CallsDialed"].empty()) {
      callsDialed = make_shared<long>(boost::any_cast<long>(m["CallsDialed"]));
    }
    if (m.find("CallsHold") != m.end() && !m["CallsHold"].empty()) {
      callsHold = make_shared<long>(boost::any_cast<long>(m["CallsHold"]));
    }
    if (m.find("CallsRinged") != m.end() && !m["CallsRinged"].empty()) {
      callsRinged = make_shared<long>(boost::any_cast<long>(m["CallsRinged"]));
    }
    if (m.find("MaxDialingTime") != m.end() && !m["MaxDialingTime"].empty()) {
      maxDialingTime = make_shared<long>(boost::any_cast<long>(m["MaxDialingTime"]));
    }
    if (m.find("MaxHoldTime") != m.end() && !m["MaxHoldTime"].empty()) {
      maxHoldTime = make_shared<long>(boost::any_cast<long>(m["MaxHoldTime"]));
    }
    if (m.find("MaxRingTime") != m.end() && !m["MaxRingTime"].empty()) {
      maxRingTime = make_shared<long>(boost::any_cast<long>(m["MaxRingTime"]));
    }
    if (m.find("MaxTalkTime") != m.end() && !m["MaxTalkTime"].empty()) {
      maxTalkTime = make_shared<long>(boost::any_cast<long>(m["MaxTalkTime"]));
    }
    if (m.find("MaxWorkTime") != m.end() && !m["MaxWorkTime"].empty()) {
      maxWorkTime = make_shared<long>(boost::any_cast<long>(m["MaxWorkTime"]));
    }
    if (m.find("SatisfactionIndex") != m.end() && !m["SatisfactionIndex"].empty()) {
      satisfactionIndex = make_shared<double>(boost::any_cast<double>(m["SatisfactionIndex"]));
    }
    if (m.find("SatisfactionRate") != m.end() && !m["SatisfactionRate"].empty()) {
      satisfactionRate = make_shared<double>(boost::any_cast<double>(m["SatisfactionRate"]));
    }
    if (m.find("SatisfactionSurveysOffered") != m.end() && !m["SatisfactionSurveysOffered"].empty()) {
      satisfactionSurveysOffered = make_shared<long>(boost::any_cast<long>(m["SatisfactionSurveysOffered"]));
    }
    if (m.find("SatisfactionSurveysResponded") != m.end() && !m["SatisfactionSurveysResponded"].empty()) {
      satisfactionSurveysResponded = make_shared<long>(boost::any_cast<long>(m["SatisfactionSurveysResponded"]));
    }
    if (m.find("TotalDialingTime") != m.end() && !m["TotalDialingTime"].empty()) {
      totalDialingTime = make_shared<long>(boost::any_cast<long>(m["TotalDialingTime"]));
    }
    if (m.find("TotalHoldTime") != m.end() && !m["TotalHoldTime"].empty()) {
      totalHoldTime = make_shared<long>(boost::any_cast<long>(m["TotalHoldTime"]));
    }
    if (m.find("TotalRingTime") != m.end() && !m["TotalRingTime"].empty()) {
      totalRingTime = make_shared<long>(boost::any_cast<long>(m["TotalRingTime"]));
    }
    if (m.find("TotalTalkTime") != m.end() && !m["TotalTalkTime"].empty()) {
      totalTalkTime = make_shared<long>(boost::any_cast<long>(m["TotalTalkTime"]));
    }
    if (m.find("TotalWorkTime") != m.end() && !m["TotalWorkTime"].empty()) {
      totalWorkTime = make_shared<long>(boost::any_cast<long>(m["TotalWorkTime"]));
    }
  }


  virtual ~ListIntervalAgentReportResponseBodyDataOutbound() = default;
};
class ListIntervalAgentReportResponseBodyDataOverall : public Darabonba::Model {
public:
  shared_ptr<double> averageBreakTime{};
  shared_ptr<double> averageHoldTime{};
  shared_ptr<double> averageReadyTime{};
  shared_ptr<double> averageTalkTime{};
  shared_ptr<double> averageWorkTime{};
  shared_ptr<long> firstCheckInTime{};
  shared_ptr<long> lastCheckoutTime{};
  shared_ptr<long> maxBreakTime{};
  shared_ptr<long> maxHoldTime{};
  shared_ptr<long> maxReadyTime{};
  shared_ptr<long> maxTalkTime{};
  shared_ptr<long> maxWorkTime{};
  shared_ptr<double> occupancyRate{};
  shared_ptr<double> satisfactionIndex{};
  shared_ptr<double> satisfactionRate{};
  shared_ptr<long> satisfactionSurveysOffered{};
  shared_ptr<long> satisfactionSurveysResponded{};
  shared_ptr<long> totalBreakTime{};
  shared_ptr<long> totalCalls{};
  shared_ptr<long> totalHoldTime{};
  shared_ptr<long> totalLoggedInTime{};
  shared_ptr<long> totalReadyTime{};
  shared_ptr<long> totalTalkTime{};
  shared_ptr<long> totalWorkTime{};

  ListIntervalAgentReportResponseBodyDataOverall() {}

  explicit ListIntervalAgentReportResponseBodyDataOverall(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (averageBreakTime) {
      res["AverageBreakTime"] = boost::any(*averageBreakTime);
    }
    if (averageHoldTime) {
      res["AverageHoldTime"] = boost::any(*averageHoldTime);
    }
    if (averageReadyTime) {
      res["AverageReadyTime"] = boost::any(*averageReadyTime);
    }
    if (averageTalkTime) {
      res["AverageTalkTime"] = boost::any(*averageTalkTime);
    }
    if (averageWorkTime) {
      res["AverageWorkTime"] = boost::any(*averageWorkTime);
    }
    if (firstCheckInTime) {
      res["FirstCheckInTime"] = boost::any(*firstCheckInTime);
    }
    if (lastCheckoutTime) {
      res["LastCheckoutTime"] = boost::any(*lastCheckoutTime);
    }
    if (maxBreakTime) {
      res["MaxBreakTime"] = boost::any(*maxBreakTime);
    }
    if (maxHoldTime) {
      res["MaxHoldTime"] = boost::any(*maxHoldTime);
    }
    if (maxReadyTime) {
      res["MaxReadyTime"] = boost::any(*maxReadyTime);
    }
    if (maxTalkTime) {
      res["MaxTalkTime"] = boost::any(*maxTalkTime);
    }
    if (maxWorkTime) {
      res["MaxWorkTime"] = boost::any(*maxWorkTime);
    }
    if (occupancyRate) {
      res["OccupancyRate"] = boost::any(*occupancyRate);
    }
    if (satisfactionIndex) {
      res["SatisfactionIndex"] = boost::any(*satisfactionIndex);
    }
    if (satisfactionRate) {
      res["SatisfactionRate"] = boost::any(*satisfactionRate);
    }
    if (satisfactionSurveysOffered) {
      res["SatisfactionSurveysOffered"] = boost::any(*satisfactionSurveysOffered);
    }
    if (satisfactionSurveysResponded) {
      res["SatisfactionSurveysResponded"] = boost::any(*satisfactionSurveysResponded);
    }
    if (totalBreakTime) {
      res["TotalBreakTime"] = boost::any(*totalBreakTime);
    }
    if (totalCalls) {
      res["TotalCalls"] = boost::any(*totalCalls);
    }
    if (totalHoldTime) {
      res["TotalHoldTime"] = boost::any(*totalHoldTime);
    }
    if (totalLoggedInTime) {
      res["TotalLoggedInTime"] = boost::any(*totalLoggedInTime);
    }
    if (totalReadyTime) {
      res["TotalReadyTime"] = boost::any(*totalReadyTime);
    }
    if (totalTalkTime) {
      res["TotalTalkTime"] = boost::any(*totalTalkTime);
    }
    if (totalWorkTime) {
      res["TotalWorkTime"] = boost::any(*totalWorkTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AverageBreakTime") != m.end() && !m["AverageBreakTime"].empty()) {
      averageBreakTime = make_shared<double>(boost::any_cast<double>(m["AverageBreakTime"]));
    }
    if (m.find("AverageHoldTime") != m.end() && !m["AverageHoldTime"].empty()) {
      averageHoldTime = make_shared<double>(boost::any_cast<double>(m["AverageHoldTime"]));
    }
    if (m.find("AverageReadyTime") != m.end() && !m["AverageReadyTime"].empty()) {
      averageReadyTime = make_shared<double>(boost::any_cast<double>(m["AverageReadyTime"]));
    }
    if (m.find("AverageTalkTime") != m.end() && !m["AverageTalkTime"].empty()) {
      averageTalkTime = make_shared<double>(boost::any_cast<double>(m["AverageTalkTime"]));
    }
    if (m.find("AverageWorkTime") != m.end() && !m["AverageWorkTime"].empty()) {
      averageWorkTime = make_shared<double>(boost::any_cast<double>(m["AverageWorkTime"]));
    }
    if (m.find("FirstCheckInTime") != m.end() && !m["FirstCheckInTime"].empty()) {
      firstCheckInTime = make_shared<long>(boost::any_cast<long>(m["FirstCheckInTime"]));
    }
    if (m.find("LastCheckoutTime") != m.end() && !m["LastCheckoutTime"].empty()) {
      lastCheckoutTime = make_shared<long>(boost::any_cast<long>(m["LastCheckoutTime"]));
    }
    if (m.find("MaxBreakTime") != m.end() && !m["MaxBreakTime"].empty()) {
      maxBreakTime = make_shared<long>(boost::any_cast<long>(m["MaxBreakTime"]));
    }
    if (m.find("MaxHoldTime") != m.end() && !m["MaxHoldTime"].empty()) {
      maxHoldTime = make_shared<long>(boost::any_cast<long>(m["MaxHoldTime"]));
    }
    if (m.find("MaxReadyTime") != m.end() && !m["MaxReadyTime"].empty()) {
      maxReadyTime = make_shared<long>(boost::any_cast<long>(m["MaxReadyTime"]));
    }
    if (m.find("MaxTalkTime") != m.end() && !m["MaxTalkTime"].empty()) {
      maxTalkTime = make_shared<long>(boost::any_cast<long>(m["MaxTalkTime"]));
    }
    if (m.find("MaxWorkTime") != m.end() && !m["MaxWorkTime"].empty()) {
      maxWorkTime = make_shared<long>(boost::any_cast<long>(m["MaxWorkTime"]));
    }
    if (m.find("OccupancyRate") != m.end() && !m["OccupancyRate"].empty()) {
      occupancyRate = make_shared<double>(boost::any_cast<double>(m["OccupancyRate"]));
    }
    if (m.find("SatisfactionIndex") != m.end() && !m["SatisfactionIndex"].empty()) {
      satisfactionIndex = make_shared<double>(boost::any_cast<double>(m["SatisfactionIndex"]));
    }
    if (m.find("SatisfactionRate") != m.end() && !m["SatisfactionRate"].empty()) {
      satisfactionRate = make_shared<double>(boost::any_cast<double>(m["SatisfactionRate"]));
    }
    if (m.find("SatisfactionSurveysOffered") != m.end() && !m["SatisfactionSurveysOffered"].empty()) {
      satisfactionSurveysOffered = make_shared<long>(boost::any_cast<long>(m["SatisfactionSurveysOffered"]));
    }
    if (m.find("SatisfactionSurveysResponded") != m.end() && !m["SatisfactionSurveysResponded"].empty()) {
      satisfactionSurveysResponded = make_shared<long>(boost::any_cast<long>(m["SatisfactionSurveysResponded"]));
    }
    if (m.find("TotalBreakTime") != m.end() && !m["TotalBreakTime"].empty()) {
      totalBreakTime = make_shared<long>(boost::any_cast<long>(m["TotalBreakTime"]));
    }
    if (m.find("TotalCalls") != m.end() && !m["TotalCalls"].empty()) {
      totalCalls = make_shared<long>(boost::any_cast<long>(m["TotalCalls"]));
    }
    if (m.find("TotalHoldTime") != m.end() && !m["TotalHoldTime"].empty()) {
      totalHoldTime = make_shared<long>(boost::any_cast<long>(m["TotalHoldTime"]));
    }
    if (m.find("TotalLoggedInTime") != m.end() && !m["TotalLoggedInTime"].empty()) {
      totalLoggedInTime = make_shared<long>(boost::any_cast<long>(m["TotalLoggedInTime"]));
    }
    if (m.find("TotalReadyTime") != m.end() && !m["TotalReadyTime"].empty()) {
      totalReadyTime = make_shared<long>(boost::any_cast<long>(m["TotalReadyTime"]));
    }
    if (m.find("TotalTalkTime") != m.end() && !m["TotalTalkTime"].empty()) {
      totalTalkTime = make_shared<long>(boost::any_cast<long>(m["TotalTalkTime"]));
    }
    if (m.find("TotalWorkTime") != m.end() && !m["TotalWorkTime"].empty()) {
      totalWorkTime = make_shared<long>(boost::any_cast<long>(m["TotalWorkTime"]));
    }
  }


  virtual ~ListIntervalAgentReportResponseBodyDataOverall() = default;
};
class ListIntervalAgentReportResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<ListIntervalAgentReportResponseBodyDataInbound> inbound{};
  shared_ptr<ListIntervalAgentReportResponseBodyDataOutbound> outbound{};
  shared_ptr<ListIntervalAgentReportResponseBodyDataOverall> overall{};
  shared_ptr<long> statsTime{};

  ListIntervalAgentReportResponseBodyData() {}

  explicit ListIntervalAgentReportResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (inbound) {
      res["Inbound"] = inbound ? boost::any(inbound->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (outbound) {
      res["Outbound"] = outbound ? boost::any(outbound->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (overall) {
      res["Overall"] = overall ? boost::any(overall->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (statsTime) {
      res["StatsTime"] = boost::any(*statsTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Inbound") != m.end() && !m["Inbound"].empty()) {
      if (typeid(map<string, boost::any>) == m["Inbound"].type()) {
        ListIntervalAgentReportResponseBodyDataInbound model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Inbound"]));
        inbound = make_shared<ListIntervalAgentReportResponseBodyDataInbound>(model1);
      }
    }
    if (m.find("Outbound") != m.end() && !m["Outbound"].empty()) {
      if (typeid(map<string, boost::any>) == m["Outbound"].type()) {
        ListIntervalAgentReportResponseBodyDataOutbound model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Outbound"]));
        outbound = make_shared<ListIntervalAgentReportResponseBodyDataOutbound>(model1);
      }
    }
    if (m.find("Overall") != m.end() && !m["Overall"].empty()) {
      if (typeid(map<string, boost::any>) == m["Overall"].type()) {
        ListIntervalAgentReportResponseBodyDataOverall model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Overall"]));
        overall = make_shared<ListIntervalAgentReportResponseBodyDataOverall>(model1);
      }
    }
    if (m.find("StatsTime") != m.end() && !m["StatsTime"].empty()) {
      statsTime = make_shared<long>(boost::any_cast<long>(m["StatsTime"]));
    }
  }


  virtual ~ListIntervalAgentReportResponseBodyData() = default;
};
class ListIntervalAgentReportResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<vector<ListIntervalAgentReportResponseBodyData>> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  ListIntervalAgentReportResponseBody() {}

  explicit ListIntervalAgentReportResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<ListIntervalAgentReportResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListIntervalAgentReportResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<ListIntervalAgentReportResponseBodyData>>(expect1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListIntervalAgentReportResponseBody() = default;
};
class ListIntervalAgentReportResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListIntervalAgentReportResponseBody> body{};

  ListIntervalAgentReportResponse() {}

  explicit ListIntervalAgentReportResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListIntervalAgentReportResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListIntervalAgentReportResponseBody>(model1);
      }
    }
  }


  virtual ~ListIntervalAgentReportResponse() = default;
};
class ListIntervalInstanceReportRequest : public Darabonba::Model {
public:
  shared_ptr<long> endTime{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> interval{};
  shared_ptr<long> startTime{};

  ListIntervalInstanceReportRequest() {}

  explicit ListIntervalInstanceReportRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<string>(boost::any_cast<string>(m["Interval"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
  }


  virtual ~ListIntervalInstanceReportRequest() = default;
};
class ListIntervalInstanceReportResponseBodyDataInbound : public Darabonba::Model {
public:
  shared_ptr<double> abandonedRate{};
  shared_ptr<double> averageAbandonTime{};
  shared_ptr<double> averageAbandonedInIVRTime{};
  shared_ptr<double> averageAbandonedInQueueTime{};
  shared_ptr<double> averageAbandonedInRingTime{};
  shared_ptr<double> averageHoldTime{};
  shared_ptr<double> averageRingTime{};
  shared_ptr<double> averageTalkTime{};
  shared_ptr<double> averageWaitTime{};
  shared_ptr<double> averageWorkTime{};
  shared_ptr<long> callsAbandoned{};
  shared_ptr<long> callsAbandonedInIVR{};
  shared_ptr<long> callsAbandonedInQueue{};
  shared_ptr<long> callsAbandonedInRing{};
  shared_ptr<long> callsAbandonedInVoiceNavigator{};
  shared_ptr<long> callsAttendedTransferred{};
  shared_ptr<long> callsBlindTransferred{};
  shared_ptr<long> callsForwardToOutsideNumber{};
  shared_ptr<long> callsHandled{};
  shared_ptr<long> callsHold{};
  shared_ptr<long> callsIVRException{};
  shared_ptr<long> callsOffered{};
  shared_ptr<long> callsQueued{};
  shared_ptr<long> callsQueuingFailed{};
  shared_ptr<long> callsQueuingOverflow{};
  shared_ptr<long> callsQueuingTimeout{};
  shared_ptr<long> callsRinged{};
  shared_ptr<long> callsVoicemail{};
  shared_ptr<double> handleRate{};
  shared_ptr<long> maxAbandonTime{};
  shared_ptr<long> maxAbandonedInIVRTime{};
  shared_ptr<long> maxAbandonedInQueueTime{};
  shared_ptr<long> maxAbandonedInRingTime{};
  shared_ptr<long> maxHoldTime{};
  shared_ptr<long> maxRingTime{};
  shared_ptr<long> maxTalkTime{};
  shared_ptr<long> maxWaitTime{};
  shared_ptr<long> maxWorkTime{};
  shared_ptr<double> satisfactionIndex{};
  shared_ptr<double> satisfactionRate{};
  shared_ptr<long> satisfactionSurveysOffered{};
  shared_ptr<long> satisfactionSurveysResponded{};
  shared_ptr<double> serviceLevel20{};
  shared_ptr<long> totalAbandonTime{};
  shared_ptr<long> totalAbandonedInIVRTime{};
  shared_ptr<long> totalAbandonedInQueueTime{};
  shared_ptr<long> totalAbandonedInRingTime{};
  shared_ptr<long> totalHoldTime{};
  shared_ptr<long> totalRingTime{};
  shared_ptr<long> totalTalkTime{};
  shared_ptr<long> totalWaitTime{};
  shared_ptr<long> totalWorkTime{};

  ListIntervalInstanceReportResponseBodyDataInbound() {}

  explicit ListIntervalInstanceReportResponseBodyDataInbound(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (abandonedRate) {
      res["AbandonedRate"] = boost::any(*abandonedRate);
    }
    if (averageAbandonTime) {
      res["AverageAbandonTime"] = boost::any(*averageAbandonTime);
    }
    if (averageAbandonedInIVRTime) {
      res["AverageAbandonedInIVRTime"] = boost::any(*averageAbandonedInIVRTime);
    }
    if (averageAbandonedInQueueTime) {
      res["AverageAbandonedInQueueTime"] = boost::any(*averageAbandonedInQueueTime);
    }
    if (averageAbandonedInRingTime) {
      res["AverageAbandonedInRingTime"] = boost::any(*averageAbandonedInRingTime);
    }
    if (averageHoldTime) {
      res["AverageHoldTime"] = boost::any(*averageHoldTime);
    }
    if (averageRingTime) {
      res["AverageRingTime"] = boost::any(*averageRingTime);
    }
    if (averageTalkTime) {
      res["AverageTalkTime"] = boost::any(*averageTalkTime);
    }
    if (averageWaitTime) {
      res["AverageWaitTime"] = boost::any(*averageWaitTime);
    }
    if (averageWorkTime) {
      res["AverageWorkTime"] = boost::any(*averageWorkTime);
    }
    if (callsAbandoned) {
      res["CallsAbandoned"] = boost::any(*callsAbandoned);
    }
    if (callsAbandonedInIVR) {
      res["CallsAbandonedInIVR"] = boost::any(*callsAbandonedInIVR);
    }
    if (callsAbandonedInQueue) {
      res["CallsAbandonedInQueue"] = boost::any(*callsAbandonedInQueue);
    }
    if (callsAbandonedInRing) {
      res["CallsAbandonedInRing"] = boost::any(*callsAbandonedInRing);
    }
    if (callsAbandonedInVoiceNavigator) {
      res["CallsAbandonedInVoiceNavigator"] = boost::any(*callsAbandonedInVoiceNavigator);
    }
    if (callsAttendedTransferred) {
      res["CallsAttendedTransferred"] = boost::any(*callsAttendedTransferred);
    }
    if (callsBlindTransferred) {
      res["CallsBlindTransferred"] = boost::any(*callsBlindTransferred);
    }
    if (callsForwardToOutsideNumber) {
      res["CallsForwardToOutsideNumber"] = boost::any(*callsForwardToOutsideNumber);
    }
    if (callsHandled) {
      res["CallsHandled"] = boost::any(*callsHandled);
    }
    if (callsHold) {
      res["CallsHold"] = boost::any(*callsHold);
    }
    if (callsIVRException) {
      res["CallsIVRException"] = boost::any(*callsIVRException);
    }
    if (callsOffered) {
      res["CallsOffered"] = boost::any(*callsOffered);
    }
    if (callsQueued) {
      res["CallsQueued"] = boost::any(*callsQueued);
    }
    if (callsQueuingFailed) {
      res["CallsQueuingFailed"] = boost::any(*callsQueuingFailed);
    }
    if (callsQueuingOverflow) {
      res["CallsQueuingOverflow"] = boost::any(*callsQueuingOverflow);
    }
    if (callsQueuingTimeout) {
      res["CallsQueuingTimeout"] = boost::any(*callsQueuingTimeout);
    }
    if (callsRinged) {
      res["CallsRinged"] = boost::any(*callsRinged);
    }
    if (callsVoicemail) {
      res["CallsVoicemail"] = boost::any(*callsVoicemail);
    }
    if (handleRate) {
      res["HandleRate"] = boost::any(*handleRate);
    }
    if (maxAbandonTime) {
      res["MaxAbandonTime"] = boost::any(*maxAbandonTime);
    }
    if (maxAbandonedInIVRTime) {
      res["MaxAbandonedInIVRTime"] = boost::any(*maxAbandonedInIVRTime);
    }
    if (maxAbandonedInQueueTime) {
      res["MaxAbandonedInQueueTime"] = boost::any(*maxAbandonedInQueueTime);
    }
    if (maxAbandonedInRingTime) {
      res["MaxAbandonedInRingTime"] = boost::any(*maxAbandonedInRingTime);
    }
    if (maxHoldTime) {
      res["MaxHoldTime"] = boost::any(*maxHoldTime);
    }
    if (maxRingTime) {
      res["MaxRingTime"] = boost::any(*maxRingTime);
    }
    if (maxTalkTime) {
      res["MaxTalkTime"] = boost::any(*maxTalkTime);
    }
    if (maxWaitTime) {
      res["MaxWaitTime"] = boost::any(*maxWaitTime);
    }
    if (maxWorkTime) {
      res["MaxWorkTime"] = boost::any(*maxWorkTime);
    }
    if (satisfactionIndex) {
      res["SatisfactionIndex"] = boost::any(*satisfactionIndex);
    }
    if (satisfactionRate) {
      res["SatisfactionRate"] = boost::any(*satisfactionRate);
    }
    if (satisfactionSurveysOffered) {
      res["SatisfactionSurveysOffered"] = boost::any(*satisfactionSurveysOffered);
    }
    if (satisfactionSurveysResponded) {
      res["SatisfactionSurveysResponded"] = boost::any(*satisfactionSurveysResponded);
    }
    if (serviceLevel20) {
      res["ServiceLevel20"] = boost::any(*serviceLevel20);
    }
    if (totalAbandonTime) {
      res["TotalAbandonTime"] = boost::any(*totalAbandonTime);
    }
    if (totalAbandonedInIVRTime) {
      res["TotalAbandonedInIVRTime"] = boost::any(*totalAbandonedInIVRTime);
    }
    if (totalAbandonedInQueueTime) {
      res["TotalAbandonedInQueueTime"] = boost::any(*totalAbandonedInQueueTime);
    }
    if (totalAbandonedInRingTime) {
      res["TotalAbandonedInRingTime"] = boost::any(*totalAbandonedInRingTime);
    }
    if (totalHoldTime) {
      res["TotalHoldTime"] = boost::any(*totalHoldTime);
    }
    if (totalRingTime) {
      res["TotalRingTime"] = boost::any(*totalRingTime);
    }
    if (totalTalkTime) {
      res["TotalTalkTime"] = boost::any(*totalTalkTime);
    }
    if (totalWaitTime) {
      res["TotalWaitTime"] = boost::any(*totalWaitTime);
    }
    if (totalWorkTime) {
      res["TotalWorkTime"] = boost::any(*totalWorkTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AbandonedRate") != m.end() && !m["AbandonedRate"].empty()) {
      abandonedRate = make_shared<double>(boost::any_cast<double>(m["AbandonedRate"]));
    }
    if (m.find("AverageAbandonTime") != m.end() && !m["AverageAbandonTime"].empty()) {
      averageAbandonTime = make_shared<double>(boost::any_cast<double>(m["AverageAbandonTime"]));
    }
    if (m.find("AverageAbandonedInIVRTime") != m.end() && !m["AverageAbandonedInIVRTime"].empty()) {
      averageAbandonedInIVRTime = make_shared<double>(boost::any_cast<double>(m["AverageAbandonedInIVRTime"]));
    }
    if (m.find("AverageAbandonedInQueueTime") != m.end() && !m["AverageAbandonedInQueueTime"].empty()) {
      averageAbandonedInQueueTime = make_shared<double>(boost::any_cast<double>(m["AverageAbandonedInQueueTime"]));
    }
    if (m.find("AverageAbandonedInRingTime") != m.end() && !m["AverageAbandonedInRingTime"].empty()) {
      averageAbandonedInRingTime = make_shared<double>(boost::any_cast<double>(m["AverageAbandonedInRingTime"]));
    }
    if (m.find("AverageHoldTime") != m.end() && !m["AverageHoldTime"].empty()) {
      averageHoldTime = make_shared<double>(boost::any_cast<double>(m["AverageHoldTime"]));
    }
    if (m.find("AverageRingTime") != m.end() && !m["AverageRingTime"].empty()) {
      averageRingTime = make_shared<double>(boost::any_cast<double>(m["AverageRingTime"]));
    }
    if (m.find("AverageTalkTime") != m.end() && !m["AverageTalkTime"].empty()) {
      averageTalkTime = make_shared<double>(boost::any_cast<double>(m["AverageTalkTime"]));
    }
    if (m.find("AverageWaitTime") != m.end() && !m["AverageWaitTime"].empty()) {
      averageWaitTime = make_shared<double>(boost::any_cast<double>(m["AverageWaitTime"]));
    }
    if (m.find("AverageWorkTime") != m.end() && !m["AverageWorkTime"].empty()) {
      averageWorkTime = make_shared<double>(boost::any_cast<double>(m["AverageWorkTime"]));
    }
    if (m.find("CallsAbandoned") != m.end() && !m["CallsAbandoned"].empty()) {
      callsAbandoned = make_shared<long>(boost::any_cast<long>(m["CallsAbandoned"]));
    }
    if (m.find("CallsAbandonedInIVR") != m.end() && !m["CallsAbandonedInIVR"].empty()) {
      callsAbandonedInIVR = make_shared<long>(boost::any_cast<long>(m["CallsAbandonedInIVR"]));
    }
    if (m.find("CallsAbandonedInQueue") != m.end() && !m["CallsAbandonedInQueue"].empty()) {
      callsAbandonedInQueue = make_shared<long>(boost::any_cast<long>(m["CallsAbandonedInQueue"]));
    }
    if (m.find("CallsAbandonedInRing") != m.end() && !m["CallsAbandonedInRing"].empty()) {
      callsAbandonedInRing = make_shared<long>(boost::any_cast<long>(m["CallsAbandonedInRing"]));
    }
    if (m.find("CallsAbandonedInVoiceNavigator") != m.end() && !m["CallsAbandonedInVoiceNavigator"].empty()) {
      callsAbandonedInVoiceNavigator = make_shared<long>(boost::any_cast<long>(m["CallsAbandonedInVoiceNavigator"]));
    }
    if (m.find("CallsAttendedTransferred") != m.end() && !m["CallsAttendedTransferred"].empty()) {
      callsAttendedTransferred = make_shared<long>(boost::any_cast<long>(m["CallsAttendedTransferred"]));
    }
    if (m.find("CallsBlindTransferred") != m.end() && !m["CallsBlindTransferred"].empty()) {
      callsBlindTransferred = make_shared<long>(boost::any_cast<long>(m["CallsBlindTransferred"]));
    }
    if (m.find("CallsForwardToOutsideNumber") != m.end() && !m["CallsForwardToOutsideNumber"].empty()) {
      callsForwardToOutsideNumber = make_shared<long>(boost::any_cast<long>(m["CallsForwardToOutsideNumber"]));
    }
    if (m.find("CallsHandled") != m.end() && !m["CallsHandled"].empty()) {
      callsHandled = make_shared<long>(boost::any_cast<long>(m["CallsHandled"]));
    }
    if (m.find("CallsHold") != m.end() && !m["CallsHold"].empty()) {
      callsHold = make_shared<long>(boost::any_cast<long>(m["CallsHold"]));
    }
    if (m.find("CallsIVRException") != m.end() && !m["CallsIVRException"].empty()) {
      callsIVRException = make_shared<long>(boost::any_cast<long>(m["CallsIVRException"]));
    }
    if (m.find("CallsOffered") != m.end() && !m["CallsOffered"].empty()) {
      callsOffered = make_shared<long>(boost::any_cast<long>(m["CallsOffered"]));
    }
    if (m.find("CallsQueued") != m.end() && !m["CallsQueued"].empty()) {
      callsQueued = make_shared<long>(boost::any_cast<long>(m["CallsQueued"]));
    }
    if (m.find("CallsQueuingFailed") != m.end() && !m["CallsQueuingFailed"].empty()) {
      callsQueuingFailed = make_shared<long>(boost::any_cast<long>(m["CallsQueuingFailed"]));
    }
    if (m.find("CallsQueuingOverflow") != m.end() && !m["CallsQueuingOverflow"].empty()) {
      callsQueuingOverflow = make_shared<long>(boost::any_cast<long>(m["CallsQueuingOverflow"]));
    }
    if (m.find("CallsQueuingTimeout") != m.end() && !m["CallsQueuingTimeout"].empty()) {
      callsQueuingTimeout = make_shared<long>(boost::any_cast<long>(m["CallsQueuingTimeout"]));
    }
    if (m.find("CallsRinged") != m.end() && !m["CallsRinged"].empty()) {
      callsRinged = make_shared<long>(boost::any_cast<long>(m["CallsRinged"]));
    }
    if (m.find("CallsVoicemail") != m.end() && !m["CallsVoicemail"].empty()) {
      callsVoicemail = make_shared<long>(boost::any_cast<long>(m["CallsVoicemail"]));
    }
    if (m.find("HandleRate") != m.end() && !m["HandleRate"].empty()) {
      handleRate = make_shared<double>(boost::any_cast<double>(m["HandleRate"]));
    }
    if (m.find("MaxAbandonTime") != m.end() && !m["MaxAbandonTime"].empty()) {
      maxAbandonTime = make_shared<long>(boost::any_cast<long>(m["MaxAbandonTime"]));
    }
    if (m.find("MaxAbandonedInIVRTime") != m.end() && !m["MaxAbandonedInIVRTime"].empty()) {
      maxAbandonedInIVRTime = make_shared<long>(boost::any_cast<long>(m["MaxAbandonedInIVRTime"]));
    }
    if (m.find("MaxAbandonedInQueueTime") != m.end() && !m["MaxAbandonedInQueueTime"].empty()) {
      maxAbandonedInQueueTime = make_shared<long>(boost::any_cast<long>(m["MaxAbandonedInQueueTime"]));
    }
    if (m.find("MaxAbandonedInRingTime") != m.end() && !m["MaxAbandonedInRingTime"].empty()) {
      maxAbandonedInRingTime = make_shared<long>(boost::any_cast<long>(m["MaxAbandonedInRingTime"]));
    }
    if (m.find("MaxHoldTime") != m.end() && !m["MaxHoldTime"].empty()) {
      maxHoldTime = make_shared<long>(boost::any_cast<long>(m["MaxHoldTime"]));
    }
    if (m.find("MaxRingTime") != m.end() && !m["MaxRingTime"].empty()) {
      maxRingTime = make_shared<long>(boost::any_cast<long>(m["MaxRingTime"]));
    }
    if (m.find("MaxTalkTime") != m.end() && !m["MaxTalkTime"].empty()) {
      maxTalkTime = make_shared<long>(boost::any_cast<long>(m["MaxTalkTime"]));
    }
    if (m.find("MaxWaitTime") != m.end() && !m["MaxWaitTime"].empty()) {
      maxWaitTime = make_shared<long>(boost::any_cast<long>(m["MaxWaitTime"]));
    }
    if (m.find("MaxWorkTime") != m.end() && !m["MaxWorkTime"].empty()) {
      maxWorkTime = make_shared<long>(boost::any_cast<long>(m["MaxWorkTime"]));
    }
    if (m.find("SatisfactionIndex") != m.end() && !m["SatisfactionIndex"].empty()) {
      satisfactionIndex = make_shared<double>(boost::any_cast<double>(m["SatisfactionIndex"]));
    }
    if (m.find("SatisfactionRate") != m.end() && !m["SatisfactionRate"].empty()) {
      satisfactionRate = make_shared<double>(boost::any_cast<double>(m["SatisfactionRate"]));
    }
    if (m.find("SatisfactionSurveysOffered") != m.end() && !m["SatisfactionSurveysOffered"].empty()) {
      satisfactionSurveysOffered = make_shared<long>(boost::any_cast<long>(m["SatisfactionSurveysOffered"]));
    }
    if (m.find("SatisfactionSurveysResponded") != m.end() && !m["SatisfactionSurveysResponded"].empty()) {
      satisfactionSurveysResponded = make_shared<long>(boost::any_cast<long>(m["SatisfactionSurveysResponded"]));
    }
    if (m.find("ServiceLevel20") != m.end() && !m["ServiceLevel20"].empty()) {
      serviceLevel20 = make_shared<double>(boost::any_cast<double>(m["ServiceLevel20"]));
    }
    if (m.find("TotalAbandonTime") != m.end() && !m["TotalAbandonTime"].empty()) {
      totalAbandonTime = make_shared<long>(boost::any_cast<long>(m["TotalAbandonTime"]));
    }
    if (m.find("TotalAbandonedInIVRTime") != m.end() && !m["TotalAbandonedInIVRTime"].empty()) {
      totalAbandonedInIVRTime = make_shared<long>(boost::any_cast<long>(m["TotalAbandonedInIVRTime"]));
    }
    if (m.find("TotalAbandonedInQueueTime") != m.end() && !m["TotalAbandonedInQueueTime"].empty()) {
      totalAbandonedInQueueTime = make_shared<long>(boost::any_cast<long>(m["TotalAbandonedInQueueTime"]));
    }
    if (m.find("TotalAbandonedInRingTime") != m.end() && !m["TotalAbandonedInRingTime"].empty()) {
      totalAbandonedInRingTime = make_shared<long>(boost::any_cast<long>(m["TotalAbandonedInRingTime"]));
    }
    if (m.find("TotalHoldTime") != m.end() && !m["TotalHoldTime"].empty()) {
      totalHoldTime = make_shared<long>(boost::any_cast<long>(m["TotalHoldTime"]));
    }
    if (m.find("TotalRingTime") != m.end() && !m["TotalRingTime"].empty()) {
      totalRingTime = make_shared<long>(boost::any_cast<long>(m["TotalRingTime"]));
    }
    if (m.find("TotalTalkTime") != m.end() && !m["TotalTalkTime"].empty()) {
      totalTalkTime = make_shared<long>(boost::any_cast<long>(m["TotalTalkTime"]));
    }
    if (m.find("TotalWaitTime") != m.end() && !m["TotalWaitTime"].empty()) {
      totalWaitTime = make_shared<long>(boost::any_cast<long>(m["TotalWaitTime"]));
    }
    if (m.find("TotalWorkTime") != m.end() && !m["TotalWorkTime"].empty()) {
      totalWorkTime = make_shared<long>(boost::any_cast<long>(m["TotalWorkTime"]));
    }
  }


  virtual ~ListIntervalInstanceReportResponseBodyDataInbound() = default;
};
class ListIntervalInstanceReportResponseBodyDataOutbound : public Darabonba::Model {
public:
  shared_ptr<double> answerRate{};
  shared_ptr<double> averageDialingTime{};
  shared_ptr<double> averageHoldTime{};
  shared_ptr<double> averageRingTime{};
  shared_ptr<double> averageTalkTime{};
  shared_ptr<double> averageWorkTime{};
  shared_ptr<long> callsAnswered{};
  shared_ptr<long> callsAttendedTransferred{};
  shared_ptr<long> callsBlindTransferred{};
  shared_ptr<long> callsDialed{};
  shared_ptr<long> callsHold{};
  shared_ptr<long> callsRinged{};
  shared_ptr<long> maxDialingTime{};
  shared_ptr<long> maxHoldTime{};
  shared_ptr<long> maxRingTime{};
  shared_ptr<long> maxTalkTime{};
  shared_ptr<long> maxWorkTime{};
  shared_ptr<double> satisfactionIndex{};
  shared_ptr<double> satisfactionRate{};
  shared_ptr<long> satisfactionSurveysOffered{};
  shared_ptr<long> satisfactionSurveysResponded{};
  shared_ptr<long> totalDialingTime{};
  shared_ptr<long> totalHoldTime{};
  shared_ptr<long> totalRingTime{};
  shared_ptr<long> totalTalkTime{};
  shared_ptr<long> totalWorkTime{};

  ListIntervalInstanceReportResponseBodyDataOutbound() {}

  explicit ListIntervalInstanceReportResponseBodyDataOutbound(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (answerRate) {
      res["AnswerRate"] = boost::any(*answerRate);
    }
    if (averageDialingTime) {
      res["AverageDialingTime"] = boost::any(*averageDialingTime);
    }
    if (averageHoldTime) {
      res["AverageHoldTime"] = boost::any(*averageHoldTime);
    }
    if (averageRingTime) {
      res["AverageRingTime"] = boost::any(*averageRingTime);
    }
    if (averageTalkTime) {
      res["AverageTalkTime"] = boost::any(*averageTalkTime);
    }
    if (averageWorkTime) {
      res["AverageWorkTime"] = boost::any(*averageWorkTime);
    }
    if (callsAnswered) {
      res["CallsAnswered"] = boost::any(*callsAnswered);
    }
    if (callsAttendedTransferred) {
      res["CallsAttendedTransferred"] = boost::any(*callsAttendedTransferred);
    }
    if (callsBlindTransferred) {
      res["CallsBlindTransferred"] = boost::any(*callsBlindTransferred);
    }
    if (callsDialed) {
      res["CallsDialed"] = boost::any(*callsDialed);
    }
    if (callsHold) {
      res["CallsHold"] = boost::any(*callsHold);
    }
    if (callsRinged) {
      res["CallsRinged"] = boost::any(*callsRinged);
    }
    if (maxDialingTime) {
      res["MaxDialingTime"] = boost::any(*maxDialingTime);
    }
    if (maxHoldTime) {
      res["MaxHoldTime"] = boost::any(*maxHoldTime);
    }
    if (maxRingTime) {
      res["MaxRingTime"] = boost::any(*maxRingTime);
    }
    if (maxTalkTime) {
      res["MaxTalkTime"] = boost::any(*maxTalkTime);
    }
    if (maxWorkTime) {
      res["MaxWorkTime"] = boost::any(*maxWorkTime);
    }
    if (satisfactionIndex) {
      res["SatisfactionIndex"] = boost::any(*satisfactionIndex);
    }
    if (satisfactionRate) {
      res["SatisfactionRate"] = boost::any(*satisfactionRate);
    }
    if (satisfactionSurveysOffered) {
      res["SatisfactionSurveysOffered"] = boost::any(*satisfactionSurveysOffered);
    }
    if (satisfactionSurveysResponded) {
      res["SatisfactionSurveysResponded"] = boost::any(*satisfactionSurveysResponded);
    }
    if (totalDialingTime) {
      res["TotalDialingTime"] = boost::any(*totalDialingTime);
    }
    if (totalHoldTime) {
      res["TotalHoldTime"] = boost::any(*totalHoldTime);
    }
    if (totalRingTime) {
      res["TotalRingTime"] = boost::any(*totalRingTime);
    }
    if (totalTalkTime) {
      res["TotalTalkTime"] = boost::any(*totalTalkTime);
    }
    if (totalWorkTime) {
      res["TotalWorkTime"] = boost::any(*totalWorkTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AnswerRate") != m.end() && !m["AnswerRate"].empty()) {
      answerRate = make_shared<double>(boost::any_cast<double>(m["AnswerRate"]));
    }
    if (m.find("AverageDialingTime") != m.end() && !m["AverageDialingTime"].empty()) {
      averageDialingTime = make_shared<double>(boost::any_cast<double>(m["AverageDialingTime"]));
    }
    if (m.find("AverageHoldTime") != m.end() && !m["AverageHoldTime"].empty()) {
      averageHoldTime = make_shared<double>(boost::any_cast<double>(m["AverageHoldTime"]));
    }
    if (m.find("AverageRingTime") != m.end() && !m["AverageRingTime"].empty()) {
      averageRingTime = make_shared<double>(boost::any_cast<double>(m["AverageRingTime"]));
    }
    if (m.find("AverageTalkTime") != m.end() && !m["AverageTalkTime"].empty()) {
      averageTalkTime = make_shared<double>(boost::any_cast<double>(m["AverageTalkTime"]));
    }
    if (m.find("AverageWorkTime") != m.end() && !m["AverageWorkTime"].empty()) {
      averageWorkTime = make_shared<double>(boost::any_cast<double>(m["AverageWorkTime"]));
    }
    if (m.find("CallsAnswered") != m.end() && !m["CallsAnswered"].empty()) {
      callsAnswered = make_shared<long>(boost::any_cast<long>(m["CallsAnswered"]));
    }
    if (m.find("CallsAttendedTransferred") != m.end() && !m["CallsAttendedTransferred"].empty()) {
      callsAttendedTransferred = make_shared<long>(boost::any_cast<long>(m["CallsAttendedTransferred"]));
    }
    if (m.find("CallsBlindTransferred") != m.end() && !m["CallsBlindTransferred"].empty()) {
      callsBlindTransferred = make_shared<long>(boost::any_cast<long>(m["CallsBlindTransferred"]));
    }
    if (m.find("CallsDialed") != m.end() && !m["CallsDialed"].empty()) {
      callsDialed = make_shared<long>(boost::any_cast<long>(m["CallsDialed"]));
    }
    if (m.find("CallsHold") != m.end() && !m["CallsHold"].empty()) {
      callsHold = make_shared<long>(boost::any_cast<long>(m["CallsHold"]));
    }
    if (m.find("CallsRinged") != m.end() && !m["CallsRinged"].empty()) {
      callsRinged = make_shared<long>(boost::any_cast<long>(m["CallsRinged"]));
    }
    if (m.find("MaxDialingTime") != m.end() && !m["MaxDialingTime"].empty()) {
      maxDialingTime = make_shared<long>(boost::any_cast<long>(m["MaxDialingTime"]));
    }
    if (m.find("MaxHoldTime") != m.end() && !m["MaxHoldTime"].empty()) {
      maxHoldTime = make_shared<long>(boost::any_cast<long>(m["MaxHoldTime"]));
    }
    if (m.find("MaxRingTime") != m.end() && !m["MaxRingTime"].empty()) {
      maxRingTime = make_shared<long>(boost::any_cast<long>(m["MaxRingTime"]));
    }
    if (m.find("MaxTalkTime") != m.end() && !m["MaxTalkTime"].empty()) {
      maxTalkTime = make_shared<long>(boost::any_cast<long>(m["MaxTalkTime"]));
    }
    if (m.find("MaxWorkTime") != m.end() && !m["MaxWorkTime"].empty()) {
      maxWorkTime = make_shared<long>(boost::any_cast<long>(m["MaxWorkTime"]));
    }
    if (m.find("SatisfactionIndex") != m.end() && !m["SatisfactionIndex"].empty()) {
      satisfactionIndex = make_shared<double>(boost::any_cast<double>(m["SatisfactionIndex"]));
    }
    if (m.find("SatisfactionRate") != m.end() && !m["SatisfactionRate"].empty()) {
      satisfactionRate = make_shared<double>(boost::any_cast<double>(m["SatisfactionRate"]));
    }
    if (m.find("SatisfactionSurveysOffered") != m.end() && !m["SatisfactionSurveysOffered"].empty()) {
      satisfactionSurveysOffered = make_shared<long>(boost::any_cast<long>(m["SatisfactionSurveysOffered"]));
    }
    if (m.find("SatisfactionSurveysResponded") != m.end() && !m["SatisfactionSurveysResponded"].empty()) {
      satisfactionSurveysResponded = make_shared<long>(boost::any_cast<long>(m["SatisfactionSurveysResponded"]));
    }
    if (m.find("TotalDialingTime") != m.end() && !m["TotalDialingTime"].empty()) {
      totalDialingTime = make_shared<long>(boost::any_cast<long>(m["TotalDialingTime"]));
    }
    if (m.find("TotalHoldTime") != m.end() && !m["TotalHoldTime"].empty()) {
      totalHoldTime = make_shared<long>(boost::any_cast<long>(m["TotalHoldTime"]));
    }
    if (m.find("TotalRingTime") != m.end() && !m["TotalRingTime"].empty()) {
      totalRingTime = make_shared<long>(boost::any_cast<long>(m["TotalRingTime"]));
    }
    if (m.find("TotalTalkTime") != m.end() && !m["TotalTalkTime"].empty()) {
      totalTalkTime = make_shared<long>(boost::any_cast<long>(m["TotalTalkTime"]));
    }
    if (m.find("TotalWorkTime") != m.end() && !m["TotalWorkTime"].empty()) {
      totalWorkTime = make_shared<long>(boost::any_cast<long>(m["TotalWorkTime"]));
    }
  }


  virtual ~ListIntervalInstanceReportResponseBodyDataOutbound() = default;
};
class ListIntervalInstanceReportResponseBodyDataOverall : public Darabonba::Model {
public:
  shared_ptr<double> averageBreakTime{};
  shared_ptr<double> averageHoldTime{};
  shared_ptr<double> averageReadyTime{};
  shared_ptr<double> averageTalkTime{};
  shared_ptr<double> averageWorkTime{};
  shared_ptr<long> maxBreakTime{};
  shared_ptr<long> maxHoldTime{};
  shared_ptr<long> maxReadyTime{};
  shared_ptr<long> maxTalkTime{};
  shared_ptr<long> maxWorkTime{};
  shared_ptr<double> occupancyRate{};
  shared_ptr<double> satisfactionIndex{};
  shared_ptr<double> satisfactionRate{};
  shared_ptr<long> satisfactionSurveysOffered{};
  shared_ptr<long> satisfactionSurveysResponded{};
  shared_ptr<long> totalBreakTime{};
  shared_ptr<long> totalCalls{};
  shared_ptr<long> totalHoldTime{};
  shared_ptr<long> totalLoggedInTime{};
  shared_ptr<long> totalReadyTime{};
  shared_ptr<long> totalTalkTime{};
  shared_ptr<long> totalWorkTime{};

  ListIntervalInstanceReportResponseBodyDataOverall() {}

  explicit ListIntervalInstanceReportResponseBodyDataOverall(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (averageBreakTime) {
      res["AverageBreakTime"] = boost::any(*averageBreakTime);
    }
    if (averageHoldTime) {
      res["AverageHoldTime"] = boost::any(*averageHoldTime);
    }
    if (averageReadyTime) {
      res["AverageReadyTime"] = boost::any(*averageReadyTime);
    }
    if (averageTalkTime) {
      res["AverageTalkTime"] = boost::any(*averageTalkTime);
    }
    if (averageWorkTime) {
      res["AverageWorkTime"] = boost::any(*averageWorkTime);
    }
    if (maxBreakTime) {
      res["MaxBreakTime"] = boost::any(*maxBreakTime);
    }
    if (maxHoldTime) {
      res["MaxHoldTime"] = boost::any(*maxHoldTime);
    }
    if (maxReadyTime) {
      res["MaxReadyTime"] = boost::any(*maxReadyTime);
    }
    if (maxTalkTime) {
      res["MaxTalkTime"] = boost::any(*maxTalkTime);
    }
    if (maxWorkTime) {
      res["MaxWorkTime"] = boost::any(*maxWorkTime);
    }
    if (occupancyRate) {
      res["OccupancyRate"] = boost::any(*occupancyRate);
    }
    if (satisfactionIndex) {
      res["SatisfactionIndex"] = boost::any(*satisfactionIndex);
    }
    if (satisfactionRate) {
      res["SatisfactionRate"] = boost::any(*satisfactionRate);
    }
    if (satisfactionSurveysOffered) {
      res["SatisfactionSurveysOffered"] = boost::any(*satisfactionSurveysOffered);
    }
    if (satisfactionSurveysResponded) {
      res["SatisfactionSurveysResponded"] = boost::any(*satisfactionSurveysResponded);
    }
    if (totalBreakTime) {
      res["TotalBreakTime"] = boost::any(*totalBreakTime);
    }
    if (totalCalls) {
      res["TotalCalls"] = boost::any(*totalCalls);
    }
    if (totalHoldTime) {
      res["TotalHoldTime"] = boost::any(*totalHoldTime);
    }
    if (totalLoggedInTime) {
      res["TotalLoggedInTime"] = boost::any(*totalLoggedInTime);
    }
    if (totalReadyTime) {
      res["TotalReadyTime"] = boost::any(*totalReadyTime);
    }
    if (totalTalkTime) {
      res["TotalTalkTime"] = boost::any(*totalTalkTime);
    }
    if (totalWorkTime) {
      res["TotalWorkTime"] = boost::any(*totalWorkTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AverageBreakTime") != m.end() && !m["AverageBreakTime"].empty()) {
      averageBreakTime = make_shared<double>(boost::any_cast<double>(m["AverageBreakTime"]));
    }
    if (m.find("AverageHoldTime") != m.end() && !m["AverageHoldTime"].empty()) {
      averageHoldTime = make_shared<double>(boost::any_cast<double>(m["AverageHoldTime"]));
    }
    if (m.find("AverageReadyTime") != m.end() && !m["AverageReadyTime"].empty()) {
      averageReadyTime = make_shared<double>(boost::any_cast<double>(m["AverageReadyTime"]));
    }
    if (m.find("AverageTalkTime") != m.end() && !m["AverageTalkTime"].empty()) {
      averageTalkTime = make_shared<double>(boost::any_cast<double>(m["AverageTalkTime"]));
    }
    if (m.find("AverageWorkTime") != m.end() && !m["AverageWorkTime"].empty()) {
      averageWorkTime = make_shared<double>(boost::any_cast<double>(m["AverageWorkTime"]));
    }
    if (m.find("MaxBreakTime") != m.end() && !m["MaxBreakTime"].empty()) {
      maxBreakTime = make_shared<long>(boost::any_cast<long>(m["MaxBreakTime"]));
    }
    if (m.find("MaxHoldTime") != m.end() && !m["MaxHoldTime"].empty()) {
      maxHoldTime = make_shared<long>(boost::any_cast<long>(m["MaxHoldTime"]));
    }
    if (m.find("MaxReadyTime") != m.end() && !m["MaxReadyTime"].empty()) {
      maxReadyTime = make_shared<long>(boost::any_cast<long>(m["MaxReadyTime"]));
    }
    if (m.find("MaxTalkTime") != m.end() && !m["MaxTalkTime"].empty()) {
      maxTalkTime = make_shared<long>(boost::any_cast<long>(m["MaxTalkTime"]));
    }
    if (m.find("MaxWorkTime") != m.end() && !m["MaxWorkTime"].empty()) {
      maxWorkTime = make_shared<long>(boost::any_cast<long>(m["MaxWorkTime"]));
    }
    if (m.find("OccupancyRate") != m.end() && !m["OccupancyRate"].empty()) {
      occupancyRate = make_shared<double>(boost::any_cast<double>(m["OccupancyRate"]));
    }
    if (m.find("SatisfactionIndex") != m.end() && !m["SatisfactionIndex"].empty()) {
      satisfactionIndex = make_shared<double>(boost::any_cast<double>(m["SatisfactionIndex"]));
    }
    if (m.find("SatisfactionRate") != m.end() && !m["SatisfactionRate"].empty()) {
      satisfactionRate = make_shared<double>(boost::any_cast<double>(m["SatisfactionRate"]));
    }
    if (m.find("SatisfactionSurveysOffered") != m.end() && !m["SatisfactionSurveysOffered"].empty()) {
      satisfactionSurveysOffered = make_shared<long>(boost::any_cast<long>(m["SatisfactionSurveysOffered"]));
    }
    if (m.find("SatisfactionSurveysResponded") != m.end() && !m["SatisfactionSurveysResponded"].empty()) {
      satisfactionSurveysResponded = make_shared<long>(boost::any_cast<long>(m["SatisfactionSurveysResponded"]));
    }
    if (m.find("TotalBreakTime") != m.end() && !m["TotalBreakTime"].empty()) {
      totalBreakTime = make_shared<long>(boost::any_cast<long>(m["TotalBreakTime"]));
    }
    if (m.find("TotalCalls") != m.end() && !m["TotalCalls"].empty()) {
      totalCalls = make_shared<long>(boost::any_cast<long>(m["TotalCalls"]));
    }
    if (m.find("TotalHoldTime") != m.end() && !m["TotalHoldTime"].empty()) {
      totalHoldTime = make_shared<long>(boost::any_cast<long>(m["TotalHoldTime"]));
    }
    if (m.find("TotalLoggedInTime") != m.end() && !m["TotalLoggedInTime"].empty()) {
      totalLoggedInTime = make_shared<long>(boost::any_cast<long>(m["TotalLoggedInTime"]));
    }
    if (m.find("TotalReadyTime") != m.end() && !m["TotalReadyTime"].empty()) {
      totalReadyTime = make_shared<long>(boost::any_cast<long>(m["TotalReadyTime"]));
    }
    if (m.find("TotalTalkTime") != m.end() && !m["TotalTalkTime"].empty()) {
      totalTalkTime = make_shared<long>(boost::any_cast<long>(m["TotalTalkTime"]));
    }
    if (m.find("TotalWorkTime") != m.end() && !m["TotalWorkTime"].empty()) {
      totalWorkTime = make_shared<long>(boost::any_cast<long>(m["TotalWorkTime"]));
    }
  }


  virtual ~ListIntervalInstanceReportResponseBodyDataOverall() = default;
};
class ListIntervalInstanceReportResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<ListIntervalInstanceReportResponseBodyDataInbound> inbound{};
  shared_ptr<ListIntervalInstanceReportResponseBodyDataOutbound> outbound{};
  shared_ptr<ListIntervalInstanceReportResponseBodyDataOverall> overall{};
  shared_ptr<long> statsTime{};

  ListIntervalInstanceReportResponseBodyData() {}

  explicit ListIntervalInstanceReportResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (inbound) {
      res["Inbound"] = inbound ? boost::any(inbound->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (outbound) {
      res["Outbound"] = outbound ? boost::any(outbound->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (overall) {
      res["Overall"] = overall ? boost::any(overall->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (statsTime) {
      res["StatsTime"] = boost::any(*statsTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Inbound") != m.end() && !m["Inbound"].empty()) {
      if (typeid(map<string, boost::any>) == m["Inbound"].type()) {
        ListIntervalInstanceReportResponseBodyDataInbound model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Inbound"]));
        inbound = make_shared<ListIntervalInstanceReportResponseBodyDataInbound>(model1);
      }
    }
    if (m.find("Outbound") != m.end() && !m["Outbound"].empty()) {
      if (typeid(map<string, boost::any>) == m["Outbound"].type()) {
        ListIntervalInstanceReportResponseBodyDataOutbound model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Outbound"]));
        outbound = make_shared<ListIntervalInstanceReportResponseBodyDataOutbound>(model1);
      }
    }
    if (m.find("Overall") != m.end() && !m["Overall"].empty()) {
      if (typeid(map<string, boost::any>) == m["Overall"].type()) {
        ListIntervalInstanceReportResponseBodyDataOverall model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Overall"]));
        overall = make_shared<ListIntervalInstanceReportResponseBodyDataOverall>(model1);
      }
    }
    if (m.find("StatsTime") != m.end() && !m["StatsTime"].empty()) {
      statsTime = make_shared<long>(boost::any_cast<long>(m["StatsTime"]));
    }
  }


  virtual ~ListIntervalInstanceReportResponseBodyData() = default;
};
class ListIntervalInstanceReportResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<vector<ListIntervalInstanceReportResponseBodyData>> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  ListIntervalInstanceReportResponseBody() {}

  explicit ListIntervalInstanceReportResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<ListIntervalInstanceReportResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListIntervalInstanceReportResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<ListIntervalInstanceReportResponseBodyData>>(expect1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListIntervalInstanceReportResponseBody() = default;
};
class ListIntervalInstanceReportResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListIntervalInstanceReportResponseBody> body{};

  ListIntervalInstanceReportResponse() {}

  explicit ListIntervalInstanceReportResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListIntervalInstanceReportResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListIntervalInstanceReportResponseBody>(model1);
      }
    }
  }


  virtual ~ListIntervalInstanceReportResponse() = default;
};
class ListIntervalSkillGroupReportRequest : public Darabonba::Model {
public:
  shared_ptr<long> endTime{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> interval{};
  shared_ptr<string> skillGroupId{};
  shared_ptr<long> startTime{};

  ListIntervalSkillGroupReportRequest() {}

  explicit ListIntervalSkillGroupReportRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    if (skillGroupId) {
      res["SkillGroupId"] = boost::any(*skillGroupId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<string>(boost::any_cast<string>(m["Interval"]));
    }
    if (m.find("SkillGroupId") != m.end() && !m["SkillGroupId"].empty()) {
      skillGroupId = make_shared<string>(boost::any_cast<string>(m["SkillGroupId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
  }


  virtual ~ListIntervalSkillGroupReportRequest() = default;
};
class ListIntervalSkillGroupReportResponseBodyDataInbound : public Darabonba::Model {
public:
  shared_ptr<double> abandonRate{};
  shared_ptr<double> averageAbandonTime{};
  shared_ptr<double> averageAbandonedInQueueTime{};
  shared_ptr<double> averageAbandonedInRingTime{};
  shared_ptr<double> averageHoldTime{};
  shared_ptr<double> averageRingTime{};
  shared_ptr<double> averageTalkTime{};
  shared_ptr<double> averageWaitTime{};
  shared_ptr<double> averageWorkTime{};
  shared_ptr<long> callsAbandoned{};
  shared_ptr<long> callsAbandonedInQueue{};
  shared_ptr<long> callsAbandonedInRing{};
  shared_ptr<long> callsAttendedTransferIn{};
  shared_ptr<long> callsAttendedTransferOut{};
  shared_ptr<long> callsBlindTransferIn{};
  shared_ptr<long> callsBlindTransferOut{};
  shared_ptr<long> callsHandled{};
  shared_ptr<long> callsHold{};
  shared_ptr<long> callsOffered{};
  shared_ptr<long> callsOverflow{};
  shared_ptr<long> callsQueued{};
  shared_ptr<long> callsRinged{};
  shared_ptr<long> callsTimeout{};
  shared_ptr<double> handleRate{};
  shared_ptr<long> maxAbandonTime{};
  shared_ptr<long> maxAbandonedInQueueTime{};
  shared_ptr<long> maxAbandonedInRingTime{};
  shared_ptr<long> maxHoldTime{};
  shared_ptr<long> maxRingTime{};
  shared_ptr<long> maxTalkTime{};
  shared_ptr<long> maxWaitTime{};
  shared_ptr<long> maxWorkTime{};
  shared_ptr<double> satisfactionIndex{};
  shared_ptr<double> satisfactionRate{};
  shared_ptr<long> satisfactionSurveysOffered{};
  shared_ptr<long> satisfactionSurveysResponded{};
  shared_ptr<double> serviceLevel20{};
  shared_ptr<long> totalAbandonTime{};
  shared_ptr<long> totalAbandonedInQueueTime{};
  shared_ptr<long> totalAbandonedInRingTime{};
  shared_ptr<long> totalHoldTime{};
  shared_ptr<long> totalRingTime{};
  shared_ptr<long> totalTalkTime{};
  shared_ptr<long> totalWaitTime{};
  shared_ptr<long> totalWorkTime{};

  ListIntervalSkillGroupReportResponseBodyDataInbound() {}

  explicit ListIntervalSkillGroupReportResponseBodyDataInbound(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (abandonRate) {
      res["AbandonRate"] = boost::any(*abandonRate);
    }
    if (averageAbandonTime) {
      res["AverageAbandonTime"] = boost::any(*averageAbandonTime);
    }
    if (averageAbandonedInQueueTime) {
      res["AverageAbandonedInQueueTime"] = boost::any(*averageAbandonedInQueueTime);
    }
    if (averageAbandonedInRingTime) {
      res["AverageAbandonedInRingTime"] = boost::any(*averageAbandonedInRingTime);
    }
    if (averageHoldTime) {
      res["AverageHoldTime"] = boost::any(*averageHoldTime);
    }
    if (averageRingTime) {
      res["AverageRingTime"] = boost::any(*averageRingTime);
    }
    if (averageTalkTime) {
      res["AverageTalkTime"] = boost::any(*averageTalkTime);
    }
    if (averageWaitTime) {
      res["AverageWaitTime"] = boost::any(*averageWaitTime);
    }
    if (averageWorkTime) {
      res["AverageWorkTime"] = boost::any(*averageWorkTime);
    }
    if (callsAbandoned) {
      res["CallsAbandoned"] = boost::any(*callsAbandoned);
    }
    if (callsAbandonedInQueue) {
      res["CallsAbandonedInQueue"] = boost::any(*callsAbandonedInQueue);
    }
    if (callsAbandonedInRing) {
      res["CallsAbandonedInRing"] = boost::any(*callsAbandonedInRing);
    }
    if (callsAttendedTransferIn) {
      res["CallsAttendedTransferIn"] = boost::any(*callsAttendedTransferIn);
    }
    if (callsAttendedTransferOut) {
      res["CallsAttendedTransferOut"] = boost::any(*callsAttendedTransferOut);
    }
    if (callsBlindTransferIn) {
      res["CallsBlindTransferIn"] = boost::any(*callsBlindTransferIn);
    }
    if (callsBlindTransferOut) {
      res["CallsBlindTransferOut"] = boost::any(*callsBlindTransferOut);
    }
    if (callsHandled) {
      res["CallsHandled"] = boost::any(*callsHandled);
    }
    if (callsHold) {
      res["CallsHold"] = boost::any(*callsHold);
    }
    if (callsOffered) {
      res["CallsOffered"] = boost::any(*callsOffered);
    }
    if (callsOverflow) {
      res["CallsOverflow"] = boost::any(*callsOverflow);
    }
    if (callsQueued) {
      res["CallsQueued"] = boost::any(*callsQueued);
    }
    if (callsRinged) {
      res["CallsRinged"] = boost::any(*callsRinged);
    }
    if (callsTimeout) {
      res["CallsTimeout"] = boost::any(*callsTimeout);
    }
    if (handleRate) {
      res["HandleRate"] = boost::any(*handleRate);
    }
    if (maxAbandonTime) {
      res["MaxAbandonTime"] = boost::any(*maxAbandonTime);
    }
    if (maxAbandonedInQueueTime) {
      res["MaxAbandonedInQueueTime"] = boost::any(*maxAbandonedInQueueTime);
    }
    if (maxAbandonedInRingTime) {
      res["MaxAbandonedInRingTime"] = boost::any(*maxAbandonedInRingTime);
    }
    if (maxHoldTime) {
      res["MaxHoldTime"] = boost::any(*maxHoldTime);
    }
    if (maxRingTime) {
      res["MaxRingTime"] = boost::any(*maxRingTime);
    }
    if (maxTalkTime) {
      res["MaxTalkTime"] = boost::any(*maxTalkTime);
    }
    if (maxWaitTime) {
      res["MaxWaitTime"] = boost::any(*maxWaitTime);
    }
    if (maxWorkTime) {
      res["MaxWorkTime"] = boost::any(*maxWorkTime);
    }
    if (satisfactionIndex) {
      res["SatisfactionIndex"] = boost::any(*satisfactionIndex);
    }
    if (satisfactionRate) {
      res["SatisfactionRate"] = boost::any(*satisfactionRate);
    }
    if (satisfactionSurveysOffered) {
      res["SatisfactionSurveysOffered"] = boost::any(*satisfactionSurveysOffered);
    }
    if (satisfactionSurveysResponded) {
      res["SatisfactionSurveysResponded"] = boost::any(*satisfactionSurveysResponded);
    }
    if (serviceLevel20) {
      res["ServiceLevel20"] = boost::any(*serviceLevel20);
    }
    if (totalAbandonTime) {
      res["TotalAbandonTime"] = boost::any(*totalAbandonTime);
    }
    if (totalAbandonedInQueueTime) {
      res["TotalAbandonedInQueueTime"] = boost::any(*totalAbandonedInQueueTime);
    }
    if (totalAbandonedInRingTime) {
      res["TotalAbandonedInRingTime"] = boost::any(*totalAbandonedInRingTime);
    }
    if (totalHoldTime) {
      res["TotalHoldTime"] = boost::any(*totalHoldTime);
    }
    if (totalRingTime) {
      res["TotalRingTime"] = boost::any(*totalRingTime);
    }
    if (totalTalkTime) {
      res["TotalTalkTime"] = boost::any(*totalTalkTime);
    }
    if (totalWaitTime) {
      res["TotalWaitTime"] = boost::any(*totalWaitTime);
    }
    if (totalWorkTime) {
      res["TotalWorkTime"] = boost::any(*totalWorkTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AbandonRate") != m.end() && !m["AbandonRate"].empty()) {
      abandonRate = make_shared<double>(boost::any_cast<double>(m["AbandonRate"]));
    }
    if (m.find("AverageAbandonTime") != m.end() && !m["AverageAbandonTime"].empty()) {
      averageAbandonTime = make_shared<double>(boost::any_cast<double>(m["AverageAbandonTime"]));
    }
    if (m.find("AverageAbandonedInQueueTime") != m.end() && !m["AverageAbandonedInQueueTime"].empty()) {
      averageAbandonedInQueueTime = make_shared<double>(boost::any_cast<double>(m["AverageAbandonedInQueueTime"]));
    }
    if (m.find("AverageAbandonedInRingTime") != m.end() && !m["AverageAbandonedInRingTime"].empty()) {
      averageAbandonedInRingTime = make_shared<double>(boost::any_cast<double>(m["AverageAbandonedInRingTime"]));
    }
    if (m.find("AverageHoldTime") != m.end() && !m["AverageHoldTime"].empty()) {
      averageHoldTime = make_shared<double>(boost::any_cast<double>(m["AverageHoldTime"]));
    }
    if (m.find("AverageRingTime") != m.end() && !m["AverageRingTime"].empty()) {
      averageRingTime = make_shared<double>(boost::any_cast<double>(m["AverageRingTime"]));
    }
    if (m.find("AverageTalkTime") != m.end() && !m["AverageTalkTime"].empty()) {
      averageTalkTime = make_shared<double>(boost::any_cast<double>(m["AverageTalkTime"]));
    }
    if (m.find("AverageWaitTime") != m.end() && !m["AverageWaitTime"].empty()) {
      averageWaitTime = make_shared<double>(boost::any_cast<double>(m["AverageWaitTime"]));
    }
    if (m.find("AverageWorkTime") != m.end() && !m["AverageWorkTime"].empty()) {
      averageWorkTime = make_shared<double>(boost::any_cast<double>(m["AverageWorkTime"]));
    }
    if (m.find("CallsAbandoned") != m.end() && !m["CallsAbandoned"].empty()) {
      callsAbandoned = make_shared<long>(boost::any_cast<long>(m["CallsAbandoned"]));
    }
    if (m.find("CallsAbandonedInQueue") != m.end() && !m["CallsAbandonedInQueue"].empty()) {
      callsAbandonedInQueue = make_shared<long>(boost::any_cast<long>(m["CallsAbandonedInQueue"]));
    }
    if (m.find("CallsAbandonedInRing") != m.end() && !m["CallsAbandonedInRing"].empty()) {
      callsAbandonedInRing = make_shared<long>(boost::any_cast<long>(m["CallsAbandonedInRing"]));
    }
    if (m.find("CallsAttendedTransferIn") != m.end() && !m["CallsAttendedTransferIn"].empty()) {
      callsAttendedTransferIn = make_shared<long>(boost::any_cast<long>(m["CallsAttendedTransferIn"]));
    }
    if (m.find("CallsAttendedTransferOut") != m.end() && !m["CallsAttendedTransferOut"].empty()) {
      callsAttendedTransferOut = make_shared<long>(boost::any_cast<long>(m["CallsAttendedTransferOut"]));
    }
    if (m.find("CallsBlindTransferIn") != m.end() && !m["CallsBlindTransferIn"].empty()) {
      callsBlindTransferIn = make_shared<long>(boost::any_cast<long>(m["CallsBlindTransferIn"]));
    }
    if (m.find("CallsBlindTransferOut") != m.end() && !m["CallsBlindTransferOut"].empty()) {
      callsBlindTransferOut = make_shared<long>(boost::any_cast<long>(m["CallsBlindTransferOut"]));
    }
    if (m.find("CallsHandled") != m.end() && !m["CallsHandled"].empty()) {
      callsHandled = make_shared<long>(boost::any_cast<long>(m["CallsHandled"]));
    }
    if (m.find("CallsHold") != m.end() && !m["CallsHold"].empty()) {
      callsHold = make_shared<long>(boost::any_cast<long>(m["CallsHold"]));
    }
    if (m.find("CallsOffered") != m.end() && !m["CallsOffered"].empty()) {
      callsOffered = make_shared<long>(boost::any_cast<long>(m["CallsOffered"]));
    }
    if (m.find("CallsOverflow") != m.end() && !m["CallsOverflow"].empty()) {
      callsOverflow = make_shared<long>(boost::any_cast<long>(m["CallsOverflow"]));
    }
    if (m.find("CallsQueued") != m.end() && !m["CallsQueued"].empty()) {
      callsQueued = make_shared<long>(boost::any_cast<long>(m["CallsQueued"]));
    }
    if (m.find("CallsRinged") != m.end() && !m["CallsRinged"].empty()) {
      callsRinged = make_shared<long>(boost::any_cast<long>(m["CallsRinged"]));
    }
    if (m.find("CallsTimeout") != m.end() && !m["CallsTimeout"].empty()) {
      callsTimeout = make_shared<long>(boost::any_cast<long>(m["CallsTimeout"]));
    }
    if (m.find("HandleRate") != m.end() && !m["HandleRate"].empty()) {
      handleRate = make_shared<double>(boost::any_cast<double>(m["HandleRate"]));
    }
    if (m.find("MaxAbandonTime") != m.end() && !m["MaxAbandonTime"].empty()) {
      maxAbandonTime = make_shared<long>(boost::any_cast<long>(m["MaxAbandonTime"]));
    }
    if (m.find("MaxAbandonedInQueueTime") != m.end() && !m["MaxAbandonedInQueueTime"].empty()) {
      maxAbandonedInQueueTime = make_shared<long>(boost::any_cast<long>(m["MaxAbandonedInQueueTime"]));
    }
    if (m.find("MaxAbandonedInRingTime") != m.end() && !m["MaxAbandonedInRingTime"].empty()) {
      maxAbandonedInRingTime = make_shared<long>(boost::any_cast<long>(m["MaxAbandonedInRingTime"]));
    }
    if (m.find("MaxHoldTime") != m.end() && !m["MaxHoldTime"].empty()) {
      maxHoldTime = make_shared<long>(boost::any_cast<long>(m["MaxHoldTime"]));
    }
    if (m.find("MaxRingTime") != m.end() && !m["MaxRingTime"].empty()) {
      maxRingTime = make_shared<long>(boost::any_cast<long>(m["MaxRingTime"]));
    }
    if (m.find("MaxTalkTime") != m.end() && !m["MaxTalkTime"].empty()) {
      maxTalkTime = make_shared<long>(boost::any_cast<long>(m["MaxTalkTime"]));
    }
    if (m.find("MaxWaitTime") != m.end() && !m["MaxWaitTime"].empty()) {
      maxWaitTime = make_shared<long>(boost::any_cast<long>(m["MaxWaitTime"]));
    }
    if (m.find("MaxWorkTime") != m.end() && !m["MaxWorkTime"].empty()) {
      maxWorkTime = make_shared<long>(boost::any_cast<long>(m["MaxWorkTime"]));
    }
    if (m.find("SatisfactionIndex") != m.end() && !m["SatisfactionIndex"].empty()) {
      satisfactionIndex = make_shared<double>(boost::any_cast<double>(m["SatisfactionIndex"]));
    }
    if (m.find("SatisfactionRate") != m.end() && !m["SatisfactionRate"].empty()) {
      satisfactionRate = make_shared<double>(boost::any_cast<double>(m["SatisfactionRate"]));
    }
    if (m.find("SatisfactionSurveysOffered") != m.end() && !m["SatisfactionSurveysOffered"].empty()) {
      satisfactionSurveysOffered = make_shared<long>(boost::any_cast<long>(m["SatisfactionSurveysOffered"]));
    }
    if (m.find("SatisfactionSurveysResponded") != m.end() && !m["SatisfactionSurveysResponded"].empty()) {
      satisfactionSurveysResponded = make_shared<long>(boost::any_cast<long>(m["SatisfactionSurveysResponded"]));
    }
    if (m.find("ServiceLevel20") != m.end() && !m["ServiceLevel20"].empty()) {
      serviceLevel20 = make_shared<double>(boost::any_cast<double>(m["ServiceLevel20"]));
    }
    if (m.find("TotalAbandonTime") != m.end() && !m["TotalAbandonTime"].empty()) {
      totalAbandonTime = make_shared<long>(boost::any_cast<long>(m["TotalAbandonTime"]));
    }
    if (m.find("TotalAbandonedInQueueTime") != m.end() && !m["TotalAbandonedInQueueTime"].empty()) {
      totalAbandonedInQueueTime = make_shared<long>(boost::any_cast<long>(m["TotalAbandonedInQueueTime"]));
    }
    if (m.find("TotalAbandonedInRingTime") != m.end() && !m["TotalAbandonedInRingTime"].empty()) {
      totalAbandonedInRingTime = make_shared<long>(boost::any_cast<long>(m["TotalAbandonedInRingTime"]));
    }
    if (m.find("TotalHoldTime") != m.end() && !m["TotalHoldTime"].empty()) {
      totalHoldTime = make_shared<long>(boost::any_cast<long>(m["TotalHoldTime"]));
    }
    if (m.find("TotalRingTime") != m.end() && !m["TotalRingTime"].empty()) {
      totalRingTime = make_shared<long>(boost::any_cast<long>(m["TotalRingTime"]));
    }
    if (m.find("TotalTalkTime") != m.end() && !m["TotalTalkTime"].empty()) {
      totalTalkTime = make_shared<long>(boost::any_cast<long>(m["TotalTalkTime"]));
    }
    if (m.find("TotalWaitTime") != m.end() && !m["TotalWaitTime"].empty()) {
      totalWaitTime = make_shared<long>(boost::any_cast<long>(m["TotalWaitTime"]));
    }
    if (m.find("TotalWorkTime") != m.end() && !m["TotalWorkTime"].empty()) {
      totalWorkTime = make_shared<long>(boost::any_cast<long>(m["TotalWorkTime"]));
    }
  }


  virtual ~ListIntervalSkillGroupReportResponseBodyDataInbound() = default;
};
class ListIntervalSkillGroupReportResponseBodyDataOutbound : public Darabonba::Model {
public:
  shared_ptr<double> answerRate{};
  shared_ptr<double> averageDialingTime{};
  shared_ptr<double> averageHoldTime{};
  shared_ptr<double> averageRingTime{};
  shared_ptr<double> averageTalkTime{};
  shared_ptr<double> averageWorkTime{};
  shared_ptr<long> callsAnswered{};
  shared_ptr<long> callsAttendedTransferIn{};
  shared_ptr<long> callsAttendedTransferOut{};
  shared_ptr<long> callsBlindTransferIn{};
  shared_ptr<long> callsBlindTransferOut{};
  shared_ptr<long> callsDialed{};
  shared_ptr<long> callsHold{};
  shared_ptr<long> callsRinged{};
  shared_ptr<long> maxDialingTime{};
  shared_ptr<long> maxHoldTime{};
  shared_ptr<long> maxRingTime{};
  shared_ptr<long> maxTalkTime{};
  shared_ptr<long> maxWorkTime{};
  shared_ptr<double> satisfactionIndex{};
  shared_ptr<double> satisfactionRate{};
  shared_ptr<long> satisfactionSurveysOffered{};
  shared_ptr<long> satisfactionSurveysResponded{};
  shared_ptr<long> totalDialingTime{};
  shared_ptr<long> totalHoldTime{};
  shared_ptr<long> totalRingTime{};
  shared_ptr<long> totalTalkTime{};
  shared_ptr<long> totalWorkTime{};

  ListIntervalSkillGroupReportResponseBodyDataOutbound() {}

  explicit ListIntervalSkillGroupReportResponseBodyDataOutbound(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (answerRate) {
      res["AnswerRate"] = boost::any(*answerRate);
    }
    if (averageDialingTime) {
      res["AverageDialingTime"] = boost::any(*averageDialingTime);
    }
    if (averageHoldTime) {
      res["AverageHoldTime"] = boost::any(*averageHoldTime);
    }
    if (averageRingTime) {
      res["AverageRingTime"] = boost::any(*averageRingTime);
    }
    if (averageTalkTime) {
      res["AverageTalkTime"] = boost::any(*averageTalkTime);
    }
    if (averageWorkTime) {
      res["AverageWorkTime"] = boost::any(*averageWorkTime);
    }
    if (callsAnswered) {
      res["CallsAnswered"] = boost::any(*callsAnswered);
    }
    if (callsAttendedTransferIn) {
      res["CallsAttendedTransferIn"] = boost::any(*callsAttendedTransferIn);
    }
    if (callsAttendedTransferOut) {
      res["CallsAttendedTransferOut"] = boost::any(*callsAttendedTransferOut);
    }
    if (callsBlindTransferIn) {
      res["CallsBlindTransferIn"] = boost::any(*callsBlindTransferIn);
    }
    if (callsBlindTransferOut) {
      res["CallsBlindTransferOut"] = boost::any(*callsBlindTransferOut);
    }
    if (callsDialed) {
      res["CallsDialed"] = boost::any(*callsDialed);
    }
    if (callsHold) {
      res["CallsHold"] = boost::any(*callsHold);
    }
    if (callsRinged) {
      res["CallsRinged"] = boost::any(*callsRinged);
    }
    if (maxDialingTime) {
      res["MaxDialingTime"] = boost::any(*maxDialingTime);
    }
    if (maxHoldTime) {
      res["MaxHoldTime"] = boost::any(*maxHoldTime);
    }
    if (maxRingTime) {
      res["MaxRingTime"] = boost::any(*maxRingTime);
    }
    if (maxTalkTime) {
      res["MaxTalkTime"] = boost::any(*maxTalkTime);
    }
    if (maxWorkTime) {
      res["MaxWorkTime"] = boost::any(*maxWorkTime);
    }
    if (satisfactionIndex) {
      res["SatisfactionIndex"] = boost::any(*satisfactionIndex);
    }
    if (satisfactionRate) {
      res["SatisfactionRate"] = boost::any(*satisfactionRate);
    }
    if (satisfactionSurveysOffered) {
      res["SatisfactionSurveysOffered"] = boost::any(*satisfactionSurveysOffered);
    }
    if (satisfactionSurveysResponded) {
      res["SatisfactionSurveysResponded"] = boost::any(*satisfactionSurveysResponded);
    }
    if (totalDialingTime) {
      res["TotalDialingTime"] = boost::any(*totalDialingTime);
    }
    if (totalHoldTime) {
      res["TotalHoldTime"] = boost::any(*totalHoldTime);
    }
    if (totalRingTime) {
      res["TotalRingTime"] = boost::any(*totalRingTime);
    }
    if (totalTalkTime) {
      res["TotalTalkTime"] = boost::any(*totalTalkTime);
    }
    if (totalWorkTime) {
      res["TotalWorkTime"] = boost::any(*totalWorkTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AnswerRate") != m.end() && !m["AnswerRate"].empty()) {
      answerRate = make_shared<double>(boost::any_cast<double>(m["AnswerRate"]));
    }
    if (m.find("AverageDialingTime") != m.end() && !m["AverageDialingTime"].empty()) {
      averageDialingTime = make_shared<double>(boost::any_cast<double>(m["AverageDialingTime"]));
    }
    if (m.find("AverageHoldTime") != m.end() && !m["AverageHoldTime"].empty()) {
      averageHoldTime = make_shared<double>(boost::any_cast<double>(m["AverageHoldTime"]));
    }
    if (m.find("AverageRingTime") != m.end() && !m["AverageRingTime"].empty()) {
      averageRingTime = make_shared<double>(boost::any_cast<double>(m["AverageRingTime"]));
    }
    if (m.find("AverageTalkTime") != m.end() && !m["AverageTalkTime"].empty()) {
      averageTalkTime = make_shared<double>(boost::any_cast<double>(m["AverageTalkTime"]));
    }
    if (m.find("AverageWorkTime") != m.end() && !m["AverageWorkTime"].empty()) {
      averageWorkTime = make_shared<double>(boost::any_cast<double>(m["AverageWorkTime"]));
    }
    if (m.find("CallsAnswered") != m.end() && !m["CallsAnswered"].empty()) {
      callsAnswered = make_shared<long>(boost::any_cast<long>(m["CallsAnswered"]));
    }
    if (m.find("CallsAttendedTransferIn") != m.end() && !m["CallsAttendedTransferIn"].empty()) {
      callsAttendedTransferIn = make_shared<long>(boost::any_cast<long>(m["CallsAttendedTransferIn"]));
    }
    if (m.find("CallsAttendedTransferOut") != m.end() && !m["CallsAttendedTransferOut"].empty()) {
      callsAttendedTransferOut = make_shared<long>(boost::any_cast<long>(m["CallsAttendedTransferOut"]));
    }
    if (m.find("CallsBlindTransferIn") != m.end() && !m["CallsBlindTransferIn"].empty()) {
      callsBlindTransferIn = make_shared<long>(boost::any_cast<long>(m["CallsBlindTransferIn"]));
    }
    if (m.find("CallsBlindTransferOut") != m.end() && !m["CallsBlindTransferOut"].empty()) {
      callsBlindTransferOut = make_shared<long>(boost::any_cast<long>(m["CallsBlindTransferOut"]));
    }
    if (m.find("CallsDialed") != m.end() && !m["CallsDialed"].empty()) {
      callsDialed = make_shared<long>(boost::any_cast<long>(m["CallsDialed"]));
    }
    if (m.find("CallsHold") != m.end() && !m["CallsHold"].empty()) {
      callsHold = make_shared<long>(boost::any_cast<long>(m["CallsHold"]));
    }
    if (m.find("CallsRinged") != m.end() && !m["CallsRinged"].empty()) {
      callsRinged = make_shared<long>(boost::any_cast<long>(m["CallsRinged"]));
    }
    if (m.find("MaxDialingTime") != m.end() && !m["MaxDialingTime"].empty()) {
      maxDialingTime = make_shared<long>(boost::any_cast<long>(m["MaxDialingTime"]));
    }
    if (m.find("MaxHoldTime") != m.end() && !m["MaxHoldTime"].empty()) {
      maxHoldTime = make_shared<long>(boost::any_cast<long>(m["MaxHoldTime"]));
    }
    if (m.find("MaxRingTime") != m.end() && !m["MaxRingTime"].empty()) {
      maxRingTime = make_shared<long>(boost::any_cast<long>(m["MaxRingTime"]));
    }
    if (m.find("MaxTalkTime") != m.end() && !m["MaxTalkTime"].empty()) {
      maxTalkTime = make_shared<long>(boost::any_cast<long>(m["MaxTalkTime"]));
    }
    if (m.find("MaxWorkTime") != m.end() && !m["MaxWorkTime"].empty()) {
      maxWorkTime = make_shared<long>(boost::any_cast<long>(m["MaxWorkTime"]));
    }
    if (m.find("SatisfactionIndex") != m.end() && !m["SatisfactionIndex"].empty()) {
      satisfactionIndex = make_shared<double>(boost::any_cast<double>(m["SatisfactionIndex"]));
    }
    if (m.find("SatisfactionRate") != m.end() && !m["SatisfactionRate"].empty()) {
      satisfactionRate = make_shared<double>(boost::any_cast<double>(m["SatisfactionRate"]));
    }
    if (m.find("SatisfactionSurveysOffered") != m.end() && !m["SatisfactionSurveysOffered"].empty()) {
      satisfactionSurveysOffered = make_shared<long>(boost::any_cast<long>(m["SatisfactionSurveysOffered"]));
    }
    if (m.find("SatisfactionSurveysResponded") != m.end() && !m["SatisfactionSurveysResponded"].empty()) {
      satisfactionSurveysResponded = make_shared<long>(boost::any_cast<long>(m["SatisfactionSurveysResponded"]));
    }
    if (m.find("TotalDialingTime") != m.end() && !m["TotalDialingTime"].empty()) {
      totalDialingTime = make_shared<long>(boost::any_cast<long>(m["TotalDialingTime"]));
    }
    if (m.find("TotalHoldTime") != m.end() && !m["TotalHoldTime"].empty()) {
      totalHoldTime = make_shared<long>(boost::any_cast<long>(m["TotalHoldTime"]));
    }
    if (m.find("TotalRingTime") != m.end() && !m["TotalRingTime"].empty()) {
      totalRingTime = make_shared<long>(boost::any_cast<long>(m["TotalRingTime"]));
    }
    if (m.find("TotalTalkTime") != m.end() && !m["TotalTalkTime"].empty()) {
      totalTalkTime = make_shared<long>(boost::any_cast<long>(m["TotalTalkTime"]));
    }
    if (m.find("TotalWorkTime") != m.end() && !m["TotalWorkTime"].empty()) {
      totalWorkTime = make_shared<long>(boost::any_cast<long>(m["TotalWorkTime"]));
    }
  }


  virtual ~ListIntervalSkillGroupReportResponseBodyDataOutbound() = default;
};
class ListIntervalSkillGroupReportResponseBodyDataOverall : public Darabonba::Model {
public:
  shared_ptr<double> averageBreakTime{};
  shared_ptr<double> averageHoldTime{};
  shared_ptr<double> averageReadyTime{};
  shared_ptr<double> averageTalkTime{};
  shared_ptr<double> averageWorkTime{};
  shared_ptr<long> maxBreakTime{};
  shared_ptr<long> maxHoldTime{};
  shared_ptr<long> maxReadyTime{};
  shared_ptr<long> maxTalkTime{};
  shared_ptr<long> maxWorkTime{};
  shared_ptr<double> occupancyRate{};
  shared_ptr<double> satisfactionIndex{};
  shared_ptr<double> satisfactionRate{};
  shared_ptr<long> satisfactionSurveysOffered{};
  shared_ptr<long> satisfactionSurveysResponded{};
  shared_ptr<long> totalBreakTime{};
  shared_ptr<long> totalCalls{};
  shared_ptr<long> totalHoldTime{};
  shared_ptr<long> totalLoggedInTime{};
  shared_ptr<long> totalReadyTime{};
  shared_ptr<long> totalTalkTime{};
  shared_ptr<long> totalWorkTime{};

  ListIntervalSkillGroupReportResponseBodyDataOverall() {}

  explicit ListIntervalSkillGroupReportResponseBodyDataOverall(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (averageBreakTime) {
      res["AverageBreakTime"] = boost::any(*averageBreakTime);
    }
    if (averageHoldTime) {
      res["AverageHoldTime"] = boost::any(*averageHoldTime);
    }
    if (averageReadyTime) {
      res["AverageReadyTime"] = boost::any(*averageReadyTime);
    }
    if (averageTalkTime) {
      res["AverageTalkTime"] = boost::any(*averageTalkTime);
    }
    if (averageWorkTime) {
      res["AverageWorkTime"] = boost::any(*averageWorkTime);
    }
    if (maxBreakTime) {
      res["MaxBreakTime"] = boost::any(*maxBreakTime);
    }
    if (maxHoldTime) {
      res["MaxHoldTime"] = boost::any(*maxHoldTime);
    }
    if (maxReadyTime) {
      res["MaxReadyTime"] = boost::any(*maxReadyTime);
    }
    if (maxTalkTime) {
      res["MaxTalkTime"] = boost::any(*maxTalkTime);
    }
    if (maxWorkTime) {
      res["MaxWorkTime"] = boost::any(*maxWorkTime);
    }
    if (occupancyRate) {
      res["OccupancyRate"] = boost::any(*occupancyRate);
    }
    if (satisfactionIndex) {
      res["SatisfactionIndex"] = boost::any(*satisfactionIndex);
    }
    if (satisfactionRate) {
      res["SatisfactionRate"] = boost::any(*satisfactionRate);
    }
    if (satisfactionSurveysOffered) {
      res["SatisfactionSurveysOffered"] = boost::any(*satisfactionSurveysOffered);
    }
    if (satisfactionSurveysResponded) {
      res["SatisfactionSurveysResponded"] = boost::any(*satisfactionSurveysResponded);
    }
    if (totalBreakTime) {
      res["TotalBreakTime"] = boost::any(*totalBreakTime);
    }
    if (totalCalls) {
      res["TotalCalls"] = boost::any(*totalCalls);
    }
    if (totalHoldTime) {
      res["TotalHoldTime"] = boost::any(*totalHoldTime);
    }
    if (totalLoggedInTime) {
      res["TotalLoggedInTime"] = boost::any(*totalLoggedInTime);
    }
    if (totalReadyTime) {
      res["TotalReadyTime"] = boost::any(*totalReadyTime);
    }
    if (totalTalkTime) {
      res["TotalTalkTime"] = boost::any(*totalTalkTime);
    }
    if (totalWorkTime) {
      res["TotalWorkTime"] = boost::any(*totalWorkTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AverageBreakTime") != m.end() && !m["AverageBreakTime"].empty()) {
      averageBreakTime = make_shared<double>(boost::any_cast<double>(m["AverageBreakTime"]));
    }
    if (m.find("AverageHoldTime") != m.end() && !m["AverageHoldTime"].empty()) {
      averageHoldTime = make_shared<double>(boost::any_cast<double>(m["AverageHoldTime"]));
    }
    if (m.find("AverageReadyTime") != m.end() && !m["AverageReadyTime"].empty()) {
      averageReadyTime = make_shared<double>(boost::any_cast<double>(m["AverageReadyTime"]));
    }
    if (m.find("AverageTalkTime") != m.end() && !m["AverageTalkTime"].empty()) {
      averageTalkTime = make_shared<double>(boost::any_cast<double>(m["AverageTalkTime"]));
    }
    if (m.find("AverageWorkTime") != m.end() && !m["AverageWorkTime"].empty()) {
      averageWorkTime = make_shared<double>(boost::any_cast<double>(m["AverageWorkTime"]));
    }
    if (m.find("MaxBreakTime") != m.end() && !m["MaxBreakTime"].empty()) {
      maxBreakTime = make_shared<long>(boost::any_cast<long>(m["MaxBreakTime"]));
    }
    if (m.find("MaxHoldTime") != m.end() && !m["MaxHoldTime"].empty()) {
      maxHoldTime = make_shared<long>(boost::any_cast<long>(m["MaxHoldTime"]));
    }
    if (m.find("MaxReadyTime") != m.end() && !m["MaxReadyTime"].empty()) {
      maxReadyTime = make_shared<long>(boost::any_cast<long>(m["MaxReadyTime"]));
    }
    if (m.find("MaxTalkTime") != m.end() && !m["MaxTalkTime"].empty()) {
      maxTalkTime = make_shared<long>(boost::any_cast<long>(m["MaxTalkTime"]));
    }
    if (m.find("MaxWorkTime") != m.end() && !m["MaxWorkTime"].empty()) {
      maxWorkTime = make_shared<long>(boost::any_cast<long>(m["MaxWorkTime"]));
    }
    if (m.find("OccupancyRate") != m.end() && !m["OccupancyRate"].empty()) {
      occupancyRate = make_shared<double>(boost::any_cast<double>(m["OccupancyRate"]));
    }
    if (m.find("SatisfactionIndex") != m.end() && !m["SatisfactionIndex"].empty()) {
      satisfactionIndex = make_shared<double>(boost::any_cast<double>(m["SatisfactionIndex"]));
    }
    if (m.find("SatisfactionRate") != m.end() && !m["SatisfactionRate"].empty()) {
      satisfactionRate = make_shared<double>(boost::any_cast<double>(m["SatisfactionRate"]));
    }
    if (m.find("SatisfactionSurveysOffered") != m.end() && !m["SatisfactionSurveysOffered"].empty()) {
      satisfactionSurveysOffered = make_shared<long>(boost::any_cast<long>(m["SatisfactionSurveysOffered"]));
    }
    if (m.find("SatisfactionSurveysResponded") != m.end() && !m["SatisfactionSurveysResponded"].empty()) {
      satisfactionSurveysResponded = make_shared<long>(boost::any_cast<long>(m["SatisfactionSurveysResponded"]));
    }
    if (m.find("TotalBreakTime") != m.end() && !m["TotalBreakTime"].empty()) {
      totalBreakTime = make_shared<long>(boost::any_cast<long>(m["TotalBreakTime"]));
    }
    if (m.find("TotalCalls") != m.end() && !m["TotalCalls"].empty()) {
      totalCalls = make_shared<long>(boost::any_cast<long>(m["TotalCalls"]));
    }
    if (m.find("TotalHoldTime") != m.end() && !m["TotalHoldTime"].empty()) {
      totalHoldTime = make_shared<long>(boost::any_cast<long>(m["TotalHoldTime"]));
    }
    if (m.find("TotalLoggedInTime") != m.end() && !m["TotalLoggedInTime"].empty()) {
      totalLoggedInTime = make_shared<long>(boost::any_cast<long>(m["TotalLoggedInTime"]));
    }
    if (m.find("TotalReadyTime") != m.end() && !m["TotalReadyTime"].empty()) {
      totalReadyTime = make_shared<long>(boost::any_cast<long>(m["TotalReadyTime"]));
    }
    if (m.find("TotalTalkTime") != m.end() && !m["TotalTalkTime"].empty()) {
      totalTalkTime = make_shared<long>(boost::any_cast<long>(m["TotalTalkTime"]));
    }
    if (m.find("TotalWorkTime") != m.end() && !m["TotalWorkTime"].empty()) {
      totalWorkTime = make_shared<long>(boost::any_cast<long>(m["TotalWorkTime"]));
    }
  }


  virtual ~ListIntervalSkillGroupReportResponseBodyDataOverall() = default;
};
class ListIntervalSkillGroupReportResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<ListIntervalSkillGroupReportResponseBodyDataInbound> inbound{};
  shared_ptr<ListIntervalSkillGroupReportResponseBodyDataOutbound> outbound{};
  shared_ptr<ListIntervalSkillGroupReportResponseBodyDataOverall> overall{};
  shared_ptr<long> statsTime{};

  ListIntervalSkillGroupReportResponseBodyData() {}

  explicit ListIntervalSkillGroupReportResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (inbound) {
      res["Inbound"] = inbound ? boost::any(inbound->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (outbound) {
      res["Outbound"] = outbound ? boost::any(outbound->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (overall) {
      res["Overall"] = overall ? boost::any(overall->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (statsTime) {
      res["StatsTime"] = boost::any(*statsTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Inbound") != m.end() && !m["Inbound"].empty()) {
      if (typeid(map<string, boost::any>) == m["Inbound"].type()) {
        ListIntervalSkillGroupReportResponseBodyDataInbound model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Inbound"]));
        inbound = make_shared<ListIntervalSkillGroupReportResponseBodyDataInbound>(model1);
      }
    }
    if (m.find("Outbound") != m.end() && !m["Outbound"].empty()) {
      if (typeid(map<string, boost::any>) == m["Outbound"].type()) {
        ListIntervalSkillGroupReportResponseBodyDataOutbound model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Outbound"]));
        outbound = make_shared<ListIntervalSkillGroupReportResponseBodyDataOutbound>(model1);
      }
    }
    if (m.find("Overall") != m.end() && !m["Overall"].empty()) {
      if (typeid(map<string, boost::any>) == m["Overall"].type()) {
        ListIntervalSkillGroupReportResponseBodyDataOverall model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Overall"]));
        overall = make_shared<ListIntervalSkillGroupReportResponseBodyDataOverall>(model1);
      }
    }
    if (m.find("StatsTime") != m.end() && !m["StatsTime"].empty()) {
      statsTime = make_shared<long>(boost::any_cast<long>(m["StatsTime"]));
    }
  }


  virtual ~ListIntervalSkillGroupReportResponseBodyData() = default;
};
class ListIntervalSkillGroupReportResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<vector<ListIntervalSkillGroupReportResponseBodyData>> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  ListIntervalSkillGroupReportResponseBody() {}

  explicit ListIntervalSkillGroupReportResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<ListIntervalSkillGroupReportResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListIntervalSkillGroupReportResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<ListIntervalSkillGroupReportResponseBodyData>>(expect1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListIntervalSkillGroupReportResponseBody() = default;
};
class ListIntervalSkillGroupReportResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListIntervalSkillGroupReportResponseBody> body{};

  ListIntervalSkillGroupReportResponse() {}

  explicit ListIntervalSkillGroupReportResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListIntervalSkillGroupReportResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListIntervalSkillGroupReportResponseBody>(model1);
      }
    }
  }


  virtual ~ListIntervalSkillGroupReportResponse() = default;
};
class ListIvrTrackingDetailsRequest : public Darabonba::Model {
public:
  shared_ptr<string> contactId{};
  shared_ptr<string> instanceId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};

  ListIvrTrackingDetailsRequest() {}

  explicit ListIvrTrackingDetailsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contactId) {
      res["ContactId"] = boost::any(*contactId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ContactId") != m.end() && !m["ContactId"].empty()) {
      contactId = make_shared<string>(boost::any_cast<string>(m["ContactId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~ListIvrTrackingDetailsRequest() = default;
};
class ListIvrTrackingDetailsResponseBodyDataList : public Darabonba::Model {
public:
  shared_ptr<string> callee{};
  shared_ptr<string> caller{};
  shared_ptr<string> channelId{};
  shared_ptr<string> channelVariables{};
  shared_ptr<string> contactId{};
  shared_ptr<long> enterTime{};
  shared_ptr<string> flowId{};
  shared_ptr<string> flowName{};
  shared_ptr<string> instance{};
  shared_ptr<long> leaveTime{};
  shared_ptr<string> nodeExitCode{};
  shared_ptr<string> nodeId{};
  shared_ptr<string> nodeName{};
  shared_ptr<map<string, boost::any>> nodeProperties{};
  shared_ptr<string> nodeType{};
  shared_ptr<map<string, boost::any>> nodeVariables{};

  ListIvrTrackingDetailsResponseBodyDataList() {}

  explicit ListIvrTrackingDetailsResponseBodyDataList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callee) {
      res["Callee"] = boost::any(*callee);
    }
    if (caller) {
      res["Caller"] = boost::any(*caller);
    }
    if (channelId) {
      res["ChannelId"] = boost::any(*channelId);
    }
    if (channelVariables) {
      res["ChannelVariables"] = boost::any(*channelVariables);
    }
    if (contactId) {
      res["ContactId"] = boost::any(*contactId);
    }
    if (enterTime) {
      res["EnterTime"] = boost::any(*enterTime);
    }
    if (flowId) {
      res["FlowId"] = boost::any(*flowId);
    }
    if (flowName) {
      res["FlowName"] = boost::any(*flowName);
    }
    if (instance) {
      res["Instance"] = boost::any(*instance);
    }
    if (leaveTime) {
      res["LeaveTime"] = boost::any(*leaveTime);
    }
    if (nodeExitCode) {
      res["NodeExitCode"] = boost::any(*nodeExitCode);
    }
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    if (nodeName) {
      res["NodeName"] = boost::any(*nodeName);
    }
    if (nodeProperties) {
      res["NodeProperties"] = boost::any(*nodeProperties);
    }
    if (nodeType) {
      res["NodeType"] = boost::any(*nodeType);
    }
    if (nodeVariables) {
      res["NodeVariables"] = boost::any(*nodeVariables);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Callee") != m.end() && !m["Callee"].empty()) {
      callee = make_shared<string>(boost::any_cast<string>(m["Callee"]));
    }
    if (m.find("Caller") != m.end() && !m["Caller"].empty()) {
      caller = make_shared<string>(boost::any_cast<string>(m["Caller"]));
    }
    if (m.find("ChannelId") != m.end() && !m["ChannelId"].empty()) {
      channelId = make_shared<string>(boost::any_cast<string>(m["ChannelId"]));
    }
    if (m.find("ChannelVariables") != m.end() && !m["ChannelVariables"].empty()) {
      channelVariables = make_shared<string>(boost::any_cast<string>(m["ChannelVariables"]));
    }
    if (m.find("ContactId") != m.end() && !m["ContactId"].empty()) {
      contactId = make_shared<string>(boost::any_cast<string>(m["ContactId"]));
    }
    if (m.find("EnterTime") != m.end() && !m["EnterTime"].empty()) {
      enterTime = make_shared<long>(boost::any_cast<long>(m["EnterTime"]));
    }
    if (m.find("FlowId") != m.end() && !m["FlowId"].empty()) {
      flowId = make_shared<string>(boost::any_cast<string>(m["FlowId"]));
    }
    if (m.find("FlowName") != m.end() && !m["FlowName"].empty()) {
      flowName = make_shared<string>(boost::any_cast<string>(m["FlowName"]));
    }
    if (m.find("Instance") != m.end() && !m["Instance"].empty()) {
      instance = make_shared<string>(boost::any_cast<string>(m["Instance"]));
    }
    if (m.find("LeaveTime") != m.end() && !m["LeaveTime"].empty()) {
      leaveTime = make_shared<long>(boost::any_cast<long>(m["LeaveTime"]));
    }
    if (m.find("NodeExitCode") != m.end() && !m["NodeExitCode"].empty()) {
      nodeExitCode = make_shared<string>(boost::any_cast<string>(m["NodeExitCode"]));
    }
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<string>(boost::any_cast<string>(m["NodeId"]));
    }
    if (m.find("NodeName") != m.end() && !m["NodeName"].empty()) {
      nodeName = make_shared<string>(boost::any_cast<string>(m["NodeName"]));
    }
    if (m.find("NodeProperties") != m.end() && !m["NodeProperties"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["NodeProperties"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      nodeProperties = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("NodeType") != m.end() && !m["NodeType"].empty()) {
      nodeType = make_shared<string>(boost::any_cast<string>(m["NodeType"]));
    }
    if (m.find("NodeVariables") != m.end() && !m["NodeVariables"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["NodeVariables"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      nodeVariables = make_shared<map<string, boost::any>>(toMap1);
    }
  }


  virtual ~ListIvrTrackingDetailsResponseBodyDataList() = default;
};
class ListIvrTrackingDetailsResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<ListIvrTrackingDetailsResponseBodyDataList>> list{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  ListIvrTrackingDetailsResponseBodyData() {}

  explicit ListIvrTrackingDetailsResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (list) {
      vector<boost::any> temp1;
      for(auto item1:*list){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["List"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(vector<boost::any>) == m["List"].type()) {
        vector<ListIvrTrackingDetailsResponseBodyDataList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["List"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListIvrTrackingDetailsResponseBodyDataList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        list = make_shared<vector<ListIvrTrackingDetailsResponseBodyDataList>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListIvrTrackingDetailsResponseBodyData() = default;
};
class ListIvrTrackingDetailsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<ListIvrTrackingDetailsResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  ListIvrTrackingDetailsResponseBody() {}

  explicit ListIvrTrackingDetailsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ListIvrTrackingDetailsResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ListIvrTrackingDetailsResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListIvrTrackingDetailsResponseBody() = default;
};
class ListIvrTrackingDetailsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListIvrTrackingDetailsResponseBody> body{};

  ListIvrTrackingDetailsResponse() {}

  explicit ListIvrTrackingDetailsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListIvrTrackingDetailsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListIvrTrackingDetailsResponseBody>(model1);
      }
    }
  }


  virtual ~ListIvrTrackingDetailsResponse() = default;
};
class ListLegacyAgentEventLogsRequest : public Darabonba::Model {
public:
  shared_ptr<string> agentId{};
  shared_ptr<long> endTime{};
  shared_ptr<string> instanceId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> startTime{};

  ListLegacyAgentEventLogsRequest() {}

  explicit ListLegacyAgentEventLogsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agentId) {
      res["AgentId"] = boost::any(*agentId);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AgentId") != m.end() && !m["AgentId"].empty()) {
      agentId = make_shared<string>(boost::any_cast<string>(m["AgentId"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
  }


  virtual ~ListLegacyAgentEventLogsRequest() = default;
};
class ListLegacyAgentEventLogsResponseBodyDataList : public Darabonba::Model {
public:
  shared_ptr<string> agentDropCall{};
  shared_ptr<string> agentNo{};
  shared_ptr<string> callDir{};
  shared_ptr<string> callId{};
  shared_ptr<string> callMode{};
  shared_ptr<string> callType{};
  shared_ptr<string> calleeId{};
  shared_ptr<string> callerId{};
  shared_ptr<string> connId{};
  shared_ptr<string> event{};
  shared_ptr<string> groupNo{};
  shared_ptr<bool> outboundScenario{};
  shared_ptr<string> phoneNo{};
  shared_ptr<string> statisticDate{};
  shared_ptr<string> targetRequest{};
  shared_ptr<string> targetSelect{};
  shared_ptr<string> tenantId{};
  shared_ptr<string> transferNumber{};

  ListLegacyAgentEventLogsResponseBodyDataList() {}

  explicit ListLegacyAgentEventLogsResponseBodyDataList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agentDropCall) {
      res["AgentDropCall"] = boost::any(*agentDropCall);
    }
    if (agentNo) {
      res["AgentNo"] = boost::any(*agentNo);
    }
    if (callDir) {
      res["CallDir"] = boost::any(*callDir);
    }
    if (callId) {
      res["CallId"] = boost::any(*callId);
    }
    if (callMode) {
      res["CallMode"] = boost::any(*callMode);
    }
    if (callType) {
      res["CallType"] = boost::any(*callType);
    }
    if (calleeId) {
      res["CalleeId"] = boost::any(*calleeId);
    }
    if (callerId) {
      res["CallerId"] = boost::any(*callerId);
    }
    if (connId) {
      res["ConnId"] = boost::any(*connId);
    }
    if (event) {
      res["Event"] = boost::any(*event);
    }
    if (groupNo) {
      res["GroupNo"] = boost::any(*groupNo);
    }
    if (outboundScenario) {
      res["OutboundScenario"] = boost::any(*outboundScenario);
    }
    if (phoneNo) {
      res["PhoneNo"] = boost::any(*phoneNo);
    }
    if (statisticDate) {
      res["StatisticDate"] = boost::any(*statisticDate);
    }
    if (targetRequest) {
      res["TargetRequest"] = boost::any(*targetRequest);
    }
    if (targetSelect) {
      res["TargetSelect"] = boost::any(*targetSelect);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    if (transferNumber) {
      res["TransferNumber"] = boost::any(*transferNumber);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AgentDropCall") != m.end() && !m["AgentDropCall"].empty()) {
      agentDropCall = make_shared<string>(boost::any_cast<string>(m["AgentDropCall"]));
    }
    if (m.find("AgentNo") != m.end() && !m["AgentNo"].empty()) {
      agentNo = make_shared<string>(boost::any_cast<string>(m["AgentNo"]));
    }
    if (m.find("CallDir") != m.end() && !m["CallDir"].empty()) {
      callDir = make_shared<string>(boost::any_cast<string>(m["CallDir"]));
    }
    if (m.find("CallId") != m.end() && !m["CallId"].empty()) {
      callId = make_shared<string>(boost::any_cast<string>(m["CallId"]));
    }
    if (m.find("CallMode") != m.end() && !m["CallMode"].empty()) {
      callMode = make_shared<string>(boost::any_cast<string>(m["CallMode"]));
    }
    if (m.find("CallType") != m.end() && !m["CallType"].empty()) {
      callType = make_shared<string>(boost::any_cast<string>(m["CallType"]));
    }
    if (m.find("CalleeId") != m.end() && !m["CalleeId"].empty()) {
      calleeId = make_shared<string>(boost::any_cast<string>(m["CalleeId"]));
    }
    if (m.find("CallerId") != m.end() && !m["CallerId"].empty()) {
      callerId = make_shared<string>(boost::any_cast<string>(m["CallerId"]));
    }
    if (m.find("ConnId") != m.end() && !m["ConnId"].empty()) {
      connId = make_shared<string>(boost::any_cast<string>(m["ConnId"]));
    }
    if (m.find("Event") != m.end() && !m["Event"].empty()) {
      event = make_shared<string>(boost::any_cast<string>(m["Event"]));
    }
    if (m.find("GroupNo") != m.end() && !m["GroupNo"].empty()) {
      groupNo = make_shared<string>(boost::any_cast<string>(m["GroupNo"]));
    }
    if (m.find("OutboundScenario") != m.end() && !m["OutboundScenario"].empty()) {
      outboundScenario = make_shared<bool>(boost::any_cast<bool>(m["OutboundScenario"]));
    }
    if (m.find("PhoneNo") != m.end() && !m["PhoneNo"].empty()) {
      phoneNo = make_shared<string>(boost::any_cast<string>(m["PhoneNo"]));
    }
    if (m.find("StatisticDate") != m.end() && !m["StatisticDate"].empty()) {
      statisticDate = make_shared<string>(boost::any_cast<string>(m["StatisticDate"]));
    }
    if (m.find("TargetRequest") != m.end() && !m["TargetRequest"].empty()) {
      targetRequest = make_shared<string>(boost::any_cast<string>(m["TargetRequest"]));
    }
    if (m.find("TargetSelect") != m.end() && !m["TargetSelect"].empty()) {
      targetSelect = make_shared<string>(boost::any_cast<string>(m["TargetSelect"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["TenantId"]));
    }
    if (m.find("TransferNumber") != m.end() && !m["TransferNumber"].empty()) {
      transferNumber = make_shared<string>(boost::any_cast<string>(m["TransferNumber"]));
    }
  }


  virtual ~ListLegacyAgentEventLogsResponseBodyDataList() = default;
};
class ListLegacyAgentEventLogsResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<ListLegacyAgentEventLogsResponseBodyDataList>> list{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  ListLegacyAgentEventLogsResponseBodyData() {}

  explicit ListLegacyAgentEventLogsResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (list) {
      vector<boost::any> temp1;
      for(auto item1:*list){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["List"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(vector<boost::any>) == m["List"].type()) {
        vector<ListLegacyAgentEventLogsResponseBodyDataList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["List"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListLegacyAgentEventLogsResponseBodyDataList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        list = make_shared<vector<ListLegacyAgentEventLogsResponseBodyDataList>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListLegacyAgentEventLogsResponseBodyData() = default;
};
class ListLegacyAgentEventLogsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<ListLegacyAgentEventLogsResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ListLegacyAgentEventLogsResponseBody() {}

  explicit ListLegacyAgentEventLogsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ListLegacyAgentEventLogsResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ListLegacyAgentEventLogsResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ListLegacyAgentEventLogsResponseBody() = default;
};
class ListLegacyAgentEventLogsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListLegacyAgentEventLogsResponseBody> body{};

  ListLegacyAgentEventLogsResponse() {}

  explicit ListLegacyAgentEventLogsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListLegacyAgentEventLogsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListLegacyAgentEventLogsResponseBody>(model1);
      }
    }
  }


  virtual ~ListLegacyAgentEventLogsResponse() = default;
};
class ListLegacyAgentStatusLogsRequest : public Darabonba::Model {
public:
  shared_ptr<string> agentId{};
  shared_ptr<long> endTime{};
  shared_ptr<string> instanceId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> startTime{};

  ListLegacyAgentStatusLogsRequest() {}

  explicit ListLegacyAgentStatusLogsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agentId) {
      res["AgentId"] = boost::any(*agentId);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AgentId") != m.end() && !m["AgentId"].empty()) {
      agentId = make_shared<string>(boost::any_cast<string>(m["AgentId"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
  }


  virtual ~ListLegacyAgentStatusLogsRequest() = default;
};
class ListLegacyAgentStatusLogsResponseBodyDataList : public Darabonba::Model {
public:
  shared_ptr<string> agentDropCall{};
  shared_ptr<string> agentNo{};
  shared_ptr<string> aliHangupCause{};
  shared_ptr<string> callDir{};
  shared_ptr<string> callId{};
  shared_ptr<string> callType{};
  shared_ptr<string> calleeId{};
  shared_ptr<string> callerId{};
  shared_ptr<string> connId{};
  shared_ptr<string> extend1{};
  shared_ptr<string> extend2{};
  shared_ptr<string> extend3{};
  shared_ptr<string> extend4{};
  shared_ptr<string> groupNo{};
  shared_ptr<string> monitedAgentNo{};
  shared_ptr<string> monitedAgentPhoneNo{};
  shared_ptr<bool> outboundScenario{};
  shared_ptr<string> phoneNo{};
  shared_ptr<string> statisticDate{};
  shared_ptr<long> statisticTime{};
  shared_ptr<string> status{};
  shared_ptr<string> targetRequest{};
  shared_ptr<string> targetSelect{};
  shared_ptr<string> tenantId{};
  shared_ptr<string> transferNo{};
  shared_ptr<string> transferNumber{};

  ListLegacyAgentStatusLogsResponseBodyDataList() {}

  explicit ListLegacyAgentStatusLogsResponseBodyDataList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agentDropCall) {
      res["AgentDropCall"] = boost::any(*agentDropCall);
    }
    if (agentNo) {
      res["AgentNo"] = boost::any(*agentNo);
    }
    if (aliHangupCause) {
      res["AliHangupCause"] = boost::any(*aliHangupCause);
    }
    if (callDir) {
      res["CallDir"] = boost::any(*callDir);
    }
    if (callId) {
      res["CallId"] = boost::any(*callId);
    }
    if (callType) {
      res["CallType"] = boost::any(*callType);
    }
    if (calleeId) {
      res["CalleeId"] = boost::any(*calleeId);
    }
    if (callerId) {
      res["CallerId"] = boost::any(*callerId);
    }
    if (connId) {
      res["ConnId"] = boost::any(*connId);
    }
    if (extend1) {
      res["Extend1"] = boost::any(*extend1);
    }
    if (extend2) {
      res["Extend2"] = boost::any(*extend2);
    }
    if (extend3) {
      res["Extend3"] = boost::any(*extend3);
    }
    if (extend4) {
      res["Extend4"] = boost::any(*extend4);
    }
    if (groupNo) {
      res["GroupNo"] = boost::any(*groupNo);
    }
    if (monitedAgentNo) {
      res["MonitedAgentNo"] = boost::any(*monitedAgentNo);
    }
    if (monitedAgentPhoneNo) {
      res["MonitedAgentPhoneNo"] = boost::any(*monitedAgentPhoneNo);
    }
    if (outboundScenario) {
      res["OutboundScenario"] = boost::any(*outboundScenario);
    }
    if (phoneNo) {
      res["PhoneNo"] = boost::any(*phoneNo);
    }
    if (statisticDate) {
      res["StatisticDate"] = boost::any(*statisticDate);
    }
    if (statisticTime) {
      res["StatisticTime"] = boost::any(*statisticTime);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (targetRequest) {
      res["TargetRequest"] = boost::any(*targetRequest);
    }
    if (targetSelect) {
      res["TargetSelect"] = boost::any(*targetSelect);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    if (transferNo) {
      res["TransferNo"] = boost::any(*transferNo);
    }
    if (transferNumber) {
      res["TransferNumber"] = boost::any(*transferNumber);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AgentDropCall") != m.end() && !m["AgentDropCall"].empty()) {
      agentDropCall = make_shared<string>(boost::any_cast<string>(m["AgentDropCall"]));
    }
    if (m.find("AgentNo") != m.end() && !m["AgentNo"].empty()) {
      agentNo = make_shared<string>(boost::any_cast<string>(m["AgentNo"]));
    }
    if (m.find("AliHangupCause") != m.end() && !m["AliHangupCause"].empty()) {
      aliHangupCause = make_shared<string>(boost::any_cast<string>(m["AliHangupCause"]));
    }
    if (m.find("CallDir") != m.end() && !m["CallDir"].empty()) {
      callDir = make_shared<string>(boost::any_cast<string>(m["CallDir"]));
    }
    if (m.find("CallId") != m.end() && !m["CallId"].empty()) {
      callId = make_shared<string>(boost::any_cast<string>(m["CallId"]));
    }
    if (m.find("CallType") != m.end() && !m["CallType"].empty()) {
      callType = make_shared<string>(boost::any_cast<string>(m["CallType"]));
    }
    if (m.find("CalleeId") != m.end() && !m["CalleeId"].empty()) {
      calleeId = make_shared<string>(boost::any_cast<string>(m["CalleeId"]));
    }
    if (m.find("CallerId") != m.end() && !m["CallerId"].empty()) {
      callerId = make_shared<string>(boost::any_cast<string>(m["CallerId"]));
    }
    if (m.find("ConnId") != m.end() && !m["ConnId"].empty()) {
      connId = make_shared<string>(boost::any_cast<string>(m["ConnId"]));
    }
    if (m.find("Extend1") != m.end() && !m["Extend1"].empty()) {
      extend1 = make_shared<string>(boost::any_cast<string>(m["Extend1"]));
    }
    if (m.find("Extend2") != m.end() && !m["Extend2"].empty()) {
      extend2 = make_shared<string>(boost::any_cast<string>(m["Extend2"]));
    }
    if (m.find("Extend3") != m.end() && !m["Extend3"].empty()) {
      extend3 = make_shared<string>(boost::any_cast<string>(m["Extend3"]));
    }
    if (m.find("Extend4") != m.end() && !m["Extend4"].empty()) {
      extend4 = make_shared<string>(boost::any_cast<string>(m["Extend4"]));
    }
    if (m.find("GroupNo") != m.end() && !m["GroupNo"].empty()) {
      groupNo = make_shared<string>(boost::any_cast<string>(m["GroupNo"]));
    }
    if (m.find("MonitedAgentNo") != m.end() && !m["MonitedAgentNo"].empty()) {
      monitedAgentNo = make_shared<string>(boost::any_cast<string>(m["MonitedAgentNo"]));
    }
    if (m.find("MonitedAgentPhoneNo") != m.end() && !m["MonitedAgentPhoneNo"].empty()) {
      monitedAgentPhoneNo = make_shared<string>(boost::any_cast<string>(m["MonitedAgentPhoneNo"]));
    }
    if (m.find("OutboundScenario") != m.end() && !m["OutboundScenario"].empty()) {
      outboundScenario = make_shared<bool>(boost::any_cast<bool>(m["OutboundScenario"]));
    }
    if (m.find("PhoneNo") != m.end() && !m["PhoneNo"].empty()) {
      phoneNo = make_shared<string>(boost::any_cast<string>(m["PhoneNo"]));
    }
    if (m.find("StatisticDate") != m.end() && !m["StatisticDate"].empty()) {
      statisticDate = make_shared<string>(boost::any_cast<string>(m["StatisticDate"]));
    }
    if (m.find("StatisticTime") != m.end() && !m["StatisticTime"].empty()) {
      statisticTime = make_shared<long>(boost::any_cast<long>(m["StatisticTime"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("TargetRequest") != m.end() && !m["TargetRequest"].empty()) {
      targetRequest = make_shared<string>(boost::any_cast<string>(m["TargetRequest"]));
    }
    if (m.find("TargetSelect") != m.end() && !m["TargetSelect"].empty()) {
      targetSelect = make_shared<string>(boost::any_cast<string>(m["TargetSelect"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["TenantId"]));
    }
    if (m.find("TransferNo") != m.end() && !m["TransferNo"].empty()) {
      transferNo = make_shared<string>(boost::any_cast<string>(m["TransferNo"]));
    }
    if (m.find("TransferNumber") != m.end() && !m["TransferNumber"].empty()) {
      transferNumber = make_shared<string>(boost::any_cast<string>(m["TransferNumber"]));
    }
  }


  virtual ~ListLegacyAgentStatusLogsResponseBodyDataList() = default;
};
class ListLegacyAgentStatusLogsResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<ListLegacyAgentStatusLogsResponseBodyDataList>> list{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  ListLegacyAgentStatusLogsResponseBodyData() {}

  explicit ListLegacyAgentStatusLogsResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (list) {
      vector<boost::any> temp1;
      for(auto item1:*list){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["List"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(vector<boost::any>) == m["List"].type()) {
        vector<ListLegacyAgentStatusLogsResponseBodyDataList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["List"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListLegacyAgentStatusLogsResponseBodyDataList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        list = make_shared<vector<ListLegacyAgentStatusLogsResponseBodyDataList>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListLegacyAgentStatusLogsResponseBodyData() = default;
};
class ListLegacyAgentStatusLogsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<ListLegacyAgentStatusLogsResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ListLegacyAgentStatusLogsResponseBody() {}

  explicit ListLegacyAgentStatusLogsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ListLegacyAgentStatusLogsResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ListLegacyAgentStatusLogsResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ListLegacyAgentStatusLogsResponseBody() = default;
};
class ListLegacyAgentStatusLogsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListLegacyAgentStatusLogsResponseBody> body{};

  ListLegacyAgentStatusLogsResponse() {}

  explicit ListLegacyAgentStatusLogsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListLegacyAgentStatusLogsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListLegacyAgentStatusLogsResponseBody>(model1);
      }
    }
  }


  virtual ~ListLegacyAgentStatusLogsResponse() = default;
};
class ListLegacyAppraiseLogsRequest : public Darabonba::Model {
public:
  shared_ptr<long> endTime{};
  shared_ptr<string> instanceId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> startTime{};

  ListLegacyAppraiseLogsRequest() {}

  explicit ListLegacyAppraiseLogsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
  }


  virtual ~ListLegacyAppraiseLogsRequest() = default;
};
class ListLegacyAppraiseLogsResponseBodyDataList : public Darabonba::Model {
public:
  shared_ptr<string> acid{};
  shared_ptr<string> contactType{};
  shared_ptr<long> id{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> keyMarkRelation{};
  shared_ptr<string> note{};
  shared_ptr<string> parentNote{};
  shared_ptr<string> pressKey{};
  shared_ptr<string> ramId{};
  shared_ptr<string> skillGroupId{};
  shared_ptr<string> statisticDate{};
  shared_ptr<string> type{};

  ListLegacyAppraiseLogsResponseBodyDataList() {}

  explicit ListLegacyAppraiseLogsResponseBodyDataList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acid) {
      res["Acid"] = boost::any(*acid);
    }
    if (contactType) {
      res["ContactType"] = boost::any(*contactType);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (keyMarkRelation) {
      res["KeyMarkRelation"] = boost::any(*keyMarkRelation);
    }
    if (note) {
      res["Note"] = boost::any(*note);
    }
    if (parentNote) {
      res["ParentNote"] = boost::any(*parentNote);
    }
    if (pressKey) {
      res["PressKey"] = boost::any(*pressKey);
    }
    if (ramId) {
      res["RamId"] = boost::any(*ramId);
    }
    if (skillGroupId) {
      res["SkillGroupId"] = boost::any(*skillGroupId);
    }
    if (statisticDate) {
      res["StatisticDate"] = boost::any(*statisticDate);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Acid") != m.end() && !m["Acid"].empty()) {
      acid = make_shared<string>(boost::any_cast<string>(m["Acid"]));
    }
    if (m.find("ContactType") != m.end() && !m["ContactType"].empty()) {
      contactType = make_shared<string>(boost::any_cast<string>(m["ContactType"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("KeyMarkRelation") != m.end() && !m["KeyMarkRelation"].empty()) {
      keyMarkRelation = make_shared<string>(boost::any_cast<string>(m["KeyMarkRelation"]));
    }
    if (m.find("Note") != m.end() && !m["Note"].empty()) {
      note = make_shared<string>(boost::any_cast<string>(m["Note"]));
    }
    if (m.find("ParentNote") != m.end() && !m["ParentNote"].empty()) {
      parentNote = make_shared<string>(boost::any_cast<string>(m["ParentNote"]));
    }
    if (m.find("PressKey") != m.end() && !m["PressKey"].empty()) {
      pressKey = make_shared<string>(boost::any_cast<string>(m["PressKey"]));
    }
    if (m.find("RamId") != m.end() && !m["RamId"].empty()) {
      ramId = make_shared<string>(boost::any_cast<string>(m["RamId"]));
    }
    if (m.find("SkillGroupId") != m.end() && !m["SkillGroupId"].empty()) {
      skillGroupId = make_shared<string>(boost::any_cast<string>(m["SkillGroupId"]));
    }
    if (m.find("StatisticDate") != m.end() && !m["StatisticDate"].empty()) {
      statisticDate = make_shared<string>(boost::any_cast<string>(m["StatisticDate"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ListLegacyAppraiseLogsResponseBodyDataList() = default;
};
class ListLegacyAppraiseLogsResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<ListLegacyAppraiseLogsResponseBodyDataList>> list{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  ListLegacyAppraiseLogsResponseBodyData() {}

  explicit ListLegacyAppraiseLogsResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (list) {
      vector<boost::any> temp1;
      for(auto item1:*list){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["List"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(vector<boost::any>) == m["List"].type()) {
        vector<ListLegacyAppraiseLogsResponseBodyDataList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["List"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListLegacyAppraiseLogsResponseBodyDataList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        list = make_shared<vector<ListLegacyAppraiseLogsResponseBodyDataList>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListLegacyAppraiseLogsResponseBodyData() = default;
};
class ListLegacyAppraiseLogsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<ListLegacyAppraiseLogsResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ListLegacyAppraiseLogsResponseBody() {}

  explicit ListLegacyAppraiseLogsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ListLegacyAppraiseLogsResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ListLegacyAppraiseLogsResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ListLegacyAppraiseLogsResponseBody() = default;
};
class ListLegacyAppraiseLogsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListLegacyAppraiseLogsResponseBody> body{};

  ListLegacyAppraiseLogsResponse() {}

  explicit ListLegacyAppraiseLogsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListLegacyAppraiseLogsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListLegacyAppraiseLogsResponseBody>(model1);
      }
    }
  }


  virtual ~ListLegacyAppraiseLogsResponse() = default;
};
class ListLegacyQueueEventLogsRequest : public Darabonba::Model {
public:
  shared_ptr<long> endTime{};
  shared_ptr<string> instanceId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> skillGroupId{};
  shared_ptr<long> startTime{};

  ListLegacyQueueEventLogsRequest() {}

  explicit ListLegacyQueueEventLogsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (skillGroupId) {
      res["SkillGroupId"] = boost::any(*skillGroupId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SkillGroupId") != m.end() && !m["SkillGroupId"].empty()) {
      skillGroupId = make_shared<string>(boost::any_cast<string>(m["SkillGroupId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
  }


  virtual ~ListLegacyQueueEventLogsRequest() = default;
};
class ListLegacyQueueEventLogsResponseBodyDataList : public Darabonba::Model {
public:
  shared_ptr<string> acid{};
  shared_ptr<string> ani{};
  shared_ptr<string> answerPhone{};
  shared_ptr<long> answerTime{};
  shared_ptr<string> cause{};
  shared_ptr<string> dnis{};
  shared_ptr<long> queueTime{};
  shared_ptr<string> statisticDate{};
  shared_ptr<string> tenantId{};
  shared_ptr<string> vq{};

  ListLegacyQueueEventLogsResponseBodyDataList() {}

  explicit ListLegacyQueueEventLogsResponseBodyDataList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acid) {
      res["Acid"] = boost::any(*acid);
    }
    if (ani) {
      res["Ani"] = boost::any(*ani);
    }
    if (answerPhone) {
      res["AnswerPhone"] = boost::any(*answerPhone);
    }
    if (answerTime) {
      res["AnswerTime"] = boost::any(*answerTime);
    }
    if (cause) {
      res["Cause"] = boost::any(*cause);
    }
    if (dnis) {
      res["Dnis"] = boost::any(*dnis);
    }
    if (queueTime) {
      res["QueueTime"] = boost::any(*queueTime);
    }
    if (statisticDate) {
      res["StatisticDate"] = boost::any(*statisticDate);
    }
    if (tenantId) {
      res["TenantId"] = boost::any(*tenantId);
    }
    if (vq) {
      res["Vq"] = boost::any(*vq);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Acid") != m.end() && !m["Acid"].empty()) {
      acid = make_shared<string>(boost::any_cast<string>(m["Acid"]));
    }
    if (m.find("Ani") != m.end() && !m["Ani"].empty()) {
      ani = make_shared<string>(boost::any_cast<string>(m["Ani"]));
    }
    if (m.find("AnswerPhone") != m.end() && !m["AnswerPhone"].empty()) {
      answerPhone = make_shared<string>(boost::any_cast<string>(m["AnswerPhone"]));
    }
    if (m.find("AnswerTime") != m.end() && !m["AnswerTime"].empty()) {
      answerTime = make_shared<long>(boost::any_cast<long>(m["AnswerTime"]));
    }
    if (m.find("Cause") != m.end() && !m["Cause"].empty()) {
      cause = make_shared<string>(boost::any_cast<string>(m["Cause"]));
    }
    if (m.find("Dnis") != m.end() && !m["Dnis"].empty()) {
      dnis = make_shared<string>(boost::any_cast<string>(m["Dnis"]));
    }
    if (m.find("QueueTime") != m.end() && !m["QueueTime"].empty()) {
      queueTime = make_shared<long>(boost::any_cast<long>(m["QueueTime"]));
    }
    if (m.find("StatisticDate") != m.end() && !m["StatisticDate"].empty()) {
      statisticDate = make_shared<string>(boost::any_cast<string>(m["StatisticDate"]));
    }
    if (m.find("TenantId") != m.end() && !m["TenantId"].empty()) {
      tenantId = make_shared<string>(boost::any_cast<string>(m["TenantId"]));
    }
    if (m.find("Vq") != m.end() && !m["Vq"].empty()) {
      vq = make_shared<string>(boost::any_cast<string>(m["Vq"]));
    }
  }


  virtual ~ListLegacyQueueEventLogsResponseBodyDataList() = default;
};
class ListLegacyQueueEventLogsResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<ListLegacyQueueEventLogsResponseBodyDataList>> list{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  ListLegacyQueueEventLogsResponseBodyData() {}

  explicit ListLegacyQueueEventLogsResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (list) {
      vector<boost::any> temp1;
      for(auto item1:*list){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["List"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(vector<boost::any>) == m["List"].type()) {
        vector<ListLegacyQueueEventLogsResponseBodyDataList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["List"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListLegacyQueueEventLogsResponseBodyDataList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        list = make_shared<vector<ListLegacyQueueEventLogsResponseBodyDataList>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListLegacyQueueEventLogsResponseBodyData() = default;
};
class ListLegacyQueueEventLogsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<ListLegacyQueueEventLogsResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ListLegacyQueueEventLogsResponseBody() {}

  explicit ListLegacyQueueEventLogsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ListLegacyQueueEventLogsResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ListLegacyQueueEventLogsResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ListLegacyQueueEventLogsResponseBody() = default;
};
class ListLegacyQueueEventLogsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListLegacyQueueEventLogsResponseBody> body{};

  ListLegacyQueueEventLogsResponse() {}

  explicit ListLegacyQueueEventLogsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListLegacyQueueEventLogsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListLegacyQueueEventLogsResponseBody>(model1);
      }
    }
  }


  virtual ~ListLegacyQueueEventLogsResponse() = default;
};
class ListMonoRecordingsRequest : public Darabonba::Model {
public:
  shared_ptr<string> contactId{};
  shared_ptr<string> instanceId{};

  ListMonoRecordingsRequest() {}

  explicit ListMonoRecordingsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contactId) {
      res["ContactId"] = boost::any(*contactId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ContactId") != m.end() && !m["ContactId"].empty()) {
      contactId = make_shared<string>(boost::any_cast<string>(m["ContactId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~ListMonoRecordingsRequest() = default;
};
class ListMonoRecordingsResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> agentId{};
  shared_ptr<string> agentName{};
  shared_ptr<string> contactId{};
  shared_ptr<string> duration{};
  shared_ptr<string> fileName{};
  shared_ptr<string> fileUrl{};
  shared_ptr<string> ramId{};
  shared_ptr<string> skillGroupId{};
  shared_ptr<string> startTime{};

  ListMonoRecordingsResponseBodyData() {}

  explicit ListMonoRecordingsResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agentId) {
      res["AgentId"] = boost::any(*agentId);
    }
    if (agentName) {
      res["AgentName"] = boost::any(*agentName);
    }
    if (contactId) {
      res["ContactId"] = boost::any(*contactId);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (fileName) {
      res["FileName"] = boost::any(*fileName);
    }
    if (fileUrl) {
      res["FileUrl"] = boost::any(*fileUrl);
    }
    if (ramId) {
      res["RamId"] = boost::any(*ramId);
    }
    if (skillGroupId) {
      res["SkillGroupId"] = boost::any(*skillGroupId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AgentId") != m.end() && !m["AgentId"].empty()) {
      agentId = make_shared<string>(boost::any_cast<string>(m["AgentId"]));
    }
    if (m.find("AgentName") != m.end() && !m["AgentName"].empty()) {
      agentName = make_shared<string>(boost::any_cast<string>(m["AgentName"]));
    }
    if (m.find("ContactId") != m.end() && !m["ContactId"].empty()) {
      contactId = make_shared<string>(boost::any_cast<string>(m["ContactId"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("FileName") != m.end() && !m["FileName"].empty()) {
      fileName = make_shared<string>(boost::any_cast<string>(m["FileName"]));
    }
    if (m.find("FileUrl") != m.end() && !m["FileUrl"].empty()) {
      fileUrl = make_shared<string>(boost::any_cast<string>(m["FileUrl"]));
    }
    if (m.find("RamId") != m.end() && !m["RamId"].empty()) {
      ramId = make_shared<string>(boost::any_cast<string>(m["RamId"]));
    }
    if (m.find("SkillGroupId") != m.end() && !m["SkillGroupId"].empty()) {
      skillGroupId = make_shared<string>(boost::any_cast<string>(m["SkillGroupId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
  }


  virtual ~ListMonoRecordingsResponseBodyData() = default;
};
class ListMonoRecordingsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<vector<ListMonoRecordingsResponseBodyData>> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  ListMonoRecordingsResponseBody() {}

  explicit ListMonoRecordingsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<ListMonoRecordingsResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListMonoRecordingsResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<ListMonoRecordingsResponseBodyData>>(expect1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListMonoRecordingsResponseBody() = default;
};
class ListMonoRecordingsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListMonoRecordingsResponseBody> body{};

  ListMonoRecordingsResponse() {}

  explicit ListMonoRecordingsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListMonoRecordingsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListMonoRecordingsResponseBody>(model1);
      }
    }
  }


  virtual ~ListMonoRecordingsResponse() = default;
};
class ListMultiChannelRecordingsRequest : public Darabonba::Model {
public:
  shared_ptr<string> contactId{};
  shared_ptr<string> instanceId{};

  ListMultiChannelRecordingsRequest() {}

  explicit ListMultiChannelRecordingsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contactId) {
      res["ContactId"] = boost::any(*contactId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ContactId") != m.end() && !m["ContactId"].empty()) {
      contactId = make_shared<string>(boost::any_cast<string>(m["ContactId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~ListMultiChannelRecordingsRequest() = default;
};
class ListMultiChannelRecordingsResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> agentChannelId{};
  shared_ptr<string> agentId{};
  shared_ptr<string> agentName{};
  shared_ptr<string> contactId{};
  shared_ptr<string> duration{};
  shared_ptr<string> fileName{};
  shared_ptr<string> fileUrl{};
  shared_ptr<string> ramId{};
  shared_ptr<string> skillGroupId{};
  shared_ptr<long> startTime{};

  ListMultiChannelRecordingsResponseBodyData() {}

  explicit ListMultiChannelRecordingsResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agentChannelId) {
      res["AgentChannelId"] = boost::any(*agentChannelId);
    }
    if (agentId) {
      res["AgentId"] = boost::any(*agentId);
    }
    if (agentName) {
      res["AgentName"] = boost::any(*agentName);
    }
    if (contactId) {
      res["ContactId"] = boost::any(*contactId);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (fileName) {
      res["FileName"] = boost::any(*fileName);
    }
    if (fileUrl) {
      res["FileUrl"] = boost::any(*fileUrl);
    }
    if (ramId) {
      res["RamId"] = boost::any(*ramId);
    }
    if (skillGroupId) {
      res["SkillGroupId"] = boost::any(*skillGroupId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AgentChannelId") != m.end() && !m["AgentChannelId"].empty()) {
      agentChannelId = make_shared<string>(boost::any_cast<string>(m["AgentChannelId"]));
    }
    if (m.find("AgentId") != m.end() && !m["AgentId"].empty()) {
      agentId = make_shared<string>(boost::any_cast<string>(m["AgentId"]));
    }
    if (m.find("AgentName") != m.end() && !m["AgentName"].empty()) {
      agentName = make_shared<string>(boost::any_cast<string>(m["AgentName"]));
    }
    if (m.find("ContactId") != m.end() && !m["ContactId"].empty()) {
      contactId = make_shared<string>(boost::any_cast<string>(m["ContactId"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("FileName") != m.end() && !m["FileName"].empty()) {
      fileName = make_shared<string>(boost::any_cast<string>(m["FileName"]));
    }
    if (m.find("FileUrl") != m.end() && !m["FileUrl"].empty()) {
      fileUrl = make_shared<string>(boost::any_cast<string>(m["FileUrl"]));
    }
    if (m.find("RamId") != m.end() && !m["RamId"].empty()) {
      ramId = make_shared<string>(boost::any_cast<string>(m["RamId"]));
    }
    if (m.find("SkillGroupId") != m.end() && !m["SkillGroupId"].empty()) {
      skillGroupId = make_shared<string>(boost::any_cast<string>(m["SkillGroupId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
  }


  virtual ~ListMultiChannelRecordingsResponseBodyData() = default;
};
class ListMultiChannelRecordingsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<vector<ListMultiChannelRecordingsResponseBodyData>> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  ListMultiChannelRecordingsResponseBody() {}

  explicit ListMultiChannelRecordingsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<ListMultiChannelRecordingsResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListMultiChannelRecordingsResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<ListMultiChannelRecordingsResponseBodyData>>(expect1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListMultiChannelRecordingsResponseBody() = default;
};
class ListMultiChannelRecordingsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListMultiChannelRecordingsResponseBody> body{};

  ListMultiChannelRecordingsResponse() {}

  explicit ListMultiChannelRecordingsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListMultiChannelRecordingsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListMultiChannelRecordingsResponseBody>(model1);
      }
    }
  }


  virtual ~ListMultiChannelRecordingsResponse() = default;
};
class ListOutboundNumbersOfUserRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> skillGroupIdList{};
  shared_ptr<string> userId{};

  ListOutboundNumbersOfUserRequest() {}

  explicit ListOutboundNumbersOfUserRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (skillGroupIdList) {
      res["SkillGroupIdList"] = boost::any(*skillGroupIdList);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SkillGroupIdList") != m.end() && !m["SkillGroupIdList"].empty()) {
      skillGroupIdList = make_shared<string>(boost::any_cast<string>(m["SkillGroupIdList"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~ListOutboundNumbersOfUserRequest() = default;
};
class ListOutboundNumbersOfUserResponseBodyDataList : public Darabonba::Model {
public:
  shared_ptr<string> city{};
  shared_ptr<string> number{};
  shared_ptr<string> province{};

  ListOutboundNumbersOfUserResponseBodyDataList() {}

  explicit ListOutboundNumbersOfUserResponseBodyDataList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (city) {
      res["City"] = boost::any(*city);
    }
    if (number) {
      res["Number"] = boost::any(*number);
    }
    if (province) {
      res["Province"] = boost::any(*province);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("City") != m.end() && !m["City"].empty()) {
      city = make_shared<string>(boost::any_cast<string>(m["City"]));
    }
    if (m.find("Number") != m.end() && !m["Number"].empty()) {
      number = make_shared<string>(boost::any_cast<string>(m["Number"]));
    }
    if (m.find("Province") != m.end() && !m["Province"].empty()) {
      province = make_shared<string>(boost::any_cast<string>(m["Province"]));
    }
  }


  virtual ~ListOutboundNumbersOfUserResponseBodyDataList() = default;
};
class ListOutboundNumbersOfUserResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<ListOutboundNumbersOfUserResponseBodyDataList>> list{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  ListOutboundNumbersOfUserResponseBodyData() {}

  explicit ListOutboundNumbersOfUserResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (list) {
      vector<boost::any> temp1;
      for(auto item1:*list){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["List"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(vector<boost::any>) == m["List"].type()) {
        vector<ListOutboundNumbersOfUserResponseBodyDataList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["List"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListOutboundNumbersOfUserResponseBodyDataList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        list = make_shared<vector<ListOutboundNumbersOfUserResponseBodyDataList>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListOutboundNumbersOfUserResponseBodyData() = default;
};
class ListOutboundNumbersOfUserResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<ListOutboundNumbersOfUserResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  ListOutboundNumbersOfUserResponseBody() {}

  explicit ListOutboundNumbersOfUserResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ListOutboundNumbersOfUserResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ListOutboundNumbersOfUserResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListOutboundNumbersOfUserResponseBody() = default;
};
class ListOutboundNumbersOfUserResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListOutboundNumbersOfUserResponseBody> body{};

  ListOutboundNumbersOfUserResponse() {}

  explicit ListOutboundNumbersOfUserResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListOutboundNumbersOfUserResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListOutboundNumbersOfUserResponseBody>(model1);
      }
    }
  }


  virtual ~ListOutboundNumbersOfUserResponse() = default;
};
class ListPersonalNumbersOfUserRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<bool> isMember{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> searchPattern{};
  shared_ptr<string> userId{};

  ListPersonalNumbersOfUserRequest() {}

  explicit ListPersonalNumbersOfUserRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (isMember) {
      res["IsMember"] = boost::any(*isMember);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (searchPattern) {
      res["SearchPattern"] = boost::any(*searchPattern);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("IsMember") != m.end() && !m["IsMember"].empty()) {
      isMember = make_shared<bool>(boost::any_cast<bool>(m["IsMember"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SearchPattern") != m.end() && !m["SearchPattern"].empty()) {
      searchPattern = make_shared<string>(boost::any_cast<string>(m["SearchPattern"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~ListPersonalNumbersOfUserRequest() = default;
};
class ListPersonalNumbersOfUserResponseBodyDataList : public Darabonba::Model {
public:
  shared_ptr<bool> active{};
  shared_ptr<string> city{};
  shared_ptr<string> contactFlowId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> number{};
  shared_ptr<string> province{};

  ListPersonalNumbersOfUserResponseBodyDataList() {}

  explicit ListPersonalNumbersOfUserResponseBodyDataList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (active) {
      res["Active"] = boost::any(*active);
    }
    if (city) {
      res["City"] = boost::any(*city);
    }
    if (contactFlowId) {
      res["ContactFlowId"] = boost::any(*contactFlowId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (number) {
      res["Number"] = boost::any(*number);
    }
    if (province) {
      res["Province"] = boost::any(*province);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Active") != m.end() && !m["Active"].empty()) {
      active = make_shared<bool>(boost::any_cast<bool>(m["Active"]));
    }
    if (m.find("City") != m.end() && !m["City"].empty()) {
      city = make_shared<string>(boost::any_cast<string>(m["City"]));
    }
    if (m.find("ContactFlowId") != m.end() && !m["ContactFlowId"].empty()) {
      contactFlowId = make_shared<string>(boost::any_cast<string>(m["ContactFlowId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Number") != m.end() && !m["Number"].empty()) {
      number = make_shared<string>(boost::any_cast<string>(m["Number"]));
    }
    if (m.find("Province") != m.end() && !m["Province"].empty()) {
      province = make_shared<string>(boost::any_cast<string>(m["Province"]));
    }
  }


  virtual ~ListPersonalNumbersOfUserResponseBodyDataList() = default;
};
class ListPersonalNumbersOfUserResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<ListPersonalNumbersOfUserResponseBodyDataList>> list{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  ListPersonalNumbersOfUserResponseBodyData() {}

  explicit ListPersonalNumbersOfUserResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (list) {
      vector<boost::any> temp1;
      for(auto item1:*list){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["List"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(vector<boost::any>) == m["List"].type()) {
        vector<ListPersonalNumbersOfUserResponseBodyDataList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["List"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListPersonalNumbersOfUserResponseBodyDataList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        list = make_shared<vector<ListPersonalNumbersOfUserResponseBodyDataList>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListPersonalNumbersOfUserResponseBodyData() = default;
};
class ListPersonalNumbersOfUserResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<ListPersonalNumbersOfUserResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  ListPersonalNumbersOfUserResponseBody() {}

  explicit ListPersonalNumbersOfUserResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ListPersonalNumbersOfUserResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ListPersonalNumbersOfUserResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListPersonalNumbersOfUserResponseBody() = default;
};
class ListPersonalNumbersOfUserResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListPersonalNumbersOfUserResponseBody> body{};

  ListPersonalNumbersOfUserResponse() {}

  explicit ListPersonalNumbersOfUserResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListPersonalNumbersOfUserResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListPersonalNumbersOfUserResponseBody>(model1);
      }
    }
  }


  virtual ~ListPersonalNumbersOfUserResponse() = default;
};
class ListPhoneNumbersRequest : public Darabonba::Model {
public:
  shared_ptr<bool> active{};
  shared_ptr<string> instanceId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> searchPattern{};
  shared_ptr<string> usage{};

  ListPhoneNumbersRequest() {}

  explicit ListPhoneNumbersRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (active) {
      res["Active"] = boost::any(*active);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (searchPattern) {
      res["SearchPattern"] = boost::any(*searchPattern);
    }
    if (usage) {
      res["Usage"] = boost::any(*usage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Active") != m.end() && !m["Active"].empty()) {
      active = make_shared<bool>(boost::any_cast<bool>(m["Active"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SearchPattern") != m.end() && !m["SearchPattern"].empty()) {
      searchPattern = make_shared<string>(boost::any_cast<string>(m["SearchPattern"]));
    }
    if (m.find("Usage") != m.end() && !m["Usage"].empty()) {
      usage = make_shared<string>(boost::any_cast<string>(m["Usage"]));
    }
  }


  virtual ~ListPhoneNumbersRequest() = default;
};
class ListPhoneNumbersResponseBodyDataListSkillGroups : public Darabonba::Model {
public:
  shared_ptr<string> displayName{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> name{};
  shared_ptr<string> skillGroupId{};

  ListPhoneNumbersResponseBodyDataListSkillGroups() {}

  explicit ListPhoneNumbersResponseBodyDataListSkillGroups(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (displayName) {
      res["DisplayName"] = boost::any(*displayName);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (skillGroupId) {
      res["SkillGroupId"] = boost::any(*skillGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DisplayName") != m.end() && !m["DisplayName"].empty()) {
      displayName = make_shared<string>(boost::any_cast<string>(m["DisplayName"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("SkillGroupId") != m.end() && !m["SkillGroupId"].empty()) {
      skillGroupId = make_shared<string>(boost::any_cast<string>(m["SkillGroupId"]));
    }
  }


  virtual ~ListPhoneNumbersResponseBodyDataListSkillGroups() = default;
};
class ListPhoneNumbersResponseBodyDataList : public Darabonba::Model {
public:
  shared_ptr<bool> active{};
  shared_ptr<string> city{};
  shared_ptr<string> contactFlowId{};
  shared_ptr<string> contactFlowName{};
  shared_ptr<string> createTime{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> number{};
  shared_ptr<string> provider{};
  shared_ptr<string> province{};
  shared_ptr<vector<ListPhoneNumbersResponseBodyDataListSkillGroups>> skillGroups{};
  shared_ptr<string> tags{};
  shared_ptr<string> usage{};
  shared_ptr<string> userId{};

  ListPhoneNumbersResponseBodyDataList() {}

  explicit ListPhoneNumbersResponseBodyDataList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (active) {
      res["Active"] = boost::any(*active);
    }
    if (city) {
      res["City"] = boost::any(*city);
    }
    if (contactFlowId) {
      res["ContactFlowId"] = boost::any(*contactFlowId);
    }
    if (contactFlowName) {
      res["ContactFlowName"] = boost::any(*contactFlowName);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (number) {
      res["Number"] = boost::any(*number);
    }
    if (provider) {
      res["Provider"] = boost::any(*provider);
    }
    if (province) {
      res["Province"] = boost::any(*province);
    }
    if (skillGroups) {
      vector<boost::any> temp1;
      for(auto item1:*skillGroups){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SkillGroups"] = boost::any(temp1);
    }
    if (tags) {
      res["Tags"] = boost::any(*tags);
    }
    if (usage) {
      res["Usage"] = boost::any(*usage);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Active") != m.end() && !m["Active"].empty()) {
      active = make_shared<bool>(boost::any_cast<bool>(m["Active"]));
    }
    if (m.find("City") != m.end() && !m["City"].empty()) {
      city = make_shared<string>(boost::any_cast<string>(m["City"]));
    }
    if (m.find("ContactFlowId") != m.end() && !m["ContactFlowId"].empty()) {
      contactFlowId = make_shared<string>(boost::any_cast<string>(m["ContactFlowId"]));
    }
    if (m.find("ContactFlowName") != m.end() && !m["ContactFlowName"].empty()) {
      contactFlowName = make_shared<string>(boost::any_cast<string>(m["ContactFlowName"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Number") != m.end() && !m["Number"].empty()) {
      number = make_shared<string>(boost::any_cast<string>(m["Number"]));
    }
    if (m.find("Provider") != m.end() && !m["Provider"].empty()) {
      provider = make_shared<string>(boost::any_cast<string>(m["Provider"]));
    }
    if (m.find("Province") != m.end() && !m["Province"].empty()) {
      province = make_shared<string>(boost::any_cast<string>(m["Province"]));
    }
    if (m.find("SkillGroups") != m.end() && !m["SkillGroups"].empty()) {
      if (typeid(vector<boost::any>) == m["SkillGroups"].type()) {
        vector<ListPhoneNumbersResponseBodyDataListSkillGroups> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SkillGroups"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListPhoneNumbersResponseBodyDataListSkillGroups model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        skillGroups = make_shared<vector<ListPhoneNumbersResponseBodyDataListSkillGroups>>(expect1);
      }
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      tags = make_shared<string>(boost::any_cast<string>(m["Tags"]));
    }
    if (m.find("Usage") != m.end() && !m["Usage"].empty()) {
      usage = make_shared<string>(boost::any_cast<string>(m["Usage"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~ListPhoneNumbersResponseBodyDataList() = default;
};
class ListPhoneNumbersResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<ListPhoneNumbersResponseBodyDataList>> list{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  ListPhoneNumbersResponseBodyData() {}

  explicit ListPhoneNumbersResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (list) {
      vector<boost::any> temp1;
      for(auto item1:*list){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["List"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(vector<boost::any>) == m["List"].type()) {
        vector<ListPhoneNumbersResponseBodyDataList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["List"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListPhoneNumbersResponseBodyDataList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        list = make_shared<vector<ListPhoneNumbersResponseBodyDataList>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListPhoneNumbersResponseBodyData() = default;
};
class ListPhoneNumbersResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<ListPhoneNumbersResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  ListPhoneNumbersResponseBody() {}

  explicit ListPhoneNumbersResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ListPhoneNumbersResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ListPhoneNumbersResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListPhoneNumbersResponseBody() = default;
};
class ListPhoneNumbersResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListPhoneNumbersResponseBody> body{};

  ListPhoneNumbersResponse() {}

  explicit ListPhoneNumbersResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListPhoneNumbersResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListPhoneNumbersResponseBody>(model1);
      }
    }
  }


  virtual ~ListPhoneNumbersResponse() = default;
};
class ListPhoneNumbersOfSkillGroupRequest : public Darabonba::Model {
public:
  shared_ptr<bool> active{};
  shared_ptr<string> instanceId{};
  shared_ptr<bool> isMember{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> searchPattern{};
  shared_ptr<string> skillGroupId{};

  ListPhoneNumbersOfSkillGroupRequest() {}

  explicit ListPhoneNumbersOfSkillGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (active) {
      res["Active"] = boost::any(*active);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (isMember) {
      res["IsMember"] = boost::any(*isMember);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (searchPattern) {
      res["SearchPattern"] = boost::any(*searchPattern);
    }
    if (skillGroupId) {
      res["SkillGroupId"] = boost::any(*skillGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Active") != m.end() && !m["Active"].empty()) {
      active = make_shared<bool>(boost::any_cast<bool>(m["Active"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("IsMember") != m.end() && !m["IsMember"].empty()) {
      isMember = make_shared<bool>(boost::any_cast<bool>(m["IsMember"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SearchPattern") != m.end() && !m["SearchPattern"].empty()) {
      searchPattern = make_shared<string>(boost::any_cast<string>(m["SearchPattern"]));
    }
    if (m.find("SkillGroupId") != m.end() && !m["SkillGroupId"].empty()) {
      skillGroupId = make_shared<string>(boost::any_cast<string>(m["SkillGroupId"]));
    }
  }


  virtual ~ListPhoneNumbersOfSkillGroupRequest() = default;
};
class ListPhoneNumbersOfSkillGroupResponseBodyDataList : public Darabonba::Model {
public:
  shared_ptr<bool> active{};
  shared_ptr<string> city{};
  shared_ptr<string> contactFlowId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> number{};
  shared_ptr<string> province{};
  shared_ptr<string> usage{};

  ListPhoneNumbersOfSkillGroupResponseBodyDataList() {}

  explicit ListPhoneNumbersOfSkillGroupResponseBodyDataList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (active) {
      res["Active"] = boost::any(*active);
    }
    if (city) {
      res["City"] = boost::any(*city);
    }
    if (contactFlowId) {
      res["ContactFlowId"] = boost::any(*contactFlowId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (number) {
      res["Number"] = boost::any(*number);
    }
    if (province) {
      res["Province"] = boost::any(*province);
    }
    if (usage) {
      res["Usage"] = boost::any(*usage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Active") != m.end() && !m["Active"].empty()) {
      active = make_shared<bool>(boost::any_cast<bool>(m["Active"]));
    }
    if (m.find("City") != m.end() && !m["City"].empty()) {
      city = make_shared<string>(boost::any_cast<string>(m["City"]));
    }
    if (m.find("ContactFlowId") != m.end() && !m["ContactFlowId"].empty()) {
      contactFlowId = make_shared<string>(boost::any_cast<string>(m["ContactFlowId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Number") != m.end() && !m["Number"].empty()) {
      number = make_shared<string>(boost::any_cast<string>(m["Number"]));
    }
    if (m.find("Province") != m.end() && !m["Province"].empty()) {
      province = make_shared<string>(boost::any_cast<string>(m["Province"]));
    }
    if (m.find("Usage") != m.end() && !m["Usage"].empty()) {
      usage = make_shared<string>(boost::any_cast<string>(m["Usage"]));
    }
  }


  virtual ~ListPhoneNumbersOfSkillGroupResponseBodyDataList() = default;
};
class ListPhoneNumbersOfSkillGroupResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<ListPhoneNumbersOfSkillGroupResponseBodyDataList>> list{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  ListPhoneNumbersOfSkillGroupResponseBodyData() {}

  explicit ListPhoneNumbersOfSkillGroupResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (list) {
      vector<boost::any> temp1;
      for(auto item1:*list){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["List"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(vector<boost::any>) == m["List"].type()) {
        vector<ListPhoneNumbersOfSkillGroupResponseBodyDataList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["List"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListPhoneNumbersOfSkillGroupResponseBodyDataList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        list = make_shared<vector<ListPhoneNumbersOfSkillGroupResponseBodyDataList>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListPhoneNumbersOfSkillGroupResponseBodyData() = default;
};
class ListPhoneNumbersOfSkillGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<ListPhoneNumbersOfSkillGroupResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  ListPhoneNumbersOfSkillGroupResponseBody() {}

  explicit ListPhoneNumbersOfSkillGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ListPhoneNumbersOfSkillGroupResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ListPhoneNumbersOfSkillGroupResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListPhoneNumbersOfSkillGroupResponseBody() = default;
};
class ListPhoneNumbersOfSkillGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListPhoneNumbersOfSkillGroupResponseBody> body{};

  ListPhoneNumbersOfSkillGroupResponse() {}

  explicit ListPhoneNumbersOfSkillGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListPhoneNumbersOfSkillGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListPhoneNumbersOfSkillGroupResponseBody>(model1);
      }
    }
  }


  virtual ~ListPhoneNumbersOfSkillGroupResponse() = default;
};
class ListPrivilegesOfUserRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};

  ListPrivilegesOfUserRequest() {}

  explicit ListPrivilegesOfUserRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~ListPrivilegesOfUserRequest() = default;
};
class ListPrivilegesOfUserResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> name{};
  shared_ptr<string> scope{};

  ListPrivilegesOfUserResponseBodyData() {}

  explicit ListPrivilegesOfUserResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (scope) {
      res["Scope"] = boost::any(*scope);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Scope") != m.end() && !m["Scope"].empty()) {
      scope = make_shared<string>(boost::any_cast<string>(m["Scope"]));
    }
  }


  virtual ~ListPrivilegesOfUserResponseBodyData() = default;
};
class ListPrivilegesOfUserResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<vector<ListPrivilegesOfUserResponseBodyData>> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  ListPrivilegesOfUserResponseBody() {}

  explicit ListPrivilegesOfUserResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<ListPrivilegesOfUserResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListPrivilegesOfUserResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<ListPrivilegesOfUserResponseBodyData>>(expect1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListPrivilegesOfUserResponseBody() = default;
};
class ListPrivilegesOfUserResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListPrivilegesOfUserResponseBody> body{};

  ListPrivilegesOfUserResponse() {}

  explicit ListPrivilegesOfUserResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListPrivilegesOfUserResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListPrivilegesOfUserResponseBody>(model1);
      }
    }
  }


  virtual ~ListPrivilegesOfUserResponse() = default;
};
class ListRamUsersRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> searchPattern{};

  ListRamUsersRequest() {}

  explicit ListRamUsersRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (searchPattern) {
      res["SearchPattern"] = boost::any(*searchPattern);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SearchPattern") != m.end() && !m["SearchPattern"].empty()) {
      searchPattern = make_shared<string>(boost::any_cast<string>(m["SearchPattern"]));
    }
  }


  virtual ~ListRamUsersRequest() = default;
};
class ListRamUsersResponseBodyDataList : public Darabonba::Model {
public:
  shared_ptr<long> aliyunUid{};
  shared_ptr<string> displayName{};
  shared_ptr<string> email{};
  shared_ptr<string> loginName{};
  shared_ptr<string> mobile{};
  shared_ptr<bool> primary{};
  shared_ptr<string> ramId{};

  ListRamUsersResponseBodyDataList() {}

  explicit ListRamUsersResponseBodyDataList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aliyunUid) {
      res["AliyunUid"] = boost::any(*aliyunUid);
    }
    if (displayName) {
      res["DisplayName"] = boost::any(*displayName);
    }
    if (email) {
      res["Email"] = boost::any(*email);
    }
    if (loginName) {
      res["LoginName"] = boost::any(*loginName);
    }
    if (mobile) {
      res["Mobile"] = boost::any(*mobile);
    }
    if (primary) {
      res["Primary"] = boost::any(*primary);
    }
    if (ramId) {
      res["RamId"] = boost::any(*ramId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AliyunUid") != m.end() && !m["AliyunUid"].empty()) {
      aliyunUid = make_shared<long>(boost::any_cast<long>(m["AliyunUid"]));
    }
    if (m.find("DisplayName") != m.end() && !m["DisplayName"].empty()) {
      displayName = make_shared<string>(boost::any_cast<string>(m["DisplayName"]));
    }
    if (m.find("Email") != m.end() && !m["Email"].empty()) {
      email = make_shared<string>(boost::any_cast<string>(m["Email"]));
    }
    if (m.find("LoginName") != m.end() && !m["LoginName"].empty()) {
      loginName = make_shared<string>(boost::any_cast<string>(m["LoginName"]));
    }
    if (m.find("Mobile") != m.end() && !m["Mobile"].empty()) {
      mobile = make_shared<string>(boost::any_cast<string>(m["Mobile"]));
    }
    if (m.find("Primary") != m.end() && !m["Primary"].empty()) {
      primary = make_shared<bool>(boost::any_cast<bool>(m["Primary"]));
    }
    if (m.find("RamId") != m.end() && !m["RamId"].empty()) {
      ramId = make_shared<string>(boost::any_cast<string>(m["RamId"]));
    }
  }


  virtual ~ListRamUsersResponseBodyDataList() = default;
};
class ListRamUsersResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<ListRamUsersResponseBodyDataList>> list{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  ListRamUsersResponseBodyData() {}

  explicit ListRamUsersResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (list) {
      vector<boost::any> temp1;
      for(auto item1:*list){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["List"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(vector<boost::any>) == m["List"].type()) {
        vector<ListRamUsersResponseBodyDataList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["List"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListRamUsersResponseBodyDataList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        list = make_shared<vector<ListRamUsersResponseBodyDataList>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListRamUsersResponseBodyData() = default;
};
class ListRamUsersResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<ListRamUsersResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  ListRamUsersResponseBody() {}

  explicit ListRamUsersResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ListRamUsersResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ListRamUsersResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListRamUsersResponseBody() = default;
};
class ListRamUsersResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListRamUsersResponseBody> body{};

  ListRamUsersResponse() {}

  explicit ListRamUsersResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListRamUsersResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListRamUsersResponseBody>(model1);
      }
    }
  }


  virtual ~ListRamUsersResponse() = default;
};
class ListRealtimeAgentStatesRequest : public Darabonba::Model {
public:
  shared_ptr<string> agentIdList{};
  shared_ptr<string> agentName{};
  shared_ptr<string> callTypeList{};
  shared_ptr<string> instanceId{};
  shared_ptr<bool> outboundScenario{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> query{};
  shared_ptr<string> skillGroupId{};
  shared_ptr<string> stateList{};
  shared_ptr<string> workModeList{};

  ListRealtimeAgentStatesRequest() {}

  explicit ListRealtimeAgentStatesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agentIdList) {
      res["AgentIdList"] = boost::any(*agentIdList);
    }
    if (agentName) {
      res["AgentName"] = boost::any(*agentName);
    }
    if (callTypeList) {
      res["CallTypeList"] = boost::any(*callTypeList);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (outboundScenario) {
      res["OutboundScenario"] = boost::any(*outboundScenario);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (query) {
      res["Query"] = boost::any(*query);
    }
    if (skillGroupId) {
      res["SkillGroupId"] = boost::any(*skillGroupId);
    }
    if (stateList) {
      res["StateList"] = boost::any(*stateList);
    }
    if (workModeList) {
      res["WorkModeList"] = boost::any(*workModeList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AgentIdList") != m.end() && !m["AgentIdList"].empty()) {
      agentIdList = make_shared<string>(boost::any_cast<string>(m["AgentIdList"]));
    }
    if (m.find("AgentName") != m.end() && !m["AgentName"].empty()) {
      agentName = make_shared<string>(boost::any_cast<string>(m["AgentName"]));
    }
    if (m.find("CallTypeList") != m.end() && !m["CallTypeList"].empty()) {
      callTypeList = make_shared<string>(boost::any_cast<string>(m["CallTypeList"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("OutboundScenario") != m.end() && !m["OutboundScenario"].empty()) {
      outboundScenario = make_shared<bool>(boost::any_cast<bool>(m["OutboundScenario"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Query") != m.end() && !m["Query"].empty()) {
      query = make_shared<string>(boost::any_cast<string>(m["Query"]));
    }
    if (m.find("SkillGroupId") != m.end() && !m["SkillGroupId"].empty()) {
      skillGroupId = make_shared<string>(boost::any_cast<string>(m["SkillGroupId"]));
    }
    if (m.find("StateList") != m.end() && !m["StateList"].empty()) {
      stateList = make_shared<string>(boost::any_cast<string>(m["StateList"]));
    }
    if (m.find("WorkModeList") != m.end() && !m["WorkModeList"].empty()) {
      workModeList = make_shared<string>(boost::any_cast<string>(m["WorkModeList"]));
    }
  }


  virtual ~ListRealtimeAgentStatesRequest() = default;
};
class ListRealtimeAgentStatesResponseBodyDataList : public Darabonba::Model {
public:
  shared_ptr<string> agentId{};
  shared_ptr<string> agentName{};
  shared_ptr<string> callType{};
  shared_ptr<string> counterParty{};
  shared_ptr<long> duration{};
  shared_ptr<string> extension{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> mobile{};
  shared_ptr<bool> outboundScenario{};
  shared_ptr<vector<string>> skillGroupIdList{};
  shared_ptr<vector<string>> skillGroupNameList{};
  shared_ptr<string> state{};
  shared_ptr<string> stateCode{};
  shared_ptr<long> stateTime{};
  shared_ptr<string> workMode{};

  ListRealtimeAgentStatesResponseBodyDataList() {}

  explicit ListRealtimeAgentStatesResponseBodyDataList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agentId) {
      res["AgentId"] = boost::any(*agentId);
    }
    if (agentName) {
      res["AgentName"] = boost::any(*agentName);
    }
    if (callType) {
      res["CallType"] = boost::any(*callType);
    }
    if (counterParty) {
      res["CounterParty"] = boost::any(*counterParty);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (extension) {
      res["Extension"] = boost::any(*extension);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (mobile) {
      res["Mobile"] = boost::any(*mobile);
    }
    if (outboundScenario) {
      res["OutboundScenario"] = boost::any(*outboundScenario);
    }
    if (skillGroupIdList) {
      res["SkillGroupIdList"] = boost::any(*skillGroupIdList);
    }
    if (skillGroupNameList) {
      res["SkillGroupNameList"] = boost::any(*skillGroupNameList);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (stateCode) {
      res["StateCode"] = boost::any(*stateCode);
    }
    if (stateTime) {
      res["StateTime"] = boost::any(*stateTime);
    }
    if (workMode) {
      res["WorkMode"] = boost::any(*workMode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AgentId") != m.end() && !m["AgentId"].empty()) {
      agentId = make_shared<string>(boost::any_cast<string>(m["AgentId"]));
    }
    if (m.find("AgentName") != m.end() && !m["AgentName"].empty()) {
      agentName = make_shared<string>(boost::any_cast<string>(m["AgentName"]));
    }
    if (m.find("CallType") != m.end() && !m["CallType"].empty()) {
      callType = make_shared<string>(boost::any_cast<string>(m["CallType"]));
    }
    if (m.find("CounterParty") != m.end() && !m["CounterParty"].empty()) {
      counterParty = make_shared<string>(boost::any_cast<string>(m["CounterParty"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<long>(boost::any_cast<long>(m["Duration"]));
    }
    if (m.find("Extension") != m.end() && !m["Extension"].empty()) {
      extension = make_shared<string>(boost::any_cast<string>(m["Extension"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Mobile") != m.end() && !m["Mobile"].empty()) {
      mobile = make_shared<string>(boost::any_cast<string>(m["Mobile"]));
    }
    if (m.find("OutboundScenario") != m.end() && !m["OutboundScenario"].empty()) {
      outboundScenario = make_shared<bool>(boost::any_cast<bool>(m["OutboundScenario"]));
    }
    if (m.find("SkillGroupIdList") != m.end() && !m["SkillGroupIdList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SkillGroupIdList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SkillGroupIdList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      skillGroupIdList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("SkillGroupNameList") != m.end() && !m["SkillGroupNameList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SkillGroupNameList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SkillGroupNameList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      skillGroupNameList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("StateCode") != m.end() && !m["StateCode"].empty()) {
      stateCode = make_shared<string>(boost::any_cast<string>(m["StateCode"]));
    }
    if (m.find("StateTime") != m.end() && !m["StateTime"].empty()) {
      stateTime = make_shared<long>(boost::any_cast<long>(m["StateTime"]));
    }
    if (m.find("WorkMode") != m.end() && !m["WorkMode"].empty()) {
      workMode = make_shared<string>(boost::any_cast<string>(m["WorkMode"]));
    }
  }


  virtual ~ListRealtimeAgentStatesResponseBodyDataList() = default;
};
class ListRealtimeAgentStatesResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<ListRealtimeAgentStatesResponseBodyDataList>> list{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  ListRealtimeAgentStatesResponseBodyData() {}

  explicit ListRealtimeAgentStatesResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (list) {
      vector<boost::any> temp1;
      for(auto item1:*list){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["List"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(vector<boost::any>) == m["List"].type()) {
        vector<ListRealtimeAgentStatesResponseBodyDataList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["List"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListRealtimeAgentStatesResponseBodyDataList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        list = make_shared<vector<ListRealtimeAgentStatesResponseBodyDataList>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListRealtimeAgentStatesResponseBodyData() = default;
};
class ListRealtimeAgentStatesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<ListRealtimeAgentStatesResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  ListRealtimeAgentStatesResponseBody() {}

  explicit ListRealtimeAgentStatesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ListRealtimeAgentStatesResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ListRealtimeAgentStatesResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListRealtimeAgentStatesResponseBody() = default;
};
class ListRealtimeAgentStatesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListRealtimeAgentStatesResponseBody> body{};

  ListRealtimeAgentStatesResponse() {}

  explicit ListRealtimeAgentStatesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListRealtimeAgentStatesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListRealtimeAgentStatesResponseBody>(model1);
      }
    }
  }


  virtual ~ListRealtimeAgentStatesResponse() = default;
};
class ListRealtimeSkillGroupStatesRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> skillGroupIdList{};

  ListRealtimeSkillGroupStatesRequest() {}

  explicit ListRealtimeSkillGroupStatesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (skillGroupIdList) {
      res["SkillGroupIdList"] = boost::any(*skillGroupIdList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SkillGroupIdList") != m.end() && !m["SkillGroupIdList"].empty()) {
      skillGroupIdList = make_shared<string>(boost::any_cast<string>(m["SkillGroupIdList"]));
    }
  }


  virtual ~ListRealtimeSkillGroupStatesRequest() = default;
};
class ListRealtimeSkillGroupStatesResponseBodyDataList : public Darabonba::Model {
public:
  shared_ptr<long> breakingAgents{};
  shared_ptr<string> instanceId{};
  shared_ptr<long> loggedInAgents{};
  shared_ptr<long> longestWaitingTime{};
  shared_ptr<long> outboundScenarioReadyAgents{};
  shared_ptr<long> readyAgents{};
  shared_ptr<string> skillGroupId{};
  shared_ptr<string> skillGroupName{};
  shared_ptr<long> talkingAgents{};
  shared_ptr<long> waitingCalls{};
  shared_ptr<long> workingAgents{};

  ListRealtimeSkillGroupStatesResponseBodyDataList() {}

  explicit ListRealtimeSkillGroupStatesResponseBodyDataList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (breakingAgents) {
      res["BreakingAgents"] = boost::any(*breakingAgents);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (loggedInAgents) {
      res["LoggedInAgents"] = boost::any(*loggedInAgents);
    }
    if (longestWaitingTime) {
      res["LongestWaitingTime"] = boost::any(*longestWaitingTime);
    }
    if (outboundScenarioReadyAgents) {
      res["OutboundScenarioReadyAgents"] = boost::any(*outboundScenarioReadyAgents);
    }
    if (readyAgents) {
      res["ReadyAgents"] = boost::any(*readyAgents);
    }
    if (skillGroupId) {
      res["SkillGroupId"] = boost::any(*skillGroupId);
    }
    if (skillGroupName) {
      res["SkillGroupName"] = boost::any(*skillGroupName);
    }
    if (talkingAgents) {
      res["TalkingAgents"] = boost::any(*talkingAgents);
    }
    if (waitingCalls) {
      res["WaitingCalls"] = boost::any(*waitingCalls);
    }
    if (workingAgents) {
      res["WorkingAgents"] = boost::any(*workingAgents);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BreakingAgents") != m.end() && !m["BreakingAgents"].empty()) {
      breakingAgents = make_shared<long>(boost::any_cast<long>(m["BreakingAgents"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("LoggedInAgents") != m.end() && !m["LoggedInAgents"].empty()) {
      loggedInAgents = make_shared<long>(boost::any_cast<long>(m["LoggedInAgents"]));
    }
    if (m.find("LongestWaitingTime") != m.end() && !m["LongestWaitingTime"].empty()) {
      longestWaitingTime = make_shared<long>(boost::any_cast<long>(m["LongestWaitingTime"]));
    }
    if (m.find("OutboundScenarioReadyAgents") != m.end() && !m["OutboundScenarioReadyAgents"].empty()) {
      outboundScenarioReadyAgents = make_shared<long>(boost::any_cast<long>(m["OutboundScenarioReadyAgents"]));
    }
    if (m.find("ReadyAgents") != m.end() && !m["ReadyAgents"].empty()) {
      readyAgents = make_shared<long>(boost::any_cast<long>(m["ReadyAgents"]));
    }
    if (m.find("SkillGroupId") != m.end() && !m["SkillGroupId"].empty()) {
      skillGroupId = make_shared<string>(boost::any_cast<string>(m["SkillGroupId"]));
    }
    if (m.find("SkillGroupName") != m.end() && !m["SkillGroupName"].empty()) {
      skillGroupName = make_shared<string>(boost::any_cast<string>(m["SkillGroupName"]));
    }
    if (m.find("TalkingAgents") != m.end() && !m["TalkingAgents"].empty()) {
      talkingAgents = make_shared<long>(boost::any_cast<long>(m["TalkingAgents"]));
    }
    if (m.find("WaitingCalls") != m.end() && !m["WaitingCalls"].empty()) {
      waitingCalls = make_shared<long>(boost::any_cast<long>(m["WaitingCalls"]));
    }
    if (m.find("WorkingAgents") != m.end() && !m["WorkingAgents"].empty()) {
      workingAgents = make_shared<long>(boost::any_cast<long>(m["WorkingAgents"]));
    }
  }


  virtual ~ListRealtimeSkillGroupStatesResponseBodyDataList() = default;
};
class ListRealtimeSkillGroupStatesResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<ListRealtimeSkillGroupStatesResponseBodyDataList>> list{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  ListRealtimeSkillGroupStatesResponseBodyData() {}

  explicit ListRealtimeSkillGroupStatesResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (list) {
      vector<boost::any> temp1;
      for(auto item1:*list){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["List"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(vector<boost::any>) == m["List"].type()) {
        vector<ListRealtimeSkillGroupStatesResponseBodyDataList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["List"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListRealtimeSkillGroupStatesResponseBodyDataList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        list = make_shared<vector<ListRealtimeSkillGroupStatesResponseBodyDataList>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListRealtimeSkillGroupStatesResponseBodyData() = default;
};
class ListRealtimeSkillGroupStatesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<ListRealtimeSkillGroupStatesResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  ListRealtimeSkillGroupStatesResponseBody() {}

  explicit ListRealtimeSkillGroupStatesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ListRealtimeSkillGroupStatesResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ListRealtimeSkillGroupStatesResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListRealtimeSkillGroupStatesResponseBody() = default;
};
class ListRealtimeSkillGroupStatesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListRealtimeSkillGroupStatesResponseBody> body{};

  ListRealtimeSkillGroupStatesResponse() {}

  explicit ListRealtimeSkillGroupStatesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListRealtimeSkillGroupStatesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListRealtimeSkillGroupStatesResponseBody>(model1);
      }
    }
  }


  virtual ~ListRealtimeSkillGroupStatesResponse() = default;
};
class ListRecentCallDetailRecordsRequest : public Darabonba::Model {
public:
  shared_ptr<string> criteria{};
  shared_ptr<long> endTime{};
  shared_ptr<string> instanceId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> startTime{};

  ListRecentCallDetailRecordsRequest() {}

  explicit ListRecentCallDetailRecordsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (criteria) {
      res["Criteria"] = boost::any(*criteria);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Criteria") != m.end() && !m["Criteria"].empty()) {
      criteria = make_shared<string>(boost::any_cast<string>(m["Criteria"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
  }


  virtual ~ListRecentCallDetailRecordsRequest() = default;
};
class ListRecentCallDetailRecordsResponseBodyDataList : public Darabonba::Model {
public:
  shared_ptr<string> agentIds{};
  shared_ptr<string> callDuration{};
  shared_ptr<string> calledNumber{};
  shared_ptr<string> callingNumber{};
  shared_ptr<string> contactDisposition{};
  shared_ptr<string> contactId{};
  shared_ptr<string> contactType{};
  shared_ptr<long> duration{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> skillGroupIds{};
  shared_ptr<long> startTime{};

  ListRecentCallDetailRecordsResponseBodyDataList() {}

  explicit ListRecentCallDetailRecordsResponseBodyDataList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agentIds) {
      res["AgentIds"] = boost::any(*agentIds);
    }
    if (callDuration) {
      res["CallDuration"] = boost::any(*callDuration);
    }
    if (calledNumber) {
      res["CalledNumber"] = boost::any(*calledNumber);
    }
    if (callingNumber) {
      res["CallingNumber"] = boost::any(*callingNumber);
    }
    if (contactDisposition) {
      res["ContactDisposition"] = boost::any(*contactDisposition);
    }
    if (contactId) {
      res["ContactId"] = boost::any(*contactId);
    }
    if (contactType) {
      res["ContactType"] = boost::any(*contactType);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (skillGroupIds) {
      res["SkillGroupIds"] = boost::any(*skillGroupIds);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AgentIds") != m.end() && !m["AgentIds"].empty()) {
      agentIds = make_shared<string>(boost::any_cast<string>(m["AgentIds"]));
    }
    if (m.find("CallDuration") != m.end() && !m["CallDuration"].empty()) {
      callDuration = make_shared<string>(boost::any_cast<string>(m["CallDuration"]));
    }
    if (m.find("CalledNumber") != m.end() && !m["CalledNumber"].empty()) {
      calledNumber = make_shared<string>(boost::any_cast<string>(m["CalledNumber"]));
    }
    if (m.find("CallingNumber") != m.end() && !m["CallingNumber"].empty()) {
      callingNumber = make_shared<string>(boost::any_cast<string>(m["CallingNumber"]));
    }
    if (m.find("ContactDisposition") != m.end() && !m["ContactDisposition"].empty()) {
      contactDisposition = make_shared<string>(boost::any_cast<string>(m["ContactDisposition"]));
    }
    if (m.find("ContactId") != m.end() && !m["ContactId"].empty()) {
      contactId = make_shared<string>(boost::any_cast<string>(m["ContactId"]));
    }
    if (m.find("ContactType") != m.end() && !m["ContactType"].empty()) {
      contactType = make_shared<string>(boost::any_cast<string>(m["ContactType"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<long>(boost::any_cast<long>(m["Duration"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("SkillGroupIds") != m.end() && !m["SkillGroupIds"].empty()) {
      skillGroupIds = make_shared<string>(boost::any_cast<string>(m["SkillGroupIds"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
  }


  virtual ~ListRecentCallDetailRecordsResponseBodyDataList() = default;
};
class ListRecentCallDetailRecordsResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<ListRecentCallDetailRecordsResponseBodyDataList>> list{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  ListRecentCallDetailRecordsResponseBodyData() {}

  explicit ListRecentCallDetailRecordsResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (list) {
      vector<boost::any> temp1;
      for(auto item1:*list){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["List"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(vector<boost::any>) == m["List"].type()) {
        vector<ListRecentCallDetailRecordsResponseBodyDataList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["List"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListRecentCallDetailRecordsResponseBodyDataList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        list = make_shared<vector<ListRecentCallDetailRecordsResponseBodyDataList>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListRecentCallDetailRecordsResponseBodyData() = default;
};
class ListRecentCallDetailRecordsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<ListRecentCallDetailRecordsResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  ListRecentCallDetailRecordsResponseBody() {}

  explicit ListRecentCallDetailRecordsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ListRecentCallDetailRecordsResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ListRecentCallDetailRecordsResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListRecentCallDetailRecordsResponseBody() = default;
};
class ListRecentCallDetailRecordsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListRecentCallDetailRecordsResponseBody> body{};

  ListRecentCallDetailRecordsResponse() {}

  explicit ListRecentCallDetailRecordsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListRecentCallDetailRecordsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListRecentCallDetailRecordsResponseBody>(model1);
      }
    }
  }


  virtual ~ListRecentCallDetailRecordsResponse() = default;
};
class ListRolesRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};

  ListRolesRequest() {}

  explicit ListRolesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~ListRolesRequest() = default;
};
class ListRolesResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> roleId{};

  ListRolesResponseBodyData() {}

  explicit ListRolesResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (roleId) {
      res["RoleId"] = boost::any(*roleId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("RoleId") != m.end() && !m["RoleId"].empty()) {
      roleId = make_shared<string>(boost::any_cast<string>(m["RoleId"]));
    }
  }


  virtual ~ListRolesResponseBodyData() = default;
};
class ListRolesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<vector<ListRolesResponseBodyData>> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  ListRolesResponseBody() {}

  explicit ListRolesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<ListRolesResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListRolesResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<ListRolesResponseBodyData>>(expect1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListRolesResponseBody() = default;
};
class ListRolesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListRolesResponseBody> body{};

  ListRolesResponse() {}

  explicit ListRolesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListRolesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListRolesResponseBody>(model1);
      }
    }
  }


  virtual ~ListRolesResponse() = default;
};
class ListSkillGroupStatesRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> skillGroupIds{};

  ListSkillGroupStatesRequest() {}

  explicit ListSkillGroupStatesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (skillGroupIds) {
      res["SkillGroupIds"] = boost::any(*skillGroupIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SkillGroupIds") != m.end() && !m["SkillGroupIds"].empty()) {
      skillGroupIds = make_shared<string>(boost::any_cast<string>(m["SkillGroupIds"]));
    }
  }


  virtual ~ListSkillGroupStatesRequest() = default;
};
class ListSkillGroupStatesResponseBodyDataList : public Darabonba::Model {
public:
  shared_ptr<long> averageWaitingTime{};
  shared_ptr<long> breakingAgents{};
  shared_ptr<long> inboundTalkingAgents{};
  shared_ptr<string> instanceId{};
  shared_ptr<long> loggedInAgents{};
  shared_ptr<long> longestCall{};
  shared_ptr<long> outboundScenarioReadyAgents{};
  shared_ptr<long> outboundTalkingAgents{};
  shared_ptr<long> readyAgents{};
  shared_ptr<string> skillGroupId{};
  shared_ptr<string> skillGroupName{};
  shared_ptr<long> talkingAgents{};
  shared_ptr<long> waitingCalls{};
  shared_ptr<long> waitingCallsLevel10{};
  shared_ptr<long> waitingCallsLevel20{};
  shared_ptr<long> waitingCallsLevel30{};
  shared_ptr<long> workingAgents{};

  ListSkillGroupStatesResponseBodyDataList() {}

  explicit ListSkillGroupStatesResponseBodyDataList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (averageWaitingTime) {
      res["AverageWaitingTime"] = boost::any(*averageWaitingTime);
    }
    if (breakingAgents) {
      res["BreakingAgents"] = boost::any(*breakingAgents);
    }
    if (inboundTalkingAgents) {
      res["InboundTalkingAgents"] = boost::any(*inboundTalkingAgents);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (loggedInAgents) {
      res["LoggedInAgents"] = boost::any(*loggedInAgents);
    }
    if (longestCall) {
      res["LongestCall"] = boost::any(*longestCall);
    }
    if (outboundScenarioReadyAgents) {
      res["OutboundScenarioReadyAgents"] = boost::any(*outboundScenarioReadyAgents);
    }
    if (outboundTalkingAgents) {
      res["OutboundTalkingAgents"] = boost::any(*outboundTalkingAgents);
    }
    if (readyAgents) {
      res["ReadyAgents"] = boost::any(*readyAgents);
    }
    if (skillGroupId) {
      res["SkillGroupId"] = boost::any(*skillGroupId);
    }
    if (skillGroupName) {
      res["SkillGroupName"] = boost::any(*skillGroupName);
    }
    if (talkingAgents) {
      res["TalkingAgents"] = boost::any(*talkingAgents);
    }
    if (waitingCalls) {
      res["WaitingCalls"] = boost::any(*waitingCalls);
    }
    if (waitingCallsLevel10) {
      res["WaitingCallsLevel10"] = boost::any(*waitingCallsLevel10);
    }
    if (waitingCallsLevel20) {
      res["WaitingCallsLevel20"] = boost::any(*waitingCallsLevel20);
    }
    if (waitingCallsLevel30) {
      res["WaitingCallsLevel30"] = boost::any(*waitingCallsLevel30);
    }
    if (workingAgents) {
      res["WorkingAgents"] = boost::any(*workingAgents);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AverageWaitingTime") != m.end() && !m["AverageWaitingTime"].empty()) {
      averageWaitingTime = make_shared<long>(boost::any_cast<long>(m["AverageWaitingTime"]));
    }
    if (m.find("BreakingAgents") != m.end() && !m["BreakingAgents"].empty()) {
      breakingAgents = make_shared<long>(boost::any_cast<long>(m["BreakingAgents"]));
    }
    if (m.find("InboundTalkingAgents") != m.end() && !m["InboundTalkingAgents"].empty()) {
      inboundTalkingAgents = make_shared<long>(boost::any_cast<long>(m["InboundTalkingAgents"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("LoggedInAgents") != m.end() && !m["LoggedInAgents"].empty()) {
      loggedInAgents = make_shared<long>(boost::any_cast<long>(m["LoggedInAgents"]));
    }
    if (m.find("LongestCall") != m.end() && !m["LongestCall"].empty()) {
      longestCall = make_shared<long>(boost::any_cast<long>(m["LongestCall"]));
    }
    if (m.find("OutboundScenarioReadyAgents") != m.end() && !m["OutboundScenarioReadyAgents"].empty()) {
      outboundScenarioReadyAgents = make_shared<long>(boost::any_cast<long>(m["OutboundScenarioReadyAgents"]));
    }
    if (m.find("OutboundTalkingAgents") != m.end() && !m["OutboundTalkingAgents"].empty()) {
      outboundTalkingAgents = make_shared<long>(boost::any_cast<long>(m["OutboundTalkingAgents"]));
    }
    if (m.find("ReadyAgents") != m.end() && !m["ReadyAgents"].empty()) {
      readyAgents = make_shared<long>(boost::any_cast<long>(m["ReadyAgents"]));
    }
    if (m.find("SkillGroupId") != m.end() && !m["SkillGroupId"].empty()) {
      skillGroupId = make_shared<string>(boost::any_cast<string>(m["SkillGroupId"]));
    }
    if (m.find("SkillGroupName") != m.end() && !m["SkillGroupName"].empty()) {
      skillGroupName = make_shared<string>(boost::any_cast<string>(m["SkillGroupName"]));
    }
    if (m.find("TalkingAgents") != m.end() && !m["TalkingAgents"].empty()) {
      talkingAgents = make_shared<long>(boost::any_cast<long>(m["TalkingAgents"]));
    }
    if (m.find("WaitingCalls") != m.end() && !m["WaitingCalls"].empty()) {
      waitingCalls = make_shared<long>(boost::any_cast<long>(m["WaitingCalls"]));
    }
    if (m.find("WaitingCallsLevel10") != m.end() && !m["WaitingCallsLevel10"].empty()) {
      waitingCallsLevel10 = make_shared<long>(boost::any_cast<long>(m["WaitingCallsLevel10"]));
    }
    if (m.find("WaitingCallsLevel20") != m.end() && !m["WaitingCallsLevel20"].empty()) {
      waitingCallsLevel20 = make_shared<long>(boost::any_cast<long>(m["WaitingCallsLevel20"]));
    }
    if (m.find("WaitingCallsLevel30") != m.end() && !m["WaitingCallsLevel30"].empty()) {
      waitingCallsLevel30 = make_shared<long>(boost::any_cast<long>(m["WaitingCallsLevel30"]));
    }
    if (m.find("WorkingAgents") != m.end() && !m["WorkingAgents"].empty()) {
      workingAgents = make_shared<long>(boost::any_cast<long>(m["WorkingAgents"]));
    }
  }


  virtual ~ListSkillGroupStatesResponseBodyDataList() = default;
};
class ListSkillGroupStatesResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<ListSkillGroupStatesResponseBodyDataList>> list{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  ListSkillGroupStatesResponseBodyData() {}

  explicit ListSkillGroupStatesResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (list) {
      vector<boost::any> temp1;
      for(auto item1:*list){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["List"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(vector<boost::any>) == m["List"].type()) {
        vector<ListSkillGroupStatesResponseBodyDataList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["List"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListSkillGroupStatesResponseBodyDataList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        list = make_shared<vector<ListSkillGroupStatesResponseBodyDataList>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListSkillGroupStatesResponseBodyData() = default;
};
class ListSkillGroupStatesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<ListSkillGroupStatesResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ListSkillGroupStatesResponseBody() {}

  explicit ListSkillGroupStatesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ListSkillGroupStatesResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ListSkillGroupStatesResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ListSkillGroupStatesResponseBody() = default;
};
class ListSkillGroupStatesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListSkillGroupStatesResponseBody> body{};

  ListSkillGroupStatesResponse() {}

  explicit ListSkillGroupStatesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListSkillGroupStatesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListSkillGroupStatesResponseBody>(model1);
      }
    }
  }


  virtual ~ListSkillGroupStatesResponse() = default;
};
class ListSkillGroupSummaryReportsSinceMidnightRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> skillGroups{};

  ListSkillGroupSummaryReportsSinceMidnightRequest() {}

  explicit ListSkillGroupSummaryReportsSinceMidnightRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (skillGroups) {
      res["SkillGroups"] = boost::any(*skillGroups);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SkillGroups") != m.end() && !m["SkillGroups"].empty()) {
      skillGroups = make_shared<string>(boost::any_cast<string>(m["SkillGroups"]));
    }
  }


  virtual ~ListSkillGroupSummaryReportsSinceMidnightRequest() = default;
};
class ListSkillGroupSummaryReportsSinceMidnightResponseBodyPagedSkillGroupSummaryReportListInbound : public Darabonba::Model {
public:
  shared_ptr<long> abandonedInQueueOfQueueCount{};
  shared_ptr<long> answeredByAgentOfQueueCount{};
  shared_ptr<long> answeredByAgentOfQueueMaxWaitTimeDuration{};
  shared_ptr<long> answeredByAgentOfQueueWaitTimeDuration{};
  shared_ptr<long> averageRingTime{};
  shared_ptr<long> averageTalkTime{};
  shared_ptr<long> averageWorkTime{};
  shared_ptr<long> callsAttendedTransferOut{};
  shared_ptr<long> callsBlindTransferOut{};
  shared_ptr<long> callsHandled{};
  shared_ptr<long> callsOffered{};
  shared_ptr<long> callsServiceLevel10{};
  shared_ptr<long> callsServiceLevel20{};
  shared_ptr<long> callsServiceLevel30{};
  shared_ptr<long> giveUpByAgentOfQueueCount{};
  shared_ptr<double> handleRate{};
  shared_ptr<long> inComingQueueOfQueueCount{};
  shared_ptr<long> maxRingTime{};
  shared_ptr<string> maxTalkTime{};
  shared_ptr<long> maxWorkTime{};
  shared_ptr<long> overFlowInQueueOfQueueCount{};
  shared_ptr<long> queueMaxWaitTimeDuration{};
  shared_ptr<long> queueWaitTimeDuration{};
  shared_ptr<double> satisfactionIndex{};
  shared_ptr<long> satisfactionSurveysOffered{};
  shared_ptr<long> satisfactionSurveysResponded{};
  shared_ptr<double> serviceLevel20{};
  shared_ptr<long> totalRingTime{};
  shared_ptr<long> totalTalkTime{};
  shared_ptr<long> totalWorkTime{};

  ListSkillGroupSummaryReportsSinceMidnightResponseBodyPagedSkillGroupSummaryReportListInbound() {}

  explicit ListSkillGroupSummaryReportsSinceMidnightResponseBodyPagedSkillGroupSummaryReportListInbound(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (abandonedInQueueOfQueueCount) {
      res["AbandonedInQueueOfQueueCount"] = boost::any(*abandonedInQueueOfQueueCount);
    }
    if (answeredByAgentOfQueueCount) {
      res["AnsweredByAgentOfQueueCount"] = boost::any(*answeredByAgentOfQueueCount);
    }
    if (answeredByAgentOfQueueMaxWaitTimeDuration) {
      res["AnsweredByAgentOfQueueMaxWaitTimeDuration"] = boost::any(*answeredByAgentOfQueueMaxWaitTimeDuration);
    }
    if (answeredByAgentOfQueueWaitTimeDuration) {
      res["AnsweredByAgentOfQueueWaitTimeDuration"] = boost::any(*answeredByAgentOfQueueWaitTimeDuration);
    }
    if (averageRingTime) {
      res["AverageRingTime"] = boost::any(*averageRingTime);
    }
    if (averageTalkTime) {
      res["AverageTalkTime"] = boost::any(*averageTalkTime);
    }
    if (averageWorkTime) {
      res["AverageWorkTime"] = boost::any(*averageWorkTime);
    }
    if (callsAttendedTransferOut) {
      res["CallsAttendedTransferOut"] = boost::any(*callsAttendedTransferOut);
    }
    if (callsBlindTransferOut) {
      res["CallsBlindTransferOut"] = boost::any(*callsBlindTransferOut);
    }
    if (callsHandled) {
      res["CallsHandled"] = boost::any(*callsHandled);
    }
    if (callsOffered) {
      res["CallsOffered"] = boost::any(*callsOffered);
    }
    if (callsServiceLevel10) {
      res["CallsServiceLevel10"] = boost::any(*callsServiceLevel10);
    }
    if (callsServiceLevel20) {
      res["CallsServiceLevel20"] = boost::any(*callsServiceLevel20);
    }
    if (callsServiceLevel30) {
      res["CallsServiceLevel30"] = boost::any(*callsServiceLevel30);
    }
    if (giveUpByAgentOfQueueCount) {
      res["GiveUpByAgentOfQueueCount"] = boost::any(*giveUpByAgentOfQueueCount);
    }
    if (handleRate) {
      res["HandleRate"] = boost::any(*handleRate);
    }
    if (inComingQueueOfQueueCount) {
      res["InComingQueueOfQueueCount"] = boost::any(*inComingQueueOfQueueCount);
    }
    if (maxRingTime) {
      res["MaxRingTime"] = boost::any(*maxRingTime);
    }
    if (maxTalkTime) {
      res["MaxTalkTime"] = boost::any(*maxTalkTime);
    }
    if (maxWorkTime) {
      res["MaxWorkTime"] = boost::any(*maxWorkTime);
    }
    if (overFlowInQueueOfQueueCount) {
      res["OverFlowInQueueOfQueueCount"] = boost::any(*overFlowInQueueOfQueueCount);
    }
    if (queueMaxWaitTimeDuration) {
      res["QueueMaxWaitTimeDuration"] = boost::any(*queueMaxWaitTimeDuration);
    }
    if (queueWaitTimeDuration) {
      res["QueueWaitTimeDuration"] = boost::any(*queueWaitTimeDuration);
    }
    if (satisfactionIndex) {
      res["SatisfactionIndex"] = boost::any(*satisfactionIndex);
    }
    if (satisfactionSurveysOffered) {
      res["SatisfactionSurveysOffered"] = boost::any(*satisfactionSurveysOffered);
    }
    if (satisfactionSurveysResponded) {
      res["SatisfactionSurveysResponded"] = boost::any(*satisfactionSurveysResponded);
    }
    if (serviceLevel20) {
      res["ServiceLevel20"] = boost::any(*serviceLevel20);
    }
    if (totalRingTime) {
      res["TotalRingTime"] = boost::any(*totalRingTime);
    }
    if (totalTalkTime) {
      res["TotalTalkTime"] = boost::any(*totalTalkTime);
    }
    if (totalWorkTime) {
      res["TotalWorkTime"] = boost::any(*totalWorkTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AbandonedInQueueOfQueueCount") != m.end() && !m["AbandonedInQueueOfQueueCount"].empty()) {
      abandonedInQueueOfQueueCount = make_shared<long>(boost::any_cast<long>(m["AbandonedInQueueOfQueueCount"]));
    }
    if (m.find("AnsweredByAgentOfQueueCount") != m.end() && !m["AnsweredByAgentOfQueueCount"].empty()) {
      answeredByAgentOfQueueCount = make_shared<long>(boost::any_cast<long>(m["AnsweredByAgentOfQueueCount"]));
    }
    if (m.find("AnsweredByAgentOfQueueMaxWaitTimeDuration") != m.end() && !m["AnsweredByAgentOfQueueMaxWaitTimeDuration"].empty()) {
      answeredByAgentOfQueueMaxWaitTimeDuration = make_shared<long>(boost::any_cast<long>(m["AnsweredByAgentOfQueueMaxWaitTimeDuration"]));
    }
    if (m.find("AnsweredByAgentOfQueueWaitTimeDuration") != m.end() && !m["AnsweredByAgentOfQueueWaitTimeDuration"].empty()) {
      answeredByAgentOfQueueWaitTimeDuration = make_shared<long>(boost::any_cast<long>(m["AnsweredByAgentOfQueueWaitTimeDuration"]));
    }
    if (m.find("AverageRingTime") != m.end() && !m["AverageRingTime"].empty()) {
      averageRingTime = make_shared<long>(boost::any_cast<long>(m["AverageRingTime"]));
    }
    if (m.find("AverageTalkTime") != m.end() && !m["AverageTalkTime"].empty()) {
      averageTalkTime = make_shared<long>(boost::any_cast<long>(m["AverageTalkTime"]));
    }
    if (m.find("AverageWorkTime") != m.end() && !m["AverageWorkTime"].empty()) {
      averageWorkTime = make_shared<long>(boost::any_cast<long>(m["AverageWorkTime"]));
    }
    if (m.find("CallsAttendedTransferOut") != m.end() && !m["CallsAttendedTransferOut"].empty()) {
      callsAttendedTransferOut = make_shared<long>(boost::any_cast<long>(m["CallsAttendedTransferOut"]));
    }
    if (m.find("CallsBlindTransferOut") != m.end() && !m["CallsBlindTransferOut"].empty()) {
      callsBlindTransferOut = make_shared<long>(boost::any_cast<long>(m["CallsBlindTransferOut"]));
    }
    if (m.find("CallsHandled") != m.end() && !m["CallsHandled"].empty()) {
      callsHandled = make_shared<long>(boost::any_cast<long>(m["CallsHandled"]));
    }
    if (m.find("CallsOffered") != m.end() && !m["CallsOffered"].empty()) {
      callsOffered = make_shared<long>(boost::any_cast<long>(m["CallsOffered"]));
    }
    if (m.find("CallsServiceLevel10") != m.end() && !m["CallsServiceLevel10"].empty()) {
      callsServiceLevel10 = make_shared<long>(boost::any_cast<long>(m["CallsServiceLevel10"]));
    }
    if (m.find("CallsServiceLevel20") != m.end() && !m["CallsServiceLevel20"].empty()) {
      callsServiceLevel20 = make_shared<long>(boost::any_cast<long>(m["CallsServiceLevel20"]));
    }
    if (m.find("CallsServiceLevel30") != m.end() && !m["CallsServiceLevel30"].empty()) {
      callsServiceLevel30 = make_shared<long>(boost::any_cast<long>(m["CallsServiceLevel30"]));
    }
    if (m.find("GiveUpByAgentOfQueueCount") != m.end() && !m["GiveUpByAgentOfQueueCount"].empty()) {
      giveUpByAgentOfQueueCount = make_shared<long>(boost::any_cast<long>(m["GiveUpByAgentOfQueueCount"]));
    }
    if (m.find("HandleRate") != m.end() && !m["HandleRate"].empty()) {
      handleRate = make_shared<double>(boost::any_cast<double>(m["HandleRate"]));
    }
    if (m.find("InComingQueueOfQueueCount") != m.end() && !m["InComingQueueOfQueueCount"].empty()) {
      inComingQueueOfQueueCount = make_shared<long>(boost::any_cast<long>(m["InComingQueueOfQueueCount"]));
    }
    if (m.find("MaxRingTime") != m.end() && !m["MaxRingTime"].empty()) {
      maxRingTime = make_shared<long>(boost::any_cast<long>(m["MaxRingTime"]));
    }
    if (m.find("MaxTalkTime") != m.end() && !m["MaxTalkTime"].empty()) {
      maxTalkTime = make_shared<string>(boost::any_cast<string>(m["MaxTalkTime"]));
    }
    if (m.find("MaxWorkTime") != m.end() && !m["MaxWorkTime"].empty()) {
      maxWorkTime = make_shared<long>(boost::any_cast<long>(m["MaxWorkTime"]));
    }
    if (m.find("OverFlowInQueueOfQueueCount") != m.end() && !m["OverFlowInQueueOfQueueCount"].empty()) {
      overFlowInQueueOfQueueCount = make_shared<long>(boost::any_cast<long>(m["OverFlowInQueueOfQueueCount"]));
    }
    if (m.find("QueueMaxWaitTimeDuration") != m.end() && !m["QueueMaxWaitTimeDuration"].empty()) {
      queueMaxWaitTimeDuration = make_shared<long>(boost::any_cast<long>(m["QueueMaxWaitTimeDuration"]));
    }
    if (m.find("QueueWaitTimeDuration") != m.end() && !m["QueueWaitTimeDuration"].empty()) {
      queueWaitTimeDuration = make_shared<long>(boost::any_cast<long>(m["QueueWaitTimeDuration"]));
    }
    if (m.find("SatisfactionIndex") != m.end() && !m["SatisfactionIndex"].empty()) {
      satisfactionIndex = make_shared<double>(boost::any_cast<double>(m["SatisfactionIndex"]));
    }
    if (m.find("SatisfactionSurveysOffered") != m.end() && !m["SatisfactionSurveysOffered"].empty()) {
      satisfactionSurveysOffered = make_shared<long>(boost::any_cast<long>(m["SatisfactionSurveysOffered"]));
    }
    if (m.find("SatisfactionSurveysResponded") != m.end() && !m["SatisfactionSurveysResponded"].empty()) {
      satisfactionSurveysResponded = make_shared<long>(boost::any_cast<long>(m["SatisfactionSurveysResponded"]));
    }
    if (m.find("ServiceLevel20") != m.end() && !m["ServiceLevel20"].empty()) {
      serviceLevel20 = make_shared<double>(boost::any_cast<double>(m["ServiceLevel20"]));
    }
    if (m.find("TotalRingTime") != m.end() && !m["TotalRingTime"].empty()) {
      totalRingTime = make_shared<long>(boost::any_cast<long>(m["TotalRingTime"]));
    }
    if (m.find("TotalTalkTime") != m.end() && !m["TotalTalkTime"].empty()) {
      totalTalkTime = make_shared<long>(boost::any_cast<long>(m["TotalTalkTime"]));
    }
    if (m.find("TotalWorkTime") != m.end() && !m["TotalWorkTime"].empty()) {
      totalWorkTime = make_shared<long>(boost::any_cast<long>(m["TotalWorkTime"]));
    }
  }


  virtual ~ListSkillGroupSummaryReportsSinceMidnightResponseBodyPagedSkillGroupSummaryReportListInbound() = default;
};
class ListSkillGroupSummaryReportsSinceMidnightResponseBodyPagedSkillGroupSummaryReportListOutbound : public Darabonba::Model {
public:
  shared_ptr<double> answerRate{};
  shared_ptr<long> averageDialingTime{};
  shared_ptr<long> averageTalkTime{};
  shared_ptr<long> averageWorkTime{};
  shared_ptr<long> callsAnswered{};
  shared_ptr<long> callsDialed{};
  shared_ptr<string> callsServiceLevel30{};
  shared_ptr<long> maxDialingTime{};
  shared_ptr<long> maxTalkTime{};
  shared_ptr<long> maxWorkTime{};
  shared_ptr<double> satisfactionIndex{};
  shared_ptr<long> satisfactionSurveysOffered{};
  shared_ptr<long> satisfactionSurveysResponded{};
  shared_ptr<long> totalDialingTime{};
  shared_ptr<long> totalTalkTime{};
  shared_ptr<long> totalWorkTime{};

  ListSkillGroupSummaryReportsSinceMidnightResponseBodyPagedSkillGroupSummaryReportListOutbound() {}

  explicit ListSkillGroupSummaryReportsSinceMidnightResponseBodyPagedSkillGroupSummaryReportListOutbound(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (answerRate) {
      res["AnswerRate"] = boost::any(*answerRate);
    }
    if (averageDialingTime) {
      res["AverageDialingTime"] = boost::any(*averageDialingTime);
    }
    if (averageTalkTime) {
      res["AverageTalkTime"] = boost::any(*averageTalkTime);
    }
    if (averageWorkTime) {
      res["AverageWorkTime"] = boost::any(*averageWorkTime);
    }
    if (callsAnswered) {
      res["CallsAnswered"] = boost::any(*callsAnswered);
    }
    if (callsDialed) {
      res["CallsDialed"] = boost::any(*callsDialed);
    }
    if (callsServiceLevel30) {
      res["CallsServiceLevel30"] = boost::any(*callsServiceLevel30);
    }
    if (maxDialingTime) {
      res["MaxDialingTime"] = boost::any(*maxDialingTime);
    }
    if (maxTalkTime) {
      res["MaxTalkTime"] = boost::any(*maxTalkTime);
    }
    if (maxWorkTime) {
      res["MaxWorkTime"] = boost::any(*maxWorkTime);
    }
    if (satisfactionIndex) {
      res["SatisfactionIndex"] = boost::any(*satisfactionIndex);
    }
    if (satisfactionSurveysOffered) {
      res["SatisfactionSurveysOffered"] = boost::any(*satisfactionSurveysOffered);
    }
    if (satisfactionSurveysResponded) {
      res["SatisfactionSurveysResponded"] = boost::any(*satisfactionSurveysResponded);
    }
    if (totalDialingTime) {
      res["TotalDialingTime"] = boost::any(*totalDialingTime);
    }
    if (totalTalkTime) {
      res["TotalTalkTime"] = boost::any(*totalTalkTime);
    }
    if (totalWorkTime) {
      res["TotalWorkTime"] = boost::any(*totalWorkTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AnswerRate") != m.end() && !m["AnswerRate"].empty()) {
      answerRate = make_shared<double>(boost::any_cast<double>(m["AnswerRate"]));
    }
    if (m.find("AverageDialingTime") != m.end() && !m["AverageDialingTime"].empty()) {
      averageDialingTime = make_shared<long>(boost::any_cast<long>(m["AverageDialingTime"]));
    }
    if (m.find("AverageTalkTime") != m.end() && !m["AverageTalkTime"].empty()) {
      averageTalkTime = make_shared<long>(boost::any_cast<long>(m["AverageTalkTime"]));
    }
    if (m.find("AverageWorkTime") != m.end() && !m["AverageWorkTime"].empty()) {
      averageWorkTime = make_shared<long>(boost::any_cast<long>(m["AverageWorkTime"]));
    }
    if (m.find("CallsAnswered") != m.end() && !m["CallsAnswered"].empty()) {
      callsAnswered = make_shared<long>(boost::any_cast<long>(m["CallsAnswered"]));
    }
    if (m.find("CallsDialed") != m.end() && !m["CallsDialed"].empty()) {
      callsDialed = make_shared<long>(boost::any_cast<long>(m["CallsDialed"]));
    }
    if (m.find("CallsServiceLevel30") != m.end() && !m["CallsServiceLevel30"].empty()) {
      callsServiceLevel30 = make_shared<string>(boost::any_cast<string>(m["CallsServiceLevel30"]));
    }
    if (m.find("MaxDialingTime") != m.end() && !m["MaxDialingTime"].empty()) {
      maxDialingTime = make_shared<long>(boost::any_cast<long>(m["MaxDialingTime"]));
    }
    if (m.find("MaxTalkTime") != m.end() && !m["MaxTalkTime"].empty()) {
      maxTalkTime = make_shared<long>(boost::any_cast<long>(m["MaxTalkTime"]));
    }
    if (m.find("MaxWorkTime") != m.end() && !m["MaxWorkTime"].empty()) {
      maxWorkTime = make_shared<long>(boost::any_cast<long>(m["MaxWorkTime"]));
    }
    if (m.find("SatisfactionIndex") != m.end() && !m["SatisfactionIndex"].empty()) {
      satisfactionIndex = make_shared<double>(boost::any_cast<double>(m["SatisfactionIndex"]));
    }
    if (m.find("SatisfactionSurveysOffered") != m.end() && !m["SatisfactionSurveysOffered"].empty()) {
      satisfactionSurveysOffered = make_shared<long>(boost::any_cast<long>(m["SatisfactionSurveysOffered"]));
    }
    if (m.find("SatisfactionSurveysResponded") != m.end() && !m["SatisfactionSurveysResponded"].empty()) {
      satisfactionSurveysResponded = make_shared<long>(boost::any_cast<long>(m["SatisfactionSurveysResponded"]));
    }
    if (m.find("TotalDialingTime") != m.end() && !m["TotalDialingTime"].empty()) {
      totalDialingTime = make_shared<long>(boost::any_cast<long>(m["TotalDialingTime"]));
    }
    if (m.find("TotalTalkTime") != m.end() && !m["TotalTalkTime"].empty()) {
      totalTalkTime = make_shared<long>(boost::any_cast<long>(m["TotalTalkTime"]));
    }
    if (m.find("TotalWorkTime") != m.end() && !m["TotalWorkTime"].empty()) {
      totalWorkTime = make_shared<long>(boost::any_cast<long>(m["TotalWorkTime"]));
    }
  }


  virtual ~ListSkillGroupSummaryReportsSinceMidnightResponseBodyPagedSkillGroupSummaryReportListOutbound() = default;
};
class ListSkillGroupSummaryReportsSinceMidnightResponseBodyPagedSkillGroupSummaryReportListOverall : public Darabonba::Model {
public:
  shared_ptr<long> averageReadyTime{};
  shared_ptr<long> averageTalkTime{};
  shared_ptr<long> averageWorkTime{};
  shared_ptr<long> maxReadyTime{};
  shared_ptr<long> maxTalkTime{};
  shared_ptr<long> maxWorkTime{};
  shared_ptr<double> occupancyRate{};
  shared_ptr<double> satisfactionIndex{};
  shared_ptr<long> satisfactionSurveysOffered{};
  shared_ptr<long> satisfactionSurveysResponded{};
  shared_ptr<long> totalBreakTime{};
  shared_ptr<long> totalCalls{};
  shared_ptr<long> totalLoggedInTime{};
  shared_ptr<long> totalReadyTime{};
  shared_ptr<long> totalTalkTime{};
  shared_ptr<long> totalWorkTime{};

  ListSkillGroupSummaryReportsSinceMidnightResponseBodyPagedSkillGroupSummaryReportListOverall() {}

  explicit ListSkillGroupSummaryReportsSinceMidnightResponseBodyPagedSkillGroupSummaryReportListOverall(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (averageReadyTime) {
      res["AverageReadyTime"] = boost::any(*averageReadyTime);
    }
    if (averageTalkTime) {
      res["AverageTalkTime"] = boost::any(*averageTalkTime);
    }
    if (averageWorkTime) {
      res["AverageWorkTime"] = boost::any(*averageWorkTime);
    }
    if (maxReadyTime) {
      res["MaxReadyTime"] = boost::any(*maxReadyTime);
    }
    if (maxTalkTime) {
      res["MaxTalkTime"] = boost::any(*maxTalkTime);
    }
    if (maxWorkTime) {
      res["MaxWorkTime"] = boost::any(*maxWorkTime);
    }
    if (occupancyRate) {
      res["OccupancyRate"] = boost::any(*occupancyRate);
    }
    if (satisfactionIndex) {
      res["SatisfactionIndex"] = boost::any(*satisfactionIndex);
    }
    if (satisfactionSurveysOffered) {
      res["SatisfactionSurveysOffered"] = boost::any(*satisfactionSurveysOffered);
    }
    if (satisfactionSurveysResponded) {
      res["SatisfactionSurveysResponded"] = boost::any(*satisfactionSurveysResponded);
    }
    if (totalBreakTime) {
      res["TotalBreakTime"] = boost::any(*totalBreakTime);
    }
    if (totalCalls) {
      res["TotalCalls"] = boost::any(*totalCalls);
    }
    if (totalLoggedInTime) {
      res["TotalLoggedInTime"] = boost::any(*totalLoggedInTime);
    }
    if (totalReadyTime) {
      res["TotalReadyTime"] = boost::any(*totalReadyTime);
    }
    if (totalTalkTime) {
      res["TotalTalkTime"] = boost::any(*totalTalkTime);
    }
    if (totalWorkTime) {
      res["TotalWorkTime"] = boost::any(*totalWorkTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AverageReadyTime") != m.end() && !m["AverageReadyTime"].empty()) {
      averageReadyTime = make_shared<long>(boost::any_cast<long>(m["AverageReadyTime"]));
    }
    if (m.find("AverageTalkTime") != m.end() && !m["AverageTalkTime"].empty()) {
      averageTalkTime = make_shared<long>(boost::any_cast<long>(m["AverageTalkTime"]));
    }
    if (m.find("AverageWorkTime") != m.end() && !m["AverageWorkTime"].empty()) {
      averageWorkTime = make_shared<long>(boost::any_cast<long>(m["AverageWorkTime"]));
    }
    if (m.find("MaxReadyTime") != m.end() && !m["MaxReadyTime"].empty()) {
      maxReadyTime = make_shared<long>(boost::any_cast<long>(m["MaxReadyTime"]));
    }
    if (m.find("MaxTalkTime") != m.end() && !m["MaxTalkTime"].empty()) {
      maxTalkTime = make_shared<long>(boost::any_cast<long>(m["MaxTalkTime"]));
    }
    if (m.find("MaxWorkTime") != m.end() && !m["MaxWorkTime"].empty()) {
      maxWorkTime = make_shared<long>(boost::any_cast<long>(m["MaxWorkTime"]));
    }
    if (m.find("OccupancyRate") != m.end() && !m["OccupancyRate"].empty()) {
      occupancyRate = make_shared<double>(boost::any_cast<double>(m["OccupancyRate"]));
    }
    if (m.find("SatisfactionIndex") != m.end() && !m["SatisfactionIndex"].empty()) {
      satisfactionIndex = make_shared<double>(boost::any_cast<double>(m["SatisfactionIndex"]));
    }
    if (m.find("SatisfactionSurveysOffered") != m.end() && !m["SatisfactionSurveysOffered"].empty()) {
      satisfactionSurveysOffered = make_shared<long>(boost::any_cast<long>(m["SatisfactionSurveysOffered"]));
    }
    if (m.find("SatisfactionSurveysResponded") != m.end() && !m["SatisfactionSurveysResponded"].empty()) {
      satisfactionSurveysResponded = make_shared<long>(boost::any_cast<long>(m["SatisfactionSurveysResponded"]));
    }
    if (m.find("TotalBreakTime") != m.end() && !m["TotalBreakTime"].empty()) {
      totalBreakTime = make_shared<long>(boost::any_cast<long>(m["TotalBreakTime"]));
    }
    if (m.find("TotalCalls") != m.end() && !m["TotalCalls"].empty()) {
      totalCalls = make_shared<long>(boost::any_cast<long>(m["TotalCalls"]));
    }
    if (m.find("TotalLoggedInTime") != m.end() && !m["TotalLoggedInTime"].empty()) {
      totalLoggedInTime = make_shared<long>(boost::any_cast<long>(m["TotalLoggedInTime"]));
    }
    if (m.find("TotalReadyTime") != m.end() && !m["TotalReadyTime"].empty()) {
      totalReadyTime = make_shared<long>(boost::any_cast<long>(m["TotalReadyTime"]));
    }
    if (m.find("TotalTalkTime") != m.end() && !m["TotalTalkTime"].empty()) {
      totalTalkTime = make_shared<long>(boost::any_cast<long>(m["TotalTalkTime"]));
    }
    if (m.find("TotalWorkTime") != m.end() && !m["TotalWorkTime"].empty()) {
      totalWorkTime = make_shared<long>(boost::any_cast<long>(m["TotalWorkTime"]));
    }
  }


  virtual ~ListSkillGroupSummaryReportsSinceMidnightResponseBodyPagedSkillGroupSummaryReportListOverall() = default;
};
class ListSkillGroupSummaryReportsSinceMidnightResponseBodyPagedSkillGroupSummaryReportList : public Darabonba::Model {
public:
  shared_ptr<ListSkillGroupSummaryReportsSinceMidnightResponseBodyPagedSkillGroupSummaryReportListInbound> inbound{};
  shared_ptr<string> instanceId{};
  shared_ptr<ListSkillGroupSummaryReportsSinceMidnightResponseBodyPagedSkillGroupSummaryReportListOutbound> outbound{};
  shared_ptr<ListSkillGroupSummaryReportsSinceMidnightResponseBodyPagedSkillGroupSummaryReportListOverall> overall{};
  shared_ptr<string> skillGroupId{};
  shared_ptr<string> skillGroupName{};
  shared_ptr<string> timestamp{};

  ListSkillGroupSummaryReportsSinceMidnightResponseBodyPagedSkillGroupSummaryReportList() {}

  explicit ListSkillGroupSummaryReportsSinceMidnightResponseBodyPagedSkillGroupSummaryReportList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (inbound) {
      res["Inbound"] = inbound ? boost::any(inbound->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (outbound) {
      res["Outbound"] = outbound ? boost::any(outbound->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (overall) {
      res["Overall"] = overall ? boost::any(overall->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (skillGroupId) {
      res["SkillGroupId"] = boost::any(*skillGroupId);
    }
    if (skillGroupName) {
      res["SkillGroupName"] = boost::any(*skillGroupName);
    }
    if (timestamp) {
      res["Timestamp"] = boost::any(*timestamp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Inbound") != m.end() && !m["Inbound"].empty()) {
      if (typeid(map<string, boost::any>) == m["Inbound"].type()) {
        ListSkillGroupSummaryReportsSinceMidnightResponseBodyPagedSkillGroupSummaryReportListInbound model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Inbound"]));
        inbound = make_shared<ListSkillGroupSummaryReportsSinceMidnightResponseBodyPagedSkillGroupSummaryReportListInbound>(model1);
      }
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Outbound") != m.end() && !m["Outbound"].empty()) {
      if (typeid(map<string, boost::any>) == m["Outbound"].type()) {
        ListSkillGroupSummaryReportsSinceMidnightResponseBodyPagedSkillGroupSummaryReportListOutbound model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Outbound"]));
        outbound = make_shared<ListSkillGroupSummaryReportsSinceMidnightResponseBodyPagedSkillGroupSummaryReportListOutbound>(model1);
      }
    }
    if (m.find("Overall") != m.end() && !m["Overall"].empty()) {
      if (typeid(map<string, boost::any>) == m["Overall"].type()) {
        ListSkillGroupSummaryReportsSinceMidnightResponseBodyPagedSkillGroupSummaryReportListOverall model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Overall"]));
        overall = make_shared<ListSkillGroupSummaryReportsSinceMidnightResponseBodyPagedSkillGroupSummaryReportListOverall>(model1);
      }
    }
    if (m.find("SkillGroupId") != m.end() && !m["SkillGroupId"].empty()) {
      skillGroupId = make_shared<string>(boost::any_cast<string>(m["SkillGroupId"]));
    }
    if (m.find("SkillGroupName") != m.end() && !m["SkillGroupName"].empty()) {
      skillGroupName = make_shared<string>(boost::any_cast<string>(m["SkillGroupName"]));
    }
    if (m.find("Timestamp") != m.end() && !m["Timestamp"].empty()) {
      timestamp = make_shared<string>(boost::any_cast<string>(m["Timestamp"]));
    }
  }


  virtual ~ListSkillGroupSummaryReportsSinceMidnightResponseBodyPagedSkillGroupSummaryReportList() = default;
};
class ListSkillGroupSummaryReportsSinceMidnightResponseBodyPagedSkillGroupSummaryReport : public Darabonba::Model {
public:
  shared_ptr<vector<ListSkillGroupSummaryReportsSinceMidnightResponseBodyPagedSkillGroupSummaryReportList>> list{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  ListSkillGroupSummaryReportsSinceMidnightResponseBodyPagedSkillGroupSummaryReport() {}

  explicit ListSkillGroupSummaryReportsSinceMidnightResponseBodyPagedSkillGroupSummaryReport(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (list) {
      vector<boost::any> temp1;
      for(auto item1:*list){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["List"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(vector<boost::any>) == m["List"].type()) {
        vector<ListSkillGroupSummaryReportsSinceMidnightResponseBodyPagedSkillGroupSummaryReportList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["List"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListSkillGroupSummaryReportsSinceMidnightResponseBodyPagedSkillGroupSummaryReportList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        list = make_shared<vector<ListSkillGroupSummaryReportsSinceMidnightResponseBodyPagedSkillGroupSummaryReportList>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListSkillGroupSummaryReportsSinceMidnightResponseBodyPagedSkillGroupSummaryReport() = default;
};
class ListSkillGroupSummaryReportsSinceMidnightResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<ListSkillGroupSummaryReportsSinceMidnightResponseBodyPagedSkillGroupSummaryReport> pagedSkillGroupSummaryReport{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  ListSkillGroupSummaryReportsSinceMidnightResponseBody() {}

  explicit ListSkillGroupSummaryReportsSinceMidnightResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (pagedSkillGroupSummaryReport) {
      res["PagedSkillGroupSummaryReport"] = pagedSkillGroupSummaryReport ? boost::any(pagedSkillGroupSummaryReport->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("PagedSkillGroupSummaryReport") != m.end() && !m["PagedSkillGroupSummaryReport"].empty()) {
      if (typeid(map<string, boost::any>) == m["PagedSkillGroupSummaryReport"].type()) {
        ListSkillGroupSummaryReportsSinceMidnightResponseBodyPagedSkillGroupSummaryReport model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["PagedSkillGroupSummaryReport"]));
        pagedSkillGroupSummaryReport = make_shared<ListSkillGroupSummaryReportsSinceMidnightResponseBodyPagedSkillGroupSummaryReport>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ListSkillGroupSummaryReportsSinceMidnightResponseBody() = default;
};
class ListSkillGroupSummaryReportsSinceMidnightResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListSkillGroupSummaryReportsSinceMidnightResponseBody> body{};

  ListSkillGroupSummaryReportsSinceMidnightResponse() {}

  explicit ListSkillGroupSummaryReportsSinceMidnightResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListSkillGroupSummaryReportsSinceMidnightResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListSkillGroupSummaryReportsSinceMidnightResponseBody>(model1);
      }
    }
  }


  virtual ~ListSkillGroupSummaryReportsSinceMidnightResponse() = default;
};
class ListSkillGroupsRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> searchPattern{};

  ListSkillGroupsRequest() {}

  explicit ListSkillGroupsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (searchPattern) {
      res["SearchPattern"] = boost::any(*searchPattern);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SearchPattern") != m.end() && !m["SearchPattern"].empty()) {
      searchPattern = make_shared<string>(boost::any_cast<string>(m["SearchPattern"]));
    }
  }


  virtual ~ListSkillGroupsRequest() = default;
};
class ListSkillGroupsResponseBodyDataList : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> displayName{};
  shared_ptr<string> instanceId{};
  shared_ptr<long> phoneNumberCount{};
  shared_ptr<string> skillGroupId{};
  shared_ptr<string> skillGroupName{};
  shared_ptr<long> userCount{};

  ListSkillGroupsResponseBodyDataList() {}

  explicit ListSkillGroupsResponseBodyDataList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (displayName) {
      res["DisplayName"] = boost::any(*displayName);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (phoneNumberCount) {
      res["PhoneNumberCount"] = boost::any(*phoneNumberCount);
    }
    if (skillGroupId) {
      res["SkillGroupId"] = boost::any(*skillGroupId);
    }
    if (skillGroupName) {
      res["SkillGroupName"] = boost::any(*skillGroupName);
    }
    if (userCount) {
      res["UserCount"] = boost::any(*userCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DisplayName") != m.end() && !m["DisplayName"].empty()) {
      displayName = make_shared<string>(boost::any_cast<string>(m["DisplayName"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("PhoneNumberCount") != m.end() && !m["PhoneNumberCount"].empty()) {
      phoneNumberCount = make_shared<long>(boost::any_cast<long>(m["PhoneNumberCount"]));
    }
    if (m.find("SkillGroupId") != m.end() && !m["SkillGroupId"].empty()) {
      skillGroupId = make_shared<string>(boost::any_cast<string>(m["SkillGroupId"]));
    }
    if (m.find("SkillGroupName") != m.end() && !m["SkillGroupName"].empty()) {
      skillGroupName = make_shared<string>(boost::any_cast<string>(m["SkillGroupName"]));
    }
    if (m.find("UserCount") != m.end() && !m["UserCount"].empty()) {
      userCount = make_shared<long>(boost::any_cast<long>(m["UserCount"]));
    }
  }


  virtual ~ListSkillGroupsResponseBodyDataList() = default;
};
class ListSkillGroupsResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<ListSkillGroupsResponseBodyDataList>> list{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  ListSkillGroupsResponseBodyData() {}

  explicit ListSkillGroupsResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (list) {
      vector<boost::any> temp1;
      for(auto item1:*list){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["List"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(vector<boost::any>) == m["List"].type()) {
        vector<ListSkillGroupsResponseBodyDataList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["List"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListSkillGroupsResponseBodyDataList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        list = make_shared<vector<ListSkillGroupsResponseBodyDataList>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListSkillGroupsResponseBodyData() = default;
};
class ListSkillGroupsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<ListSkillGroupsResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  ListSkillGroupsResponseBody() {}

  explicit ListSkillGroupsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ListSkillGroupsResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ListSkillGroupsResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListSkillGroupsResponseBody() = default;
};
class ListSkillGroupsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListSkillGroupsResponseBody> body{};

  ListSkillGroupsResponse() {}

  explicit ListSkillGroupsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListSkillGroupsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListSkillGroupsResponseBody>(model1);
      }
    }
  }


  virtual ~ListSkillGroupsResponse() = default;
};
class ListSkillLevelsOfUserRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<bool> isMember{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> searchPattern{};
  shared_ptr<string> userId{};

  ListSkillLevelsOfUserRequest() {}

  explicit ListSkillLevelsOfUserRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (isMember) {
      res["IsMember"] = boost::any(*isMember);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (searchPattern) {
      res["SearchPattern"] = boost::any(*searchPattern);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("IsMember") != m.end() && !m["IsMember"].empty()) {
      isMember = make_shared<bool>(boost::any_cast<bool>(m["IsMember"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SearchPattern") != m.end() && !m["SearchPattern"].empty()) {
      searchPattern = make_shared<string>(boost::any_cast<string>(m["SearchPattern"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~ListSkillLevelsOfUserRequest() = default;
};
class ListSkillLevelsOfUserResponseBodyDataList : public Darabonba::Model {
public:
  shared_ptr<string> skillGroupId{};
  shared_ptr<string> skillGroupName{};
  shared_ptr<string> skillLevel{};

  ListSkillLevelsOfUserResponseBodyDataList() {}

  explicit ListSkillLevelsOfUserResponseBodyDataList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (skillGroupId) {
      res["SkillGroupId"] = boost::any(*skillGroupId);
    }
    if (skillGroupName) {
      res["SkillGroupName"] = boost::any(*skillGroupName);
    }
    if (skillLevel) {
      res["SkillLevel"] = boost::any(*skillLevel);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SkillGroupId") != m.end() && !m["SkillGroupId"].empty()) {
      skillGroupId = make_shared<string>(boost::any_cast<string>(m["SkillGroupId"]));
    }
    if (m.find("SkillGroupName") != m.end() && !m["SkillGroupName"].empty()) {
      skillGroupName = make_shared<string>(boost::any_cast<string>(m["SkillGroupName"]));
    }
    if (m.find("SkillLevel") != m.end() && !m["SkillLevel"].empty()) {
      skillLevel = make_shared<string>(boost::any_cast<string>(m["SkillLevel"]));
    }
  }


  virtual ~ListSkillLevelsOfUserResponseBodyDataList() = default;
};
class ListSkillLevelsOfUserResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<ListSkillLevelsOfUserResponseBodyDataList>> list{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  ListSkillLevelsOfUserResponseBodyData() {}

  explicit ListSkillLevelsOfUserResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (list) {
      vector<boost::any> temp1;
      for(auto item1:*list){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["List"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(vector<boost::any>) == m["List"].type()) {
        vector<ListSkillLevelsOfUserResponseBodyDataList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["List"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListSkillLevelsOfUserResponseBodyDataList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        list = make_shared<vector<ListSkillLevelsOfUserResponseBodyDataList>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListSkillLevelsOfUserResponseBodyData() = default;
};
class ListSkillLevelsOfUserResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<ListSkillLevelsOfUserResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  ListSkillLevelsOfUserResponseBody() {}

  explicit ListSkillLevelsOfUserResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ListSkillLevelsOfUserResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ListSkillLevelsOfUserResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListSkillLevelsOfUserResponseBody() = default;
};
class ListSkillLevelsOfUserResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListSkillLevelsOfUserResponseBody> body{};

  ListSkillLevelsOfUserResponse() {}

  explicit ListSkillLevelsOfUserResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListSkillLevelsOfUserResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListSkillLevelsOfUserResponseBody>(model1);
      }
    }
  }


  virtual ~ListSkillLevelsOfUserResponse() = default;
};
class ListUnassignedNumbersRequest : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> searchPattern{};

  ListUnassignedNumbersRequest() {}

  explicit ListUnassignedNumbersRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (searchPattern) {
      res["SearchPattern"] = boost::any(*searchPattern);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SearchPattern") != m.end() && !m["SearchPattern"].empty()) {
      searchPattern = make_shared<string>(boost::any_cast<string>(m["SearchPattern"]));
    }
  }


  virtual ~ListUnassignedNumbersRequest() = default;
};
class ListUnassignedNumbersResponseBodyDataList : public Darabonba::Model {
public:
  shared_ptr<string> city{};
  shared_ptr<string> number{};
  shared_ptr<string> province{};

  ListUnassignedNumbersResponseBodyDataList() {}

  explicit ListUnassignedNumbersResponseBodyDataList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (city) {
      res["City"] = boost::any(*city);
    }
    if (number) {
      res["Number"] = boost::any(*number);
    }
    if (province) {
      res["Province"] = boost::any(*province);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("City") != m.end() && !m["City"].empty()) {
      city = make_shared<string>(boost::any_cast<string>(m["City"]));
    }
    if (m.find("Number") != m.end() && !m["Number"].empty()) {
      number = make_shared<string>(boost::any_cast<string>(m["Number"]));
    }
    if (m.find("Province") != m.end() && !m["Province"].empty()) {
      province = make_shared<string>(boost::any_cast<string>(m["Province"]));
    }
  }


  virtual ~ListUnassignedNumbersResponseBodyDataList() = default;
};
class ListUnassignedNumbersResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<ListUnassignedNumbersResponseBodyDataList>> list{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  ListUnassignedNumbersResponseBodyData() {}

  explicit ListUnassignedNumbersResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (list) {
      vector<boost::any> temp1;
      for(auto item1:*list){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["List"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(vector<boost::any>) == m["List"].type()) {
        vector<ListUnassignedNumbersResponseBodyDataList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["List"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListUnassignedNumbersResponseBodyDataList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        list = make_shared<vector<ListUnassignedNumbersResponseBodyDataList>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListUnassignedNumbersResponseBodyData() = default;
};
class ListUnassignedNumbersResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<ListUnassignedNumbersResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  ListUnassignedNumbersResponseBody() {}

  explicit ListUnassignedNumbersResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ListUnassignedNumbersResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ListUnassignedNumbersResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListUnassignedNumbersResponseBody() = default;
};
class ListUnassignedNumbersResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListUnassignedNumbersResponseBody> body{};

  ListUnassignedNumbersResponse() {}

  explicit ListUnassignedNumbersResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListUnassignedNumbersResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListUnassignedNumbersResponseBody>(model1);
      }
    }
  }


  virtual ~ListUnassignedNumbersResponse() = default;
};
class ListUserLevelsOfSkillGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<bool> isMember{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> searchPattern{};
  shared_ptr<string> skillGroupId{};

  ListUserLevelsOfSkillGroupRequest() {}

  explicit ListUserLevelsOfSkillGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (isMember) {
      res["IsMember"] = boost::any(*isMember);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (searchPattern) {
      res["SearchPattern"] = boost::any(*searchPattern);
    }
    if (skillGroupId) {
      res["SkillGroupId"] = boost::any(*skillGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("IsMember") != m.end() && !m["IsMember"].empty()) {
      isMember = make_shared<bool>(boost::any_cast<bool>(m["IsMember"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SearchPattern") != m.end() && !m["SearchPattern"].empty()) {
      searchPattern = make_shared<string>(boost::any_cast<string>(m["SearchPattern"]));
    }
    if (m.find("SkillGroupId") != m.end() && !m["SkillGroupId"].empty()) {
      skillGroupId = make_shared<string>(boost::any_cast<string>(m["SkillGroupId"]));
    }
  }


  virtual ~ListUserLevelsOfSkillGroupRequest() = default;
};
class ListUserLevelsOfSkillGroupResponseBodyDataList : public Darabonba::Model {
public:
  shared_ptr<string> displayName{};
  shared_ptr<string> loginName{};
  shared_ptr<string> ramId{};
  shared_ptr<string> roleId{};
  shared_ptr<string> roleName{};
  shared_ptr<string> skillGroupId{};
  shared_ptr<string> skillGroupName{};
  shared_ptr<long> skillLevel{};
  shared_ptr<string> userId{};

  ListUserLevelsOfSkillGroupResponseBodyDataList() {}

  explicit ListUserLevelsOfSkillGroupResponseBodyDataList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (displayName) {
      res["DisplayName"] = boost::any(*displayName);
    }
    if (loginName) {
      res["LoginName"] = boost::any(*loginName);
    }
    if (ramId) {
      res["RamId"] = boost::any(*ramId);
    }
    if (roleId) {
      res["RoleId"] = boost::any(*roleId);
    }
    if (roleName) {
      res["RoleName"] = boost::any(*roleName);
    }
    if (skillGroupId) {
      res["SkillGroupId"] = boost::any(*skillGroupId);
    }
    if (skillGroupName) {
      res["SkillGroupName"] = boost::any(*skillGroupName);
    }
    if (skillLevel) {
      res["SkillLevel"] = boost::any(*skillLevel);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DisplayName") != m.end() && !m["DisplayName"].empty()) {
      displayName = make_shared<string>(boost::any_cast<string>(m["DisplayName"]));
    }
    if (m.find("LoginName") != m.end() && !m["LoginName"].empty()) {
      loginName = make_shared<string>(boost::any_cast<string>(m["LoginName"]));
    }
    if (m.find("RamId") != m.end() && !m["RamId"].empty()) {
      ramId = make_shared<string>(boost::any_cast<string>(m["RamId"]));
    }
    if (m.find("RoleId") != m.end() && !m["RoleId"].empty()) {
      roleId = make_shared<string>(boost::any_cast<string>(m["RoleId"]));
    }
    if (m.find("RoleName") != m.end() && !m["RoleName"].empty()) {
      roleName = make_shared<string>(boost::any_cast<string>(m["RoleName"]));
    }
    if (m.find("SkillGroupId") != m.end() && !m["SkillGroupId"].empty()) {
      skillGroupId = make_shared<string>(boost::any_cast<string>(m["SkillGroupId"]));
    }
    if (m.find("SkillGroupName") != m.end() && !m["SkillGroupName"].empty()) {
      skillGroupName = make_shared<string>(boost::any_cast<string>(m["SkillGroupName"]));
    }
    if (m.find("SkillLevel") != m.end() && !m["SkillLevel"].empty()) {
      skillLevel = make_shared<long>(boost::any_cast<long>(m["SkillLevel"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~ListUserLevelsOfSkillGroupResponseBodyDataList() = default;
};
class ListUserLevelsOfSkillGroupResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<ListUserLevelsOfSkillGroupResponseBodyDataList>> list{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  ListUserLevelsOfSkillGroupResponseBodyData() {}

  explicit ListUserLevelsOfSkillGroupResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (list) {
      vector<boost::any> temp1;
      for(auto item1:*list){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["List"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(vector<boost::any>) == m["List"].type()) {
        vector<ListUserLevelsOfSkillGroupResponseBodyDataList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["List"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListUserLevelsOfSkillGroupResponseBodyDataList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        list = make_shared<vector<ListUserLevelsOfSkillGroupResponseBodyDataList>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListUserLevelsOfSkillGroupResponseBodyData() = default;
};
class ListUserLevelsOfSkillGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<ListUserLevelsOfSkillGroupResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  ListUserLevelsOfSkillGroupResponseBody() {}

  explicit ListUserLevelsOfSkillGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ListUserLevelsOfSkillGroupResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ListUserLevelsOfSkillGroupResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListUserLevelsOfSkillGroupResponseBody() = default;
};
class ListUserLevelsOfSkillGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListUserLevelsOfSkillGroupResponseBody> body{};

  ListUserLevelsOfSkillGroupResponse() {}

  explicit ListUserLevelsOfSkillGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListUserLevelsOfSkillGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListUserLevelsOfSkillGroupResponseBody>(model1);
      }
    }
  }


  virtual ~ListUserLevelsOfSkillGroupResponse() = default;
};
class ListUsersRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> searchPattern{};

  ListUsersRequest() {}

  explicit ListUsersRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (searchPattern) {
      res["SearchPattern"] = boost::any(*searchPattern);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SearchPattern") != m.end() && !m["SearchPattern"].empty()) {
      searchPattern = make_shared<string>(boost::any_cast<string>(m["SearchPattern"]));
    }
  }


  virtual ~ListUsersRequest() = default;
};
class ListUsersResponseBodyDataListPersonalOutboundNumberList : public Darabonba::Model {
public:
  shared_ptr<bool> active{};
  shared_ptr<string> city{};
  shared_ptr<string> number{};
  shared_ptr<string> province{};
  shared_ptr<string> usage{};

  ListUsersResponseBodyDataListPersonalOutboundNumberList() {}

  explicit ListUsersResponseBodyDataListPersonalOutboundNumberList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (active) {
      res["Active"] = boost::any(*active);
    }
    if (city) {
      res["City"] = boost::any(*city);
    }
    if (number) {
      res["Number"] = boost::any(*number);
    }
    if (province) {
      res["Province"] = boost::any(*province);
    }
    if (usage) {
      res["Usage"] = boost::any(*usage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Active") != m.end() && !m["Active"].empty()) {
      active = make_shared<bool>(boost::any_cast<bool>(m["Active"]));
    }
    if (m.find("City") != m.end() && !m["City"].empty()) {
      city = make_shared<string>(boost::any_cast<string>(m["City"]));
    }
    if (m.find("Number") != m.end() && !m["Number"].empty()) {
      number = make_shared<string>(boost::any_cast<string>(m["Number"]));
    }
    if (m.find("Province") != m.end() && !m["Province"].empty()) {
      province = make_shared<string>(boost::any_cast<string>(m["Province"]));
    }
    if (m.find("Usage") != m.end() && !m["Usage"].empty()) {
      usage = make_shared<string>(boost::any_cast<string>(m["Usage"]));
    }
  }


  virtual ~ListUsersResponseBodyDataListPersonalOutboundNumberList() = default;
};
class ListUsersResponseBodyDataListSkillLevelList : public Darabonba::Model {
public:
  shared_ptr<string> skillGroupId{};
  shared_ptr<string> skillGroupName{};
  shared_ptr<long> skillLevel{};

  ListUsersResponseBodyDataListSkillLevelList() {}

  explicit ListUsersResponseBodyDataListSkillLevelList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (skillGroupId) {
      res["SkillGroupId"] = boost::any(*skillGroupId);
    }
    if (skillGroupName) {
      res["SkillGroupName"] = boost::any(*skillGroupName);
    }
    if (skillLevel) {
      res["SkillLevel"] = boost::any(*skillLevel);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SkillGroupId") != m.end() && !m["SkillGroupId"].empty()) {
      skillGroupId = make_shared<string>(boost::any_cast<string>(m["SkillGroupId"]));
    }
    if (m.find("SkillGroupName") != m.end() && !m["SkillGroupName"].empty()) {
      skillGroupName = make_shared<string>(boost::any_cast<string>(m["SkillGroupName"]));
    }
    if (m.find("SkillLevel") != m.end() && !m["SkillLevel"].empty()) {
      skillLevel = make_shared<long>(boost::any_cast<long>(m["SkillLevel"]));
    }
  }


  virtual ~ListUsersResponseBodyDataListSkillLevelList() = default;
};
class ListUsersResponseBodyDataList : public Darabonba::Model {
public:
  shared_ptr<string> deviceExt{};
  shared_ptr<string> deviceId{};
  shared_ptr<string> deviceState{};
  shared_ptr<string> displayId{};
  shared_ptr<string> displayName{};
  shared_ptr<string> email{};
  shared_ptr<string> extension{};
  shared_ptr<string> loginName{};
  shared_ptr<string> mobile{};
  shared_ptr<vector<ListUsersResponseBodyDataListPersonalOutboundNumberList>> personalOutboundNumberList{};
  shared_ptr<bool> primaryAccount{};
  shared_ptr<long> ramId{};
  shared_ptr<string> roleId{};
  shared_ptr<string> roleName{};
  shared_ptr<vector<ListUsersResponseBodyDataListSkillLevelList>> skillLevelList{};
  shared_ptr<string> userId{};
  shared_ptr<string> workMode{};

  ListUsersResponseBodyDataList() {}

  explicit ListUsersResponseBodyDataList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceExt) {
      res["DeviceExt"] = boost::any(*deviceExt);
    }
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (deviceState) {
      res["DeviceState"] = boost::any(*deviceState);
    }
    if (displayId) {
      res["DisplayId"] = boost::any(*displayId);
    }
    if (displayName) {
      res["DisplayName"] = boost::any(*displayName);
    }
    if (email) {
      res["Email"] = boost::any(*email);
    }
    if (extension) {
      res["Extension"] = boost::any(*extension);
    }
    if (loginName) {
      res["LoginName"] = boost::any(*loginName);
    }
    if (mobile) {
      res["Mobile"] = boost::any(*mobile);
    }
    if (personalOutboundNumberList) {
      vector<boost::any> temp1;
      for(auto item1:*personalOutboundNumberList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["PersonalOutboundNumberList"] = boost::any(temp1);
    }
    if (primaryAccount) {
      res["PrimaryAccount"] = boost::any(*primaryAccount);
    }
    if (ramId) {
      res["RamId"] = boost::any(*ramId);
    }
    if (roleId) {
      res["RoleId"] = boost::any(*roleId);
    }
    if (roleName) {
      res["RoleName"] = boost::any(*roleName);
    }
    if (skillLevelList) {
      vector<boost::any> temp1;
      for(auto item1:*skillLevelList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SkillLevelList"] = boost::any(temp1);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (workMode) {
      res["WorkMode"] = boost::any(*workMode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceExt") != m.end() && !m["DeviceExt"].empty()) {
      deviceExt = make_shared<string>(boost::any_cast<string>(m["DeviceExt"]));
    }
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("DeviceState") != m.end() && !m["DeviceState"].empty()) {
      deviceState = make_shared<string>(boost::any_cast<string>(m["DeviceState"]));
    }
    if (m.find("DisplayId") != m.end() && !m["DisplayId"].empty()) {
      displayId = make_shared<string>(boost::any_cast<string>(m["DisplayId"]));
    }
    if (m.find("DisplayName") != m.end() && !m["DisplayName"].empty()) {
      displayName = make_shared<string>(boost::any_cast<string>(m["DisplayName"]));
    }
    if (m.find("Email") != m.end() && !m["Email"].empty()) {
      email = make_shared<string>(boost::any_cast<string>(m["Email"]));
    }
    if (m.find("Extension") != m.end() && !m["Extension"].empty()) {
      extension = make_shared<string>(boost::any_cast<string>(m["Extension"]));
    }
    if (m.find("LoginName") != m.end() && !m["LoginName"].empty()) {
      loginName = make_shared<string>(boost::any_cast<string>(m["LoginName"]));
    }
    if (m.find("Mobile") != m.end() && !m["Mobile"].empty()) {
      mobile = make_shared<string>(boost::any_cast<string>(m["Mobile"]));
    }
    if (m.find("PersonalOutboundNumberList") != m.end() && !m["PersonalOutboundNumberList"].empty()) {
      if (typeid(vector<boost::any>) == m["PersonalOutboundNumberList"].type()) {
        vector<ListUsersResponseBodyDataListPersonalOutboundNumberList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["PersonalOutboundNumberList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListUsersResponseBodyDataListPersonalOutboundNumberList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        personalOutboundNumberList = make_shared<vector<ListUsersResponseBodyDataListPersonalOutboundNumberList>>(expect1);
      }
    }
    if (m.find("PrimaryAccount") != m.end() && !m["PrimaryAccount"].empty()) {
      primaryAccount = make_shared<bool>(boost::any_cast<bool>(m["PrimaryAccount"]));
    }
    if (m.find("RamId") != m.end() && !m["RamId"].empty()) {
      ramId = make_shared<long>(boost::any_cast<long>(m["RamId"]));
    }
    if (m.find("RoleId") != m.end() && !m["RoleId"].empty()) {
      roleId = make_shared<string>(boost::any_cast<string>(m["RoleId"]));
    }
    if (m.find("RoleName") != m.end() && !m["RoleName"].empty()) {
      roleName = make_shared<string>(boost::any_cast<string>(m["RoleName"]));
    }
    if (m.find("SkillLevelList") != m.end() && !m["SkillLevelList"].empty()) {
      if (typeid(vector<boost::any>) == m["SkillLevelList"].type()) {
        vector<ListUsersResponseBodyDataListSkillLevelList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SkillLevelList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListUsersResponseBodyDataListSkillLevelList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        skillLevelList = make_shared<vector<ListUsersResponseBodyDataListSkillLevelList>>(expect1);
      }
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
    if (m.find("WorkMode") != m.end() && !m["WorkMode"].empty()) {
      workMode = make_shared<string>(boost::any_cast<string>(m["WorkMode"]));
    }
  }


  virtual ~ListUsersResponseBodyDataList() = default;
};
class ListUsersResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<ListUsersResponseBodyDataList>> list{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  ListUsersResponseBodyData() {}

  explicit ListUsersResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (list) {
      vector<boost::any> temp1;
      for(auto item1:*list){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["List"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(vector<boost::any>) == m["List"].type()) {
        vector<ListUsersResponseBodyDataList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["List"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListUsersResponseBodyDataList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        list = make_shared<vector<ListUsersResponseBodyDataList>>(expect1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~ListUsersResponseBodyData() = default;
};
class ListUsersResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<ListUsersResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  ListUsersResponseBody() {}

  explicit ListUsersResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ListUsersResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ListUsersResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListUsersResponseBody() = default;
};
class ListUsersResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListUsersResponseBody> body{};

  ListUsersResponse() {}

  explicit ListUsersResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListUsersResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListUsersResponseBody>(model1);
      }
    }
  }


  virtual ~ListUsersResponse() = default;
};
class MakeCallRequest : public Darabonba::Model {
public:
  shared_ptr<string> callee{};
  shared_ptr<string> caller{};
  shared_ptr<string> deviceId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> maskedCallee{};
  shared_ptr<string> tags{};
  shared_ptr<long> timeoutSeconds{};
  shared_ptr<string> userId{};

  MakeCallRequest() {}

  explicit MakeCallRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callee) {
      res["Callee"] = boost::any(*callee);
    }
    if (caller) {
      res["Caller"] = boost::any(*caller);
    }
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (maskedCallee) {
      res["MaskedCallee"] = boost::any(*maskedCallee);
    }
    if (tags) {
      res["Tags"] = boost::any(*tags);
    }
    if (timeoutSeconds) {
      res["TimeoutSeconds"] = boost::any(*timeoutSeconds);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Callee") != m.end() && !m["Callee"].empty()) {
      callee = make_shared<string>(boost::any_cast<string>(m["Callee"]));
    }
    if (m.find("Caller") != m.end() && !m["Caller"].empty()) {
      caller = make_shared<string>(boost::any_cast<string>(m["Caller"]));
    }
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("MaskedCallee") != m.end() && !m["MaskedCallee"].empty()) {
      maskedCallee = make_shared<string>(boost::any_cast<string>(m["MaskedCallee"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      tags = make_shared<string>(boost::any_cast<string>(m["Tags"]));
    }
    if (m.find("TimeoutSeconds") != m.end() && !m["TimeoutSeconds"].empty()) {
      timeoutSeconds = make_shared<long>(boost::any_cast<long>(m["TimeoutSeconds"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~MakeCallRequest() = default;
};
class MakeCallResponseBodyDataCallContextChannelContexts : public Darabonba::Model {
public:
  shared_ptr<string> callType{};
  shared_ptr<string> channelFlags{};
  shared_ptr<string> channelId{};
  shared_ptr<string> channelState{};
  shared_ptr<string> destination{};
  shared_ptr<string> jobId{};
  shared_ptr<string> originator{};
  shared_ptr<string> releaseInitiator{};
  shared_ptr<string> releaseReason{};
  shared_ptr<long> timestamp{};
  shared_ptr<string> userExtension{};
  shared_ptr<string> userId{};

  MakeCallResponseBodyDataCallContextChannelContexts() {}

  explicit MakeCallResponseBodyDataCallContextChannelContexts(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callType) {
      res["CallType"] = boost::any(*callType);
    }
    if (channelFlags) {
      res["ChannelFlags"] = boost::any(*channelFlags);
    }
    if (channelId) {
      res["ChannelId"] = boost::any(*channelId);
    }
    if (channelState) {
      res["ChannelState"] = boost::any(*channelState);
    }
    if (destination) {
      res["Destination"] = boost::any(*destination);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (originator) {
      res["Originator"] = boost::any(*originator);
    }
    if (releaseInitiator) {
      res["ReleaseInitiator"] = boost::any(*releaseInitiator);
    }
    if (releaseReason) {
      res["ReleaseReason"] = boost::any(*releaseReason);
    }
    if (timestamp) {
      res["Timestamp"] = boost::any(*timestamp);
    }
    if (userExtension) {
      res["UserExtension"] = boost::any(*userExtension);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallType") != m.end() && !m["CallType"].empty()) {
      callType = make_shared<string>(boost::any_cast<string>(m["CallType"]));
    }
    if (m.find("ChannelFlags") != m.end() && !m["ChannelFlags"].empty()) {
      channelFlags = make_shared<string>(boost::any_cast<string>(m["ChannelFlags"]));
    }
    if (m.find("ChannelId") != m.end() && !m["ChannelId"].empty()) {
      channelId = make_shared<string>(boost::any_cast<string>(m["ChannelId"]));
    }
    if (m.find("ChannelState") != m.end() && !m["ChannelState"].empty()) {
      channelState = make_shared<string>(boost::any_cast<string>(m["ChannelState"]));
    }
    if (m.find("Destination") != m.end() && !m["Destination"].empty()) {
      destination = make_shared<string>(boost::any_cast<string>(m["Destination"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("Originator") != m.end() && !m["Originator"].empty()) {
      originator = make_shared<string>(boost::any_cast<string>(m["Originator"]));
    }
    if (m.find("ReleaseInitiator") != m.end() && !m["ReleaseInitiator"].empty()) {
      releaseInitiator = make_shared<string>(boost::any_cast<string>(m["ReleaseInitiator"]));
    }
    if (m.find("ReleaseReason") != m.end() && !m["ReleaseReason"].empty()) {
      releaseReason = make_shared<string>(boost::any_cast<string>(m["ReleaseReason"]));
    }
    if (m.find("Timestamp") != m.end() && !m["Timestamp"].empty()) {
      timestamp = make_shared<long>(boost::any_cast<long>(m["Timestamp"]));
    }
    if (m.find("UserExtension") != m.end() && !m["UserExtension"].empty()) {
      userExtension = make_shared<string>(boost::any_cast<string>(m["UserExtension"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~MakeCallResponseBodyDataCallContextChannelContexts() = default;
};
class MakeCallResponseBodyDataCallContext : public Darabonba::Model {
public:
  shared_ptr<string> callType{};
  shared_ptr<vector<MakeCallResponseBodyDataCallContextChannelContexts>> channelContexts{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> jobId{};

  MakeCallResponseBodyDataCallContext() {}

  explicit MakeCallResponseBodyDataCallContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callType) {
      res["CallType"] = boost::any(*callType);
    }
    if (channelContexts) {
      vector<boost::any> temp1;
      for(auto item1:*channelContexts){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ChannelContexts"] = boost::any(temp1);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallType") != m.end() && !m["CallType"].empty()) {
      callType = make_shared<string>(boost::any_cast<string>(m["CallType"]));
    }
    if (m.find("ChannelContexts") != m.end() && !m["ChannelContexts"].empty()) {
      if (typeid(vector<boost::any>) == m["ChannelContexts"].type()) {
        vector<MakeCallResponseBodyDataCallContextChannelContexts> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ChannelContexts"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            MakeCallResponseBodyDataCallContextChannelContexts model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        channelContexts = make_shared<vector<MakeCallResponseBodyDataCallContextChannelContexts>>(expect1);
      }
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
  }


  virtual ~MakeCallResponseBodyDataCallContext() = default;
};
class MakeCallResponseBodyDataUserContext : public Darabonba::Model {
public:
  shared_ptr<string> breakCode{};
  shared_ptr<string> deviceId{};
  shared_ptr<string> extension{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> jobId{};
  shared_ptr<bool> outboundScenario{};
  shared_ptr<vector<string>> signedSkillGroupIdList{};
  shared_ptr<string> userId{};
  shared_ptr<string> userState{};
  shared_ptr<string> workMode{};

  MakeCallResponseBodyDataUserContext() {}

  explicit MakeCallResponseBodyDataUserContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (breakCode) {
      res["BreakCode"] = boost::any(*breakCode);
    }
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (extension) {
      res["Extension"] = boost::any(*extension);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (outboundScenario) {
      res["OutboundScenario"] = boost::any(*outboundScenario);
    }
    if (signedSkillGroupIdList) {
      res["SignedSkillGroupIdList"] = boost::any(*signedSkillGroupIdList);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (userState) {
      res["UserState"] = boost::any(*userState);
    }
    if (workMode) {
      res["WorkMode"] = boost::any(*workMode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BreakCode") != m.end() && !m["BreakCode"].empty()) {
      breakCode = make_shared<string>(boost::any_cast<string>(m["BreakCode"]));
    }
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("Extension") != m.end() && !m["Extension"].empty()) {
      extension = make_shared<string>(boost::any_cast<string>(m["Extension"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("OutboundScenario") != m.end() && !m["OutboundScenario"].empty()) {
      outboundScenario = make_shared<bool>(boost::any_cast<bool>(m["OutboundScenario"]));
    }
    if (m.find("SignedSkillGroupIdList") != m.end() && !m["SignedSkillGroupIdList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SignedSkillGroupIdList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SignedSkillGroupIdList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      signedSkillGroupIdList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
    if (m.find("UserState") != m.end() && !m["UserState"].empty()) {
      userState = make_shared<string>(boost::any_cast<string>(m["UserState"]));
    }
    if (m.find("WorkMode") != m.end() && !m["WorkMode"].empty()) {
      workMode = make_shared<string>(boost::any_cast<string>(m["WorkMode"]));
    }
  }


  virtual ~MakeCallResponseBodyDataUserContext() = default;
};
class MakeCallResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<MakeCallResponseBodyDataCallContext> callContext{};
  shared_ptr<long> contextId{};
  shared_ptr<MakeCallResponseBodyDataUserContext> userContext{};

  MakeCallResponseBodyData() {}

  explicit MakeCallResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callContext) {
      res["CallContext"] = callContext ? boost::any(callContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (contextId) {
      res["ContextId"] = boost::any(*contextId);
    }
    if (userContext) {
      res["UserContext"] = userContext ? boost::any(userContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallContext") != m.end() && !m["CallContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["CallContext"].type()) {
        MakeCallResponseBodyDataCallContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CallContext"]));
        callContext = make_shared<MakeCallResponseBodyDataCallContext>(model1);
      }
    }
    if (m.find("ContextId") != m.end() && !m["ContextId"].empty()) {
      contextId = make_shared<long>(boost::any_cast<long>(m["ContextId"]));
    }
    if (m.find("UserContext") != m.end() && !m["UserContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["UserContext"].type()) {
        MakeCallResponseBodyDataUserContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["UserContext"]));
        userContext = make_shared<MakeCallResponseBodyDataUserContext>(model1);
      }
    }
  }


  virtual ~MakeCallResponseBodyData() = default;
};
class MakeCallResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<MakeCallResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<vector<string>> params{};
  shared_ptr<string> requestId{};

  MakeCallResponseBody() {}

  explicit MakeCallResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (params) {
      res["Params"] = boost::any(*params);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        MakeCallResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<MakeCallResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Params") != m.end() && !m["Params"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Params"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Params"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      params = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~MakeCallResponseBody() = default;
};
class MakeCallResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<MakeCallResponseBody> body{};

  MakeCallResponse() {}

  explicit MakeCallResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        MakeCallResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<MakeCallResponseBody>(model1);
      }
    }
  }


  virtual ~MakeCallResponse() = default;
};
class ModifyAudioFileRequest : public Darabonba::Model {
public:
  shared_ptr<string> audioFileName{};
  shared_ptr<string> audioResourceId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> name{};
  shared_ptr<string> ossFileKey{};

  ModifyAudioFileRequest() {}

  explicit ModifyAudioFileRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (audioFileName) {
      res["AudioFileName"] = boost::any(*audioFileName);
    }
    if (audioResourceId) {
      res["AudioResourceId"] = boost::any(*audioResourceId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (ossFileKey) {
      res["OssFileKey"] = boost::any(*ossFileKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AudioFileName") != m.end() && !m["AudioFileName"].empty()) {
      audioFileName = make_shared<string>(boost::any_cast<string>(m["AudioFileName"]));
    }
    if (m.find("AudioResourceId") != m.end() && !m["AudioResourceId"].empty()) {
      audioResourceId = make_shared<string>(boost::any_cast<string>(m["AudioResourceId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("OssFileKey") != m.end() && !m["OssFileKey"].empty()) {
      ossFileKey = make_shared<string>(boost::any_cast<string>(m["OssFileKey"]));
    }
  }


  virtual ~ModifyAudioFileRequest() = default;
};
class ModifyAudioFileResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  ModifyAudioFileResponseBody() {}

  explicit ModifyAudioFileResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyAudioFileResponseBody() = default;
};
class ModifyAudioFileResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyAudioFileResponseBody> body{};

  ModifyAudioFileResponse() {}

  explicit ModifyAudioFileResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyAudioFileResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyAudioFileResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyAudioFileResponse() = default;
};
class ModifyCustomCallTaggingRequest : public Darabonba::Model {
public:
  shared_ptr<string> callTagNameList{};
  shared_ptr<string> description{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> number{};

  ModifyCustomCallTaggingRequest() {}

  explicit ModifyCustomCallTaggingRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callTagNameList) {
      res["CallTagNameList"] = boost::any(*callTagNameList);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (number) {
      res["Number"] = boost::any(*number);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallTagNameList") != m.end() && !m["CallTagNameList"].empty()) {
      callTagNameList = make_shared<string>(boost::any_cast<string>(m["CallTagNameList"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Number") != m.end() && !m["Number"].empty()) {
      number = make_shared<string>(boost::any_cast<string>(m["Number"]));
    }
  }


  virtual ~ModifyCustomCallTaggingRequest() = default;
};
class ModifyCustomCallTaggingResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  ModifyCustomCallTaggingResponseBody() {}

  explicit ModifyCustomCallTaggingResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyCustomCallTaggingResponseBody() = default;
};
class ModifyCustomCallTaggingResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyCustomCallTaggingResponseBody> body{};

  ModifyCustomCallTaggingResponse() {}

  explicit ModifyCustomCallTaggingResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyCustomCallTaggingResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyCustomCallTaggingResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyCustomCallTaggingResponse() = default;
};
class ModifyInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> instanceId{};

  ModifyInstanceRequest() {}

  explicit ModifyInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~ModifyInstanceRequest() = default;
};
class ModifyInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  ModifyInstanceResponseBody() {}

  explicit ModifyInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyInstanceResponseBody() = default;
};
class ModifyInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyInstanceResponseBody> body{};

  ModifyInstanceResponse() {}

  explicit ModifyInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyInstanceResponse() = default;
};
class ModifyPhoneNumberRequest : public Darabonba::Model {
public:
  shared_ptr<string> contactFlowId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> number{};
  shared_ptr<string> usage{};

  ModifyPhoneNumberRequest() {}

  explicit ModifyPhoneNumberRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contactFlowId) {
      res["ContactFlowId"] = boost::any(*contactFlowId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (number) {
      res["Number"] = boost::any(*number);
    }
    if (usage) {
      res["Usage"] = boost::any(*usage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ContactFlowId") != m.end() && !m["ContactFlowId"].empty()) {
      contactFlowId = make_shared<string>(boost::any_cast<string>(m["ContactFlowId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Number") != m.end() && !m["Number"].empty()) {
      number = make_shared<string>(boost::any_cast<string>(m["Number"]));
    }
    if (m.find("Usage") != m.end() && !m["Usage"].empty()) {
      usage = make_shared<string>(boost::any_cast<string>(m["Usage"]));
    }
  }


  virtual ~ModifyPhoneNumberRequest() = default;
};
class ModifyPhoneNumberResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  ModifyPhoneNumberResponseBody() {}

  explicit ModifyPhoneNumberResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyPhoneNumberResponseBody() = default;
};
class ModifyPhoneNumberResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyPhoneNumberResponseBody> body{};

  ModifyPhoneNumberResponse() {}

  explicit ModifyPhoneNumberResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyPhoneNumberResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyPhoneNumberResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyPhoneNumberResponse() = default;
};
class ModifySkillGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> displayName{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> skillGroupId{};

  ModifySkillGroupRequest() {}

  explicit ModifySkillGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (displayName) {
      res["DisplayName"] = boost::any(*displayName);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (skillGroupId) {
      res["SkillGroupId"] = boost::any(*skillGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DisplayName") != m.end() && !m["DisplayName"].empty()) {
      displayName = make_shared<string>(boost::any_cast<string>(m["DisplayName"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("SkillGroupId") != m.end() && !m["SkillGroupId"].empty()) {
      skillGroupId = make_shared<string>(boost::any_cast<string>(m["SkillGroupId"]));
    }
  }


  virtual ~ModifySkillGroupRequest() = default;
};
class ModifySkillGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  ModifySkillGroupResponseBody() {}

  explicit ModifySkillGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifySkillGroupResponseBody() = default;
};
class ModifySkillGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifySkillGroupResponseBody> body{};

  ModifySkillGroupResponse() {}

  explicit ModifySkillGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifySkillGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifySkillGroupResponseBody>(model1);
      }
    }
  }


  virtual ~ModifySkillGroupResponse() = default;
};
class ModifySkillLevelsOfUserRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> skillLevelList{};
  shared_ptr<string> userId{};

  ModifySkillLevelsOfUserRequest() {}

  explicit ModifySkillLevelsOfUserRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (skillLevelList) {
      res["SkillLevelList"] = boost::any(*skillLevelList);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("SkillLevelList") != m.end() && !m["SkillLevelList"].empty()) {
      skillLevelList = make_shared<string>(boost::any_cast<string>(m["SkillLevelList"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~ModifySkillLevelsOfUserRequest() = default;
};
class ModifySkillLevelsOfUserResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  ModifySkillLevelsOfUserResponseBody() {}

  explicit ModifySkillLevelsOfUserResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifySkillLevelsOfUserResponseBody() = default;
};
class ModifySkillLevelsOfUserResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifySkillLevelsOfUserResponseBody> body{};

  ModifySkillLevelsOfUserResponse() {}

  explicit ModifySkillLevelsOfUserResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifySkillLevelsOfUserResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifySkillLevelsOfUserResponseBody>(model1);
      }
    }
  }


  virtual ~ModifySkillLevelsOfUserResponse() = default;
};
class ModifyUserRequest : public Darabonba::Model {
public:
  shared_ptr<string> displayId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> mobile{};
  shared_ptr<string> roleId{};
  shared_ptr<string> userId{};
  shared_ptr<string> workMode{};

  ModifyUserRequest() {}

  explicit ModifyUserRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (displayId) {
      res["DisplayId"] = boost::any(*displayId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (mobile) {
      res["Mobile"] = boost::any(*mobile);
    }
    if (roleId) {
      res["RoleId"] = boost::any(*roleId);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (workMode) {
      res["WorkMode"] = boost::any(*workMode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DisplayId") != m.end() && !m["DisplayId"].empty()) {
      displayId = make_shared<string>(boost::any_cast<string>(m["DisplayId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Mobile") != m.end() && !m["Mobile"].empty()) {
      mobile = make_shared<string>(boost::any_cast<string>(m["Mobile"]));
    }
    if (m.find("RoleId") != m.end() && !m["RoleId"].empty()) {
      roleId = make_shared<string>(boost::any_cast<string>(m["RoleId"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
    if (m.find("WorkMode") != m.end() && !m["WorkMode"].empty()) {
      workMode = make_shared<string>(boost::any_cast<string>(m["WorkMode"]));
    }
  }


  virtual ~ModifyUserRequest() = default;
};
class ModifyUserResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  ModifyUserResponseBody() {}

  explicit ModifyUserResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyUserResponseBody() = default;
};
class ModifyUserResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyUserResponseBody> body{};

  ModifyUserResponse() {}

  explicit ModifyUserResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyUserResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyUserResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyUserResponse() = default;
};
class ModifyUserLevelsOfSkillGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> skillGroupId{};
  shared_ptr<string> userLevelList{};

  ModifyUserLevelsOfSkillGroupRequest() {}

  explicit ModifyUserLevelsOfSkillGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (skillGroupId) {
      res["SkillGroupId"] = boost::any(*skillGroupId);
    }
    if (userLevelList) {
      res["UserLevelList"] = boost::any(*userLevelList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("SkillGroupId") != m.end() && !m["SkillGroupId"].empty()) {
      skillGroupId = make_shared<string>(boost::any_cast<string>(m["SkillGroupId"]));
    }
    if (m.find("UserLevelList") != m.end() && !m["UserLevelList"].empty()) {
      userLevelList = make_shared<string>(boost::any_cast<string>(m["UserLevelList"]));
    }
  }


  virtual ~ModifyUserLevelsOfSkillGroupRequest() = default;
};
class ModifyUserLevelsOfSkillGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  ModifyUserLevelsOfSkillGroupResponseBody() {}

  explicit ModifyUserLevelsOfSkillGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyUserLevelsOfSkillGroupResponseBody() = default;
};
class ModifyUserLevelsOfSkillGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyUserLevelsOfSkillGroupResponseBody> body{};

  ModifyUserLevelsOfSkillGroupResponse() {}

  explicit ModifyUserLevelsOfSkillGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyUserLevelsOfSkillGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyUserLevelsOfSkillGroupResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyUserLevelsOfSkillGroupResponse() = default;
};
class MonitorCallRequest : public Darabonba::Model {
public:
  shared_ptr<string> deviceId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> monitoredUserId{};
  shared_ptr<long> timeoutSeconds{};
  shared_ptr<string> userId{};

  MonitorCallRequest() {}

  explicit MonitorCallRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (monitoredUserId) {
      res["MonitoredUserId"] = boost::any(*monitoredUserId);
    }
    if (timeoutSeconds) {
      res["TimeoutSeconds"] = boost::any(*timeoutSeconds);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("MonitoredUserId") != m.end() && !m["MonitoredUserId"].empty()) {
      monitoredUserId = make_shared<string>(boost::any_cast<string>(m["MonitoredUserId"]));
    }
    if (m.find("TimeoutSeconds") != m.end() && !m["TimeoutSeconds"].empty()) {
      timeoutSeconds = make_shared<long>(boost::any_cast<long>(m["TimeoutSeconds"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~MonitorCallRequest() = default;
};
class MonitorCallResponseBodyDataCallContextChannelContexts : public Darabonba::Model {
public:
  shared_ptr<string> callType{};
  shared_ptr<string> channelFlags{};
  shared_ptr<string> channelId{};
  shared_ptr<string> channelState{};
  shared_ptr<string> destination{};
  shared_ptr<long> index{};
  shared_ptr<string> jobId{};
  shared_ptr<string> originator{};
  shared_ptr<string> releaseInitiator{};
  shared_ptr<string> releaseReason{};
  shared_ptr<string> skillGroupId{};
  shared_ptr<long> timestamp{};
  shared_ptr<string> userExtension{};
  shared_ptr<string> userId{};

  MonitorCallResponseBodyDataCallContextChannelContexts() {}

  explicit MonitorCallResponseBodyDataCallContextChannelContexts(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callType) {
      res["CallType"] = boost::any(*callType);
    }
    if (channelFlags) {
      res["ChannelFlags"] = boost::any(*channelFlags);
    }
    if (channelId) {
      res["ChannelId"] = boost::any(*channelId);
    }
    if (channelState) {
      res["ChannelState"] = boost::any(*channelState);
    }
    if (destination) {
      res["Destination"] = boost::any(*destination);
    }
    if (index) {
      res["Index"] = boost::any(*index);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (originator) {
      res["Originator"] = boost::any(*originator);
    }
    if (releaseInitiator) {
      res["ReleaseInitiator"] = boost::any(*releaseInitiator);
    }
    if (releaseReason) {
      res["ReleaseReason"] = boost::any(*releaseReason);
    }
    if (skillGroupId) {
      res["SkillGroupId"] = boost::any(*skillGroupId);
    }
    if (timestamp) {
      res["Timestamp"] = boost::any(*timestamp);
    }
    if (userExtension) {
      res["UserExtension"] = boost::any(*userExtension);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallType") != m.end() && !m["CallType"].empty()) {
      callType = make_shared<string>(boost::any_cast<string>(m["CallType"]));
    }
    if (m.find("ChannelFlags") != m.end() && !m["ChannelFlags"].empty()) {
      channelFlags = make_shared<string>(boost::any_cast<string>(m["ChannelFlags"]));
    }
    if (m.find("ChannelId") != m.end() && !m["ChannelId"].empty()) {
      channelId = make_shared<string>(boost::any_cast<string>(m["ChannelId"]));
    }
    if (m.find("ChannelState") != m.end() && !m["ChannelState"].empty()) {
      channelState = make_shared<string>(boost::any_cast<string>(m["ChannelState"]));
    }
    if (m.find("Destination") != m.end() && !m["Destination"].empty()) {
      destination = make_shared<string>(boost::any_cast<string>(m["Destination"]));
    }
    if (m.find("Index") != m.end() && !m["Index"].empty()) {
      index = make_shared<long>(boost::any_cast<long>(m["Index"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("Originator") != m.end() && !m["Originator"].empty()) {
      originator = make_shared<string>(boost::any_cast<string>(m["Originator"]));
    }
    if (m.find("ReleaseInitiator") != m.end() && !m["ReleaseInitiator"].empty()) {
      releaseInitiator = make_shared<string>(boost::any_cast<string>(m["ReleaseInitiator"]));
    }
    if (m.find("ReleaseReason") != m.end() && !m["ReleaseReason"].empty()) {
      releaseReason = make_shared<string>(boost::any_cast<string>(m["ReleaseReason"]));
    }
    if (m.find("SkillGroupId") != m.end() && !m["SkillGroupId"].empty()) {
      skillGroupId = make_shared<string>(boost::any_cast<string>(m["SkillGroupId"]));
    }
    if (m.find("Timestamp") != m.end() && !m["Timestamp"].empty()) {
      timestamp = make_shared<long>(boost::any_cast<long>(m["Timestamp"]));
    }
    if (m.find("UserExtension") != m.end() && !m["UserExtension"].empty()) {
      userExtension = make_shared<string>(boost::any_cast<string>(m["UserExtension"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~MonitorCallResponseBodyDataCallContextChannelContexts() = default;
};
class MonitorCallResponseBodyDataCallContext : public Darabonba::Model {
public:
  shared_ptr<string> callType{};
  shared_ptr<vector<MonitorCallResponseBodyDataCallContextChannelContexts>> channelContexts{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> jobId{};

  MonitorCallResponseBodyDataCallContext() {}

  explicit MonitorCallResponseBodyDataCallContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callType) {
      res["CallType"] = boost::any(*callType);
    }
    if (channelContexts) {
      vector<boost::any> temp1;
      for(auto item1:*channelContexts){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ChannelContexts"] = boost::any(temp1);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallType") != m.end() && !m["CallType"].empty()) {
      callType = make_shared<string>(boost::any_cast<string>(m["CallType"]));
    }
    if (m.find("ChannelContexts") != m.end() && !m["ChannelContexts"].empty()) {
      if (typeid(vector<boost::any>) == m["ChannelContexts"].type()) {
        vector<MonitorCallResponseBodyDataCallContextChannelContexts> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ChannelContexts"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            MonitorCallResponseBodyDataCallContextChannelContexts model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        channelContexts = make_shared<vector<MonitorCallResponseBodyDataCallContextChannelContexts>>(expect1);
      }
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
  }


  virtual ~MonitorCallResponseBodyDataCallContext() = default;
};
class MonitorCallResponseBodyDataUserContext : public Darabonba::Model {
public:
  shared_ptr<string> breakCode{};
  shared_ptr<string> deviceId{};
  shared_ptr<string> extension{};
  shared_ptr<long> heartbeat{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> jobId{};
  shared_ptr<string> mobile{};
  shared_ptr<bool> outboundScenario{};
  shared_ptr<long> reserved{};
  shared_ptr<vector<string>> signedSkillGroupIdList{};
  shared_ptr<string> userId{};
  shared_ptr<string> userState{};
  shared_ptr<string> workMode{};

  MonitorCallResponseBodyDataUserContext() {}

  explicit MonitorCallResponseBodyDataUserContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (breakCode) {
      res["BreakCode"] = boost::any(*breakCode);
    }
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (extension) {
      res["Extension"] = boost::any(*extension);
    }
    if (heartbeat) {
      res["Heartbeat"] = boost::any(*heartbeat);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (mobile) {
      res["Mobile"] = boost::any(*mobile);
    }
    if (outboundScenario) {
      res["OutboundScenario"] = boost::any(*outboundScenario);
    }
    if (reserved) {
      res["Reserved"] = boost::any(*reserved);
    }
    if (signedSkillGroupIdList) {
      res["SignedSkillGroupIdList"] = boost::any(*signedSkillGroupIdList);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (userState) {
      res["UserState"] = boost::any(*userState);
    }
    if (workMode) {
      res["WorkMode"] = boost::any(*workMode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BreakCode") != m.end() && !m["BreakCode"].empty()) {
      breakCode = make_shared<string>(boost::any_cast<string>(m["BreakCode"]));
    }
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("Extension") != m.end() && !m["Extension"].empty()) {
      extension = make_shared<string>(boost::any_cast<string>(m["Extension"]));
    }
    if (m.find("Heartbeat") != m.end() && !m["Heartbeat"].empty()) {
      heartbeat = make_shared<long>(boost::any_cast<long>(m["Heartbeat"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("Mobile") != m.end() && !m["Mobile"].empty()) {
      mobile = make_shared<string>(boost::any_cast<string>(m["Mobile"]));
    }
    if (m.find("OutboundScenario") != m.end() && !m["OutboundScenario"].empty()) {
      outboundScenario = make_shared<bool>(boost::any_cast<bool>(m["OutboundScenario"]));
    }
    if (m.find("Reserved") != m.end() && !m["Reserved"].empty()) {
      reserved = make_shared<long>(boost::any_cast<long>(m["Reserved"]));
    }
    if (m.find("SignedSkillGroupIdList") != m.end() && !m["SignedSkillGroupIdList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SignedSkillGroupIdList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SignedSkillGroupIdList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      signedSkillGroupIdList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
    if (m.find("UserState") != m.end() && !m["UserState"].empty()) {
      userState = make_shared<string>(boost::any_cast<string>(m["UserState"]));
    }
    if (m.find("WorkMode") != m.end() && !m["WorkMode"].empty()) {
      workMode = make_shared<string>(boost::any_cast<string>(m["WorkMode"]));
    }
  }


  virtual ~MonitorCallResponseBodyDataUserContext() = default;
};
class MonitorCallResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<MonitorCallResponseBodyDataCallContext> callContext{};
  shared_ptr<MonitorCallResponseBodyDataUserContext> userContext{};

  MonitorCallResponseBodyData() {}

  explicit MonitorCallResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callContext) {
      res["CallContext"] = callContext ? boost::any(callContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (userContext) {
      res["UserContext"] = userContext ? boost::any(userContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallContext") != m.end() && !m["CallContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["CallContext"].type()) {
        MonitorCallResponseBodyDataCallContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CallContext"]));
        callContext = make_shared<MonitorCallResponseBodyDataCallContext>(model1);
      }
    }
    if (m.find("UserContext") != m.end() && !m["UserContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["UserContext"].type()) {
        MonitorCallResponseBodyDataUserContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["UserContext"]));
        userContext = make_shared<MonitorCallResponseBodyDataUserContext>(model1);
      }
    }
  }


  virtual ~MonitorCallResponseBodyData() = default;
};
class MonitorCallResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<MonitorCallResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<vector<string>> params{};
  shared_ptr<string> requestId{};

  MonitorCallResponseBody() {}

  explicit MonitorCallResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (params) {
      res["Params"] = boost::any(*params);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        MonitorCallResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<MonitorCallResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Params") != m.end() && !m["Params"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Params"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Params"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      params = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~MonitorCallResponseBody() = default;
};
class MonitorCallResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<MonitorCallResponseBody> body{};

  MonitorCallResponse() {}

  explicit MonitorCallResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        MonitorCallResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<MonitorCallResponseBody>(model1);
      }
    }
  }


  virtual ~MonitorCallResponse() = default;
};
class MuteCallRequest : public Darabonba::Model {
public:
  shared_ptr<string> channelId{};
  shared_ptr<string> deviceId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> jobId{};
  shared_ptr<string> userId{};

  MuteCallRequest() {}

  explicit MuteCallRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (channelId) {
      res["ChannelId"] = boost::any(*channelId);
    }
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChannelId") != m.end() && !m["ChannelId"].empty()) {
      channelId = make_shared<string>(boost::any_cast<string>(m["ChannelId"]));
    }
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~MuteCallRequest() = default;
};
class MuteCallResponseBodyDataCallContextChannelContexts : public Darabonba::Model {
public:
  shared_ptr<string> callType{};
  shared_ptr<string> channelFlags{};
  shared_ptr<string> channelId{};
  shared_ptr<string> channelState{};
  shared_ptr<string> destination{};
  shared_ptr<long> index{};
  shared_ptr<string> jobId{};
  shared_ptr<string> originator{};
  shared_ptr<string> releaseInitiator{};
  shared_ptr<string> releaseReason{};
  shared_ptr<long> timestamp{};
  shared_ptr<string> userExtension{};
  shared_ptr<string> userId{};

  MuteCallResponseBodyDataCallContextChannelContexts() {}

  explicit MuteCallResponseBodyDataCallContextChannelContexts(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callType) {
      res["CallType"] = boost::any(*callType);
    }
    if (channelFlags) {
      res["ChannelFlags"] = boost::any(*channelFlags);
    }
    if (channelId) {
      res["ChannelId"] = boost::any(*channelId);
    }
    if (channelState) {
      res["ChannelState"] = boost::any(*channelState);
    }
    if (destination) {
      res["Destination"] = boost::any(*destination);
    }
    if (index) {
      res["Index"] = boost::any(*index);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (originator) {
      res["Originator"] = boost::any(*originator);
    }
    if (releaseInitiator) {
      res["ReleaseInitiator"] = boost::any(*releaseInitiator);
    }
    if (releaseReason) {
      res["ReleaseReason"] = boost::any(*releaseReason);
    }
    if (timestamp) {
      res["Timestamp"] = boost::any(*timestamp);
    }
    if (userExtension) {
      res["UserExtension"] = boost::any(*userExtension);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallType") != m.end() && !m["CallType"].empty()) {
      callType = make_shared<string>(boost::any_cast<string>(m["CallType"]));
    }
    if (m.find("ChannelFlags") != m.end() && !m["ChannelFlags"].empty()) {
      channelFlags = make_shared<string>(boost::any_cast<string>(m["ChannelFlags"]));
    }
    if (m.find("ChannelId") != m.end() && !m["ChannelId"].empty()) {
      channelId = make_shared<string>(boost::any_cast<string>(m["ChannelId"]));
    }
    if (m.find("ChannelState") != m.end() && !m["ChannelState"].empty()) {
      channelState = make_shared<string>(boost::any_cast<string>(m["ChannelState"]));
    }
    if (m.find("Destination") != m.end() && !m["Destination"].empty()) {
      destination = make_shared<string>(boost::any_cast<string>(m["Destination"]));
    }
    if (m.find("Index") != m.end() && !m["Index"].empty()) {
      index = make_shared<long>(boost::any_cast<long>(m["Index"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("Originator") != m.end() && !m["Originator"].empty()) {
      originator = make_shared<string>(boost::any_cast<string>(m["Originator"]));
    }
    if (m.find("ReleaseInitiator") != m.end() && !m["ReleaseInitiator"].empty()) {
      releaseInitiator = make_shared<string>(boost::any_cast<string>(m["ReleaseInitiator"]));
    }
    if (m.find("ReleaseReason") != m.end() && !m["ReleaseReason"].empty()) {
      releaseReason = make_shared<string>(boost::any_cast<string>(m["ReleaseReason"]));
    }
    if (m.find("Timestamp") != m.end() && !m["Timestamp"].empty()) {
      timestamp = make_shared<long>(boost::any_cast<long>(m["Timestamp"]));
    }
    if (m.find("UserExtension") != m.end() && !m["UserExtension"].empty()) {
      userExtension = make_shared<string>(boost::any_cast<string>(m["UserExtension"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~MuteCallResponseBodyDataCallContextChannelContexts() = default;
};
class MuteCallResponseBodyDataCallContext : public Darabonba::Model {
public:
  shared_ptr<string> callType{};
  shared_ptr<vector<MuteCallResponseBodyDataCallContextChannelContexts>> channelContexts{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> jobId{};

  MuteCallResponseBodyDataCallContext() {}

  explicit MuteCallResponseBodyDataCallContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callType) {
      res["CallType"] = boost::any(*callType);
    }
    if (channelContexts) {
      vector<boost::any> temp1;
      for(auto item1:*channelContexts){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ChannelContexts"] = boost::any(temp1);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallType") != m.end() && !m["CallType"].empty()) {
      callType = make_shared<string>(boost::any_cast<string>(m["CallType"]));
    }
    if (m.find("ChannelContexts") != m.end() && !m["ChannelContexts"].empty()) {
      if (typeid(vector<boost::any>) == m["ChannelContexts"].type()) {
        vector<MuteCallResponseBodyDataCallContextChannelContexts> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ChannelContexts"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            MuteCallResponseBodyDataCallContextChannelContexts model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        channelContexts = make_shared<vector<MuteCallResponseBodyDataCallContextChannelContexts>>(expect1);
      }
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
  }


  virtual ~MuteCallResponseBodyDataCallContext() = default;
};
class MuteCallResponseBodyDataUserContext : public Darabonba::Model {
public:
  shared_ptr<string> breakCode{};
  shared_ptr<string> deviceId{};
  shared_ptr<string> extension{};
  shared_ptr<long> heartbeat{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> jobId{};
  shared_ptr<string> mobile{};
  shared_ptr<bool> outboundScenario{};
  shared_ptr<long> reserved{};
  shared_ptr<vector<string>> signedSkillGroupIdList{};
  shared_ptr<string> userId{};
  shared_ptr<string> userState{};
  shared_ptr<string> workMode{};

  MuteCallResponseBodyDataUserContext() {}

  explicit MuteCallResponseBodyDataUserContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (breakCode) {
      res["BreakCode"] = boost::any(*breakCode);
    }
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (extension) {
      res["Extension"] = boost::any(*extension);
    }
    if (heartbeat) {
      res["Heartbeat"] = boost::any(*heartbeat);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (mobile) {
      res["Mobile"] = boost::any(*mobile);
    }
    if (outboundScenario) {
      res["OutboundScenario"] = boost::any(*outboundScenario);
    }
    if (reserved) {
      res["Reserved"] = boost::any(*reserved);
    }
    if (signedSkillGroupIdList) {
      res["SignedSkillGroupIdList"] = boost::any(*signedSkillGroupIdList);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (userState) {
      res["UserState"] = boost::any(*userState);
    }
    if (workMode) {
      res["WorkMode"] = boost::any(*workMode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BreakCode") != m.end() && !m["BreakCode"].empty()) {
      breakCode = make_shared<string>(boost::any_cast<string>(m["BreakCode"]));
    }
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("Extension") != m.end() && !m["Extension"].empty()) {
      extension = make_shared<string>(boost::any_cast<string>(m["Extension"]));
    }
    if (m.find("Heartbeat") != m.end() && !m["Heartbeat"].empty()) {
      heartbeat = make_shared<long>(boost::any_cast<long>(m["Heartbeat"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("Mobile") != m.end() && !m["Mobile"].empty()) {
      mobile = make_shared<string>(boost::any_cast<string>(m["Mobile"]));
    }
    if (m.find("OutboundScenario") != m.end() && !m["OutboundScenario"].empty()) {
      outboundScenario = make_shared<bool>(boost::any_cast<bool>(m["OutboundScenario"]));
    }
    if (m.find("Reserved") != m.end() && !m["Reserved"].empty()) {
      reserved = make_shared<long>(boost::any_cast<long>(m["Reserved"]));
    }
    if (m.find("SignedSkillGroupIdList") != m.end() && !m["SignedSkillGroupIdList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SignedSkillGroupIdList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SignedSkillGroupIdList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      signedSkillGroupIdList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
    if (m.find("UserState") != m.end() && !m["UserState"].empty()) {
      userState = make_shared<string>(boost::any_cast<string>(m["UserState"]));
    }
    if (m.find("WorkMode") != m.end() && !m["WorkMode"].empty()) {
      workMode = make_shared<string>(boost::any_cast<string>(m["WorkMode"]));
    }
  }


  virtual ~MuteCallResponseBodyDataUserContext() = default;
};
class MuteCallResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<MuteCallResponseBodyDataCallContext> callContext{};
  shared_ptr<MuteCallResponseBodyDataUserContext> userContext{};

  MuteCallResponseBodyData() {}

  explicit MuteCallResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callContext) {
      res["CallContext"] = callContext ? boost::any(callContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (userContext) {
      res["UserContext"] = userContext ? boost::any(userContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallContext") != m.end() && !m["CallContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["CallContext"].type()) {
        MuteCallResponseBodyDataCallContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CallContext"]));
        callContext = make_shared<MuteCallResponseBodyDataCallContext>(model1);
      }
    }
    if (m.find("UserContext") != m.end() && !m["UserContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["UserContext"].type()) {
        MuteCallResponseBodyDataUserContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["UserContext"]));
        userContext = make_shared<MuteCallResponseBodyDataUserContext>(model1);
      }
    }
  }


  virtual ~MuteCallResponseBodyData() = default;
};
class MuteCallResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<MuteCallResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<vector<string>> params{};
  shared_ptr<string> requestId{};

  MuteCallResponseBody() {}

  explicit MuteCallResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (params) {
      res["Params"] = boost::any(*params);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        MuteCallResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<MuteCallResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Params") != m.end() && !m["Params"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Params"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Params"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      params = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~MuteCallResponseBody() = default;
};
class MuteCallResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<MuteCallResponseBody> body{};

  MuteCallResponse() {}

  explicit MuteCallResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        MuteCallResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<MuteCallResponseBody>(model1);
      }
    }
  }


  virtual ~MuteCallResponse() = default;
};
class PauseCampaignRequest : public Darabonba::Model {
public:
  shared_ptr<string> campaignId{};
  shared_ptr<string> instanceId{};

  PauseCampaignRequest() {}

  explicit PauseCampaignRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (campaignId) {
      res["CampaignId"] = boost::any(*campaignId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CampaignId") != m.end() && !m["CampaignId"].empty()) {
      campaignId = make_shared<string>(boost::any_cast<string>(m["CampaignId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~PauseCampaignRequest() = default;
};
class PauseCampaignResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  PauseCampaignResponseBody() {}

  explicit PauseCampaignResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<string>(boost::any_cast<string>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~PauseCampaignResponseBody() = default;
};
class PauseCampaignResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<PauseCampaignResponseBody> body{};

  PauseCampaignResponse() {}

  explicit PauseCampaignResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        PauseCampaignResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<PauseCampaignResponseBody>(model1);
      }
    }
  }


  virtual ~PauseCampaignResponse() = default;
};
class PickOutboundNumbersRequest : public Darabonba::Model {
public:
  shared_ptr<string> calledNumber{};
  shared_ptr<long> count{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> skillGroupIdList{};

  PickOutboundNumbersRequest() {}

  explicit PickOutboundNumbersRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (calledNumber) {
      res["CalledNumber"] = boost::any(*calledNumber);
    }
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (skillGroupIdList) {
      res["SkillGroupIdList"] = boost::any(*skillGroupIdList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CalledNumber") != m.end() && !m["CalledNumber"].empty()) {
      calledNumber = make_shared<string>(boost::any_cast<string>(m["CalledNumber"]));
    }
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("SkillGroupIdList") != m.end() && !m["SkillGroupIdList"].empty()) {
      skillGroupIdList = make_shared<string>(boost::any_cast<string>(m["SkillGroupIdList"]));
    }
  }


  virtual ~PickOutboundNumbersRequest() = default;
};
class PickOutboundNumbersResponseBodyDataCallee : public Darabonba::Model {
public:
  shared_ptr<string> city{};
  shared_ptr<string> number{};
  shared_ptr<string> province{};

  PickOutboundNumbersResponseBodyDataCallee() {}

  explicit PickOutboundNumbersResponseBodyDataCallee(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (city) {
      res["City"] = boost::any(*city);
    }
    if (number) {
      res["Number"] = boost::any(*number);
    }
    if (province) {
      res["Province"] = boost::any(*province);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("City") != m.end() && !m["City"].empty()) {
      city = make_shared<string>(boost::any_cast<string>(m["City"]));
    }
    if (m.find("Number") != m.end() && !m["Number"].empty()) {
      number = make_shared<string>(boost::any_cast<string>(m["Number"]));
    }
    if (m.find("Province") != m.end() && !m["Province"].empty()) {
      province = make_shared<string>(boost::any_cast<string>(m["Province"]));
    }
  }


  virtual ~PickOutboundNumbersResponseBodyDataCallee() = default;
};
class PickOutboundNumbersResponseBodyDataCaller : public Darabonba::Model {
public:
  shared_ptr<string> city{};
  shared_ptr<string> number{};
  shared_ptr<string> province{};

  PickOutboundNumbersResponseBodyDataCaller() {}

  explicit PickOutboundNumbersResponseBodyDataCaller(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (city) {
      res["City"] = boost::any(*city);
    }
    if (number) {
      res["Number"] = boost::any(*number);
    }
    if (province) {
      res["Province"] = boost::any(*province);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("City") != m.end() && !m["City"].empty()) {
      city = make_shared<string>(boost::any_cast<string>(m["City"]));
    }
    if (m.find("Number") != m.end() && !m["Number"].empty()) {
      number = make_shared<string>(boost::any_cast<string>(m["Number"]));
    }
    if (m.find("Province") != m.end() && !m["Province"].empty()) {
      province = make_shared<string>(boost::any_cast<string>(m["Province"]));
    }
  }


  virtual ~PickOutboundNumbersResponseBodyDataCaller() = default;
};
class PickOutboundNumbersResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<PickOutboundNumbersResponseBodyDataCallee> callee{};
  shared_ptr<PickOutboundNumbersResponseBodyDataCaller> caller{};

  PickOutboundNumbersResponseBodyData() {}

  explicit PickOutboundNumbersResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callee) {
      res["Callee"] = callee ? boost::any(callee->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (caller) {
      res["Caller"] = caller ? boost::any(caller->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Callee") != m.end() && !m["Callee"].empty()) {
      if (typeid(map<string, boost::any>) == m["Callee"].type()) {
        PickOutboundNumbersResponseBodyDataCallee model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Callee"]));
        callee = make_shared<PickOutboundNumbersResponseBodyDataCallee>(model1);
      }
    }
    if (m.find("Caller") != m.end() && !m["Caller"].empty()) {
      if (typeid(map<string, boost::any>) == m["Caller"].type()) {
        PickOutboundNumbersResponseBodyDataCaller model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Caller"]));
        caller = make_shared<PickOutboundNumbersResponseBodyDataCaller>(model1);
      }
    }
  }


  virtual ~PickOutboundNumbersResponseBodyData() = default;
};
class PickOutboundNumbersResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<vector<PickOutboundNumbersResponseBodyData>> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  PickOutboundNumbersResponseBody() {}

  explicit PickOutboundNumbersResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<PickOutboundNumbersResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            PickOutboundNumbersResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<PickOutboundNumbersResponseBodyData>>(expect1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~PickOutboundNumbersResponseBody() = default;
};
class PickOutboundNumbersResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<PickOutboundNumbersResponseBody> body{};

  PickOutboundNumbersResponse() {}

  explicit PickOutboundNumbersResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        PickOutboundNumbersResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<PickOutboundNumbersResponseBody>(model1);
      }
    }
  }


  virtual ~PickOutboundNumbersResponse() = default;
};
class PollUserStatusRequest : public Darabonba::Model {
public:
  shared_ptr<string> deviceId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> userId{};

  PollUserStatusRequest() {}

  explicit PollUserStatusRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~PollUserStatusRequest() = default;
};
class PollUserStatusResponseBodyDataCallContextChannelContexts : public Darabonba::Model {
public:
  shared_ptr<string> callType{};
  shared_ptr<string> channelFlags{};
  shared_ptr<string> channelId{};
  shared_ptr<string> channelState{};
  shared_ptr<string> channelVariables{};
  shared_ptr<string> destination{};
  shared_ptr<long> index{};
  shared_ptr<string> jobId{};
  shared_ptr<string> originator{};
  shared_ptr<string> releaseInitiator{};
  shared_ptr<string> releaseReason{};
  shared_ptr<string> skillGroupId{};
  shared_ptr<long> timestamp{};
  shared_ptr<string> userExtension{};
  shared_ptr<string> userId{};

  PollUserStatusResponseBodyDataCallContextChannelContexts() {}

  explicit PollUserStatusResponseBodyDataCallContextChannelContexts(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callType) {
      res["CallType"] = boost::any(*callType);
    }
    if (channelFlags) {
      res["ChannelFlags"] = boost::any(*channelFlags);
    }
    if (channelId) {
      res["ChannelId"] = boost::any(*channelId);
    }
    if (channelState) {
      res["ChannelState"] = boost::any(*channelState);
    }
    if (channelVariables) {
      res["ChannelVariables"] = boost::any(*channelVariables);
    }
    if (destination) {
      res["Destination"] = boost::any(*destination);
    }
    if (index) {
      res["Index"] = boost::any(*index);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (originator) {
      res["Originator"] = boost::any(*originator);
    }
    if (releaseInitiator) {
      res["ReleaseInitiator"] = boost::any(*releaseInitiator);
    }
    if (releaseReason) {
      res["ReleaseReason"] = boost::any(*releaseReason);
    }
    if (skillGroupId) {
      res["SkillGroupId"] = boost::any(*skillGroupId);
    }
    if (timestamp) {
      res["Timestamp"] = boost::any(*timestamp);
    }
    if (userExtension) {
      res["UserExtension"] = boost::any(*userExtension);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallType") != m.end() && !m["CallType"].empty()) {
      callType = make_shared<string>(boost::any_cast<string>(m["CallType"]));
    }
    if (m.find("ChannelFlags") != m.end() && !m["ChannelFlags"].empty()) {
      channelFlags = make_shared<string>(boost::any_cast<string>(m["ChannelFlags"]));
    }
    if (m.find("ChannelId") != m.end() && !m["ChannelId"].empty()) {
      channelId = make_shared<string>(boost::any_cast<string>(m["ChannelId"]));
    }
    if (m.find("ChannelState") != m.end() && !m["ChannelState"].empty()) {
      channelState = make_shared<string>(boost::any_cast<string>(m["ChannelState"]));
    }
    if (m.find("ChannelVariables") != m.end() && !m["ChannelVariables"].empty()) {
      channelVariables = make_shared<string>(boost::any_cast<string>(m["ChannelVariables"]));
    }
    if (m.find("Destination") != m.end() && !m["Destination"].empty()) {
      destination = make_shared<string>(boost::any_cast<string>(m["Destination"]));
    }
    if (m.find("Index") != m.end() && !m["Index"].empty()) {
      index = make_shared<long>(boost::any_cast<long>(m["Index"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("Originator") != m.end() && !m["Originator"].empty()) {
      originator = make_shared<string>(boost::any_cast<string>(m["Originator"]));
    }
    if (m.find("ReleaseInitiator") != m.end() && !m["ReleaseInitiator"].empty()) {
      releaseInitiator = make_shared<string>(boost::any_cast<string>(m["ReleaseInitiator"]));
    }
    if (m.find("ReleaseReason") != m.end() && !m["ReleaseReason"].empty()) {
      releaseReason = make_shared<string>(boost::any_cast<string>(m["ReleaseReason"]));
    }
    if (m.find("SkillGroupId") != m.end() && !m["SkillGroupId"].empty()) {
      skillGroupId = make_shared<string>(boost::any_cast<string>(m["SkillGroupId"]));
    }
    if (m.find("Timestamp") != m.end() && !m["Timestamp"].empty()) {
      timestamp = make_shared<long>(boost::any_cast<long>(m["Timestamp"]));
    }
    if (m.find("UserExtension") != m.end() && !m["UserExtension"].empty()) {
      userExtension = make_shared<string>(boost::any_cast<string>(m["UserExtension"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~PollUserStatusResponseBodyDataCallContextChannelContexts() = default;
};
class PollUserStatusResponseBodyDataCallContext : public Darabonba::Model {
public:
  shared_ptr<string> callType{};
  shared_ptr<string> callVariables{};
  shared_ptr<vector<PollUserStatusResponseBodyDataCallContextChannelContexts>> channelContexts{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> jobId{};

  PollUserStatusResponseBodyDataCallContext() {}

  explicit PollUserStatusResponseBodyDataCallContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callType) {
      res["CallType"] = boost::any(*callType);
    }
    if (callVariables) {
      res["CallVariables"] = boost::any(*callVariables);
    }
    if (channelContexts) {
      vector<boost::any> temp1;
      for(auto item1:*channelContexts){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ChannelContexts"] = boost::any(temp1);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallType") != m.end() && !m["CallType"].empty()) {
      callType = make_shared<string>(boost::any_cast<string>(m["CallType"]));
    }
    if (m.find("CallVariables") != m.end() && !m["CallVariables"].empty()) {
      callVariables = make_shared<string>(boost::any_cast<string>(m["CallVariables"]));
    }
    if (m.find("ChannelContexts") != m.end() && !m["ChannelContexts"].empty()) {
      if (typeid(vector<boost::any>) == m["ChannelContexts"].type()) {
        vector<PollUserStatusResponseBodyDataCallContextChannelContexts> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ChannelContexts"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            PollUserStatusResponseBodyDataCallContextChannelContexts model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        channelContexts = make_shared<vector<PollUserStatusResponseBodyDataCallContextChannelContexts>>(expect1);
      }
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
  }


  virtual ~PollUserStatusResponseBodyDataCallContext() = default;
};
class PollUserStatusResponseBodyDataUserContext : public Darabonba::Model {
public:
  shared_ptr<string> breakCode{};
  shared_ptr<string> deviceId{};
  shared_ptr<string> extension{};
  shared_ptr<long> heartbeat{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> jobId{};
  shared_ptr<string> mobile{};
  shared_ptr<bool> outboundScenario{};
  shared_ptr<long> reserved{};
  shared_ptr<vector<string>> signedSkillGroupIdList{};
  shared_ptr<string> userId{};
  shared_ptr<string> userState{};
  shared_ptr<string> workMode{};

  PollUserStatusResponseBodyDataUserContext() {}

  explicit PollUserStatusResponseBodyDataUserContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (breakCode) {
      res["BreakCode"] = boost::any(*breakCode);
    }
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (extension) {
      res["Extension"] = boost::any(*extension);
    }
    if (heartbeat) {
      res["Heartbeat"] = boost::any(*heartbeat);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (mobile) {
      res["Mobile"] = boost::any(*mobile);
    }
    if (outboundScenario) {
      res["OutboundScenario"] = boost::any(*outboundScenario);
    }
    if (reserved) {
      res["Reserved"] = boost::any(*reserved);
    }
    if (signedSkillGroupIdList) {
      res["SignedSkillGroupIdList"] = boost::any(*signedSkillGroupIdList);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (userState) {
      res["UserState"] = boost::any(*userState);
    }
    if (workMode) {
      res["WorkMode"] = boost::any(*workMode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BreakCode") != m.end() && !m["BreakCode"].empty()) {
      breakCode = make_shared<string>(boost::any_cast<string>(m["BreakCode"]));
    }
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("Extension") != m.end() && !m["Extension"].empty()) {
      extension = make_shared<string>(boost::any_cast<string>(m["Extension"]));
    }
    if (m.find("Heartbeat") != m.end() && !m["Heartbeat"].empty()) {
      heartbeat = make_shared<long>(boost::any_cast<long>(m["Heartbeat"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("Mobile") != m.end() && !m["Mobile"].empty()) {
      mobile = make_shared<string>(boost::any_cast<string>(m["Mobile"]));
    }
    if (m.find("OutboundScenario") != m.end() && !m["OutboundScenario"].empty()) {
      outboundScenario = make_shared<bool>(boost::any_cast<bool>(m["OutboundScenario"]));
    }
    if (m.find("Reserved") != m.end() && !m["Reserved"].empty()) {
      reserved = make_shared<long>(boost::any_cast<long>(m["Reserved"]));
    }
    if (m.find("SignedSkillGroupIdList") != m.end() && !m["SignedSkillGroupIdList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SignedSkillGroupIdList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SignedSkillGroupIdList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      signedSkillGroupIdList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
    if (m.find("UserState") != m.end() && !m["UserState"].empty()) {
      userState = make_shared<string>(boost::any_cast<string>(m["UserState"]));
    }
    if (m.find("WorkMode") != m.end() && !m["WorkMode"].empty()) {
      workMode = make_shared<string>(boost::any_cast<string>(m["WorkMode"]));
    }
  }


  virtual ~PollUserStatusResponseBodyDataUserContext() = default;
};
class PollUserStatusResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<PollUserStatusResponseBodyDataCallContext> callContext{};
  shared_ptr<long> contextId{};
  shared_ptr<PollUserStatusResponseBodyDataUserContext> userContext{};

  PollUserStatusResponseBodyData() {}

  explicit PollUserStatusResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callContext) {
      res["CallContext"] = callContext ? boost::any(callContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (contextId) {
      res["ContextId"] = boost::any(*contextId);
    }
    if (userContext) {
      res["UserContext"] = userContext ? boost::any(userContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallContext") != m.end() && !m["CallContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["CallContext"].type()) {
        PollUserStatusResponseBodyDataCallContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CallContext"]));
        callContext = make_shared<PollUserStatusResponseBodyDataCallContext>(model1);
      }
    }
    if (m.find("ContextId") != m.end() && !m["ContextId"].empty()) {
      contextId = make_shared<long>(boost::any_cast<long>(m["ContextId"]));
    }
    if (m.find("UserContext") != m.end() && !m["UserContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["UserContext"].type()) {
        PollUserStatusResponseBodyDataUserContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["UserContext"]));
        userContext = make_shared<PollUserStatusResponseBodyDataUserContext>(model1);
      }
    }
  }


  virtual ~PollUserStatusResponseBodyData() = default;
};
class PollUserStatusResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<PollUserStatusResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<vector<string>> params{};
  shared_ptr<string> requestId{};

  PollUserStatusResponseBody() {}

  explicit PollUserStatusResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (params) {
      res["Params"] = boost::any(*params);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        PollUserStatusResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<PollUserStatusResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Params") != m.end() && !m["Params"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Params"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Params"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      params = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~PollUserStatusResponseBody() = default;
};
class PollUserStatusResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<PollUserStatusResponseBody> body{};

  PollUserStatusResponse() {}

  explicit PollUserStatusResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        PollUserStatusResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<PollUserStatusResponseBody>(model1);
      }
    }
  }


  virtual ~PollUserStatusResponse() = default;
};
class ReadyForServiceRequest : public Darabonba::Model {
public:
  shared_ptr<string> deviceId{};
  shared_ptr<string> instanceId{};
  shared_ptr<bool> outboundScenario{};
  shared_ptr<string> userId{};

  ReadyForServiceRequest() {}

  explicit ReadyForServiceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (outboundScenario) {
      res["OutboundScenario"] = boost::any(*outboundScenario);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("OutboundScenario") != m.end() && !m["OutboundScenario"].empty()) {
      outboundScenario = make_shared<bool>(boost::any_cast<bool>(m["OutboundScenario"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~ReadyForServiceRequest() = default;
};
class ReadyForServiceResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> breakCode{};
  shared_ptr<string> deviceId{};
  shared_ptr<string> extension{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> jobId{};
  shared_ptr<bool> outboundScenario{};
  shared_ptr<vector<string>> signedSkillGroupIdList{};
  shared_ptr<string> userId{};
  shared_ptr<string> userState{};
  shared_ptr<string> workMode{};

  ReadyForServiceResponseBodyData() {}

  explicit ReadyForServiceResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (breakCode) {
      res["BreakCode"] = boost::any(*breakCode);
    }
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (extension) {
      res["Extension"] = boost::any(*extension);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (outboundScenario) {
      res["OutboundScenario"] = boost::any(*outboundScenario);
    }
    if (signedSkillGroupIdList) {
      res["SignedSkillGroupIdList"] = boost::any(*signedSkillGroupIdList);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (userState) {
      res["UserState"] = boost::any(*userState);
    }
    if (workMode) {
      res["WorkMode"] = boost::any(*workMode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BreakCode") != m.end() && !m["BreakCode"].empty()) {
      breakCode = make_shared<string>(boost::any_cast<string>(m["BreakCode"]));
    }
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("Extension") != m.end() && !m["Extension"].empty()) {
      extension = make_shared<string>(boost::any_cast<string>(m["Extension"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("OutboundScenario") != m.end() && !m["OutboundScenario"].empty()) {
      outboundScenario = make_shared<bool>(boost::any_cast<bool>(m["OutboundScenario"]));
    }
    if (m.find("SignedSkillGroupIdList") != m.end() && !m["SignedSkillGroupIdList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SignedSkillGroupIdList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SignedSkillGroupIdList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      signedSkillGroupIdList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
    if (m.find("UserState") != m.end() && !m["UserState"].empty()) {
      userState = make_shared<string>(boost::any_cast<string>(m["UserState"]));
    }
    if (m.find("WorkMode") != m.end() && !m["WorkMode"].empty()) {
      workMode = make_shared<string>(boost::any_cast<string>(m["WorkMode"]));
    }
  }


  virtual ~ReadyForServiceResponseBodyData() = default;
};
class ReadyForServiceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<ReadyForServiceResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<vector<string>> params{};
  shared_ptr<string> requestId{};

  ReadyForServiceResponseBody() {}

  explicit ReadyForServiceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (params) {
      res["Params"] = boost::any(*params);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ReadyForServiceResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ReadyForServiceResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Params") != m.end() && !m["Params"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Params"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Params"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      params = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ReadyForServiceResponseBody() = default;
};
class ReadyForServiceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ReadyForServiceResponseBody> body{};

  ReadyForServiceResponse() {}

  explicit ReadyForServiceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ReadyForServiceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ReadyForServiceResponseBody>(model1);
      }
    }
  }


  virtual ~ReadyForServiceResponse() = default;
};
class RegisterDeviceRequest : public Darabonba::Model {
public:
  shared_ptr<string> deviceId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> password{};
  shared_ptr<string> userId{};

  RegisterDeviceRequest() {}

  explicit RegisterDeviceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (password) {
      res["Password"] = boost::any(*password);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Password") != m.end() && !m["Password"].empty()) {
      password = make_shared<string>(boost::any_cast<string>(m["Password"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~RegisterDeviceRequest() = default;
};
class RegisterDeviceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<vector<string>> params{};
  shared_ptr<string> requestId{};

  RegisterDeviceResponseBody() {}

  explicit RegisterDeviceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (params) {
      res["Params"] = boost::any(*params);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Params") != m.end() && !m["Params"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Params"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Params"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      params = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RegisterDeviceResponseBody() = default;
};
class RegisterDeviceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RegisterDeviceResponseBody> body{};

  RegisterDeviceResponse() {}

  explicit RegisterDeviceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RegisterDeviceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RegisterDeviceResponseBody>(model1);
      }
    }
  }


  virtual ~RegisterDeviceResponse() = default;
};
class RegisterDevicesRequest : public Darabonba::Model {
public:
  shared_ptr<string> deviceId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> password{};
  shared_ptr<string> userIdListJson{};

  RegisterDevicesRequest() {}

  explicit RegisterDevicesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (password) {
      res["Password"] = boost::any(*password);
    }
    if (userIdListJson) {
      res["UserIdListJson"] = boost::any(*userIdListJson);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Password") != m.end() && !m["Password"].empty()) {
      password = make_shared<string>(boost::any_cast<string>(m["Password"]));
    }
    if (m.find("UserIdListJson") != m.end() && !m["UserIdListJson"].empty()) {
      userIdListJson = make_shared<string>(boost::any_cast<string>(m["UserIdListJson"]));
    }
  }


  virtual ~RegisterDevicesRequest() = default;
};
class RegisterDevicesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<vector<string>> params{};
  shared_ptr<string> requestId{};

  RegisterDevicesResponseBody() {}

  explicit RegisterDevicesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (params) {
      res["Params"] = boost::any(*params);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Params") != m.end() && !m["Params"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Params"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Params"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      params = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RegisterDevicesResponseBody() = default;
};
class RegisterDevicesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RegisterDevicesResponseBody> body{};

  RegisterDevicesResponse() {}

  explicit RegisterDevicesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RegisterDevicesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RegisterDevicesResponseBody>(model1);
      }
    }
  }


  virtual ~RegisterDevicesResponse() = default;
};
class ReleaseCallRequest : public Darabonba::Model {
public:
  shared_ptr<string> channelId{};
  shared_ptr<string> deviceId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> jobId{};
  shared_ptr<string> userId{};

  ReleaseCallRequest() {}

  explicit ReleaseCallRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (channelId) {
      res["ChannelId"] = boost::any(*channelId);
    }
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChannelId") != m.end() && !m["ChannelId"].empty()) {
      channelId = make_shared<string>(boost::any_cast<string>(m["ChannelId"]));
    }
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~ReleaseCallRequest() = default;
};
class ReleaseCallResponseBodyDataCallContextChannelContexts : public Darabonba::Model {
public:
  shared_ptr<string> callType{};
  shared_ptr<string> channelId{};
  shared_ptr<string> channelState{};
  shared_ptr<string> destination{};
  shared_ptr<string> jobId{};
  shared_ptr<string> originator{};
  shared_ptr<string> releaseInitiator{};
  shared_ptr<string> releaseReason{};
  shared_ptr<long> timestamp{};
  shared_ptr<string> userExtension{};
  shared_ptr<string> userId{};

  ReleaseCallResponseBodyDataCallContextChannelContexts() {}

  explicit ReleaseCallResponseBodyDataCallContextChannelContexts(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callType) {
      res["CallType"] = boost::any(*callType);
    }
    if (channelId) {
      res["ChannelId"] = boost::any(*channelId);
    }
    if (channelState) {
      res["ChannelState"] = boost::any(*channelState);
    }
    if (destination) {
      res["Destination"] = boost::any(*destination);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (originator) {
      res["Originator"] = boost::any(*originator);
    }
    if (releaseInitiator) {
      res["ReleaseInitiator"] = boost::any(*releaseInitiator);
    }
    if (releaseReason) {
      res["ReleaseReason"] = boost::any(*releaseReason);
    }
    if (timestamp) {
      res["Timestamp"] = boost::any(*timestamp);
    }
    if (userExtension) {
      res["UserExtension"] = boost::any(*userExtension);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallType") != m.end() && !m["CallType"].empty()) {
      callType = make_shared<string>(boost::any_cast<string>(m["CallType"]));
    }
    if (m.find("ChannelId") != m.end() && !m["ChannelId"].empty()) {
      channelId = make_shared<string>(boost::any_cast<string>(m["ChannelId"]));
    }
    if (m.find("ChannelState") != m.end() && !m["ChannelState"].empty()) {
      channelState = make_shared<string>(boost::any_cast<string>(m["ChannelState"]));
    }
    if (m.find("Destination") != m.end() && !m["Destination"].empty()) {
      destination = make_shared<string>(boost::any_cast<string>(m["Destination"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("Originator") != m.end() && !m["Originator"].empty()) {
      originator = make_shared<string>(boost::any_cast<string>(m["Originator"]));
    }
    if (m.find("ReleaseInitiator") != m.end() && !m["ReleaseInitiator"].empty()) {
      releaseInitiator = make_shared<string>(boost::any_cast<string>(m["ReleaseInitiator"]));
    }
    if (m.find("ReleaseReason") != m.end() && !m["ReleaseReason"].empty()) {
      releaseReason = make_shared<string>(boost::any_cast<string>(m["ReleaseReason"]));
    }
    if (m.find("Timestamp") != m.end() && !m["Timestamp"].empty()) {
      timestamp = make_shared<long>(boost::any_cast<long>(m["Timestamp"]));
    }
    if (m.find("UserExtension") != m.end() && !m["UserExtension"].empty()) {
      userExtension = make_shared<string>(boost::any_cast<string>(m["UserExtension"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~ReleaseCallResponseBodyDataCallContextChannelContexts() = default;
};
class ReleaseCallResponseBodyDataCallContext : public Darabonba::Model {
public:
  shared_ptr<vector<ReleaseCallResponseBodyDataCallContextChannelContexts>> channelContexts{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> jobId{};

  ReleaseCallResponseBodyDataCallContext() {}

  explicit ReleaseCallResponseBodyDataCallContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (channelContexts) {
      vector<boost::any> temp1;
      for(auto item1:*channelContexts){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ChannelContexts"] = boost::any(temp1);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChannelContexts") != m.end() && !m["ChannelContexts"].empty()) {
      if (typeid(vector<boost::any>) == m["ChannelContexts"].type()) {
        vector<ReleaseCallResponseBodyDataCallContextChannelContexts> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ChannelContexts"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ReleaseCallResponseBodyDataCallContextChannelContexts model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        channelContexts = make_shared<vector<ReleaseCallResponseBodyDataCallContextChannelContexts>>(expect1);
      }
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
  }


  virtual ~ReleaseCallResponseBodyDataCallContext() = default;
};
class ReleaseCallResponseBodyDataUserContext : public Darabonba::Model {
public:
  shared_ptr<string> breakCode{};
  shared_ptr<string> deviceId{};
  shared_ptr<string> extension{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> jobId{};
  shared_ptr<bool> outboundScenario{};
  shared_ptr<vector<string>> signedSkillGroupIdList{};
  shared_ptr<string> userId{};
  shared_ptr<string> userState{};
  shared_ptr<string> workMode{};

  ReleaseCallResponseBodyDataUserContext() {}

  explicit ReleaseCallResponseBodyDataUserContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (breakCode) {
      res["BreakCode"] = boost::any(*breakCode);
    }
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (extension) {
      res["Extension"] = boost::any(*extension);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (outboundScenario) {
      res["OutboundScenario"] = boost::any(*outboundScenario);
    }
    if (signedSkillGroupIdList) {
      res["SignedSkillGroupIdList"] = boost::any(*signedSkillGroupIdList);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (userState) {
      res["UserState"] = boost::any(*userState);
    }
    if (workMode) {
      res["WorkMode"] = boost::any(*workMode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BreakCode") != m.end() && !m["BreakCode"].empty()) {
      breakCode = make_shared<string>(boost::any_cast<string>(m["BreakCode"]));
    }
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("Extension") != m.end() && !m["Extension"].empty()) {
      extension = make_shared<string>(boost::any_cast<string>(m["Extension"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("OutboundScenario") != m.end() && !m["OutboundScenario"].empty()) {
      outboundScenario = make_shared<bool>(boost::any_cast<bool>(m["OutboundScenario"]));
    }
    if (m.find("SignedSkillGroupIdList") != m.end() && !m["SignedSkillGroupIdList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SignedSkillGroupIdList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SignedSkillGroupIdList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      signedSkillGroupIdList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
    if (m.find("UserState") != m.end() && !m["UserState"].empty()) {
      userState = make_shared<string>(boost::any_cast<string>(m["UserState"]));
    }
    if (m.find("WorkMode") != m.end() && !m["WorkMode"].empty()) {
      workMode = make_shared<string>(boost::any_cast<string>(m["WorkMode"]));
    }
  }


  virtual ~ReleaseCallResponseBodyDataUserContext() = default;
};
class ReleaseCallResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<ReleaseCallResponseBodyDataCallContext> callContext{};
  shared_ptr<long> contextId{};
  shared_ptr<ReleaseCallResponseBodyDataUserContext> userContext{};

  ReleaseCallResponseBodyData() {}

  explicit ReleaseCallResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callContext) {
      res["CallContext"] = callContext ? boost::any(callContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (contextId) {
      res["ContextId"] = boost::any(*contextId);
    }
    if (userContext) {
      res["UserContext"] = userContext ? boost::any(userContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallContext") != m.end() && !m["CallContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["CallContext"].type()) {
        ReleaseCallResponseBodyDataCallContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CallContext"]));
        callContext = make_shared<ReleaseCallResponseBodyDataCallContext>(model1);
      }
    }
    if (m.find("ContextId") != m.end() && !m["ContextId"].empty()) {
      contextId = make_shared<long>(boost::any_cast<long>(m["ContextId"]));
    }
    if (m.find("UserContext") != m.end() && !m["UserContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["UserContext"].type()) {
        ReleaseCallResponseBodyDataUserContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["UserContext"]));
        userContext = make_shared<ReleaseCallResponseBodyDataUserContext>(model1);
      }
    }
  }


  virtual ~ReleaseCallResponseBodyData() = default;
};
class ReleaseCallResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<ReleaseCallResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<vector<string>> params{};
  shared_ptr<string> requestId{};

  ReleaseCallResponseBody() {}

  explicit ReleaseCallResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (params) {
      res["Params"] = boost::any(*params);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ReleaseCallResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ReleaseCallResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Params") != m.end() && !m["Params"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Params"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Params"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      params = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ReleaseCallResponseBody() = default;
};
class ReleaseCallResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ReleaseCallResponseBody> body{};

  ReleaseCallResponse() {}

  explicit ReleaseCallResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ReleaseCallResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ReleaseCallResponseBody>(model1);
      }
    }
  }


  virtual ~ReleaseCallResponse() = default;
};
class RemoveDoNotCallNumbersRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> numberList{};

  RemoveDoNotCallNumbersRequest() {}

  explicit RemoveDoNotCallNumbersRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (numberList) {
      res["NumberList"] = boost::any(*numberList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("NumberList") != m.end() && !m["NumberList"].empty()) {
      numberList = make_shared<string>(boost::any_cast<string>(m["NumberList"]));
    }
  }


  virtual ~RemoveDoNotCallNumbersRequest() = default;
};
class RemoveDoNotCallNumbersResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  RemoveDoNotCallNumbersResponseBody() {}

  explicit RemoveDoNotCallNumbersResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RemoveDoNotCallNumbersResponseBody() = default;
};
class RemoveDoNotCallNumbersResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RemoveDoNotCallNumbersResponseBody> body{};

  RemoveDoNotCallNumbersResponse() {}

  explicit RemoveDoNotCallNumbersResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RemoveDoNotCallNumbersResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RemoveDoNotCallNumbersResponseBody>(model1);
      }
    }
  }


  virtual ~RemoveDoNotCallNumbersResponse() = default;
};
class RemovePersonalNumbersFromUserRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> numberList{};
  shared_ptr<string> userId{};

  RemovePersonalNumbersFromUserRequest() {}

  explicit RemovePersonalNumbersFromUserRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (numberList) {
      res["NumberList"] = boost::any(*numberList);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("NumberList") != m.end() && !m["NumberList"].empty()) {
      numberList = make_shared<string>(boost::any_cast<string>(m["NumberList"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~RemovePersonalNumbersFromUserRequest() = default;
};
class RemovePersonalNumbersFromUserResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  RemovePersonalNumbersFromUserResponseBody() {}

  explicit RemovePersonalNumbersFromUserResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RemovePersonalNumbersFromUserResponseBody() = default;
};
class RemovePersonalNumbersFromUserResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RemovePersonalNumbersFromUserResponseBody> body{};

  RemovePersonalNumbersFromUserResponse() {}

  explicit RemovePersonalNumbersFromUserResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RemovePersonalNumbersFromUserResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RemovePersonalNumbersFromUserResponseBody>(model1);
      }
    }
  }


  virtual ~RemovePersonalNumbersFromUserResponse() = default;
};
class RemovePhoneNumberFromSkillGroupsRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> number{};
  shared_ptr<string> skillGroupIdList{};

  RemovePhoneNumberFromSkillGroupsRequest() {}

  explicit RemovePhoneNumberFromSkillGroupsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (number) {
      res["Number"] = boost::any(*number);
    }
    if (skillGroupIdList) {
      res["SkillGroupIdList"] = boost::any(*skillGroupIdList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Number") != m.end() && !m["Number"].empty()) {
      number = make_shared<string>(boost::any_cast<string>(m["Number"]));
    }
    if (m.find("SkillGroupIdList") != m.end() && !m["SkillGroupIdList"].empty()) {
      skillGroupIdList = make_shared<string>(boost::any_cast<string>(m["SkillGroupIdList"]));
    }
  }


  virtual ~RemovePhoneNumberFromSkillGroupsRequest() = default;
};
class RemovePhoneNumberFromSkillGroupsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  RemovePhoneNumberFromSkillGroupsResponseBody() {}

  explicit RemovePhoneNumberFromSkillGroupsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RemovePhoneNumberFromSkillGroupsResponseBody() = default;
};
class RemovePhoneNumberFromSkillGroupsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RemovePhoneNumberFromSkillGroupsResponseBody> body{};

  RemovePhoneNumberFromSkillGroupsResponse() {}

  explicit RemovePhoneNumberFromSkillGroupsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RemovePhoneNumberFromSkillGroupsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RemovePhoneNumberFromSkillGroupsResponseBody>(model1);
      }
    }
  }


  virtual ~RemovePhoneNumberFromSkillGroupsResponse() = default;
};
class RemovePhoneNumbersRequest : public Darabonba::Model {
public:
  shared_ptr<bool> force{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> numberList{};

  RemovePhoneNumbersRequest() {}

  explicit RemovePhoneNumbersRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (force) {
      res["Force"] = boost::any(*force);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (numberList) {
      res["NumberList"] = boost::any(*numberList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Force") != m.end() && !m["Force"].empty()) {
      force = make_shared<bool>(boost::any_cast<bool>(m["Force"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("NumberList") != m.end() && !m["NumberList"].empty()) {
      numberList = make_shared<string>(boost::any_cast<string>(m["NumberList"]));
    }
  }


  virtual ~RemovePhoneNumbersRequest() = default;
};
class RemovePhoneNumbersResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<vector<string>> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  RemovePhoneNumbersResponseBody() {}

  explicit RemovePhoneNumbersResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Data"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      data = make_shared<vector<string>>(toVec1);
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RemovePhoneNumbersResponseBody() = default;
};
class RemovePhoneNumbersResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RemovePhoneNumbersResponseBody> body{};

  RemovePhoneNumbersResponse() {}

  explicit RemovePhoneNumbersResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RemovePhoneNumbersResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RemovePhoneNumbersResponseBody>(model1);
      }
    }
  }


  virtual ~RemovePhoneNumbersResponse() = default;
};
class RemovePhoneNumbersFromSkillGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> numberList{};
  shared_ptr<string> skillGroupId{};

  RemovePhoneNumbersFromSkillGroupRequest() {}

  explicit RemovePhoneNumbersFromSkillGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (numberList) {
      res["NumberList"] = boost::any(*numberList);
    }
    if (skillGroupId) {
      res["SkillGroupId"] = boost::any(*skillGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("NumberList") != m.end() && !m["NumberList"].empty()) {
      numberList = make_shared<string>(boost::any_cast<string>(m["NumberList"]));
    }
    if (m.find("SkillGroupId") != m.end() && !m["SkillGroupId"].empty()) {
      skillGroupId = make_shared<string>(boost::any_cast<string>(m["SkillGroupId"]));
    }
  }


  virtual ~RemovePhoneNumbersFromSkillGroupRequest() = default;
};
class RemovePhoneNumbersFromSkillGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  RemovePhoneNumbersFromSkillGroupResponseBody() {}

  explicit RemovePhoneNumbersFromSkillGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RemovePhoneNumbersFromSkillGroupResponseBody() = default;
};
class RemovePhoneNumbersFromSkillGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RemovePhoneNumbersFromSkillGroupResponseBody> body{};

  RemovePhoneNumbersFromSkillGroupResponse() {}

  explicit RemovePhoneNumbersFromSkillGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RemovePhoneNumbersFromSkillGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RemovePhoneNumbersFromSkillGroupResponseBody>(model1);
      }
    }
  }


  virtual ~RemovePhoneNumbersFromSkillGroupResponse() = default;
};
class RemoveSkillGroupsFromUserRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> skillGroupIdList{};
  shared_ptr<string> userId{};

  RemoveSkillGroupsFromUserRequest() {}

  explicit RemoveSkillGroupsFromUserRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (skillGroupIdList) {
      res["SkillGroupIdList"] = boost::any(*skillGroupIdList);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("SkillGroupIdList") != m.end() && !m["SkillGroupIdList"].empty()) {
      skillGroupIdList = make_shared<string>(boost::any_cast<string>(m["SkillGroupIdList"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~RemoveSkillGroupsFromUserRequest() = default;
};
class RemoveSkillGroupsFromUserResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  RemoveSkillGroupsFromUserResponseBody() {}

  explicit RemoveSkillGroupsFromUserResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RemoveSkillGroupsFromUserResponseBody() = default;
};
class RemoveSkillGroupsFromUserResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RemoveSkillGroupsFromUserResponseBody> body{};

  RemoveSkillGroupsFromUserResponse() {}

  explicit RemoveSkillGroupsFromUserResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RemoveSkillGroupsFromUserResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RemoveSkillGroupsFromUserResponseBody>(model1);
      }
    }
  }


  virtual ~RemoveSkillGroupsFromUserResponse() = default;
};
class RemoveUsersRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> userIdList{};

  RemoveUsersRequest() {}

  explicit RemoveUsersRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (userIdList) {
      res["UserIdList"] = boost::any(*userIdList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("UserIdList") != m.end() && !m["UserIdList"].empty()) {
      userIdList = make_shared<string>(boost::any_cast<string>(m["UserIdList"]));
    }
  }


  virtual ~RemoveUsersRequest() = default;
};
class RemoveUsersResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<vector<string>> params{};
  shared_ptr<string> requestId{};

  RemoveUsersResponseBody() {}

  explicit RemoveUsersResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (params) {
      res["Params"] = boost::any(*params);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Params") != m.end() && !m["Params"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Params"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Params"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      params = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RemoveUsersResponseBody() = default;
};
class RemoveUsersResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RemoveUsersResponseBody> body{};

  RemoveUsersResponse() {}

  explicit RemoveUsersResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RemoveUsersResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RemoveUsersResponseBody>(model1);
      }
    }
  }


  virtual ~RemoveUsersResponse() = default;
};
class RemoveUsersFromSkillGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> skillGroupId{};
  shared_ptr<string> userIdList{};

  RemoveUsersFromSkillGroupRequest() {}

  explicit RemoveUsersFromSkillGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (skillGroupId) {
      res["SkillGroupId"] = boost::any(*skillGroupId);
    }
    if (userIdList) {
      res["UserIdList"] = boost::any(*userIdList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("SkillGroupId") != m.end() && !m["SkillGroupId"].empty()) {
      skillGroupId = make_shared<string>(boost::any_cast<string>(m["SkillGroupId"]));
    }
    if (m.find("UserIdList") != m.end() && !m["UserIdList"].empty()) {
      userIdList = make_shared<string>(boost::any_cast<string>(m["UserIdList"]));
    }
  }


  virtual ~RemoveUsersFromSkillGroupRequest() = default;
};
class RemoveUsersFromSkillGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  RemoveUsersFromSkillGroupResponseBody() {}

  explicit RemoveUsersFromSkillGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RemoveUsersFromSkillGroupResponseBody() = default;
};
class RemoveUsersFromSkillGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RemoveUsersFromSkillGroupResponseBody> body{};

  RemoveUsersFromSkillGroupResponse() {}

  explicit RemoveUsersFromSkillGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RemoveUsersFromSkillGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RemoveUsersFromSkillGroupResponseBody>(model1);
      }
    }
  }


  virtual ~RemoveUsersFromSkillGroupResponse() = default;
};
class ResetAgentStateRequest : public Darabonba::Model {
public:
  shared_ptr<string> deviceId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> userId{};

  ResetAgentStateRequest() {}

  explicit ResetAgentStateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~ResetAgentStateRequest() = default;
};
class ResetAgentStateResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> breakCode{};
  shared_ptr<string> deviceId{};
  shared_ptr<string> extension{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> jobId{};
  shared_ptr<bool> outboundScenario{};
  shared_ptr<vector<string>> signedSkillGroupIdList{};
  shared_ptr<string> userId{};
  shared_ptr<string> userState{};
  shared_ptr<string> workMode{};

  ResetAgentStateResponseBodyData() {}

  explicit ResetAgentStateResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (breakCode) {
      res["BreakCode"] = boost::any(*breakCode);
    }
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (extension) {
      res["Extension"] = boost::any(*extension);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (outboundScenario) {
      res["OutboundScenario"] = boost::any(*outboundScenario);
    }
    if (signedSkillGroupIdList) {
      res["SignedSkillGroupIdList"] = boost::any(*signedSkillGroupIdList);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (userState) {
      res["UserState"] = boost::any(*userState);
    }
    if (workMode) {
      res["WorkMode"] = boost::any(*workMode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BreakCode") != m.end() && !m["BreakCode"].empty()) {
      breakCode = make_shared<string>(boost::any_cast<string>(m["BreakCode"]));
    }
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("Extension") != m.end() && !m["Extension"].empty()) {
      extension = make_shared<string>(boost::any_cast<string>(m["Extension"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("OutboundScenario") != m.end() && !m["OutboundScenario"].empty()) {
      outboundScenario = make_shared<bool>(boost::any_cast<bool>(m["OutboundScenario"]));
    }
    if (m.find("SignedSkillGroupIdList") != m.end() && !m["SignedSkillGroupIdList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SignedSkillGroupIdList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SignedSkillGroupIdList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      signedSkillGroupIdList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
    if (m.find("UserState") != m.end() && !m["UserState"].empty()) {
      userState = make_shared<string>(boost::any_cast<string>(m["UserState"]));
    }
    if (m.find("WorkMode") != m.end() && !m["WorkMode"].empty()) {
      workMode = make_shared<string>(boost::any_cast<string>(m["WorkMode"]));
    }
  }


  virtual ~ResetAgentStateResponseBodyData() = default;
};
class ResetAgentStateResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<ResetAgentStateResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<vector<string>> params{};
  shared_ptr<string> requestId{};

  ResetAgentStateResponseBody() {}

  explicit ResetAgentStateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (params) {
      res["Params"] = boost::any(*params);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        ResetAgentStateResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<ResetAgentStateResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Params") != m.end() && !m["Params"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Params"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Params"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      params = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ResetAgentStateResponseBody() = default;
};
class ResetAgentStateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ResetAgentStateResponseBody> body{};

  ResetAgentStateResponse() {}

  explicit ResetAgentStateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ResetAgentStateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ResetAgentStateResponseBody>(model1);
      }
    }
  }


  virtual ~ResetAgentStateResponse() = default;
};
class ResetUserPasswordRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> password{};
  shared_ptr<string> userId{};

  ResetUserPasswordRequest() {}

  explicit ResetUserPasswordRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (password) {
      res["Password"] = boost::any(*password);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Password") != m.end() && !m["Password"].empty()) {
      password = make_shared<string>(boost::any_cast<string>(m["Password"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~ResetUserPasswordRequest() = default;
};
class ResetUserPasswordResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  ResetUserPasswordResponseBody() {}

  explicit ResetUserPasswordResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ResetUserPasswordResponseBody() = default;
};
class ResetUserPasswordResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ResetUserPasswordResponseBody> body{};

  ResetUserPasswordResponse() {}

  explicit ResetUserPasswordResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ResetUserPasswordResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ResetUserPasswordResponseBody>(model1);
      }
    }
  }


  virtual ~ResetUserPasswordResponse() = default;
};
class RestoreArchivedRecordingsRequest : public Darabonba::Model {
public:
  shared_ptr<string> contactIds{};
  shared_ptr<string> instanceId{};

  RestoreArchivedRecordingsRequest() {}

  explicit RestoreArchivedRecordingsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contactIds) {
      res["ContactIds"] = boost::any(*contactIds);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ContactIds") != m.end() && !m["ContactIds"].empty()) {
      contactIds = make_shared<string>(boost::any_cast<string>(m["ContactIds"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~RestoreArchivedRecordingsRequest() = default;
};
class RestoreArchivedRecordingsResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> contactId{};
  shared_ptr<string> exists{};
  shared_ptr<string> status{};
  shared_ptr<string> storageType{};

  RestoreArchivedRecordingsResponseBodyData() {}

  explicit RestoreArchivedRecordingsResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contactId) {
      res["ContactId"] = boost::any(*contactId);
    }
    if (exists) {
      res["Exists"] = boost::any(*exists);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (storageType) {
      res["StorageType"] = boost::any(*storageType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ContactId") != m.end() && !m["ContactId"].empty()) {
      contactId = make_shared<string>(boost::any_cast<string>(m["ContactId"]));
    }
    if (m.find("Exists") != m.end() && !m["Exists"].empty()) {
      exists = make_shared<string>(boost::any_cast<string>(m["Exists"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("StorageType") != m.end() && !m["StorageType"].empty()) {
      storageType = make_shared<string>(boost::any_cast<string>(m["StorageType"]));
    }
  }


  virtual ~RestoreArchivedRecordingsResponseBodyData() = default;
};
class RestoreArchivedRecordingsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<vector<RestoreArchivedRecordingsResponseBodyData>> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  RestoreArchivedRecordingsResponseBody() {}

  explicit RestoreArchivedRecordingsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Data"] = boost::any(temp1);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(vector<boost::any>) == m["Data"].type()) {
        vector<RestoreArchivedRecordingsResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            RestoreArchivedRecordingsResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<RestoreArchivedRecordingsResponseBodyData>>(expect1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RestoreArchivedRecordingsResponseBody() = default;
};
class RestoreArchivedRecordingsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RestoreArchivedRecordingsResponseBody> body{};

  RestoreArchivedRecordingsResponse() {}

  explicit RestoreArchivedRecordingsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RestoreArchivedRecordingsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RestoreArchivedRecordingsResponseBody>(model1);
      }
    }
  }


  virtual ~RestoreArchivedRecordingsResponse() = default;
};
class ResumeCampaignRequest : public Darabonba::Model {
public:
  shared_ptr<string> campaignId{};
  shared_ptr<string> instanceId{};

  ResumeCampaignRequest() {}

  explicit ResumeCampaignRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (campaignId) {
      res["CampaignId"] = boost::any(*campaignId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CampaignId") != m.end() && !m["CampaignId"].empty()) {
      campaignId = make_shared<string>(boost::any_cast<string>(m["CampaignId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~ResumeCampaignRequest() = default;
};
class ResumeCampaignResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  ResumeCampaignResponseBody() {}

  explicit ResumeCampaignResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<string>(boost::any_cast<string>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ResumeCampaignResponseBody() = default;
};
class ResumeCampaignResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ResumeCampaignResponseBody> body{};

  ResumeCampaignResponse() {}

  explicit ResumeCampaignResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ResumeCampaignResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ResumeCampaignResponseBody>(model1);
      }
    }
  }


  virtual ~ResumeCampaignResponse() = default;
};
class RetrieveCallRequest : public Darabonba::Model {
public:
  shared_ptr<string> channelId{};
  shared_ptr<string> deviceId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> jobId{};
  shared_ptr<string> userId{};

  RetrieveCallRequest() {}

  explicit RetrieveCallRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (channelId) {
      res["ChannelId"] = boost::any(*channelId);
    }
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChannelId") != m.end() && !m["ChannelId"].empty()) {
      channelId = make_shared<string>(boost::any_cast<string>(m["ChannelId"]));
    }
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~RetrieveCallRequest() = default;
};
class RetrieveCallResponseBodyDataCallContextChannelContexts : public Darabonba::Model {
public:
  shared_ptr<string> callType{};
  shared_ptr<string> channelId{};
  shared_ptr<string> channelState{};
  shared_ptr<string> destination{};
  shared_ptr<string> jobId{};
  shared_ptr<string> originator{};
  shared_ptr<string> releaseInitiator{};
  shared_ptr<string> releaseReason{};
  shared_ptr<string> skillGroupId{};
  shared_ptr<long> timestamp{};
  shared_ptr<string> userExtension{};
  shared_ptr<string> userId{};

  RetrieveCallResponseBodyDataCallContextChannelContexts() {}

  explicit RetrieveCallResponseBodyDataCallContextChannelContexts(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callType) {
      res["CallType"] = boost::any(*callType);
    }
    if (channelId) {
      res["ChannelId"] = boost::any(*channelId);
    }
    if (channelState) {
      res["ChannelState"] = boost::any(*channelState);
    }
    if (destination) {
      res["Destination"] = boost::any(*destination);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (originator) {
      res["Originator"] = boost::any(*originator);
    }
    if (releaseInitiator) {
      res["ReleaseInitiator"] = boost::any(*releaseInitiator);
    }
    if (releaseReason) {
      res["ReleaseReason"] = boost::any(*releaseReason);
    }
    if (skillGroupId) {
      res["SkillGroupId"] = boost::any(*skillGroupId);
    }
    if (timestamp) {
      res["Timestamp"] = boost::any(*timestamp);
    }
    if (userExtension) {
      res["UserExtension"] = boost::any(*userExtension);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallType") != m.end() && !m["CallType"].empty()) {
      callType = make_shared<string>(boost::any_cast<string>(m["CallType"]));
    }
    if (m.find("ChannelId") != m.end() && !m["ChannelId"].empty()) {
      channelId = make_shared<string>(boost::any_cast<string>(m["ChannelId"]));
    }
    if (m.find("ChannelState") != m.end() && !m["ChannelState"].empty()) {
      channelState = make_shared<string>(boost::any_cast<string>(m["ChannelState"]));
    }
    if (m.find("Destination") != m.end() && !m["Destination"].empty()) {
      destination = make_shared<string>(boost::any_cast<string>(m["Destination"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("Originator") != m.end() && !m["Originator"].empty()) {
      originator = make_shared<string>(boost::any_cast<string>(m["Originator"]));
    }
    if (m.find("ReleaseInitiator") != m.end() && !m["ReleaseInitiator"].empty()) {
      releaseInitiator = make_shared<string>(boost::any_cast<string>(m["ReleaseInitiator"]));
    }
    if (m.find("ReleaseReason") != m.end() && !m["ReleaseReason"].empty()) {
      releaseReason = make_shared<string>(boost::any_cast<string>(m["ReleaseReason"]));
    }
    if (m.find("SkillGroupId") != m.end() && !m["SkillGroupId"].empty()) {
      skillGroupId = make_shared<string>(boost::any_cast<string>(m["SkillGroupId"]));
    }
    if (m.find("Timestamp") != m.end() && !m["Timestamp"].empty()) {
      timestamp = make_shared<long>(boost::any_cast<long>(m["Timestamp"]));
    }
    if (m.find("UserExtension") != m.end() && !m["UserExtension"].empty()) {
      userExtension = make_shared<string>(boost::any_cast<string>(m["UserExtension"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~RetrieveCallResponseBodyDataCallContextChannelContexts() = default;
};
class RetrieveCallResponseBodyDataCallContext : public Darabonba::Model {
public:
  shared_ptr<string> callType{};
  shared_ptr<vector<RetrieveCallResponseBodyDataCallContextChannelContexts>> channelContexts{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> jobId{};

  RetrieveCallResponseBodyDataCallContext() {}

  explicit RetrieveCallResponseBodyDataCallContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callType) {
      res["CallType"] = boost::any(*callType);
    }
    if (channelContexts) {
      vector<boost::any> temp1;
      for(auto item1:*channelContexts){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ChannelContexts"] = boost::any(temp1);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallType") != m.end() && !m["CallType"].empty()) {
      callType = make_shared<string>(boost::any_cast<string>(m["CallType"]));
    }
    if (m.find("ChannelContexts") != m.end() && !m["ChannelContexts"].empty()) {
      if (typeid(vector<boost::any>) == m["ChannelContexts"].type()) {
        vector<RetrieveCallResponseBodyDataCallContextChannelContexts> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ChannelContexts"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            RetrieveCallResponseBodyDataCallContextChannelContexts model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        channelContexts = make_shared<vector<RetrieveCallResponseBodyDataCallContextChannelContexts>>(expect1);
      }
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
  }


  virtual ~RetrieveCallResponseBodyDataCallContext() = default;
};
class RetrieveCallResponseBodyDataUserContext : public Darabonba::Model {
public:
  shared_ptr<string> breakCode{};
  shared_ptr<string> deviceId{};
  shared_ptr<string> extension{};
  shared_ptr<long> heartbeat{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> jobId{};
  shared_ptr<string> mobile{};
  shared_ptr<bool> outboundScenario{};
  shared_ptr<long> reserved{};
  shared_ptr<vector<string>> signedSkillGroupIdList{};
  shared_ptr<string> userId{};
  shared_ptr<string> userState{};
  shared_ptr<string> workMode{};

  RetrieveCallResponseBodyDataUserContext() {}

  explicit RetrieveCallResponseBodyDataUserContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (breakCode) {
      res["BreakCode"] = boost::any(*breakCode);
    }
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (extension) {
      res["Extension"] = boost::any(*extension);
    }
    if (heartbeat) {
      res["Heartbeat"] = boost::any(*heartbeat);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (mobile) {
      res["Mobile"] = boost::any(*mobile);
    }
    if (outboundScenario) {
      res["OutboundScenario"] = boost::any(*outboundScenario);
    }
    if (reserved) {
      res["Reserved"] = boost::any(*reserved);
    }
    if (signedSkillGroupIdList) {
      res["SignedSkillGroupIdList"] = boost::any(*signedSkillGroupIdList);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (userState) {
      res["UserState"] = boost::any(*userState);
    }
    if (workMode) {
      res["WorkMode"] = boost::any(*workMode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BreakCode") != m.end() && !m["BreakCode"].empty()) {
      breakCode = make_shared<string>(boost::any_cast<string>(m["BreakCode"]));
    }
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("Extension") != m.end() && !m["Extension"].empty()) {
      extension = make_shared<string>(boost::any_cast<string>(m["Extension"]));
    }
    if (m.find("Heartbeat") != m.end() && !m["Heartbeat"].empty()) {
      heartbeat = make_shared<long>(boost::any_cast<long>(m["Heartbeat"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("Mobile") != m.end() && !m["Mobile"].empty()) {
      mobile = make_shared<string>(boost::any_cast<string>(m["Mobile"]));
    }
    if (m.find("OutboundScenario") != m.end() && !m["OutboundScenario"].empty()) {
      outboundScenario = make_shared<bool>(boost::any_cast<bool>(m["OutboundScenario"]));
    }
    if (m.find("Reserved") != m.end() && !m["Reserved"].empty()) {
      reserved = make_shared<long>(boost::any_cast<long>(m["Reserved"]));
    }
    if (m.find("SignedSkillGroupIdList") != m.end() && !m["SignedSkillGroupIdList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SignedSkillGroupIdList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SignedSkillGroupIdList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      signedSkillGroupIdList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
    if (m.find("UserState") != m.end() && !m["UserState"].empty()) {
      userState = make_shared<string>(boost::any_cast<string>(m["UserState"]));
    }
    if (m.find("WorkMode") != m.end() && !m["WorkMode"].empty()) {
      workMode = make_shared<string>(boost::any_cast<string>(m["WorkMode"]));
    }
  }


  virtual ~RetrieveCallResponseBodyDataUserContext() = default;
};
class RetrieveCallResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<RetrieveCallResponseBodyDataCallContext> callContext{};
  shared_ptr<RetrieveCallResponseBodyDataUserContext> userContext{};

  RetrieveCallResponseBodyData() {}

  explicit RetrieveCallResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callContext) {
      res["CallContext"] = callContext ? boost::any(callContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (userContext) {
      res["UserContext"] = userContext ? boost::any(userContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallContext") != m.end() && !m["CallContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["CallContext"].type()) {
        RetrieveCallResponseBodyDataCallContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CallContext"]));
        callContext = make_shared<RetrieveCallResponseBodyDataCallContext>(model1);
      }
    }
    if (m.find("UserContext") != m.end() && !m["UserContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["UserContext"].type()) {
        RetrieveCallResponseBodyDataUserContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["UserContext"]));
        userContext = make_shared<RetrieveCallResponseBodyDataUserContext>(model1);
      }
    }
  }


  virtual ~RetrieveCallResponseBodyData() = default;
};
class RetrieveCallResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<RetrieveCallResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<vector<string>> params{};
  shared_ptr<string> requestId{};

  RetrieveCallResponseBody() {}

  explicit RetrieveCallResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (params) {
      res["Params"] = boost::any(*params);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        RetrieveCallResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<RetrieveCallResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Params") != m.end() && !m["Params"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Params"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Params"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      params = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RetrieveCallResponseBody() = default;
};
class RetrieveCallResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RetrieveCallResponseBody> body{};

  RetrieveCallResponse() {}

  explicit RetrieveCallResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RetrieveCallResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RetrieveCallResponseBody>(model1);
      }
    }
  }


  virtual ~RetrieveCallResponse() = default;
};
class SaveRTCStatsV2Request : public Darabonba::Model {
public:
  shared_ptr<string> callId{};
  shared_ptr<string> generalInfo{};
  shared_ptr<string> googAddress{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> receiverReport{};
  shared_ptr<string> senderReport{};

  SaveRTCStatsV2Request() {}

  explicit SaveRTCStatsV2Request(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callId) {
      res["CallId"] = boost::any(*callId);
    }
    if (generalInfo) {
      res["GeneralInfo"] = boost::any(*generalInfo);
    }
    if (googAddress) {
      res["GoogAddress"] = boost::any(*googAddress);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (receiverReport) {
      res["ReceiverReport"] = boost::any(*receiverReport);
    }
    if (senderReport) {
      res["SenderReport"] = boost::any(*senderReport);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallId") != m.end() && !m["CallId"].empty()) {
      callId = make_shared<string>(boost::any_cast<string>(m["CallId"]));
    }
    if (m.find("GeneralInfo") != m.end() && !m["GeneralInfo"].empty()) {
      generalInfo = make_shared<string>(boost::any_cast<string>(m["GeneralInfo"]));
    }
    if (m.find("GoogAddress") != m.end() && !m["GoogAddress"].empty()) {
      googAddress = make_shared<string>(boost::any_cast<string>(m["GoogAddress"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("ReceiverReport") != m.end() && !m["ReceiverReport"].empty()) {
      receiverReport = make_shared<string>(boost::any_cast<string>(m["ReceiverReport"]));
    }
    if (m.find("SenderReport") != m.end() && !m["SenderReport"].empty()) {
      senderReport = make_shared<string>(boost::any_cast<string>(m["SenderReport"]));
    }
  }


  virtual ~SaveRTCStatsV2Request() = default;
};
class SaveRTCStatsV2ResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<long> rowCount{};
  shared_ptr<bool> success{};
  shared_ptr<long> timeStamp{};

  SaveRTCStatsV2ResponseBody() {}

  explicit SaveRTCStatsV2ResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (rowCount) {
      res["RowCount"] = boost::any(*rowCount);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (timeStamp) {
      res["TimeStamp"] = boost::any(*timeStamp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("RowCount") != m.end() && !m["RowCount"].empty()) {
      rowCount = make_shared<long>(boost::any_cast<long>(m["RowCount"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TimeStamp") != m.end() && !m["TimeStamp"].empty()) {
      timeStamp = make_shared<long>(boost::any_cast<long>(m["TimeStamp"]));
    }
  }


  virtual ~SaveRTCStatsV2ResponseBody() = default;
};
class SaveRTCStatsV2Response : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SaveRTCStatsV2ResponseBody> body{};

  SaveRTCStatsV2Response() {}

  explicit SaveRTCStatsV2Response(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SaveRTCStatsV2ResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SaveRTCStatsV2ResponseBody>(model1);
      }
    }
  }


  virtual ~SaveRTCStatsV2Response() = default;
};
class SaveTerminalLogRequest : public Darabonba::Model {
public:
  shared_ptr<string> appName{};
  shared_ptr<string> callId{};
  shared_ptr<string> content{};
  shared_ptr<long> dataType{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> jobId{};
  shared_ptr<string> methodName{};
  shared_ptr<string> status{};
  shared_ptr<string> uniqueRequestId{};

  SaveTerminalLogRequest() {}

  explicit SaveTerminalLogRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (callId) {
      res["CallId"] = boost::any(*callId);
    }
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (dataType) {
      res["DataType"] = boost::any(*dataType);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (methodName) {
      res["MethodName"] = boost::any(*methodName);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (uniqueRequestId) {
      res["UniqueRequestId"] = boost::any(*uniqueRequestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("CallId") != m.end() && !m["CallId"].empty()) {
      callId = make_shared<string>(boost::any_cast<string>(m["CallId"]));
    }
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("DataType") != m.end() && !m["DataType"].empty()) {
      dataType = make_shared<long>(boost::any_cast<long>(m["DataType"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("MethodName") != m.end() && !m["MethodName"].empty()) {
      methodName = make_shared<string>(boost::any_cast<string>(m["MethodName"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("UniqueRequestId") != m.end() && !m["UniqueRequestId"].empty()) {
      uniqueRequestId = make_shared<string>(boost::any_cast<string>(m["UniqueRequestId"]));
    }
  }


  virtual ~SaveTerminalLogRequest() = default;
};
class SaveTerminalLogResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};
  shared_ptr<long> timeStamp{};

  SaveTerminalLogResponseBody() {}

  explicit SaveTerminalLogResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (timeStamp) {
      res["TimeStamp"] = boost::any(*timeStamp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TimeStamp") != m.end() && !m["TimeStamp"].empty()) {
      timeStamp = make_shared<long>(boost::any_cast<long>(m["TimeStamp"]));
    }
  }


  virtual ~SaveTerminalLogResponseBody() = default;
};
class SaveTerminalLogResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SaveTerminalLogResponseBody> body{};

  SaveTerminalLogResponse() {}

  explicit SaveTerminalLogResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SaveTerminalLogResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SaveTerminalLogResponseBody>(model1);
      }
    }
  }


  virtual ~SaveTerminalLogResponse() = default;
};
class SaveWebRTCStatsRequest : public Darabonba::Model {
public:
  shared_ptr<string> callId{};
  shared_ptr<string> generalInfo{};
  shared_ptr<string> googAddress{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> receiverReport{};
  shared_ptr<string> senderReport{};

  SaveWebRTCStatsRequest() {}

  explicit SaveWebRTCStatsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callId) {
      res["CallId"] = boost::any(*callId);
    }
    if (generalInfo) {
      res["GeneralInfo"] = boost::any(*generalInfo);
    }
    if (googAddress) {
      res["GoogAddress"] = boost::any(*googAddress);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (receiverReport) {
      res["ReceiverReport"] = boost::any(*receiverReport);
    }
    if (senderReport) {
      res["SenderReport"] = boost::any(*senderReport);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallId") != m.end() && !m["CallId"].empty()) {
      callId = make_shared<string>(boost::any_cast<string>(m["CallId"]));
    }
    if (m.find("GeneralInfo") != m.end() && !m["GeneralInfo"].empty()) {
      generalInfo = make_shared<string>(boost::any_cast<string>(m["GeneralInfo"]));
    }
    if (m.find("GoogAddress") != m.end() && !m["GoogAddress"].empty()) {
      googAddress = make_shared<string>(boost::any_cast<string>(m["GoogAddress"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("ReceiverReport") != m.end() && !m["ReceiverReport"].empty()) {
      receiverReport = make_shared<string>(boost::any_cast<string>(m["ReceiverReport"]));
    }
    if (m.find("SenderReport") != m.end() && !m["SenderReport"].empty()) {
      senderReport = make_shared<string>(boost::any_cast<string>(m["SenderReport"]));
    }
  }


  virtual ~SaveWebRTCStatsRequest() = default;
};
class SaveWebRTCStatsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<long> rowCount{};
  shared_ptr<bool> success{};
  shared_ptr<long> timeStamp{};

  SaveWebRTCStatsResponseBody() {}

  explicit SaveWebRTCStatsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (rowCount) {
      res["RowCount"] = boost::any(*rowCount);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (timeStamp) {
      res["TimeStamp"] = boost::any(*timeStamp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("RowCount") != m.end() && !m["RowCount"].empty()) {
      rowCount = make_shared<long>(boost::any_cast<long>(m["RowCount"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TimeStamp") != m.end() && !m["TimeStamp"].empty()) {
      timeStamp = make_shared<long>(boost::any_cast<long>(m["TimeStamp"]));
    }
  }


  virtual ~SaveWebRTCStatsResponseBody() = default;
};
class SaveWebRTCStatsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SaveWebRTCStatsResponseBody> body{};

  SaveWebRTCStatsResponse() {}

  explicit SaveWebRTCStatsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SaveWebRTCStatsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SaveWebRTCStatsResponseBody>(model1);
      }
    }
  }


  virtual ~SaveWebRTCStatsResponse() = default;
};
class SaveWebRtcInfoRequest : public Darabonba::Model {
public:
  shared_ptr<string> callId{};
  shared_ptr<string> content{};
  shared_ptr<string> contentType{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> jobId{};

  SaveWebRtcInfoRequest() {}

  explicit SaveWebRtcInfoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callId) {
      res["CallId"] = boost::any(*callId);
    }
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (contentType) {
      res["ContentType"] = boost::any(*contentType);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallId") != m.end() && !m["CallId"].empty()) {
      callId = make_shared<string>(boost::any_cast<string>(m["CallId"]));
    }
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("ContentType") != m.end() && !m["ContentType"].empty()) {
      contentType = make_shared<string>(boost::any_cast<string>(m["ContentType"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
  }


  virtual ~SaveWebRtcInfoRequest() = default;
};
class SaveWebRtcInfoResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<long> rowCount{};
  shared_ptr<bool> success{};
  shared_ptr<long> timeStamp{};

  SaveWebRtcInfoResponseBody() {}

  explicit SaveWebRtcInfoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (rowCount) {
      res["RowCount"] = boost::any(*rowCount);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (timeStamp) {
      res["TimeStamp"] = boost::any(*timeStamp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("RowCount") != m.end() && !m["RowCount"].empty()) {
      rowCount = make_shared<long>(boost::any_cast<long>(m["RowCount"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("TimeStamp") != m.end() && !m["TimeStamp"].empty()) {
      timeStamp = make_shared<long>(boost::any_cast<long>(m["TimeStamp"]));
    }
  }


  virtual ~SaveWebRtcInfoResponseBody() = default;
};
class SaveWebRtcInfoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SaveWebRtcInfoResponseBody> body{};

  SaveWebRtcInfoResponse() {}

  explicit SaveWebRtcInfoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SaveWebRtcInfoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SaveWebRtcInfoResponseBody>(model1);
      }
    }
  }


  virtual ~SaveWebRtcInfoResponse() = default;
};
class SendDtmfSignalingRequest : public Darabonba::Model {
public:
  shared_ptr<string> channelId{};
  shared_ptr<string> deviceId{};
  shared_ptr<string> dtmf{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> jobId{};
  shared_ptr<string> userId{};

  SendDtmfSignalingRequest() {}

  explicit SendDtmfSignalingRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (channelId) {
      res["ChannelId"] = boost::any(*channelId);
    }
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (dtmf) {
      res["Dtmf"] = boost::any(*dtmf);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChannelId") != m.end() && !m["ChannelId"].empty()) {
      channelId = make_shared<string>(boost::any_cast<string>(m["ChannelId"]));
    }
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("Dtmf") != m.end() && !m["Dtmf"].empty()) {
      dtmf = make_shared<string>(boost::any_cast<string>(m["Dtmf"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~SendDtmfSignalingRequest() = default;
};
class SendDtmfSignalingResponseBodyDataCallContextChannelContexts : public Darabonba::Model {
public:
  shared_ptr<string> callType{};
  shared_ptr<string> channelFlags{};
  shared_ptr<string> channelId{};
  shared_ptr<string> channelState{};
  shared_ptr<string> destination{};
  shared_ptr<long> index{};
  shared_ptr<string> jobId{};
  shared_ptr<string> originator{};
  shared_ptr<string> releaseInitiator{};
  shared_ptr<string> releaseReason{};
  shared_ptr<string> skillGroupId{};
  shared_ptr<long> timestamp{};
  shared_ptr<string> userExtension{};
  shared_ptr<string> userId{};

  SendDtmfSignalingResponseBodyDataCallContextChannelContexts() {}

  explicit SendDtmfSignalingResponseBodyDataCallContextChannelContexts(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callType) {
      res["CallType"] = boost::any(*callType);
    }
    if (channelFlags) {
      res["ChannelFlags"] = boost::any(*channelFlags);
    }
    if (channelId) {
      res["ChannelId"] = boost::any(*channelId);
    }
    if (channelState) {
      res["ChannelState"] = boost::any(*channelState);
    }
    if (destination) {
      res["Destination"] = boost::any(*destination);
    }
    if (index) {
      res["Index"] = boost::any(*index);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (originator) {
      res["Originator"] = boost::any(*originator);
    }
    if (releaseInitiator) {
      res["ReleaseInitiator"] = boost::any(*releaseInitiator);
    }
    if (releaseReason) {
      res["ReleaseReason"] = boost::any(*releaseReason);
    }
    if (skillGroupId) {
      res["SkillGroupId"] = boost::any(*skillGroupId);
    }
    if (timestamp) {
      res["Timestamp"] = boost::any(*timestamp);
    }
    if (userExtension) {
      res["UserExtension"] = boost::any(*userExtension);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallType") != m.end() && !m["CallType"].empty()) {
      callType = make_shared<string>(boost::any_cast<string>(m["CallType"]));
    }
    if (m.find("ChannelFlags") != m.end() && !m["ChannelFlags"].empty()) {
      channelFlags = make_shared<string>(boost::any_cast<string>(m["ChannelFlags"]));
    }
    if (m.find("ChannelId") != m.end() && !m["ChannelId"].empty()) {
      channelId = make_shared<string>(boost::any_cast<string>(m["ChannelId"]));
    }
    if (m.find("ChannelState") != m.end() && !m["ChannelState"].empty()) {
      channelState = make_shared<string>(boost::any_cast<string>(m["ChannelState"]));
    }
    if (m.find("Destination") != m.end() && !m["Destination"].empty()) {
      destination = make_shared<string>(boost::any_cast<string>(m["Destination"]));
    }
    if (m.find("Index") != m.end() && !m["Index"].empty()) {
      index = make_shared<long>(boost::any_cast<long>(m["Index"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("Originator") != m.end() && !m["Originator"].empty()) {
      originator = make_shared<string>(boost::any_cast<string>(m["Originator"]));
    }
    if (m.find("ReleaseInitiator") != m.end() && !m["ReleaseInitiator"].empty()) {
      releaseInitiator = make_shared<string>(boost::any_cast<string>(m["ReleaseInitiator"]));
    }
    if (m.find("ReleaseReason") != m.end() && !m["ReleaseReason"].empty()) {
      releaseReason = make_shared<string>(boost::any_cast<string>(m["ReleaseReason"]));
    }
    if (m.find("SkillGroupId") != m.end() && !m["SkillGroupId"].empty()) {
      skillGroupId = make_shared<string>(boost::any_cast<string>(m["SkillGroupId"]));
    }
    if (m.find("Timestamp") != m.end() && !m["Timestamp"].empty()) {
      timestamp = make_shared<long>(boost::any_cast<long>(m["Timestamp"]));
    }
    if (m.find("UserExtension") != m.end() && !m["UserExtension"].empty()) {
      userExtension = make_shared<string>(boost::any_cast<string>(m["UserExtension"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~SendDtmfSignalingResponseBodyDataCallContextChannelContexts() = default;
};
class SendDtmfSignalingResponseBodyDataCallContext : public Darabonba::Model {
public:
  shared_ptr<string> callType{};
  shared_ptr<vector<SendDtmfSignalingResponseBodyDataCallContextChannelContexts>> channelContexts{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> jobId{};

  SendDtmfSignalingResponseBodyDataCallContext() {}

  explicit SendDtmfSignalingResponseBodyDataCallContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callType) {
      res["CallType"] = boost::any(*callType);
    }
    if (channelContexts) {
      vector<boost::any> temp1;
      for(auto item1:*channelContexts){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ChannelContexts"] = boost::any(temp1);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallType") != m.end() && !m["CallType"].empty()) {
      callType = make_shared<string>(boost::any_cast<string>(m["CallType"]));
    }
    if (m.find("ChannelContexts") != m.end() && !m["ChannelContexts"].empty()) {
      if (typeid(vector<boost::any>) == m["ChannelContexts"].type()) {
        vector<SendDtmfSignalingResponseBodyDataCallContextChannelContexts> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ChannelContexts"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SendDtmfSignalingResponseBodyDataCallContextChannelContexts model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        channelContexts = make_shared<vector<SendDtmfSignalingResponseBodyDataCallContextChannelContexts>>(expect1);
      }
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
  }


  virtual ~SendDtmfSignalingResponseBodyDataCallContext() = default;
};
class SendDtmfSignalingResponseBodyDataUserContext : public Darabonba::Model {
public:
  shared_ptr<string> breakCode{};
  shared_ptr<string> deviceId{};
  shared_ptr<string> extension{};
  shared_ptr<long> heartbeat{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> jobId{};
  shared_ptr<string> mobile{};
  shared_ptr<bool> outboundScenario{};
  shared_ptr<long> reserved{};
  shared_ptr<vector<string>> signedSkillGroupIdList{};
  shared_ptr<string> userId{};
  shared_ptr<string> userState{};
  shared_ptr<string> workMode{};

  SendDtmfSignalingResponseBodyDataUserContext() {}

  explicit SendDtmfSignalingResponseBodyDataUserContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (breakCode) {
      res["BreakCode"] = boost::any(*breakCode);
    }
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (extension) {
      res["Extension"] = boost::any(*extension);
    }
    if (heartbeat) {
      res["Heartbeat"] = boost::any(*heartbeat);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (mobile) {
      res["Mobile"] = boost::any(*mobile);
    }
    if (outboundScenario) {
      res["OutboundScenario"] = boost::any(*outboundScenario);
    }
    if (reserved) {
      res["Reserved"] = boost::any(*reserved);
    }
    if (signedSkillGroupIdList) {
      res["SignedSkillGroupIdList"] = boost::any(*signedSkillGroupIdList);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (userState) {
      res["UserState"] = boost::any(*userState);
    }
    if (workMode) {
      res["WorkMode"] = boost::any(*workMode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BreakCode") != m.end() && !m["BreakCode"].empty()) {
      breakCode = make_shared<string>(boost::any_cast<string>(m["BreakCode"]));
    }
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("Extension") != m.end() && !m["Extension"].empty()) {
      extension = make_shared<string>(boost::any_cast<string>(m["Extension"]));
    }
    if (m.find("Heartbeat") != m.end() && !m["Heartbeat"].empty()) {
      heartbeat = make_shared<long>(boost::any_cast<long>(m["Heartbeat"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("Mobile") != m.end() && !m["Mobile"].empty()) {
      mobile = make_shared<string>(boost::any_cast<string>(m["Mobile"]));
    }
    if (m.find("OutboundScenario") != m.end() && !m["OutboundScenario"].empty()) {
      outboundScenario = make_shared<bool>(boost::any_cast<bool>(m["OutboundScenario"]));
    }
    if (m.find("Reserved") != m.end() && !m["Reserved"].empty()) {
      reserved = make_shared<long>(boost::any_cast<long>(m["Reserved"]));
    }
    if (m.find("SignedSkillGroupIdList") != m.end() && !m["SignedSkillGroupIdList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SignedSkillGroupIdList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SignedSkillGroupIdList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      signedSkillGroupIdList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
    if (m.find("UserState") != m.end() && !m["UserState"].empty()) {
      userState = make_shared<string>(boost::any_cast<string>(m["UserState"]));
    }
    if (m.find("WorkMode") != m.end() && !m["WorkMode"].empty()) {
      workMode = make_shared<string>(boost::any_cast<string>(m["WorkMode"]));
    }
  }


  virtual ~SendDtmfSignalingResponseBodyDataUserContext() = default;
};
class SendDtmfSignalingResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<SendDtmfSignalingResponseBodyDataCallContext> callContext{};
  shared_ptr<SendDtmfSignalingResponseBodyDataUserContext> userContext{};

  SendDtmfSignalingResponseBodyData() {}

  explicit SendDtmfSignalingResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callContext) {
      res["CallContext"] = callContext ? boost::any(callContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (userContext) {
      res["UserContext"] = userContext ? boost::any(userContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallContext") != m.end() && !m["CallContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["CallContext"].type()) {
        SendDtmfSignalingResponseBodyDataCallContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CallContext"]));
        callContext = make_shared<SendDtmfSignalingResponseBodyDataCallContext>(model1);
      }
    }
    if (m.find("UserContext") != m.end() && !m["UserContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["UserContext"].type()) {
        SendDtmfSignalingResponseBodyDataUserContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["UserContext"]));
        userContext = make_shared<SendDtmfSignalingResponseBodyDataUserContext>(model1);
      }
    }
  }


  virtual ~SendDtmfSignalingResponseBodyData() = default;
};
class SendDtmfSignalingResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<SendDtmfSignalingResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<vector<string>> params{};
  shared_ptr<string> requestId{};

  SendDtmfSignalingResponseBody() {}

  explicit SendDtmfSignalingResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (params) {
      res["Params"] = boost::any(*params);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        SendDtmfSignalingResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<SendDtmfSignalingResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Params") != m.end() && !m["Params"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Params"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Params"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      params = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SendDtmfSignalingResponseBody() = default;
};
class SendDtmfSignalingResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SendDtmfSignalingResponseBody> body{};

  SendDtmfSignalingResponse() {}

  explicit SendDtmfSignalingResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SendDtmfSignalingResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SendDtmfSignalingResponseBody>(model1);
      }
    }
  }


  virtual ~SendDtmfSignalingResponse() = default;
};
class SignInGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> deviceId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> signedSkillGroupIdList{};
  shared_ptr<string> userId{};

  SignInGroupRequest() {}

  explicit SignInGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (signedSkillGroupIdList) {
      res["SignedSkillGroupIdList"] = boost::any(*signedSkillGroupIdList);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("SignedSkillGroupIdList") != m.end() && !m["SignedSkillGroupIdList"].empty()) {
      signedSkillGroupIdList = make_shared<string>(boost::any_cast<string>(m["SignedSkillGroupIdList"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~SignInGroupRequest() = default;
};
class SignInGroupResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> breakCode{};
  shared_ptr<string> deviceId{};
  shared_ptr<string> extension{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> jobId{};
  shared_ptr<bool> outboundScenario{};
  shared_ptr<vector<string>> signedSkillGroupIdList{};
  shared_ptr<string> userId{};
  shared_ptr<string> userState{};
  shared_ptr<string> workMode{};

  SignInGroupResponseBodyData() {}

  explicit SignInGroupResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (breakCode) {
      res["BreakCode"] = boost::any(*breakCode);
    }
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (extension) {
      res["Extension"] = boost::any(*extension);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (outboundScenario) {
      res["OutboundScenario"] = boost::any(*outboundScenario);
    }
    if (signedSkillGroupIdList) {
      res["SignedSkillGroupIdList"] = boost::any(*signedSkillGroupIdList);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (userState) {
      res["UserState"] = boost::any(*userState);
    }
    if (workMode) {
      res["WorkMode"] = boost::any(*workMode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BreakCode") != m.end() && !m["BreakCode"].empty()) {
      breakCode = make_shared<string>(boost::any_cast<string>(m["BreakCode"]));
    }
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("Extension") != m.end() && !m["Extension"].empty()) {
      extension = make_shared<string>(boost::any_cast<string>(m["Extension"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("OutboundScenario") != m.end() && !m["OutboundScenario"].empty()) {
      outboundScenario = make_shared<bool>(boost::any_cast<bool>(m["OutboundScenario"]));
    }
    if (m.find("SignedSkillGroupIdList") != m.end() && !m["SignedSkillGroupIdList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SignedSkillGroupIdList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SignedSkillGroupIdList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      signedSkillGroupIdList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
    if (m.find("UserState") != m.end() && !m["UserState"].empty()) {
      userState = make_shared<string>(boost::any_cast<string>(m["UserState"]));
    }
    if (m.find("WorkMode") != m.end() && !m["WorkMode"].empty()) {
      workMode = make_shared<string>(boost::any_cast<string>(m["WorkMode"]));
    }
  }


  virtual ~SignInGroupResponseBodyData() = default;
};
class SignInGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<SignInGroupResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<vector<string>> params{};
  shared_ptr<string> requestId{};

  SignInGroupResponseBody() {}

  explicit SignInGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (params) {
      res["Params"] = boost::any(*params);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        SignInGroupResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<SignInGroupResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Params") != m.end() && !m["Params"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Params"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Params"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      params = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SignInGroupResponseBody() = default;
};
class SignInGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SignInGroupResponseBody> body{};

  SignInGroupResponse() {}

  explicit SignInGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SignInGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SignInGroupResponseBody>(model1);
      }
    }
  }


  virtual ~SignInGroupResponse() = default;
};
class SignOutGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> deviceId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> userId{};

  SignOutGroupRequest() {}

  explicit SignOutGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~SignOutGroupRequest() = default;
};
class SignOutGroupResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> breakCode{};
  shared_ptr<string> deviceId{};
  shared_ptr<string> extension{};
  shared_ptr<long> heartbeat{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> jobId{};
  shared_ptr<string> mobile{};
  shared_ptr<bool> outboundScenario{};
  shared_ptr<long> reserved{};
  shared_ptr<vector<string>> signedSkillGroupIdList{};
  shared_ptr<string> userId{};
  shared_ptr<string> userState{};
  shared_ptr<string> workMode{};

  SignOutGroupResponseBodyData() {}

  explicit SignOutGroupResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (breakCode) {
      res["BreakCode"] = boost::any(*breakCode);
    }
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (extension) {
      res["Extension"] = boost::any(*extension);
    }
    if (heartbeat) {
      res["Heartbeat"] = boost::any(*heartbeat);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (mobile) {
      res["Mobile"] = boost::any(*mobile);
    }
    if (outboundScenario) {
      res["OutboundScenario"] = boost::any(*outboundScenario);
    }
    if (reserved) {
      res["Reserved"] = boost::any(*reserved);
    }
    if (signedSkillGroupIdList) {
      res["SignedSkillGroupIdList"] = boost::any(*signedSkillGroupIdList);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (userState) {
      res["UserState"] = boost::any(*userState);
    }
    if (workMode) {
      res["WorkMode"] = boost::any(*workMode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BreakCode") != m.end() && !m["BreakCode"].empty()) {
      breakCode = make_shared<string>(boost::any_cast<string>(m["BreakCode"]));
    }
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("Extension") != m.end() && !m["Extension"].empty()) {
      extension = make_shared<string>(boost::any_cast<string>(m["Extension"]));
    }
    if (m.find("Heartbeat") != m.end() && !m["Heartbeat"].empty()) {
      heartbeat = make_shared<long>(boost::any_cast<long>(m["Heartbeat"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("Mobile") != m.end() && !m["Mobile"].empty()) {
      mobile = make_shared<string>(boost::any_cast<string>(m["Mobile"]));
    }
    if (m.find("OutboundScenario") != m.end() && !m["OutboundScenario"].empty()) {
      outboundScenario = make_shared<bool>(boost::any_cast<bool>(m["OutboundScenario"]));
    }
    if (m.find("Reserved") != m.end() && !m["Reserved"].empty()) {
      reserved = make_shared<long>(boost::any_cast<long>(m["Reserved"]));
    }
    if (m.find("SignedSkillGroupIdList") != m.end() && !m["SignedSkillGroupIdList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SignedSkillGroupIdList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SignedSkillGroupIdList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      signedSkillGroupIdList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
    if (m.find("UserState") != m.end() && !m["UserState"].empty()) {
      userState = make_shared<string>(boost::any_cast<string>(m["UserState"]));
    }
    if (m.find("WorkMode") != m.end() && !m["WorkMode"].empty()) {
      workMode = make_shared<string>(boost::any_cast<string>(m["WorkMode"]));
    }
  }


  virtual ~SignOutGroupResponseBodyData() = default;
};
class SignOutGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<SignOutGroupResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<vector<string>> params{};
  shared_ptr<string> requestId{};

  SignOutGroupResponseBody() {}

  explicit SignOutGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (params) {
      res["Params"] = boost::any(*params);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        SignOutGroupResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<SignOutGroupResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Params") != m.end() && !m["Params"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Params"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Params"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      params = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SignOutGroupResponseBody() = default;
};
class SignOutGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SignOutGroupResponseBody> body{};

  SignOutGroupResponse() {}

  explicit SignOutGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SignOutGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SignOutGroupResponseBody>(model1);
      }
    }
  }


  virtual ~SignOutGroupResponse() = default;
};
class StartBack2BackCallRequest : public Darabonba::Model {
public:
  shared_ptr<string> additionalBroker{};
  shared_ptr<string> broker{};
  shared_ptr<string> callee{};
  shared_ptr<string> caller{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> tags{};
  shared_ptr<long> timeoutSeconds{};

  StartBack2BackCallRequest() {}

  explicit StartBack2BackCallRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (additionalBroker) {
      res["AdditionalBroker"] = boost::any(*additionalBroker);
    }
    if (broker) {
      res["Broker"] = boost::any(*broker);
    }
    if (callee) {
      res["Callee"] = boost::any(*callee);
    }
    if (caller) {
      res["Caller"] = boost::any(*caller);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (tags) {
      res["Tags"] = boost::any(*tags);
    }
    if (timeoutSeconds) {
      res["TimeoutSeconds"] = boost::any(*timeoutSeconds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AdditionalBroker") != m.end() && !m["AdditionalBroker"].empty()) {
      additionalBroker = make_shared<string>(boost::any_cast<string>(m["AdditionalBroker"]));
    }
    if (m.find("Broker") != m.end() && !m["Broker"].empty()) {
      broker = make_shared<string>(boost::any_cast<string>(m["Broker"]));
    }
    if (m.find("Callee") != m.end() && !m["Callee"].empty()) {
      callee = make_shared<string>(boost::any_cast<string>(m["Callee"]));
    }
    if (m.find("Caller") != m.end() && !m["Caller"].empty()) {
      caller = make_shared<string>(boost::any_cast<string>(m["Caller"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      tags = make_shared<string>(boost::any_cast<string>(m["Tags"]));
    }
    if (m.find("TimeoutSeconds") != m.end() && !m["TimeoutSeconds"].empty()) {
      timeoutSeconds = make_shared<long>(boost::any_cast<long>(m["TimeoutSeconds"]));
    }
  }


  virtual ~StartBack2BackCallRequest() = default;
};
class StartBack2BackCallResponseBodyDataCallContextChannelContexts : public Darabonba::Model {
public:
  shared_ptr<string> callType{};
  shared_ptr<string> channelFlags{};
  shared_ptr<string> channelId{};
  shared_ptr<string> channelState{};
  shared_ptr<string> destination{};
  shared_ptr<string> jobId{};
  shared_ptr<string> originator{};
  shared_ptr<string> releaseInitiator{};
  shared_ptr<string> releaseReason{};
  shared_ptr<long> timestamp{};
  shared_ptr<string> userExtension{};
  shared_ptr<string> userId{};

  StartBack2BackCallResponseBodyDataCallContextChannelContexts() {}

  explicit StartBack2BackCallResponseBodyDataCallContextChannelContexts(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callType) {
      res["CallType"] = boost::any(*callType);
    }
    if (channelFlags) {
      res["ChannelFlags"] = boost::any(*channelFlags);
    }
    if (channelId) {
      res["ChannelId"] = boost::any(*channelId);
    }
    if (channelState) {
      res["ChannelState"] = boost::any(*channelState);
    }
    if (destination) {
      res["Destination"] = boost::any(*destination);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (originator) {
      res["Originator"] = boost::any(*originator);
    }
    if (releaseInitiator) {
      res["ReleaseInitiator"] = boost::any(*releaseInitiator);
    }
    if (releaseReason) {
      res["ReleaseReason"] = boost::any(*releaseReason);
    }
    if (timestamp) {
      res["Timestamp"] = boost::any(*timestamp);
    }
    if (userExtension) {
      res["UserExtension"] = boost::any(*userExtension);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallType") != m.end() && !m["CallType"].empty()) {
      callType = make_shared<string>(boost::any_cast<string>(m["CallType"]));
    }
    if (m.find("ChannelFlags") != m.end() && !m["ChannelFlags"].empty()) {
      channelFlags = make_shared<string>(boost::any_cast<string>(m["ChannelFlags"]));
    }
    if (m.find("ChannelId") != m.end() && !m["ChannelId"].empty()) {
      channelId = make_shared<string>(boost::any_cast<string>(m["ChannelId"]));
    }
    if (m.find("ChannelState") != m.end() && !m["ChannelState"].empty()) {
      channelState = make_shared<string>(boost::any_cast<string>(m["ChannelState"]));
    }
    if (m.find("Destination") != m.end() && !m["Destination"].empty()) {
      destination = make_shared<string>(boost::any_cast<string>(m["Destination"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("Originator") != m.end() && !m["Originator"].empty()) {
      originator = make_shared<string>(boost::any_cast<string>(m["Originator"]));
    }
    if (m.find("ReleaseInitiator") != m.end() && !m["ReleaseInitiator"].empty()) {
      releaseInitiator = make_shared<string>(boost::any_cast<string>(m["ReleaseInitiator"]));
    }
    if (m.find("ReleaseReason") != m.end() && !m["ReleaseReason"].empty()) {
      releaseReason = make_shared<string>(boost::any_cast<string>(m["ReleaseReason"]));
    }
    if (m.find("Timestamp") != m.end() && !m["Timestamp"].empty()) {
      timestamp = make_shared<long>(boost::any_cast<long>(m["Timestamp"]));
    }
    if (m.find("UserExtension") != m.end() && !m["UserExtension"].empty()) {
      userExtension = make_shared<string>(boost::any_cast<string>(m["UserExtension"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~StartBack2BackCallResponseBodyDataCallContextChannelContexts() = default;
};
class StartBack2BackCallResponseBodyDataCallContext : public Darabonba::Model {
public:
  shared_ptr<string> callType{};
  shared_ptr<vector<StartBack2BackCallResponseBodyDataCallContextChannelContexts>> channelContexts{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> jobId{};

  StartBack2BackCallResponseBodyDataCallContext() {}

  explicit StartBack2BackCallResponseBodyDataCallContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callType) {
      res["CallType"] = boost::any(*callType);
    }
    if (channelContexts) {
      vector<boost::any> temp1;
      for(auto item1:*channelContexts){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ChannelContexts"] = boost::any(temp1);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallType") != m.end() && !m["CallType"].empty()) {
      callType = make_shared<string>(boost::any_cast<string>(m["CallType"]));
    }
    if (m.find("ChannelContexts") != m.end() && !m["ChannelContexts"].empty()) {
      if (typeid(vector<boost::any>) == m["ChannelContexts"].type()) {
        vector<StartBack2BackCallResponseBodyDataCallContextChannelContexts> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ChannelContexts"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            StartBack2BackCallResponseBodyDataCallContextChannelContexts model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        channelContexts = make_shared<vector<StartBack2BackCallResponseBodyDataCallContextChannelContexts>>(expect1);
      }
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
  }


  virtual ~StartBack2BackCallResponseBodyDataCallContext() = default;
};
class StartBack2BackCallResponseBodyDataUserContext : public Darabonba::Model {
public:
  shared_ptr<string> breakCode{};
  shared_ptr<string> deviceId{};
  shared_ptr<string> deviceState{};
  shared_ptr<string> extension{};
  shared_ptr<long> heartbeat{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> jobId{};
  shared_ptr<string> mobile{};
  shared_ptr<bool> outboundScenario{};
  shared_ptr<long> reserved{};
  shared_ptr<vector<string>> signedSkillGroupIdList{};
  shared_ptr<string> userId{};
  shared_ptr<string> userState{};
  shared_ptr<string> workMode{};

  StartBack2BackCallResponseBodyDataUserContext() {}

  explicit StartBack2BackCallResponseBodyDataUserContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (breakCode) {
      res["BreakCode"] = boost::any(*breakCode);
    }
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (deviceState) {
      res["DeviceState"] = boost::any(*deviceState);
    }
    if (extension) {
      res["Extension"] = boost::any(*extension);
    }
    if (heartbeat) {
      res["Heartbeat"] = boost::any(*heartbeat);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (mobile) {
      res["Mobile"] = boost::any(*mobile);
    }
    if (outboundScenario) {
      res["OutboundScenario"] = boost::any(*outboundScenario);
    }
    if (reserved) {
      res["Reserved"] = boost::any(*reserved);
    }
    if (signedSkillGroupIdList) {
      res["SignedSkillGroupIdList"] = boost::any(*signedSkillGroupIdList);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (userState) {
      res["UserState"] = boost::any(*userState);
    }
    if (workMode) {
      res["WorkMode"] = boost::any(*workMode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BreakCode") != m.end() && !m["BreakCode"].empty()) {
      breakCode = make_shared<string>(boost::any_cast<string>(m["BreakCode"]));
    }
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("DeviceState") != m.end() && !m["DeviceState"].empty()) {
      deviceState = make_shared<string>(boost::any_cast<string>(m["DeviceState"]));
    }
    if (m.find("Extension") != m.end() && !m["Extension"].empty()) {
      extension = make_shared<string>(boost::any_cast<string>(m["Extension"]));
    }
    if (m.find("Heartbeat") != m.end() && !m["Heartbeat"].empty()) {
      heartbeat = make_shared<long>(boost::any_cast<long>(m["Heartbeat"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("Mobile") != m.end() && !m["Mobile"].empty()) {
      mobile = make_shared<string>(boost::any_cast<string>(m["Mobile"]));
    }
    if (m.find("OutboundScenario") != m.end() && !m["OutboundScenario"].empty()) {
      outboundScenario = make_shared<bool>(boost::any_cast<bool>(m["OutboundScenario"]));
    }
    if (m.find("Reserved") != m.end() && !m["Reserved"].empty()) {
      reserved = make_shared<long>(boost::any_cast<long>(m["Reserved"]));
    }
    if (m.find("SignedSkillGroupIdList") != m.end() && !m["SignedSkillGroupIdList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SignedSkillGroupIdList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SignedSkillGroupIdList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      signedSkillGroupIdList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
    if (m.find("UserState") != m.end() && !m["UserState"].empty()) {
      userState = make_shared<string>(boost::any_cast<string>(m["UserState"]));
    }
    if (m.find("WorkMode") != m.end() && !m["WorkMode"].empty()) {
      workMode = make_shared<string>(boost::any_cast<string>(m["WorkMode"]));
    }
  }


  virtual ~StartBack2BackCallResponseBodyDataUserContext() = default;
};
class StartBack2BackCallResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<StartBack2BackCallResponseBodyDataCallContext> callContext{};
  shared_ptr<StartBack2BackCallResponseBodyDataUserContext> userContext{};

  StartBack2BackCallResponseBodyData() {}

  explicit StartBack2BackCallResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callContext) {
      res["CallContext"] = callContext ? boost::any(callContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (userContext) {
      res["UserContext"] = userContext ? boost::any(userContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallContext") != m.end() && !m["CallContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["CallContext"].type()) {
        StartBack2BackCallResponseBodyDataCallContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CallContext"]));
        callContext = make_shared<StartBack2BackCallResponseBodyDataCallContext>(model1);
      }
    }
    if (m.find("UserContext") != m.end() && !m["UserContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["UserContext"].type()) {
        StartBack2BackCallResponseBodyDataUserContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["UserContext"]));
        userContext = make_shared<StartBack2BackCallResponseBodyDataUserContext>(model1);
      }
    }
  }


  virtual ~StartBack2BackCallResponseBodyData() = default;
};
class StartBack2BackCallResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<StartBack2BackCallResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<vector<string>> params{};
  shared_ptr<string> requestId{};

  StartBack2BackCallResponseBody() {}

  explicit StartBack2BackCallResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (params) {
      res["Params"] = boost::any(*params);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        StartBack2BackCallResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<StartBack2BackCallResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Params") != m.end() && !m["Params"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Params"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Params"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      params = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~StartBack2BackCallResponseBody() = default;
};
class StartBack2BackCallResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<StartBack2BackCallResponseBody> body{};

  StartBack2BackCallResponse() {}

  explicit StartBack2BackCallResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        StartBack2BackCallResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<StartBack2BackCallResponseBody>(model1);
      }
    }
  }


  virtual ~StartBack2BackCallResponse() = default;
};
class StartConferenceRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> participantListJson{};
  shared_ptr<string> tags{};
  shared_ptr<long> timeoutSeconds{};
  shared_ptr<string> userId{};

  StartConferenceRequest() {}

  explicit StartConferenceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (participantListJson) {
      res["ParticipantListJson"] = boost::any(*participantListJson);
    }
    if (tags) {
      res["Tags"] = boost::any(*tags);
    }
    if (timeoutSeconds) {
      res["TimeoutSeconds"] = boost::any(*timeoutSeconds);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("ParticipantListJson") != m.end() && !m["ParticipantListJson"].empty()) {
      participantListJson = make_shared<string>(boost::any_cast<string>(m["ParticipantListJson"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      tags = make_shared<string>(boost::any_cast<string>(m["Tags"]));
    }
    if (m.find("TimeoutSeconds") != m.end() && !m["TimeoutSeconds"].empty()) {
      timeoutSeconds = make_shared<long>(boost::any_cast<long>(m["TimeoutSeconds"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~StartConferenceRequest() = default;
};
class StartConferenceResponseBodyDataCallContextChannelContexts : public Darabonba::Model {
public:
  shared_ptr<string> callType{};
  shared_ptr<string> channelFlags{};
  shared_ptr<string> channelId{};
  shared_ptr<string> channelState{};
  shared_ptr<string> destination{};
  shared_ptr<string> jobId{};
  shared_ptr<string> originator{};
  shared_ptr<string> releaseInitiator{};
  shared_ptr<string> releaseReason{};
  shared_ptr<long> timestamp{};
  shared_ptr<string> userExtension{};
  shared_ptr<string> userId{};

  StartConferenceResponseBodyDataCallContextChannelContexts() {}

  explicit StartConferenceResponseBodyDataCallContextChannelContexts(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callType) {
      res["CallType"] = boost::any(*callType);
    }
    if (channelFlags) {
      res["ChannelFlags"] = boost::any(*channelFlags);
    }
    if (channelId) {
      res["ChannelId"] = boost::any(*channelId);
    }
    if (channelState) {
      res["ChannelState"] = boost::any(*channelState);
    }
    if (destination) {
      res["Destination"] = boost::any(*destination);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (originator) {
      res["Originator"] = boost::any(*originator);
    }
    if (releaseInitiator) {
      res["ReleaseInitiator"] = boost::any(*releaseInitiator);
    }
    if (releaseReason) {
      res["ReleaseReason"] = boost::any(*releaseReason);
    }
    if (timestamp) {
      res["Timestamp"] = boost::any(*timestamp);
    }
    if (userExtension) {
      res["UserExtension"] = boost::any(*userExtension);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallType") != m.end() && !m["CallType"].empty()) {
      callType = make_shared<string>(boost::any_cast<string>(m["CallType"]));
    }
    if (m.find("ChannelFlags") != m.end() && !m["ChannelFlags"].empty()) {
      channelFlags = make_shared<string>(boost::any_cast<string>(m["ChannelFlags"]));
    }
    if (m.find("ChannelId") != m.end() && !m["ChannelId"].empty()) {
      channelId = make_shared<string>(boost::any_cast<string>(m["ChannelId"]));
    }
    if (m.find("ChannelState") != m.end() && !m["ChannelState"].empty()) {
      channelState = make_shared<string>(boost::any_cast<string>(m["ChannelState"]));
    }
    if (m.find("Destination") != m.end() && !m["Destination"].empty()) {
      destination = make_shared<string>(boost::any_cast<string>(m["Destination"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("Originator") != m.end() && !m["Originator"].empty()) {
      originator = make_shared<string>(boost::any_cast<string>(m["Originator"]));
    }
    if (m.find("ReleaseInitiator") != m.end() && !m["ReleaseInitiator"].empty()) {
      releaseInitiator = make_shared<string>(boost::any_cast<string>(m["ReleaseInitiator"]));
    }
    if (m.find("ReleaseReason") != m.end() && !m["ReleaseReason"].empty()) {
      releaseReason = make_shared<string>(boost::any_cast<string>(m["ReleaseReason"]));
    }
    if (m.find("Timestamp") != m.end() && !m["Timestamp"].empty()) {
      timestamp = make_shared<long>(boost::any_cast<long>(m["Timestamp"]));
    }
    if (m.find("UserExtension") != m.end() && !m["UserExtension"].empty()) {
      userExtension = make_shared<string>(boost::any_cast<string>(m["UserExtension"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~StartConferenceResponseBodyDataCallContextChannelContexts() = default;
};
class StartConferenceResponseBodyDataCallContext : public Darabonba::Model {
public:
  shared_ptr<string> callType{};
  shared_ptr<vector<StartConferenceResponseBodyDataCallContextChannelContexts>> channelContexts{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> jobId{};

  StartConferenceResponseBodyDataCallContext() {}

  explicit StartConferenceResponseBodyDataCallContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callType) {
      res["CallType"] = boost::any(*callType);
    }
    if (channelContexts) {
      vector<boost::any> temp1;
      for(auto item1:*channelContexts){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ChannelContexts"] = boost::any(temp1);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallType") != m.end() && !m["CallType"].empty()) {
      callType = make_shared<string>(boost::any_cast<string>(m["CallType"]));
    }
    if (m.find("ChannelContexts") != m.end() && !m["ChannelContexts"].empty()) {
      if (typeid(vector<boost::any>) == m["ChannelContexts"].type()) {
        vector<StartConferenceResponseBodyDataCallContextChannelContexts> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ChannelContexts"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            StartConferenceResponseBodyDataCallContextChannelContexts model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        channelContexts = make_shared<vector<StartConferenceResponseBodyDataCallContextChannelContexts>>(expect1);
      }
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
  }


  virtual ~StartConferenceResponseBodyDataCallContext() = default;
};
class StartConferenceResponseBodyDataUserContext : public Darabonba::Model {
public:
  shared_ptr<string> breakCode{};
  shared_ptr<string> deviceId{};
  shared_ptr<string> deviceState{};
  shared_ptr<string> extension{};
  shared_ptr<long> heartbeat{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> jobId{};
  shared_ptr<string> mobile{};
  shared_ptr<bool> outboundScenario{};
  shared_ptr<long> reserved{};
  shared_ptr<vector<string>> signedSkillGroupIdList{};
  shared_ptr<string> userId{};
  shared_ptr<string> userState{};
  shared_ptr<string> workMode{};

  StartConferenceResponseBodyDataUserContext() {}

  explicit StartConferenceResponseBodyDataUserContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (breakCode) {
      res["BreakCode"] = boost::any(*breakCode);
    }
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (deviceState) {
      res["DeviceState"] = boost::any(*deviceState);
    }
    if (extension) {
      res["Extension"] = boost::any(*extension);
    }
    if (heartbeat) {
      res["Heartbeat"] = boost::any(*heartbeat);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (mobile) {
      res["Mobile"] = boost::any(*mobile);
    }
    if (outboundScenario) {
      res["OutboundScenario"] = boost::any(*outboundScenario);
    }
    if (reserved) {
      res["Reserved"] = boost::any(*reserved);
    }
    if (signedSkillGroupIdList) {
      res["SignedSkillGroupIdList"] = boost::any(*signedSkillGroupIdList);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (userState) {
      res["UserState"] = boost::any(*userState);
    }
    if (workMode) {
      res["WorkMode"] = boost::any(*workMode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BreakCode") != m.end() && !m["BreakCode"].empty()) {
      breakCode = make_shared<string>(boost::any_cast<string>(m["BreakCode"]));
    }
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("DeviceState") != m.end() && !m["DeviceState"].empty()) {
      deviceState = make_shared<string>(boost::any_cast<string>(m["DeviceState"]));
    }
    if (m.find("Extension") != m.end() && !m["Extension"].empty()) {
      extension = make_shared<string>(boost::any_cast<string>(m["Extension"]));
    }
    if (m.find("Heartbeat") != m.end() && !m["Heartbeat"].empty()) {
      heartbeat = make_shared<long>(boost::any_cast<long>(m["Heartbeat"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("Mobile") != m.end() && !m["Mobile"].empty()) {
      mobile = make_shared<string>(boost::any_cast<string>(m["Mobile"]));
    }
    if (m.find("OutboundScenario") != m.end() && !m["OutboundScenario"].empty()) {
      outboundScenario = make_shared<bool>(boost::any_cast<bool>(m["OutboundScenario"]));
    }
    if (m.find("Reserved") != m.end() && !m["Reserved"].empty()) {
      reserved = make_shared<long>(boost::any_cast<long>(m["Reserved"]));
    }
    if (m.find("SignedSkillGroupIdList") != m.end() && !m["SignedSkillGroupIdList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SignedSkillGroupIdList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SignedSkillGroupIdList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      signedSkillGroupIdList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
    if (m.find("UserState") != m.end() && !m["UserState"].empty()) {
      userState = make_shared<string>(boost::any_cast<string>(m["UserState"]));
    }
    if (m.find("WorkMode") != m.end() && !m["WorkMode"].empty()) {
      workMode = make_shared<string>(boost::any_cast<string>(m["WorkMode"]));
    }
  }


  virtual ~StartConferenceResponseBodyDataUserContext() = default;
};
class StartConferenceResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<StartConferenceResponseBodyDataCallContext> callContext{};
  shared_ptr<StartConferenceResponseBodyDataUserContext> userContext{};

  StartConferenceResponseBodyData() {}

  explicit StartConferenceResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callContext) {
      res["CallContext"] = callContext ? boost::any(callContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (userContext) {
      res["UserContext"] = userContext ? boost::any(userContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallContext") != m.end() && !m["CallContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["CallContext"].type()) {
        StartConferenceResponseBodyDataCallContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CallContext"]));
        callContext = make_shared<StartConferenceResponseBodyDataCallContext>(model1);
      }
    }
    if (m.find("UserContext") != m.end() && !m["UserContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["UserContext"].type()) {
        StartConferenceResponseBodyDataUserContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["UserContext"]));
        userContext = make_shared<StartConferenceResponseBodyDataUserContext>(model1);
      }
    }
  }


  virtual ~StartConferenceResponseBodyData() = default;
};
class StartConferenceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<StartConferenceResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<vector<string>> params{};
  shared_ptr<string> requestId{};

  StartConferenceResponseBody() {}

  explicit StartConferenceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (params) {
      res["Params"] = boost::any(*params);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        StartConferenceResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<StartConferenceResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Params") != m.end() && !m["Params"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Params"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Params"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      params = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~StartConferenceResponseBody() = default;
};
class StartConferenceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<StartConferenceResponseBody> body{};

  StartConferenceResponse() {}

  explicit StartConferenceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        StartConferenceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<StartConferenceResponseBody>(model1);
      }
    }
  }


  virtual ~StartConferenceResponse() = default;
};
class StartPredictiveCallRequest : public Darabonba::Model {
public:
  shared_ptr<string> callee{};
  shared_ptr<string> caller{};
  shared_ptr<string> contactFlowId{};
  shared_ptr<string> contactFlowVariables{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> maskedCallee{};
  shared_ptr<string> skillGroupId{};
  shared_ptr<string> tags{};
  shared_ptr<long> timeoutSeconds{};

  StartPredictiveCallRequest() {}

  explicit StartPredictiveCallRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callee) {
      res["Callee"] = boost::any(*callee);
    }
    if (caller) {
      res["Caller"] = boost::any(*caller);
    }
    if (contactFlowId) {
      res["ContactFlowId"] = boost::any(*contactFlowId);
    }
    if (contactFlowVariables) {
      res["ContactFlowVariables"] = boost::any(*contactFlowVariables);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (maskedCallee) {
      res["MaskedCallee"] = boost::any(*maskedCallee);
    }
    if (skillGroupId) {
      res["SkillGroupId"] = boost::any(*skillGroupId);
    }
    if (tags) {
      res["Tags"] = boost::any(*tags);
    }
    if (timeoutSeconds) {
      res["TimeoutSeconds"] = boost::any(*timeoutSeconds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Callee") != m.end() && !m["Callee"].empty()) {
      callee = make_shared<string>(boost::any_cast<string>(m["Callee"]));
    }
    if (m.find("Caller") != m.end() && !m["Caller"].empty()) {
      caller = make_shared<string>(boost::any_cast<string>(m["Caller"]));
    }
    if (m.find("ContactFlowId") != m.end() && !m["ContactFlowId"].empty()) {
      contactFlowId = make_shared<string>(boost::any_cast<string>(m["ContactFlowId"]));
    }
    if (m.find("ContactFlowVariables") != m.end() && !m["ContactFlowVariables"].empty()) {
      contactFlowVariables = make_shared<string>(boost::any_cast<string>(m["ContactFlowVariables"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("MaskedCallee") != m.end() && !m["MaskedCallee"].empty()) {
      maskedCallee = make_shared<string>(boost::any_cast<string>(m["MaskedCallee"]));
    }
    if (m.find("SkillGroupId") != m.end() && !m["SkillGroupId"].empty()) {
      skillGroupId = make_shared<string>(boost::any_cast<string>(m["SkillGroupId"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      tags = make_shared<string>(boost::any_cast<string>(m["Tags"]));
    }
    if (m.find("TimeoutSeconds") != m.end() && !m["TimeoutSeconds"].empty()) {
      timeoutSeconds = make_shared<long>(boost::any_cast<long>(m["TimeoutSeconds"]));
    }
  }


  virtual ~StartPredictiveCallRequest() = default;
};
class StartPredictiveCallResponseBodyDataCallContextChannelContexts : public Darabonba::Model {
public:
  shared_ptr<string> callType{};
  shared_ptr<string> channelFlags{};
  shared_ptr<string> channelId{};
  shared_ptr<string> channelState{};
  shared_ptr<string> destination{};
  shared_ptr<string> jobId{};
  shared_ptr<string> originator{};
  shared_ptr<string> releaseInitiator{};
  shared_ptr<string> releaseReason{};
  shared_ptr<long> timestamp{};
  shared_ptr<string> userExtension{};
  shared_ptr<string> userId{};

  StartPredictiveCallResponseBodyDataCallContextChannelContexts() {}

  explicit StartPredictiveCallResponseBodyDataCallContextChannelContexts(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callType) {
      res["CallType"] = boost::any(*callType);
    }
    if (channelFlags) {
      res["ChannelFlags"] = boost::any(*channelFlags);
    }
    if (channelId) {
      res["ChannelId"] = boost::any(*channelId);
    }
    if (channelState) {
      res["ChannelState"] = boost::any(*channelState);
    }
    if (destination) {
      res["Destination"] = boost::any(*destination);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (originator) {
      res["Originator"] = boost::any(*originator);
    }
    if (releaseInitiator) {
      res["ReleaseInitiator"] = boost::any(*releaseInitiator);
    }
    if (releaseReason) {
      res["ReleaseReason"] = boost::any(*releaseReason);
    }
    if (timestamp) {
      res["Timestamp"] = boost::any(*timestamp);
    }
    if (userExtension) {
      res["UserExtension"] = boost::any(*userExtension);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallType") != m.end() && !m["CallType"].empty()) {
      callType = make_shared<string>(boost::any_cast<string>(m["CallType"]));
    }
    if (m.find("ChannelFlags") != m.end() && !m["ChannelFlags"].empty()) {
      channelFlags = make_shared<string>(boost::any_cast<string>(m["ChannelFlags"]));
    }
    if (m.find("ChannelId") != m.end() && !m["ChannelId"].empty()) {
      channelId = make_shared<string>(boost::any_cast<string>(m["ChannelId"]));
    }
    if (m.find("ChannelState") != m.end() && !m["ChannelState"].empty()) {
      channelState = make_shared<string>(boost::any_cast<string>(m["ChannelState"]));
    }
    if (m.find("Destination") != m.end() && !m["Destination"].empty()) {
      destination = make_shared<string>(boost::any_cast<string>(m["Destination"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("Originator") != m.end() && !m["Originator"].empty()) {
      originator = make_shared<string>(boost::any_cast<string>(m["Originator"]));
    }
    if (m.find("ReleaseInitiator") != m.end() && !m["ReleaseInitiator"].empty()) {
      releaseInitiator = make_shared<string>(boost::any_cast<string>(m["ReleaseInitiator"]));
    }
    if (m.find("ReleaseReason") != m.end() && !m["ReleaseReason"].empty()) {
      releaseReason = make_shared<string>(boost::any_cast<string>(m["ReleaseReason"]));
    }
    if (m.find("Timestamp") != m.end() && !m["Timestamp"].empty()) {
      timestamp = make_shared<long>(boost::any_cast<long>(m["Timestamp"]));
    }
    if (m.find("UserExtension") != m.end() && !m["UserExtension"].empty()) {
      userExtension = make_shared<string>(boost::any_cast<string>(m["UserExtension"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~StartPredictiveCallResponseBodyDataCallContextChannelContexts() = default;
};
class StartPredictiveCallResponseBodyDataCallContext : public Darabonba::Model {
public:
  shared_ptr<string> callType{};
  shared_ptr<vector<StartPredictiveCallResponseBodyDataCallContextChannelContexts>> channelContexts{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> jobId{};

  StartPredictiveCallResponseBodyDataCallContext() {}

  explicit StartPredictiveCallResponseBodyDataCallContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callType) {
      res["CallType"] = boost::any(*callType);
    }
    if (channelContexts) {
      vector<boost::any> temp1;
      for(auto item1:*channelContexts){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ChannelContexts"] = boost::any(temp1);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallType") != m.end() && !m["CallType"].empty()) {
      callType = make_shared<string>(boost::any_cast<string>(m["CallType"]));
    }
    if (m.find("ChannelContexts") != m.end() && !m["ChannelContexts"].empty()) {
      if (typeid(vector<boost::any>) == m["ChannelContexts"].type()) {
        vector<StartPredictiveCallResponseBodyDataCallContextChannelContexts> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ChannelContexts"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            StartPredictiveCallResponseBodyDataCallContextChannelContexts model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        channelContexts = make_shared<vector<StartPredictiveCallResponseBodyDataCallContextChannelContexts>>(expect1);
      }
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
  }


  virtual ~StartPredictiveCallResponseBodyDataCallContext() = default;
};
class StartPredictiveCallResponseBodyDataUserContext : public Darabonba::Model {
public:
  shared_ptr<string> breakCode{};
  shared_ptr<string> deviceId{};
  shared_ptr<string> deviceState{};
  shared_ptr<string> extension{};
  shared_ptr<long> heartbeat{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> jobId{};
  shared_ptr<string> mobile{};
  shared_ptr<bool> outboundScenario{};
  shared_ptr<long> reserved{};
  shared_ptr<vector<string>> signedSkillGroupIdList{};
  shared_ptr<string> userId{};
  shared_ptr<string> userState{};
  shared_ptr<string> workMode{};

  StartPredictiveCallResponseBodyDataUserContext() {}

  explicit StartPredictiveCallResponseBodyDataUserContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (breakCode) {
      res["BreakCode"] = boost::any(*breakCode);
    }
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (deviceState) {
      res["DeviceState"] = boost::any(*deviceState);
    }
    if (extension) {
      res["Extension"] = boost::any(*extension);
    }
    if (heartbeat) {
      res["Heartbeat"] = boost::any(*heartbeat);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (mobile) {
      res["Mobile"] = boost::any(*mobile);
    }
    if (outboundScenario) {
      res["OutboundScenario"] = boost::any(*outboundScenario);
    }
    if (reserved) {
      res["Reserved"] = boost::any(*reserved);
    }
    if (signedSkillGroupIdList) {
      res["SignedSkillGroupIdList"] = boost::any(*signedSkillGroupIdList);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (userState) {
      res["UserState"] = boost::any(*userState);
    }
    if (workMode) {
      res["WorkMode"] = boost::any(*workMode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BreakCode") != m.end() && !m["BreakCode"].empty()) {
      breakCode = make_shared<string>(boost::any_cast<string>(m["BreakCode"]));
    }
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("DeviceState") != m.end() && !m["DeviceState"].empty()) {
      deviceState = make_shared<string>(boost::any_cast<string>(m["DeviceState"]));
    }
    if (m.find("Extension") != m.end() && !m["Extension"].empty()) {
      extension = make_shared<string>(boost::any_cast<string>(m["Extension"]));
    }
    if (m.find("Heartbeat") != m.end() && !m["Heartbeat"].empty()) {
      heartbeat = make_shared<long>(boost::any_cast<long>(m["Heartbeat"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("Mobile") != m.end() && !m["Mobile"].empty()) {
      mobile = make_shared<string>(boost::any_cast<string>(m["Mobile"]));
    }
    if (m.find("OutboundScenario") != m.end() && !m["OutboundScenario"].empty()) {
      outboundScenario = make_shared<bool>(boost::any_cast<bool>(m["OutboundScenario"]));
    }
    if (m.find("Reserved") != m.end() && !m["Reserved"].empty()) {
      reserved = make_shared<long>(boost::any_cast<long>(m["Reserved"]));
    }
    if (m.find("SignedSkillGroupIdList") != m.end() && !m["SignedSkillGroupIdList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SignedSkillGroupIdList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SignedSkillGroupIdList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      signedSkillGroupIdList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
    if (m.find("UserState") != m.end() && !m["UserState"].empty()) {
      userState = make_shared<string>(boost::any_cast<string>(m["UserState"]));
    }
    if (m.find("WorkMode") != m.end() && !m["WorkMode"].empty()) {
      workMode = make_shared<string>(boost::any_cast<string>(m["WorkMode"]));
    }
  }


  virtual ~StartPredictiveCallResponseBodyDataUserContext() = default;
};
class StartPredictiveCallResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<StartPredictiveCallResponseBodyDataCallContext> callContext{};
  shared_ptr<StartPredictiveCallResponseBodyDataUserContext> userContext{};

  StartPredictiveCallResponseBodyData() {}

  explicit StartPredictiveCallResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callContext) {
      res["CallContext"] = callContext ? boost::any(callContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (userContext) {
      res["UserContext"] = userContext ? boost::any(userContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallContext") != m.end() && !m["CallContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["CallContext"].type()) {
        StartPredictiveCallResponseBodyDataCallContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CallContext"]));
        callContext = make_shared<StartPredictiveCallResponseBodyDataCallContext>(model1);
      }
    }
    if (m.find("UserContext") != m.end() && !m["UserContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["UserContext"].type()) {
        StartPredictiveCallResponseBodyDataUserContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["UserContext"]));
        userContext = make_shared<StartPredictiveCallResponseBodyDataUserContext>(model1);
      }
    }
  }


  virtual ~StartPredictiveCallResponseBodyData() = default;
};
class StartPredictiveCallResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<StartPredictiveCallResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<vector<string>> params{};
  shared_ptr<string> requestId{};

  StartPredictiveCallResponseBody() {}

  explicit StartPredictiveCallResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (params) {
      res["Params"] = boost::any(*params);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        StartPredictiveCallResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<StartPredictiveCallResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Params") != m.end() && !m["Params"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Params"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Params"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      params = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~StartPredictiveCallResponseBody() = default;
};
class StartPredictiveCallResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<StartPredictiveCallResponseBody> body{};

  StartPredictiveCallResponse() {}

  explicit StartPredictiveCallResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        StartPredictiveCallResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<StartPredictiveCallResponseBody>(model1);
      }
    }
  }


  virtual ~StartPredictiveCallResponse() = default;
};
class StartPrivacyCallRequest : public Darabonba::Model {
public:
  shared_ptr<string> appId{};
  shared_ptr<string> callee{};
  shared_ptr<string> caller{};
  shared_ptr<string> instanceId{};

  StartPrivacyCallRequest() {}

  explicit StartPrivacyCallRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (callee) {
      res["Callee"] = boost::any(*callee);
    }
    if (caller) {
      res["Caller"] = boost::any(*caller);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("Callee") != m.end() && !m["Callee"].empty()) {
      callee = make_shared<string>(boost::any_cast<string>(m["Callee"]));
    }
    if (m.find("Caller") != m.end() && !m["Caller"].empty()) {
      caller = make_shared<string>(boost::any_cast<string>(m["Caller"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~StartPrivacyCallRequest() = default;
};
class StartPrivacyCallResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<vector<string>> params{};
  shared_ptr<string> requestId{};

  StartPrivacyCallResponseBody() {}

  explicit StartPrivacyCallResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (params) {
      res["Params"] = boost::any(*params);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Params") != m.end() && !m["Params"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Params"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Params"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      params = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~StartPrivacyCallResponseBody() = default;
};
class StartPrivacyCallResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<StartPrivacyCallResponseBody> body{};

  StartPrivacyCallResponse() {}

  explicit StartPrivacyCallResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        StartPrivacyCallResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<StartPrivacyCallResponseBody>(model1);
      }
    }
  }


  virtual ~StartPrivacyCallResponse() = default;
};
class SubmitCampaignRequest : public Darabonba::Model {
public:
  shared_ptr<string> campaignId{};
  shared_ptr<string> instanceId{};

  SubmitCampaignRequest() {}

  explicit SubmitCampaignRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (campaignId) {
      res["CampaignId"] = boost::any(*campaignId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CampaignId") != m.end() && !m["CampaignId"].empty()) {
      campaignId = make_shared<string>(boost::any_cast<string>(m["CampaignId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~SubmitCampaignRequest() = default;
};
class SubmitCampaignResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  SubmitCampaignResponseBody() {}

  explicit SubmitCampaignResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<string>(boost::any_cast<string>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SubmitCampaignResponseBody() = default;
};
class SubmitCampaignResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SubmitCampaignResponseBody> body{};

  SubmitCampaignResponse() {}

  explicit SubmitCampaignResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SubmitCampaignResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SubmitCampaignResponseBody>(model1);
      }
    }
  }


  virtual ~SubmitCampaignResponse() = default;
};
class SwitchToConferenceRequest : public Darabonba::Model {
public:
  shared_ptr<string> deviceId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> jobId{};
  shared_ptr<string> userId{};

  SwitchToConferenceRequest() {}

  explicit SwitchToConferenceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~SwitchToConferenceRequest() = default;
};
class SwitchToConferenceResponseBodyDataCallContextChannelContexts : public Darabonba::Model {
public:
  shared_ptr<string> callType{};
  shared_ptr<string> channelFlags{};
  shared_ptr<string> channelId{};
  shared_ptr<string> channelState{};
  shared_ptr<string> destination{};
  shared_ptr<long> index{};
  shared_ptr<string> jobId{};
  shared_ptr<string> originator{};
  shared_ptr<string> releaseInitiator{};
  shared_ptr<string> releaseReason{};
  shared_ptr<string> skillGroupId{};
  shared_ptr<long> timestamp{};
  shared_ptr<string> userExtension{};
  shared_ptr<string> userId{};

  SwitchToConferenceResponseBodyDataCallContextChannelContexts() {}

  explicit SwitchToConferenceResponseBodyDataCallContextChannelContexts(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callType) {
      res["CallType"] = boost::any(*callType);
    }
    if (channelFlags) {
      res["ChannelFlags"] = boost::any(*channelFlags);
    }
    if (channelId) {
      res["ChannelId"] = boost::any(*channelId);
    }
    if (channelState) {
      res["ChannelState"] = boost::any(*channelState);
    }
    if (destination) {
      res["Destination"] = boost::any(*destination);
    }
    if (index) {
      res["Index"] = boost::any(*index);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (originator) {
      res["Originator"] = boost::any(*originator);
    }
    if (releaseInitiator) {
      res["ReleaseInitiator"] = boost::any(*releaseInitiator);
    }
    if (releaseReason) {
      res["ReleaseReason"] = boost::any(*releaseReason);
    }
    if (skillGroupId) {
      res["SkillGroupId"] = boost::any(*skillGroupId);
    }
    if (timestamp) {
      res["Timestamp"] = boost::any(*timestamp);
    }
    if (userExtension) {
      res["UserExtension"] = boost::any(*userExtension);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallType") != m.end() && !m["CallType"].empty()) {
      callType = make_shared<string>(boost::any_cast<string>(m["CallType"]));
    }
    if (m.find("ChannelFlags") != m.end() && !m["ChannelFlags"].empty()) {
      channelFlags = make_shared<string>(boost::any_cast<string>(m["ChannelFlags"]));
    }
    if (m.find("ChannelId") != m.end() && !m["ChannelId"].empty()) {
      channelId = make_shared<string>(boost::any_cast<string>(m["ChannelId"]));
    }
    if (m.find("ChannelState") != m.end() && !m["ChannelState"].empty()) {
      channelState = make_shared<string>(boost::any_cast<string>(m["ChannelState"]));
    }
    if (m.find("Destination") != m.end() && !m["Destination"].empty()) {
      destination = make_shared<string>(boost::any_cast<string>(m["Destination"]));
    }
    if (m.find("Index") != m.end() && !m["Index"].empty()) {
      index = make_shared<long>(boost::any_cast<long>(m["Index"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("Originator") != m.end() && !m["Originator"].empty()) {
      originator = make_shared<string>(boost::any_cast<string>(m["Originator"]));
    }
    if (m.find("ReleaseInitiator") != m.end() && !m["ReleaseInitiator"].empty()) {
      releaseInitiator = make_shared<string>(boost::any_cast<string>(m["ReleaseInitiator"]));
    }
    if (m.find("ReleaseReason") != m.end() && !m["ReleaseReason"].empty()) {
      releaseReason = make_shared<string>(boost::any_cast<string>(m["ReleaseReason"]));
    }
    if (m.find("SkillGroupId") != m.end() && !m["SkillGroupId"].empty()) {
      skillGroupId = make_shared<string>(boost::any_cast<string>(m["SkillGroupId"]));
    }
    if (m.find("Timestamp") != m.end() && !m["Timestamp"].empty()) {
      timestamp = make_shared<long>(boost::any_cast<long>(m["Timestamp"]));
    }
    if (m.find("UserExtension") != m.end() && !m["UserExtension"].empty()) {
      userExtension = make_shared<string>(boost::any_cast<string>(m["UserExtension"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~SwitchToConferenceResponseBodyDataCallContextChannelContexts() = default;
};
class SwitchToConferenceResponseBodyDataCallContext : public Darabonba::Model {
public:
  shared_ptr<string> callType{};
  shared_ptr<vector<SwitchToConferenceResponseBodyDataCallContextChannelContexts>> channelContexts{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> jobId{};

  SwitchToConferenceResponseBodyDataCallContext() {}

  explicit SwitchToConferenceResponseBodyDataCallContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callType) {
      res["CallType"] = boost::any(*callType);
    }
    if (channelContexts) {
      vector<boost::any> temp1;
      for(auto item1:*channelContexts){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ChannelContexts"] = boost::any(temp1);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallType") != m.end() && !m["CallType"].empty()) {
      callType = make_shared<string>(boost::any_cast<string>(m["CallType"]));
    }
    if (m.find("ChannelContexts") != m.end() && !m["ChannelContexts"].empty()) {
      if (typeid(vector<boost::any>) == m["ChannelContexts"].type()) {
        vector<SwitchToConferenceResponseBodyDataCallContextChannelContexts> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ChannelContexts"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SwitchToConferenceResponseBodyDataCallContextChannelContexts model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        channelContexts = make_shared<vector<SwitchToConferenceResponseBodyDataCallContextChannelContexts>>(expect1);
      }
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
  }


  virtual ~SwitchToConferenceResponseBodyDataCallContext() = default;
};
class SwitchToConferenceResponseBodyDataUserContext : public Darabonba::Model {
public:
  shared_ptr<string> breakCode{};
  shared_ptr<string> deviceId{};
  shared_ptr<string> deviceState{};
  shared_ptr<string> extension{};
  shared_ptr<long> heartbeat{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> jobId{};
  shared_ptr<string> mobile{};
  shared_ptr<bool> outboundScenario{};
  shared_ptr<vector<string>> signedSkillGroupIdList{};
  shared_ptr<string> userId{};
  shared_ptr<string> userState{};
  shared_ptr<string> workMode{};

  SwitchToConferenceResponseBodyDataUserContext() {}

  explicit SwitchToConferenceResponseBodyDataUserContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (breakCode) {
      res["BreakCode"] = boost::any(*breakCode);
    }
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (deviceState) {
      res["DeviceState"] = boost::any(*deviceState);
    }
    if (extension) {
      res["Extension"] = boost::any(*extension);
    }
    if (heartbeat) {
      res["Heartbeat"] = boost::any(*heartbeat);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (mobile) {
      res["Mobile"] = boost::any(*mobile);
    }
    if (outboundScenario) {
      res["OutboundScenario"] = boost::any(*outboundScenario);
    }
    if (signedSkillGroupIdList) {
      res["SignedSkillGroupIdList"] = boost::any(*signedSkillGroupIdList);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (userState) {
      res["UserState"] = boost::any(*userState);
    }
    if (workMode) {
      res["WorkMode"] = boost::any(*workMode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BreakCode") != m.end() && !m["BreakCode"].empty()) {
      breakCode = make_shared<string>(boost::any_cast<string>(m["BreakCode"]));
    }
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("DeviceState") != m.end() && !m["DeviceState"].empty()) {
      deviceState = make_shared<string>(boost::any_cast<string>(m["DeviceState"]));
    }
    if (m.find("Extension") != m.end() && !m["Extension"].empty()) {
      extension = make_shared<string>(boost::any_cast<string>(m["Extension"]));
    }
    if (m.find("Heartbeat") != m.end() && !m["Heartbeat"].empty()) {
      heartbeat = make_shared<long>(boost::any_cast<long>(m["Heartbeat"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("Mobile") != m.end() && !m["Mobile"].empty()) {
      mobile = make_shared<string>(boost::any_cast<string>(m["Mobile"]));
    }
    if (m.find("OutboundScenario") != m.end() && !m["OutboundScenario"].empty()) {
      outboundScenario = make_shared<bool>(boost::any_cast<bool>(m["OutboundScenario"]));
    }
    if (m.find("SignedSkillGroupIdList") != m.end() && !m["SignedSkillGroupIdList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SignedSkillGroupIdList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SignedSkillGroupIdList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      signedSkillGroupIdList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
    if (m.find("UserState") != m.end() && !m["UserState"].empty()) {
      userState = make_shared<string>(boost::any_cast<string>(m["UserState"]));
    }
    if (m.find("WorkMode") != m.end() && !m["WorkMode"].empty()) {
      workMode = make_shared<string>(boost::any_cast<string>(m["WorkMode"]));
    }
  }


  virtual ~SwitchToConferenceResponseBodyDataUserContext() = default;
};
class SwitchToConferenceResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<SwitchToConferenceResponseBodyDataCallContext> callContext{};
  shared_ptr<SwitchToConferenceResponseBodyDataUserContext> userContext{};

  SwitchToConferenceResponseBodyData() {}

  explicit SwitchToConferenceResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callContext) {
      res["CallContext"] = callContext ? boost::any(callContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (userContext) {
      res["UserContext"] = userContext ? boost::any(userContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallContext") != m.end() && !m["CallContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["CallContext"].type()) {
        SwitchToConferenceResponseBodyDataCallContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CallContext"]));
        callContext = make_shared<SwitchToConferenceResponseBodyDataCallContext>(model1);
      }
    }
    if (m.find("UserContext") != m.end() && !m["UserContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["UserContext"].type()) {
        SwitchToConferenceResponseBodyDataUserContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["UserContext"]));
        userContext = make_shared<SwitchToConferenceResponseBodyDataUserContext>(model1);
      }
    }
  }


  virtual ~SwitchToConferenceResponseBodyData() = default;
};
class SwitchToConferenceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<SwitchToConferenceResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<vector<string>> params{};
  shared_ptr<string> requestId{};

  SwitchToConferenceResponseBody() {}

  explicit SwitchToConferenceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (params) {
      res["Params"] = boost::any(*params);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        SwitchToConferenceResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<SwitchToConferenceResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Params") != m.end() && !m["Params"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Params"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Params"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      params = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SwitchToConferenceResponseBody() = default;
};
class SwitchToConferenceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SwitchToConferenceResponseBody> body{};

  SwitchToConferenceResponse() {}

  explicit SwitchToConferenceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SwitchToConferenceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SwitchToConferenceResponseBody>(model1);
      }
    }
  }


  virtual ~SwitchToConferenceResponse() = default;
};
class TakeBreakRequest : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> deviceId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> userId{};

  TakeBreakRequest() {}

  explicit TakeBreakRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~TakeBreakRequest() = default;
};
class TakeBreakResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> breakCode{};
  shared_ptr<string> deviceId{};
  shared_ptr<string> extension{};
  shared_ptr<long> heartbeat{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> jobId{};
  shared_ptr<string> mobile{};
  shared_ptr<bool> outboundScenario{};
  shared_ptr<long> reserved{};
  shared_ptr<vector<string>> signedSkillGroupIdList{};
  shared_ptr<string> userId{};
  shared_ptr<string> userState{};
  shared_ptr<string> workMode{};

  TakeBreakResponseBodyData() {}

  explicit TakeBreakResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (breakCode) {
      res["BreakCode"] = boost::any(*breakCode);
    }
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (extension) {
      res["Extension"] = boost::any(*extension);
    }
    if (heartbeat) {
      res["Heartbeat"] = boost::any(*heartbeat);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (mobile) {
      res["Mobile"] = boost::any(*mobile);
    }
    if (outboundScenario) {
      res["OutboundScenario"] = boost::any(*outboundScenario);
    }
    if (reserved) {
      res["Reserved"] = boost::any(*reserved);
    }
    if (signedSkillGroupIdList) {
      res["SignedSkillGroupIdList"] = boost::any(*signedSkillGroupIdList);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (userState) {
      res["UserState"] = boost::any(*userState);
    }
    if (workMode) {
      res["WorkMode"] = boost::any(*workMode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BreakCode") != m.end() && !m["BreakCode"].empty()) {
      breakCode = make_shared<string>(boost::any_cast<string>(m["BreakCode"]));
    }
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("Extension") != m.end() && !m["Extension"].empty()) {
      extension = make_shared<string>(boost::any_cast<string>(m["Extension"]));
    }
    if (m.find("Heartbeat") != m.end() && !m["Heartbeat"].empty()) {
      heartbeat = make_shared<long>(boost::any_cast<long>(m["Heartbeat"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("Mobile") != m.end() && !m["Mobile"].empty()) {
      mobile = make_shared<string>(boost::any_cast<string>(m["Mobile"]));
    }
    if (m.find("OutboundScenario") != m.end() && !m["OutboundScenario"].empty()) {
      outboundScenario = make_shared<bool>(boost::any_cast<bool>(m["OutboundScenario"]));
    }
    if (m.find("Reserved") != m.end() && !m["Reserved"].empty()) {
      reserved = make_shared<long>(boost::any_cast<long>(m["Reserved"]));
    }
    if (m.find("SignedSkillGroupIdList") != m.end() && !m["SignedSkillGroupIdList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SignedSkillGroupIdList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SignedSkillGroupIdList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      signedSkillGroupIdList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
    if (m.find("UserState") != m.end() && !m["UserState"].empty()) {
      userState = make_shared<string>(boost::any_cast<string>(m["UserState"]));
    }
    if (m.find("WorkMode") != m.end() && !m["WorkMode"].empty()) {
      workMode = make_shared<string>(boost::any_cast<string>(m["WorkMode"]));
    }
  }


  virtual ~TakeBreakResponseBodyData() = default;
};
class TakeBreakResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<TakeBreakResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<vector<string>> params{};
  shared_ptr<string> requestId{};

  TakeBreakResponseBody() {}

  explicit TakeBreakResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (params) {
      res["Params"] = boost::any(*params);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        TakeBreakResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<TakeBreakResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Params") != m.end() && !m["Params"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Params"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Params"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      params = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~TakeBreakResponseBody() = default;
};
class TakeBreakResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<TakeBreakResponseBody> body{};

  TakeBreakResponse() {}

  explicit TakeBreakResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        TakeBreakResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<TakeBreakResponseBody>(model1);
      }
    }
  }


  virtual ~TakeBreakResponse() = default;
};
class UnmuteCallRequest : public Darabonba::Model {
public:
  shared_ptr<string> channelId{};
  shared_ptr<string> deviceId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> jobId{};
  shared_ptr<string> userId{};

  UnmuteCallRequest() {}

  explicit UnmuteCallRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (channelId) {
      res["ChannelId"] = boost::any(*channelId);
    }
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChannelId") != m.end() && !m["ChannelId"].empty()) {
      channelId = make_shared<string>(boost::any_cast<string>(m["ChannelId"]));
    }
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~UnmuteCallRequest() = default;
};
class UnmuteCallResponseBodyDataCallContextChannelContexts : public Darabonba::Model {
public:
  shared_ptr<string> callType{};
  shared_ptr<string> channelFlags{};
  shared_ptr<string> channelId{};
  shared_ptr<string> channelState{};
  shared_ptr<string> destination{};
  shared_ptr<long> index{};
  shared_ptr<string> jobId{};
  shared_ptr<string> originator{};
  shared_ptr<string> releaseInitiator{};
  shared_ptr<string> releaseReason{};
  shared_ptr<string> skillGroupId{};
  shared_ptr<long> timestamp{};
  shared_ptr<string> userExtension{};
  shared_ptr<string> userId{};

  UnmuteCallResponseBodyDataCallContextChannelContexts() {}

  explicit UnmuteCallResponseBodyDataCallContextChannelContexts(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callType) {
      res["CallType"] = boost::any(*callType);
    }
    if (channelFlags) {
      res["ChannelFlags"] = boost::any(*channelFlags);
    }
    if (channelId) {
      res["ChannelId"] = boost::any(*channelId);
    }
    if (channelState) {
      res["ChannelState"] = boost::any(*channelState);
    }
    if (destination) {
      res["Destination"] = boost::any(*destination);
    }
    if (index) {
      res["Index"] = boost::any(*index);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (originator) {
      res["Originator"] = boost::any(*originator);
    }
    if (releaseInitiator) {
      res["ReleaseInitiator"] = boost::any(*releaseInitiator);
    }
    if (releaseReason) {
      res["ReleaseReason"] = boost::any(*releaseReason);
    }
    if (skillGroupId) {
      res["SkillGroupId"] = boost::any(*skillGroupId);
    }
    if (timestamp) {
      res["Timestamp"] = boost::any(*timestamp);
    }
    if (userExtension) {
      res["UserExtension"] = boost::any(*userExtension);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallType") != m.end() && !m["CallType"].empty()) {
      callType = make_shared<string>(boost::any_cast<string>(m["CallType"]));
    }
    if (m.find("ChannelFlags") != m.end() && !m["ChannelFlags"].empty()) {
      channelFlags = make_shared<string>(boost::any_cast<string>(m["ChannelFlags"]));
    }
    if (m.find("ChannelId") != m.end() && !m["ChannelId"].empty()) {
      channelId = make_shared<string>(boost::any_cast<string>(m["ChannelId"]));
    }
    if (m.find("ChannelState") != m.end() && !m["ChannelState"].empty()) {
      channelState = make_shared<string>(boost::any_cast<string>(m["ChannelState"]));
    }
    if (m.find("Destination") != m.end() && !m["Destination"].empty()) {
      destination = make_shared<string>(boost::any_cast<string>(m["Destination"]));
    }
    if (m.find("Index") != m.end() && !m["Index"].empty()) {
      index = make_shared<long>(boost::any_cast<long>(m["Index"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("Originator") != m.end() && !m["Originator"].empty()) {
      originator = make_shared<string>(boost::any_cast<string>(m["Originator"]));
    }
    if (m.find("ReleaseInitiator") != m.end() && !m["ReleaseInitiator"].empty()) {
      releaseInitiator = make_shared<string>(boost::any_cast<string>(m["ReleaseInitiator"]));
    }
    if (m.find("ReleaseReason") != m.end() && !m["ReleaseReason"].empty()) {
      releaseReason = make_shared<string>(boost::any_cast<string>(m["ReleaseReason"]));
    }
    if (m.find("SkillGroupId") != m.end() && !m["SkillGroupId"].empty()) {
      skillGroupId = make_shared<string>(boost::any_cast<string>(m["SkillGroupId"]));
    }
    if (m.find("Timestamp") != m.end() && !m["Timestamp"].empty()) {
      timestamp = make_shared<long>(boost::any_cast<long>(m["Timestamp"]));
    }
    if (m.find("UserExtension") != m.end() && !m["UserExtension"].empty()) {
      userExtension = make_shared<string>(boost::any_cast<string>(m["UserExtension"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~UnmuteCallResponseBodyDataCallContextChannelContexts() = default;
};
class UnmuteCallResponseBodyDataCallContext : public Darabonba::Model {
public:
  shared_ptr<string> callType{};
  shared_ptr<vector<UnmuteCallResponseBodyDataCallContextChannelContexts>> channelContexts{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> jobId{};

  UnmuteCallResponseBodyDataCallContext() {}

  explicit UnmuteCallResponseBodyDataCallContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callType) {
      res["CallType"] = boost::any(*callType);
    }
    if (channelContexts) {
      vector<boost::any> temp1;
      for(auto item1:*channelContexts){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ChannelContexts"] = boost::any(temp1);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallType") != m.end() && !m["CallType"].empty()) {
      callType = make_shared<string>(boost::any_cast<string>(m["CallType"]));
    }
    if (m.find("ChannelContexts") != m.end() && !m["ChannelContexts"].empty()) {
      if (typeid(vector<boost::any>) == m["ChannelContexts"].type()) {
        vector<UnmuteCallResponseBodyDataCallContextChannelContexts> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ChannelContexts"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UnmuteCallResponseBodyDataCallContextChannelContexts model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        channelContexts = make_shared<vector<UnmuteCallResponseBodyDataCallContextChannelContexts>>(expect1);
      }
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
  }


  virtual ~UnmuteCallResponseBodyDataCallContext() = default;
};
class UnmuteCallResponseBodyDataUserContext : public Darabonba::Model {
public:
  shared_ptr<string> breakCode{};
  shared_ptr<string> deviceId{};
  shared_ptr<string> extension{};
  shared_ptr<long> heartbeat{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> jobId{};
  shared_ptr<string> mobile{};
  shared_ptr<bool> outboundScenario{};
  shared_ptr<vector<string>> signedSkillGroupIdList{};
  shared_ptr<string> userId{};
  shared_ptr<string> userState{};
  shared_ptr<string> workMode{};

  UnmuteCallResponseBodyDataUserContext() {}

  explicit UnmuteCallResponseBodyDataUserContext(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (breakCode) {
      res["BreakCode"] = boost::any(*breakCode);
    }
    if (deviceId) {
      res["DeviceId"] = boost::any(*deviceId);
    }
    if (extension) {
      res["Extension"] = boost::any(*extension);
    }
    if (heartbeat) {
      res["Heartbeat"] = boost::any(*heartbeat);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (mobile) {
      res["Mobile"] = boost::any(*mobile);
    }
    if (outboundScenario) {
      res["OutboundScenario"] = boost::any(*outboundScenario);
    }
    if (signedSkillGroupIdList) {
      res["SignedSkillGroupIdList"] = boost::any(*signedSkillGroupIdList);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (userState) {
      res["UserState"] = boost::any(*userState);
    }
    if (workMode) {
      res["WorkMode"] = boost::any(*workMode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BreakCode") != m.end() && !m["BreakCode"].empty()) {
      breakCode = make_shared<string>(boost::any_cast<string>(m["BreakCode"]));
    }
    if (m.find("DeviceId") != m.end() && !m["DeviceId"].empty()) {
      deviceId = make_shared<string>(boost::any_cast<string>(m["DeviceId"]));
    }
    if (m.find("Extension") != m.end() && !m["Extension"].empty()) {
      extension = make_shared<string>(boost::any_cast<string>(m["Extension"]));
    }
    if (m.find("Heartbeat") != m.end() && !m["Heartbeat"].empty()) {
      heartbeat = make_shared<long>(boost::any_cast<long>(m["Heartbeat"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("Mobile") != m.end() && !m["Mobile"].empty()) {
      mobile = make_shared<string>(boost::any_cast<string>(m["Mobile"]));
    }
    if (m.find("OutboundScenario") != m.end() && !m["OutboundScenario"].empty()) {
      outboundScenario = make_shared<bool>(boost::any_cast<bool>(m["OutboundScenario"]));
    }
    if (m.find("SignedSkillGroupIdList") != m.end() && !m["SignedSkillGroupIdList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SignedSkillGroupIdList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SignedSkillGroupIdList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      signedSkillGroupIdList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
    if (m.find("UserState") != m.end() && !m["UserState"].empty()) {
      userState = make_shared<string>(boost::any_cast<string>(m["UserState"]));
    }
    if (m.find("WorkMode") != m.end() && !m["WorkMode"].empty()) {
      workMode = make_shared<string>(boost::any_cast<string>(m["WorkMode"]));
    }
  }


  virtual ~UnmuteCallResponseBodyDataUserContext() = default;
};
class UnmuteCallResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<UnmuteCallResponseBodyDataCallContext> callContext{};
  shared_ptr<UnmuteCallResponseBodyDataUserContext> userContext{};

  UnmuteCallResponseBodyData() {}

  explicit UnmuteCallResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (callContext) {
      res["CallContext"] = callContext ? boost::any(callContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (userContext) {
      res["UserContext"] = userContext ? boost::any(userContext->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CallContext") != m.end() && !m["CallContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["CallContext"].type()) {
        UnmuteCallResponseBodyDataCallContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CallContext"]));
        callContext = make_shared<UnmuteCallResponseBodyDataCallContext>(model1);
      }
    }
    if (m.find("UserContext") != m.end() && !m["UserContext"].empty()) {
      if (typeid(map<string, boost::any>) == m["UserContext"].type()) {
        UnmuteCallResponseBodyDataUserContext model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["UserContext"]));
        userContext = make_shared<UnmuteCallResponseBodyDataUserContext>(model1);
      }
    }
  }


  virtual ~UnmuteCallResponseBodyData() = default;
};
class UnmuteCallResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<UnmuteCallResponseBodyData> data{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<vector<string>> params{};
  shared_ptr<string> requestId{};

  UnmuteCallResponseBody() {}

  explicit UnmuteCallResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (data) {
      res["Data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (params) {
      res["Params"] = boost::any(*params);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      if (typeid(map<string, boost::any>) == m["Data"].type()) {
        UnmuteCallResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Data"]));
        data = make_shared<UnmuteCallResponseBodyData>(model1);
      }
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Params") != m.end() && !m["Params"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Params"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Params"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      params = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UnmuteCallResponseBody() = default;
};
class UnmuteCallResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UnmuteCallResponseBody> body{};

  UnmuteCallResponse() {}

  explicit UnmuteCallResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UnmuteCallResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UnmuteCallResponseBody>(model1);
      }
    }
  }


  virtual ~UnmuteCallResponse() = default;
};
class UnregisterDeviceRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> userId{};

  UnregisterDeviceRequest() {}

  explicit UnregisterDeviceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~UnregisterDeviceRequest() = default;
};
class UnregisterDeviceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  UnregisterDeviceResponseBody() {}

  explicit UnregisterDeviceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UnregisterDeviceResponseBody() = default;
};
class UnregisterDeviceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UnregisterDeviceResponseBody> body{};

  UnregisterDeviceResponse() {}

  explicit UnregisterDeviceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UnregisterDeviceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UnregisterDeviceResponseBody>(model1);
      }
    }
  }


  virtual ~UnregisterDeviceResponse() = default;
};
class UpdateConfigItemsRequest : public Darabonba::Model {
public:
  shared_ptr<string> configItems{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> objectId{};
  shared_ptr<string> objectType{};

  UpdateConfigItemsRequest() {}

  explicit UpdateConfigItemsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configItems) {
      res["ConfigItems"] = boost::any(*configItems);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (objectId) {
      res["ObjectId"] = boost::any(*objectId);
    }
    if (objectType) {
      res["ObjectType"] = boost::any(*objectType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigItems") != m.end() && !m["ConfigItems"].empty()) {
      configItems = make_shared<string>(boost::any_cast<string>(m["ConfigItems"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("ObjectId") != m.end() && !m["ObjectId"].empty()) {
      objectId = make_shared<string>(boost::any_cast<string>(m["ObjectId"]));
    }
    if (m.find("ObjectType") != m.end() && !m["ObjectType"].empty()) {
      objectType = make_shared<string>(boost::any_cast<string>(m["ObjectType"]));
    }
  }


  virtual ~UpdateConfigItemsRequest() = default;
};
class UpdateConfigItemsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  UpdateConfigItemsResponseBody() {}

  explicit UpdateConfigItemsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<long>(boost::any_cast<long>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateConfigItemsResponseBody() = default;
};
class UpdateConfigItemsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateConfigItemsResponseBody> body{};

  UpdateConfigItemsResponse() {}

  explicit UpdateConfigItemsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateConfigItemsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateConfigItemsResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateConfigItemsResponse() = default;
};
class Client : Alibabacloud_OpenApi::Client {
public:
  explicit Client(const shared_ptr<Alibabacloud_OpenApi::Config>& config);
  string getEndpoint(shared_ptr<string> productId,
                     shared_ptr<string> regionId,
                     shared_ptr<string> endpointRule,
                     shared_ptr<string> network,
                     shared_ptr<string> suffix,
                     shared_ptr<map<string, string>> endpointMap,
                     shared_ptr<string> endpoint);
  AbortCampaignResponse abortCampaignWithOptions(shared_ptr<AbortCampaignRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AbortCampaignResponse abortCampaign(shared_ptr<AbortCampaignRequest> request);
  AddCasesResponse addCasesWithOptions(shared_ptr<AddCasesRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddCasesResponse addCases(shared_ptr<AddCasesRequest> request);
  AddNumbersToSkillGroupResponse addNumbersToSkillGroupWithOptions(shared_ptr<AddNumbersToSkillGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddNumbersToSkillGroupResponse addNumbersToSkillGroup(shared_ptr<AddNumbersToSkillGroupRequest> request);
  AddPersonalNumbersToUserResponse addPersonalNumbersToUserWithOptions(shared_ptr<AddPersonalNumbersToUserRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddPersonalNumbersToUserResponse addPersonalNumbersToUser(shared_ptr<AddPersonalNumbersToUserRequest> request);
  AddPhoneNumberToSkillGroupsResponse addPhoneNumberToSkillGroupsWithOptions(shared_ptr<AddPhoneNumberToSkillGroupsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddPhoneNumberToSkillGroupsResponse addPhoneNumberToSkillGroups(shared_ptr<AddPhoneNumberToSkillGroupsRequest> request);
  AddPhoneNumbersResponse addPhoneNumbersWithOptions(shared_ptr<AddPhoneNumbersRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddPhoneNumbersResponse addPhoneNumbers(shared_ptr<AddPhoneNumbersRequest> request);
  AddSkillGroupsToUserResponse addSkillGroupsToUserWithOptions(shared_ptr<AddSkillGroupsToUserRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddSkillGroupsToUserResponse addSkillGroupsToUser(shared_ptr<AddSkillGroupsToUserRequest> request);
  AddUsersToSkillGroupResponse addUsersToSkillGroupWithOptions(shared_ptr<AddUsersToSkillGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddUsersToSkillGroupResponse addUsersToSkillGroup(shared_ptr<AddUsersToSkillGroupRequest> request);
  AnswerCallResponse answerCallWithOptions(shared_ptr<AnswerCallRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AnswerCallResponse answerCall(shared_ptr<AnswerCallRequest> request);
  AssignUsersResponse assignUsersWithOptions(shared_ptr<AssignUsersRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AssignUsersResponse assignUsers(shared_ptr<AssignUsersRequest> request);
  BargeInCallResponse bargeInCallWithOptions(shared_ptr<BargeInCallRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  BargeInCallResponse bargeInCall(shared_ptr<BargeInCallRequest> request);
  BlindTransferResponse blindTransferWithOptions(shared_ptr<BlindTransferRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  BlindTransferResponse blindTransfer(shared_ptr<BlindTransferRequest> request);
  CancelAttendedTransferResponse cancelAttendedTransferWithOptions(shared_ptr<CancelAttendedTransferRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CancelAttendedTransferResponse cancelAttendedTransfer(shared_ptr<CancelAttendedTransferRequest> request);
  ChangeWorkModeResponse changeWorkModeWithOptions(shared_ptr<ChangeWorkModeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ChangeWorkModeResponse changeWorkMode(shared_ptr<ChangeWorkModeRequest> request);
  CoachCallResponse coachCallWithOptions(shared_ptr<CoachCallRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CoachCallResponse coachCall(shared_ptr<CoachCallRequest> request);
  CompleteAttendedTransferResponse completeAttendedTransferWithOptions(shared_ptr<CompleteAttendedTransferRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CompleteAttendedTransferResponse completeAttendedTransfer(shared_ptr<CompleteAttendedTransferRequest> request);
  CreateAudioFileResponse createAudioFileWithOptions(shared_ptr<CreateAudioFileRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateAudioFileResponse createAudioFile(shared_ptr<CreateAudioFileRequest> request);
  CreateCallTagsResponse createCallTagsWithOptions(shared_ptr<CreateCallTagsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateCallTagsResponse createCallTags(shared_ptr<CreateCallTagsRequest> request);
  CreateCampaignResponse createCampaignWithOptions(shared_ptr<CreateCampaignRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateCampaignResponse createCampaign(shared_ptr<CreateCampaignRequest> request);
  CreateCustomCallTaggingResponse createCustomCallTaggingWithOptions(shared_ptr<CreateCustomCallTaggingRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateCustomCallTaggingResponse createCustomCallTagging(shared_ptr<CreateCustomCallTaggingRequest> request);
  CreateInstanceResponse createInstanceWithOptions(shared_ptr<CreateInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateInstanceResponse createInstance(shared_ptr<CreateInstanceRequest> request);
  CreateSkillGroupResponse createSkillGroupWithOptions(shared_ptr<CreateSkillGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateSkillGroupResponse createSkillGroup(shared_ptr<CreateSkillGroupRequest> request);
  CreateUserResponse createUserWithOptions(shared_ptr<CreateUserRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateUserResponse createUser(shared_ptr<CreateUserRequest> request);
  DeleteAudioFileResponse deleteAudioFileWithOptions(shared_ptr<DeleteAudioFileRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteAudioFileResponse deleteAudioFile(shared_ptr<DeleteAudioFileRequest> request);
  DeleteCallTagResponse deleteCallTagWithOptions(shared_ptr<DeleteCallTagRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteCallTagResponse deleteCallTag(shared_ptr<DeleteCallTagRequest> request);
  DeleteCustomCallTaggingResponse deleteCustomCallTaggingWithOptions(shared_ptr<DeleteCustomCallTaggingRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteCustomCallTaggingResponse deleteCustomCallTagging(shared_ptr<DeleteCustomCallTaggingRequest> request);
  DeleteSkillGroupResponse deleteSkillGroupWithOptions(shared_ptr<DeleteSkillGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteSkillGroupResponse deleteSkillGroup(shared_ptr<DeleteSkillGroupRequest> request);
  EndConferenceResponse endConferenceWithOptions(shared_ptr<EndConferenceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  EndConferenceResponse endConference(shared_ptr<EndConferenceRequest> request);
  ExportCustomCallTaggingResponse exportCustomCallTaggingWithOptions(shared_ptr<ExportCustomCallTaggingRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ExportCustomCallTaggingResponse exportCustomCallTagging(shared_ptr<ExportCustomCallTaggingRequest> request);
  ExportDoNotCallNumbersResponse exportDoNotCallNumbersWithOptions(shared_ptr<ExportDoNotCallNumbersRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ExportDoNotCallNumbersResponse exportDoNotCallNumbers(shared_ptr<ExportDoNotCallNumbersRequest> request);
  GetAudioFileResponse getAudioFileWithOptions(shared_ptr<GetAudioFileRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetAudioFileResponse getAudioFile(shared_ptr<GetAudioFileRequest> request);
  GetAudioFileDownloadUrlResponse getAudioFileDownloadUrlWithOptions(shared_ptr<GetAudioFileDownloadUrlRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetAudioFileDownloadUrlResponse getAudioFileDownloadUrl(shared_ptr<GetAudioFileDownloadUrlRequest> request);
  GetAudioFileUploadParametersResponse getAudioFileUploadParametersWithOptions(shared_ptr<GetAudioFileUploadParametersRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetAudioFileUploadParametersResponse getAudioFileUploadParameters(shared_ptr<GetAudioFileUploadParametersRequest> request);
  GetCallDetailRecordResponse getCallDetailRecordWithOptions(shared_ptr<GetCallDetailRecordRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetCallDetailRecordResponse getCallDetailRecord(shared_ptr<GetCallDetailRecordRequest> request);
  GetCampaignResponse getCampaignWithOptions(shared_ptr<GetCampaignRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetCampaignResponse getCampaign(shared_ptr<GetCampaignRequest> request);
  GetCaseFileUploadUrlResponse getCaseFileUploadUrlWithOptions(shared_ptr<GetCaseFileUploadUrlRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetCaseFileUploadUrlResponse getCaseFileUploadUrl(shared_ptr<GetCaseFileUploadUrlRequest> request);
  GetConversationDetailResponse getConversationDetailWithOptions(shared_ptr<GetConversationDetailRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetConversationDetailResponse getConversationDetail(shared_ptr<GetConversationDetailRequest> request);
  GetDoNotCallFileUploadParametersResponse getDoNotCallFileUploadParametersWithOptions(shared_ptr<GetDoNotCallFileUploadParametersRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetDoNotCallFileUploadParametersResponse getDoNotCallFileUploadParameters(shared_ptr<GetDoNotCallFileUploadParametersRequest> request);
  GetHistoricalCallerReportResponse getHistoricalCallerReportWithOptions(shared_ptr<GetHistoricalCallerReportRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetHistoricalCallerReportResponse getHistoricalCallerReport(shared_ptr<GetHistoricalCallerReportRequest> request);
  GetHistoricalCampaignReportResponse getHistoricalCampaignReportWithOptions(shared_ptr<GetHistoricalCampaignReportRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetHistoricalCampaignReportResponse getHistoricalCampaignReport(shared_ptr<GetHistoricalCampaignReportRequest> request);
  GetHistoricalInstanceReportResponse getHistoricalInstanceReportWithOptions(shared_ptr<GetHistoricalInstanceReportRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetHistoricalInstanceReportResponse getHistoricalInstanceReport(shared_ptr<GetHistoricalInstanceReportRequest> request);
  GetInstanceResponse getInstanceWithOptions(shared_ptr<GetInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetInstanceResponse getInstance(shared_ptr<GetInstanceRequest> request);
  GetInstanceTrendingReportResponse getInstanceTrendingReportWithOptions(shared_ptr<GetInstanceTrendingReportRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetInstanceTrendingReportResponse getInstanceTrendingReport(shared_ptr<GetInstanceTrendingReportRequest> request);
  GetLoginDetailsResponse getLoginDetailsWithOptions(shared_ptr<GetLoginDetailsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetLoginDetailsResponse getLoginDetails(shared_ptr<GetLoginDetailsRequest> request);
  GetMonoRecordingResponse getMonoRecordingWithOptions(shared_ptr<GetMonoRecordingRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetMonoRecordingResponse getMonoRecording(shared_ptr<GetMonoRecordingRequest> request);
  GetMultiChannelRecordingResponse getMultiChannelRecordingWithOptions(shared_ptr<GetMultiChannelRecordingRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetMultiChannelRecordingResponse getMultiChannelRecording(shared_ptr<GetMultiChannelRecordingRequest> request);
  GetNumberLocationResponse getNumberLocationWithOptions(shared_ptr<GetNumberLocationRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetNumberLocationResponse getNumberLocation(shared_ptr<GetNumberLocationRequest> request);
  GetRealtimeCampaignStatsResponse getRealtimeCampaignStatsWithOptions(shared_ptr<GetRealtimeCampaignStatsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetRealtimeCampaignStatsResponse getRealtimeCampaignStats(shared_ptr<GetRealtimeCampaignStatsRequest> request);
  GetRealtimeInstanceStatesResponse getRealtimeInstanceStatesWithOptions(shared_ptr<GetRealtimeInstanceStatesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetRealtimeInstanceStatesResponse getRealtimeInstanceStates(shared_ptr<GetRealtimeInstanceStatesRequest> request);
  GetSkillGroupResponse getSkillGroupWithOptions(shared_ptr<GetSkillGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetSkillGroupResponse getSkillGroup(shared_ptr<GetSkillGroupRequest> request);
  GetTurnCredentialsResponse getTurnCredentialsWithOptions(shared_ptr<GetTurnCredentialsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetTurnCredentialsResponse getTurnCredentials(shared_ptr<GetTurnCredentialsRequest> request);
  GetTurnServerListResponse getTurnServerListWithOptions(shared_ptr<GetTurnServerListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetTurnServerListResponse getTurnServerList(shared_ptr<GetTurnServerListRequest> request);
  GetUploadAudioDataParamsResponse getUploadAudioDataParamsWithOptions(shared_ptr<GetUploadAudioDataParamsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetUploadAudioDataParamsResponse getUploadAudioDataParams(shared_ptr<GetUploadAudioDataParamsRequest> request);
  GetUserResponse getUserWithOptions(shared_ptr<GetUserRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetUserResponse getUser(shared_ptr<GetUserRequest> request);
  GetVoicemailRecordingResponse getVoicemailRecordingWithOptions(shared_ptr<GetVoicemailRecordingRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetVoicemailRecordingResponse getVoicemailRecording(shared_ptr<GetVoicemailRecordingRequest> request);
  HoldCallResponse holdCallWithOptions(shared_ptr<HoldCallRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  HoldCallResponse holdCall(shared_ptr<HoldCallRequest> request);
  ImportAdminsResponse importAdminsWithOptions(shared_ptr<ImportAdminsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ImportAdminsResponse importAdmins(shared_ptr<ImportAdminsRequest> request);
  ImportCustomCallTaggingResponse importCustomCallTaggingWithOptions(shared_ptr<ImportCustomCallTaggingRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ImportCustomCallTaggingResponse importCustomCallTagging(shared_ptr<ImportCustomCallTaggingRequest> request);
  ImportDoNotCallNumbersResponse importDoNotCallNumbersWithOptions(shared_ptr<ImportDoNotCallNumbersRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ImportDoNotCallNumbersResponse importDoNotCallNumbers(shared_ptr<ImportDoNotCallNumbersRequest> request);
  InitiateAttendedTransferResponse initiateAttendedTransferWithOptions(shared_ptr<InitiateAttendedTransferRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  InitiateAttendedTransferResponse initiateAttendedTransfer(shared_ptr<InitiateAttendedTransferRequest> request);
  InterceptCallResponse interceptCallWithOptions(shared_ptr<InterceptCallRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  InterceptCallResponse interceptCall(shared_ptr<InterceptCallRequest> request);
  LaunchAuthenticationResponse launchAuthenticationWithOptions(shared_ptr<LaunchAuthenticationRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  LaunchAuthenticationResponse launchAuthentication(shared_ptr<LaunchAuthenticationRequest> request);
  LaunchSurveyResponse launchSurveyWithOptions(shared_ptr<LaunchSurveyRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  LaunchSurveyResponse launchSurvey(shared_ptr<LaunchSurveyRequest> request);
  ListAgentStateLogsResponse listAgentStateLogsWithOptions(shared_ptr<ListAgentStateLogsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListAgentStateLogsResponse listAgentStateLogs(shared_ptr<ListAgentStateLogsRequest> request);
  ListAgentStatesResponse listAgentStatesWithOptions(shared_ptr<ListAgentStatesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListAgentStatesResponse listAgentStates(shared_ptr<ListAgentStatesRequest> request);
  ListAgentSummaryReportsSinceMidnightResponse listAgentSummaryReportsSinceMidnightWithOptions(shared_ptr<ListAgentSummaryReportsSinceMidnightRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListAgentSummaryReportsSinceMidnightResponse listAgentSummaryReportsSinceMidnight(shared_ptr<ListAgentSummaryReportsSinceMidnightRequest> request);
  ListAttemptsResponse listAttemptsWithOptions(shared_ptr<ListAttemptsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListAttemptsResponse listAttempts(shared_ptr<ListAttemptsRequest> request);
  ListAudioFilesResponse listAudioFilesWithOptions(shared_ptr<ListAudioFilesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListAudioFilesResponse listAudioFiles(shared_ptr<ListAudioFilesRequest> request);
  ListBriefSkillGroupsResponse listBriefSkillGroupsWithOptions(shared_ptr<ListBriefSkillGroupsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListBriefSkillGroupsResponse listBriefSkillGroups(shared_ptr<ListBriefSkillGroupsRequest> request);
  ListCallDetailRecordsResponse listCallDetailRecordsWithOptions(shared_ptr<ListCallDetailRecordsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListCallDetailRecordsResponse listCallDetailRecords(shared_ptr<ListCallDetailRecordsRequest> request);
  ListCallTagsResponse listCallTagsWithOptions(shared_ptr<ListCallTagsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListCallTagsResponse listCallTags(shared_ptr<ListCallTagsRequest> request);
  ListCampaignTrendingReportResponse listCampaignTrendingReportWithOptions(shared_ptr<ListCampaignTrendingReportRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListCampaignTrendingReportResponse listCampaignTrendingReport(shared_ptr<ListCampaignTrendingReportRequest> request);
  ListCampaignsResponse listCampaignsWithOptions(shared_ptr<ListCampaignsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListCampaignsResponse listCampaigns(shared_ptr<ListCampaignsRequest> request);
  ListCasesResponse listCasesWithOptions(shared_ptr<ListCasesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListCasesResponse listCases(shared_ptr<ListCasesRequest> request);
  ListConfigItemsResponse listConfigItemsWithOptions(shared_ptr<ListConfigItemsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListConfigItemsResponse listConfigItems(shared_ptr<ListConfigItemsRequest> request);
  ListContactFlowsResponse listContactFlowsWithOptions(shared_ptr<ListContactFlowsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListContactFlowsResponse listContactFlows(shared_ptr<ListContactFlowsRequest> request);
  ListCustomCallTaggingResponse listCustomCallTaggingWithOptions(shared_ptr<ListCustomCallTaggingRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListCustomCallTaggingResponse listCustomCallTagging(shared_ptr<ListCustomCallTaggingRequest> request);
  ListDevicesResponse listDevicesWithOptions(shared_ptr<ListDevicesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListDevicesResponse listDevices(shared_ptr<ListDevicesRequest> request);
  ListDoNotCallNumbersResponse listDoNotCallNumbersWithOptions(shared_ptr<ListDoNotCallNumbersRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListDoNotCallNumbersResponse listDoNotCallNumbers(shared_ptr<ListDoNotCallNumbersRequest> request);
  ListHistoricalAgentReportResponse listHistoricalAgentReportWithOptions(shared_ptr<ListHistoricalAgentReportRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListHistoricalAgentReportResponse listHistoricalAgentReport(shared_ptr<ListHistoricalAgentReportRequest> request);
  ListHistoricalSkillGroupReportResponse listHistoricalSkillGroupReportWithOptions(shared_ptr<ListHistoricalSkillGroupReportRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListHistoricalSkillGroupReportResponse listHistoricalSkillGroupReport(shared_ptr<ListHistoricalSkillGroupReportRequest> request);
  ListInstancesResponse listInstancesWithOptions(shared_ptr<ListInstancesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListInstancesResponse listInstances(shared_ptr<ListInstancesRequest> request);
  ListInstancesOfUserResponse listInstancesOfUserWithOptions(shared_ptr<ListInstancesOfUserRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListInstancesOfUserResponse listInstancesOfUser(shared_ptr<ListInstancesOfUserRequest> request);
  ListIntervalAgentReportResponse listIntervalAgentReportWithOptions(shared_ptr<ListIntervalAgentReportRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListIntervalAgentReportResponse listIntervalAgentReport(shared_ptr<ListIntervalAgentReportRequest> request);
  ListIntervalInstanceReportResponse listIntervalInstanceReportWithOptions(shared_ptr<ListIntervalInstanceReportRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListIntervalInstanceReportResponse listIntervalInstanceReport(shared_ptr<ListIntervalInstanceReportRequest> request);
  ListIntervalSkillGroupReportResponse listIntervalSkillGroupReportWithOptions(shared_ptr<ListIntervalSkillGroupReportRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListIntervalSkillGroupReportResponse listIntervalSkillGroupReport(shared_ptr<ListIntervalSkillGroupReportRequest> request);
  ListIvrTrackingDetailsResponse listIvrTrackingDetailsWithOptions(shared_ptr<ListIvrTrackingDetailsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListIvrTrackingDetailsResponse listIvrTrackingDetails(shared_ptr<ListIvrTrackingDetailsRequest> request);
  ListLegacyAgentEventLogsResponse listLegacyAgentEventLogsWithOptions(shared_ptr<ListLegacyAgentEventLogsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListLegacyAgentEventLogsResponse listLegacyAgentEventLogs(shared_ptr<ListLegacyAgentEventLogsRequest> request);
  ListLegacyAgentStatusLogsResponse listLegacyAgentStatusLogsWithOptions(shared_ptr<ListLegacyAgentStatusLogsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListLegacyAgentStatusLogsResponse listLegacyAgentStatusLogs(shared_ptr<ListLegacyAgentStatusLogsRequest> request);
  ListLegacyAppraiseLogsResponse listLegacyAppraiseLogsWithOptions(shared_ptr<ListLegacyAppraiseLogsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListLegacyAppraiseLogsResponse listLegacyAppraiseLogs(shared_ptr<ListLegacyAppraiseLogsRequest> request);
  ListLegacyQueueEventLogsResponse listLegacyQueueEventLogsWithOptions(shared_ptr<ListLegacyQueueEventLogsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListLegacyQueueEventLogsResponse listLegacyQueueEventLogs(shared_ptr<ListLegacyQueueEventLogsRequest> request);
  ListMonoRecordingsResponse listMonoRecordingsWithOptions(shared_ptr<ListMonoRecordingsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListMonoRecordingsResponse listMonoRecordings(shared_ptr<ListMonoRecordingsRequest> request);
  ListMultiChannelRecordingsResponse listMultiChannelRecordingsWithOptions(shared_ptr<ListMultiChannelRecordingsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListMultiChannelRecordingsResponse listMultiChannelRecordings(shared_ptr<ListMultiChannelRecordingsRequest> request);
  ListOutboundNumbersOfUserResponse listOutboundNumbersOfUserWithOptions(shared_ptr<ListOutboundNumbersOfUserRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListOutboundNumbersOfUserResponse listOutboundNumbersOfUser(shared_ptr<ListOutboundNumbersOfUserRequest> request);
  ListPersonalNumbersOfUserResponse listPersonalNumbersOfUserWithOptions(shared_ptr<ListPersonalNumbersOfUserRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListPersonalNumbersOfUserResponse listPersonalNumbersOfUser(shared_ptr<ListPersonalNumbersOfUserRequest> request);
  ListPhoneNumbersResponse listPhoneNumbersWithOptions(shared_ptr<ListPhoneNumbersRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListPhoneNumbersResponse listPhoneNumbers(shared_ptr<ListPhoneNumbersRequest> request);
  ListPhoneNumbersOfSkillGroupResponse listPhoneNumbersOfSkillGroupWithOptions(shared_ptr<ListPhoneNumbersOfSkillGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListPhoneNumbersOfSkillGroupResponse listPhoneNumbersOfSkillGroup(shared_ptr<ListPhoneNumbersOfSkillGroupRequest> request);
  ListPrivilegesOfUserResponse listPrivilegesOfUserWithOptions(shared_ptr<ListPrivilegesOfUserRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListPrivilegesOfUserResponse listPrivilegesOfUser(shared_ptr<ListPrivilegesOfUserRequest> request);
  ListRamUsersResponse listRamUsersWithOptions(shared_ptr<ListRamUsersRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListRamUsersResponse listRamUsers(shared_ptr<ListRamUsersRequest> request);
  ListRealtimeAgentStatesResponse listRealtimeAgentStatesWithOptions(shared_ptr<ListRealtimeAgentStatesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListRealtimeAgentStatesResponse listRealtimeAgentStates(shared_ptr<ListRealtimeAgentStatesRequest> request);
  ListRealtimeSkillGroupStatesResponse listRealtimeSkillGroupStatesWithOptions(shared_ptr<ListRealtimeSkillGroupStatesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListRealtimeSkillGroupStatesResponse listRealtimeSkillGroupStates(shared_ptr<ListRealtimeSkillGroupStatesRequest> request);
  ListRecentCallDetailRecordsResponse listRecentCallDetailRecordsWithOptions(shared_ptr<ListRecentCallDetailRecordsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListRecentCallDetailRecordsResponse listRecentCallDetailRecords(shared_ptr<ListRecentCallDetailRecordsRequest> request);
  ListRolesResponse listRolesWithOptions(shared_ptr<ListRolesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListRolesResponse listRoles(shared_ptr<ListRolesRequest> request);
  ListSkillGroupStatesResponse listSkillGroupStatesWithOptions(shared_ptr<ListSkillGroupStatesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListSkillGroupStatesResponse listSkillGroupStates(shared_ptr<ListSkillGroupStatesRequest> request);
  ListSkillGroupSummaryReportsSinceMidnightResponse listSkillGroupSummaryReportsSinceMidnightWithOptions(shared_ptr<ListSkillGroupSummaryReportsSinceMidnightRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListSkillGroupSummaryReportsSinceMidnightResponse listSkillGroupSummaryReportsSinceMidnight(shared_ptr<ListSkillGroupSummaryReportsSinceMidnightRequest> request);
  ListSkillGroupsResponse listSkillGroupsWithOptions(shared_ptr<ListSkillGroupsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListSkillGroupsResponse listSkillGroups(shared_ptr<ListSkillGroupsRequest> request);
  ListSkillLevelsOfUserResponse listSkillLevelsOfUserWithOptions(shared_ptr<ListSkillLevelsOfUserRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListSkillLevelsOfUserResponse listSkillLevelsOfUser(shared_ptr<ListSkillLevelsOfUserRequest> request);
  ListUnassignedNumbersResponse listUnassignedNumbersWithOptions(shared_ptr<ListUnassignedNumbersRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListUnassignedNumbersResponse listUnassignedNumbers(shared_ptr<ListUnassignedNumbersRequest> request);
  ListUserLevelsOfSkillGroupResponse listUserLevelsOfSkillGroupWithOptions(shared_ptr<ListUserLevelsOfSkillGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListUserLevelsOfSkillGroupResponse listUserLevelsOfSkillGroup(shared_ptr<ListUserLevelsOfSkillGroupRequest> request);
  ListUsersResponse listUsersWithOptions(shared_ptr<ListUsersRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListUsersResponse listUsers(shared_ptr<ListUsersRequest> request);
  MakeCallResponse makeCallWithOptions(shared_ptr<MakeCallRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  MakeCallResponse makeCall(shared_ptr<MakeCallRequest> request);
  ModifyAudioFileResponse modifyAudioFileWithOptions(shared_ptr<ModifyAudioFileRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyAudioFileResponse modifyAudioFile(shared_ptr<ModifyAudioFileRequest> request);
  ModifyCustomCallTaggingResponse modifyCustomCallTaggingWithOptions(shared_ptr<ModifyCustomCallTaggingRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyCustomCallTaggingResponse modifyCustomCallTagging(shared_ptr<ModifyCustomCallTaggingRequest> request);
  ModifyInstanceResponse modifyInstanceWithOptions(shared_ptr<ModifyInstanceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyInstanceResponse modifyInstance(shared_ptr<ModifyInstanceRequest> request);
  ModifyPhoneNumberResponse modifyPhoneNumberWithOptions(shared_ptr<ModifyPhoneNumberRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyPhoneNumberResponse modifyPhoneNumber(shared_ptr<ModifyPhoneNumberRequest> request);
  ModifySkillGroupResponse modifySkillGroupWithOptions(shared_ptr<ModifySkillGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifySkillGroupResponse modifySkillGroup(shared_ptr<ModifySkillGroupRequest> request);
  ModifySkillLevelsOfUserResponse modifySkillLevelsOfUserWithOptions(shared_ptr<ModifySkillLevelsOfUserRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifySkillLevelsOfUserResponse modifySkillLevelsOfUser(shared_ptr<ModifySkillLevelsOfUserRequest> request);
  ModifyUserResponse modifyUserWithOptions(shared_ptr<ModifyUserRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyUserResponse modifyUser(shared_ptr<ModifyUserRequest> request);
  ModifyUserLevelsOfSkillGroupResponse modifyUserLevelsOfSkillGroupWithOptions(shared_ptr<ModifyUserLevelsOfSkillGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyUserLevelsOfSkillGroupResponse modifyUserLevelsOfSkillGroup(shared_ptr<ModifyUserLevelsOfSkillGroupRequest> request);
  MonitorCallResponse monitorCallWithOptions(shared_ptr<MonitorCallRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  MonitorCallResponse monitorCall(shared_ptr<MonitorCallRequest> request);
  MuteCallResponse muteCallWithOptions(shared_ptr<MuteCallRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  MuteCallResponse muteCall(shared_ptr<MuteCallRequest> request);
  PauseCampaignResponse pauseCampaignWithOptions(shared_ptr<PauseCampaignRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  PauseCampaignResponse pauseCampaign(shared_ptr<PauseCampaignRequest> request);
  PickOutboundNumbersResponse pickOutboundNumbersWithOptions(shared_ptr<PickOutboundNumbersRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  PickOutboundNumbersResponse pickOutboundNumbers(shared_ptr<PickOutboundNumbersRequest> request);
  PollUserStatusResponse pollUserStatusWithOptions(shared_ptr<PollUserStatusRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  PollUserStatusResponse pollUserStatus(shared_ptr<PollUserStatusRequest> request);
  ReadyForServiceResponse readyForServiceWithOptions(shared_ptr<ReadyForServiceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ReadyForServiceResponse readyForService(shared_ptr<ReadyForServiceRequest> request);
  RegisterDeviceResponse registerDeviceWithOptions(shared_ptr<RegisterDeviceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RegisterDeviceResponse registerDevice(shared_ptr<RegisterDeviceRequest> request);
  RegisterDevicesResponse registerDevicesWithOptions(shared_ptr<RegisterDevicesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RegisterDevicesResponse registerDevices(shared_ptr<RegisterDevicesRequest> request);
  ReleaseCallResponse releaseCallWithOptions(shared_ptr<ReleaseCallRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ReleaseCallResponse releaseCall(shared_ptr<ReleaseCallRequest> request);
  RemoveDoNotCallNumbersResponse removeDoNotCallNumbersWithOptions(shared_ptr<RemoveDoNotCallNumbersRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RemoveDoNotCallNumbersResponse removeDoNotCallNumbers(shared_ptr<RemoveDoNotCallNumbersRequest> request);
  RemovePersonalNumbersFromUserResponse removePersonalNumbersFromUserWithOptions(shared_ptr<RemovePersonalNumbersFromUserRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RemovePersonalNumbersFromUserResponse removePersonalNumbersFromUser(shared_ptr<RemovePersonalNumbersFromUserRequest> request);
  RemovePhoneNumberFromSkillGroupsResponse removePhoneNumberFromSkillGroupsWithOptions(shared_ptr<RemovePhoneNumberFromSkillGroupsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RemovePhoneNumberFromSkillGroupsResponse removePhoneNumberFromSkillGroups(shared_ptr<RemovePhoneNumberFromSkillGroupsRequest> request);
  RemovePhoneNumbersResponse removePhoneNumbersWithOptions(shared_ptr<RemovePhoneNumbersRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RemovePhoneNumbersResponse removePhoneNumbers(shared_ptr<RemovePhoneNumbersRequest> request);
  RemovePhoneNumbersFromSkillGroupResponse removePhoneNumbersFromSkillGroupWithOptions(shared_ptr<RemovePhoneNumbersFromSkillGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RemovePhoneNumbersFromSkillGroupResponse removePhoneNumbersFromSkillGroup(shared_ptr<RemovePhoneNumbersFromSkillGroupRequest> request);
  RemoveSkillGroupsFromUserResponse removeSkillGroupsFromUserWithOptions(shared_ptr<RemoveSkillGroupsFromUserRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RemoveSkillGroupsFromUserResponse removeSkillGroupsFromUser(shared_ptr<RemoveSkillGroupsFromUserRequest> request);
  RemoveUsersResponse removeUsersWithOptions(shared_ptr<RemoveUsersRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RemoveUsersResponse removeUsers(shared_ptr<RemoveUsersRequest> request);
  RemoveUsersFromSkillGroupResponse removeUsersFromSkillGroupWithOptions(shared_ptr<RemoveUsersFromSkillGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RemoveUsersFromSkillGroupResponse removeUsersFromSkillGroup(shared_ptr<RemoveUsersFromSkillGroupRequest> request);
  ResetAgentStateResponse resetAgentStateWithOptions(shared_ptr<ResetAgentStateRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ResetAgentStateResponse resetAgentState(shared_ptr<ResetAgentStateRequest> request);
  ResetUserPasswordResponse resetUserPasswordWithOptions(shared_ptr<ResetUserPasswordRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ResetUserPasswordResponse resetUserPassword(shared_ptr<ResetUserPasswordRequest> request);
  RestoreArchivedRecordingsResponse restoreArchivedRecordingsWithOptions(shared_ptr<RestoreArchivedRecordingsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RestoreArchivedRecordingsResponse restoreArchivedRecordings(shared_ptr<RestoreArchivedRecordingsRequest> request);
  ResumeCampaignResponse resumeCampaignWithOptions(shared_ptr<ResumeCampaignRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ResumeCampaignResponse resumeCampaign(shared_ptr<ResumeCampaignRequest> request);
  RetrieveCallResponse retrieveCallWithOptions(shared_ptr<RetrieveCallRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RetrieveCallResponse retrieveCall(shared_ptr<RetrieveCallRequest> request);
  SaveRTCStatsV2Response saveRTCStatsV2WithOptions(shared_ptr<SaveRTCStatsV2Request> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SaveRTCStatsV2Response saveRTCStatsV2(shared_ptr<SaveRTCStatsV2Request> request);
  SaveTerminalLogResponse saveTerminalLogWithOptions(shared_ptr<SaveTerminalLogRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SaveTerminalLogResponse saveTerminalLog(shared_ptr<SaveTerminalLogRequest> request);
  SaveWebRTCStatsResponse saveWebRTCStatsWithOptions(shared_ptr<SaveWebRTCStatsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SaveWebRTCStatsResponse saveWebRTCStats(shared_ptr<SaveWebRTCStatsRequest> request);
  SaveWebRtcInfoResponse saveWebRtcInfoWithOptions(shared_ptr<SaveWebRtcInfoRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SaveWebRtcInfoResponse saveWebRtcInfo(shared_ptr<SaveWebRtcInfoRequest> request);
  SendDtmfSignalingResponse sendDtmfSignalingWithOptions(shared_ptr<SendDtmfSignalingRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SendDtmfSignalingResponse sendDtmfSignaling(shared_ptr<SendDtmfSignalingRequest> request);
  SignInGroupResponse signInGroupWithOptions(shared_ptr<SignInGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SignInGroupResponse signInGroup(shared_ptr<SignInGroupRequest> request);
  SignOutGroupResponse signOutGroupWithOptions(shared_ptr<SignOutGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SignOutGroupResponse signOutGroup(shared_ptr<SignOutGroupRequest> request);
  StartBack2BackCallResponse startBack2BackCallWithOptions(shared_ptr<StartBack2BackCallRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  StartBack2BackCallResponse startBack2BackCall(shared_ptr<StartBack2BackCallRequest> request);
  StartConferenceResponse startConferenceWithOptions(shared_ptr<StartConferenceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  StartConferenceResponse startConference(shared_ptr<StartConferenceRequest> request);
  StartPredictiveCallResponse startPredictiveCallWithOptions(shared_ptr<StartPredictiveCallRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  StartPredictiveCallResponse startPredictiveCall(shared_ptr<StartPredictiveCallRequest> request);
  StartPrivacyCallResponse startPrivacyCallWithOptions(shared_ptr<StartPrivacyCallRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  StartPrivacyCallResponse startPrivacyCall(shared_ptr<StartPrivacyCallRequest> request);
  SubmitCampaignResponse submitCampaignWithOptions(shared_ptr<SubmitCampaignRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SubmitCampaignResponse submitCampaign(shared_ptr<SubmitCampaignRequest> request);
  SwitchToConferenceResponse switchToConferenceWithOptions(shared_ptr<SwitchToConferenceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SwitchToConferenceResponse switchToConference(shared_ptr<SwitchToConferenceRequest> request);
  TakeBreakResponse takeBreakWithOptions(shared_ptr<TakeBreakRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  TakeBreakResponse takeBreak(shared_ptr<TakeBreakRequest> request);
  UnmuteCallResponse unmuteCallWithOptions(shared_ptr<UnmuteCallRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UnmuteCallResponse unmuteCall(shared_ptr<UnmuteCallRequest> request);
  UnregisterDeviceResponse unregisterDeviceWithOptions(shared_ptr<UnregisterDeviceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UnregisterDeviceResponse unregisterDevice(shared_ptr<UnregisterDeviceRequest> request);
  UpdateConfigItemsResponse updateConfigItemsWithOptions(shared_ptr<UpdateConfigItemsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateConfigItemsResponse updateConfigItems(shared_ptr<UpdateConfigItemsRequest> request);

  virtual ~Client() = default;
};
} // namespace Alibabacloud_CCC20200701

#endif
